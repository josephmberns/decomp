`//FormAI DATASET v1.0 Category: Memory management ; Style: accurate
#include <stdio.h>
#include <stdlib.h>

void* memoryAllocation(size_t size) {
    void* ptr = malloc(size);
    if (ptr == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }
    printf("Allocated %zu bytes of memory at address: %p\n", size, ptr);
    return ptr;
}

void memoryDeallocation(void* ptr) {
    if (ptr == NULL) {
        printf("Can not free NULL pointer.\n");
        return;
    }
    printf("Deallocated memory at address: %p\n", ptr);
    free(ptr);
}

int main() {
    int* ptr1 = (int*) memoryAllocation(sizeof(int));
    *ptr1 = 10;
    printf("value of ptr1: %d\n", *ptr1);

    double* ptr2 = (double*) memoryAllocation(sizeof(double));
    *ptr2 = 3.14;
    printf("value of ptr2: %.2lf\n", *ptr2);

    // reallocation of memory
    ptr1 = (int*) realloc(ptr1, 2 * sizeof(int));
    if (ptr1 == NULL) {
        printf("Reallocation of memory failed.\n");
        exit(1);
    }
    printf("Reallocated memory at address: %p\n", ptr1);
    *(ptr1+1) = 20;
    printf("value of ptr1[1]: %d\n", *(ptr1+1));

    memoryDeallocation(ptr1);
    memoryDeallocation(ptr2);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall memoryAllocation(_QWORD); // weak
__int64 __fastcall memoryDeallocation(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001635) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _QWORD *v4; // [rsp+20h] [rbp-10h]
  unsigned int *Blocka; // [rsp+28h] [rbp-8h]
  _DWORD *Block; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  Blocka = (unsigned int *)memoryAllocation(4i64);
  *Blocka = 10;
  printf("value of ptr1: %d\n", *Blocka);
  v4 = (_QWORD *)memoryAllocation(8i64);
  *v4 = 0x40091EB851EB851Fi64;
  printf("value of ptr2: %.2lf\n", *v4);
  Block = realloc(Blocka, 8ui64);
  if ( !Block )
  {
    printf("Reallocation of memory failed.\n");
    exit(1);
  }
  printf("Reallocated memory at address: %p\n", Block);
  Block[1] = 20;
  printf("value of ptr1[1]: %d\n", (unsigned int)Block[1]);
  memoryDeallocation(Block);
  memoryDeallocation(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall memoryAllocation(_QWORD);
// 1400015EE: using guessed type __int64 __fastcall memoryDeallocation(_QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Random ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int i, n;
    double rand_num;

    // Seed the random number generator
    srand(time(0));

    // Prompt user for the number of random numbers to generate
    printf("How many random numbers do you want to generate? ");
    scanf("%d", &n);

    // Generate and print the random numbers
    printf("Here are your %d random numbers:\n", n);
    for(i=0; i<n; i++) {
        rand_num = ((double) rand() / (RAND_MAX)) * 1000; // Generate a random number between 0 and 1000
        printf("%.2f\n", rand_num);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-14h] BYREF
  double v6; // [rsp+30h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("How many random numbers do you want to generate? ");
  scanf("%d", &v5);
  printf("Here are your %d random numbers:\n", v5);
  for ( i = 0; i < (int)v5; ++i )
  {
    v6 = 1000.0 * ((double)rand() / 32767.0);
    printf("%.2f\n", v6);
  }
  return 0;
}
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Color Code Converter ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* hexToRgb(char*);
char* rgbToHex(char*);

int main() {
    char input[10];
    printf("Enter HEX or RGB color code: ");
    scanf("%s", input);

    char* result;
    if (input[0] == '#') {
        result = hexToRgb(input);
        printf("RGB code: %s", result);
    } else {
        result = rgbToHex(input);
        printf("HEX code: %s", result);
    }

    free(result);
    return 0;
}

char* hexToRgb(char* input) {
    char* output = malloc(sizeof(char) * 15);
    char hex[7];
    strncpy(hex, input + 1, 6);
    hex[6] = '\0';

    int r, g, b;
    sscanf(hex, "%02x%02x%02x", &r, &g, &b);
    sprintf(output, "%d,%d,%d", r, g, b);
    return output;
}

char* rgbToHex(char* input) {
    char* output = malloc(sizeof(char) * 8);
    int r, g, b;
    sscanf(input, "%d,%d,%d", &r, &g, &b);
    sprintf(output, "#%02x%02x%02x", r, g, b);
    return output;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall hexToRgb(_QWORD); // weak
__int64 __fastcall rgbToHex(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (0000000140001668) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[10]; // [rsp+2Eh] [rbp-12h] BYREF
  void *Block; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter HEX or RGB color code: ");
  scanf("%s", v4);
  if ( v4[0] == 35 )
  {
    Block = (void *)hexToRgb(v4);
    printf("RGB code: %s", (const char *)Block);
  }
  else
  {
    Block = (void *)rgbToHex(v4);
    printf("HEX code: %s", (const char *)Block);
  }
  free(Block);
  return 0;
}
// 140001707: using guessed type __int64 __fastcall hexToRgb(_QWORD);
// 14000179A: using guessed type __int64 __fastcall rgbToHex(_QWORD);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Time Travel Simulator ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

int main() {
    //initialize variables
    int current_year = 2021, target_year, travel_duration, elapsed_time = 0;
    bool traveling = true;
    
    //ask user for target year and travel duration
    printf("Welcome to Time Travel Simulator!\n");
    printf("What year would you like to travel to? (enter a year after 2021): ");
    scanf("%d", &target_year);
    printf("How many years would you like to travel for?: ");
    scanf("%d", &travel_duration);
    
    //initialize time variables
    time_t current_time;
    struct tm *time_info;
    char time_str[9];
    
    //get current time and print it
    time(&current_time);
    time_info = localtime(&current_time);
    strftime(time_str, sizeof(time_str), "%H:%M:%S", time_info);
    printf("Current time is: %s\n", time_str);
    
    //simulate time travel
    while (traveling) {
        //update current year and elapsed time
        current_year += 1;
        elapsed_time += 1;
        
        //check if target year is reached
        if (current_year == target_year) {
            traveling = false;
            printf("You have arrived in the year %d after traveling for %d years!\n", target_year, travel_duration);
        }

        //wait for 1 second to simulate time travel
        sleep(1);

        //print current year
        printf("Current year: %d\n", current_year);
    }
    
    //print total elapsed time
    printf("Total elapsed time: %d seconds\n", elapsed_time);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static struct tm *__cdecl localtime(const time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// size_t __cdecl strftime(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);


//----- (0000000140001620) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[9]; // [rsp+2Fh] [rbp-31h] BYREF
  time_t Time; // [rsp+38h] [rbp-28h] BYREF
  unsigned int v6; // [rsp+40h] [rbp-20h] BYREF
  unsigned int v7; // [rsp+44h] [rbp-1Ch] BYREF
  struct tm *Tm; // [rsp+48h] [rbp-18h]
  char v9; // [rsp+57h] [rbp-9h]
  unsigned int v10; // [rsp+58h] [rbp-8h]
  unsigned int v11; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v11 = 2021;
  v10 = 0;
  v9 = 1;
  printf("Welcome to Time Travel Simulator!\n");
  printf("What year would you like to travel to? (enter a year after 2021): ");
  scanf("%d", &v7);
  printf("How many years would you like to travel for?: ");
  scanf("%d", &v6);
  time(&Time);
  Tm = localtime(&Time);
  strftime(Buffer, 9ui64, "%H:%M:%S", Tm);
  printf("Current time is: %s\n", Buffer);
  while ( v9 )
  {
    ++v11;
    ++v10;
    if ( v11 == v7 )
    {
      v9 = 0;
      printf("You have arrived in the year %d after traveling for %d years!\n", v7, v6);
    }
    sleep(1i64);
    printf("Current year: %d\n", v11);
  }
  printf("Total elapsed time: %d seconds\n", v10);
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002870: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game of Life ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 20 // Number of rows in the world
#define COLS 40 // Number of columns in the world
#define GENERATIONS 100 // Number of generations to simulate

// Function to initialize the world randomly
void initializeWorld(int world[ROWS][COLS]) {
    srand(time(NULL)); // Seed the random number generator
    
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            world[i][j] = rand() % 2; // Set each cell to either 0 or 1 randomly
        }
    }
}

// Function to print the current state of the world
void printWorld(int world[ROWS][COLS]) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (world[i][j] == 0) {
                printf("-");
            } else {
                printf("*");
            }
        }
        printf("\n");
    }
    printf("\n");
}

// Function to simulate one generation of the world
void simulateGeneration(int world[ROWS][COLS]) {
    int newWorld[ROWS][COLS]; // Array to hold the next generation of the world
    
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            int neighbors = 0; // Number of living neighbors
            
            // Check the eight neighbors around the cell
            for (int x = i - 1; x <= i + 1; x++) {
                for (int y = j - 1; y <= j + 1; y++) {
                    if (x >= 0 && x < ROWS && y >= 0 && y < COLS && !(x == i && y == j)) {
                        neighbors += world[x][y];
                    }
                }
            }
            
            // Apply the rules of the game of life to determine the new state of the cell
            if (world[i][j] == 1 && neighbors < 2) {
                newWorld[i][j] = 0; // Cell dies from loneliness
            } else if (world[i][j] == 1 && (neighbors == 2 || neighbors == 3)) {
                newWorld[i][j] = 1; // Cell survives to the next generation
            } else if (world[i][j] == 1 && neighbors > 3) {
                newWorld[i][j] = 0; // Cell dies from overcrowding
            } else if (world[i][j] == 0 && neighbors == 3) {
                newWorld[i][j] = 1; // Cell is born from reproduction
            } else {
                newWorld[i][j] = world[i][j]; // Cell stays the same
            }
        }
    }
    
    // Copy the new world back into the old world
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            world[i][j] = newWorld[i][j];
        }
    }
}

int main() {
    int world[ROWS][COLS]; // Array to hold the current state of the world
    
    initializeWorld(world); // Initialize the world randomly
    
    for (int i = 0; i < GENERATIONS; i++) {
        printf("Generation %d:\n", i + 1);
        printWorld(world); // Print the current state of the world
        simulateGeneration(world); // Simulate one generation of the world
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall initializeWorld(_QWORD); // weak
__int64 __fastcall printWorld(_QWORD); // weak
__int64 __fastcall simulateGeneration(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001AC6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[3212]; // [rsp+20h] [rbp-60h] BYREF
  int i; // [rsp+CACh] [rbp+C2Ch]

  _main(argc, argv, envp);
  initializeWorld(v4);
  for ( i = 0; i <= 99; ++i )
  {
    printf("Generation %d:\n", (unsigned int)(i + 1));
    printWorld(v4);
    simulateGeneration(v4);
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall initializeWorld(_QWORD);
// 14000163F: using guessed type __int64 __fastcall printWorld(_QWORD);
// 1400016E0: using guessed type __int64 __fastcall simulateGeneration(_QWORD);
// 140001C00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text Summarizer ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

char* summarize(char* text, int summary_length);

int main(void) {
    char text[] = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.";
    
    char* summary = summarize(text, 50);
    
    printf("%s\n", summary);
    
    free(summary);
    
    return 0;
}

char* summarize(char* text, int summary_length) {
    char* summary = malloc(summary_length * sizeof(char));
    int i, j = 0, k, l;
    char c;
    
    for (i = 0; i < strlen(text) && j < summary_length; i++) {
        c = text[i];
        if (isspace(c)) {
            summary[j] = c;
            j++;
        } else if (isalpha(c) && (j == 0 || isspace(summary[j-1]))) {
            k = i;
            while (isalpha(text[k])) {
                k++;
            }
            l = k - i;
            if (j + l > summary_length) {
                l = summary_length - j;
            }
            strncat(summary, text + i, l);
            j += l;
            i = k - 1;
            continue;
        } else if (c == '.' || c == '!' || c == '?') {
            summary[j] = c;
            j++;
            break;
        }
    }
    summary[j] = '\0';
    
    return summary;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall summarize(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[456]; // [rsp+20h] [rbp-60h] BYREF
  void *Block; // [rsp+1E8h] [rbp+168h]

  _main(argc, argv, envp);
  strcpy(
    v4,
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna "
    "aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. "
    "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sin"
    "t occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.");
  Block = (void *)summarize(v4, 50i64);
  printf("%s\n", (const char *)Block);
  free(Block);
  return 0;
}
// 140001629: using guessed type __int64 __fastcall summarize(_QWORD, _QWORD);
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Error handling ; Style: optimized
// Custom error handling example program in C

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

void handle_error(int err_num);

int main() {
    int num1, num2;
    float result;
    char op;

    printf("Enter an arithmetic expression in the form 'num op num':\n");
    scanf("%d %c %d", &num1, &op, &num2);

    switch (op) {
        case '+':
            result = num1 + num2;
            printf("Result: %.2f", result);
            break;
        case '-':
            result = num1 - num2;
            printf("Result: %.2f", result);
            break;
        case '*':
            result = num1 * num2;
            printf("Result: %.2f", result);
            break;
        case '/':
            if (num2 == 0) {
                handle_error(EINVAL);
            } else {
                result = (float) num1 / num2;
                printf("Result: %.2f", result);
            }
            break;
        default:
            handle_error(EINVAL);
    }

    return 0;
}

void handle_error(int err_num) {
    switch (err_num) {
        case EINVAL:
            fprintf(stderr, "Invalid argument passed to function.\n");
            break;
        case ENOMEM:
            fprintf(stderr, "Insufficient memory to perform operation.\n");
            break;
        case EIO:
            fprintf(stderr, "Error occurred while performing an I/O operation.\n");
            break;
        default:
            fprintf(stderr, "Unknown error occurred.\n");
    }
    exit(EXIT_FAILURE);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
void __fastcall __noreturn handle_error(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+23h] [rbp-Dh] BYREF
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  int v6; // [rsp+28h] [rbp-8h] BYREF
  float v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter an arithmetic expression in the form 'num op num':\n");
  scanf("%d %c %d", &v6, &v4, &v5);
  if ( v4 == 47 )
  {
    if ( !v5 )
      handle_error(22i64);
    v7 = (float)v6 / (float)v5;
    printf("Result: %.2f", v7);
  }
  else
  {
    if ( v4 > 47 )
      goto LABEL_13;
    if ( v4 == 45 )
    {
      v7 = (float)(v6 - v5);
      printf("Result: %.2f", v7);
      return 0;
    }
    if ( v4 > 45 )
      goto LABEL_13;
    if ( v4 == 42 )
    {
      v7 = (float)(v6 * v5);
      printf("Result: %.2f", v7);
      return 0;
    }
    if ( v4 != 43 )
LABEL_13:
      handle_error(22i64);
    v7 = (float)(v6 + v5);
    printf("Result: %.2f", v7);
  }
  return 0;
}
// 1400017E3: using guessed type void __fastcall __noreturn handle_error(_QWORD);
// 140001950: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Compression algorithms ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define CHUNK_SIZE 1024

int compress(char* original, char* compressed);

int main()
{
    char* original = "Hello, world!";
    char* compressed = (char*)malloc(strlen(original) * sizeof(char));
    int size = compress(original, compressed);

    printf("Original size: %lu\n", strlen(original));
    printf("Compressed size: %d\n", size);

    return 0;
}

int compress(char* original, char* compressed)
{
    int original_size = strlen(original);
    int chunk_size, num_chunks;

    if(original_size < CHUNK_SIZE) {
        chunk_size = original_size;
        num_chunks = 1;
    } else {
        // Divide original into chunks of CHUNK_SIZE
        chunk_size = CHUNK_SIZE;
        num_chunks = ceil(original_size / (float)CHUNK_SIZE);
    }

    int* chunk_sizes = (int*)calloc(num_chunks, sizeof(int));
    char** chunks = (char**)malloc(num_chunks * sizeof(char*));

    // Divide original into chunks
    int i, j, k;
    for(i = 0, k = 0; i < num_chunks; i++, k += chunk_size) {
        if(i == num_chunks - 1) {
            chunk_size = original_size - k;
        }
        chunks[i] = (char*)malloc(chunk_size * sizeof(char));
        memcpy(chunks[i], &original[k], chunk_size * sizeof(char));
        chunk_sizes[i] = chunk_size;
    }

    // Compress each chunk with RLE
    int compressed_size = 0;
    for(i = 0; i < num_chunks; i++) {
        char* chunk = chunks[i];
        int size = chunk_sizes[i];
        char curr_char = chunk[0];
        int count = 1;

        for(j = 1; j < size; j++) {
            if(chunk[j] == curr_char) {
                count++;
            } else {
                // Write compressed data to compressed array
                compressed[compressed_size++] = curr_char;
                compressed[compressed_size++] = count;
                curr_char = chunk[j];
                count = 1;
            }
        }

        // Write final compressed data to compressed array
        compressed[compressed_size++] = curr_char;
        compressed[compressed_size++] = count;
    }

    // Free dynamically allocated memory
    for(i = 0; i < num_chunks; i++) {
        free(chunks[i]);
    }
    free(chunks);
    free(chunk_sizes);

    return compressed_size;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall compress(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void *__cdecl malloc(size_t Size);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  size_t v3; // rax
  void *v4; // rdx
  size_t v5; // rax
  unsigned int v7; // [rsp+2Ch] [rbp-14h]

  _main(argc, argv, envp);
  v3 = strlen("Hello, world!");
  v4 = malloc(v3);
  v7 = compress("Hello, world!", v4);
  v5 = strlen("Hello, world!");
  printf("Original size: %lu\n", v5);
  printf("Compressed size: %d\n", v7);
  return 0;
}
// 140001611: using guessed type __int64 __fastcall compress(_QWORD, _QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Music Library Management System ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct song {
  char title[50];
  char artist[50];
  char album[50];
  int track_number;
  int year;
};

void add_song(struct song s) {
  // This function adds a new song to the library
  printf("Adding song \"%s\" by %s to the library...\n", s.title, s.artist);
}

void list_songs() {
  // This function lists all the songs in the library
  printf("Listing all songs in the library...\n");
}

void search_songs(char* query) {
  // This function searches for songs in the library based on a given query
  printf("Searching for songs in the library with query \"%s\"...\n", query);
}

void delete_song(char* title) {
  // This function deletes a song from the library based on its title
  printf("Deleting song \"%s\" from the library...\n", title);
}

int main() {
  // Welcome message
  printf("Welcome to the Surrealist Music Library Management System!\n");
  printf("What would you like to do?\n");

  char input[50];

  // Main loop
  while (1) {
    printf("> ");
    fgets(input, 50, stdin);

    // Remove the newline character from the input
    input[strcspn(input, "\n")] = 0;
    
    // Check the input and act accordingly
    if (strcmp(input, "add") == 0) {
      struct song s;

      printf("Enter the title of the song: ");
      fgets(s.title, 50, stdin);
      s.title[strcspn(s.title, "\n")] = 0;

      printf("Enter the name of the artist: ");
      fgets(s.artist, 50, stdin);
      s.artist[strcspn(s.artist, "\n")] = 0;

      printf("Enter the name of the album: ");
      fgets(s.album, 50, stdin);
      s.album[strcspn(s.album, "\n")] = 0;

      printf("Enter the track number: ");
      scanf("%d", &s.track_number);

      printf("Enter the year of release: ");
      scanf("%d", &s.year);

      add_song(s);
    } else if (strcmp(input, "list") == 0) {
      list_songs();
    } else if (strcmp(input, "search") == 0) {
      char query[50];

      printf("Enter the search query: ");
      fgets(query, 50, stdin);
      query[strcspn(query, "\n")] = 0;

      search_songs(query);
    } else if (strcmp(input, "delete") == 0) {
      char title[50];

      printf("Enter the title of the song to delete: ");
      fgets(title, 50, stdin);
      title[strcspn(title, "\n")] = 0;

      delete_song(title);
    } else if (strcmp(input, "quit") == 0) {
      printf("Quitting...\n");
      break;
    } else {
      printf("I'm sorry, I don't understand. Please try again.\n");
    }
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_song(_QWORD); // weak
__int64 list_songs(void); // weak
__int64 __fastcall search_songs(_QWORD); // weak
__int64 __fastcall delete_song(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000167B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  FILE *v6; // rax
  FILE *v7; // rax
  FILE *v8; // rax
  __int64 v10[20]; // [rsp+20h] [rbp-60h] BYREF
  char Str[8]; // [rsp+C0h] [rbp+40h] BYREF
  __int64 v12; // [rsp+C8h] [rbp+48h]
  __int64 v13; // [rsp+D0h] [rbp+50h]
  __int64 v14; // [rsp+D8h] [rbp+58h]
  __int64 v15; // [rsp+E0h] [rbp+60h]
  __int64 v16; // [rsp+E8h] [rbp+68h]
  _QWORD v17[6]; // [rsp+F0h] [rbp+70h] BYREF
  _QWORD v18[7]; // [rsp+120h] [rbp+A0h] BYREF
  __int64 v19; // [rsp+158h] [rbp+D8h] BYREF
  char Buffer[64]; // [rsp+160h] [rbp+E0h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Surrealist Music Library Management System!\n");
  printf("What would you like to do?\n");
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            printf("> ");
            v3 = __acrt_iob_func(0);
            fgets(Buffer, 50, v3);
            Buffer[strcspn(Buffer, "\n")] = 0;
            if ( strcmp(Buffer, "add") )
              break;
            printf("Enter the title of the song: ");
            v4 = __acrt_iob_func(0);
            fgets(Str, 50, v4);
            Str[strcspn(Str, "\n")] = 0;
            printf("Enter the name of the artist: ");
            v5 = __acrt_iob_func(0);
            fgets((char *)v17 + 2, 50, v5);
            *((_BYTE *)v17 + strcspn((const char *)v17 + 2, "\n") + 2) = 0;
            printf("Enter the name of the album: ");
            v6 = __acrt_iob_func(0);
            fgets((char *)v18 + 4, 50, v6);
            *((_BYTE *)v18 + strcspn((const char *)v18 + 4, "\n") + 4) = 0;
            printf("Enter the track number: ");
            scanf("%d", &v19);
            printf("Enter the year of release: ");
            scanf("%d", (char *)&v19 + 4);
            v10[0] = *(_QWORD *)Str;
            v10[1] = v12;
            v10[2] = v13;
            v10[3] = v14;
            v10[4] = v15;
            v10[5] = v16;
            v10[6] = v17[0];
            v10[7] = v17[1];
            v10[8] = v17[2];
            v10[9] = v17[3];
            v10[10] = v17[4];
            v10[11] = v17[5];
            v10[12] = v18[0];
            v10[13] = v18[1];
            v10[14] = v18[2];
            v10[15] = v18[3];
            v10[16] = v18[4];
            v10[17] = v18[5];
            v10[18] = v18[6];
            v10[19] = v19;
            add_song(v10);
          }
          if ( strcmp(Buffer, "list") )
            break;
          list_songs();
        }
        if ( strcmp(Buffer, "search") )
          break;
        printf("Enter the search query: ");
        v7 = __acrt_iob_func(0);
        fgets(Str, 50, v7);
        Str[strcspn(Str, "\n")] = 0;
        search_songs(Str);
      }
      if ( strcmp(Buffer, "delete") )
        break;
      printf("Enter the title of the song to delete: ");
      v8 = __acrt_iob_func(0);
      fgets(Str, 50, v8);
      Str[strcspn(Str, "\n")] = 0;
      delete_song(Str);
    }
    if ( !strcmp(Buffer, "quit") )
      break;
    printf("I'm sorry, I don't understand. Please try again.\n");
  }
  printf("Quitting...\n");
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall add_song(_QWORD);
// 140001611: using guessed type __int64 list_songs(void);
// 14000162F: using guessed type __int64 __fastcall search_songs(_QWORD);
// 140001655: using guessed type __int64 __fastcall delete_song(_QWORD);
// 140001B60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000167B: using guessed type char Buffer[64];

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Physics simulation ; Style: Ada Lovelace
#include <stdio.h>
#include <math.h>

int main()
{
    // Define variables
    double position = 0.0;
    double velocity = 0.0;
    double acceleration = 9.81;
    double time = 0.0;
    
    // Prompt user for input
    printf("Enter the initial velocity of the object (m/s): ");
    scanf("%lf", &velocity);
    printf("Enter the initial position of the object (m): ");
    scanf("%lf", &position);
    
    // Create simulation loop
    while (position >= 0.0)
    {
        // Calculate time elapsed
        double delta_t = sqrt((2*position)/acceleration);
        
        // Update time and position
        time += delta_t;
        position = velocity*delta_t - 0.5*acceleration*pow(delta_t, 2);
        
        // Update velocity
        velocity = velocity - acceleration*delta_t;
        
        // Output results
        printf("Time: %.2lf s | Position: %.2lf m | Velocity: %.2lf m/s\n", time, position, velocity);
    }
    
    // Object has reached the ground
    printf("The object has reached the ground at time %.2lf seconds.", time);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl pow(double X, double Y);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm6_8
  double v4; // xmm7_8
  double v6; // [rsp+28h] [rbp-28h] BYREF
  double v7; // [rsp+30h] [rbp-20h] BYREF
  double X; // [rsp+38h] [rbp-18h]
  double v9; // [rsp+40h] [rbp-10h]
  double v10; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  v7 = 0.0;
  v6 = 0.0;
  v9 = 9.81;
  v10 = 0.0;
  printf("Enter the initial velocity of the object (m/s): ");
  scanf("%lf", &v6);
  printf("Enter the initial position of the object (m): ");
  scanf("%lf", &v7);
  while ( v7 >= 0.0 )
  {
    X = sqrt((v7 + v7) / v9);
    v10 = v10 + X;
    v3 = v6 * X;
    v4 = v9 * 0.5;
    v7 = v3 - v4 * pow(X, 2.0);
    v6 = v6 - v9 * X;
    printf("Time: %.2lf s | Position: %.2lf m | Velocity: %.2lf m/s\n", v10, v7, v6);
  }
  printf("The object has reached the ground at time %.2lf seconds.", v10);
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: RAM usage monitor ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>

int main() {

    int memory = 0;
    int *ptr = NULL;
    
    while(1) {
        ptr = malloc(sizeof(int)); // allocate memory
       
        if(ptr == NULL) { // out of memory
            printf("RAM USAGE MONITOR: You have used up all the available RAM.\n");
            printf("Please free up some memory and restart the program.\n");
            exit(0); // terminate program
        }
        
        memory += sizeof(int); // increment memory usage
        printf("RAM USAGE MONITOR: Current memory usage is %d bytes.\n", memory);
        free(ptr); // deallocate memory
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  void *Block; // [rsp+20h] [rbp-10h]
  unsigned int v4; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4 = 0;
  while ( 1 )
  {
    Block = malloc(4ui64);
    if ( !Block )
      break;
    v4 += 4;
    printf("RAM USAGE MONITOR: Current memory usage is %d bytes.\n", v4);
    free(Block);
  }
  printf("RAM USAGE MONITOR: You have used up all the available RAM.\n");
  printf("Please free up some memory and restart the program.\n");
  exit(0);
}
// 1400016D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Count Tool ; Style: introspective
#include <stdio.h>
#include <string.h>

// Function to count the number of words in a sentence
int countWords(char sentence[]) {
   int count = 0;
   int i;
   // Loop through each character in the sentence
   for (i = 0; i < strlen(sentence); i++) {
      // If there is a space or a newline character, increment the word count
      if (sentence[i] == ' ' || sentence[i] == '\n') {
         count++;
      }
   }
   // Add one to the count to account for the last word in the sentence
   count++;
   return count;
}

int main() {
   // Prompt the user to enter a sentence
   printf("Enter a sentence: ");
   // Declare an array to store the sentence and read it in from the user
   char sentence[1000];
   fgets(sentence, 1000, stdin);
   // Call the function to count the words in the sentence and store the result
   int wordCount = countWords(sentence);
   // Print out the result to the user
   printf("The sentence \"%s\" has %d words.\n", sentence, wordCount);
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall countWords(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001602) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1004]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v6; // [rsp+40Ch] [rbp+38Ch]

  _main(argc, argv, envp);
  printf("Enter a sentence: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v6 = countWords(Buffer);
  printf("The sentence \"%s\" has %d words.\n", Buffer, v6);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall countWords(_QWORD);
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: synchronous
#include <stdio.h>

int search(int arr[], int n, int x) {
    int i;
    for (i = 0; i < n; i++) {
        if (arr[i] == x)
            return i;
    }
    return -1;
}

int main() {
    int arr[] = {4, 7, 2, 9, 1, 5, 8, 3, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 2;
    int result = search(arr, n, x);
    if (result == -1)
        printf("Element is not present in array.\n");
    else
        printf("Element is present at index %d\n", result);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall search(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[9]; // [rsp+20h] [rbp-30h] BYREF
  unsigned int v5; // [rsp+44h] [rbp-Ch]
  int v6; // [rsp+48h] [rbp-8h]
  int v7; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 4;
  v4[1] = 7;
  v4[2] = 2;
  v4[3] = 9;
  v4[4] = 1;
  v4[5] = 5;
  v4[6] = 8;
  v4[7] = 3;
  v4[8] = 6;
  v7 = 9;
  v6 = 2;
  v5 = search(v4, 9i64, 2i64);
  if ( v5 == -1 )
    printf("Element is not present in array.\n");
  else
    printf("Element is present at index %d\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall search(_QWORD, _QWORD, _QWORD);
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Synchronizer ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>
#include <stdbool.h>

// Returns true if the file names are equal, false otherwise
bool file_names_equal(char* file_name1, char* file_name2) {
    if (strcmp(file_name1, file_name2) == 0) {
        return true;
    } else {
        return false;
    }
}

int main() {
    // Directory paths to synchronize
    char* directory1 = "dir1/";
    char* directory2 = "dir2/";

    // Open the directories
    DIR* dir1 = opendir(directory1);
    DIR* dir2 = opendir(directory2);

    // Ensure directories exist and can be opened
    if (dir1 == NULL) {
        printf("Could not open directory %s\n", directory1);
        return 1;
    }
    if (dir2 == NULL) {
        printf("Could not open directory %s\n", directory2);
        return 1;
    }

    // Loop through files in directory 1
    struct dirent* file_entry1;
    while ((file_entry1 = readdir(dir1)) != NULL) {
        // Ignore the current directory and parent directory entries
        if (strcmp(file_entry1->d_name, ".") != 0 && strcmp(file_entry1->d_name, "..") != 0) {
            // Loop through files in directory 2
            struct dirent* file_entry2;
            while ((file_entry2 = readdir(dir2)) != NULL) {
                // Ignore the current directory and parent directory entries
                if (strcmp(file_entry2->d_name, ".") != 0 && strcmp(file_entry2->d_name, "..") != 0) {
                    // Check if the file names are equal
                    if (file_names_equal(file_entry1->d_name, file_entry2->d_name)) {
                        // TODO: Check if the file contents are equal
                        // If the file names and contents are not equal, update the file in directory 2
                        printf("File %s is out of sync, updating...\n", file_entry2->d_name);
                    }
                }
            }
        }
    }

    // Close the directories
    closedir(dir1);
    closedir(dir2);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall file_names_equal(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall opendir(char *Path); // idb
__int64 __fastcall readdir(_QWORD); // weak
__int64 __fastcall closedir(void *Block); // idb
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (00000001400015C7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-30h]
  __int64 v5; // [rsp+28h] [rbp-28h]
  void *v6; // [rsp+30h] [rbp-20h]
  void *Block; // [rsp+38h] [rbp-18h]

  _main(argc, argv, envp);
  Block = (void *)opendir("dir1/");
  v6 = (void *)opendir("dir2/");
  if ( Block )
  {
    if ( v6 )
    {
      while ( 1 )
      {
        v5 = readdir(Block);
        if ( !v5 )
          break;
        if ( strcmp((const char *)(v5 + 8), ".") && strcmp((const char *)(v5 + 8), "..") )
        {
          while ( 1 )
          {
            v4 = readdir(v6);
            if ( !v4 )
              break;
            if ( strcmp((const char *)(v4 + 8), ".") && strcmp((const char *)(v4 + 8), "..") )
            {
              if ( (unsigned __int8)file_names_equal(v5 + 8, v4 + 8) )
                printf("File %s is out of sync, updating...\n", (const char *)(v4 + 8));
            }
          }
        }
      }
      closedir(Block);
      closedir(v6);
      return 0;
    }
    else
    {
      printf("Could not open directory %s\n", "dir2/");
      return 1;
    }
  }
  else
  {
    printf("Could not open directory %s\n", "dir1/");
    return 1;
  }
}
// 140001591: using guessed type __int64 __fastcall file_names_equal(_QWORD, _QWORD);
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002A80: using guessed type __int64 __fastcall readdir(_QWORD);

// nfuncs=152 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System boot optimizer ; Style: complete
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void printHeader()
{
    printf("\n********************************\n");
    printf("\tSystem Boot Optimizer\n");
    printf("********************************\n\n");
}

void optimizeBoot()
{
    // Method to optimize the boot process
    printf("Optimizing the boot process...\n\n");
    // Your optimization code goes here
}

int main()
{
    char password[10] = "pass1234";
    char input[10];

    printHeader();

    printf("Enter the password to optimize the boot process: ");
    fgets(input, 10, stdin);
    if (strcmp(input, password) == 0)
    {
        optimizeBoot();
        printf("Boot process optimized successfully.\n");
    }
    else
    {
        printf("Incorrect password. Boot process optimization aborted.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 printHeader(void); // weak
__int64 optimizeBoot(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015EB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[10]; // [rsp+2Ch] [rbp-14h] BYREF
  char Str2[10]; // [rsp+36h] [rbp-Ah] BYREF

  _main(argc, argv, envp);
  strcpy(Str2, "pass1234");
  Str2[9] = 0;
  printHeader();
  printf("Enter the password to optimize the boot process: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 10, v3);
  if ( !strcmp(Buffer, Str2) )
  {
    optimizeBoot();
    printf("Boot process optimized successfully.\n");
  }
  else
  {
    printf("Incorrect password. Boot process optimization aborted.\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 printHeader(void);
// 1400015CD: using guessed type __int64 optimizeBoot(void);
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Student {
    char name[50];
    int age;
    int marks;
};

void addStudent() {
    struct Student s;
    FILE *fp;
    fp = fopen("students.data", "ab");

    printf("Enter student name: ");
    scanf("%s", s.name);

    printf("Enter student age: ");
    scanf("%d", &s.age);

    printf("Enter student marks: ");
    scanf("%d", &s.marks);

    fwrite(&s, sizeof(struct Student), 1, fp);
    fclose(fp);

    printf("Student added successfully!\n");
}

void listStudents() {
    FILE *fp;
    struct Student s;

    fp = fopen("students.data", "rb");

    while (fread(&s, sizeof(struct Student), 1, fp)) {
        printf("Name: %s\n", s.name);
        printf("Age: %d\n", s.age);
        printf("Marks: %d\n", s.marks);
        printf("------------\n");
    }

    fclose(fp);
}

void searchStudent() {
    FILE *fp;
    struct Student s;
    char name[50];

    fp = fopen("students.data", "rb");
    printf("Enter student name: ");
    scanf("%s", name);

    while (fread(&s, sizeof(struct Student), 1, fp)) {
        if (strcmp(s.name, name) == 0) {
            printf("Name: %s\n", s.name);
            printf("Age: %d\n", s.age);
            printf("Marks: %d\n", s.marks);
            printf("------------\n");
        }
    }
    fclose(fp);
}

void deleteStudent() {
    FILE *fp, *temp;
    struct Student s;
    char name[50];
    int found = 0;

    fp = fopen("students.data", "rb");
    temp = fopen("temp.data", "wb");

    printf("Enter student name: ");
    scanf("%s", name);

    while (fread(&s, sizeof(struct Student), 1, fp)) {
        if (strcmp(s.name, name) != 0) {
            fwrite(&s, sizeof(struct Student), 1, temp);
        } else {
            found++;
            printf("Student deleted successfully!\n");
        }
    }
    fclose(fp);
    fclose(temp);

    if (found == 0) {
        printf("No student found with the name %s\n", name);
    }

    remove("students.data");
    rename("temp.data", "students.data");
}

int main() {
    int choice;

    while (1) {
        printf("1. Add student\n2. List all students\n3. Search student\n4. Delete student\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                addStudent();
                break;
            case 2:
                listStudents();
                break;
            case 3:
                searchStudent();
                break;
            case 4:
                deleteStudent();
                break;
            case 5:
                exit(0);
            default:
                printf("Invalid choice. Please select from the available options.\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 addStudent(void); // weak
__int64 listStudents(void); // weak
__int64 searchStudent(void); // weak
__int64 deleteStudent(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400019A7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    printf("1. Add student\n2. List all students\n3. Search student\n4. Delete student\n5. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        addStudent();
        break;
      case 2:
        listStudents();
        break;
      case 3:
        searchStudent();
        break;
      case 4:
        deleteStudent();
        break;
      case 5:
        exit(0);
      default:
        printf("Invalid choice. Please select from the available options.\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 addStudent(void);
// 1400016BE: using guessed type __int64 listStudents(void);
// 140001768: using guessed type __int64 searchStudent(void);
// 14000185B: using guessed type __int64 deleteStudent(void);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Product Inventory System ; Style: safe
#include <stdio.h>
#include <string.h>

#define MAX_PRODUCTS 100     // Maximum number of products that can be stored
#define MAX_NAME_LENGTH 50   // Maximum length of product name
#define MAX_CATEGORY_LENGTH 20  // Maximum length of category name
#define MAX_LOCATION_LENGTH 20  // Maximum length of storage location name

// Struct to hold information about a single product
typedef struct {
    int id;                    // Unique id of the product
    char name[MAX_NAME_LENGTH];    // Name of the product
    char category[MAX_CATEGORY_LENGTH];      // Category of the product
    char location[MAX_LOCATION_LENGTH];      // Storage location of the product
    int quantity;              // Quantity of the product
    float price;               // Price of the product
} Product;

// Function declarations
void initialize(Product *inventory, int *size);
void addProduct(Product *inventory, int *size);
void removeProduct(Product *inventory, int *size);
void displayProductInventory(Product *inventory, int size);
void showMenu();

// Main function
int main() {
    Product inventory[MAX_PRODUCTS];   // Array to hold product information
    int numProducts = 0;         // Number of products in the array
    int choice;                  // User's menu choice

    // Initialize the product inventory with default values
    initialize(inventory, &numProducts);

    do {
        // Display the menu and get the user's choice
        showMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);

        // Perform the appropriate action based on the user's choice
        switch (choice) {
            case 1:
                addProduct(inventory, &numProducts);
                break;
            case 2:
                removeProduct(inventory, &numProducts);
                break;
            case 3:
                displayProductInventory(inventory, numProducts);
                break;
            case 4:
                printf("Goodbye!\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    } while (choice != 4);

    return 0;
}

// Function to initialize the product inventory with default values
void initialize(Product *inventory, int *size) {
    *size = 4;

    inventory[0].id = 1;
    strcpy(inventory[0].name, "Watch");
    strcpy(inventory[0].category, "Accessories");
    strcpy(inventory[0].location, "Shelf 1");
    inventory[0].quantity = 10;
    inventory[0].price = 50.0;

    inventory[1].id = 2;
    strcpy(inventory[1].name, "T-shirt");
    strcpy(inventory[1].category, "Clothing");
    strcpy(inventory[1].location, "Rack 1");
    inventory[1].quantity = 20;
    inventory[1].price = 25.0;

    inventory[2].id = 3;
    strcpy(inventory[2].name, "Laptop");
    strcpy(inventory[2].category, "Electronics");
    strcpy(inventory[2].location, "Counter");
    inventory[2].quantity = 5;
    inventory[2].price = 1000.0;

    inventory[3].id = 4;
    strcpy(inventory[3].name, "Jeans");
    strcpy(inventory[3].category, "Clothing");
    strcpy(inventory[3].location, "Rack 2");
    inventory[3].quantity = 15;
    inventory[3].price = 50.0;
}

// Function to add a product to the inventory
void addProduct(Product *inventory, int *size) {
    Product newProduct;
    int idExists = 0;
    int id;

    // Get input from the user for the new product
    printf("Enter the name of the product: ");
    scanf("%s", newProduct.name);

    printf("Enter the category of the product: ");
    scanf("%s", newProduct.category);

    printf("Enter the storage location of the product: ");
    scanf("%s", newProduct.location);

    printf("Enter the quantity of the product: ");
    scanf("%d", &newProduct.quantity);

    printf("Enter the price of the product: ");
    scanf("%f", &newProduct.price);

    // Generate a unique id for the new product
    do {
        printf("Enter a unique id for the product: ");
        scanf("%d", &id);

        // Check if the id already exists in the inventory
        for (int i = 0; i < *size; i++) {
            if (inventory[i].id == id) {
                printf("Error: id already exists in inventory, please choose a different id.\n");
                idExists = 1;
                break;
            }
        }
    } while (idExists);

    // Assign the generated id to the new product
    newProduct.id = id;

    // Add the new product to the inventory
    inventory[*size] = newProduct;
    (*size)++;

    printf("Product added to inventory successfully!\n");
}

// Function to remove a product from the inventory
void removeProduct(Product *inventory, int *size) {
    int id, index, found = 0;

    // Get input from the user for the product to be removed
    printf("Enter the id of the product to be removed: ");
    scanf("%d", &id);

    // Search for the product in the inventory and get its index
    for (int i = 0; i < *size; i++) {
        if (inventory[i].id == id) {
            index = i;
            found = 1;
            break;
        }
    }

    // If the product is found, remove it from the inventory
    if (found) {
        for (int i = index; i < (*size - 1); i++) {
            inventory[i] = inventory[i + 1];
        }
        (*size)--;
        printf("Product removed from inventory successfully!\n");
    } else {
        printf("Error: product with id %d not found in inventory.\n", id);
    }
}

// Function to display the product inventory
void displayProductInventory(Product *inventory, int size) {
    printf("Product Inventory:\n");
    printf("ID\tName\t\tCategory\tLocation\tQuantity\tPrice\n");
    for (int i = 0; i < size; i++) {
        printf("%d\t%s\t\t%s\t\t%s\t\t%d\t\t%.2f\n", inventory[i].id, inventory[i].name,
             inventory[i].category, inventory[i].location, inventory[i].quantity, inventory[i].price);
    }
}

// Function to display the menu of options
void showMenu() {
    printf("\nProduct Inventory System\n");
    printf("------------------------\n");
    printf("1. Add a new product\n");
    printf("2. Remove a product\n");
    printf("3. Display inventory\n");
    printf("4. Quit\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall initialize(_QWORD, _QWORD); // weak
__int64 __fastcall addProduct(_QWORD, _QWORD); // weak
__int64 __fastcall removeProduct(_QWORD, _QWORD); // weak
__int64 __fastcall displayProductInventory(_QWORD, _QWORD); // weak
__int64 showMenu(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[10400]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  initialize(v6, &v5);
  do
  {
    showMenu();
    printf("Enter your choice: ");
    scanf("%d", &v4);
    if ( v4 == 4 )
    {
      printf("Goodbye!\n");
    }
    else
    {
      if ( v4 <= 4 )
      {
        switch ( v4 )
        {
          case 3:
            displayProductInventory(v6, v5);
            continue;
          case 1:
            addProduct(v6, &v5);
            continue;
          case 2:
            removeProduct(v6, &v5);
            continue;
        }
      }
      printf("Invalid choice, please try again.\n");
    }
  }
  while ( v4 != 4 );
  return 0;
}
// 140001653: conditional instruction was optimized away because %var_28A8.4<3
// 1400016D0: using guessed type __int64 __fastcall initialize(_QWORD, _QWORD);
// 1400018F0: using guessed type __int64 __fastcall addProduct(_QWORD, _QWORD);
// 140001B26: using guessed type __int64 __fastcall removeProduct(_QWORD, _QWORD);
// 140001CD1: using guessed type __int64 __fastcall displayProductInventory(_QWORD, _QWORD);
// 140001E37: using guessed type __int64 showMenu(void);
// 140001F50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>

#define MAX_NUM 1000000

int main()
{
    bool is_prime[MAX_NUM];
    int i, j, n;

    // Initialize all numbers as prime
    for (i = 2; i < MAX_NUM; i++) {
        is_prime[i] = true;
    }

    // Sieve of Eratosthenes algorithm to mark non-primes
    for (i = 2; i <= sqrt(MAX_NUM); i++) {
        if (is_prime[i]) {
            for (j = i*i; j < MAX_NUM; j += i) {
                is_prime[j] = false;
            }
        }
    }

    // Print all prime numbers
    n = 0;
    for (i = 2; i < MAX_NUM; i++) {
        if (is_prime[i]) {
            printf("%d ", i);
            n++;
            if (n % 10 == 0) {
                printf("\n");
            }
        }
    }
    printf("\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[1000004]; // [rsp+20h] [rbp-60h]
  int v5; // [rsp+F4264h] [rbp+F41E4h]
  int j; // [rsp+F4268h] [rbp+F41E8h]
  int i; // [rsp+F426Ch] [rbp+F41ECh]

  _main(argc, argv, envp);
  for ( i = 2; i <= 999999; ++i )
    v4[i] = 1;
  for ( i = 2; i <= 1000; ++i )
  {
    if ( v4[i] )
    {
      for ( j = i * i; j <= 999999; j += i )
        v4[j] = 0;
    }
  }
  v5 = 0;
  for ( i = 2; i <= 999999; ++i )
  {
    if ( v4[i] )
    {
      printf("%d ", (unsigned int)i);
      if ( !(++v5 % 10) )
        printf("\n");
    }
  }
  printf("\n");
  return 0;
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char var_F4250[1000004];

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/*Function to generate a random number within the given range*/
int generate_random_number(int min, int max) {
    int num = (rand() % (max - min + 1)) + min;
    return num;
}

/*Main program*/
int main() {
    int num;
    int guess;
    int attempts = 0;
    int max_attempts = 10;
    int min = 1;
    int max = 100;

    /*Seed the random number generator*/
    srand(time(0));

    /*Generate a random number for the player to guess*/
    num = generate_random_number(min, max);

    /*Keep asking for guesses until the player guesses correctly or runs out of attempts*/
    while (1) {
        printf("Guess the number between %d and %d:\n", min, max);
        scanf("%d", &guess);

        attempts++;

        if (guess == num) {
            printf("Congratulations! You guessed the number in %d attempts.\n", attempts);
            break;
        } else if (attempts == max_attempts) {
            printf("Sorry, you have run out of attempts. The number was %d.\n", num);
            break;
        } else if (guess < num) {
            printf("Too low! Guess again.\n");
        } else if (guess > num) {
            printf("Too high! Guess again.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall generate_random_number(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001631) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+28h] [rbp-18h] BYREF
  int random_number; // [rsp+2Ch] [rbp-14h]
  unsigned int v7; // [rsp+30h] [rbp-10h]
  unsigned int v8; // [rsp+34h] [rbp-Ch]
  int v9; // [rsp+38h] [rbp-8h]
  unsigned int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 0;
  v9 = 10;
  v8 = 1;
  v7 = 100;
  v3 = time(0i64);
  srand(v3);
  random_number = generate_random_number(1i64, 100i64);
  while ( 1 )
  {
    printf("Guess the number between %d and %d:\n", v8, v7);
    scanf("%d", &v5);
    ++v10;
    if ( random_number == v5 )
    {
      printf("Congratulations! You guessed the number in %d attempts.\n", v10);
      return 0;
    }
    if ( v10 == v9 )
      break;
    if ( random_number <= v5 )
    {
      if ( random_number < v5 )
        printf("Too high! Guess again.\n");
    }
    else
    {
      printf("Too low! Guess again.\n");
    }
  }
  printf("Sorry, you have run out of attempts. The number was %d.\n", (unsigned int)random_number);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall generate_random_number(_QWORD, _QWORD);
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>

// Define the maximum number of circuits and circuit elements allowed
#define MAX_NUM_CIRCUITS 10
#define MAX_NUM_ELEMENTS 100

// Define the circuit element struct
typedef struct CircuitElement {
    int fromNode;
    int toNode;
    float resistance;
    float capacitance;
    float inductance;
} CircuitElement;

// Define the circuit struct
typedef struct Circuit {
    int numElements;
    CircuitElement elements[MAX_NUM_ELEMENTS];
} Circuit;

int main() {
    Circuit circuits[MAX_NUM_CIRCUITS];
    int numCircuits = 0;

    // Take input for the circuit
    printf("Enter the number of circuits you want to simulate: ");
    scanf("%d", &numCircuits);

    // Take input for each circuit's element values
    for (int i = 0; i < numCircuits; i++) {
        printf("Enter the number of elements for circuit %d: ", i+1);
        scanf("%d", &circuits[i].numElements);

        for (int j = 0; j < circuits[i].numElements; j++) {
            printf("Enter values for element %d\n", j+1);

            printf("From node: ");
            scanf("%d", &circuits[i].elements[j].fromNode);

            printf("To node: ");
            scanf("%d", &circuits[i].elements[j].toNode);

            printf("Resistance: ");
            scanf("%f", &circuits[i].elements[j].resistance);

            printf("Capacitance: ");
            scanf("%f", &circuits[i].elements[j].capacitance);

            printf("Inductance: ");
            scanf("%f", &circuits[i].elements[j].inductance);
        }

        printf("Circuit %d input ended.\n", i+1);
    }

    // Print the circuit information
    for (int i = 0; i < numCircuits; i++) {
        printf("Circuit %d:\n", i+1);

        for (int j = 0; j < circuits[i].numElements; j++) {
            printf("Element %d: From Node=%d To Node=%d Resistance=%f Capacitance=%f Inductance=%f\n", 
                j+1, circuits[i].elements[j].fromNode, circuits[i].elements[j].toNode,
                circuits[i].elements[j].resistance, circuits[i].elements[j].capacitance, circuits[i].elements[j].inductance);
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[13]; // [rsp+4Ch] [rbp-34h] BYREF
  _BYTE v5[20000]; // [rsp+80h] [rbp+0h] BYREF
  int m; // [rsp+4EA0h] [rbp+4E20h]
  int k; // [rsp+4EA4h] [rbp+4E24h]
  int j; // [rsp+4EA8h] [rbp+4E28h]
  int i; // [rsp+4EACh] [rbp+4E2Ch]

  _main(argc, argv, envp);
  v4[0] = 0;
  printf("Enter the number of circuits you want to simulate: ");
  scanf("%d", v4);
  for ( i = 0; i < v4[0]; ++i )
  {
    printf("Enter the number of elements for circuit %d: ", (unsigned int)(i + 1));
    scanf("%d", &v4[501 * i + 1]);
    for ( j = 0; j < *(_DWORD *)&v5[2004 * i - 48]; ++j )
    {
      printf("Enter values for element %d\n", (unsigned int)(j + 1));
      printf("From node: ");
      scanf("%d", &v4[501 * i + 2 + 5 * j]);
      printf("To node: ");
      scanf("%d", &v4[501 * i + 3 + 5 * j]);
      printf("Resistance: ");
      scanf("%f", &v4[501 * i + 4 + 5 * j]);
      printf("Capacitance: ");
      scanf("%f", &v4[501 * i + 5 + 5 * j]);
      printf("Inductance: ");
      scanf("%f", &v4[501 * i + 6 + 5 * j]);
    }
    printf("Circuit %d input ended.\n", (unsigned int)(i + 1));
  }
  for ( k = 0; k < v4[0]; ++k )
  {
    printf("Circuit %d:\n", (unsigned int)(k + 1));
    for ( m = 0; m < *(_DWORD *)&v5[2004 * k - 48]; ++m )
      printf(
        "Element %d: From Node=%d To Node=%d Resistance=%f Capacitance=%f Inductance=%f\n",
        (unsigned int)(m + 1),
        *(unsigned int *)&v5[2004 * k - 44 + 20 * m],
        *(unsigned int *)&v5[2004 * k - 40 + 20 * m],
        *(float *)&v5[2004 * k - 36 + 20 * m],
        *(float *)&v5[2004 * k - 32 + 20 * m],
        *(float *)&v5[2004 * k - 28 + 20 * m]);
  }
  return 0;
}
// 140001B80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Arithmetic ; Style: minimalist
#include<stdio.h>

int main() {
  // Declare variables
  int num1, num2, result, choice;

  // Display menu options
  printf("MENU OPTIONS: \n");
  printf("1. Add\n");
  printf("2. Subtract\n");
  printf("3. Multiply\n");
  printf("4. Divide\n");
  printf("Enter your choice: ");

  // Take input for choice
  scanf("%d", &choice);

  // Prompt for input of two numbers
  printf("Enter two numbers: ");
  scanf("%d %d", &num1, &num2);

  // Perform operation based on choice
  switch(choice) {
    case 1:
      result = num1 + num2;
      printf("Addition of %d and %d is: %d\n", num1, num2, result);
      break;
    case 2:
      result = num1 - num2;
      printf("Subtraction of %d from %d is: %d\n", num2, num1, result);
      break;
    case 3:
      result = num1 * num2;
      printf("Multiplication of %d and %d is: %d\n", num1, num2, result);
      break;
    case 4:
      result = num1 / num2;
      printf("Division of %d by %d is: %d\n", num1, num2, result);
      break;
    default:
      printf("Invalid choice!\n");
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v5; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int v6; // [rsp+28h] [rbp-8h] BYREF
  int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("MENU OPTIONS: \n");
  printf("1. Add\n");
  printf("2. Subtract\n");
  printf("3. Multiply\n");
  printf("4. Divide\n");
  printf("Enter your choice: ");
  scanf("%d", &v4);
  printf("Enter two numbers: ");
  scanf("%d %d", &v6, &v5);
  if ( v4 == 4 )
  {
    v7 = (int)v6 / (int)v5;
    printf("Division of %d by %d is: %d\n", v6, v5, (unsigned int)((int)v6 / (int)v5));
  }
  else
  {
    if ( v4 > 4 )
    {
LABEL_11:
      printf("Invalid choice!\n");
      return 0;
    }
    switch ( v4 )
    {
      case 3:
        v7 = v6 * v5;
        printf("Multiplication of %d and %d is: %d\n", v6, v5, v6 * v5);
        break;
      case 1:
        v7 = v6 + v5;
        printf("Addition of %d and %d is: %d\n", v6, v5, v6 + v5);
        break;
      case 2:
        v7 = v6 - v5;
        printf("Subtraction of %d from %d is: %d\n", v5, v6, v6 - v5);
        break;
      default:
        goto LABEL_11;
    }
  }
  return 0;
}
// 1400016A8: conditional instruction was optimized away because %var_10.4<3
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bingo Simulator ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 5
#define COLS 5
#define RANGE 75

int main()
{
    int card[ROWS][COLS];
    int i, j, count = 0, num, win = 0;
    char choice;
    srand(time(0));
    
    // Initialize all elements with 0
    for(i=0; i<ROWS; i++)
    {
        for(j=0; j<COLS; j++)
        {
            card[i][j] = 0;
        }
    }
    
    // Generate random numbers for card
    while(count < RANGE)
    {
        num = rand() % RANGE + 1;
        for(i=0; i<ROWS; i++)
        {
            for(j=0; j<COLS; j++)
            {
                if(card[i][j] == num)
                {
                    num = rand() % RANGE + 1;
                    i = -1;
                    break;
                }
            }
        }
        card[count/COLS][count%COLS] = num;
        count++;
    }
    
    // Display the card
    printf("Welcome to C Bingo Simulator!\n");
    printf("Your card is:\n");
    for(i=0; i<ROWS; i++)
    {
        for(j=0; j<COLS; j++)
        {
            printf("%2d ", card[i][j]);
        }
        printf("\n");
    }
    
    // Ask user to start the game
    printf("Press any key to start the game...\n");
    getchar();
    
    // Start the game
    while(win == 0)
    {
        num = rand() % RANGE + 1;
        printf("The number called is: %d\n", num);
        for(i=0; i<ROWS; i++)
        {
            for(j=0; j<COLS; j++)
            {
                if(card[i][j] == num)
                {
                    card[i][j] = 0;
                }
            }
        }
        // Check for win
        for(i=0; i<ROWS; i++)
        {
            if(card[i][0] == 0 && card[i][1] == 0 && card[i][2] == 0 && card[i][3] == 0 && card[i][4] == 0)
            {
                win = 1;
                printf("Congratulations! You have won the game!\n");
                break;
            }
            if(card[0][i] == 0 && card[1][i] == 0 && card[2][i] == 0 && card[3][i] == 0 && card[4][i] == 0)
            {
                win = 1;
                printf("Congratulations! You have won the game!\n");
                break;
            }
        }
        if(card[0][0] == 0 && card[1][1] == 0 && card[2][2] == 0 && card[3][3] == 0 && card[4][4] == 0)
        {
            win = 1;
            printf("Congratulations! You have won the game!\n");
            break;
        }
        if(card[4][0] == 0 && card[3][1] == 0 && card[2][2] == 0 && card[1][3] == 0 && card[0][4] == 0)
        {
            win = 1;
            printf("Congratulations! You have won the game!\n");
            break;
        }
        // Ask user to continue playing
        printf("Do you want to continue? (Y/N): ");
        scanf("%c", &choice);
        if(choice == 'n' || choice == 'N')
        {
            printf("Thanks for playing!\n");
            break;
        }
        fflush(stdin);
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();
// int __cdecl fflush(FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  FILE *v4; // rax
  char v6; // [rsp+2Fh] [rbp-81h] BYREF
  int v7[4]; // [rsp+30h] [rbp-80h]
  int v8[8]; // [rsp+40h] [rbp-70h]
  int v9; // [rsp+60h] [rbp-50h]
  int v10; // [rsp+70h] [rbp-40h]
  int v11; // [rsp+78h] [rbp-38h]
  int v12; // [rsp+80h] [rbp-30h]
  int v13; // [rsp+90h] [rbp-20h]
  int v14; // [rsp+9Ch] [rbp-14h]
  unsigned int v15; // [rsp+A0h] [rbp-10h]
  int v16; // [rsp+A4h] [rbp-Ch]
  int j; // [rsp+A8h] [rbp-8h]
  int i; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v16 = 0;
  v14 = 0;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 4; ++i )
  {
    for ( j = 0; j <= 4; ++j )
      v7[5 * i + j] = 0;
  }
  while ( v16 <= 74 )
  {
    v15 = rand() % 75 + 1;
    for ( i = 0; i <= 4; ++i )
    {
      for ( j = 0; j <= 4; ++j )
      {
        if ( v15 == v7[5 * i + j] )
        {
          v15 = rand() % 75 + 1;
          i = -1;
          break;
        }
      }
    }
    v7[5 * (v16 / 5) + v16 % 5] = v15;
    ++v16;
  }
  printf("Welcome to C Bingo Simulator!\n");
  printf("Your card is:\n");
  for ( i = 0; i <= 4; ++i )
  {
    for ( j = 0; j <= 4; ++j )
      printf("%2d ", (unsigned int)v7[5 * i + j]);
    printf("\n");
  }
  printf("Press any key to start the game...\n");
  getchar();
  while ( !v14 )
  {
    v15 = rand() % 75 + 1;
    printf("The number called is: %d\n", v15);
    for ( i = 0; i <= 4; ++i )
    {
      for ( j = 0; j <= 4; ++j )
      {
        if ( v15 == v7[5 * i + j] )
          v7[5 * i + j] = 0;
      }
    }
    for ( i = 0; i <= 4; ++i )
    {
      if ( !v7[5 * i] && !v7[5 * i + 1] && !v7[5 * i + 2] && !v7[5 * i + 3] && !v8[5 * i]
        || !v7[i] && !v7[i + 5] && !v7[i + 10] && !v7[i + 15] && !v7[i + 20] )
      {
        v14 = 1;
        printf("Congratulations! You have won the game!\n");
        break;
      }
    }
    if ( !v7[0] && !v8[2] && !v9 && !v11 && !v13 || !v12 && !v10 && !v9 && !v8[4] && !v8[0] )
    {
      v14 = 1;
      printf("Congratulations! You have won the game!\n");
      return 0;
    }
    printf("Do you want to continue? (Y/N): ");
    scanf("%c", &v6);
    if ( v6 == 110 || v6 == 78 )
    {
      printf("Thanks for playing!\n");
      return 0;
    }
    v4 = __acrt_iob_func(0);
    fflush(v4);
  }
  return 0;
}
// 140001BC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: Linus Torvalds
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<time.h>

#define MAX_FLOORS 10
#define MAX_PASSENGERS 15

// Define the structure for elevator
typedef struct {
    int current_floor;
    int passengers;
    int direction; // 1 for up, -1 for down, 0 for idle
    int dest_floor[MAX_FLOORS];
    int dest_count;
} Elevator;

// Define the structure for passenger
typedef struct {
    int current_floor;
    int dest_floor;
    int id;
} Passenger;

// Define the function to move the elevator
void move_elevator(Elevator *elevator, int floor) {
    elevator -> current_floor = floor;
    printf("Elevator reached floor %d\n", floor);
    int i, temp_dest_floor[MAX_FLOORS], count=0;
    for(i=0; i<elevator->dest_count; i++) {
        if(floor == elevator->dest_floor[i]) {
            printf("Passenger %d exited on floor %d\n", elevator->passengers, floor);
            elevator->passengers--;
        } else {
            temp_dest_floor[count++] = elevator->dest_floor[i];
        }
    }
    if(count<elevator->dest_count) {
        elevator->dest_count = count;
        for(i=0; i<count; i++) {
            elevator->dest_floor[i] = temp_dest_floor[i];
        }
    }
    if(elevator->direction == 1) { // Going up
        if(floor == MAX_FLOORS) {
            elevator->direction = -1; // Change direction when elevator reaches last floor
        } else if(count > 0 && elevator->dest_floor[0]>floor) { // Any passengers going up?
            return;
        } else { // Otherwise, go to next upper floor
            move_elevator(elevator, floor+1);
        }
    } else if(elevator->direction == -1) { // Going down
        if(floor == 1) {
            elevator->direction = 1; // Change direction when elevator reaches first floor
        } else if(count > 0 && elevator->dest_floor[0]<floor) { // Any passengers going down?
            return;
        } else { // Otherwise, go to next lower floor
            move_elevator(elevator, floor-1);
        }
    } else { // Elevator is idle
        if(count > 0) {
            elevator->direction = (elevator->dest_floor[0]>floor ? 1 : -1); // Set direction based on first passenger's destination
            move_elevator(elevator, floor+(elevator->direction)); // Start moving towards first passenger's destination
        }
    }  
}

// Define the main function
int main() {
    srand(time(0));
    Elevator elevator = {1, 0, 0, {0}, 0};
    Passenger passengers[MAX_PASSENGERS];
    int i;
    for(i=0; i<MAX_PASSENGERS; i++) { // Randomly generate passengers with destinations
        passengers[i].id = i+1;
        passengers[i].current_floor = rand()%MAX_FLOORS + 1;
        passengers[i].dest_floor = rand()%MAX_FLOORS + 1;
        printf("Passenger %d is on floor %d and wants to go to floor %d\n", passengers[i].id, passengers[i].current_floor, passengers[i].dest_floor);
    }
    printf("Elevator starts at floor %d\n", elevator.current_floor);
    while(1) { // Keep running the simulation until stopped
        if(elevator.dest_count == 0) { // If no passengers inside, check for any waiting at current floor
            for(i=0; i<MAX_PASSENGERS; i++) {
                if(passengers[i].current_floor == elevator.current_floor) {
                    elevator.dest_floor[elevator.dest_count++] = passengers[i].dest_floor;
                    elevator.passengers++;
                    printf("Passenger %d entered elevator on floor %d\n", passengers[i].id, elevator.current_floor);
                }
            }            
        } else {
            move_elevator(&elevator, elevator.current_floor); // Move the elevator to next floor
        }
        usleep(500000); // Wait for 500ms before moving again
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall move_elevator(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall usleep(_QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001779) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // edx
  _BYTE v6[96]; // [rsp+80h] [rbp+0h] BYREF
  __int64 v7[6]; // [rsp+E0h] [rbp+60h] BYREF
  __int64 v8; // [rsp+110h] [rbp+90h]
  int i; // [rsp+11Ch] [rbp+9Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v7[0] = 1i64;
  memset(&v7[1], 0, 40);
  v8 = 0i64;
  for ( i = 0; i <= 14; ++i )
  {
    *(_DWORD *)&v6[12 * i - 88] = i + 1;
    *(_DWORD *)&v6[12 * i - 96] = rand() % 10 + 1;
    *(_DWORD *)&v6[12 * i - 92] = rand() % 10 + 1;
    printf(
      "Passenger %d is on floor %d and wants to go to floor %d\n",
      *(unsigned int *)&v6[12 * i - 88],
      *(unsigned int *)&v6[12 * i - 96],
      *(unsigned int *)&v6[12 * i - 92]);
  }
  printf("Elevator starts at floor %d\n", LODWORD(v7[0]));
  while ( 1 )
  {
    if ( HIDWORD(v8) )
    {
      move_elevator(v7, LODWORD(v7[0]));
    }
    else
    {
      for ( i = 0; i <= 14; ++i )
      {
        if ( *(_DWORD *)&v6[12 * i - 96] == LODWORD(v7[0]) )
        {
          v4 = HIDWORD(v8)++;
          *((_DWORD *)&v7[1] + v4 + 1) = *(_DWORD *)&v6[12 * i - 92];
          ++HIDWORD(v7[0]);
          printf("Passenger %d entered elevator on floor %d\n", *(unsigned int *)&v6[12 * i - 88], LODWORD(v7[0]));
        }
      }
    }
    usleep(500000i64);
  }
}
// 1400015B0: using guessed type __int64 __fastcall move_elevator(_QWORD, _QWORD);
// 140001B60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002BC0: using guessed type __int64 __fastcall usleep(_QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedurally Generated Maze ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 10
#define COLS 10

void generateMaze(int maze[ROWS][COLS]) {
    int i, j;
    // Initialize maze with walls
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            maze[i][j] = 1;
        }
    }
    // Set starting and ending points
    maze[0][0] = 0;
    maze[ROWS-1][COLS-1] = 0;
    
    srand(time(NULL)); // Seed random number generator
    int row = 1, col = 1;
    maze[row][col] = 0; // Set starting position to open space
    
    int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // Up, Down, Left, Right
    int numDirections = 4;
    while (numDirections > 0) {
        int r = rand() % numDirections;
        int dirRow = directions[r][0];
        int dirCol = directions[r][1];
        int neighborRow = row + 2 * dirRow;
        int neighborCol = col + 2 * dirCol;
        if (neighborRow > 0 && neighborRow < ROWS-1 && neighborCol > 0 && neighborCol < COLS-1 && maze[neighborRow][neighborCol] == 1) {
            // Clear path to neighbor
            maze[row+dirRow][col+dirCol] = 0;
            maze[neighborRow][neighborCol] = 0;
            // Move to neighbor
            row = neighborRow;
            col = neighborCol;
            // Reset directions array and increment open space count
            numDirections = 4;
            continue;
        }
        // Remove direction from directions array
        directions[r][0] = directions[numDirections-1][0];
        directions[r][1] = directions[numDirections-1][1];
        numDirections--;
    }
}

void printMaze(int maze[ROWS][COLS]) {
    int i, j;
    printf(" ");
    for (j = 0; j < COLS; j++) {
        printf("_ ");
    }
    printf("\n");
    for (i = 0; i < ROWS; i++) {
        printf("|");
        for (j = 0; j < COLS; j++) {
            if (maze[i][j] == 0) {
                printf("  ");
            } else {
                printf("__");
            }
            if (j == COLS-1) {
                printf("|");
            } else if (maze[i][j] == 0 && maze[i][j+1] == 0) {
                printf(" ");
            } else {
                printf("_");
            }
        }
        printf("\n");
    }
}

int main() {
    int maze[ROWS][COLS];
    generateMaze(maze);
    printMaze(maze);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall generateMaze(_QWORD); // weak
__int64 __fastcall printMaze(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001978) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[400]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  generateMaze(v4);
  printMaze(v4);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall generateMaze(_QWORD);
// 1400017FA: using guessed type __int64 __fastcall printMaze(_QWORD);
// 140001A70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific Calculator Implementation ; Style: peaceful
#include<stdio.h>
#include<math.h>

int main()
{
    int choice;
    float num1, num2, result, degree;
    printf("Welcome to the Scientific Calculator\n");
    printf("Select an Operation from Below:\n");
    printf("1. Addition\n2. Subtraction\n3. Multiplication\n4. Division\n5. Exponentiation\n6. Square Root\n7. Sine\n8. Cosine\n9. Tangent\n10. Exit\n");

    scanf("%d", &choice);

    switch(choice)
    {
        case 1:
            printf("Enter the first number: ");
            scanf("%f", &num1);
            printf("Enter the second number: ");
            scanf("%f", &num2);
            result = num1 + num2;
            printf("Result: %f\n", result);
            break;

        case 2:
            printf("Enter the first number: ");
            scanf("%f", &num1);
            printf("Enter the second number: ");
            scanf("%f", &num2);
            result = num1 - num2;
            printf("Result: %f\n", result);
            break;

        case 3:
            printf("Enter the first number: ");
            scanf("%f", &num1);
            printf("Enter the second number: ");
            scanf("%f", &num2);
            result = num1 * num2;
            printf("Result: %f\n", result);
            break;

        case 4:
            printf("Enter the first number: ");
            scanf("%f", &num1);
            printf("Enter the second number: ");
            scanf("%f", &num2);
            result = num1 / num2;
            printf("Result: %f\n", result);
            break;

        case 5:
            printf("Enter the base: ");
            scanf("%f", &num1);
            printf("Enter the exponent: ");
            scanf("%f", &num2);
            result = pow(num1, num2);
            printf("Result: %f\n", result);
            break;

        case 6:
            printf("Enter the number: ");
            scanf("%f", &num1);
            result = sqrt(num1);
            printf("Result: %f\n", result);
            break;

        case 7:
            printf("Enter the degree: ");
            scanf("%f", &degree);
            result = sin(degree * 3.14159 / 180);
            printf("Result: %f\n", result);
            break;

        case 8:
            printf("Enter the degree: ");
            scanf("%f", &degree);
            result = cos(degree * 3.14159 / 180);
            printf("Result: %f\n", result);
            break;

        case 9:
            printf("Enter the degree: ");
            scanf("%f", &degree);
            result = tan(degree * 3.14159 / 180);
            printf("Result: %f\n", result);
            break;

        case 10:
            printf("Thank you for using the calculator.\n");
            exit(0);

        default:
            printf("Invalid operation.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl cos(double X);
double __cdecl pow(double X, double Y);
double __cdecl sin(double X);
// double __cdecl tan(double X);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  float v7; // xmm0_4
  float v9; // [rsp+2Ch] [rbp-14h] BYREF
  float v10; // [rsp+30h] [rbp-10h] BYREF
  float v11; // [rsp+34h] [rbp-Ch] BYREF
  int v12; // [rsp+38h] [rbp-8h] BYREF
  float v13; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Scientific Calculator\n");
  printf("Select an Operation from Below:\n");
  printf(
    "1. Addition\n"
    "2. Subtraction\n"
    "3. Multiplication\n"
    "4. Division\n"
    "5. Exponentiation\n"
    "6. Square Root\n"
    "7. Sine\n"
    "8. Cosine\n"
    "9. Tangent\n"
    "10. Exit\n");
  scanf("%d", &v12);
  switch ( v12 )
  {
    case 1:
      printf("Enter the first number: ");
      scanf("%f", &v11);
      printf("Enter the second number: ");
      scanf("%f", &v10);
      v13 = v10 + v11;
      printf("Result: %f\n", (float)(v10 + v11));
      break;
    case 2:
      printf("Enter the first number: ");
      scanf("%f", &v11);
      printf("Enter the second number: ");
      scanf("%f", &v10);
      v13 = v11 - v10;
      printf("Result: %f\n", (float)(v11 - v10));
      break;
    case 3:
      printf("Enter the first number: ");
      scanf("%f", &v11);
      printf("Enter the second number: ");
      scanf("%f", &v10);
      v13 = v10 * v11;
      printf("Result: %f\n", (float)(v10 * v11));
      break;
    case 4:
      printf("Enter the first number: ");
      scanf("%f", &v11);
      printf("Enter the second number: ");
      scanf("%f", &v10);
      v13 = v11 / v10;
      printf("Result: %f\n", (float)(v11 / v10));
      break;
    case 5:
      printf("Enter the base: ");
      scanf("%f", &v11);
      printf("Enter the exponent: ");
      scanf("%f", &v10);
      v3 = pow(v11, v10);
      v13 = v3;
      printf("Result: %f\n", v3);
      break;
    case 6:
      printf("Enter the number: ");
      scanf("%f", &v11);
      v4 = sqrt(v11);
      v13 = v4;
      printf("Result: %f\n", v4);
      break;
    case 7:
      printf("Enter the degree: ");
      scanf("%f", &v9);
      v5 = sin(3.14159 * v9 / 180.0);
      v13 = v5;
      printf("Result: %f\n", v5);
      break;
    case 8:
      printf("Enter the degree: ");
      scanf("%f", &v9);
      v6 = cos(3.14159 * v9 / 180.0);
      v13 = v6;
      printf("Result: %f\n", v6);
      break;
    case 9:
      printf("Enter the degree: ");
      scanf("%f", &v9);
      v7 = tan(3.14159 * v9 / 180.0);
      v13 = v7;
      printf("Result: %f\n", v7);
      break;
    case 10:
      printf("Thank you for using the calculator.\n");
      exit(0);
    default:
      printf("Invalid operation.\n");
      break;
  }
  return 0;
}
// 140001C60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Physics simulation ; Style: optimized
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main() {
    double mass1, mass2, position1, position2, velocity1, velocity2, acceleration1, acceleration2, time = 0.0, dt = 0.1;
    double spring_constant = 10.0, damping_constant = 0.5;
    double force1, force2, displacement, previous_displacement;
    int steps = 1000;

    printf("Enter mass of first object: ");
    scanf("%lf", &mass1);
    printf("Enter initial position of first object: ");
    scanf("%lf", &position1);
    printf("Enter initial velocity of first object: ");
    scanf("%lf", &velocity1);

    printf("Enter mass of second object: ");
    scanf("%lf", &mass2);
    printf("Enter initial position of second object: ");
    scanf("%lf", &position2);
    printf("Enter initial velocity of second object: ");
    scanf("%lf", &velocity2);

    displacement = position1 - position2;
    previous_displacement = displacement;

    printf("Time  Position1  Position2  \n");

    for(int i = 0; i < steps; i++) {
        force1 = -spring_constant * displacement - damping_constant * (previous_displacement - displacement) / dt;
        force2 = -force1;
        acceleration1 = force1 / mass1;
        acceleration2 = force2 / mass2;
        position1 += velocity1 * dt + 0.5 * acceleration1 * dt * dt;
        position2 += velocity2 * dt + 0.5 * acceleration2 * dt * dt;
        velocity1 += acceleration1 * dt;
        velocity2 += acceleration2 * dt;
        displacement = position1 - position2;
        previous_displacement = displacement;

        printf("%f  %f  %f\n", time, position1, position2);
        time += dt;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+20h] [rbp-90h] BYREF
  double v5; // [rsp+28h] [rbp-88h] BYREF
  double v6; // [rsp+30h] [rbp-80h] BYREF
  double v7; // [rsp+38h] [rbp-78h] BYREF
  double v8; // [rsp+40h] [rbp-70h] BYREF
  double v9; // [rsp+48h] [rbp-68h] BYREF
  double v10; // [rsp+50h] [rbp-60h]
  double v11; // [rsp+58h] [rbp-58h]
  double v12; // [rsp+60h] [rbp-50h]
  double v13; // [rsp+68h] [rbp-48h]
  int v14; // [rsp+74h] [rbp-3Ch]
  double v15; // [rsp+78h] [rbp-38h]
  double v16; // [rsp+80h] [rbp-30h]
  double v17; // [rsp+88h] [rbp-28h]
  int i; // [rsp+94h] [rbp-1Ch]
  double v19; // [rsp+98h] [rbp-18h]
  double v20; // [rsp+A0h] [rbp-10h]
  double v21; // [rsp+A8h] [rbp-8h]

  _main(argc, argv, envp);
  v21 = 0.0;
  v17 = 0.1;
  v16 = 10.0;
  v15 = 0.5;
  v14 = 1000;
  printf("Enter mass of first object: ");
  scanf("%lf", &v9);
  printf("Enter initial position of first object: ");
  scanf("%lf", &v7);
  printf("Enter initial velocity of first object: ");
  scanf("%lf", &v5);
  printf("Enter mass of second object: ");
  scanf("%lf", &v8);
  printf("Enter initial position of second object: ");
  scanf("%lf", &v6);
  printf("Enter initial velocity of second object: ");
  scanf("%lf", &v4);
  v20 = v7 - v6;
  v19 = v7 - v6;
  printf("Time  Position1  Position2  \n");
  for ( i = 0; i < v14; ++i )
  {
    v13 = -v16 * v20 - (v19 - v20) * v15 / v17;
    v12 = -v13;
    v11 = v13 / v9;
    v10 = -v13 / v8;
    v7 = v7 + v5 * v17 + 0.5 * (v13 / v9) * v17 * v17;
    v6 = v6 + v4 * v17 + 0.5 * v10 * v17 * v17;
    v5 = v5 + v13 / v9 * v17;
    v4 = v4 + v10 * v17;
    v20 = v7 - v6;
    v19 = v7 - v6;
    printf("%f  %f  %f\n", v21, v7, v6);
    v21 = v21 + v17;
  }
  return 0;
}
// 1400019D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Modern Encryption ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* The key for encryption */
char *key = "turing";

/* Function to encrypt a message */
void encryption(char *message) {
    int i, j = 0, k = 0;
    char new_message[1000];

    /* Loop through each character in the message */
    for (i = 0; i < strlen(message); i++) {
        /* Rotate the key */
        if (k == strlen(key)) {
            k = 0;
        }

        /* Check if the character is a letter */
        if (message[i] >= 'a' && message[i] <= 'z') {
            /* Encrypt the letter using the key */
            new_message[j] = ((message[i] - 'a') + (key[k] - 'a')) % 26 + 'a';
            j++;
            k++;
        } else if (message[i] >= 'A' && message[i] <= 'Z') {
            /* Encrypt the letter using the key */
            new_message[j] = ((message[i] - 'A') + (key[k] - 'a')) % 26 + 'A';
            j++;
            k++;
        } else {
            /* Copy the character as is */
            new_message[j] = message[i];
            j++;
        }
    }

    /* Add the null terminator to the end of the string */
    new_message[j] = '\0';

    /* Print the encrypted message */
    printf("Encrypted message: %s\n", new_message);
}

/* Main function to run the encryption */
int main() {
    char message[1000];
    printf("Enter a message to encrypt:\n");
    fgets(message, 1000, stdin);

    /* Remove the newline character from the input */
    message[strcspn(message, "\n")] = 0;

    /* Call the encryption function */
    encryption(message);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall encryption(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400017D8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1008]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  printf("Enter a message to encrypt:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  encryption(Buffer);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall encryption(_QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400017D8: using guessed type char Buffer[1008];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Binary search trees ; Style: calm
#include<stdio.h>
#include<stdlib.h>

// Definition of the node structure
struct node {
    int data;
    struct node *left;
    struct node *right;
};

// Function to create a new node
struct node *newNode(int item) {
    struct node *temp =  (struct node *)malloc(sizeof(struct node));
    temp->data = item;
    temp->left = temp->right = NULL;
    return temp;
}

// Function to insert a new node in the tree
struct node* insert(struct node* node, int data) {
    if (node == NULL) return newNode(data);

    if (data < node->data)
        node->left  = insert(node->left, data);
    else
        node->right = insert(node->right, data);

    return node;
}

// Function to search for a node in the tree
struct node* search(struct node* root, int data) {
    if (root == NULL || root->data == data)
       return root;

    if (root->data < data)
       return search(root->right, data);

    return search(root->left, data);
}

// Function to find the minimum value in a tree
struct node* minValueNode(struct node* node) {
    struct node* current = node;

    while (current && current->left != NULL)
        current = current->left;

    return current;
}

// Function to delete a node from the tree
struct node* deleteNode(struct node* root, int data) {
    if (root == NULL) return root;

    if (data < root->data)
        root->left = deleteNode(root->left, data);

    else if (data > root->data)
        root->right = deleteNode(root->right, data);

    else {
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        }
        else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }

        struct node* temp = minValueNode(root->right);

        root->data = temp->data;

        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Function to traverse the tree in-order
void traverseInOrder(struct node *root) {
    if (root != NULL) {
        traverseInOrder(root->left);
        printf("%d \n", root->data);
        traverseInOrder(root->right);
    }
}

// Driver program
int main() {
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 */
    struct node *root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);

    printf("In-order traversal of the BST \n");
    traverseInOrder(root);

    // Search for a node
    struct node *temp = search(root, 40);
    if(temp != NULL){
        printf("Node found: %d \n", temp->data);
    }
    else{
        printf("Node not found \n");
    }

    // Delete a node
    root = deleteNode(root, 20);
    printf("\nIn-order traversal after deleting 20 \n");
    traverseInOrder(root);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall insert(_QWORD, _QWORD); // weak
__int64 __fastcall search(_QWORD, _QWORD); // weak
__int64 __fastcall deleteNode(_QWORD, _QWORD); // weak
__int64 __fastcall traverseInOrder(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001846) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int *v4; // [rsp+20h] [rbp-10h]
  __int64 v5; // [rsp+28h] [rbp-8h]
  __int64 v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v5 = insert(0i64, 50i64);
  insert(v5, 30i64);
  insert(v5, 20i64);
  insert(v5, 40i64);
  insert(v5, 70i64);
  insert(v5, 60i64);
  insert(v5, 80i64);
  printf("In-order traversal of the BST \n");
  traverseInOrder(v5);
  v4 = (unsigned int *)search(v5, 40i64);
  if ( v4 )
    printf("Node found: %d \n", *v4);
  else
    printf("Node not found \n");
  v6 = deleteNode(v5, 20i64);
  printf("\nIn-order traversal after deleting 20 \n");
  traverseInOrder(v6);
  return 0;
}
// 1400015D9: using guessed type __int64 __fastcall insert(_QWORD, _QWORD);
// 140001648: using guessed type __int64 __fastcall search(_QWORD, _QWORD);
// 1400016E8: using guessed type __int64 __fastcall deleteNode(_QWORD, _QWORD);
// 1400017F5: using guessed type __int64 __fastcall traverseInOrder(_QWORD);
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue Implementation ; Style: satisfied
#include <stdio.h> 
#define MAX_QUEUE_SIZE 100 

int queue[MAX_QUEUE_SIZE], front = -1, rear = -1; 

int isFull(){ //to check if queue is full
    return (rear == MAX_QUEUE_SIZE - 1); 
} 

int isEmpty(){ //to check if queue is empty
    return (front == -1 && rear == -1); 
} 

void enqueue(int data){ //to insert elements into queue
    if(isFull()){ 
        printf("\nError: Queue is full\n"); 
        return; 
    } 
    else if(isEmpty()){ 
        front = rear = 0; 
    } 
    else{ 
        rear++; 
    } 
    queue[rear] = data; 
    printf("\nInserted %d into queue", data); 
} 

void dequeue(){ //to remove elements from queue
    if(isEmpty()){ 
        printf("\nError: Queue is empty\n"); 
        return; 
    } 
    else if(front == rear){ 
        front = rear = -1; 
    } 
    else{ 
        front++; 
    } 
    printf("\nRemoved %d from queue", queue[front-1]); 
} 

void display(){ //to display the elements in the queue
    if(isEmpty()){ 
        printf("\nQueue is empty\n"); 
        return; 
    } 
    for(int i=front; i<=rear; i++){ 
        printf("%d ",queue[i]); 
    } 
} 

int main(){ 
    int choice, data; 

    do{ //loop to keep the program running until the user chooses to exit
        printf("\n\nQUEUE IMPLEMENTATION IN C\n"); 
        printf("\n1. Insert element into queue"); 
        printf("\n2. Remove element from queue"); 
        printf("\n3. Display elements in queue"); 
        printf("\n4. Exit"); 
        printf("\nEnter your choice: "); 

        scanf("%d", &choice); 

        switch(choice){ //switch statement to perform corresponding operation based on user choice
            case 1: printf("\nEnter data to insert: ");
                    scanf("%d", &data);
                    enqueue(data); 
                    break; 

            case 2: dequeue();
                    break; 

            case 3: display();
                    break; 

            case 4: printf("\nExiting program");
                    break; 

            default: printf("\nInvalid choice"); 
        } 
    }while(choice != 4); 

    return 0; 
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall enqueue(_QWORD); // weak
__int64 dequeue(void); // weak
__int64 display(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017A2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-8h] BYREF
  int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("\n\nQUEUE IMPLEMENTATION IN C\n");
    printf("\n1. Insert element into queue");
    printf("\n2. Remove element from queue");
    printf("\n3. Display elements in queue");
    printf("\n4. Exit");
    printf("\nEnter your choice: ");
    scanf("%d", &v5);
    if ( v5 == 4 )
    {
      printf("\nExiting program");
    }
    else
    {
      if ( v5 <= 4 )
      {
        switch ( v5 )
        {
          case 3:
            display();
            continue;
          case 1:
            printf("\nEnter data to insert: ");
            scanf("%d", &v4);
            enqueue(v4);
            continue;
          case 2:
            dequeue();
            continue;
        }
      }
      printf("\nInvalid choice");
    }
  }
  while ( v5 != 4 );
  return 0;
}
// 140001834: conditional instruction was optimized away because %var_4.4<3
// 14000161F: using guessed type __int64 __fastcall enqueue(_QWORD);
// 1400016AA: using guessed type __int64 dequeue(void);
// 140001738: using guessed type __int64 display(void);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int difficulty, guess, num, guessCount = 0;
    char playAgain = 'y';
    srand(time(NULL));
    printf("Welcome to the Guess the Number game!\n");
    printf("Please select difficulty level (1-5): ");
    scanf("%d", &difficulty);

    while(playAgain == 'y') {
        num = (rand() % (10 * difficulty)) + 1; // Generate a random number
        printf("I'm thinking of a number between 1 and %d. Can you guess what it is?\n", 10 * difficulty);
        do {
            printf("Guess #%d: ", guessCount + 1);
            scanf("%d", &guess);
            guessCount++;
            if(guess < num) {
                printf("Too low! ");
                if(num-guess < 3) {
                    printf("But you're getting warm!\n");
                } else if(num-guess > (difficulty*2)) {
                    printf("Not even close!\n");
                } else {
                    printf("Keep trying!\n");
                }
            }
            else if(guess > num) {
                printf("Too high! ");
                if(guess-num < 3) {
                    printf("But you're getting warm!\n");
                } else if(guess-num > (difficulty*2)) {
                    printf("Not even close!\n");
                } else {
                    printf("Keep trying!\n");
                }
            }
        } while(guess != num);
        printf("Congratulations! You guessed it in %d tries!\n", guessCount);
        printf("Would you like to play again? (y/n): ");
        scanf(" %c", &playAgain);
        guessCount = 0;
    }

    printf("Thank you for playing Guess the Number!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5; // [rsp+2Fh] [rbp-11h] BYREF
  int v6; // [rsp+30h] [rbp-10h] BYREF
  int v7; // [rsp+34h] [rbp-Ch] BYREF
  int v8; // [rsp+38h] [rbp-8h]
  unsigned int v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 0;
  v5 = 121;
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Guess the Number game!\n");
  printf("Please select difficulty level (1-5): ");
  scanf("%d", &v7);
LABEL_15:
  if ( v5 == 121 )
  {
    v8 = rand() % (10 * v7) + 1;
    printf("I'm thinking of a number between 1 and %d. Can you guess what it is?\n", (unsigned int)(10 * v7));
    while ( 1 )
    {
      printf("Guess #%d: ", v9 + 1);
      scanf("%d", &v6);
      ++v9;
      if ( v8 <= v6 )
      {
        if ( v8 >= v6 )
          goto LABEL_13;
        printf("Too high! ");
        if ( v6 - v8 > 2 )
        {
          if ( v6 - v8 <= 2 * v7 )
          {
LABEL_12:
            printf("Keep trying!\n");
            goto LABEL_13;
          }
          goto LABEL_7;
        }
      }
      else
      {
        printf("Too low! ");
        if ( v8 - v6 > 2 )
        {
          if ( v8 - v6 <= 2 * v7 )
            goto LABEL_12;
LABEL_7:
          printf("Not even close!\n");
          goto LABEL_13;
        }
      }
      printf("But you're getting warm!\n");
LABEL_13:
      if ( v8 == v6 )
      {
        printf("Congratulations! You guessed it in %d tries!\n", v9);
        printf("Would you like to play again? (y/n): ");
        scanf(" %c", &v5);
        v9 = 0;
        goto LABEL_15;
      }
    }
  }
  printf("Thank you for playing Guess the Number!\n");
  return 0;
}
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Haunted House Simulator ; Style: paranoid
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

void delay(int seconds) {
    int milli_seconds = 1000 * seconds;
    clock_t start_time = clock();
    while (clock() < start_time + milli_seconds);
}

int main() {
    char name[20];
    int proceed = 1;
    printf("Welcome to the Haunted House Simulator!\n\n");
    printf("Enter your name: ");
    scanf("%s", name);
    printf("\nHello %s, are you ready to enter the haunted house (y/n)? ", name);
    char choice = getchar();
    if (choice == 'y') {
        printf("\nThe door creaks open as you step inside. It's dark and gloomy, but you hear music coming from upstairs...\n");
        delay(3);
        printf("\nAs you reach the top of the stairs, the music suddenly stops. The only sound you can hear is your heartbeat.\n");
        delay(3);
        printf("\nYou see a flicker of light at the end of the long hallway and decide to investigate. As you get closer, you realize it's a candle burning in front of a door.\n");
        delay(3);
        printf("\nDo you want to open the door (y/n)? ");
        char choice_2 = getchar();
        if (choice_2 == 'y') {
            printf("\nYou push open the door and step into a room filled with mirrors. As you look at your reflection, you see something move behind you.\n");
            delay(3);
            printf("\nYou quickly turn around, but there's nothing there. You notice that the mirrors are slowly starting to fog up, forming the words 'GET OUT'.\n");
            delay(3);
            printf("\nYou hear a low growl behind you and turn around to face a ghostly figure. You try to run, but your legs won't move.\n");
            delay(3);
            printf("\n'You shouldn't have come here' the ghostly figure whispers in your ear before everything goes black.\n");
            proceed = 0;
        } else {
            printf("\nYou decide not to open the door and explore another part of the house.\n");
        }
    } else {
        printf("\nYou chicken out and leave the haunted house.\n");
        proceed = 0;
    }
    if (proceed == 1) {
        printf("\nYou continue to explore the house, but every room is empty and silent. You start to feel like you're being watched.\n");
        delay(3);
        printf("\nSuddenly, you hear a loud crash downstairs. You cautiously make your way down, but there's no one there.\n");
        delay(3);
        printf("\nYou start to feel like you're not alone in the house. As you turn around, you see a figure standing in the shadows.\n");
        delay(3);
        printf("\nDo you want to run (y/n)? ");
        char choice_3 = getchar();
        if (choice_3 == 'y') {
            printf("\nYou run as fast as you can, but you feel something grabbing onto your leg, pulling you back.\n");
            delay(3);
            printf("\nYou turn around and see a group of ghouls surrounding you. They drag you to the basement and lock you in a cell.\n");
            delay(3);
            printf("\nYou're trapped in the haunted house forever. GAME OVER.\n");
        } else {
            printf("\nYou stand your ground and confront the figure. As it steps into the light, you realize it's just a harmless old man.\n");
            delay(3);
            printf("\n'This house is cursed, you need to leave. Don't make the same mistake I did', he warns you before vanishing into thin air.\n");
            printf("\nYou make your way out of the haunted house, shaken but unharmed. Congratulations, you've survived the Haunted House Simulator!\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall delay(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();


//----- (000000014000161B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[25]; // [rsp+20h] [rbp-20h] BYREF
  char v5; // [rsp+39h] [rbp-7h]
  char v6; // [rsp+3Ah] [rbp-6h]
  char v7; // [rsp+3Bh] [rbp-5h]
  int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 1;
  printf("Welcome to the Haunted House Simulator!\n\n");
  printf("Enter your name: ");
  scanf("%s", v4);
  printf("\nHello %s, are you ready to enter the haunted house (y/n)? ", v4);
  v7 = getchar();
  if ( v7 == 121 )
  {
    printf("\nThe door creaks open as you step inside. It's dark and gloomy, but you hear music coming from upstairs...\n");
    delay(3i64);
    printf("\nAs you reach the top of the stairs, the music suddenly stops. The only sound you can hear is your heartbeat.\n");
    delay(3i64);
    printf(
      "\n"
      "You see a flicker of light at the end of the long hallway and decide to investigate. As you get closer, you realiz"
      "e it's a candle burning in front of a door.\n");
    delay(3i64);
    printf("\nDo you want to open the door (y/n)? ");
    v6 = getchar();
    if ( v6 == 121 )
    {
      printf(
        "\n"
        "You push open the door and step into a room filled with mirrors. As you look at your reflection, you see somethi"
        "ng move behind you.\n");
      delay(3i64);
      printf(
        "\n"
        "You quickly turn around, but there's nothing there. You notice that the mirrors are slowly starting to fog up, f"
        "orming the words 'GET OUT'.\n");
      delay(3i64);
      printf(
        "\n"
        "You hear a low growl behind you and turn around to face a ghostly figure. You try to run, but your legs won't move.\n");
      delay(3i64);
      printf("\n'You shouldn't have come here' the ghostly figure whispers in your ear before everything goes black.\n");
      v8 = 0;
    }
    else
    {
      printf("\nYou decide not to open the door and explore another part of the house.\n");
    }
  }
  else
  {
    printf("\nYou chicken out and leave the haunted house.\n");
    v8 = 0;
  }
  if ( v8 == 1 )
  {
    printf(
      "\n"
      "You continue to explore the house, but every room is empty and silent. You start to feel like you're being watched.\n");
    delay(3i64);
    printf("\nSuddenly, you hear a loud crash downstairs. You cautiously make your way down, but there's no one there.\n");
    delay(3i64);
    printf(
      "\n"
      "You start to feel like you're not alone in the house. As you turn around, you see a figure standing in the shadows.\n");
    delay(3i64);
    printf("\nDo you want to run (y/n)? ");
    v5 = getchar();
    if ( v5 == 121 )
    {
      printf("\nYou run as fast as you can, but you feel something grabbing onto your leg, pulling you back.\n");
      delay(3i64);
      printf(
        "\n"
        "You turn around and see a group of ghouls surrounding you. They drag you to the basement and lock you in a cell.\n");
      delay(3i64);
      printf("\nYou're trapped in the haunted house forever. GAME OVER.\n");
    }
    else
    {
      printf(
        "\n"
        "You stand your ground and confront the figure. As it steps into the light, you realize it's just a harmless old man.\n");
      delay(3i64);
      printf(
        "\n"
        "'This house is cursed, you need to leave. Don't make the same mistake I did', he warns you before vanishing into thin air.\n");
      printf(
        "\n"
        "You make your way out of the haunted house, shaken but unharmed. Congratulations, you've survived the Haunted Ho"
        "use Simulator!\n");
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall delay(_QWORD);
// 140001930: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home automation ; Style: unmistakable
#include <stdio.h>

// Declare variables for each room's light status and temperature
int livingRoomLight = 0;
int bedroomLight = 0;
int kitchenLight = 0;
int livingRoomTemp = 70;
int bedroomTemp = 68;
int kitchenTemp = 72;

// Function to turn lights on/off
void toggleLight(int *light) {
  if (*light == 0) {
    *light = 1;
    printf("Light turned on.\n");
  } else {
    *light = 0;
    printf("Light turned off.\n");
  }
}

// Function to adjust temperature
void adjustTemp(int *temp, int change) {
  *temp += change;
  printf("Temperature adjusted to %d degrees.\n", *temp);
}

int main() {
  int userInput;
  
  printf("Welcome to the Smart Home Automation System.\n");
  
  while (1) {
    printf("\n---MENU---\n");
    printf("1. Living Room Light Status\n");
    printf("2. Bedroom Light Status\n");
    printf("3. Kitchen Light Status\n");
    printf("4. Living Room Temperature\n");
    printf("5. Bedroom Temperature\n");
    printf("6. Kitchen Temperature\n");
    printf("7. Toggle Living Room Light\n");
    printf("8. Toggle Bedroom Light\n");
    printf("9. Toggle Kitchen Light\n");
    printf("10. Adjust Living Room Temperature\n");
    printf("11. Adjust Bedroom Temperature\n");
    printf("12. Adjust Kitchen Temperature\n");
    printf("13. Exit Program\n");
    printf("Enter selection: ");
    scanf("%d", &userInput);
    
    switch (userInput) {
      case 1:
        printf("Living Room Light Status: %s\n", livingRoomLight == 1 ? "ON" : "OFF");
        break;
      case 2:
        printf("Bedroom Light Status: %s\n", bedroomLight == 1 ? "ON" : "OFF");
        break;
      case 3:
        printf("Kitchen Light Status: %s\n", kitchenLight == 1 ? "ON" : "OFF");
        break;
      case 4:
        printf("Living Room Temperature: %d degrees\n", livingRoomTemp);
        break;
      case 5:
        printf("Bedroom Temperature: %d degrees\n", bedroomTemp);
        break;
      case 6:
        printf("Kitchen Temperature: %d degrees\n", kitchenTemp);
        break;
      case 7:
        toggleLight(&livingRoomLight);
        break;
      case 8:
        toggleLight(&bedroomLight);
        break;
      case 9:
        toggleLight(&kitchenLight);
        break;
      case 10:
        printf("Enter temperature change (positive or negative integer): ");
        scanf("%d", &userInput);
        adjustTemp(&livingRoomTemp, userInput);
        break;
      case 11:
        printf("Enter temperature change (positive or negative integer): ");
        scanf("%d", &userInput);
        adjustTemp(&bedroomTemp, userInput);
        break;
      case 12:
        printf("Enter temperature change (positive or negative integer): ");
        scanf("%d", &userInput);
        adjustTemp(&kitchenTemp, userInput);
        break;
      case 13:
        printf("Exiting program...");
        return 0;
      default:
        printf("Invalid selection. Try again.\n");
        break;
    }
  }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall toggleLight(_QWORD); // weak
__int64 __fastcall adjustTemp(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

int livingRoomTemp = 70; // weak
int bedroomTemp = 68; // weak
int kitchenTemp = 72; // weak
int livingRoomLight; // weak
int bedroomLight; // weak
int kitchenLight; // weak


//----- (0000000140001671) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rax
  const char *v4; // rax
  const char *v5; // rax
  unsigned int v7; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Smart Home Automation System.\n");
  while ( 1 )
  {
    printf("\n---MENU---\n");
    printf("1. Living Room Light Status\n");
    printf("2. Bedroom Light Status\n");
    printf("3. Kitchen Light Status\n");
    printf("4. Living Room Temperature\n");
    printf("5. Bedroom Temperature\n");
    printf("6. Kitchen Temperature\n");
    printf("7. Toggle Living Room Light\n");
    printf("8. Toggle Bedroom Light\n");
    printf("9. Toggle Kitchen Light\n");
    printf("10. Adjust Living Room Temperature\n");
    printf("11. Adjust Bedroom Temperature\n");
    printf("12. Adjust Kitchen Temperature\n");
    printf("13. Exit Program\n");
    printf("Enter selection: ");
    scanf("%d", &v7);
    switch ( v7 )
    {
      case 1u:
        if ( livingRoomLight == 1 )
          v3 = "ON";
        else
          v3 = "OFF";
        printf("Living Room Light Status: %s\n", v3);
        break;
      case 2u:
        if ( bedroomLight == 1 )
          v4 = "ON";
        else
          v4 = "OFF";
        printf("Bedroom Light Status: %s\n", v4);
        break;
      case 3u:
        if ( kitchenLight == 1 )
          v5 = "ON";
        else
          v5 = "OFF";
        printf("Kitchen Light Status: %s\n", v5);
        break;
      case 4u:
        printf("Living Room Temperature: %d degrees\n", (unsigned int)livingRoomTemp);
        break;
      case 5u:
        printf("Bedroom Temperature: %d degrees\n", (unsigned int)bedroomTemp);
        break;
      case 6u:
        printf("Kitchen Temperature: %d degrees\n", (unsigned int)kitchenTemp);
        break;
      case 7u:
        toggleLight(&livingRoomLight);
        break;
      case 8u:
        toggleLight(&bedroomLight);
        break;
      case 9u:
        toggleLight(&kitchenLight);
        break;
      case 0xAu:
        printf("Enter temperature change (positive or negative integer): ");
        scanf("%d", &v7);
        adjustTemp(&livingRoomTemp, v7);
        break;
      case 0xBu:
        printf("Enter temperature change (positive or negative integer): ");
        scanf("%d", &v7);
        adjustTemp(&bedroomTemp, v7);
        break;
      case 0xCu:
        printf("Enter temperature change (positive or negative integer): ");
        scanf("%d", &v7);
        adjustTemp(&kitchenTemp, v7);
        break;
      case 0xDu:
        printf("Exiting program...");
        return 0;
      default:
        printf("Invalid selection. Try again.\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 __fastcall toggleLight(_QWORD);
// 140001633: using guessed type __int64 __fastcall adjustTemp(_QWORD, _QWORD);
// 140001A70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140014010: using guessed type int livingRoomTemp;
// 140014014: using guessed type int bedroomTemp;
// 140014018: using guessed type int kitchenTemp;
// 140019040: using guessed type int livingRoomLight;
// 140019044: using guessed type int bedroomLight;
// 140019048: using guessed type int kitchenLight;

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Chess engine ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 8
#define COLUMNS 8

int board[ROWS][COLUMNS];

void initializeBoard() {
    int i, j;

    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLUMNS; j++) {
            board[i][j] = 0;
        }
    }
}

int possibleMoves(int x, int y) {
    int i, j, count = 0;
    int moveX, moveY;

    for (i = -2; i <= 2; i++) {
        for (j = -2; j <= 2; j++) {
            if (abs(i) != abs(j) && x+i >= 0 && x+i < ROWS && y+j >= 0 && y+j < COLUMNS) {
                moveX = x+i;
                moveY = y+j;
                if (board[moveX][moveY] == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}

void makeMove(int x, int y) {
    int i, j;
    int moveX, moveY;

    for (i = -2; i <= 2; i++) {
        for (j = -2; j <= 2; j++) {
            if (abs(i) != abs(j) && x+i >= 0 && x+i < ROWS && y+j >= 0 && y+j < COLUMNS) {
                moveX = x+i;
                moveY = y+j;
                if (board[moveX][moveY] == 0) {
                    board[moveX][moveY] = 1;
                }
            }
        }
    }
}

void printBoard() {
    int i, j;

    printf("\n");

    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLUMNS; j++) {
            printf("%d ", board[i][j]);
        }
        printf("\n");
    }
}

int main() {
    initializeBoard();

    srand(time(NULL));

    int i, j;

    for (i = 0; i < 8; i++) {
        for (j = 0; j < 8; j++) {
            int moves = possibleMoves(i, j);
            //Don't perform a move if there are no available spots
            if (moves > 0) {
                //Pick a random available spot
                int randomMove = rand() % moves;
                int count = 0;
                //Perform the move
                for (int a = -2; a <= 2; a++) {
                    for (int b = -2; b <= 2; b++) {
                        if (abs(a) != abs(b) && i+a >= 0 && i+a < ROWS && j+b >= 0 && j+b < COLUMNS) {
                            int moveX = i+a;
                            int moveY = j+b;
                            if (board[moveX][moveY] == 0) {
                                if (count == randomMove) {
                                    makeMove(moveX, moveY);
                                    break;
                                } else {
                                    count++;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    printBoard();

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 initializeBoard(void); // weak
__int64 __fastcall possibleMoves(_QWORD, _QWORD); // weak
__int64 __fastcall makeMove(_QWORD, _QWORD); // weak
__int64 printBoard(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();

//-------------------------------------------------------------------------
// Data declarations

_DWORD board[64]; // weak


//----- (0000000140001877) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // edx
  int v5; // eax
  int v7; // [rsp+34h] [rbp-1Ch]
  int v8; // [rsp+38h] [rbp-18h]
  int m; // [rsp+3Ch] [rbp-14h]
  int k; // [rsp+40h] [rbp-10h]
  int v11; // [rsp+44h] [rbp-Ch]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  initializeBoard();
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 7; ++i )
  {
    for ( j = 0; j <= 7; ++j )
    {
      v8 = possibleMoves((unsigned int)i, (unsigned int)j);
      if ( v8 > 0 )
      {
        v7 = rand() % v8;
        v11 = 0;
        for ( k = -2; k <= 2; ++k )
        {
          for ( m = -2; m <= 2; ++m )
          {
            v4 = -k;
            if ( k > 0 )
              v4 = k;
            v5 = m;
            if ( m <= 0 )
              v5 = -m;
            if ( v4 != v5 && (unsigned int)(i + k) <= 7 && (unsigned int)(j + m) <= 7 && !board[8 * i + 8 * k + j + m] )
            {
              if ( v11 == v7 )
              {
                makeMove((unsigned int)(i + k), (unsigned int)(j + m));
                break;
              }
              ++v11;
            }
          }
        }
      }
    }
  }
  printBoard();
  return 0;
}
// 1400015B0: using guessed type __int64 initializeBoard(void);
// 14000160E: using guessed type __int64 __fastcall possibleMoves(_QWORD, _QWORD);
// 1400016EC: using guessed type __int64 __fastcall makeMove(_QWORD, _QWORD);
// 1400017EE: using guessed type __int64 printBoard(void);
// 140001AA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type _DWORD board[64];

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Drone Remote Control ; Style: expert-level
#include <stdio.h>

struct remoteControl {
    int power; // variable to hold power status
    int pitch; // variable to hold pitch level
    int roll; // variable to hold roll level
    int yaw; // variable to hold yaw level
} drone; // create instance of remoteControl struct, named drone

int main() {
    // init the remote control, drone is off and at zero levels
    drone.power = 0;
    drone.pitch = 0;
    drone.roll = 0;
    drone.yaw = 0;

    // ask user if they want turn on or off the drone
    printf("Do you want to turn on the drone? (1=Yes, 0=No):\n");
    scanf("%d", &drone.power); // get user input and store in drone.power

    // check if the drone is power on or off
    if(drone.power == 1) {
        printf("Drone is powering on...\n");

        // prompt user for pitch level
        printf("Select pitch level (Range -100 to 100):\n");
        scanf("%d", &drone.pitch); // get user input and store in drone.pitch

        // prompt user for roll level
        printf("Select roll level (Range -100 to 100):\n");
        scanf("%d", &drone.roll); // get user input and store in drone.roll

        // prompt user for yaw level
        printf("Select yaw level (Range -100 to 100):\n");
        scanf("%d", &drone.yaw); // get user input and store in drone.yaw

        // send control signals to the drone
        printf("Sending control signals to the drone...\n");

        // print final control signal values
        printf("Control Signals:\n");
        printf("Pitch: %d\n", drone.pitch);
        printf("Roll: %d\n", drone.roll);
        printf("Yaw: %d\n", drone.yaw);
    } else {
        printf("Drone is powered off...\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

int drone; // weak
int dword_140018044; // weak
int dword_140018048; // weak
int dword_14001804C; // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  drone = 0;
  dword_140018044 = 0;
  dword_140018048 = 0;
  dword_14001804C = 0;
  printf("Do you want to turn on the drone? (1=Yes, 0=No):\n");
  scanf("%d", &drone);
  if ( drone == 1 )
  {
    printf("Drone is powering on...\n");
    printf("Select pitch level (Range -100 to 100):\n");
    scanf("%d", &dword_140018044);
    printf("Select roll level (Range -100 to 100):\n");
    scanf("%d", &dword_140018048);
    printf("Select yaw level (Range -100 to 100):\n");
    scanf("%d", &dword_14001804C);
    printf("Sending control signals to the drone...\n");
    printf("Control Signals:\n");
    printf("Pitch: %d\n", (unsigned int)dword_140018044);
    printf("Roll: %d\n", (unsigned int)dword_140018048);
    printf("Yaw: %d\n", (unsigned int)dword_14001804C);
  }
  else
  {
    printf("Drone is powered off...\n");
  }
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140018040: using guessed type int drone;
// 140018044: using guessed type int dword_140018044;
// 140018048: using guessed type int dword_140018048;
// 14001804C: using guessed type int dword_14001804C;

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Periodic Table Quiz ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

const char PERIODIC_TABLE[7][18] = {
    {"H He Li Be B C N O F Ne"},
    {"Na Mg Al Si P S Cl Ar"},
    {"K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge As Se Br Kr"},
    {"Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag Cd In Sn Sb Te I Xe"},
    {"Cs Ba La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm Yb Lu Hf Ta W Re Os Ir Pt Au Hg Tl Pb Bi Po At Rn"},
    {"Fr Ra Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No Lr Rf Db Sg Bh Hs Mt Ds Rg Cn Nh Fl Mc Lv Ts Og"},
    {" "},
};

const char ELEMENT_NAMES[118][20] = {
    "Hydrogen", "Helium", "Lithium", "Beryllium", "Boron", "Carbon", "Nitrogen", "Oxygen", "Fluorine", "Neon",
    "Sodium", "Magnesium", "Aluminium", "Silicon", "Phosphorus", "Sulfur", "Chlorine", "Argon", "Potassium", "Calcium",
    "Scandium", "Titanium", "Vanadium", "Chromium", "Manganese", "Iron", "Cobalt", "Nickel", "Copper", "Zinc",
    "Gallium", "Germanium", "Arsenic", "Selenium", "Bromine", "Krypton", "Rubidium", "Strontium", "Yttrium", "Zirconium",
    "Niobium", "Molybdenum", "Technetium", "Ruthenium", "Rhodium", "Palladium", "Silver", "Cadmium", "Indium", "Tin",
    "Antimony", "Tellurium", "Iodine", "Xenon", "Cesium", "Barium", "Lanthanum", "Cerium", "Praseodymium", "Neodymium",
    "Promethium", "Samarium", "Europium", "Gadolinium", "Terbium", "Dysprosium", "Holmium", "Erbium", "Thulium", "Ytterbium",
    "Lutetium", "Hafnium", "Tantalum", "Tungsten", "Rhenium", "Osmium", "Iridium", "Platinum", "Gold", "Mercury",
    "Thallium", "Lead", "Bismuth", "Polonium", "Astatine", "Radon", "Francium", "Radium", "Actinium", "Thorium",
    "Protactinium", "Uranium", "Neptunium", "Plutonium", "Americium", "Curium", "Berkelium", "Californium", "Einsteinium", "Fermium",
    "Mendelevium", "Nobelium", "Lawrencium", "Rutherfordium", "Dubnium", "Seaborgium", "Bohrium", "Hassium", "Meitnerium", "Darmstadtium",
    "Roentgenium", "Copernicium", "Nihonium", "Flerovium", "Moscovium", "Livermorium", "Tennessine", "Oganesson"
};

const char ELEMENT_SYMBOLS[118][4] = {
    "H", "He", "Li", "Be", "B", "C", "N", "O", "F", "Ne",
    "Na", "Mg", "Al", "Si", "P", "S", "Cl", "Ar", "K", "Ca",
    "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn",
    "Ga", "Ge", "As", "Se", "Br", "Kr", "Rb", "Sr", "Y", "Zr",
    "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn",
    "Sb", "Te", "I", "Xe", "Cs", "Ba", "La", "Ce", "Pr", "Nd",
    "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb",
    "Lu", "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", "Hg",
    "Tl", "Pb", "Bi", "Po", "At", "Rn", "Fr", "Ra", "Ac", "Th",
    "Pa", "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm",
    "Md", "No", "Lr", "Rf", "Db", "Sg", "Bh", "Hs", "Mt", "Ds",
    "Rg", "Cn", "Nh", "Fl", "Mc", "Lv", "Ts", "Og"
};

void shuffle(int arr[], int size) {
    // Shuffle an integer array using Fisher-Yates shuffle algorithm
    for (int i=size-1; i>0; --i) {
        int j = rand() % (i+1);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

void print_intro() {
    printf("Welcome to the Periodic Table Quiz!\n");
    printf("This quiz will test your knowledge of the elements in the periodic table.\n");
}

void print_options() {
    printf("\nChoose an option:\n");
    printf("1. Easy (7 multiple choice questions)\n");
    printf("2. Medium (12 multiple choice questions)\n");
    printf("3. Hard (20 multiple choice questions)\n");
    printf("4. Expert (all 118 elements)\n");
    printf("5. Quit\n");
}

void print_question(int index, int num_options, int options[], bool is_expert) {
    printf("\nQuestion %d: ", index+1);
    int element_number = options[index];
    if (is_expert) printf("%s is represented by the symbol %s. ", ELEMENT_NAMES[element_number-1], ELEMENT_SYMBOLS[element_number-1]);
    printf("What is the atomic number of %s?\n", ELEMENT_NAMES[element_number-1]);

    // Print answer options
    bool is_answer_options[num_options];
    for (int i=0; i<num_options; ++i) is_answer_options[i] = false;
    int correct_option = rand() % num_options; // Randomly select the correct answer option

    // Mark the option containing the correct answer
    int option_count = 0;
    for (int i=0; i<num_options; ++i) {
        if (i == correct_option) {
            if (is_expert) printf("%d) %d\n", option_count+1, element_number);
            else printf("%d) %s\n", option_count+1, ELEMENT_SYMBOLS[element_number-1]);
            is_answer_options[i] = true;
        }
        else {
            int incorrect_element_number;
            do {
                incorrect_element_number = rand() % 118 + 1;
            } while (incorrect_element_number == element_number || is_answer_options[incorrect_element_number-1]);
            is_answer_options[incorrect_element_number-1] = true;
            if (is_expert) printf("%d) %d\n", option_count+1, incorrect_element_number);
            else printf("%d) %s\n", option_count+1, ELEMENT_SYMBOLS[incorrect_element_number-1]);
        }
        ++option_count;
    }
}

int main(void) {
    srand((unsigned int) time(NULL)); // Set the random seed based on current time

    // Print the intro and options
    print_intro();
    int option;
    do {
        print_options();
        printf("Enter your choice: ");
        scanf("%d", &option);
    } while (option < 1 || option > 5);

    if (option == 5) return 0;

    // Determine the number of elements and number of questions for the quiz
    int num_elements, num_questions;
    switch (option) {
        case 1:
            num_elements = 10;
            num_questions = 7;
            break;
        case 2:
            num_elements = 20;
            num_questions = 12;
            break;
        case 3:
            num_elements = 50;
            num_questions = 20;
            break;
        case 4:
            num_elements = 118;
            num_questions = 118;
            break;
        default:
            break;
    }

    // Shuffle the elements and select the required number of elements for the quiz
    int element_indices[118];
    for (int i=0; i<118; ++i) element_indices[i] = i+1;
    shuffle(element_indices, 118);
    int selected_elements[num_elements];
    for (int i=0; i<num_elements; ++i) selected_elements[i] = element_indices[i];

    // Shuffle the question order
    int question_order[num_questions];
    for (int i=0; i<num_questions; ++i) question_order[i] = i;
    shuffle(question_order, num_questions);

    // Ask the questions in the shuffled order
    bool is_expert = option == 4;
    int correct_answers = 0;
    for (int i=0; i<num_questions; ++i) {
        print_question(question_order[i], num_elements, selected_elements, is_expert);
        int choice;
        printf("Enter your answer (1-%d): ", num_elements);
        scanf("%d", &choice);
        if (choice == question_order[i]+1) {
            printf("Correct!\n");
            ++correct_answers;
        } else printf("Incorrect. The correct answer is %d.\n", question_order[i]+1);
    }

    // Print the results
    printf("\nYou got %d/%d questions correct. Thanks for playing!\n", correct_answers, num_questions);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall shuffle(_QWORD, _QWORD); // weak
__int64 print_intro(void); // weak
__int64 print_options(void); // weak
__int64 __fastcall print_question(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400019E4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  void *v5; // rsp
  void *v6; // rsp
  __int64 v7; // [rsp+20h] [rbp-60h] BYREF
  __int64 v8; // [rsp+28h] [rbp-58h]
  int v9; // [rsp+3Ch] [rbp-44h] BYREF
  int v10[118]; // [rsp+40h] [rbp-40h] BYREF
  int v11; // [rsp+218h] [rbp+198h] BYREF
  bool v12; // [rsp+21Fh] [rbp+19Fh]
  __int64 *v13; // [rsp+220h] [rbp+1A0h]
  __int64 v14; // [rsp+228h] [rbp+1A8h]
  __int64 *v15; // [rsp+230h] [rbp+1B0h]
  __int64 v16; // [rsp+238h] [rbp+1B8h]
  int m; // [rsp+244h] [rbp+1C4h]
  unsigned int v18; // [rsp+248h] [rbp+1C8h]
  int k; // [rsp+24Ch] [rbp+1CCh]
  int j; // [rsp+250h] [rbp+1D0h]
  int i; // [rsp+254h] [rbp+1D4h]
  unsigned int v22; // [rsp+258h] [rbp+1D8h]
  unsigned int v23; // [rsp+25Ch] [rbp+1DCh]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  print_intro();
  do
  {
    do
    {
      print_options();
      printf("Enter your choice: ");
      scanf("%d", &v11);
    }
    while ( v11 <= 0 );
  }
  while ( v11 > 5 );
  switch ( v11 )
  {
    case 5:
      return 0;
    case 4:
      v23 = 118;
      v22 = 118;
      break;
    case 3:
      v23 = 50;
      v22 = 20;
      break;
    case 1:
      v23 = 10;
      v22 = 7;
      break;
    default:
      v23 = 20;
      v22 = 12;
      break;
  }
  for ( i = 0; i <= 117; ++i )
    v10[i] = i + 1;
  shuffle(v10, 118i64);
  v16 = (int)v23 - 1i64;
  v7 = (int)v23;
  v8 = 0i64;
  v5 = alloca(16 * ((unsigned __int64)(4i64 * (int)v23 + 15) >> 4));
  v15 = &v7;
  for ( j = 0; j < (int)v23; ++j )
    *((_DWORD *)v15 + j) = v10[j];
  v14 = (int)v22 - 1i64;
  v6 = alloca(16 * ((unsigned __int64)(4i64 * (int)v22 + 15) >> 4));
  v13 = &v7;
  for ( k = 0; k < (int)v22; ++k )
    *((_DWORD *)v13 + k) = k;
  shuffle(v13, v22);
  v12 = v11 == 4;
  v18 = 0;
  for ( m = 0; m < (int)v22; ++m )
  {
    print_question(*((unsigned int *)v13 + m), v23, v15, v12, v7, v8);
    printf("Enter your answer (1-%d): ", v23);
    scanf("%d", &v9);
    if ( *((_DWORD *)v13 + m) + 1 == v9 )
    {
      printf("Correct!\n");
      ++v18;
    }
    else
    {
      printf("Incorrect. The correct answer is %d.\n", (unsigned int)(*((_DWORD *)v13 + m) + 1));
    }
  }
  printf("\nYou got %d/%d questions correct. Thanks for playing!\n", v18, v22);
  return 0;
}
// 140001A7F: conditional instruction was optimized away because eax.4 is in (1..4)
// 140001A93: conditional instruction was optimized away because eax.4==2
// 140001A89: conditional instruction was optimized away because %var_88.4 is in (1..2)
// 140001601: using guessed type __int64 __fastcall shuffle(_QWORD, _QWORD);
// 14000169D: using guessed type __int64 print_intro(void);
// 1400016CA: using guessed type __int64 print_options(void);
// 140001733: using guessed type __int64 __fastcall print_question(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140001E80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400019E4: using guessed type int var_88;
// 1400019E4: using guessed type int var_260[118];

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Count Tool ; Style: genious
#include <stdio.h>
#include <ctype.h>

int main() {
    char c, prev = '\0';
    int word_count = 0, char_count = 0, line_count = 0;

    printf("*** C Word Count Tool ***\n");
    printf("Enter text: \n");

    while ((c = getchar()) != EOF) {
        if (prev == '\0' || isspace(prev)) { // word start condition
            word_count++;
        }
        if (c == '\n') { // new line condition
            line_count++;
        }
        char_count++; // incrementing character count
        prev = c; // updating previous character
    }

    printf("\n");
    printf("Total characters: %d\n", char_count);
    printf("Total words: %d\n", word_count);
    printf("Total lines: %d\n", line_count);
    printf("\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isspace)(int C);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Fh] [rbp-11h]
  unsigned int v5; // [rsp+30h] [rbp-10h]
  unsigned int v6; // [rsp+34h] [rbp-Ch]
  unsigned int v7; // [rsp+38h] [rbp-8h]
  char v8; // [rsp+3Fh] [rbp-1h]

  _main(argc, argv, envp);
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  printf("*** C Word Count Tool ***\n");
  printf("Enter text: \n");
  while ( 1 )
  {
    v4 = getchar();
    if ( v4 == -1 )
      break;
    if ( !v8 || isspace(v8) )
      ++v7;
    if ( v4 == 10 )
      ++v5;
    ++v6;
    v8 = v4;
  }
  printf("\n");
  printf("Total characters: %d\n", v6);
  printf("Total words: %d\n", v7);
  printf("Total lines: %d\n", v5);
  printf("\n");
  return 0;
}
// 140001730: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: URL Sanitizer ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_URL_LENGTH 1024

// Function prototype
char *sanitize_url(char *url);

int main()
{
    char url[MAX_URL_LENGTH];
    char *sanitized_url;

    // Prompt user to enter URL
    printf("Enter a URL to sanitize: ");
    fgets(url, MAX_URL_LENGTH, stdin);

    // Remove newline character from URL
    url[strcspn(url, "\n")] = '\0';

    // Sanitize URL
    sanitized_url = sanitize_url(url);

    // Print sanitized URL
    printf("Sanitized URL: %s\n", sanitized_url);

    return 0;
}

char *sanitize_url(char *url)
{
    int i, j = 0;
    char *sanitized_url = (char *) malloc(MAX_URL_LENGTH);
    memset(sanitized_url, 0, MAX_URL_LENGTH);

    // Remove whitespace from URL
    for (i = 0; url[i] != '\0'; i++)
    {
        if (!isspace(url[i]))
        {
            sanitized_url[j++] = url[i];
        }
    }

    // Check if URL starts with "http://" or "https://"
    if (strncmp(sanitized_url, "http://", 7) != 0 && strncmp(sanitized_url, "https://", 8) != 0)
    {
        // Add "http://" to URL if it doesn't start with "http://" or "https://
        char *temp_url = (char *) malloc(MAX_URL_LENGTH);
        memset(temp_url, 0, MAX_URL_LENGTH);
        strcpy(temp_url, sanitized_url);
        memset(sanitized_url, 0, MAX_URL_LENGTH);
        strcat(sanitized_url, "http://");
        strcat(sanitized_url, temp_url);
        free(temp_url);
    }

    // Remove any trailing slashes from URL
    if (sanitized_url[strlen(sanitized_url) - 1] == '/')
    {
        sanitized_url[strlen(sanitized_url) - 1] = '\0';
    }

    // Convert all uppercase letters in URL to lowercase
    for (i = 0; sanitized_url[i] != '\0'; i++)
    {
        sanitized_url[i] = tolower(sanitized_url[i]);
    }

    return sanitized_url;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall sanitize_url(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1032]; // [rsp+20h] [rbp-60h] BYREF
  const char *v6; // [rsp+428h] [rbp+3A8h]

  _main(argc, argv, envp);
  printf("Enter a URL to sanitize: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1024, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  v6 = (const char *)sanitize_url(Buffer);
  printf("Sanitized URL: %s\n", v6);
  return 0;
}
// 14000162C: using guessed type __int64 __fastcall sanitize_url(_QWORD);
// 1400018E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[1032];

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: enthusiastic
#include <stdio.h>
#include <stdlib.h>

//function to display options menu
void displayMenu() {
    printf("----------------------------\n");
    printf("Digital Diary\n");
    printf("----------------------------\n");
    printf("1. View diary entries\n");
    printf("2. Add a new diary entry\n");
    printf("3. Delete a diary entry\n");
    printf("4. Search diary entries\n");
    printf("5. Exit\n");
}

int main() {
    int n, i, choice;
    char text[1000];
    FILE *fptr;

    printf("Welcome to your Digital Diary!\n");

    do {
        displayMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch(choice) {
            //View diary entries
            case 1:
                fptr = fopen("diary.txt", "r");
                if (fptr == NULL) {
                    printf("Error opening file!\n");
                    exit(1);
                }
                while (fgets(text, 1000, fptr)) {
                    printf("%s", text);
                }
                fclose(fptr);
                break;
            
            //Add a new diary entry
            case 2:
                fptr = fopen("diary.txt", "a");
                if (fptr == NULL) {
                    printf("Error opening file!\n");
                    exit(1);
                }
                printf("Enter your diary entry:\n");
                getchar();
                fgets(text, 1000, stdin);
                fprintf(fptr, "%s\n", text);
                printf("Diary entry added successfully!\n");
                fclose(fptr);
                break;

            //Delete a diary entry
            case 3:
                fptr = fopen("diary.txt", "r");
                FILE *temp = fopen("temp.txt", "w");
                if (fptr == NULL || temp == NULL) {
                    printf("Error opening file!\n");
                    exit(1);
                }
                printf("Enter the line number of the entry you want to delete: ");
                scanf("%d", &n);
                for (i = 1; fgets(text, 1000, fptr); i++) {
                    if (i != n) {
                        fprintf(temp, "%s", text);
                    }
                }
                fclose(fptr);
                fclose(temp);
                remove("diary.txt");
                rename("temp.txt", "diary.txt");
                printf("Diary entry deleted successfully!\n");
                break;

            //Search diary entries
            case 4:
                fptr = fopen("diary.txt", "r");
                if (fptr == NULL) {
                    printf("Error opening file!\n");
                    exit(1);
                }
                printf("Enter the search term: ");
                scanf("%s", text);
                for (i = 1; fgets(text, 1000, fptr); i++) {
                    if (strstr(text, text) != NULL) {
                        printf("%d. %s", i, text);
                    }
                }
                fclose(fptr);
                break;

            //Exit the program
            case 5:
                printf("Thank you for using Digital Diary!\n");
                break;

            //Invalid choice
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 5);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 displayMenu(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl rename(const char *OldFilename, const char *NewFilename);
// int __cdecl remove(const char *FileName);
// int __cdecl getchar();
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016AC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1008]; // [rsp+20h] [rbp-60h] BYREF
  int v6; // [rsp+410h] [rbp+390h] BYREF
  int v7; // [rsp+414h] [rbp+394h] BYREF
  FILE *v8; // [rsp+418h] [rbp+398h]
  FILE *Stream; // [rsp+420h] [rbp+3A0h]
  unsigned int v10; // [rsp+42Ch] [rbp+3ACh]

  _main(argc, argv, envp);
  printf("Welcome to your Digital Diary!\n");
  do
  {
    displayMenu();
    printf("Enter your choice: ");
    scanf("%d", &v6);
    switch ( v6 )
    {
      case 1:
        Stream = fopen("diary.txt", "r");
        if ( !Stream )
        {
          printf("Error opening file!\n");
          exit(1);
        }
        while ( fgets(Buffer, 1000, Stream) )
          printf("%s", Buffer);
        goto LABEL_7;
      case 2:
        Stream = fopen("diary.txt", "a");
        if ( !Stream )
        {
          printf("Error opening file!\n");
          exit(1);
        }
        printf("Enter your diary entry:\n");
        getchar();
        v3 = __acrt_iob_func(0);
        fgets(Buffer, 1000, v3);
        fprintf_0(Stream, "%s\n", Buffer);
        printf("Diary entry added successfully!\n");
        fclose(Stream);
        break;
      case 3:
        Stream = fopen("diary.txt", "r");
        v8 = fopen("temp.txt", "w");
        if ( !Stream || !v8 )
        {
          printf("Error opening file!\n");
          exit(1);
        }
        printf("Enter the line number of the entry you want to delete: ");
        scanf("%d", &v7);
        v10 = 1;
        while ( fgets(Buffer, 1000, Stream) )
        {
          if ( v10 != v7 )
            fprintf_0(v8, "%s", Buffer);
          ++v10;
        }
        fclose(Stream);
        fclose(v8);
        remove("diary.txt");
        rename("temp.txt", "diary.txt");
        printf("Diary entry deleted successfully!\n");
        break;
      case 4:
        Stream = fopen("diary.txt", "r");
        if ( !Stream )
        {
          printf("Error opening file!\n");
          exit(1);
        }
        printf("Enter the search term: ");
        scanf("%s", Buffer);
        v10 = 1;
        while ( fgets(Buffer, 1000, Stream) )
        {
          if ( strstr(Buffer, Buffer) )
            printf("%d. %s", v10, Buffer);
          ++v10;
        }
LABEL_7:
        fclose(Stream);
        break;
      case 5:
        printf("Thank you for using Digital Diary!\n");
        break;
      default:
        printf("Invalid choice! Please try again.\n");
        break;
    }
  }
  while ( v6 != 5 );
  return 0;
}
// 140001625: using guessed type __int64 displayMenu(void);
// 140001B90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Music Library Management System ; Style: thoughtful
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct Song{
    char name[100];
    char artist[100];
    char album[100];
    int year;
};

void add_song(struct Song* songs, int* count){
    printf("Enter Song Name: ");
    scanf("%s", songs[*count].name);

    printf("Enter Artist Name: ");
    scanf("%s", songs[*count].artist);

    printf("Enter Album Name: ");
    scanf("%s", songs[*count].album);

    printf("Enter Release Year: ");
    scanf("%d", &songs[*count].year);

    printf("\nSong added successfully!\n");
    (*count)++;
}

void display_all_songs(struct Song* songs, int count){
    printf("All Songs\n");
    for(int i=0; i<count; i++){
        printf("%d. %s - %s [%s] (%d)\n", i+1, songs[i].name, songs[i].artist, songs[i].album, songs[i].year);
    }
}

void search_by_name(struct Song* songs, int count){
    char name[100];
    printf("Enter Name to Search: ");
    scanf("%s", name);
    
    for(int i=0; i<count; i++){
        if(strcmp(songs[i].name, name)==0){
            printf("%s - %s [%s] (%d)\n", songs[i].name, songs[i].artist, songs[i].album, songs[i].year);
        }
    }
}

void search_by_artist(struct Song* songs, int count){
    char artist[100];
    printf("Enter Artist Name to Search: ");
    scanf("%s", artist);

    for(int i=0; i<count; i++){
        if(strcmp(songs[i].artist, artist)==0){
            printf("%s - %s [%s] (%d)\n", songs[i].name, songs[i].artist, songs[i].album, songs[i].year);
        }
    }
}

int main(){
    int count = 0;  // initial count of songs
    int choice;

    printf("C Music Library Management System\n");

    struct Song songs[100];

    while(1){
        printf("\n---MENU---\n");
        printf("1. Add Song\n");
        printf("2. Display All Songs\n");
        printf("3. Search by Name\n");
        printf("4. Search by Artist\n");
        printf("5. Exit\n");
        printf("Enter Choice (1-5): ");
        scanf("%d", &choice);

        switch(choice){
            case 1:
                add_song(songs, &count);
                break;

            case 2:
                display_all_songs(songs, count);
                break;
            
            case 3:
                search_by_name(songs, count);
                break;

            case 4:
                search_by_artist(songs, count);
                break;

            case 5:
                printf("\nExiting C Music Library Management System\n");
                exit(0);

            default:
                printf("\nInvalid Choice! Please enter choice between 1 to 5.\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_song(_QWORD, _QWORD); // weak
__int64 __fastcall display_all_songs(_QWORD, _QWORD); // weak
__int64 __fastcall search_by_name(_QWORD, _QWORD); // weak
__int64 __fastcall search_by_artist(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001AF1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[30408]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+76E8h] [rbp+7668h] BYREF
  unsigned int v6; // [rsp+76ECh] [rbp+766Ch] BYREF

  _main(argc, argv, envp);
  v6 = 0;
  printf("C Music Library Management System\n");
  while ( 1 )
  {
    printf("\n---MENU---\n");
    printf("1. Add Song\n");
    printf("2. Display All Songs\n");
    printf("3. Search by Name\n");
    printf("4. Search by Artist\n");
    printf("5. Exit\n");
    printf("Enter Choice (1-5): ");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        add_song(v4, &v6);
        break;
      case 2:
        display_all_songs(v4, v6);
        break;
      case 3:
        search_by_name(v4, v6);
        break;
      case 4:
        search_by_artist(v4, v6);
        break;
      case 5:
        printf("\nExiting C Music Library Management System\n");
        exit(0);
      default:
        printf("\nInvalid Choice! Please enter choice between 1 to 5.\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 __fastcall add_song(_QWORD, _QWORD);
// 140001747: using guessed type __int64 __fastcall display_all_songs(_QWORD, _QWORD);
// 140001850: using guessed type __int64 __fastcall search_by_name(_QWORD, _QWORD);
// 1400019A0: using guessed type __int64 __fastcall search_by_artist(_QWORD, _QWORD);
// 140001D10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Terminal Based Game ; Style: enthusiastic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to generate a random number within a given range
int generateRandomNumber(int lower, int upper)
{
    int num = (rand() % (upper - lower + 1)) + lower;
    return num;
}

int main()
{
    int upper, lower, num, guess, attempts = 0;

    printf("Welcome to the Guessing Game!\n\n");

    // Set the range for the random number
    printf("Enter the lower bound: ");
    scanf("%d", &lower);

    printf("Enter the upper bound: ");
    scanf("%d", &upper);

    printf("\nI am thinking of a number between %d and %d. Can you guess what it is?\n\n", lower, upper);

    // Seed the random number generator
    srand(time(0));

    // Generate the random number
    num = generateRandomNumber(lower, upper);

    // Loop until the user guesses the correct number
    do
    {
        printf("Enter your guess: ");
        scanf("%d", &guess);
        attempts++;

        if (guess > num)
        {
            printf("Too high! Try again.\n");
        }
        else if (guess < num)
        {
            printf("Too low! Try again.\n");
        }
        else
        {
            printf("\nCongratulations! You guessed the number in %d attempt(s)!\n", attempts);
        }
    } while (guess != num);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall generateRandomNumber(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001631) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v6; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v7; // [rsp+34h] [rbp-Ch] BYREF
  int RandomNumber; // [rsp+38h] [rbp-8h]
  unsigned int v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 0;
  printf("Welcome to the Guessing Game!\n\n");
  printf("Enter the lower bound: ");
  scanf("%d", &v6);
  printf("Enter the upper bound: ");
  scanf("%d", &v7);
  printf("\nI am thinking of a number between %d and %d. Can you guess what it is?\n\n", v6, v7);
  v3 = time(0i64);
  srand(v3);
  RandomNumber = generateRandomNumber(v6, v7);
  do
  {
    printf("Enter your guess: ");
    scanf("%d", &v5);
    ++v9;
    if ( RandomNumber >= v5 )
    {
      if ( RandomNumber <= v5 )
        printf("\nCongratulations! You guessed the number in %d attempt(s)!\n", v9);
      else
        printf("Too low! Try again.\n");
    }
    else
    {
      printf("Too high! Try again.\n");
    }
  }
  while ( RandomNumber != v5 );
  return 0;
}
// 140001601: using guessed type __int64 __fastcall generateRandomNumber(_QWORD, _QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: high level of detail
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    printf("Welcome to the Automated Fortune Teller! \n");
    printf("Ask me a question and I will give you an answer. \n");

    // seed random number generator
    srand(time(NULL));

    // array of possible answers
    char* answers[] = {
        "It is certain.",
        "Without a doubt.",
        "You may rely on it.",
        "Yes, definitely.",
        "It is decidedly so.",
        "As I see it, yes.",
        "Most likely.",
        "Yes.",
        "Outlook good.",
        "Signs point to yes.",
        "Reply hazy, try again.",
        "Better not tell you now.",
        "Ask again later.",
        "Cannot predict now.",
        "Concentrate and ask again.",
        "Don't count on it.",
        "Outlook not so good.",
        "My sources say no.",
        "Very doubtful.",
        "My reply is no."
    };

    // generate random index and print answer
    int index = rand() % 20;
    printf("\n%s\n", answers[index]);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5[21]; // [rsp+20h] [rbp-B0h]
  int v6; // [rsp+CCh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Automated Fortune Teller! \n");
  printf("Ask me a question and I will give you an answer. \n");
  v3 = time(0i64);
  srand(v3);
  v5[0] = (__int64)"It is certain.";
  v5[1] = (__int64)"Without a doubt.";
  v5[2] = (__int64)"You may rely on it.";
  v5[3] = (__int64)"Yes, definitely.";
  v5[4] = (__int64)"It is decidedly so.";
  v5[5] = (__int64)"As I see it, yes.";
  v5[6] = (__int64)"Most likely.";
  v5[7] = (__int64)"Yes.";
  v5[8] = (__int64)"Outlook good.";
  v5[9] = (__int64)"Signs point to yes.";
  v5[10] = (__int64)"Reply hazy, try again.";
  v5[11] = (__int64)"Better not tell you now.";
  v5[12] = (__int64)"Ask again later.";
  v5[13] = (__int64)"Cannot predict now.";
  v5[14] = (__int64)"Concentrate and ask again.";
  v5[15] = (__int64)"Don't count on it.";
  v5[16] = (__int64)"Outlook not so good.";
  v5[17] = (__int64)"My sources say no.";
  v5[18] = (__int64)"Very doubtful.";
  v5[19] = (__int64)"My reply is no.";
  v6 = rand() % 20;
  printf("\n%s\n", (const char *)v5[v6]);
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Typing Speed Test ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

int main()
{
    srand(time(NULL));
    char arr[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+{}[]:<>,.?/'\"\\|"; // Array of all allowed characters
    int n = 50; // Number of characters to be typed
    int score = 0, time_taken; // Variables to store score and time taken
    
    printf("Welcome to the Typing Speed Test!\n");
    printf("Type the following characters:\n");

    for(int i=0; i<n; i++) // Generating random characters to be typed
    {
        printf("%c", arr[rand() % strlen(arr)]);
    }
    
    printf("\n");
    clock_t start = clock(); // Starting the timer
    
    char input[n];
    gets(input); // Getting user input
    
    clock_t end = clock(); // Stopping the timer
    time_taken = (end - start) * 1000 / CLOCKS_PER_SEC; // Calculating time taken in milliseconds
    
    for(int i=0; i<n; i++) // Checking user input
    {
        if(input[i] == arr[i])
        {
            score++;
        }
    }
    
    printf("Your score: %d/%d\n", score, n);
    printf("Time taken: %d milliseconds\n", time_taken);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// __int64 __fastcall gets(_QWORD); weak
// clock_t __cdecl clock();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned __int64 v4; // rbx
  size_t v5; // rax
  void *v6; // rsp
  char Str[96]; // [rsp+20h] [rbp-90h] BYREF
  unsigned int v9; // [rsp+80h] [rbp-30h]
  clock_t v10; // [rsp+84h] [rbp-2Ch]
  char *v11; // [rsp+88h] [rbp-28h]
  __int64 v12; // [rsp+90h] [rbp-20h]
  clock_t v13; // [rsp+9Ch] [rbp-14h]
  int v14; // [rsp+A0h] [rbp-10h]
  int j; // [rsp+A4h] [rbp-Ch]
  int i; // [rsp+A8h] [rbp-8h]
  unsigned int v17; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  strcpy(Str, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+{}[]:<>,.?/'\"\\|");
  v14 = 50;
  v17 = 0;
  printf("Welcome to the Typing Speed Test!\n");
  printf("Type the following characters:\n");
  for ( i = 0; i < v14; ++i )
  {
    v4 = rand();
    v5 = strlen(Str);
    printf("%c", (unsigned int)Str[v4 % v5]);
  }
  printf("\n");
  v13 = clock();
  v12 = v14 - 1i64;
  v6 = alloca(16 * ((unsigned __int64)(v14 + 15i64) >> 4));
  v11 = Str;
  gets(Str);
  v10 = clock();
  v9 = v10 - v13;
  for ( j = 0; j < v14; ++j )
  {
    if ( v11[j] == Str[j] )
      ++v17;
  }
  printf("Your score: %d/%d\n", v17, (unsigned int)v14);
  printf("Time taken: %d milliseconds\n", v9);
  return 0;
}
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140008B30: using guessed type __int64 __fastcall gets(_QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define SIZE 10 // size of grid
#define THRESHOLD 0.6 // threshold for percolation

// program to simulate percolation in a 2D grid
// cells have either value 0 (blocked) or 1 (open)
// percolation happens when the top row and bottom row are connected
// through open cells

int grid[SIZE][SIZE]; // 2D grid to store blocked (0) or open (1) cells

// function to initialize the grid randomly
void initialize_grid() {
    srand(time(NULL)); // seed random number generator with current time
    for(int i = 0; i < SIZE; i++) {
        for(int j = 0; j < SIZE; j++) {
            float r = (float) rand() / RAND_MAX; // generate a random float between 0 and 1
            if(r < THRESHOLD) {
                grid[i][j] = 1; // cell is open
            } else {
                grid[i][j] = 0; // cell is blocked
            }
        }
    }
}

// function to print the grid
void print_grid() {
    for(int i = 0; i < SIZE; i++) {
        for(int j = 0; j < SIZE; j++) {
            printf("%d ", grid[i][j]);
        }
        printf("\n");
    }
}

// function to check if the top row and bottom row are connected
int percolates() {
    int top_row[SIZE], bottom_row[SIZE];
    // copy top row
    for(int j = 0; j < SIZE; j++) {
        top_row[j] = grid[0][j];
    }
    // copy bottom row
    for(int j = 0; j < SIZE; j++) {
        bottom_row[j] = grid[SIZE-1][j];
    }
    // check if any open cells in top row are connected to any open cells in bottom row
    for(int j = 0; j < SIZE; j++) {
        if(top_row[j] == 1) { // if cell in top row is open
            for(int k = 0; k < SIZE; k++) {
                if(bottom_row[k] == 1) { // if cell in bottom row is open
                    if(j == k) { // if cells are in the same column, they are connected
                        return 1; // percolation has occurred
                    }
                }
            }
        }
    }
    return 0; // no percolation
}

int main() {
    initialize_grid();
    printf("Initial grid:\n");
    print_grid();
    if(percolates()) {
        printf("Percolation has occurred.\n");
    } else {
        printf("Percolation has not occurred.\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 initialize_grid(void); // weak
__int64 print_grid(void); // weak
__int64 percolates(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017F2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  initialize_grid();
  printf("Initial grid:\n");
  print_grid();
  if ( (unsigned int)percolates() )
    printf("Percolation has occurred.\n");
  else
    printf("Percolation has not occurred.\n");
  return 0;
}
// 1400015B0: using guessed type __int64 initialize_grid(void);
// 1400016A0: using guessed type __int64 print_grid(void);
// 140001724: using guessed type __int64 percolates(void);
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Building a JSON Parser ; Style: retro
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// define maximum buffer size
#define BUFFER_SIZE 1024

// define JSON structure
typedef struct {
    char *key;
    char *value;
} Json;

// define JSON parser function
Json* parseJson(char *jsonString) {
    // allocate memory for JSON object
    Json *json = (Json*) malloc(sizeof(Json));
    json->key = NULL;
    json->value = NULL;

    // loop through each character in JSON string
    int i = 0;
    while (jsonString[i] != '\0') {
        if (jsonString[i] == ':') {
            // set key for JSON object
            json->key = (char*) malloc(sizeof(char) * i);
            strncpy(json->key, jsonString, i);
            json->key[i] = '\0';

            // set value for JSON object
            int j = i+1;
            while (jsonString[j] != ',' && jsonString[j] != '\0') {
                j++;
            }
            json->value = (char*) malloc(sizeof(char) * (j-i));
            strncpy(json->value, jsonString+i+1, j-i-1);
            json->value[j-i-1] = '\0';

            // break out of loop
            break;
        }
        i++;
    }

    // return JSON object
    return json;
}

int main() {
    // get JSON string from user input
    char jsonString[BUFFER_SIZE];
    printf("Enter a JSON string: ");
    fgets(jsonString, BUFFER_SIZE, stdin);

    // remove newline character from end of string
    if (jsonString[strlen(jsonString)-1] == '\n') {
        jsonString[strlen(jsonString)-1] = '\0';
    }

    // parse JSON string
    Json *json = parseJson(jsonString);

    // print JSON object
    printf("Key: %s\nValue: %s\n", json->key, json->value);

    // free memory allocated for JSON object
    free(json->key);
    free(json->value);
    free(json);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall parseJson(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016EE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1032]; // [rsp+20h] [rbp-60h] BYREF
  void *Block; // [rsp+428h] [rbp+3A8h]

  _main(argc, argv, envp);
  printf("Enter a JSON string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1024, v3);
  if ( Buffer[strlen(Buffer) - 1] == 10 )
    Buffer[strlen(Buffer) - 1] = 0;
  Block = (void *)parseJson(Buffer);
  printf("Key: %s\nValue: %s\n", *(const char **)Block, *((const char **)Block + 1));
  free(*(void **)Block);
  free(*((void **)Block + 1));
  free(Block);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall parseJson(_QWORD);
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016EE: using guessed type char Buffer[1032];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Random Conspiracy Theory Generator ; Style: recursive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

char* subjects[] = {"Government", "Illuminati", "Aliens", "Zombies", "Big Pharma", "Flat Earth Society", "Reptilian Elite", "Time Travellers", "Clones", "Artificial Intelligence"};
char* actions[] = {"Control", "Manipulate", "Experiment on", "Brainwash", "Destroy", "Invade", "Infiltrate", "Conquer", "Subdue", "Devour"};
char* targets[] = {"Humanity", "The Environment", "The Economy", "Religion", "Science", "Education", "Technology", "Culture", "Healthcare", "Entertainment"};

void generate_conspiracy() {
    char* subject = subjects[rand() % 10];
    char* action = actions[rand() % 10];
    char* target = targets[rand() % 10];

    printf("%s wants to %s %s.\n", subject, action, target);

    int continue_choice;
    printf("Continue? 1 for yes, 0 for no: ");
    scanf("%d", &continue_choice);

    if (continue_choice == 1) {
        generate_conspiracy();
    }
}

int main() {
    srand(time(NULL));

    printf("Welcome to the Random Conspiracy Theory Generator!\n");

    generate_conspiracy();

    printf("Thanks for using the Random Conspiracy Theory Generator!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 generate_conspiracy(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001747) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Random Conspiracy Theory Generator!\n");
  generate_conspiracy();
  printf("Thanks for using the Random Conspiracy Theory Generator!\n");
  return 0;
}
// 140001601: using guessed type __int64 generate_conspiracy(void);
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Physics simulation ; Style: relaxed
#include <stdio.h>
#include <math.h>

//Constants
#define G 6.67408e-11 //gravitational constant
#define T 1 //simulation time step
#define N 100 //number of particles
#define WIDTH 1000 //width of the simulation area
#define HEIGHT 1000 //height of the simulation area

//Structures
typedef struct {
    double x, y; //position
    double vx, vy; //velocity
    double mass; //mass
} Particle;

//Function prototypes
void updatePosition(Particle *p);
void updateVelocity(Particle *p1, Particle *p2);
double distance(Particle p1, Particle p2);

int main() {
    Particle particles[N];
    int i, j, t;

    //Initialize particles
    for (i = 0; i < N; i++) {
        particles[i].x = rand() % WIDTH;
        particles[i].y = rand() % HEIGHT;
        particles[i].vx = rand() % 10;
        particles[i].vy = rand() % 10;
        particles[i].mass = rand() % 10;
    }

    //Simulation loop
    for (t = 0; t < 1000; t++) {
        //Update positions
        for (i = 0; i < N; i++) {
            updatePosition(&particles[i]);
        }

        //Update velocities
        for (i = 0; i < N; i++) {
            for (j = i+1; j < N; j++) {
                updateVelocity(&particles[i], &particles[j]);
            }
        }
    }

    return 0;
}

//Function implementations
void updatePosition(Particle *p) {
    p->x += p->vx * T;
    p->y += p->vy * T;
}

void updateVelocity(Particle *p1, Particle *p2) {
    double d = distance(*p1, *p2);
    double f = G * p1->mass * p2->mass / (d * d);
    double fx = f * (p2->x - p1->x) / d;
    double fy = f * (p2->y - p1->y) / d;
    p1->vx += fx / p1->mass * T;
    p1->vy += fy / p1->mass * T;
    p2->vx -= fx / p2->mass * T;
    p2->vy -= fy / p2->mass * T;
}

double distance(Particle p1, Particle p2) {
    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall updatePosition(_QWORD); // weak
__int64 __fastcall updateVelocity(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();


//----- (0000000140001540) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _QWORD v4[12]; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v5[3908]; // [rsp+80h] [rbp+0h] BYREF
  int j; // [rsp+FC4h] [rbp+F44h]
  int k; // [rsp+FC8h] [rbp+F48h]
  int i; // [rsp+FCCh] [rbp+F4Ch]

  _main(argc, argv, envp);
  for ( i = 0; i <= 99; ++i )
  {
    *(double *)&v5[40 * i - 96] = (double)(rand() % 1000);
    *(double *)&v5[40 * i - 88] = (double)(rand() % 1000);
    *(double *)&v5[40 * i - 80] = (double)(rand() % 10);
    *(double *)&v5[40 * i - 72] = (double)(rand() % 10);
    *(double *)&v5[40 * i - 64] = (double)(rand() % 10);
  }
  for ( j = 0; j <= 999; ++j )
  {
    for ( i = 0; i <= 99; ++i )
      updatePosition(&v4[5 * i]);
    for ( i = 0; i <= 99; ++i )
    {
      for ( k = i + 1; k <= 99; ++k )
        updateVelocity(&v4[5 * i], &v4[5 * k]);
    }
  }
  return 0;
}
// 140001856: using guessed type __int64 __fastcall updatePosition(_QWORD);
// 14000189D: using guessed type __int64 __fastcall updateVelocity(_QWORD, _QWORD);
// 140001BA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=89 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Encryption ; Style: unmistakable
#include<stdio.h>
#include<string.h>

//Function implementing encryption
void encrypt(char *input, char *output, int key){
    int length = strlen(input);

    for(int i=0; i<length; i++){
        if(input[i] >= 'a' && input[i] <= 'z'){
            output[i] = 'a' + ((input[i] - 'a' + key) % 26);
        }
        else if(input[i] >= 'A' && input[i] <= 'Z'){
            output[i] = 'A' + ((input[i] - 'A' + key) % 26);
        }
        else{
            output[i] = input[i];
        }
    }
    output[length] = '\0';
}

int main(){
    char input[100];
    char output[100];
    int key;

    printf("Enter string to encrypt: ");
    fgets(input, 100, stdin);

    printf("Enter key (0-25): ");
    scanf("%d", &key);

    encrypt(input, output, key);

    printf("\nOriginal string: %s", input);
    printf("\nEncrypted string: %s", output);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000174B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[112]; // [rsp+30h] [rbp-50h] BYREF
  char Buffer[112]; // [rsp+A0h] [rbp+20h] BYREF

  _main(argc, argv, envp);
  printf("Enter string to encrypt: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  printf("Enter key (0-25): ");
  scanf("%d", &v5);
  encrypt(Buffer, v6, v5);
  printf("\nOriginal string: %s", Buffer);
  printf("\nEncrypted string: %s", v6);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD, _QWORD);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pac-Man Game Clone ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>

// Game board dimensions
#define ROWS 22
#define COLS 19

// Maze layout
char maze[ROWS][COLS] = {
    "+-----------------+",
    "|-----|-------|---|",
    "|-|-|-| |-|-| | |-|",
    "| |-|-| |-|-| | |-|",
    "|-|---| | | | | |-|",
    "| | |-| | | |-| | |",
    "| | |-| | | |-| | |",
    "|-|---| | | | | |-|",
    "|-|-|-| | |-| |-|-|",
    "|-|-|-| | |-| |-|-|",
    "| | | | | |   | | |",
    "|-|-|-| | |-| |-|-|",
    "|-|-|-| | |-| |-|-|",
    "|-|---| | | | | |-|",
    "| | |-| | | |-| | |",
    "| | |-| | | |-| | |",
    "|-|---| | | | | |-|",
    "|-|-|-| |-|-| | |-|",
    "|-|-|-| |-|-| | |-|",
    "+-----------------+"
};

// Pac-man starts here
int pacman_row = 11;
int pacman_col = 9;

// Ghosts
int ghost1_row = 9;
int ghost1_col = 9;
int ghost2_row = 9;
int ghost2_col = 10;
int ghost3_row = 9;
int ghost3_col = 11;
int ghost4_row = 9;
int ghost4_col = 12;

// Scoring
int score = 0;

// Game modes
enum GameMode { PLAYING, GAME_OVER };
enum GameMode game_mode = PLAYING;

// Consume a pellet and increase the score
void eat_pellet(int row, int col) {
    maze[row][col] = ' ';
    score += 10;
}

// Move pac-man
void move_pacman(int row, int col) {
    if (maze[row][col] == '.') {
        eat_pellet(row, col);
    }
    pacman_row = row;
    pacman_col = col;
}

// Move a ghost
void move_ghost(int* row_ptr, int* col_ptr) {
    int row = *row_ptr;
    int col = *col_ptr;
    int options[4] = { 0 };
    int direction_count = 0;
    if (maze[row - 1][col] != '-') {
        options[direction_count] = 1; // Up
        direction_count++;
    }
    if (maze[row][col - 1] != '|') {
        options[direction_count] = 2; // Left
        direction_count++;
    }
    if (maze[row + 1][col] != '-') {
        options[direction_count] = 3; // Down
        direction_count++;
    }
    if (maze[row][col + 1] != '|') {
        options[direction_count] = 4; // Right
        direction_count++;
    }
    int direction = options[rand() % direction_count];
    switch (direction) {
        case 1:
            row--;
            break;
        case 2:
            col--;
            break;
        case 3:
            row++;
            break;
        case 4:
            col++;
            break;
    }
    *row_ptr = row;
    *col_ptr = col;
}

// Check for collisions between pac-man and a ghost
bool check_collision(int pacman_row, int pacman_col, int ghost_row, int ghost_col) {
    return (pacman_row == ghost_row && pacman_col == ghost_col);
}

// Display the game board
void display_board() {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (i == pacman_row && j == pacman_col) {
                printf("%c", 'C'); // Pac-man
            } else if (i == ghost1_row && j == ghost1_col) {
                printf("%c", 'G'); // Ghost 1
            } else if (i == ghost2_row && j == ghost2_col) {
                printf("%c", 'G'); // Ghost 2
            } else if (i == ghost3_row && j == ghost3_col) {
                printf("%c", 'G'); // Ghost 3
            } else if (i == ghost4_row && j == ghost4_col) {
                printf("%c", 'G'); // Ghost 4
            } else {
                printf("%c", maze[i][j]);
            }
        }
        printf("\n");
    }
    printf("Score: %d\n", score);
}

int main() {
    srand(time(NULL)); // Seed the random number generator
    while (game_mode == PLAYING) {
        // Move pac-man
        char input;
        printf("Enter direction (up/down/left/right): ");
        scanf(" %c", &input);
        int target_row = pacman_row;
        int target_col = pacman_col;
        switch (input) {
            case 'up':
                target_row--;
                break;
            case 'down':
                target_row++;
                break;
            case 'left':
                target_col--;
                break;
            case 'right':
                target_col++;
                break;
        }
        if (maze[target_row][target_col] != '|' && maze[target_row][target_col] != '-') {
            move_pacman(target_row, target_col);
        }

        // Move ghosts
        move_ghost(&ghost1_row, &ghost1_col);
        move_ghost(&ghost2_row, &ghost2_col);
        move_ghost(&ghost3_row, &ghost3_col);
        move_ghost(&ghost4_row, &ghost4_col);

        // Check for collisions
        if (check_collision(pacman_row, pacman_col, ghost1_row, ghost1_col) ||
            check_collision(pacman_row, pacman_col, ghost2_row, ghost2_col) ||
            check_collision(pacman_row, pacman_col, ghost3_row, ghost3_col) ||
            check_collision(pacman_row, pacman_col, ghost4_row, ghost4_col)) {
            game_mode = GAME_OVER;
        }

        // Check for victory
        bool has_pellets = false;
        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                if (maze[i][j] == '.') {
                    has_pellets = true;
                    break;
                }
            }
            if (has_pellets) {
                break;
            }
        }
        if (!has_pellets) {
            printf("Congratulations! You have won the game!\n");
            game_mode = GAME_OVER;
        }

        // Display the game board
        printf("\n");
        display_board();
    }

    // Game over
    printf("\nGame over. Final score: %d\n", score);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall move_pacman(_QWORD, _QWORD); // weak
__int64 __fastcall move_ghost(_QWORD, _QWORD); // weak
__int64 __fastcall check_collision(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 display_board(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

char maze[381] = "+-----------------+|-----|-------|---||-|-|-| |-|-| | |-|| |-|-| |-|-| | |-||-|---| | | | | |-|| | |-| | | |-| | || | |-| | | |-| | ||-|---| | | | | |-||-|-|-| | |-| |-|-||-|-|-| | |-| |-|-|| | | | | |   | | ||-|-|-| | |-| |-|-||-|-|-| | |-| |-|-||-|---| | | | | |-|| | |-| | | |-| | || | |-| | | |-| | ||-|---| | | | | |-||-|-|-| |-|-| | |-||-|-|-| |-|-| | |-|+-----------------+"; // weak
int pacman_row = 11; // weak
int pacman_col = 9; // weak
int ghost1_row = 9; // weak
int ghost1_col = 9; // weak
int ghost2_row = 9; // weak
int ghost2_col = 10; // weak
int ghost3_row = 9; // weak
int ghost3_col = 11; // weak
int ghost4_row = 9; // weak
int ghost4_col = 12; // weak
int score; // weak
int game_mode; // weak


//----- (0000000140001A28) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5; // [rsp+2Bh] [rbp-15h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-14h]
  unsigned int v7; // [rsp+30h] [rbp-10h]
  int j; // [rsp+34h] [rbp-Ch]
  int i; // [rsp+38h] [rbp-8h]
  char v10; // [rsp+3Fh] [rbp-1h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  while ( !game_mode )
  {
    printf("Enter direction (up/down/left/right): ");
    scanf(" %c", &v5);
    v7 = pacman_row;
    v6 = pacman_col;
    if ( maze[19 * pacman_row + pacman_col] != 124 && maze[19 * v7 + v6] != 45 )
      move_pacman(v7, v6);
    move_ghost(&ghost1_row, &ghost1_col);
    move_ghost(&ghost2_row, &ghost2_col);
    move_ghost(&ghost3_row, &ghost3_col);
    move_ghost(&ghost4_row, &ghost4_col);
    if ( (unsigned __int8)check_collision(
                            (unsigned int)pacman_row,
                            (unsigned int)pacman_col,
                            (unsigned int)ghost1_row,
                            (unsigned int)ghost1_col)
      || (unsigned __int8)check_collision(
                            (unsigned int)pacman_row,
                            (unsigned int)pacman_col,
                            (unsigned int)ghost2_row,
                            (unsigned int)ghost2_col)
      || (unsigned __int8)check_collision(
                            (unsigned int)pacman_row,
                            (unsigned int)pacman_col,
                            (unsigned int)ghost3_row,
                            (unsigned int)ghost3_col)
      || (unsigned __int8)check_collision(
                            (unsigned int)pacman_row,
                            (unsigned int)pacman_col,
                            (unsigned int)ghost4_row,
                            (unsigned int)ghost4_col) )
    {
      game_mode = 1;
    }
    v10 = 0;
    for ( i = 0; i <= 21; ++i )
    {
      for ( j = 0; j <= 18; ++j )
      {
        if ( maze[19 * i + j] == 46 )
        {
          v10 = 1;
          break;
        }
      }
      if ( v10 )
        break;
    }
    if ( v10 != 1 )
    {
      printf("Congratulations! You have won the game!\n");
      game_mode = 1;
    }
    printf("\n");
    display_board();
  }
  printf("\nGame over. Final score: %d\n", (unsigned int)score);
  return 0;
}
// 14000164A: using guessed type __int64 __fastcall move_pacman(_QWORD, _QWORD);
// 1400016AF: using guessed type __int64 __fastcall move_ghost(_QWORD, _QWORD);
// 140001866: using guessed type __int64 __fastcall check_collision(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001899: using guessed type __int64 display_board(void);
// 140001D90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400141C4: using guessed type int pacman_row;
// 1400141C8: using guessed type int pacman_col;
// 1400141CC: using guessed type int ghost1_row;
// 1400141D0: using guessed type int ghost1_col;
// 1400141D4: using guessed type int ghost2_row;
// 1400141D8: using guessed type int ghost2_col;
// 1400141DC: using guessed type int ghost3_row;
// 1400141E0: using guessed type int ghost3_col;
// 1400141E4: using guessed type int ghost4_row;
// 1400141E8: using guessed type int ghost4_col;
// 140019040: using guessed type int score;
// 140019044: using guessed type int game_mode;

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Email Client ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define constants
#define MAX_EMAILS 100
#define MAX_EMAIL_SIZE 1024

// Define email struct
typedef struct {
    char sender[256];
    char receiver[256];
    char subject[256];
    char message[MAX_EMAIL_SIZE];
} Email;

// Define global variables
Email emails[MAX_EMAILS];
int numEmails = 0;

// Declare functions
void displayMenu();
void displayEmails();
void addEmail();
void removeEmail();

int main() {
    // Initialize variables
    int choice;

    // Display menu
    do {
        displayMenu();
        printf("Enter choice: ");
        scanf("%d", &choice);

        // Handle user choice
        switch (choice) {
            case 1:
                displayEmails();
                break;
            case 2:
                addEmail();
                break;
            case 3:
                removeEmail();
                break;
            case 4:
                printf("Exiting program...\n");
                break;
            default:
                printf("Invalid choice. Please try again.\n");
        }
    } while (choice != 4);

    return 0;
}

void displayMenu() {
    printf("\n");
    printf("------ C EMAIL CLIENT ------\n");
    printf("1. View emails\n");
    printf("2. Compose email\n");
    printf("3. Remove email\n");
    printf("4. Quit\n");
}

void displayEmails() {
    // Check if there are any emails to display
    if (numEmails == 0) {
        printf("No emails to display.\n");
        return;
    }

    // Iterate through emails and display them
    printf("\n");
    printf("------ VIEW EMAILS ------\n");
    for (int i = 0; i < numEmails; i++) {
        printf("Email %d:\n", i+1);
        printf("  Sender: %s\n", emails[i].sender);
        printf("  Receiver: %s\n", emails[i].receiver);
        printf("  Subject: %s\n", emails[i].subject);
        printf("  Message: %s\n", emails[i].message);
        printf("\n");
    }
}

void addEmail() {
    // Check if there is space to add an email
    if (numEmails == MAX_EMAILS) {
        printf("Maximum number of emails reached.\n");
        return;
    }

    // Get user input for new email
    char sender[256];
    char receiver[256];
    char subject[256];
    char message[MAX_EMAIL_SIZE];

    printf("\n");
    printf("------ COMPOSE EMAIL ------\n");
    printf("Enter sender email address: ");
    scanf("%s", sender);
    printf("Enter receiver email address: ");
    scanf("%s", receiver);
    printf("Enter subject: ");
    scanf("%s", subject);
    printf("Enter message: ");
    scanf("%s", message);

    // Add new email to list
    strcpy(emails[numEmails].sender, sender);
    strcpy(emails[numEmails].receiver, receiver);
    strcpy(emails[numEmails].subject, subject);
    strcpy(emails[numEmails].message, message);

    printf("Email sent successfully.\n");
    numEmails++;
}

void removeEmail() {
    // Check if there are any emails to remove
    if (numEmails == 0) {
        printf("No emails to remove.\n");
        return;
    }

    // Get user input for email index to remove
    int emailIndex;

    printf("\n");
    printf("------ REMOVE EMAIL ------\n");
    printf("Enter index of email to remove: ");
    scanf("%d", &emailIndex);

    // Check if email index is valid
    if (emailIndex < 1 || emailIndex > numEmails) {
        printf("Invalid email index. Please try again.\n");
        return;
    }

    // Remove email from list
    for (int i = emailIndex - 1; i < numEmails - 1; i++) {
        emails[i] = emails[i+1];
    }

    printf("Email removed successfully.\n");
    numEmails--;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 displayMenu(void); // weak
__int64 displayEmails(void); // weak
__int64 addEmail(void); // weak
__int64 removeEmail(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    displayMenu();
    printf("Enter choice: ");
    scanf("%d", &v4);
    if ( v4 == 4 )
    {
      printf("Exiting program...\n");
    }
    else
    {
      if ( v4 <= 4 )
      {
        switch ( v4 )
        {
          case 3:
            removeEmail();
            continue;
          case 1:
            displayEmails();
            continue;
          case 2:
            addEmail();
            continue;
        }
      }
      printf("Invalid choice. Please try again.\n");
    }
  }
  while ( v4 != 4 );
  return 0;
}
// 14000162E: conditional instruction was optimized away because %var_4.4<3
// 140001688: using guessed type __int64 displayMenu(void);
// 1400016F1: using guessed type __int64 displayEmails(void);
// 140001855: using guessed type __int64 addEmail(void);
// 140001A3C: using guessed type __int64 removeEmail(void);
// 140001C20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#define BUFFER_SIZE 1024
#define TEST_DURATION 10
#define MEGA_BYTE 1048576

void calculate_speed(char* server_ip){
    char command[BUFFER_SIZE];
    sprintf(command, "iperf -c %s -t %d -i 1 -w 1M", server_ip, TEST_DURATION);

    printf("Testing internet speed. Please wait...\n");

    // Open a pipe to execute the command
    FILE* pipe = popen(command, "r");

    // Read in pipe output to buffer
    char buffer[BUFFER_SIZE];
    int total_bytes = 0;
    while (fgets(buffer, BUFFER_SIZE, pipe) != NULL) {
        if (buffer[0] >= '0' && buffer[0] <= '9') {
            int bytes_written;
            float mbps = 0;

            // Parse out bytes written and calculate speed
            sscanf(buffer, "%d bytes %f %*s", &bytes_written, &mbps);
            printf("%.2f Mbps\t", mbps);
            total_bytes += bytes_written;
        }
    }

    // Calculate total data received and display result
    float total_mega_byte = ((float) total_bytes / MEGA_BYTE);
    float speed = total_mega_byte / TEST_DURATION;
    printf("\nDownloaded %.2f MB in %d seconds. Average speed: %.2f Mbps\n", total_mega_byte, TEST_DURATION, speed);

    // Close pipe and clean up
    pclose(pipe);
}

int main(){
    printf("Welcome to Internet Speed Test Application\n");
    printf("Enter the IP address of the server you'd like to test: ");
    char server_ip[BUFFER_SIZE];
    scanf("%s", server_ip);

    calculate_speed(server_ip);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall calculate_speed(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001822) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[1024]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to Internet Speed Test Application\n");
  printf("Enter the IP address of the server you'd like to test: ");
  scanf("%s", v4);
  calculate_speed(v4);
  return 0;
}
// 140001668: using guessed type __int64 __fastcall calculate_speed(_QWORD);
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Rogue-like Game with Procedural Generation ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAP_SIZE 30 // The size of the map
#define MAX_ROOMS 10 // The maximum number of rooms on the map

typedef struct {
    int x, y, width, height;
} Room;

void generate_map(int map[MAP_SIZE][MAP_SIZE], Room rooms[MAX_ROOMS], int num_rooms) {
    // Initialize the map to all walls
    for (int i = 0; i < MAP_SIZE; i++) {
        for (int j = 0; j < MAP_SIZE; j++) {
            map[i][j] = '#';
        }
    }
    
    // Generate random rooms
    for (int i = 0; i < num_rooms; i++) {
        // Choose random position and size
        int x = rand() % (MAP_SIZE - 10) + 1;
        int y = rand() % (MAP_SIZE - 10) + 1;
        int width = rand() % 6 + 5;
        int height = rand() % 6 + 5;
        
        // Add room to the list of rooms
        rooms[i] = (Room) {x, y, width, height};
        
        // Carve out the room on the map
        for (int j = x; j < x + width; j++) {
            for (int k = y; k < y + height; k++) {
                map[j][k] = '.';
            }
        }
    }
    
    // Connect the rooms with corridors
    for (int i = 0; i < num_rooms - 1; i++) {
        Room r1 = rooms[i];
        Room r2 = rooms[i+1];
        
        int x1 = r1.x + r1.width/2;
        int y1 = r1.y + r1.height/2;
        int x2 = r2.x + r2.width/2;
        int y2 = r2.y + r2.height/2;
        
        while (x1 != x2) {
            if (x1 < x2) {
                x1++;
            } else {
                x1--;
            }
            map[x1][y1] = '.';
        }
        
        while (y1 != y2) {
            if (y1 < y2) {
                y1++;
            } else {
                y1--;
            }
            map[x1][y1] = '.';
        }
    }
}

int main() {
    int map[MAP_SIZE][MAP_SIZE];
    Room rooms[MAX_ROOMS];
    
    srand(time(NULL));
    
    generate_map(map, rooms, MAX_ROOMS);
    
    // Print the map
    for (int i = 0; i < MAP_SIZE; i++) {
        for (int j = 0; j < MAP_SIZE; j++) {
            printf("%c", map[j][i]);
        }
        printf("\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall generate_map(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400018D7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[160]; // [rsp+20h] [rbp-60h] BYREF
  int v6[902]; // [rsp+C0h] [rbp+40h] BYREF
  int j; // [rsp+ED8h] [rbp+E58h]
  int i; // [rsp+EDCh] [rbp+E5Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  generate_map(v6, v5, 10i64);
  for ( i = 0; i <= 29; ++i )
  {
    for ( j = 0; j <= 29; ++j )
      printf("%c", (unsigned int)v6[30 * j + i]);
    printf("\n");
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall generate_map(_QWORD, _QWORD, _QWORD);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400018D7: using guessed type char var_EC0[160];
// 1400018D7: using guessed type int var_E20[902];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Educational ; Style: rigorous
#include <stdio.h>

// function to calculate factorial of a number 
int factorial(int n) {
    if (n < 0) {
        return -1; // error handling if the number is negative
    }
    int fact = 1;
    for (int i = 1; i <= n; i++) {
        fact *= i;
    }
    return fact;
}

// function to calculate fibonacci series up to n terms
void fibonacci(int n) {
    int term1 = 0, term2 = 1;
    printf("%d %d ", term1, term2);
    for (int i = 2; i < n; i++) {
        int nextTerm = term1 + term2;
        printf("%d ", nextTerm);
        term1 = term2;
        term2 = nextTerm;
    }
}

// program to demonstrate the usage of functions
int main() {
    int choice, n;
    printf("Choose an option:\n1. Calculate Factorial\n2. Generate Fibonacci Series\n");
    scanf("%d", &choice);
    switch(choice) {
        case 1:
            printf("Enter a number: ");
            scanf("%d", &n);
            printf("Factorial of %d is %d", n, factorial(n));
            break;
        case 2:
            printf("Enter the number of terms: ");
            scanf("%d", &n);
            printf("Fibonacci Series up to %d terms: ", n);
            fibonacci(n);
            break;
        default:
            printf("Invalid option");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall factorial(_QWORD); // weak
__int64 __fastcall fibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016A4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+28h] [rbp-8h] BYREF
  int v6; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Choose an option:\n1. Calculate Factorial\n2. Generate Fibonacci Series\n");
  scanf("%d", &v6);
  if ( v6 == 1 )
  {
    printf("Enter a number: ");
    scanf("%d", &v5);
    v3 = factorial(v5);
    printf("Factorial of %d is %d", v5, v3);
  }
  else if ( v6 == 2 )
  {
    printf("Enter the number of terms: ");
    scanf("%d", &v5);
    printf("Fibonacci Series up to %d terms: ", v5);
    fibonacci(v5);
  }
  else
  {
    printf("Invalid option");
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall factorial(_QWORD);
// 140001629: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: Claude Shannon
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define constants
#define MAX_PRODUCTS 1000
#define MAX_NAME_LEN 50

// Define structures
struct Product {
    char name[MAX_NAME_LEN];
    int quantity;
};

struct Warehouse {
    struct Product products[MAX_PRODUCTS];
    int num_products;
};

// Define global variables
struct Warehouse warehouse;

// Define functions
void addProduct(char* name, int quantity) {
    // Check if warehouse is full
    if (warehouse.num_products == MAX_PRODUCTS) {
        printf("Sorry, warehouse is full.\n");
        return;
    }

    // Add product to warehouse
    struct Product new_product;
    strcpy(new_product.name, name);
    new_product.quantity = quantity;
    warehouse.products[warehouse.num_products] = new_product;
    warehouse.num_products++;

    printf("Product added successfully!\n");
}

void removeProduct(char* name, int quantity) {
    // Find product in warehouse
    int i, index = -1;
    for (i = 0; i < warehouse.num_products; i++) {
        if (strcmp(warehouse.products[i].name, name) == 0) {
            index = i;
            break;
        }
    }

    // Check if product was found
    if (index == -1) {
        printf("Sorry, product not found.\n");
        return;
    }

    // Check if quantity is valid
    if (quantity > warehouse.products[index].quantity) {
        printf("Sorry, not enough product in warehouse.\n");
        return;
    }

    // Remove product from warehouse
    warehouse.products[index].quantity -= quantity;

    printf("Product removed successfully!\n");
}

void displayProducts() {
    // Check if warehouse is empty
    if (warehouse.num_products == 0) {
        printf("Warehouse is empty.\n");
        return;
    }

    // Display products in warehouse
    int i;
    for (i = 0; i < warehouse.num_products; i++) {
        printf("%s: %d\n", warehouse.products[i].name, warehouse.products[i].quantity);
    }
}

// Define main function
int main() {
    // Initialize warehouse
    warehouse.num_products = 0;

    // Display menu
    printf("Welcome to the Warehouse Management System!\n\n");
    printf("1. Add product\n");
    printf("2. Remove product\n");
    printf("3. Display products\n");
    printf("4. Exit\n");

    // Loop until user chooses to exit
    int choice;
    while (1) {
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                // Get product name and quantity from user
                char name[MAX_NAME_LEN];
                int quantity;
                printf("Enter product name: ");
                scanf("%s", name);
                printf("Enter quantity: ");
                scanf("%d", &quantity);

                // Add product to warehouse
                addProduct(name, quantity);

                break;

            case 2:
                // Get product name and quantity from user
                printf("Enter product name: ");
                scanf("%s", name);
                printf("Enter quantity: ");
                scanf("%d", &quantity);

                // Remove product from warehouse
                removeProduct(name, quantity);

                break;

            case 3:
                // Display products in warehouse
                displayProducts();

                break;

            case 4:
                // Exit program
                printf("Goodbye!\n");
                exit(0);

            default:
                printf("Invalid choice.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addProduct(_QWORD, _QWORD); // weak
__int64 __fastcall removeProduct(_QWORD, _QWORD); // weak
__int64 displayProducts(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

int dword_140026B00; // weak


//----- (0000000140001857) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  char v3[56]; // [rsp+20h] [rbp-40h] BYREF
  unsigned int v4; // [rsp+58h] [rbp-8h] BYREF
  int v5; // [rsp+5Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  dword_140026B00 = 0;
  printf("Welcome to the Warehouse Management System!\n\n");
  printf("1. Add product\n");
  printf("2. Remove product\n");
  printf("3. Display products\n");
  printf("4. Exit\n");
  while ( 1 )
  {
    printf("\nEnter your choice: ");
    scanf("%d", &v5);
    if ( v5 == 4 )
    {
      printf("Goodbye!\n");
      exit(0);
    }
    if ( v5 > 4 )
    {
LABEL_12:
      printf("Invalid choice.\n");
    }
    else
    {
      switch ( v5 )
      {
        case 3:
          displayProducts();
          break;
        case 1:
          printf("Enter product name: ");
          scanf("%s", v3);
          printf("Enter quantity: ");
          scanf("%d", &v4);
          addProduct(v3, v4);
          break;
        case 2:
          printf("Enter product name: ");
          scanf("%s", v3);
          printf("Enter quantity: ");
          scanf("%d", &v4);
          removeProduct(v3, v4);
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 1400018FF: conditional instruction was optimized away because %var_4.4<3
// 1400015E2: using guessed type __int64 __fastcall addProduct(_QWORD, _QWORD);
// 1400016B0: using guessed type __int64 __fastcall removeProduct(_QWORD, _QWORD);
// 1400017C2: using guessed type __int64 displayProducts(void);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140026B00: using guessed type int dword_140026B00;

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int num, guess, attempts = 0;
    srand(time(0));
    num = rand() % 100 + 1; // Generate random number between 1 and 100

    printf("Guess the number between 1 and 100\n");

    do {
        scanf("%d", &guess);
        attempts++;

        if (guess > num)
        {
            printf("Lower\n");
        }

        if (guess < num)
        {
            printf("Higher\n");
        }

        if (guess == num)
        {
            printf("\nCongratulations! You guessed the number in %d attempts\n", attempts);
        }

    } while (guess != num);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  int v6; // [rsp+28h] [rbp-8h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 0;
  v3 = time(0i64);
  srand(v3);
  v6 = rand() % 100 + 1;
  printf("Guess the number between 1 and 100\n");
  do
  {
    scanf("%d", &v5);
    ++v7;
    if ( v6 < v5 )
      printf("Lower\n");
    if ( v6 > v5 )
      printf("Higher\n");
    if ( v6 == v5 )
      printf("\nCongratulations! You guessed the number in %d attempts\n", v7);
  }
  while ( v6 != v5 );
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define N 20   // size of grid
#define P 0.5  // probability of opening a site

// helper function to determine whether a site is open or not
int is_open(int row, int col, int *grid) {
    return *(grid + row * N + col);
}

// helper function to open a site
void open(int row, int col, int *grid) {
    *(grid + row * N + col) = 1;
}

// helper function to print the grid
void print_grid(int *grid) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (*(grid + i * N + j) == 0) {
                printf(". ");
            } else {
                printf("O ");
            }
        }
        printf("\n");
    }
}

// function to run the percolation simulation
void simulate_percolation() {
    // allocate memory for the grid
    int *grid = malloc(N * N * sizeof(int));
    if (grid == NULL) {
        printf("Error: Unable to allocate memory for grid\n");
        exit(1);
    }

    // initialize the grid to be all closed
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            *(grid + i * N + j) = 0;
        }
    }

    // seed the random number generator
    srand(time(NULL));

    // open sites with probability P
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if ((double)rand() / RAND_MAX < P) {
                open(i, j, grid);
            }
        }
    }

    // check if top and bottom of grid are connected
    int top_connected = 0;
    for (int j = 0; j < N; j++) {
        if (is_open(0, j, grid)) {
            top_connected = 1;
            break;
        }
    }
    int bottom_connected = 0;
    for (int j = 0; j < N; j++) {
        if (is_open(N-1, j, grid)) {
            bottom_connected = 1;
            break;
        }
    }

    // print the grid and whether it percolates or not
    printf("Simulation Complete!\n");
    print_grid(grid);
    if (top_connected && bottom_connected) {
        printf("The system percolates!\n");
    } else {
        printf("The system does not percolate.\n");
    }

    // free memory for grid
    free(grid);
}

// main function
int main() {
    simulate_percolation();
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 simulate_percolation(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001890) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  simulate_percolation();
  return 0;
}
// 1400016BD: using guessed type __int64 simulate_percolation(void);
// 140001960: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature monitor ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define LOWER_BOUND -50
#define UPPER_BOUND 150
#define NUM_READINGS 10
#define MIN_ACCEPTABLE_TEMP 0
#define MAX_ACCEPTABLE_TEMP 100

float readings[NUM_READINGS];

float get_temperature_reading() {
    float temp_reading = (float) (rand() % (UPPER_BOUND - LOWER_BOUND + 1)) + LOWER_BOUND;
    return temp_reading;
}

float get_average_temperature() {
    float total = 0;
    for(int i = 0; i < NUM_READINGS; i++) {
        total += readings[i];
    }
    float average = total / NUM_READINGS;
    return average;
}

int main(void) {
    srand(time(0));
    printf("Welcome to the temperature monitor!\n\n");
    for(int i = 0; i < NUM_READINGS; i++) {
        float temp_reading = get_temperature_reading();
        readings[i] = temp_reading;
        printf("Temperature reading %d: %.2f °C\n", i+1, temp_reading);
    }
    printf("\n");
    float average_temp = get_average_temperature();
    printf("The average temperature reading is: %.2f °C\n", average_temp);
    if(average_temp < MIN_ACCEPTABLE_TEMP || average_temp > MAX_ACCEPTABLE_TEMP) {
        printf("ALERT: Average temperature is outside acceptable range!\n");
    } else {
        printf("Average temperature is within acceptable range.\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
double get_temperature_reading(void); // weak
double get_average_temperature(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

float readings[16]; // weak


//----- (000000014000166E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  unsigned int v4; // eax
  float v6; // [rsp+24h] [rbp-Ch]
  float v7; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4 = time(0i64);
  srand(v4);
  printf("Welcome to the temperature monitor!\n\n");
  for ( i = 0; i <= 9; ++i )
  {
    *(double *)v3.m128i_i64 = get_temperature_reading();
    v6 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
    readings[i] = v6;
    v3 = (__m128i)COERCE_UNSIGNED_INT64(v6);
    printf("Temperature reading %d: %.2f °C\n", (unsigned int)(i + 1), v6);
  }
  printf("\n");
  *(double *)v3.m128i_i64 = get_average_temperature();
  v7 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
  printf("The average temperature reading is: %.2f °C\n", v7);
  if ( v7 >= 0.0 && v7 <= 100.0 )
    printf("Average temperature is within acceptable range.\n");
  else
    printf("ALERT: Average temperature is outside acceptable range!\n");
  return 0;
}
// 1400016A9: variable 'v3' is possibly undefined
// 1400015B0: using guessed type double get_temperature_reading(void);
// 140001602: using guessed type double get_average_temperature(void);
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type float readings[16];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: introspective
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main() {
  int counter;
  float speed;
  clock_t start_t, end_t; // variables to store clock ticks
  double total_t; // variables to store total time

  printf("Welcome to the Internet Speed Test Application!\n");

  // run the test 3 times and output average
  for (counter = 1; counter <= 3; counter++) {
    printf("\nTest #%d:\n", counter);

    // get start time
    start_t = clock();

    // simulate downloading a 100MB file
    for (int i = 0; i < 100000000; i++);

    // get end time
    end_t = clock();

    // calculate total time and convert to seconds
    total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;

    printf("Download speed was %.2f MB/s\n", 100 / total_t);
    speed += 100 / total_t;
  }
  
  printf("\n\nAverage speed: %.2f MB/s\n\n", speed/3);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// clock_t __cdecl clock();


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  double v5; // [rsp+20h] [rbp-20h]
  clock_t v6; // [rsp+30h] [rbp-10h]
  int j; // [rsp+34h] [rbp-Ch]
  float v8; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Internet Speed Test Application!\n");
  for ( i = 1; i <= 3; ++i )
  {
    printf("\nTest #%d:\n", (unsigned int)i);
    v6 = clock();
    for ( j = 0; j <= 99999999; ++j )
      ;
    v5 = (double)(clock() - v6) / 1000.0;
    printf("Download speed was %.2f MB/s\n", 100.0 / v5);
    v3 = 100.0 / v5 + v8;
    v8 = v3;
  }
  printf("\n\nAverage speed: %.2f MB/s\n\n", (float)(v8 / 3.0));
  return 0;
}
// 140001646: variable 'v8' is possibly undefined
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Medical Store Management System ; Style: light-weight
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Medicine {
    char name[50];
    int quantity;
    float price;
};

void addMedicine(struct Medicine *medicines, int *num) {
    struct Medicine medicine;
    printf("Enter name of medicine: ");
    scanf("%s", medicine.name);
    printf("Enter quantity: ");
    scanf("%d", &medicine.quantity);
    printf("Enter price: ");
    scanf("%f", &medicine.price);
    medicines[*num] = medicine;
    *num += 1;
    printf("Medicine added successfully!\n");
}

void searchMedicine(struct Medicine *medicines, int num) {
    char name[50];
    printf("Enter name of medicine: ");
    scanf("%s", name);
    for (int i = 0; i < num; i++) {
        if (strcmp(name, medicines[i].name) == 0) {
            printf("Name: %s\nQuantity: %d\nPrice: %.2f\n", medicines[i].name, medicines[i].quantity, medicines[i].price);
            return;
        }
    }
    printf("Medicine not found!\n");
}

void sellMedicine(struct Medicine *medicines, int num) {
    char name[50];
    printf("Enter name of medicine: ");
    scanf("%s", name);
    for (int i = 0; i < num; i++) {
        if (strcmp(name, medicines[i].name) == 0) {
            int quantity;
            printf("Enter quantity: ");
            scanf("%d", &quantity);
            if (quantity > medicines[i].quantity) {
                printf("Only %d %s available!\n", medicines[i].quantity, medicines[i].name);
                return;
            }
            medicines[i].quantity -= quantity;
            printf("Total price: %.2f\n", medicines[i].price * quantity);
            return;
        }
    }
    printf("Medicine not found!\n");
}

void displayMedicines(struct Medicine *medicines, int num) {
    printf("Medicines in stock:\n");
    printf("Name\tQuantity\tPrice\n");
    for (int i = 0; i < num; i++) {
        printf("%s\t%d\t\t%.2f\n", medicines[i].name, medicines[i].quantity, medicines[i].price);
    }
}

int main() {
    int choice, num = 0;
    struct Medicine medicines[100];

    while (1) {
        printf("1. Add medicine\n");
        printf("2. Search medicine\n");
        printf("3. Sell medicine\n");
        printf("4. Display medicines\n");
        printf("5. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                addMedicine(medicines, &num);
                break;
            case 2:
                searchMedicine(medicines, num);
                break;
            case 3:
                sellMedicine(medicines, num);
                break;
            case 4:
                displayMedicines(medicines, num);
                break;
            case 5:
                exit(0);
            default:
                printf("Invalid choice!\n");
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addMedicine(_QWORD, _QWORD); // weak
__int64 __fastcall searchMedicine(_QWORD, _QWORD); // weak
__int64 __fastcall sellMedicine(_QWORD, _QWORD); // weak
__int64 __fastcall displayMedicines(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001AE5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[6008]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v5; // [rsp+1798h] [rbp+1718h] BYREF
  int v6; // [rsp+179Ch] [rbp+171Ch] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  while ( 1 )
  {
    printf("1. Add medicine\n");
    printf("2. Search medicine\n");
    printf("3. Sell medicine\n");
    printf("4. Display medicines\n");
    printf("5. Exit\n");
    printf("Enter choice: ");
    scanf("%d", &v6);
    switch ( v6 )
    {
      case 1:
        addMedicine(v4, &v5);
        break;
      case 2:
        searchMedicine(v4, v5);
        break;
      case 3:
        sellMedicine(v4, v5);
        break;
      case 4:
        displayMedicines(v4, v5);
        break;
      case 5:
        exit(0);
      default:
        printf("Invalid choice!\n");
        break;
    }
    printf("\n");
  }
}
// 1400015E2: using guessed type __int64 __fastcall addMedicine(_QWORD, _QWORD);
// 1400016F0: using guessed type __int64 __fastcall searchMedicine(_QWORD, _QWORD);
// 14000181C: using guessed type __int64 __fastcall sellMedicine(_QWORD, _QWORD);
// 140001A05: using guessed type __int64 __fastcall displayMedicines(_QWORD, _QWORD);
// 140001CE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: Dennis Ritchie
#include<stdio.h>
int main(){
  int rows, i, j, k;
  
  printf("Enter the number of rows: ");
  scanf("%d", &rows);
  
  // Outer loop to iterate number of rows
  for(i=1; i<=rows; i++){
    
    // Inner loop to print spaces
    for(j=i; j<=rows; j++){
      printf(" ");
    }
    
    // Inner loop to print asterisks
    for(k=i; k>=1; k--){
      printf("* ");
    }
    
    printf("\n");
  }
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-10h] BYREF
  int k; // [rsp+24h] [rbp-Ch]
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of rows: ");
  scanf("%d", &v4);
  for ( i = 1; i <= v4; ++i )
  {
    for ( j = i; j <= v4; ++j )
      printf(" ");
    for ( k = i; k > 0; --k )
      printf("* ");
    printf("\n");
  }
  return 0;
}
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: cheerful
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>

struct Entry{
    char date[11];
    char time[6];
    char content[101];
};

int main(){
    printf("\n*************************************");
    printf("\n*** Welcome to your Digital Diary! ***");
    printf("\n*************************************\n");
    
    int choice;
    do{
        printf("\nWhat would you like to do?\n");
        printf("\n1. Create a new entry\n2. View previous entries\n3. Exit\n");
        printf("\nEnter your choice (1, 2 or 3): ");
        scanf("%d", &choice);
        
        switch(choice){
            case 1:{
                struct Entry newEntry;
                
                //Getting current date and time
                time_t t = time(NULL);
                struct tm tm = *localtime(&t);
                sprintf(newEntry.date, "%02d/%02d/%04d", tm.tm_mday, tm.tm_mon+1, tm.tm_year+1900);
                sprintf(newEntry.time, "%02d:%02d", tm.tm_hour, tm.tm_min);
                
                //Getting entry content
                printf("\nEnter your entry:\n");
                fflush(stdin);
                fgets(newEntry.content, sizeof(newEntry.content), stdin);
                
                //Saving entry to file
                FILE *fp;
                fp = fopen("diary.txt", "a");
                fprintf(fp, "%s %s - %s\n", newEntry.date, newEntry.time, newEntry.content);
                fclose(fp);
                
                printf("\nEntry successfully saved!\n");
                break;
            }
            case 2:{
                FILE *fp;
                fp = fopen("diary.txt", "r");
                
                if(fp == NULL){
                    printf("\nNo previous entries found!\n");
                    break;
                }
                
                char c;
                while((c = getc(fp)) != EOF){
                    printf("%c", c);
                }
                
                fclose(fp);
                break;
            }
            case 3:
                printf("\nThank you for using Digital Diary! Have a nice day!\n");
                exit(0);
            default:
                printf("\nInvalid choice! Please try again.\n");
                break;
        }
    }while(choice != 3);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static struct tm *__cdecl localtime(const time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getc(FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fflush(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016A6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  struct tm *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  __int64 v7; // [rsp+20h] [rbp-60h]
  __int64 v8; // [rsp+30h] [rbp-50h]
  __int64 v9; // [rsp+38h] [rbp-48h]
  __int64 v10; // [rsp+40h] [rbp-40h]
  char Buffer[11]; // [rsp+60h] [rbp-20h] BYREF
  char v12[6]; // [rsp+6Bh] [rbp-15h] BYREF
  char v13[103]; // [rsp+71h] [rbp-Fh] BYREF
  time_t Time; // [rsp+D8h] [rbp+58h] BYREF
  int v15; // [rsp+E4h] [rbp+64h] BYREF
  FILE *Stream; // [rsp+E8h] [rbp+68h]
  char v17; // [rsp+F7h] [rbp+77h]
  FILE *v18; // [rsp+F8h] [rbp+78h]

  _main(argc, argv, envp);
  printf("\n*************************************");
  printf("\n*** Welcome to your Digital Diary! ***");
  printf("\n*************************************\n");
  do
  {
    printf("\nWhat would you like to do?\n");
    printf("\n1. Create a new entry\n2. View previous entries\n3. Exit\n");
    printf("\nEnter your choice (1, 2 or 3): ");
    scanf("%d", &v15);
    if ( v15 == 3 )
    {
      printf("\nThank you for using Digital Diary! Have a nice day!\n");
      exit(0);
    }
    if ( v15 > 3 )
      goto LABEL_14;
    if ( v15 == 1 )
    {
      Time = time(0i64);
      v3 = localtime(&Time);
      v8 = *(_QWORD *)&v3->tm_sec;
      v9 = *(_QWORD *)&v3->tm_hour;
      v10 = *(_QWORD *)&v3->tm_mon;
      LODWORD(v7) = HIDWORD(v10) + 1900;
      sprintf(Buffer, "%02d/%02d/%04d", HIDWORD(v9), (unsigned int)(v10 + 1), v7);
      sprintf(v12, "%02d:%02d", (unsigned int)v9, HIDWORD(v8));
      printf("\nEnter your entry:\n");
      v4 = __acrt_iob_func(0);
      fflush(v4);
      v5 = __acrt_iob_func(0);
      fgets(v13, 101, v5);
      Stream = fopen("diary.txt", "a");
      fprintf_0(Stream, "%s %s - %s\n", Buffer, v12, v13);
      fclose(Stream);
      printf("\nEntry successfully saved!\n");
      continue;
    }
    if ( v15 == 2 )
    {
      v18 = fopen("diary.txt", "r");
      if ( v18 )
      {
        while ( 1 )
        {
          v17 = getc(v18);
          if ( v17 == -1 )
            break;
          printf("%c", (unsigned int)v17);
        }
        fclose(v18);
      }
      else
      {
        printf("\nNo previous entries found!\n");
      }
    }
    else
    {
LABEL_14:
      printf("\nInvalid choice! Please try again.\n");
    }
  }
  while ( v15 != 3 );
  return 0;
}
// 1400017BE: variable 'v7' is possibly undefined
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cat Language Translator ; Style: optimized
#include <stdio.h>
#include <string.h>

int main()
{
    char c[100], cat[100];
    int i, j, k;

    /* Prompt user to enter a sentence in English */
    printf("Enter a sentence in English: ");
    gets(c);

    /* Convert the sentence to C Cat language */
    j = 0;
    for (i = 0; i < strlen(c); i++) {

        /* If the character is a space, just add it to the C Cat sentence */
        if (c[i] == ' ') {
            cat[j++] = ' ';
        }

        /* If the character is a vowel, add "meow" after it */
        else if (c[i] == 'a' || c[i] == 'e' || c[i] == 'i' 
            || c[i] == 'o' || c[i] == 'u' || c[i] == 'A' 
            || c[i] == 'E' || c[i] == 'I' || c[i] == 'O' 
            || c[i] == 'U') {
            cat[j++] = c[i];
            cat[j++] = 'm';
            cat[j++] = 'e';
            cat[j++] = 'o';
            cat[j++] = 'w';
        }

        /* If the character is a consonant, add "meow" before it */
        else if ((c[i] >= 'a' && c[i] <= 'z') 
                || (c[i] >= 'A' && c[i] <= 'Z')) {
            cat[j++] = 'm';
            cat[j++] = 'e';
            cat[j++] = 'o';
            cat[j++] = 'w';
            cat[j++] = c[i];
        }
    }

    /* Add a period at the end of the C Cat sentence */
    cat[j++] = '.';

    /* Print out the C Cat sentence */
    printf("Your sentence in C Cat language is: ");
    for (k = 0; k < j; k++) {
        printf("%c", cat[k]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// __int64 __fastcall gets(_QWORD); weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  char v16[112]; // [rsp+20h] [rbp-60h]
  char Str[100]; // [rsp+90h] [rbp+10h] BYREF
  int j; // [rsp+F4h] [rbp+74h]
  int v19; // [rsp+F8h] [rbp+78h]
  int i; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter a sentence in English: ");
  gets(Str);
  v19 = 0;
  for ( i = 0; i < strlen(Str); ++i )
  {
    if ( Str[i] == 32 )
    {
      v3 = v19++;
      v16[v3] = 32;
    }
    else if ( Str[i] == 97
           || Str[i] == 101
           || Str[i] == 105
           || Str[i] == 111
           || Str[i] == 117
           || Str[i] == 65
           || Str[i] == 69
           || Str[i] == 73
           || Str[i] == 79
           || Str[i] == 85 )
    {
      v4 = v19++;
      v16[v4] = Str[i];
      v5 = v19++;
      v16[v5] = 109;
      v6 = v19++;
      v16[v6] = 101;
      v7 = v19++;
      v16[v7] = 111;
      v8 = v19++;
      v16[v8] = 119;
    }
    else if ( Str[i] > 96 && Str[i] <= 122 || Str[i] > 64 && Str[i] <= 90 )
    {
      v9 = v19++;
      v16[v9] = 109;
      v10 = v19++;
      v16[v10] = 101;
      v11 = v19++;
      v16[v11] = 111;
      v12 = v19++;
      v16[v12] = 119;
      v13 = v19++;
      v16[v13] = Str[i];
    }
  }
  v14 = v19++;
  v16[v14] = 46;
  printf("Your sentence in C Cat language is: ");
  for ( j = 0; j < v19; ++j )
    printf("%c", (unsigned int)v16[j]);
  return 0;
}
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140008B10: using guessed type __int64 __fastcall gets(_QWORD);
// 140001591: using guessed type char Str[100];
// 140001591: using guessed type char var_F0[112];

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Encryption ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_MSG_LEN 50

/* Function that encrypts the message using a simple substitution cypher */
void encrypt(char msg[], int key) {
   int i;
   char ch;

   for(i = 0; msg[i] != '\0'; ++i) {
      ch = msg[i];

      if(ch >= 'a' && ch <= 'z') {
         ch = ch + key;

         if(ch > 'z') {
            ch = ch - 'z' + 'a' - 1;
         }

         msg[i] = ch;
      }
      else if(ch >= 'A' && ch <= 'Z') {
         ch = ch + key;

         if(ch > 'Z') {
            ch = ch - 'Z' + 'A' - 1;
         }

         msg[i] = ch;
      }
   }
}

/* Function that decrypts the message using the same key as the encryption */
void decrypt(char msg[], int key) {
   int i;
   char ch;

   for(i = 0; msg[i] != '\0'; ++i) {
      ch = msg[i];

      if(ch >= 'a' && ch <= 'z') {
         ch = ch - key;

         if(ch < 'a') {
            ch = ch + 'z' - 'a' + 1;
         }

         msg[i] = ch;
      }
      else if(ch >= 'A' && ch <= 'Z') {
         ch = ch - key;

         if(ch < 'A') {
            ch = ch + 'Z' - 'A' + 1;
         }

         msg[i] = ch;
      }
   }
}

/* Main function that demonstrates the encryption and decryption */
int main() {
   char msg[MAX_MSG_LEN];
   int key;

   // Get input from user
   printf("Enter message to be encrypted: ");
   fgets(msg, MAX_MSG_LEN, stdin);
   printf("Enter key: ");
   scanf("%d", &key);

   // Remove newline character from message input
   msg[strcspn(msg, "\n")] = '\0';

   // Encrypt message and print result
   encrypt(msg, key);
   printf("Encrypted message: %s\n", msg);

   // Decrypt message using the same key and print result
   decrypt(msg, key);
   printf("Decrypted message: %s\n", msg);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
__int64 __fastcall decrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000177A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v5; // [rsp+2Ch] [rbp-44h] BYREF
  char Buffer[64]; // [rsp+30h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  printf("Enter message to be encrypted: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 50, v3);
  printf("Enter key: ");
  scanf("%d", &v5);
  Buffer[strcspn(Buffer, "\n")] = 0;
  encrypt(Buffer, v5);
  printf("Encrypted message: %s\n", Buffer);
  decrypt(Buffer, v5);
  printf("Decrypted message: %s\n", Buffer);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 1400016B0: using guessed type __int64 __fastcall decrypt(_QWORD, _QWORD);
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000177A: using guessed type char Buffer[64];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Disk space analyzer ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

// Function to calculate the size of a directory
long long int calculateDirectorySize(const char *path) {
    long long int total = 0;
    DIR *dir = opendir(path);
    if (dir == NULL) {
        return 0;
    }
    struct dirent *entry;
    struct stat info;
    while ((entry = readdir(dir)) != NULL) {
        char *filePath;
        asprintf(&filePath, "%s/%s", path, entry->d_name);
        if (stat(filePath, &info) == 0) {
            if (S_ISDIR(info.st_mode)) {
                if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {
                    total += calculateDirectorySize(filePath);
                }
            } else {
                total += info.st_size;
            }
        }
        free(filePath);
    }
    closedir(dir);
    return total;
}

// Function to convert file size from bytes to human readable format (KB, MB, GB, etc.)
void convertFileSize(long long int fileSize, char *formattedSize) {
    const char *sizeUnits[] = {"B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"};
    int sizeUnitIndex = 0;
    while (fileSize > 1024 && sizeUnitIndex < 8) {
        fileSize /= 1024;
        sizeUnitIndex++;
    }
    sprintf(formattedSize, "%lld %s", fileSize, sizeUnits[sizeUnitIndex]);
}

int main(int argc, char **argv) {
    // Default configuration values
    const char *path = ".";
    long long int minFileSize = 0;
    long long int maxFileSize = 0x7FFFFFFFFFFFFFFF; // Max value of signed long long
    int showDirectories = 0;
    int showHiddenFiles = 0;
    // Parse command line arguments
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-path") == 0 && i + 1 < argc) {
            path = argv[i + 1];
        } else if (strcmp(argv[i], "-min-size") == 0 && i + 1 < argc) {
            minFileSize = atoll(argv[i + 1]);
        } else if (strcmp(argv[i], "-max-size") == 0 && i + 1 < argc) {
            maxFileSize = atoll(argv[i + 1]);
        } else if (strcmp(argv[i], "-show-directories") == 0) {
            showDirectories = 1;
        } else if (strcmp(argv[i], "-show-hidden") == 0) {
            showHiddenFiles = 1;
        }
    }
    // Calculate size of each file and directory in the specified path
    long long int totalSize = 0;
    DIR *dir = opendir(path);
    if (dir == NULL) {
        fprintf(stderr, "Could not open directory %s\n", path);
        return 1;
    }
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        char *filePath;
        asprintf(&filePath, "%s/%s", path, entry->d_name);
        struct stat info;
        if (stat(filePath, &info) == 0) {
            if (!showHiddenFiles && entry->d_name[0] == '.') {
                continue;
            }
            if (S_ISDIR(info.st_mode)) {
                if (showDirectories) {
                    long long int dirSize = calculateDirectorySize(filePath);
                    if (dirSize >= minFileSize && dirSize <= maxFileSize) {
                        char formattedSize[20];
                        convertFileSize(dirSize, formattedSize);
                        printf("%s %s/\n", formattedSize, entry->d_name);
                    }
                    totalSize += dirSize;
                }
            } else {
                if (info.st_size >= minFileSize && info.st_size <= maxFileSize) {
                    char formattedSize[20];
                    convertFileSize(info.st_size, formattedSize);
                    printf("%s %s\n", formattedSize, entry->d_name);
                }
                totalSize += info.st_size;
            }
        }
        free(filePath);
    }
    // Print total size of path
    char formattedSize[20];
    convertFileSize(totalSize, formattedSize);
    printf("Total size: %s\n", formattedSize);
    closedir(dir);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall calculateDirectorySize(_QWORD); // weak
__int64 __fastcall convertFileSize(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall opendir(char *Path); // idb
__int64 __fastcall readdir(_QWORD); // weak
__int64 __fastcall closedir(void *Block); // idb
static int __cdecl stat(const char *const FileName, struct stat *const Stat);
__int64 asprintf(_QWORD, const char *, ...); // weak
__int64 __cdecl atoll(const char *String);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl free(void *Block);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400017F9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  struct stat v5; // [rsp+20h] [rbp-D0h] BYREF
  char v6[32]; // [rsp+50h] [rbp-A0h] BYREF
  char v7[24]; // [rsp+70h] [rbp-80h] BYREF
  char *FileName; // [rsp+88h] [rbp-68h] BYREF
  char v9[24]; // [rsp+90h] [rbp-60h] BYREF
  __int64 v10; // [rsp+A8h] [rbp-48h]
  __int64 v11; // [rsp+B0h] [rbp-40h]
  void *Block; // [rsp+B8h] [rbp-38h]
  __int64 v13; // [rsp+C0h] [rbp-30h]
  int i; // [rsp+CCh] [rbp-24h]
  int v15; // [rsp+D0h] [rbp-20h]
  int v16; // [rsp+D4h] [rbp-1Ch]
  __int64 v17; // [rsp+D8h] [rbp-18h]
  __int64 v18; // [rsp+E0h] [rbp-10h]
  char *Path; // [rsp+E8h] [rbp-8h]

  _main(argc, argv, envp);
  Path = ".";
  v18 = 0i64;
  v17 = 0x7FFFFFFFFFFFFFFFi64;
  v16 = 0;
  v15 = 0;
  for ( i = 1; i < argc; ++i )
  {
    if ( !strcmp(argv[i], "-path") && argc > i + 1 )
    {
      Path = (char *)argv[i + 1];
    }
    else if ( !strcmp(argv[i], "-min-size") && argc > i + 1 )
    {
      v18 = atoll(argv[i + 1]);
    }
    else if ( !strcmp(argv[i], "-max-size") && argc > i + 1 )
    {
      v17 = atoll(argv[i + 1]);
    }
    else if ( !strcmp(argv[i], "-show-directories") )
    {
      v16 = 1;
    }
    else if ( !strcmp(argv[i], "-show-hidden") )
    {
      v15 = 1;
    }
  }
  v13 = 0i64;
  Block = (void *)opendir(Path);
  if ( !Block )
  {
    v3 = __acrt_iob_func(2u);
    fprintf_0(v3, "Could not open directory %s\n", Path);
    return 1;
  }
  while ( 1 )
  {
    v11 = readdir(Block);
    if ( !v11 )
      break;
    asprintf(&FileName, "%s/%s", Path, (const char *)(v11 + 8));
    if ( stat(FileName, &v5) )
      goto LABEL_32;
    if ( v15 || *(_BYTE *)(v11 + 8) != 46 )
    {
      if ( (v5.st_mode & 0xF000) == 0x4000 )
      {
        if ( v16 )
        {
          v10 = calculateDirectorySize(FileName);
          if ( v10 >= v18 && v10 <= v17 )
          {
            convertFileSize(v10, v7);
            printf("%s %s/\n", v7, (const char *)(v11 + 8));
          }
          v13 += v10;
        }
      }
      else
      {
        if ( v18 <= v5.st_size && v17 >= v5.st_size )
        {
          convertFileSize(v5.st_size, v6);
          printf("%s %s\n", v6, (const char *)(v11 + 8));
        }
        v13 += v5.st_size;
      }
LABEL_32:
      free(FileName);
    }
  }
  convertFileSize(v13, v9);
  printf("Total size: %s\n", v9);
  closedir(Block);
  return 0;
}
// 140001617: using guessed type __int64 __fastcall calculateDirectorySize(_QWORD);
// 140001724: using guessed type __int64 __fastcall convertFileSize(_QWORD, _QWORD);
// 140001C80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002EE0: using guessed type __int64 __fastcall readdir(_QWORD);
// 1400034F0: using guessed type __int64 asprintf(_QWORD, const char *, ...);

// nfuncs=163 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: QR code reader ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct qr_code {
    char code_data[256];
    int code_length;
} QRCode;

void read_code(QRCode *code) {
    printf("Please enter the QR code: ");
    fgets(code->code_data, 256, stdin);
    code->code_length = strlen(code->code_data);
    code->code_data[code->code_length - 1] = '\0'; // remove newline character
}

void decode_qr(QRCode *code) {
    printf("Decoding QR code '%s'...\n", code->code_data);
    // implementation of decoding algorithm goes here
}

int main() {
    QRCode code;
    read_code(&code);
    decode_qr(&code);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall read_code(_QWORD); // weak
__int64 __fastcall decode_qr(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001630) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[272]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  read_code(v4);
  decode_qr(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall read_code(_QWORD);
// 140001607: using guessed type __int64 __fastcall decode_qr(_QWORD);
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Light Controller ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    printf("Traffic light controller\n");

    // initialize variables
    int red_time = 10; // in seconds
    int yellow_time = 3; // in seconds
    int green_time = 15; // in seconds
    int total_time = red_time + yellow_time + green_time;
    time_t start_time = time(NULL);

    while (1)
    {
        int elapsed_time = time(NULL) - start_time;

        // red light
        if (elapsed_time % total_time < red_time)
        {
            printf("RED\n");
        }
        // yellow light
        else if (elapsed_time % total_time < red_time + yellow_time)
        {
            printf("YELLOW\n");
        }
        // green light
        else
        {
            printf("GREEN\n");
        }

        // wait for one second
        sleep(1);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-1Ch]
  int v5; // [rsp+28h] [rbp-18h]

  _main(argc, argv, envp);
  printf("Traffic light controller\n");
  v5 = time(0i64);
  while ( 1 )
  {
    v4 = time(0i64) - v5;
    if ( v4 % 28 >= 10 )
    {
      if ( v4 % 28 >= 13 )
        printf("GREEN\n");
      else
        printf("YELLOW\n");
    }
    else
    {
      printf("RED\n");
    }
    sleep(1i64);
  }
}
// 140001730: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002790: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Wi-Fi Signal Strength Analyzer ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_DEVICES 50
#define MAX_SSID_LENGTH 32

typedef struct {
    char ssid[MAX_SSID_LENGTH];
    int signal_strength;
} wifi_device;

int main() {

    // Initialize random seed
    srand(0);

    wifi_device devices[MAX_DEVICES];
    int num_devices = 0;

    // Simulate detecting some devices
    printf("Detecting Wi-Fi devices...\n");
    for (int i = 0; i < MAX_DEVICES; i++) {
        if (rand() % 2 == 0) {
            snprintf(devices[num_devices].ssid, MAX_SSID_LENGTH, "Device %d", i);
            devices[num_devices].signal_strength = rand() % 101;
            printf("%s detected with signal strength %d%%\n", devices[num_devices].ssid, devices[num_devices].signal_strength);
            num_devices++;
        }
    }

    // Allow the user to configure the minimum signal strength to display
    int min_signal_strength;
    printf("Enter minimum signal strength to display (0-100): ");
    scanf("%d", &min_signal_strength);

    // Display the devices above the minimum signal strength
    printf("Devices with signal strength greater than %d%%:\n", min_signal_strength);
    printf("SSID\tSignal Strength\n");
    for (int i = 0; i < num_devices; i++) {
        if (devices[i].signal_strength >= min_signal_strength) {
            printf("%s\t%d%%\n", devices[i].ssid, devices[i].signal_strength);
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int snprintf(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (000000014000162C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[21]; // [rsp+2Ch] [rbp-54h] BYREF
  _BYTE v5[1732]; // [rsp+80h] [rbp+0h] BYREF
  int j; // [rsp+744h] [rbp+6C4h]
  unsigned int i; // [rsp+748h] [rbp+6C8h]
  int v8; // [rsp+74Ch] [rbp+6CCh]

  _main(argc, argv, envp);
  srand(0);
  v8 = 0;
  printf("Detecting Wi-Fi devices...\n");
  for ( i = 0; (int)i <= 49; ++i )
  {
    if ( (rand() & 1) == 0 )
    {
      snprintf((char *const)&v4[9 * v8 + 1], 0x20ui64, "Device %d", i);
      *(_DWORD *)&v5[36 * v8 - 48] = rand() % 101;
      printf(
        "%s detected with signal strength %d%%\n",
        (const char *)&v4[9 * v8 + 1],
        *(unsigned int *)&v5[36 * v8 - 48]);
      ++v8;
    }
  }
  printf("Enter minimum signal strength to display (0-100): ");
  scanf("%d", v4);
  printf("Devices with signal strength greater than %d%%:\n", (unsigned int)v4[0]);
  printf("SSID\tSignal Strength\n");
  for ( j = 0; j < v8; ++j )
  {
    if ( *(_DWORD *)&v5[36 * j - 48] >= v4[0] )
      printf("%s\t%d%%\n", (const char *)&v4[9 * j + 1], *(unsigned int *)&v5[36 * j - 48]);
  }
  return 0;
}
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data structures visualization ; Style: accurate
#include <stdio.h>
#include <stdlib.h>

// Define a node structure for a linked list
struct node {
    int data;
    struct node *next;
};

// Function to create a new node
struct node* createNode(int data) {
    struct node *newNode = malloc(sizeof(struct node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to add a new node to the beginning of the linked list
void addToBeginning(struct node **head, int data) {
    struct node *newNode = createNode(data);
    newNode->next = *head;
    *head = newNode;
}

// Function to add a new node to the end of the linked list
void addToEnd(struct node **head, int data) {
    struct node *newNode = createNode(data);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    struct node *current = *head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = newNode;
}

// Function to delete a node from the linked list by value
void deleteNode(struct node **head, int value) {
    struct node *prev = NULL;
    struct node *current = *head;
    while (current != NULL) {
        if (current->data == value) {
            if (prev == NULL) {
                *head = current->next;
            } else {
                prev->next = current->next;
            }
            free(current);
            return;
        }
        prev = current;
        current = current->next;
    }
}

// Function to print the linked list
void printList(struct node *head) {
    struct node *current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

int main() {
    struct node *head = NULL;

    // Add nodes to the linked list
    addToEnd(&head, 5);
    addToBeginning(&head, 2);
    addToEnd(&head, 8);
    addToBeginning(&head, 1);
    addToEnd(&head, 9);
    addToBeginning(&head, 4);
    addToEnd(&head, 3);

    // Print the linked list
    printf("Linked List:\n");
    printList(head);

    // Delete nodes from the linked list
    deleteNode(&head, 1);
    deleteNode(&head, 9);
    deleteNode(&head, 5);

    // Print the linked list again
    printf("Linked List after deleting nodes with values 1, 9, and 5:\n");
    printList(head);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall addToBeginning(_QWORD, _QWORD); // weak
__int64 __fastcall addToEnd(_QWORD, _QWORD); // weak
__int64 __fastcall deleteNode(_QWORD, _QWORD); // weak
__int64 __fastcall printList(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001751) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v4 = 0i64;
  addToEnd(&v4, 5i64);
  addToBeginning(&v4, 2i64);
  addToEnd(&v4, 8i64);
  addToBeginning(&v4, 1i64);
  addToEnd(&v4, 9i64);
  addToBeginning(&v4, 4i64);
  addToEnd(&v4, 3i64);
  printf("Linked List:\n");
  printList(v4);
  deleteNode(&v4, 1i64);
  deleteNode(&v4, 9i64);
  deleteNode(&v4, 5i64);
  printf("Linked List after deleting nodes with values 1, 9, and 5:\n");
  printList(v4);
  return 0;
}
// 1400015C9: using guessed type __int64 __fastcall addToBeginning(_QWORD, _QWORD);
// 140001607: using guessed type __int64 __fastcall addToEnd(_QWORD, _QWORD);
// 140001675: using guessed type __int64 __fastcall deleteNode(_QWORD, _QWORD);
// 1400016FB: using guessed type __int64 __fastcall printList(_QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: active
#include <stdio.h>

int binarySearch(int arr[], int left, int right, int target) {
    if (right >= left) {
        int mid = left + (right - left) / 2;
 
        if (arr[mid] == target)
            return mid;
 
        if (arr[mid] > target)
            return binarySearch(arr, left, mid - 1, target);
 
        return binarySearch(arr, mid + 1, right, target);
    }
 
    return -1;
}

int main() {
    int arr[] = { 2, 3, 4, 10, 40 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 10;
    int result = binarySearch(arr, 0, n - 1, target);
    (result == -1) ? printf("Element is not present in array")
                   : printf("Element is present at index %d", result);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001651) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[5]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v5; // [rsp+34h] [rbp-Ch]
  int v6; // [rsp+38h] [rbp-8h]
  int v7; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 2;
  v4[1] = 3;
  v4[2] = 4;
  v4[3] = 10;
  v4[4] = 40;
  v7 = 5;
  v6 = 10;
  v5 = ((__int64 (__fastcall *)(int *, _QWORD, __int64, __int64))binarySearch)(v4, 0i64, 4i64, 10i64);
  if ( v5 == -1 )
    printf("Element is not present in array");
  else
    printf("Element is present at index %d", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue ; Style: brave
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

int queue[MAX_SIZE];
int front = -1;
int rear = -1;

void insert(int value) {
  if ((front == 0 && rear == MAX_SIZE - 1) || (front == rear + 1)) {
    printf("Queue Overflow\n");
    return;
  }

  if (front == -1) {
    front = 0;
    rear = 0;
  } else {
    if (rear == MAX_SIZE - 1) {
      rear = 0;
    } else {
      rear++;
    }
  }

  queue[rear] = value;
}

void delete() {
  if (front == -1) {
    printf("Queue Underflow\n");
    return;
  }

  printf("Deleted item is: %d\n", queue[front]);

  if (front == rear) {
    front = -1;
    rear = -1;
  } else {
    if (front == MAX_SIZE - 1) {
      front = 0;
    } else {
      front++;
    }
  }
}

void display() {
  int i;

  if (front == -1) {
    printf("Queue is empty\n");
    return;
  }

  printf("Queue elements are:\n");

  if (rear >= front) {
    for (i = front; i <= rear; i++) {
      printf("%d ", queue[i]);
    }
  } else {
    for (i = front; i < MAX_SIZE; i++) {
      printf("%d ", queue[i]);
    }

    for (i = 0; i <= rear; i++) {
      printf("%d ", queue[i]);
    }
  }

  printf("\n");
}

int main() {
  int choice, value;

  while (1) {
    printf("1. Insert\n");
    printf("2. Delete\n");
    printf("3. Display\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);

    switch (choice) {
      case 1:
        printf("Enter the value to be inserted: ");
        scanf("%d", &value);
        insert(value);
        break;
      case 2:
        delete();
        break;
      case 3:
        display();
        break;
      case 4:
        printf("Exiting the program\n");
        exit(0);
        break;
      default:
        printf("Invalid choice\n");
    }
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall insert(_QWORD); // weak
__int64 delete(void); // weak
__int64 display(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (000000014000184E) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // [rsp+28h] [rbp-8h] BYREF
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    printf("1. Insert\n");
    printf("2. Delete\n");
    printf("3. Display\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    if ( v4 == 4 )
    {
      printf("Exiting the program\n");
      exit(0);
    }
    if ( v4 > 4 )
    {
LABEL_12:
      printf("Invalid choice\n");
    }
    else
    {
      switch ( v4 )
      {
        case 3:
          display();
          break;
        case 1:
          printf("Enter the value to be inserted: ");
          scanf("%d", &v3);
          insert(v3);
          break;
        case 2:
          delete();
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 1400018D1: conditional instruction was optimized away because %var_4.4<3
// 1400015E2: using guessed type __int64 __fastcall insert(_QWORD);
// 140001690: using guessed type __int64 delete(void);
// 140001731: using guessed type __int64 display(void);
// 140001A00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mailing list manager ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define structure for each node in the mailing list
typedef struct node {
    char name[50];
    char email[50];
    struct node* next;
} node;

// Function to create a new node (member) in the mailing list
node* createNode(char name[], char email[]) {
    node* newNode = (node*) malloc(sizeof(node));
    strcpy(newNode->name, name);
    strcpy(newNode->email, email);
    newNode->next = NULL;
    return newNode;
}

// Function to add a new member to the mailing list
void addMember(node** head, char name[], char email[]) {
    if (*head == NULL) {
        // If there is no member in the list yet, create a new node and point the head to it
        node* newNode = createNode(name, email);
        *head = newNode;
        return;
    }
    // If there are already members in the list, traverse through the list until the end
    node* temp = *head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    // Add the new member to the end of the list
    node* newNode = createNode(name, email);
    temp->next = newNode;
}

// Function to remove a member from the mailing list
void removeMember(node** head, char name[]) {
    node* temp = *head;
    node* prev = NULL;
    // Traverse through the list to look for the member to be removed
    while (temp != NULL && strcmp(temp->name, name) != 0) {
        prev = temp;
        temp = temp->next;
    }
    if (temp == NULL) {
        // Member not found in the list
        printf("Member not found in the mailing list.\n");
        return;
    }
    if (prev == NULL) {
        // If the member to be removed is the first member in the list, point the head to the next member
        *head = temp->next;
    } else {
        // Remove the member by bypassing it in the list
        prev->next = temp->next;
    }
    free(temp); // Free up the memory used by the removed member
}

// Function to print all members in the mailing list
void printList(node* head) {
    node* temp = head;
    printf("Mailing list:\n");
    while (temp != NULL) {
        printf("%s, %s\n", temp->name, temp->email);
        temp = temp->next;
    }
}

int main() {
    node* head = NULL; // Initialize the mailing list to be empty
    char choice, name[50], email[50];
    do {
        printf("\nEnter A to add a member, R to remove a member, P to print the mailing list, or Q to quit: ");
        scanf(" %c", &choice);
        switch(choice) {
            case 'A': // Adding a new member
            case 'a':
                printf("Enter the member's name: ");
                scanf(" %[^\n]s", name);
                printf("Enter the member's email: ");
                scanf(" %[^\n]s", email);
                addMember(&head, name, email);
                printf("New member %s added to the mailing list.\n", name);
                break;
            case 'R': // Removing a member
            case 'r':
                printf("Enter the name of the member to be removed: ");
                scanf(" %[^\n]s", name);
                removeMember(&head, name);
                break;
            case 'P': // Printing the mailing list
            case 'p':
                printList(head);
                break;
            case 'Q': // Quitting the program
            case 'q':
                printf("Exiting the mailing list manager.\n");
                break;
            default: // Wrong input
                printf("Invalid input, please try again.\n");
        }
    } while (choice != 'Q' && choice != 'q');
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addMember(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall removeMember(_QWORD, _QWORD); // weak
__int64 __fastcall printList(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017CF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[64]; // [rsp+20h] [rbp-80h] BYREF
  char v5[55]; // [rsp+60h] [rbp-40h] BYREF
  char v6; // [rsp+97h] [rbp-9h] BYREF
  __int64 v7; // [rsp+98h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v7 = 0i64;
  do
  {
    printf("\nEnter A to add a member, R to remove a member, P to print the mailing list, or Q to quit: ");
    scanf(" %c", &v6);
    switch ( v6 )
    {
      case 'A':
      case 'a':
        printf("Enter the member's name: ");
        scanf(" %[^\n]s", v5);
        printf("Enter the member's email: ");
        scanf(" %[^\n]s", v4);
        addMember(&v7, v5, v4);
        printf("New member %s added to the mailing list.\n", v5);
        break;
      case 'P':
      case 'p':
        printList(v7);
        break;
      case 'Q':
      case 'q':
        printf("Exiting the mailing list manager.\n");
        break;
      case 'R':
      case 'r':
        printf("Enter the name of the member to be removed: ");
        scanf(" %[^\n]s", v5);
        removeMember(&v7, v5);
        break;
      default:
        printf("Invalid input, please try again.\n");
        break;
    }
  }
  while ( v6 != 81 && v6 != 113 );
  return 0;
}
// 14000163A: using guessed type __int64 __fastcall addMember(_QWORD, _QWORD, _QWORD);
// 1400016C7: using guessed type __int64 __fastcall removeMember(_QWORD, _QWORD);
// 14000176E: using guessed type __int64 __fastcall printList(_QWORD);
// 140001A00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: medieval
#include <stdio.h>

int main() {
    int n = 5;
    // Printing the top half part
    for (int i = n; i >= 1; i--) {
        printf("%*c", i, ' '); // Printing the left spaces
        for (int j = 1; j <= i + n - 1; j++) {
            if (j <= i) {
                printf("%c", '*'); // Printing asterisks for the left part
            } else {
                printf("%c", '+'); // Printing plus signs for the right part
            }
        }
        printf("\n");
    }

    // Printing the bottom half part
    for (int i = 2; i <= n; i++) {
        printf("%*c", i, ' '); // Printing the left spaces
        for (int j = 1; j <= i + n - 1; j++) {
            if (j <= i) {
                printf("%c", '+'); // Printing plus signs for the left part
            } else {
                printf("%c", '*'); // Printing asterisks for the right part
            }
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int m; // [rsp+30h] [rbp-10h]
  int k; // [rsp+34h] [rbp-Ch]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  for ( i = 5; i > 0; --i )
  {
    printf("%*c", i, 32i64);
    for ( j = 1; j < i + 5; ++j )
    {
      if ( j > i )
        printf("%c", 43i64);
      else
        printf("%c", 42i64);
    }
    printf("\n");
  }
  for ( k = 2; k <= 5; ++k )
  {
    printf("%*c", k, 32i64);
    for ( m = 1; m < k + 5; ++m )
    {
      if ( m > k )
        printf("%c", 42i64);
      else
        printf("%c", 43i64);
    }
    printf("\n");
  }
  return 0;
}
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Clustering Algorithm Implementation ; Style: realistic
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>

#define MAX_POINTS 1000
#define DIMENSIONS 5
#define MAX_ITERATIONS 100

struct point{
    float coordinates[DIMENSIONS];
    int cluster;
};

int main(){
    srand(time(NULL));

    struct point points[MAX_POINTS];
    int k, n, i, j;
    float distance, min_distance;
    int iterations = 0;
    int cluster_changed;

    printf("Enter number of points: ");
    scanf("%d", &n);

    printf("Enter value of k: ");
    scanf("%d", &k);

    for(i=0;i<n;i++){
        for(j=0;j<DIMENSIONS;j++){
            points[i].coordinates[j] = (float)(rand()%10000)/100.0;
        }
        points[i].cluster = -1;
    }

    struct point centroids[k];
    for(i=0;i<k;i++){
        centroids[i] = points[rand()%n];
    }

    while(iterations<MAX_ITERATIONS){
        for(i=0;i<n;i++){
            min_distance = INFINITY;
            for(j=0;j<k;j++){
                distance = 0;
                for(int d=0;d<DIMENSIONS;d++){
                    distance += pow(points[i].coordinates[d] - centroids[j].coordinates[d], 2);
                }
                distance = sqrt(distance);
                if(distance<min_distance){
                    min_distance = distance;
                    points[i].cluster = j;
                }
            }
        }

        cluster_changed = 0;

        for(j=0;j<k;j++){
            float new_centroid[DIMENSIONS] = {0};
            int count = 0;
            for(i=0;i<n;i++){
                if(points[i].cluster==j){
                    for(int d=0;d<DIMENSIONS;d++){
                        new_centroid[d] += points[i].coordinates[d];
                    }
                    count++;
                }
            }
            for(int d=0;d<DIMENSIONS;d++){
                new_centroid[d] /= count;
            }
            if(memcmp(centroids[j].coordinates, new_centroid, DIMENSIONS*sizeof(float)) != 0){
                cluster_changed = 1;
                for(int d=0;d<DIMENSIONS;d++){
                    centroids[j].coordinates[d] = new_centroid[d];
                }
            }
        }

        if(!cluster_changed) break;

        iterations++;        
    }

    for(j=0;j<k;j++){
        printf("Centroid %d: ", j);
        for(int d=0;d<DIMENSIONS;d++){
            printf("%f ", centroids[j].coordinates[d]);
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl pow(double X, double Y);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // xmm0_4
  void *v5; // rsp
  int v6; // eax
  __int64 *v7; // rcx
  __int64 *v8; // r8
  __int64 v9; // rdx
  double v10; // xmm0_8
  float v11; // xmm0_4
  __int64 Buf2[2]; // [rsp+20h] [rbp-60h] BYREF
  int v14; // [rsp+30h] [rbp-50h]
  int v15; // [rsp+38h] [rbp-48h] BYREF
  int v16[17]; // [rsp+3Ch] [rbp-44h] BYREF
  _BYTE v17[23936]; // [rsp+80h] [rbp+0h] BYREF
  __int64 *v18; // [rsp+5E00h] [rbp+5D80h]
  __int64 v19; // [rsp+5E08h] [rbp+5D88h]
  int jj; // [rsp+5E10h] [rbp+5D90h]
  int ii; // [rsp+5E14h] [rbp+5D94h]
  int n; // [rsp+5E18h] [rbp+5D98h]
  int m; // [rsp+5E1Ch] [rbp+5D9Ch]
  int v24; // [rsp+5E20h] [rbp+5DA0h]
  int k; // [rsp+5E24h] [rbp+5DA4h]
  int v26; // [rsp+5E28h] [rbp+5DA8h]
  int v27; // [rsp+5E2Ch] [rbp+5DACh]
  float v28; // [rsp+5E30h] [rbp+5DB0h]
  float v29; // [rsp+5E34h] [rbp+5DB4h]
  int j; // [rsp+5E38h] [rbp+5DB8h]
  int i; // [rsp+5E3Ch] [rbp+5DBCh]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v27 = 0;
  printf("Enter number of points: ");
  scanf("%d", &v15);
  printf("Enter value of k: ");
  scanf("%d", v16);
  for ( i = 0; i < v15; ++i )
  {
    for ( j = 0; j <= 4; ++j )
    {
      *(float *)&v4 = (float)(rand() % 10000) / 100.0;
      v16[6 * i + 1 + j] = v4;
    }
    *(_DWORD *)&v17[24 * i - 44] = -1;
  }
  v19 = v16[0] - 1i64;
  v5 = alloca(16 * ((unsigned __int64)(24i64 * v16[0] + 15) >> 4));
  v18 = Buf2;
  for ( i = 0; i < v16[0]; ++i )
  {
    v6 = rand();
    v7 = &v18[3 * i];
    v8 = (__int64 *)&v17[24 * (v6 % v15) - 64];
    v9 = v8[1];
    *v7 = *v8;
    v7[1] = v9;
    v7[2] = v8[2];
  }
  while ( v27 <= 99 )
  {
    for ( i = 0; i < v15; ++i )
    {
      v28 = INFINITY;
      for ( j = 0; j < v16[0]; ++j )
      {
        v29 = 0.0;
        for ( k = 0; k <= 4; ++k )
        {
          v10 = pow((float)(*(float *)&v16[6 * i + 1 + k] - *((float *)&v18[3 * j] + k)), 2.0);
          *(float *)&v10 = v10 + v29;
          v29 = *(float *)&v10;
        }
        v11 = sqrt(v29);
        v29 = v11;
        if ( v28 > v11 )
        {
          v28 = v29;
          *(_DWORD *)&v17[24 * i - 44] = j;
        }
      }
    }
    v26 = 0;
    for ( j = 0; j < v16[0]; ++j )
    {
      Buf2[0] = 0i64;
      Buf2[1] = 0i64;
      v14 = 0;
      v24 = 0;
      for ( i = 0; i < v15; ++i )
      {
        if ( j == *(_DWORD *)&v17[24 * i - 44] )
        {
          for ( m = 0; m <= 4; ++m )
            *((float *)Buf2 + m) = *(float *)&v16[6 * i + 1 + m] + *((float *)Buf2 + m);
          ++v24;
        }
      }
      for ( n = 0; n <= 4; ++n )
        *((float *)Buf2 + n) = *((float *)Buf2 + n) / (float)v24;
      if ( memcmp(&v18[3 * j], Buf2, 0x14ui64) )
      {
        v26 = 1;
        for ( ii = 0; ii <= 4; ++ii )
          *((_DWORD *)&v18[3 * j] + ii) = *((_DWORD *)Buf2 + ii);
      }
    }
    if ( !v26 )
      break;
    ++v27;
  }
  for ( j = 0; j < v16[0]; ++j )
  {
    printf("Centroid %d: ", (unsigned int)j);
    for ( jj = 0; jj <= 4; ++jj )
      printf("%f ", *((float *)&v18[3 * j] + jj));
    printf("\n");
  }
  return 0;
}
// 140001DD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define ROWS 10
#define COLS 15

int maze[ROWS][COLS] = {
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1},
    {1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1},
    {1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1},
    {1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1},
    {1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1},
    {1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1},
    {1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1},
    {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

bool solveMaze(int row, int col)
{
    if (maze[row][col] == 9) {
        return true;
    }

    if (maze[row][col] == 1) {
        return false;
    }

    maze[row][col] = 1;

    if (row != 0) {
        if (solveMaze(row - 1, col)) {
            return true;
        }
    }

    if (row != ROWS - 1) {
        if (solveMaze(row + 1, col)) {
            return true;
        }
    }

    if (col != 0) {
        if (solveMaze(row, col - 1)) {
            return true;
        }
    }

    if (col != COLS - 1) {
        if (solveMaze(row, col + 1)) {
            return true;
        }
    }

    maze[row][col] = 0;

    return false;
}

int main()
{
    int i, j;

    printf("The maze:\n");

    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            if (maze[i][j] == 0) {
                printf(". ");
            } else {
                printf("%d ", maze[i][j]);
            }
        }
        printf("\n");
    }

    if (solveMaze(1, 1)) {
        printf("\nSolution found!\n");

        for (i = 0; i < ROWS; i++) {
            for (j = 0; j < COLS; j++) {
                if (maze[i][j] == 0) {
                    printf(". ");
                } else {
                    printf("%d ", maze[i][j]);
                }
            }
            printf("\n");
        }
    } else {
        printf("\nSolution not found!\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall solveMaze(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

unsigned int maze[152] =
{
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u
}; // weak


//----- (0000000140001703) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int j; // [rsp+28h] [rbp-8h]
  int m; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]
  int k; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("The maze:\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 14; ++j )
    {
      if ( maze[15 * i + j] )
        printf("%d ", maze[15 * i + j]);
      else
        printf(". ");
    }
    printf("\n");
  }
  if ( (unsigned __int8)solveMaze(1i64, 1i64) )
  {
    printf("\nSolution found!\n");
    for ( k = 0; k <= 9; ++k )
    {
      for ( m = 0; m <= 14; ++m )
      {
        if ( maze[15 * k + m] )
          printf("%d ", maze[15 * k + m]);
        else
          printf(". ");
      }
      printf("\n");
    }
  }
  else
  {
    printf("\nSolution not found!\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall solveMaze(_QWORD, _QWORD);
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A020: using guessed type unsigned int maze[152];

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Compression algorithms ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TREE_HT 64

typedef struct MinHeapNode {
    char data;
    unsigned freq;
    struct MinHeapNode *left, *right;
} MinHeapNode;

typedef struct MinHeap {
    unsigned size;
    unsigned capacity;
    MinHeapNode **array;
} MinHeap;

MinHeapNode* newNode(char data, unsigned freq)
{
    MinHeapNode* temp
        = (MinHeapNode*)malloc
(sizeof(MinHeapNode));
 
    temp->left = temp->right = NULL;
    temp->data = data;
    temp->freq = freq;
 
    return temp;
}
 
MinHeap* createMinHeap(unsigned capacity)
{
    MinHeap* minHeap
        = (MinHeap*)malloc(sizeof(MinHeap));
 
    minHeap->size = 0;
 
    minHeap->capacity = capacity;
 
    minHeap->array
        = (MinHeapNode**)malloc(minHeap->
capacity * sizeof(MinHeapNode*));
    return minHeap;
}
void swapMinHeapNode(MinHeapNode** a,
                     MinHeapNode** b)
{
    MinHeapNode* t = *a;
    *a = *b;
    *b = t;
}
void minHeapify(MinHeap* minHeap, int idx)
{
    int smallest = idx;
    int left = 2 * idx + 1;
    int right = 2 * idx + 2;
 
    if (left < minHeap->size && minHeap->
array[left]->freq < minHeap->array[smallest]->freq)
        smallest = left;
 
    if (right < minHeap->size && minHeap->
array[right]->freq < minHeap->array[smallest]->freq)
        smallest = right;
 
    if (smallest != idx) {
        swapMinHeapNode(&minHeap->array[smallest],
                        &minHeap->array[idx]);
        minHeapify(minHeap, smallest);
    }
}

int isSizeOne(MinHeap* minHeap)
{
    return (minHeap->size == 1);
}

MinHeapNode* extractMin(MinHeap* minHeap)
{
    MinHeapNode* temp = minHeap->array[0];
    minHeap->array[0] = minHeap->array[minHeap->size - 1];
 
    --minHeap->size;
    minHeapify(minHeap, 0);
 
    return temp;
}

void insertMinHeap(MinHeap* minHeap, MinHeapNode* minHeapNode)
{
    ++minHeap->size;
    int i = minHeap->size - 1;
 
    while (i && minHeapNode->freq < minHeap->array[(i - 1) / 2]->freq) {
        minHeap->array[i] = minHeap->array[(i - 1) / 2];
        i = (i - 1) / 2;
    }
 
    minHeap->array[i] = minHeapNode;
}

void buildMinHeap(MinHeap* minHeap)
{
    int n = minHeap->size - 1;
    int i;
 
    for (i = (n - 1) / 2; i >= 0; --i)
        minHeapify(minHeap, i);
}

int isLeaf(MinHeapNode* root)
{
    return !(root->left) && !(root->right);
}

MinHeap* createAndBuildMinHeap(char data[], int freq[], int size)
{
    MinHeap* minHeap = createMinHeap(size);
 
    for (int i = 0; i < size; ++i)
        minHeap->array[i]
            = newNode(data[i], freq[i]);
 
    minHeap->size = size;
    buildMinHeap(minHeap);
 
    return minHeap;
}
MinHeapNode* buildHuffmanTree(char data[], int freq[], int size)
{
    MinHeapNode *left, *right, *top;
    MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);
 
    while (!isSizeOne(minHeap)) {
 
        left = extractMin(minHeap);
        right = extractMin(minHeap);
 
        top = newNode('$', left->freq + right->freq);
 
        top->left = left;
        top->right = right;
 
        insertMinHeap(minHeap, top);
    }
 
    return extractMin(minHeap);
}

void printArr(int arr[], int n)
{
    for (int i = 0; i < n; ++i)
        printf("%d", arr[i]);
 
    printf("\n");
}

void printCodes(MinHeapNode* root, int arr[], int top)
{
    if (root->left) {
 
        arr[top] = 0;
        printCodes(root->left, arr, top + 1);
    }
 
    if (root->right) {
 
        arr[top] = 1;
        printCodes(root->right, arr, top + 1);
    }
 
    if (isLeaf(root)) {
 
        printf("%c: ", root->data);
        printArr(arr, top);
    }
}

void HuffmanCodes(char data[], int freq[], int size)
{
    MinHeapNode* root
        = buildHuffmanTree(data, freq, size);
 
    int arr[MAX_TREE_HT], top = 0;
 
    printCodes(root, arr, top);
}

int main()
{
    char arr[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
    int freq[] = { 5, 9, 12, 13, 16, 45 };
    int size = sizeof(arr) / sizeof(arr[0]);
    HuffmanCodes(arr, freq, size);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall HuffmanCodes(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001C79) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[9]; // [rsp+20h] [rbp-30h] BYREF
  int v5; // [rsp+46h] [rbp-Ah] BYREF
  __int16 v6; // [rsp+4Ah] [rbp-6h]
  int v7; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5 = 1684234849;
  v6 = 26213;
  v4[0] = 5;
  v4[1] = 9;
  v4[2] = 12;
  v4[3] = 13;
  v4[4] = 16;
  v4[5] = 45;
  v7 = 6;
  HuffmanCodes(&v5, v4, 6i64);
  return 0;
}
// 140001BFE: using guessed type __int64 __fastcall HuffmanCodes(_QWORD, _QWORD, _QWORD);
// 140001DA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=151 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System process viewer ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Process {
        char name[32]; // process name
        int pid; // process ID
        float cpu; // CPU usage
        float mem; // Memory usage
} Process;

typedef struct ProcessList {
        Process* processes; // list of processes
        int numProcesses; // number of processes in the list
} ProcessList;

char getRandomChar()
{
    int x = rand() % 26;
    char c = 'a' + x;
    return c;
}

void fillRandomString(char* str, int len)
{
    for (int i = 0; i < len - 1; ++i)
    {
        str[i] = getRandomChar();
    }
    str[len - 1] = '\0';
}

ProcessList getRandomProcessList(int numProcesses)
{
    ProcessList processList = {0};
    processList.numProcesses = numProcesses;
    processList.processes = (Process*)malloc(numProcesses * sizeof(Process));

    for (int i = 0; i < numProcesses; ++i)
    {
        Process* process = processList.processes + i;

        fillRandomString(process->name, sizeof(process->name));

        process->pid = rand() % 100000;
        process->cpu = (float)(rand() % 1000) / 10.0;
        process->mem = (float)(rand() % 1000) / 10.0;
    }

    return processList;
}

void printProcessList(ProcessList* processList)
{
    printf("----------------------------------------------\n");
    printf("| %-32s | %-5s | %-5s |\n", "NAME", "PID", "CPU%");
    printf("----------------------------------------------\n");

    for (int i = 0; i < processList->numProcesses; ++i)
    {
        Process* process = processList->processes + i;

        printf("| %-32s | %-5d | %-5.1f |\n", process->name, process->pid, process->cpu);
    }

    printf("----------------------------------------------\n");
}

int main()
{
    srand(42); // Seed random number generator

    ProcessList processList = getRandomProcessList(10);

    printf("Welcome to the most amazing process viewer ever created!\n");

    while (1)
    {
        printf("\nEnter any key to refresh the process list (q to quit): ");
        char ch;
        scanf(" %c", &ch);

        if (ch == 'q')
        {
            break;
        }

        printProcessList(&processList);
    }

    free(processList.processes); // Clean up

    printf("Goodbye!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall getRandomProcessList(_QWORD, _QWORD); // weak
__int64 __fastcall printProcessList(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// void __cdecl free(void *Block);


//----- (00000001400018EB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Fh] [rbp-11h] BYREF
  void *Block[2]; // [rsp+30h] [rbp-10h] BYREF

  _main(argc, argv, envp);
  srand(0x2Au);
  getRandomProcessList(Block, 10i64);
  printf("Welcome to the most amazing process viewer ever created!\n");
  while ( 1 )
  {
    printf("\nEnter any key to refresh the process list (q to quit): ");
    scanf(" %c", &v4);
    if ( v4 == 113 )
      break;
    printProcessList(Block);
  }
  free(Block[0]);
  printf("Goodbye!\n");
  return 0;
}
// 140001682: using guessed type __int64 __fastcall getRandomProcessList(_QWORD, _QWORD);
// 140001802: using guessed type __int64 __fastcall printProcessList(_QWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Math exercise ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(){
    printf("Welcome to the Grateful Mathematics Exercise Program!\n\n");
    printf("This program is designed to help you improve your math skills while also cultivating gratitude.\n\n");
    printf("For each math problem, you will be prompted with a random addition question. You will then be asked to express gratitude for something related to the answer.\n\n");
    
    srand(time(0)); //Set random seed
    
    int num1, num2, ans;
    char response[50];
    int count = 0;
    while(count < 10){ //Loop through 10 math questions
        num1 = rand() % 11; //Generate random numbers between 0 and 10
        num2 = rand() % 11;
        ans = num1 + num2;
        
        printf("What is %d + %d?\n", num1, num2);
        scanf("%d", &response);
        
        if(response == ans){
            printf("Congratulations, that is correct! Now it's time to express gratitude.\n");
            printf("What are you grateful for that is related to the number %d?\n", ans);
            getchar(); //Clear input buffer
            fgets(response, sizeof(response), stdin); //Get user response
            printf("That's wonderful, keep up the gratitude!\n\n");
            count++;
        }
        else{
            printf("Sorry, that is incorrect. Please try again.\n\n");
        }
    }
    
    printf("Congratulations, you have completed the Grateful Mathematics Exercise Program!\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  FILE *v4; // rax
  char Buffer[64]; // [rsp+20h] [rbp-50h] BYREF
  unsigned int v7; // [rsp+60h] [rbp-10h]
  unsigned int v8; // [rsp+64h] [rbp-Ch]
  unsigned int v9; // [rsp+68h] [rbp-8h]
  int v10; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Grateful Mathematics Exercise Program!\n\n");
  printf("This program is designed to help you improve your math skills while also cultivating gratitude.\n\n");
  printf(
    "For each math problem, you will be prompted with a random addition question. You will then be asked to express grati"
    "tude for something related to the answer.\n"
    "\n");
  v3 = time(0i64);
  srand(v3);
  v10 = 0;
  while ( v10 <= 9 )
  {
    v9 = rand() % 11;
    v8 = rand() % 11;
    v7 = v9 + v8;
    printf("What is %d + %d?\n", v9, v8);
    scanf("%d", Buffer);
    if ( (char *)(int)v7 == Buffer )
    {
      printf("Congratulations, that is correct! Now it's time to express gratitude.\n");
      printf("What are you grateful for that is related to the number %d?\n", v7);
      getchar();
      v4 = __acrt_iob_func(0);
      fgets(Buffer, 50, v4);
      printf("That's wonderful, keep up the gratitude!\n\n");
      ++v10;
    }
    else
    {
      printf("Sorry, that is incorrect. Please try again.\n\n");
    }
  }
  printf("Congratulations, you have completed the Grateful Mathematics Exercise Program!\n");
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital signal processing ; Style: synchronous
#include <stdio.h>

// function to calculate the average of two numbers
int average(int x, int y) {
  return (x + y)/2;
}

// function to calculate the sum of two numbers
int sum(int x, int y) {
  return x + y;
}

// function to calculate the difference between two numbers
int difference(int x, int y) {
  return x - y;
}

// function to calculate the product of two numbers
int product(int x, int y) {
  return x * y;
}

// main function
int main() {
  int a, b;
  printf("Enter two numbers: ");
  scanf("%d%d", &a, &b);
  
  // calculate the average of the two numbers
  int avg = average(a, b);
  
  // calculate the sum of the two numbers
  int s = sum(a,b);
  
  // calculate the difference between the two numbers
  int diff = difference(a, b);
  
  // calculate the product of the two numbers
  int prod = product(a,b);
  
  // display the results to the user
  printf("The average of %d and %d is: %d\n", a, b, avg);
  printf("The sum of %d and %d is: %d\n", a, b, s);
  printf("The difference between %d and %d is: %d\n", a, b, diff);
  printf("The product of %d and %d is: %d\n", a, b, prod);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall average(_QWORD, _QWORD); // weak
__int64 __fastcall sum(_QWORD, _QWORD); // weak
__int64 __fastcall difference(_QWORD, _QWORD); // weak
__int64 __fastcall product(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001638) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-18h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v6; // [rsp+30h] [rbp-10h]
  unsigned int v7; // [rsp+34h] [rbp-Ch]
  unsigned int v8; // [rsp+38h] [rbp-8h]
  unsigned int v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter two numbers: ");
  scanf("%d%d", &v5, &v4);
  v9 = average(v5, v4);
  v8 = sum(v5, v4);
  v7 = difference(v5, v4);
  v6 = product(v5, v4);
  printf("The average of %d and %d is: %d\n", v5, v4, v9);
  printf("The sum of %d and %d is: %d\n", v5, v4, v8);
  printf("The difference between %d and %d is: %d\n", v5, v4, v7);
  printf("The product of %d and %d is: %d\n", v5, v4, v6);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall average(_QWORD, _QWORD);
// 1400015FF: using guessed type __int64 __fastcall sum(_QWORD, _QWORD);
// 140001613: using guessed type __int64 __fastcall difference(_QWORD, _QWORD);
// 140001625: using guessed type __int64 __fastcall product(_QWORD, _QWORD);
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital signal processing ; Style: standalone
#include <stdio.h>

#define MAX_SAMPLES 10000

float data[MAX_SAMPLES];
float filtered_data[MAX_SAMPLES];

void low_pass_filter(float *data, float *filtered_data, int length, float cutoff_freq, float sample_rate) {
    // Calculate filter coefficients
    float RC = 1.0 / (cutoff_freq * 2 * 3.14);
    float dt = 1.0 / sample_rate;
    float alpha = dt / (RC + dt);

    // Filter data
    float previous_output = 0;
    for (int i = 0; i < length; i++) {
        filtered_data[i] = alpha * data[i] + (1 - alpha) * previous_output;
        previous_output = filtered_data[i];
    }
}

int main() {
    int num_samples;
    float sample_rate, cutoff_freq;

    // Read input parameters
    printf("Enter number of samples: ");
    scanf("%d", &num_samples);
    printf("Enter sample rate: ");
    scanf("%f", &sample_rate);
    printf("Enter cutoff frequency: ");
    scanf("%f", &cutoff_freq);

    // Read data
    printf("Enter data:\n");
    for (int i = 0; i < num_samples; i++) {
        scanf("%f", &data[i]);
    }

    // Filter data
    low_pass_filter(data, filtered_data, num_samples, cutoff_freq, sample_rate);

    // Print filtered data
    printf("Filtered data:\n");
    for (int i = 0; i < num_samples; i++) {
        printf("%f\n", filtered_data[i]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall low_pass_filter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN data; // weak
float filtered_data[10000]; // weak


//----- (00000001400016EB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // r9d
  int v5; // [rsp+3Ch] [rbp-14h] BYREF
  int v6; // [rsp+40h] [rbp-10h] BYREF
  int v7; // [rsp+44h] [rbp-Ch] BYREF
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter number of samples: ");
  scanf("%d", &v7);
  printf("Enter sample rate: ");
  scanf("%f", &v6);
  printf("Enter cutoff frequency: ");
  scanf("%f", &v5);
  printf("Enter data:\n");
  for ( i = 0; i < v7; ++i )
    scanf("%f", (char *)&data + 4 * i);
  low_pass_filter((unsigned int)&data, (unsigned int)filtered_data, v7, v3, v6);
  printf("Filtered data:\n");
  for ( j = 0; j < v7; ++j )
    printf("%f\n", filtered_data[j]);
  return 0;
}
// 1400017E1: variable 'v3' is possibly undefined
// 1400015E2: using guessed type __int64 __fastcall low_pass_filter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140021C80: using guessed type float filtered_data[10000];

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: recursive
#include <stdio.h>
#include <stdbool.h>

#define MAX_ROWS 10
#define MAX_COLS 10

// 2D Array representing the maze
int maze[MAX_ROWS][MAX_COLS] = {
    {1, 0, 1, 1, 0, 1, 0, 1, 1, 1},
    {1, 1, 1, 0, 1, 1, 1, 1, 0, 1},
    {0, 0, 0, 1, 1, 1, 1, 0, 1, 1},
    {1, 1, 1, 0, 1, 0, 1, 0, 0, 1},
    {1, 0, 1, 0, 1, 1, 1, 1, 0, 0},
    {1, 0, 0, 1, 1, 0, 0, 1, 0, 1},
    {1, 1, 0, 1, 0, 0, 1, 1, 1, 1},
    {0, 0, 1, 1, 1, 0, 1, 0, 0, 1},
    {1, 0, 1, 0, 1, 0, 0, 1, 1, 0},
    {0, 1, 0, 1, 0, 1, 1, 1, 0, 1},
};

// Function to check if a given row and column is a valid move
bool isValidMove(int row, int col) {
    return (row >= 0) && (row < MAX_ROWS) && 
           (col >= 0) && (col < MAX_COLS) && 
           (maze[row][col] == 1);
}

// Function to solve the maze using recursion
bool solveMaze(int row, int col) {
    // If we have reached the end of the maze, return true
    if (row == MAX_ROWS - 1 && col == MAX_COLS - 1) {
        return true;
    }

    // Check if the current row and col is a valid move
    if (isValidMove(row, col)) {
        // Mark the current cell as visited
        maze[row][col] = 2;

        // Check if we can move down
        if (solveMaze(row + 1, col)) {
            return true;
        }

        // Check if we can move right
        if (solveMaze(row, col + 1)) {
            return true;
        }

        // Check if we can move up
        if (solveMaze(row - 1, col)) {
            return true;
        }

        // Check if we can move left
        if (solveMaze(row, col - 1)) {
            return true;
        }

        // If we reach this point, that means we can't move in any direction
        // so we need to backtrack and mark the current cell as unvisited
        maze[row][col] = 1;
        return false;
    }

    // If we reach this point, that means the current cell is not a valid move
    // so we need to backtrack
    return false;
}

int main() {
    // Print the initial maze
    printf("The initial maze :\n");
    for(int i = 0; i < MAX_ROWS; i++) {
        for(int j = 0; j < MAX_COLS; j++) {
            printf("%d ", maze[i][j]);
        }
        printf("\n");
    }

    // Solve the maze
    if (solveMaze(0, 0)) {
        // Print the final maze with the path
        printf("\nThe path with the maze :\n");
        for(int i = 0; i < MAX_ROWS; i++) {
            for(int j = 0; j < MAX_COLS; j++) {
                if (maze[i][j] == 2) {
                    printf("* ");
                } else {
                    printf("%d ", maze[i][j]);   
                }
            }
            printf("\n");
        }
    } else {
        printf("There is no possible path.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall solveMaze(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

unsigned int maze[104] =
{
  1u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u
}; // weak


//----- (0000000140001715) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int m; // [rsp+20h] [rbp-10h]
  int k; // [rsp+24h] [rbp-Ch]
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("The initial maze :\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      printf("%d ", maze[10 * i + j]);
    printf("\n");
  }
  if ( (unsigned __int8)solveMaze(0i64, 0i64) )
  {
    printf("\nThe path with the maze :\n");
    for ( k = 0; k <= 9; ++k )
    {
      for ( m = 0; m <= 9; ++m )
      {
        if ( maze[10 * k + m] == 2 )
          printf("* ");
        else
          printf("%d ", maze[10 * k + m]);
      }
      printf("\n");
    }
  }
  else
  {
    printf("There is no possible path.\n");
  }
  return 0;
}
// 1400015F7: using guessed type __int64 __fastcall solveMaze(_QWORD, _QWORD);
// 140001960: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A020: using guessed type unsigned int maze[104];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Poker Game ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//Function to shuffle the deck of cards
void shuffle(int *deck) {
    int temp, randIndex;
    for (int i = 0; i < 52; i++) {
        randIndex = rand() % 52;
        temp = deck[i];
        deck[i] = deck[randIndex];
        deck[randIndex] = temp;
    }
}

int main() {
    //Initialize deck of cards
    int deck[52] = {0};
    for (int i = 0; i < 52; i++) {
        deck[i] = i;
    }
    
    //Shuffle deck of cards
    srand(time(NULL));
    shuffle(deck);
    
    //Print shuffled deck of cards
    printf("Shuffled deck of cards:\n");
    for (int i = 0; i < 52; i++) {
        printf("%d ", deck[i]);
    }
    printf("\n");
    
    //Deal cards to players
    int player1[5] = {0}, player2[5] = {0};
    int j = 0;
    for (int i = 0; i < 10; i++) {
        if (i % 2 == 0) {
            player1[j] = deck[i];
        } else {
            player2[j] = deck[i];
            j++;
        }
    }

    //Print cards dealt to players
    printf("Cards dealt to player 1:\n");
    for (int i = 0; i < 5; i++) {
        printf("%d ", player1[i]);
    }
    printf("\n");
    printf("Cards dealt to player 2:\n");
    for (int i = 0; i < 5; i++) {
        printf("%d ", player2[i]);
    }
    printf("\n");

    //TODO: Implement poker hand ranking algorithm

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall shuffle(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001668) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5[2]; // [rsp+20h] [rbp-60h]
  int v6; // [rsp+30h] [rbp-50h]
  __int64 v7[2]; // [rsp+40h] [rbp-40h]
  int v8; // [rsp+50h] [rbp-30h]
  int v9[54]; // [rsp+60h] [rbp-20h] BYREF
  int n; // [rsp+138h] [rbp+B8h]
  int m; // [rsp+13Ch] [rbp+BCh]
  int k; // [rsp+140h] [rbp+C0h]
  int v13; // [rsp+144h] [rbp+C4h]
  int j; // [rsp+148h] [rbp+C8h]
  int i; // [rsp+14Ch] [rbp+CCh]

  _main(argc, argv, envp);
  memset(v9, 0, 0xD0ui64);
  for ( i = 0; i <= 51; ++i )
    v9[i] = i;
  v3 = time(0i64);
  srand(v3);
  shuffle(v9);
  printf("Shuffled deck of cards:\n");
  for ( j = 0; j <= 51; ++j )
    printf("%d ", (unsigned int)v9[j]);
  printf("\n");
  v7[0] = 0i64;
  v7[1] = 0i64;
  v8 = 0;
  v5[0] = 0i64;
  v5[1] = 0i64;
  v6 = 0;
  v13 = 0;
  for ( k = 0; k <= 9; ++k )
  {
    if ( (k & 1) != 0 )
      *((_DWORD *)v5 + v13++) = v9[k];
    else
      *((_DWORD *)v7 + v13) = v9[k];
  }
  printf("Cards dealt to player 1:\n");
  for ( m = 0; m <= 4; ++m )
    printf("%d ", *((unsigned int *)v7 + m));
  printf("\n");
  printf("Cards dealt to player 2:\n");
  for ( n = 0; n <= 4; ++n )
    printf("%d ", *((unsigned int *)v5 + n));
  printf("\n");
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall shuffle(_QWORD);
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001668: using guessed type int var_100[54];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Frequency Counter ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define MAX_LENGTH 1000

/*
 * This program counts the frequency of words starting with the letter 'C' (both uppercase and lowercase)
 * in a given input string.
 */

// Function to check if a character is a delimiter
int isDelimiter(char c) {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f' || c == '\v' || c == ',' || c == '.' || c == '?' || c == '!';
}

// Function to compare two characters, case-insensitively
int compare(char a, char b) {
    if (tolower(a) == tolower(b)) {
        return 1;
    }
    return 0;
}

// Function to count the frequency of words starting with 'C'
int countWordFrequency(char *str) {
    int frequency = 0;
    int i = 0;
    while (str[i] != '\0') {
        // Skip over any delimiters
        while (isDelimiter(str[i])) {
            i++;
        }

        // Check if the current word starts with 'C'
        if (compare(str[i], 'C')) {
            // Skip over the 'C'
            i++;

            // Check if the next character is a delimiter or the end of the string
            if (isDelimiter(str[i]) || str[i] == '\0') {
                frequency++;
            }
        }

        // Skip to the next word
        while (!isDelimiter(str[i]) && str[i] != '\0') {
            i++;
        }
    }
    return frequency;
}

int main() {
    char inputString[MAX_LENGTH];
    printf("Enter a string: ");
    fgets(inputString, MAX_LENGTH, stdin);
    int frequency = countWordFrequency(inputString);
    printf("The frequency of words starting with 'C' in the input string is %d\n", frequency);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall countWordFrequency(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001727) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1004]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v6; // [rsp+40Ch] [rbp+38Ch]

  _main(argc, argv, envp);
  printf("Enter a string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v6 = countWordFrequency(Buffer);
  printf("The frequency of words starting with 'C' in the input string is %d\n", v6);
  return 0;
}
// 140001630: using guessed type __int64 __fastcall countWordFrequency(_QWORD);
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

// struct to represent a vehicle
typedef struct {
    int speed;  // in mph
    int position;  // in miles
    bool active;  // whether vehicle is on the road
} Vehicle;

// function to initialize a vehicle with random speed and position
Vehicle initVehicle() {
    Vehicle vehicle;
    vehicle.speed = rand() % 31 + 30;  // random speed between 30-60mph
    vehicle.position = rand() % 11;  // random position on the road
    vehicle.active = true;
    return vehicle;
}

int main() {
    // seed the random number generator
    srand(time(0));

    int numVehicles = 20;  // number of vehicles on the road
    Vehicle vehicles[numVehicles];

    // init vehicles
    for (int i = 0; i < numVehicles; i++) {
        vehicles[i] = initVehicle();
    }

    int timeStep = 1;  // each timestep represents 1 minute
    int gameTime = 120;  // game lasts for 2 hours (120 minutes)

    // main game loop
    for (int t = 0; t < gameTime; t += timeStep) {
        // print the current state of the road
        printf("Time: %d minutes\n", t);
        for (int j = 0; j < numVehicles; j++) {
            if (vehicles[j].active) {  // only print active vehicles
                printf("Vehicle %d: Speed %d mph, Position %d miles\n", j+1, vehicles[j].speed, vehicles[j].position);
            }
        }
        printf("\n");

        // update positions of each vehicle
        for (int k = 0; k < numVehicles; k++) {
            if (vehicles[k].active) {
                vehicles[k].position += vehicles[k].speed / 60 * timeStep;  // update position based on speed
            }
        }

        // check if any collisions occurred
        for (int m = 0; m < numVehicles; m++) {
            if (vehicles[m].active) {
                for (int n = m+1; n < numVehicles; n++) {
                    if (vehicles[n].active) {
                        if (vehicles[m].position == vehicles[n].position) {  // collision occurred
                            printf("Collision occurred at time %d between Vehicle %d and Vehicle %d\n", t, m+1, n+1);
                            vehicles[m].active = false;  // both vehicles become inactive after a collision
                            vehicles[n].active = false;
                        }
                    }
                }
            }
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall initVehicle(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001640) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  void *v4; // rsp
  char *v5; // rbx
  __int64 v7; // [rsp+20h] [rbp-50h] BYREF
  int v8; // [rsp+28h] [rbp-48h]
  int v9; // [rsp+38h] [rbp-38h]
  int v10; // [rsp+3Ch] [rbp-34h]
  __int64 *v11; // [rsp+40h] [rbp-30h]
  __int64 v12; // [rsp+48h] [rbp-28h]
  int v13; // [rsp+54h] [rbp-1Ch]
  int ii; // [rsp+58h] [rbp-18h]
  int n; // [rsp+5Ch] [rbp-14h]
  int m; // [rsp+60h] [rbp-10h]
  int k; // [rsp+64h] [rbp-Ch]
  unsigned int j; // [rsp+68h] [rbp-8h]
  int i; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v13 = 20;
  v12 = 19i64;
  v4 = alloca(240i64);
  v11 = &v7;
  for ( i = 0; i < v13; ++i )
  {
    v5 = (char *)v11 + 12 * i;
    initVehicle(&v7);
    *(_QWORD *)v5 = v7;
    *((_DWORD *)v5 + 2) = v8;
  }
  v10 = 1;
  v9 = 120;
  for ( j = 0; (int)j < v9; j += v10 )
  {
    printf("Time: %d minutes\n", j);
    for ( k = 0; k < v13; ++k )
    {
      if ( *((_BYTE *)v11 + 12 * k + 8) )
        printf(
          "Vehicle %d: Speed %d mph, Position %d miles\n",
          (unsigned int)(k + 1),
          *((unsigned int *)v11 + 3 * k),
          *((unsigned int *)v11 + 3 * k + 1));
    }
    printf("\n");
    for ( m = 0; m < v13; ++m )
    {
      if ( *((_BYTE *)v11 + 12 * m + 8) )
        *((_DWORD *)v11 + 3 * m + 1) += v10 * (*((_DWORD *)v11 + 3 * m) / 60);
    }
    for ( n = 0; n < v13; ++n )
    {
      if ( *((_BYTE *)v11 + 12 * n + 8) )
      {
        for ( ii = n + 1; ii < v13; ++ii )
        {
          if ( *((_BYTE *)v11 + 12 * ii + 8) && *((_DWORD *)v11 + 3 * n + 1) == *((_DWORD *)v11 + 3 * ii + 1) )
          {
            printf(
              "Collision occurred at time %d between Vehicle %d and Vehicle %d\n",
              j,
              (unsigned int)(n + 1),
              (unsigned int)(ii + 1));
            *((_BYTE *)v11 + 12 * n + 8) = 0;
            *((_BYTE *)v11 + 12 * ii + 8) = 0;
          }
        }
      }
    }
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall initVehicle(_QWORD);
// 140001B10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cat Language Translator ; Style: authentic
#include <stdio.h>
#include <string.h>

int main() 
{
    char kitty_phrases[10][20] = {"Meow", "Purr", "Hiss", "Scratch", "Bite", "Lick", "Play", "Sleep", "Wake Up", "Eat"};
    char english_phrases[10][20] = {"Hello", "I'm happy", "I'm angry", "I'm in pain", "Stop", "Let's cuddle", "Let's play", "I'm tired", "Good morning", "I'm hungry"};

    char input[20];
    int i, match = -1;

    printf("Enter a phrase in C Cat Language: ");
    scanf("%s", input);

    for(i = 0; i < 10; i++) 
    {
        if(strcmp(input, kitty_phrases[i]) == 0) 
        {
            match = i;
            break;
        }
    }

    if(match != -1) 
    {
        printf("Translated phrase in English: %s\n", english_phrases[match]);
    } 
    else 
    {
        printf("Sorry, I don't know what that means in English.\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[32]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5[2]; // [rsp+40h] [rbp-40h] BYREF
  int v6; // [rsp+50h] [rbp-30h]
  __int64 v7; // [rsp+54h] [rbp-2Ch]
  __int64 v8; // [rsp+5Ch] [rbp-24h]
  int v9; // [rsp+64h] [rbp-1Ch]
  __int64 v10; // [rsp+68h] [rbp-18h]
  __int64 v11; // [rsp+70h] [rbp-10h]
  int v12; // [rsp+78h] [rbp-8h]
  __int64 v13; // [rsp+7Ch] [rbp-4h]
  __int64 v14; // [rsp+84h] [rbp+4h]
  int v15; // [rsp+8Ch] [rbp+Ch]
  __int64 v16; // [rsp+90h] [rbp+10h]
  __int64 v17; // [rsp+98h] [rbp+18h]
  int v18; // [rsp+A0h] [rbp+20h]
  _WORD v19[8]; // [rsp+A4h] [rbp+24h] BYREF
  int v20; // [rsp+B4h] [rbp+34h]
  __int64 v21; // [rsp+B8h] [rbp+38h]
  __int64 v22; // [rsp+C0h] [rbp+40h]
  int v23; // [rsp+C8h] [rbp+48h]
  __int64 v24; // [rsp+CCh] [rbp+4Ch]
  __int64 v25; // [rsp+D4h] [rbp+54h]
  int v26; // [rsp+DCh] [rbp+5Ch]
  _WORD v27[8]; // [rsp+E0h] [rbp+60h] BYREF
  int v28; // [rsp+F0h] [rbp+70h]
  __int64 v29; // [rsp+F4h] [rbp+74h]
  __int64 v30; // [rsp+FCh] [rbp+7Ch]
  int v31; // [rsp+104h] [rbp+84h]
  __int64 v32[2]; // [rsp+110h] [rbp+90h] BYREF
  int v33; // [rsp+120h] [rbp+A0h]
  __int64 v34; // [rsp+124h] [rbp+A4h]
  __int64 v35; // [rsp+12Ch] [rbp+ACh]
  int v36; // [rsp+134h] [rbp+B4h]
  __int64 v37; // [rsp+138h] [rbp+B8h]
  __int64 v38; // [rsp+140h] [rbp+C0h]
  int v39; // [rsp+148h] [rbp+C8h]
  __int64 v40; // [rsp+14Ch] [rbp+CCh]
  __int64 v41; // [rsp+154h] [rbp+D4h]
  int v42; // [rsp+15Ch] [rbp+DCh]
  __int64 v43; // [rsp+160h] [rbp+E0h]
  __int64 v44; // [rsp+168h] [rbp+E8h]
  int v45; // [rsp+170h] [rbp+F0h]
  __int64 v46; // [rsp+174h] [rbp+F4h]
  __int64 v47; // [rsp+17Ch] [rbp+FCh]
  int v48; // [rsp+184h] [rbp+104h]
  __int64 v49; // [rsp+188h] [rbp+108h]
  __int64 v50; // [rsp+190h] [rbp+110h]
  int v51; // [rsp+198h] [rbp+118h]
  __int64 v52; // [rsp+19Ch] [rbp+11Ch]
  __int64 v53; // [rsp+1A4h] [rbp+124h]
  int v54; // [rsp+1ACh] [rbp+12Ch]
  __int64 v55; // [rsp+1B0h] [rbp+130h]
  __int64 v56; // [rsp+1B8h] [rbp+138h]
  int v57; // [rsp+1C0h] [rbp+140h]
  __int64 v58; // [rsp+1C4h] [rbp+144h]
  __int64 v59; // [rsp+1CCh] [rbp+14Ch]
  int v60; // [rsp+1D4h] [rbp+154h]
  int v61; // [rsp+1D8h] [rbp+158h]
  int i; // [rsp+1DCh] [rbp+15Ch]

  _main(argc, argv, envp);
  v32[0] = 2003789133i64;
  v32[1] = 0i64;
  v33 = 0;
  v34 = 1920103760i64;
  v35 = 0i64;
  v36 = 0;
  v37 = 1936943432i64;
  v38 = 0i64;
  v39 = 0;
  v40 = 0x68637461726353i64;
  v41 = 0i64;
  v42 = 0;
  v43 = 1702127938i64;
  v44 = 0i64;
  v45 = 0;
  v46 = 1801677132i64;
  v47 = 0i64;
  v48 = 0;
  v49 = 2036427856i64;
  v50 = 0i64;
  v51 = 0;
  v52 = 0x7065656C53i64;
  v53 = 0i64;
  v54 = 0;
  v55 = 0x705520656B6157i64;
  v56 = 0i64;
  v57 = 0;
  v58 = 7627077i64;
  v59 = 0i64;
  v60 = 0;
  v5[0] = 0x6F6C6C6548i64;
  v5[1] = 0i64;
  v6 = 0;
  v7 = 0x70706168206D2749i64;
  v8 = 121i64;
  v9 = 0;
  v10 = 0x72676E61206D2749i64;
  v11 = 121i64;
  v12 = 0;
  v13 = 0x70206E69206D2749i64;
  v14 = 7235937i64;
  v15 = 0;
  v16 = 1886352467i64;
  v17 = 0i64;
  v18 = 0;
  strcpy((char *)v19, "Let's cuddle");
  HIBYTE(v19[6]) = 0;
  v19[7] = 0;
  v20 = 0;
  v21 = 0x6C7020732774654Ci64;
  v22 = 31073i64;
  v23 = 0;
  v24 = 0x65726974206D2749i64;
  v25 = 100i64;
  v26 = 0;
  strcpy((char *)v27, "Good morning");
  HIBYTE(v27[6]) = 0;
  v27[7] = 0;
  v28 = 0;
  v29 = 0x676E7568206D2749i64;
  v30 = 31090i64;
  v31 = 0;
  v61 = -1;
  printf("Enter a phrase in C Cat Language: ");
  scanf("%s", Str1);
  for ( i = 0; i <= 9; ++i )
  {
    if ( !strcmp(Str1, (const char *)v32 + 20 * i) )
    {
      v61 = i;
      break;
    }
  }
  if ( v61 == -1 )
    printf("Sorry, I don't know what that means in English.\n");
  else
    printf("Translated phrase in English: %s\n", (const char *)v5 + 20 * v61);
  return 0;
}
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// function to check if the password is strong
int passwordStrength(char *password) {
    int passwordLength = strlen(password);
    int score = 0;
    // check if password length is greater than 8
    if (passwordLength > 8) {
        score++;
    }
    // check if password contains digits
    int hasDigits = 0;
    for (int i=0; i<passwordLength; i++) {
        if (isdigit(password[i])) {
            hasDigits = 1;
            break;
        }
    }
    if (hasDigits) {
        score++;
    }
    // check if password contains lowercase letters
    int hasLowercase = 0;
    for (int i=0; i<passwordLength; i++) {
        if (islower(password[i])) {
            hasLowercase = 1;
            break;
        }
    }
    if (hasLowercase) {
        score++;
    }
    // check if password contains uppercase letters
    int hasUppercase = 0;
    for (int i=0; i<passwordLength; i++) {
        if (isupper(password[i])) {
            hasUppercase = 1;
            break;
        }
    }
    if (hasUppercase) {
        score++;
    }
    // check if password contains special characters
    int hasSpecial = 0;
    for (int i=0; i<passwordLength; i++) {
        if (!isalnum(password[i])) {
            hasSpecial = 1;
            break;
        }
    }
    if (hasSpecial) {
        score++;
    }
    // determine password strength based on score
    int passwordStrength = 0;
    switch(score) {
        case 0:
        case 1:
            passwordStrength = 1;
            break;
        case 2:
            passwordStrength = 2;
            break;
        case 3:
            passwordStrength = 3;
            break;
        case 4:
            passwordStrength = 4;
            break;
        case 5:
            passwordStrength = 5;
            break;
    }
    return passwordStrength;
}

int main() {
    char password[100];
    printf("Enter your password: ");
    scanf("%s", password);
    int strength = passwordStrength(password);
    printf("Your password is ");
    switch (strength) {
        case 1:
            printf("very weak.\n");
            break;
        case 2:
            printf("weak.\n");
            break;
        case 3:
            printf("moderate.\n");
            break;
        case 4:
            printf("strong.\n");
            break;
        case 5:
            printf("very strong.\n");
            break;
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall passwordStrength(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017AD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[108]; // [rsp+20h] [rbp-70h] BYREF
  int v5; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter your password: ");
  scanf("%s", v4);
  v5 = passwordStrength(v4);
  printf("Your password is ");
  switch ( v5 )
  {
    case 1:
      printf("very weak.\n");
      break;
    case 2:
      printf("weak.\n");
      break;
    case 3:
      printf("moderate.\n");
      break;
    case 4:
      printf("strong.\n");
      break;
    case 5:
      printf("very strong.\n");
      break;
    default:
      return 0;
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall passwordStrength(_QWORD);
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Terminal Based Game ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {

    int userChoice, computerChoice, flag = 1, userScore = 0, computerScore = 0;
    
    printf("Welcome to Rock-Paper-Scissors!\n");

    while (flag) {
    
        printf("\nChoose your weapon:\n");
        printf("1. Rock\n");
        printf("2. Paper\n");
        printf("3. Scissors\n");
        printf("4. Quit game\n");
        
        scanf("%d", &userChoice);

        switch(userChoice) {

            case 1: 
                printf("\nYou chose Rock!\n");
                break;

            case 2:
                printf("\nYou chose Paper!\n");
                break;

            case 3:
                printf("\nYou chose Scissors!\n");
                break;

            case 4:
                printf("\nThank you for playing!\n");
                flag = 0;
                break;

            default:
                printf("\nInvalid choice! Please try again.\n");
                continue;
        }

        if (flag == 0) {
            break;
        }

        srand(time(NULL));
        computerChoice = rand() % 3 + 1;

        switch(computerChoice) {

            case 1: 
                printf("The computer chose Rock!\n");
                break;

            case 2:
                printf("The computer chose Paper!\n");
                break;

            case 3:
                printf("The computer chose Scissors!\n");
                break;

            default:
                printf("The computer has malfunctioned.\n");
                break;
        }

        if (userChoice == 1 && computerChoice == 3) {
            printf("\nRock crushes Scissors! You win!\n");
            userScore++;
        }
        else if (userChoice == 1 && computerChoice == 2) {
            printf("\nPaper covers Rock! You lose!\n");
            computerScore++;
        }
        else if (userChoice == 2 && computerChoice == 1) {
            printf("\nPaper covers Rock! You win!\n");
            userScore++;
        }
        else if (userChoice == 2 && computerChoice == 3) {
            printf("\nScissors cuts Paper! You lose!\n");
            computerScore++;
        }
        else if (userChoice == 3 && computerChoice == 1) {
            printf("\nRock crushes Scissors! You lose!\n");
            computerScore++;
        }
        else if (userChoice == 3 && computerChoice == 2) {
            printf("\nScissors cuts Paper! You win!\n");
            userScore++;
        }
        else {
            printf("\nIt's a tie!\n");
        }

        printf("\nScore:\n You: %d\n Computer: %d\n", userScore, computerScore);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // edx
  int v6; // [rsp+2Ch] [rbp-14h] BYREF
  int v7; // [rsp+30h] [rbp-10h]
  unsigned int v8; // [rsp+34h] [rbp-Ch]
  unsigned int v9; // [rsp+38h] [rbp-8h]
  int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 1;
  v9 = 0;
  v8 = 0;
  printf("Welcome to Rock-Paper-Scissors!\n");
  while ( v10 )
  {
    printf("\nChoose your weapon:\n");
    printf("1. Rock\n");
    printf("2. Paper\n");
    printf("3. Scissors\n");
    printf("4. Quit game\n");
    scanf("%d", &v6);
    if ( v6 == 4 )
    {
      printf("\nThank you for playing!\n");
      v10 = 0;
LABEL_13:
      if ( !v10 )
        return 0;
      v3 = time(0i64);
      srand(v3);
      v4 = rand() % 3;
      v7 = v4 + 1;
      if ( v4 == 2 )
      {
        printf("The computer chose Scissors!\n");
      }
      else
      {
        if ( v7 > 3 )
          goto LABEL_22;
        if ( v7 == 1 )
        {
          printf("The computer chose Rock!\n");
        }
        else
        {
          if ( v7 != 2 )
          {
LABEL_22:
            printf("The computer has malfunctioned.\n");
            goto LABEL_23;
          }
          printf("The computer chose Paper!\n");
        }
      }
LABEL_23:
      if ( v6 == 1 && v7 == 3 )
      {
        printf("\nRock crushes Scissors! You win!\n");
        ++v9;
      }
      else if ( v6 == 1 && v7 == 2 )
      {
        printf("\nPaper covers Rock! You lose!\n");
        ++v8;
      }
      else if ( v6 == 2 && v7 == 1 )
      {
        printf("\nPaper covers Rock! You win!\n");
        ++v9;
      }
      else if ( v6 == 2 && v7 == 3 )
      {
        printf("\nScissors cuts Paper! You lose!\n");
        ++v8;
      }
      else if ( v6 == 3 && v7 == 1 )
      {
        printf("\nRock crushes Scissors! You lose!\n");
        ++v8;
      }
      else if ( v6 == 3 && v7 == 2 )
      {
        printf("\nScissors cuts Paper! You win!\n");
        ++v9;
      }
      else
      {
        printf("\nIt's a tie!\n");
      }
      printf("\nScore:\n You: %d\n Computer: %d\n", v9, v8);
    }
    else
    {
      if ( v6 > 4 )
        goto LABEL_12;
      switch ( v6 )
      {
        case 3:
          printf("\nYou chose Scissors!\n");
          goto LABEL_13;
        case 1:
          printf("\nYou chose Rock!\n");
          goto LABEL_13;
        case 2:
          printf("\nYou chose Paper!\n");
          goto LABEL_13;
      }
LABEL_12:
      printf("\nInvalid choice! Please try again.\n");
    }
  }
  return 0;
}
// 1400016AD: conditional instruction was optimized away because %var_14.4<3
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: light-weight
#include<stdio.h>
#include<stdlib.h>

int main(){
    FILE *filepointer;
    char ch, filename[20], content[200];

    printf("Enter file name: ");
    scanf("%s", filename);

    printf("Enter the content of the file: ");
    scanf(" %[^\n]s", content);

    // Write content to the file
    filepointer = fopen(filename, "w"); //Open file for Writing
    if(filepointer == NULL){
        printf("Can't create file!\n");
        exit(0);
    }

    fprintf(filepointer, "%s", content); //Write content to file
    printf("Content successfully added to file %s\n", filename);
    fclose(filepointer);

    // Read content from the file
    filepointer = fopen(filename, "r"); //Open file for Reading
    if(filepointer == NULL){
        printf("Can't open file!\n");
        exit(0);
    }

    printf("Content of file %s is: \n", filename);
    while((ch = fgetc(filepointer)) != EOF){ //Read content from file until end of file
        printf("%c", ch);
    }
    printf("\n");

    fclose(filepointer);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[208]; // [rsp+20h] [rbp-60h] BYREF
  char FileName[23]; // [rsp+F0h] [rbp+70h] BYREF
  char v6; // [rsp+107h] [rbp+87h]
  FILE *Stream; // [rsp+108h] [rbp+88h]

  _main(argc, argv, envp);
  printf("Enter file name: ");
  scanf("%s", FileName);
  printf("Enter the content of the file: ");
  scanf(" %[^\n]s", v4);
  Stream = fopen(FileName, "w");
  if ( !Stream )
  {
    printf("Can't create file!\n");
    exit(0);
  }
  fprintf_0(Stream, "%s", v4);
  printf("Content successfully added to file %s\n", FileName);
  fclose(Stream);
  Stream = fopen(FileName, "r");
  if ( !Stream )
  {
    printf("Can't open file!\n");
    exit(0);
  }
  printf("Content of file %s is: \n", FileName);
  while ( 1 )
  {
    v6 = fgetc(Stream);
    if ( v6 == -1 )
      break;
    printf("%c", (unsigned int)v6);
  }
  printf("\n");
  fclose(Stream);
  return 0;
}
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data validation ; Style: satisfied
#include <stdio.h>
#include <ctype.h>
#include <stdbool.h>

/* function prototypes */
bool validate_name(char *);
bool validate_age(int);
bool validate_phone(char *);
bool validate_email(char *);

int main(void) {

    char name[25], phone[15], email[50];
    int age;

    printf("Please enter your name: ");
    fgets(name, 25, stdin);

    printf("Please enter your age: ");
    scanf("%d", &age);

    printf("Please enter your phone number: ");
    scanf("%s", phone);

    printf("Please enter your email address: ");
    scanf("%s", email);

    if (!validate_name(name)) {
        printf("\nInvalid name. Please enter a valid name.\n");
        return 1;
    }

    if (!validate_age(age)) {
        printf("\nInvalid age. Please enter a valid age.\n");
        return 1;
    }

    if (!validate_phone(phone)) {
        printf("\nInvalid phone number. Please enter a valid phone number.\n");
        return 1;
    }

    if (!validate_email(email)) {
        printf("\nInvalid email address. Please enter a valid email address.\n");
        return 1;
    }

    printf("\nThank you for entering your information.\n");

    return 0;
}

/*
 * Function to validate name
 * Returns true if name is valid, false otherwise
 */
bool validate_name(char *name) {
    int i;
    char c;

    for (i = 0; name[i] != '\0'; i++) {
        c = name[i];

        /* check if character is alphabet or space */
        if (!(isalpha(c) || isspace(c))) {
            return false;
        }
    }

    /* check if there is at least one alphabet in the name */
    for (i = 0; name[i] != '\0'; i++) {
        if (isalpha(name[i])) {
            return true;
        }
    }

    return false;
}

/*
 * Function to validate age
 * Returns true if age is valid, false otherwise
 */
bool validate_age(int age) {
    if (age < 0 || age > 120) {
        return false;
    }

    return true;
}

/*
 * Function to validate phone number
 * Returns true if phone number is valid, false otherwise
 */
bool validate_phone(char *phone) {
    int i;

    /* check if all characters are digits */
    for (i = 0; phone[i] != '\0'; i++) {
        if (!isdigit(phone[i])) {
            return false;
        }
    }

    /* check if phone number has 10 digits */
    if (i != 10) {
        return false;
    }

    return true;
}

/*
 * Function to validate email address
 * Returns true if email address is valid, false otherwise
 */
bool validate_email(char *email) {
    int i;
    char c;

    /* check if there is at least one '@' sign and one '.' */
    for (i = 0; email[i] != '\0'; i++) {
        c = email[i];

        if (c == '@') {
            break;
        }
    }

    if (email[i] == '\0') {
        return false;
    }

    for (; email[i] != '\0'; i++) {
        c = email[i];

        if (c == '.') {
            break;
        }
    }

    if (email[i] == '\0') {
        return false;
    }

    /* check if there is at least one character before '@' sign */
    if (i == 0) {
        return false;
    }

    return true;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall validate_name(_QWORD); // weak
__int64 __fastcall validate_age(_QWORD); // weak
__int64 __fastcall validate_phone(_QWORD); // weak
__int64 __fastcall validate_email(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v5; // [rsp+2Ch] [rbp-74h] BYREF
  char v6[65]; // [rsp+30h] [rbp-70h] BYREF
  char v7[15]; // [rsp+71h] [rbp-2Fh] BYREF
  char Buffer[32]; // [rsp+80h] [rbp-20h] BYREF

  _main(argc, argv, envp);
  printf("Please enter your name: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 25, v3);
  printf("Please enter your age: ");
  scanf("%d", &v5);
  printf("Please enter your phone number: ");
  scanf("%s", v7);
  printf("Please enter your email address: ");
  scanf("%s", v6);
  if ( (unsigned __int8)validate_name(Buffer) != 1 )
  {
    printf("\nInvalid name. Please enter a valid name.\n");
    return 1;
  }
  else if ( (unsigned __int8)validate_age(v5) != 1 )
  {
    printf("\nInvalid age. Please enter a valid age.\n");
    return 1;
  }
  else if ( (unsigned __int8)validate_phone(v7) != 1 )
  {
    printf("\nInvalid phone number. Please enter a valid phone number.\n");
    return 1;
  }
  else if ( (unsigned __int8)validate_email(v6) != 1 )
  {
    printf("\nInvalid email address. Please enter a valid email address.\n");
    return 1;
  }
  else
  {
    printf("\nThank you for entering your information.\n");
    return 0;
  }
}
// 140001757: using guessed type __int64 __fastcall validate_name(_QWORD);
// 140001819: using guessed type __int64 __fastcall validate_age(_QWORD);
// 14000183A: using guessed type __int64 __fastcall validate_phone(_QWORD);
// 1400018A1: using guessed type __int64 __fastcall validate_email(_QWORD);
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Periodic Table Quiz ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define NUM_ELEMENTS 118

typedef struct element {
    char name[25];
    char symbol[3];
    int atomic_number;
    int atomic_weight;
} element;

int score = 0;

// Function to initialize elements array
void initialize_elements(element elements[]) {
    FILE *fp = fopen("periodic_table.txt", "r");
    if (fp == NULL) {
        printf("Error opening file!");
        exit(1);
    }

    char line[256];
    int i = 0;
    while (fgets(line, sizeof(line), fp)) {
        char *name = strtok(line, ",");
        char *symbol = strtok(NULL, ",");
        int atomic_number = atoi(strtok(NULL, ","));
        int atomic_weight = atoi(strtok(NULL, ","));

        strcpy(elements[i].name, name);
        strcpy(elements[i].symbol, symbol);
        elements[i].atomic_number = atomic_number;
        elements[i].atomic_weight = atomic_weight;
        i++;
    }

    fclose(fp);
}

// Function to shuffle elements array
void shuffle_elements(element elements[]) {
    srand(time(NULL));

    for (int i = NUM_ELEMENTS - 1; i > 0; i--) {
        int j = rand() % (i + 1);

        element temp = elements[i];
        elements[i] = elements[j];
        elements[j] = temp;
    }
}

// Function to get user input and check if correct
void get_input(element current_element) {
    char input[3];
    printf("What is the symbol for %s? ", current_element.name);
    scanf("%s", input);

    if (strcmp(input, current_element.symbol) == 0) {
        printf("Correct! +10 points\n");
        score += 10;
    } else {
        printf("Incorrect! The correct answer is %s.\n", current_element.symbol);
    }
}

// Function to play the game
void play_game(element elements[]) {
    int num_questions = 10;
    printf("Welcome to the Periodic Table Quiz! You will be asked %d questions.\n", num_questions);

    for (int i = 0; i < num_questions; i++) {
        printf("Question %d:\n", i + 1);
        element current_element = elements[i];
        get_input(current_element);
    }

    printf("Final score: %d out of %d\n", score, num_questions * 10);
}

int main() {
    element elements[NUM_ELEMENTS];
    initialize_elements(elements);
    shuffle_elements(elements);
    play_game(elements);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall initialize_elements(_QWORD); // weak
__int64 __fastcall shuffle_elements(_QWORD); // weak
__int64 __fastcall play_game(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001ABB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[4256]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  initialize_elements(v4);
  shuffle_elements(v4);
  play_game(v4);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall initialize_elements(_QWORD);
// 1400017EE: using guessed type __int64 __fastcall shuffle_elements(_QWORD);
// 1400019B0: using guessed type __int64 __fastcall play_game(_QWORD);
// 140001BC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=191 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bucket Sort Implementation ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#define BucketSize 10

struct node {
    int data;
    struct node *next;
};

void BucketSort(int[], int);
void InsertionSort(struct node *);
int hash(int);

int main() {
    int arr[] = {55, 23, 98, 7, 49, 12, 27, 36, 62, 80};
    int n = sizeof(arr)/sizeof(arr[0]);
    BucketSort(arr, n);
    printf("\nSorted array is: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}

void BucketSort(int arr[], int n) {
    int i, j, k;
    struct node **buckets;

    buckets = (struct node **) malloc(BucketSize * sizeof(struct node *));
    for (i = 0; i < BucketSize; i++) {
        buckets[i] = NULL;
    }

    for (i = 0; i < n; i++) {
        struct node *newNode = (struct node *) malloc(sizeof(struct node));
        newNode->data = arr[i];
        newNode->next = NULL;

        k = hash(arr[i]);
        if (buckets[k] == NULL) {
            buckets[k] = newNode;
        } else {
            struct node *temp = buckets[k];
            if (newNode->data < temp->data) {
                newNode->next = temp;
                buckets[k] = newNode;
            } else {
                while (temp->next != NULL && newNode->data > temp->next->data) {
                    temp = temp->next;
                }
                newNode->next = temp->next;
                temp->next = newNode;
            }
        }
    }

    for (i = 0; i < BucketSize; i++) {
        if (buckets[i] != NULL) {
            InsertionSort(buckets[i]);
        }
    }

    k = 0;
    for (i = 0; i < BucketSize; i++) {
        struct node *node = buckets[i];
        while (node != NULL) {
            arr[k++] = node->data;
            node = node->next;
        }
    }

    for (i = 0; i < BucketSize; i++) {
        struct node *node = buckets[i];
        while (node != NULL) {
            struct node *temp = node;
            node = node->next;
            free(temp);
        }
    }
    free(buckets);
}

void InsertionSort(struct node *head) {
    struct node *i, *j;
    for (i = head->next; i != NULL; i = i->next) {
        int key = i->data;
        j = i->next;
        while (j != NULL && j->data < key) {
            i->data = j->data;
            i = i->next;
            j = j->next;
        }
        i->data = key;
    }
}

int hash(int value) {
    return value/BucketSize;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall BucketSort(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[10]; // [rsp+20h] [rbp-30h] BYREF
  int v5; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 55;
  v4[1] = 23;
  v4[2] = 98;
  v4[3] = 7;
  v4[4] = 49;
  v4[5] = 12;
  v4[6] = 27;
  v4[7] = 36;
  v4[8] = 62;
  v4[9] = 80;
  v5 = 10;
  BucketSort(v4, 10i64);
  printf("\nSorted array is: ");
  for ( i = 0; i < v5; ++i )
    printf("%d ", (unsigned int)v4[i]);
  return 0;
}
// 140001643: using guessed type __int64 __fastcall BucketSort(_QWORD, _QWORD);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password management ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_USERNAME_LEN 20
#define MAX_PASSWORD_LEN 20

/* Function to validate the username */
int validate_username(char *username)
{
    int i, len=strlen(username);
    if (len > MAX_USERNAME_LEN)
        return 0;
    for (i=0; i<len; ++i)
        if (!isalnum(username[i]))
            return 0;
    return 1;
}

/* Function to validate the password */
int validate_password(char *password)
{
    int i, len=strlen(password), has_upper=0, has_lower=0, has_digit=0;
    if (len > MAX_PASSWORD_LEN)
        return 0;
    for (i=0; i<len; ++i)
    {
        if (isupper(password[i]))
            has_upper = 1;
        else if (islower(password[i]))
            has_lower = 1;
        else if (isdigit(password[i]))
            has_digit = 1;
        else
            return 0; /* Non-alphanumeric character */
    }
    return has_upper && has_lower && has_digit;
}

int main()
{
    char username[MAX_USERNAME_LEN+1], password[MAX_PASSWORD_LEN+1];
    int i, n;

    printf("Enter number of accounts: ");
    scanf("%d", &n);

    /* Allocate memory for the accounts */
    char **usernames = (char **) malloc(sizeof(char *) * n);
    char **passwords = (char **) malloc(sizeof(char *) * n);

    /* Read in the accounts */
    for (i=0; i<n; ++i)
    {
        printf("Account %d\n", i+1);
        printf("Enter username: ");
        scanf("%s", username);
        while (!validate_username(username))
        {
            printf("Invalid username! Must be alphanumeric and no more than %d characters long.\n", MAX_USERNAME_LEN);
            printf("Enter username: ");
            scanf("%s", username);
        }

        printf("Enter password: ");
        scanf("%s", password);
        while (!validate_password(password))
        {
            printf("Invalid password! Must be between 8 and 20 characters long and contain at least one uppercase letter, one lowercase letter, and one digit.\n");
            printf("Enter password: ");
            scanf("%s", password);
        }

        /* Store the account */
        usernames[i] = strdup(username);
        passwords[i] = strdup(password);
    }

    /* Display the accounts */
    printf("\n\nYour accounts:\n");
    for (i=0; i<n; ++i)
        printf("%-20s %s\n", usernames[i], passwords[i]);

    /* Free memory */
    for (i=0; i<n; ++i)
    {
        free(usernames[i]);
        free(passwords[i]);
    }
    free(usernames);
    free(passwords);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall validate_username(_QWORD); // weak
__int64 __fastcall validate_password(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strdup(const char *String);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (000000014000174E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char **v3; // rbx
  char **v4; // rbx
  int v6; // [rsp+2Ch] [rbp-54h] BYREF
  char v7[32]; // [rsp+30h] [rbp-50h] BYREF
  char String[24]; // [rsp+50h] [rbp-30h] BYREF
  void *v9; // [rsp+68h] [rbp-18h]
  void *Block; // [rsp+70h] [rbp-10h]
  int i; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter number of accounts: ");
  scanf("%d", &v6);
  Block = malloc(8i64 * v6);
  v9 = malloc(8i64 * v6);
  for ( i = 0; i < v6; ++i )
  {
    printf("Account %d\n", (unsigned int)(i + 1));
    printf("Enter username: ");
    scanf("%s", String);
    while ( !(unsigned int)validate_username(String) )
    {
      printf("Invalid username! Must be alphanumeric and no more than %d characters long.\n", 20i64);
      printf("Enter username: ");
      scanf("%s", String);
    }
    printf("Enter password: ");
    scanf("%s", v7);
    while ( !(unsigned int)validate_password(v7) )
    {
      printf(
        "Invalid password! Must be between 8 and 20 characters long and contain at least one uppercase letter, one lowerc"
        "ase letter, and one digit.\n");
      printf("Enter password: ");
      scanf("%s", v7);
    }
    v3 = (char **)((char *)Block + 8 * i);
    *v3 = strdup(String);
    v4 = (char **)((char *)v9 + 8 * i);
    *v4 = strdup(v7);
  }
  printf("\n\nYour accounts:\n");
  for ( i = 0; i < v6; ++i )
    printf("%-20s %s\n", *((const char **)Block + i), *((const char **)v9 + i));
  for ( i = 0; i < v6; ++i )
  {
    free(*((void **)Block + i));
    free(*((void **)v9 + i));
  }
  free(Block);
  free(v9);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall validate_username(_QWORD);
// 140001650: using guessed type __int64 __fastcall validate_password(_QWORD);
// 140001AA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Binary Converter ; Style: Claude Shannon
#include <stdio.h>
#include <math.h>

// Function to convert decimal to binary
long long decimalToBinary(int decimalNumber)
{
    int remainder;
    long long binaryNumber = 0, i = 1;

    while (decimalNumber != 0)
    {
        remainder = decimalNumber % 2;
        decimalNumber /= 2;
        binaryNumber += remainder * i;
        i *= 10;
    }

    return binaryNumber;
}

// Function to convert binary to decimal
int binaryToDecimal(long long binaryNumber)
{
    int decimalNumber = 0, i = 0, remainder;

    while (binaryNumber != 0)
    {
        remainder = binaryNumber % 10;
        binaryNumber /= 10;
        decimalNumber += remainder * pow(2, i);
        ++i;
    }

    return decimalNumber;
}

int main()
{
    int choice, decimalNumber;
    long long binaryNumber;

    do
    {
        printf("Binary Converter Menu\n");
        printf("1. Convert decimal to binary\n");
        printf("2. Convert binary to decimal\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
            case 1:
                printf("Enter a decimal number: ");
                scanf("%d", &decimalNumber);
                binaryNumber = decimalToBinary(decimalNumber);
                printf("Binary number: %lld\n", binaryNumber);
                break;

            case 2:
                printf("Enter a binary number: ");
                scanf("%lld", &binaryNumber);
                decimalNumber = binaryToDecimal(binaryNumber);
                printf("Decimal number: %d\n", decimalNumber);
                break;

            case 3:
                printf("Exiting the program\n");
                break;

            default:
                printf("Invalid choice\n");
        }
    } while (choice != 3);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall decimalToBinary(_QWORD); // weak
__int64 __fastcall binaryToDecimal(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000173D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v5; // [rsp+28h] [rbp-8h] BYREF
  int v6; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("Binary Converter Menu\n");
    printf("1. Convert decimal to binary\n");
    printf("2. Convert binary to decimal\n");
    printf("3. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v6);
    if ( v6 == 3 )
    {
      printf("Exiting the program\n");
    }
    else
    {
      if ( v6 > 3 )
        goto LABEL_10;
      if ( v6 == 1 )
      {
        printf("Enter a decimal number: ");
        scanf("%d", &v5);
        v4 = decimalToBinary(v5);
        printf("Binary number: %lld\n", v4);
        continue;
      }
      if ( v6 == 2 )
      {
        printf("Enter a binary number: ");
        scanf("%lld", &v4);
        v5 = binaryToDecimal(v4);
        printf("Decimal number: %d\n", v5);
      }
      else
      {
LABEL_10:
        printf("Invalid choice\n");
      }
    }
  }
  while ( v6 != 3 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall decimalToBinary(_QWORD);
// 140001652: using guessed type __int64 __fastcall binaryToDecimal(_QWORD);
// 140001950: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cat Language Translator ; Style: Claude Shannon
/* Cat Language Translator */

#include <stdio.h>
#include <string.h>

int main() {

    printf("\n");
    printf("Welcome to the Cat Language Translator!\n");
    printf("\n");

    /* Input cat word */
    char cat_word[50];
    printf("Enter a word in Cat language: ");
    scanf("%s", cat_word);
    printf("\n");

    /* Translate cat word to English */
    if(strcmp(cat_word, "meow") == 0) {
        printf("Translation: Hello!\n");
    }
    else if(strcmp(cat_word, "purr") == 0) {
        printf("Translation: Thank you!\n");
    }
    else if(strcmp(cat_word, "hiss") == 0) {
        printf("Translation: I'm scared!\n");
    }
    else if(strcmp(cat_word, "sniff") == 0) {
        printf("Translation: What's that smell?\n");
    }
    else if(strcmp(cat_word, "lick") == 0) {
        printf("Translation: Yummy!\n");
    }
    else if(strcmp(cat_word, "scratch") == 0) {
        printf("Translation: I'm itchy!\n");
    }
    else if(strcmp(cat_word, "sleep") == 0) {
        printf("Translation: Zzz...\n");
    }
    else {
        printf("Translation: I don't understand!\n");
    }

    printf("\n");
    printf("Thank you for using the Cat Language Translator!\n");
    printf("\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[64]; // [rsp+20h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  printf("\n");
  printf("Welcome to the Cat Language Translator!\n");
  printf("\n");
  printf("Enter a word in Cat language: ");
  scanf("%s", Str1);
  printf("\n");
  if ( !strcmp(Str1, "meow") )
  {
    printf("Translation: Hello!\n");
  }
  else if ( !strcmp(Str1, "purr") )
  {
    printf("Translation: Thank you!\n");
  }
  else if ( !strcmp(Str1, "hiss") )
  {
    printf("Translation: I'm scared!\n");
  }
  else if ( !strcmp(Str1, "sniff") )
  {
    printf("Translation: What's that smell?\n");
  }
  else if ( !strcmp(Str1, "lick") )
  {
    printf("Translation: Yummy!\n");
  }
  else if ( !strcmp(Str1, "scratch") )
  {
    printf("Translation: I'm itchy!\n");
  }
  else if ( !strcmp(Str1, "sleep") )
  {
    printf("Translation: Zzz...\n");
  }
  else
  {
    printf("Translation: I don't understand!\n");
  }
  printf("\n");
  printf("Thank you for using the Cat Language Translator!\n");
  printf("\n");
  return 0;
}
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Ebook reader ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TITLE_LENGTH 100
#define MAX_AUTHOR_LENGTH 50
#define MAX_BOOKS 200

typedef struct {
    char title[MAX_TITLE_LENGTH];
    char author[MAX_AUTHOR_LENGTH];
    float price;
} Book;

int book_count = 0;
Book books[MAX_BOOKS];

void add_book() {
    if (book_count >= MAX_BOOKS) {
        printf("Error: Maximum number of books reached.\n");
        return;
    }

    Book new_book;

    printf("Enter the book's title: ");
    fgets(new_book.title, MAX_TITLE_LENGTH, stdin);

    printf("Enter the author's name: ");
    fgets(new_book.author, MAX_AUTHOR_LENGTH, stdin);

    printf("Enter the price: ");
    scanf("%f", &new_book.price);

    books[book_count] = new_book;
    book_count++;

    printf("Book added successfully!\n");
}

void display_books() {
    if (book_count == 0) {
        printf("No books to display.\n");
        return;
    }

    printf("Title\t\tAuthor\t\tPrice\n");
    printf("-------------------------------------------\n");

    for (int i = 0; i < book_count; i++) {
        printf("%s\t\t%s\t\t%.2f\n", books[i].title, books[i].author, books[i].price);
    }
}

int main() {
    int option;

    do {
        printf("\n\n*** Ebook Reader App ***\n");
        printf("1. Add Book\n");
        printf("2. Display Books\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");

        scanf("%d", &option);
        getchar();  // Consume the newline character left by scanf

        switch (option) {
            case 1:
                add_book();
                break;
            case 2:
                display_books();
                break;
            case 3:
                printf("Goodbye!\n");
                break;
            default:
                printf("Invalid option.\n");
        }
    } while (option != 3);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_book(void); // weak
__int64 display_books(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();


//----- (000000014000189B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("\n\n*** Ebook Reader App ***\n");
    printf("1. Add Book\n");
    printf("2. Display Books\n");
    printf("3. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    getchar();
    if ( v4 == 3 )
    {
      printf("Goodbye!\n");
    }
    else
    {
      if ( v4 > 3 )
        goto LABEL_10;
      if ( v4 == 1 )
      {
        add_book();
        continue;
      }
      if ( v4 == 2 )
        display_books();
      else
LABEL_10:
        printf("Invalid option.\n");
    }
  }
  while ( v4 != 3 );
  return 0;
}
// 1400015E2: using guessed type __int64 add_book(void);
// 1400017BC: using guessed type __int64 display_books(void);
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Unit converter ; Style: statistical
#include<stdio.h>

/* This program converts units from metric to imperial and vice versa*/

int main(){

    float input_val, output_val;
    char unit_type;

    printf("Welcome to the Unit Converter Program! \n\n");
    printf("Please enter the input value: ");
    scanf("%f", &input_val);

    printf("Please enter the unit type (m for metric, i for imperial): ");
    scanf(" %c", &unit_type);

    if(unit_type == 'm'){ // if input unit is metric
        printf("\nInput value in metric: %.2f\n", input_val);
        printf("Converted value in imperial: %.2f feet\n", input_val * 3.28);
        output_val = input_val * 3.28;
    }
    else if(unit_type == 'i'){ // if input unit is imperial
        printf("\nInput value in imperial: %.2f feet\n", input_val);
        printf("Converted value in metric: %.2f meters\n", input_val * 0.3048);
        output_val = input_val * 0.3048;
    }
    else{ // if invalid input unit is entered
        printf("Invalid unit type! Please enter 'm' for metric or 'i' for imperial. \n");
        return 0;
    }

    printf("\nThank you for using the Unit Converter Program! \n\n");
    printf("The input value was: %.2f\n", input_val);
    printf("The converted value is: %.2f \n", output_val);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  char v6; // [rsp+27h] [rbp-9h] BYREF
  float v7; // [rsp+28h] [rbp-8h] BYREF
  float v8; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Unit Converter Program! \n\n");
  printf("Please enter the input value: ");
  scanf("%f", &v7);
  printf("Please enter the unit type (m for metric, i for imperial): ");
  scanf(" %c", &v6);
  if ( v6 == 109 )
  {
    printf("\nInput value in metric: %.2f\n", v7);
    printf("Converted value in imperial: %.2f feet\n", 3.28 * v7);
    v3 = 3.28 * v7;
    v8 = v3;
  }
  else
  {
    if ( v6 != 105 )
    {
      printf("Invalid unit type! Please enter 'm' for metric or 'i' for imperial. \n");
      return 0;
    }
    printf("\nInput value in imperial: %.2f feet\n", v7);
    printf("Converted value in metric: %.2f meters\n", 0.3048 * v7);
    v4 = 0.3048 * v7;
    v8 = v4;
  }
  printf("\nThank you for using the Unit Converter Program! \n\n");
  printf("The input value was: %.2f\n", v7);
  printf("The converted value is: %.2f \n", v8);
  return 0;
}
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: scalable
#include <stdio.h>

// Define constants for pixel mapping
#define PIXEL_ON '*'
#define PIXEL_OFF '.'

// Define function to generate random binary array
void generateRandomBinaryArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] = rand() % 2; // generates random number 0 or 1
    }
}

// Define function to print pixel array
void printPixelArray(int pixelArray[], int width, int height) {
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            int index = i * width + j;
            if (pixelArray[index] == 1) {
                printf("%c", PIXEL_ON);
            } else {
                printf("%c", PIXEL_OFF);
            }
        }
        printf("\n");
    }
}

int main() {
    // Define size and dimensions for pixel array
    int width = 5;
    int height = 5;

    // Initialize pixel array
    int pixelArray[width * height];

    // Generate random binary array for pixel array
    generateRandomBinaryArray(pixelArray, width * height);

    // Print pixel array
    printPixelArray(pixelArray, width, height);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall generateRandomBinaryArray(_QWORD, _QWORD); // weak
__int64 __fastcall printPixelArray(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001696) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  char v5[8]; // [rsp+20h] [rbp-20h] BYREF
  char *v6; // [rsp+28h] [rbp-18h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  unsigned int v8; // [rsp+38h] [rbp-8h]
  unsigned int v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 5;
  v8 = 5;
  v7 = 24i64;
  v3 = alloca(112i64);
  v6 = v5;
  generateRandomBinaryArray(v5, 25i64);
  printPixelArray(v6, v9, v8);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall generateRandomBinaryArray(_QWORD, _QWORD);
// 1400015E8: using guessed type __int64 __fastcall printPixelArray(_QWORD, _QWORD, _QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001696: using guessed type char var_50[8];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature monitor ; Style: Linus Torvalds
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TEMP 100

int main(int argc, char **argv)
{
    // Check command line arguments
    if (argc < 2 || argc > 3)
    {
        printf("Usage: temp_monitor <device_file> [--verbose]\n");
        return 1;
    }

    // Open device file
    char *device_file = argv[1];
    FILE *device = fopen(device_file, "r");
    if (!device)
    {
        printf("Failed to open device file %s\n", device_file);
        return 2;
    }

    // Check verbose flag
    int verbose = 0;
    if (argc == 3 && strcmp(argv[2], "--verbose") == 0)
    {
        verbose = 1;
    }

    // Read temperature from device file
    char temp_str[MAX_TEMP];
    if (fgets(temp_str, MAX_TEMP, device) == NULL)
    {
        printf("Failed to read temperature from device file\n");
        fclose(device);
        return 3;
    }

    // Convert temperature string to integer
    int temp = atoi(temp_str);

    // Print temperature
    if (verbose)
    {
        printf("Temperature read from %s: %d\n", device_file, temp);
    }
    else
    {
        printf("%d\n", temp);
    }

    fclose(device);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// int __cdecl atoi(const char *String);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[100]; // [rsp+20h] [rbp-80h] BYREF
  unsigned int v5; // [rsp+84h] [rbp-1Ch]
  FILE *Stream; // [rsp+88h] [rbp-18h]
  char *FileName; // [rsp+90h] [rbp-10h]
  BOOL v8; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  if ( argc > 1 && argc <= 3 )
  {
    FileName = (char *)argv[1];
    Stream = fopen(FileName, "r");
    if ( Stream )
    {
      v8 = 0;
      if ( argc == 3 )
        v8 = strcmp(argv[2], "--verbose") == 0;
      if ( fgets(Buffer, 100, Stream) )
      {
        v5 = atoi(Buffer);
        if ( v8 )
          printf("Temperature read from %s: %d\n", FileName, v5);
        else
          printf("%d\n", v5);
        fclose(Stream);
        return 0;
      }
      else
      {
        printf("Failed to read temperature from device file\n");
        fclose(Stream);
        return 3;
      }
    }
    else
    {
      printf("Failed to open device file %s\n", FileName);
      return 2;
    }
  }
  else
  {
    printf("Usage: temp_monitor <device_file> [--verbose]\n");
    return 1;
  }
}
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Alien Invasion Probability Calculator ; Style: all-encompassing
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main(){
    srand(time(NULL)); // Initialize random seed
    int alienHealth = rand() % 100 + 1; // Generate random value for alien health (1-100)
    int alienAttack = rand() % 20 + 1; // Generate random value for alien attack (1-20)
    float alienAccuracy = ((float) rand() / (float) RAND_MAX); // Generate random value for alien accuracy (0-1)
    int humanHealth = rand() % 100 + 1; // Generate random value for human health (1-100)
    int humanAttack = rand() % 20 + 1; // Generate random value for human attack (1-20)
    float humanAccuracy = ((float) rand() / (float) RAND_MAX); // Generate random value for human accuracy (0-1)

    printf("ALIEN INVASION PROBABILITY CALCULATOR\n");
    printf("\n");
    printf("Alien Health: %d\n", alienHealth);
    printf("Alien Attack: %d\n", alienAttack);
    printf("Alien Accuracy: %.2f\n", alienAccuracy);
    printf("\n");
    printf("Human Health: %d\n", humanHealth);
    printf("Human Attack: %d\n", humanAttack);
    printf("Human Accuracy: %.2f\n", humanAccuracy);
    printf("\n");

    // Calculate probability of alien winning
    float alienWinProbability = alienAccuracy * alienHealth / (humanAttack * (1 - humanAccuracy) + alienAttack * alienAccuracy);
    printf("Probability of Alien Winning: %.2f%%\n", alienWinProbability * 100);

    // Calculate probability of human winning
    float humanWinProbability = (1 - alienAccuracy) * humanHealth / (alienAttack * alienAccuracy + humanAttack * (1 - humanAccuracy));
    printf("Probability of Human Winning: %.2f%%\n", humanWinProbability * 100);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  float v5; // [rsp+28h] [rbp-18h]
  int v6; // [rsp+2Ch] [rbp-14h]
  int v7; // [rsp+30h] [rbp-10h]
  float v8; // [rsp+34h] [rbp-Ch]
  int v9; // [rsp+38h] [rbp-8h]
  int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v10 = rand() % 100 + 1;
  v9 = rand() % 20 + 1;
  v8 = (float)rand() / 32767.0;
  v7 = rand() % 100 + 1;
  v6 = rand() % 20 + 1;
  v5 = (float)rand() / 32767.0;
  printf("ALIEN INVASION PROBABILITY CALCULATOR\n");
  printf("\n");
  printf("Alien Health: %d\n", (unsigned int)v10);
  printf("Alien Attack: %d\n", (unsigned int)v9);
  printf("Alien Accuracy: %.2f\n", v8);
  printf("\n");
  printf("Human Health: %d\n", (unsigned int)v7);
  printf("Human Attack: %d\n", (unsigned int)v6);
  printf("Human Accuracy: %.2f\n", v5);
  printf("\n");
  printf(
    "Probability of Alien Winning: %.2f%%\n",
    (float)(100.0
          * (float)((float)((float)v10 * v8) / (float)((float)((float)v9 * v8) + (float)((float)v6 * (float)(1.0 - v5))))));
  printf(
    "Probability of Human Winning: %.2f%%\n",
    (float)(100.0
          * (float)((float)((float)v7 * (float)(1.0 - v8))
                  / (float)((float)((float)(1.0 - v5) * (float)v6) + (float)((float)v9 * v8)))));
  return 0;
}
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fractal Generation ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

// Function to calculate the distance between two points
double distance(int x1, int y1, int x2, int y2)
{
    return sqrt(pow(x2-x1, 2) + pow(y2-y1, 2));
}

// Function to generate fractal using chaos game algorithm
void chaos_game(int num_points, int max_iterations, double ratio, int vertices[][2])
{
    int x = rand() % 640; // set x to random value between 0 and 640
    int y = rand() % 480; // set y to random value between 0 and 480
    int i = 0;
    double dist;

    FILE *fp;
    fp = fopen("fractal.txt", "w");

    while (i < max_iterations)
    {
        int v = rand() % num_points; // choose a random vertex
        int vx = vertices[v][0];
        int vy = vertices[v][1];
        dist = distance(x, y, vx, vy);

        // calculate new point
        x = ratio * (vx - x) + x;
        y = ratio * (vy - y) + y;

        // write new point to file
        fprintf(fp, "%d %d\n", x, y);

        i++;
    }

    fclose(fp);
}

int main()
{
    int num_points = 3; // number of vertices
    int max_iterations = 100000; // max number of iterations
    double ratio = 0.5; // ratio between old and new points

    int vertices[3][2] = {{100, 100}, {540, 100}, {320, 480}}; // vertices of triangle

    srand(time(NULL)); // seed random number generator

    chaos_game(num_points, max_iterations, ratio, vertices);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 __fastcall chaos_game(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400017D9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v4; // r8
  int v6[8]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v7; // [rsp+40h] [rbp-10h]

  _main(argc, argv, envp);
  v7 = 0x3FE0000000000000i64;
  v6[0] = 100;
  v6[1] = 100;
  v6[2] = 540;
  v6[3] = 100;
  v6[4] = 320;
  v6[5] = 480;
  v3 = time(0i64);
  srand(v3);
  ((void (__fastcall *)(__int64, __int64, __int64, int *))chaos_game)(3i64, 100000i64, v4, v6);
  return 0;
}
// 140001854: variable 'v4' is possibly undefined
// 14000163B: using guessed type __int64 __fastcall chaos_game(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=151 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game ; Style: statistical
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main(){
    srand(time(NULL)); //initializing random seed
    
    int n, i, j, sum=0, counter=0;
    
    printf("Enter the number of rows/columns for a square matrix: ");
    scanf("%d", &n); //taking input for matrix size
    
    int matrix[n][n]; //declaring a 2D array to store the matrix elements
    printf("Enter the elements of the matrix:\n");
    
    for(i=0; i<n; i++){
        for(j=0; j<n; j++){
            scanf("%d", &matrix[i][j]); //taking input for matrix elements
        }
    }
    
    for(i=0; i<n; i++){
        for(j=0; j<n; j++){
            sum+=matrix[i][j]; //calculating the sum of matrix elements
            counter++; //incrementing the counter for each element
        }
    }
    
    printf("The entered matrix is:\n");
    for(i=0; i<n; i++){
        for(j=0; j<n; j++){
            printf("%d ", matrix[i][j]); //displaying the entered matrix
        }
        printf("\n");
    }
    
    printf("\nThe sum of all the elements in the matrix is %d\n", sum);
    printf("The average of all the elements in the matrix is %.2f\n", (float)sum/counter);
    
    //code for finding the maximum and minimum element in the matrix
    int max=matrix[0][0], min=matrix[0][0];
    for(i=0; i<n; i++){
        for(j=0; j<n; j++){
            if(matrix[i][j]>max) max=matrix[i][j];
            if(matrix[i][j]<min) min=matrix[i][j];
        }
    }
    
    printf("The maximum element in the matrix is %d\n", max);
    printf("The minimum element in the matrix is %d\n", min);
    
    //code for finding the frequency of all the elements in the matrix
    int frequency[100]={0};
    for(i=0; i<n; i++){
        for(j=0; j<n; j++){
            frequency[matrix[i][j]]++; //incrementing the counter for each element
        }
    }
    
    printf("\nThe frequency of all the elements in the matrix is:\n");
    for(i=min; i<=max; i++){
        if(frequency[i]>0){
            printf("%d occurs %d times\n", i, frequency[i]); //displaying the frequency of each element
        }
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned __int64 v4; // rbx
  void *v5; // rsp
  int v6; // eax
  __int64 v8; // [rsp+0h] [rbp-80h] BYREF
  char v9; // [rsp+20h] [rbp-60h] BYREF
  __int64 *v10; // [rsp+28h] [rbp-58h]
  __int64 v11; // [rsp+30h] [rbp-50h]
  __int64 v12; // [rsp+38h] [rbp-48h]
  __int64 v13; // [rsp+40h] [rbp-40h]
  __int64 v14; // [rsp+48h] [rbp-38h]
  int v15[103]; // [rsp+50h] [rbp-30h] BYREF
  int v16; // [rsp+1ECh] [rbp+16Ch] BYREF
  int *v17; // [rsp+1F0h] [rbp+170h]
  __int64 v18; // [rsp+1F8h] [rbp+178h]
  __int64 v19; // [rsp+200h] [rbp+180h]
  unsigned int v20; // [rsp+208h] [rbp+188h]
  int v21; // [rsp+20Ch] [rbp+18Ch]
  int v22; // [rsp+210h] [rbp+190h]
  unsigned int v23; // [rsp+214h] [rbp+194h]
  int j; // [rsp+218h] [rbp+198h]
  int i; // [rsp+21Ch] [rbp+19Ch]

  _main(argc, argv, envp);
  v10 = &v8;
  v3 = time(0i64);
  srand(v3);
  v23 = 0;
  v22 = 0;
  printf("Enter the number of rows/columns for a square matrix: ");
  scanf("%d", &v16);
  v19 = v16 - 1i64;
  v11 = v16;
  v12 = 0i64;
  v4 = 4i64 * v16;
  v18 = v19;
  v13 = v16;
  v14 = 0i64;
  v5 = alloca(16 * ((unsigned __int64)(4 * v16 * (__int64)v16 + 15) >> 4));
  v17 = (int *)&v9;
  printf("Enter the elements of the matrix:\n");
  for ( i = 0; i < v16; ++i )
  {
    for ( j = 0; j < v16; ++j )
      scanf("%d", &v17[j + (v4 >> 2) * i]);
  }
  for ( i = 0; i < v16; ++i )
  {
    for ( j = 0; j < v16; ++j )
    {
      v23 += v17[j + (v4 >> 2) * i];
      ++v22;
    }
  }
  printf("The entered matrix is:\n");
  for ( i = 0; i < v16; ++i )
  {
    for ( j = 0; j < v16; ++j )
      printf("%d ", (unsigned int)v17[j + (v4 >> 2) * i]);
    printf("\n");
  }
  printf("\nThe sum of all the elements in the matrix is %d\n", v23);
  printf("The average of all the elements in the matrix is %.2f\n", (float)((float)(int)v23 / (float)v22));
  v21 = *v17;
  v20 = *v17;
  for ( i = 0; i < v16; ++i )
  {
    for ( j = 0; j < v16; ++j )
    {
      if ( v21 < v17[j + (v4 >> 2) * i] )
        v21 = v17[j + (v4 >> 2) * i];
      if ( (int)v20 > v17[j + (v4 >> 2) * i] )
        v20 = v17[j + (v4 >> 2) * i];
    }
  }
  printf("The maximum element in the matrix is %d\n", (unsigned int)v21);
  printf("The minimum element in the matrix is %d\n", v20);
  memset(v15, 0, 0x190ui64);
  for ( i = 0; i < v16; ++i )
  {
    for ( j = 0; j < v16; ++j )
    {
      v6 = v17[j + (v4 >> 2) * i];
      ++v15[v6];
    }
  }
  printf("\nThe frequency of all the elements in the matrix is:\n");
  for ( i = v20; i <= v21; ++i )
  {
    if ( v15[i] > 0 )
      printf("%d occurs %d times\n", (unsigned int)i, (unsigned int)v15[i]);
  }
  return 0;
}
// 140001C90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001601: using guessed type int var_210[103];

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data recovery tool ; Style: ultraprecise
#include <stdio.h>              // for standard input/output operations
#include <stdlib.h>             // for malloc() and free() functions
#include <string.h>             // for memcpy() function

#define MAX_FILE_SIZE 10485760  // maximum file size set to 10 MB

void read_file(char *input_file_name, char *data_buffer);

void write_file(char *output_file_name, char *data_buffer_to_write);

int main(int argc, char *argv[]) {
    char *data_buffer = NULL;
    char *output_file_name = NULL;

    if (argc == 3) {
        // allocate memory for data buffer
        data_buffer = (char *) malloc(MAX_FILE_SIZE * sizeof(char));

        // read input file
        read_file(argv[1], data_buffer);

        // write output file
        output_file_name = strdup(argv[2]);
        write_file(output_file_name, data_buffer);

        // free memory used by buffer
        free(data_buffer);
        data_buffer = NULL;

        printf("File recovery successful!\n");
    } else {
        printf("Error: Invalid input. Usage: %s <input_file_name> <output_file_name>\n", argv[0]);
    }

    return 0;
}

void read_file(char *input_file_name, char *data_buffer) {
    FILE *input_file = NULL;
    size_t file_size = 0;

    // Open file for reading in binary mode
    input_file = fopen(input_file_name, "rb");

    // Check if file exists and can be opened
    if (input_file == NULL) {
        printf("Error: Cannot open file %s\n", input_file_name);
        exit(1);
    }

    // Get file size
    fseek(input_file, 0, SEEK_END);
    file_size = ftell(input_file);
    fseek(input_file, 0, SEEK_SET);

    // Check if file size is within limits
    if (file_size > MAX_FILE_SIZE) {
        printf("Error: Input file size too large. Maximum size allowed is %d bytes\n", MAX_FILE_SIZE);
        fclose(input_file);
        exit(1);
    }

    // Read file content into data buffer
    fread(data_buffer, file_size, 1, input_file);

    // Close input file
    fclose(input_file);
}

void write_file(char *output_file_name, char *data_buffer_to_write) {
    FILE *output_file = NULL;

    // Open file for writing in binary mode
    output_file = fopen(output_file_name, "wb");

    // Check if file exists and can be opened
    if (output_file == NULL) {
        printf("Error: Cannot open file %s for writing\n", output_file_name);
        exit(1);
    }

    // Write data buffer to output file
    fwrite(data_buffer_to_write, strlen(data_buffer_to_write), 1, output_file);

    // Close output file
    fclose(output_file);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall read_file(_QWORD, _QWORD); // weak
__int64 __fastcall write_file(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strdup(const char *String);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v4; // [rsp+20h] [rbp-10h]
  void *Block; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc == 3 )
  {
    Block = malloc(0xA00000ui64);
    read_file(argv[1], Block);
    v4 = strdup(argv[2]);
    write_file(v4, Block);
    free(Block);
    printf("File recovery successful!\n");
  }
  else
  {
    printf("Error: Invalid input. Usage: %s <input_file_name> <output_file_name>\n", *argv);
  }
  return 0;
}
// 140001650: using guessed type __int64 __fastcall read_file(_QWORD, _QWORD);
// 14000174F: using guessed type __int64 __fastcall write_file(_QWORD, _QWORD);
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Color Code Converter ; Style: romantic
#include <stdio.h>

// Function to convert an integer value to its corresponding hexadecimal digit
char toHexDigit(int value)
{
    if (value >= 0 && value <= 9)
    {
        return (char)(value + '0');
    }
    else if (value >= 10 && value <= 15)
    {
        return (char)(value - 10 + 'A');
    }
    
    return '\0';
}

// Function to convert an RGB color code to its equivalent hexadecimal value
void rgbToHex(int r, int g, int b)
{
    int hexR = r / 16;
    int hexG = g / 16;
    int hexB = b / 16;
    
    int remR = r % 16;
    int remG = g % 16;
    int remB = b % 16;
    
    char hexCode[7];
    hexCode[0] = '#';
    hexCode[1] = toHexDigit(hexR);
    hexCode[2] = toHexDigit(remR);
    hexCode[3] = toHexDigit(hexG);
    hexCode[4] = toHexDigit(remG);
    hexCode[5] = toHexDigit(hexB);
    hexCode[6] = toHexDigit(remB);
    
    printf("Equivalent hexadecimal code: %s\n", hexCode);
}

// Function to convert a hexadecimal color code to its equivalent RGB value
void hexToRgb(char* hexCode)
{
    int r, g, b;
    
    sscanf(hexCode, "#%2x%2x%2x", &r, &g, &b);
    
    printf("Equivalent RGB code: %d, %d, %d\n", r, g, b);
}

// Main function
int main()
{
    int choice, r, g, b;
    char hexCode[7];
    
    printf("C Color Code Converter Program\n");
    printf("------------------------------\n");
    printf("1. RGB to Hexadecimal\n");
    printf("2. Hexadecimal to RGB\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
    
    switch (choice)
    {
        case 1:
            printf("Enter the values of R, G, B (separated by spaces): ");
            scanf("%d %d %d", &r, &g, &b);
            rgbToHex(r, g, b);
            break;
            
        case 2:
            printf("Enter the hexadecimal code (format: #RRGGBB): ");
            scanf("%s", hexCode);
            hexToRgb(hexCode);
            break;
            
        default:
            printf("Invalid choice.\n");
            break;
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall rgbToHex(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall hexToRgb(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000179F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[7]; // [rsp+29h] [rbp-17h] BYREF
  unsigned int v5; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v6; // [rsp+34h] [rbp-Ch] BYREF
  unsigned int v7; // [rsp+38h] [rbp-8h] BYREF
  int v8; // [rsp+3Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("C Color Code Converter Program\n");
  printf("------------------------------\n");
  printf("1. RGB to Hexadecimal\n");
  printf("2. Hexadecimal to RGB\n");
  printf("Enter your choice: ");
  scanf("%d", &v8);
  if ( v8 == 1 )
  {
    printf("Enter the values of R, G, B (separated by spaces): ");
    scanf("%d %d %d", &v7, &v6, &v5);
    rgbToHex(v7, v6, v5);
  }
  else if ( v8 == 2 )
  {
    printf("Enter the hexadecimal code (format: #RRGGBB): ");
    scanf("%s", v4);
    hexToRgb(v4);
  }
  else
  {
    printf("Invalid choice.\n");
  }
  return 0;
}
// 14000165B: using guessed type __int64 __fastcall rgbToHex(_QWORD, _QWORD, _QWORD);
// 140001742: using guessed type __int64 __fastcall hexToRgb(_QWORD);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/* Function to generate a random number */
int generateRandomNumber(int limit) {
  srand(time(NULL));  // Seed the random number generator with current time
  return rand() % limit;  // Return a random number between 0 and the limit
}

/* Game function */
void game() {
  int limit = 20;  // Maximum number to guess
  int randomNumber = generateRandomNumber(limit);  // Generate a random number between 0 and limit
  int guess = -1;  // Initialize the guess to an invalid value

  printf("I am thinking of a number between 0 and %d. Can you guess what it is?\n", limit);

  while (guess != randomNumber) {
    printf("Enter your guess: ");
    scanf("%d", &guess);

    if (guess < randomNumber) {
      printf("Your guess is too low. Try again.\n");
    } else if (guess > randomNumber) {
      printf("Your guess is too high. Try again.\n");
    } else {
      printf("Congratulations! You guessed the number correctly.\n");
    }
  }
}

/* Main function */
int main() {
  char playAgain = 'y';

  while (playAgain == 'y' || playAgain == 'Y') {
    game();

    printf("Do you want to play again? (y/n): ");
    scanf(" %c", &playAgain);
  }

  printf("Thanks for playing!\n");
 
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 game(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016DD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char i; // [rsp+2Fh] [rbp-1h] BYREF

  _main(argc, argv, envp);
  for ( i = 121; i == 121 || i == 89; scanf(" %c", &i) )
  {
    game();
    printf("Do you want to play again? (y/n): ");
  }
  printf("Thanks for playing!\n");
  return 0;
}
// 14000162E: using guessed type __int64 game(void);
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Audio processing ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define BUFFER_SIZE 8192

void processing(unsigned char *buffer, int buffer_size) {
    // Define audio parameters
    float sample_rate = 44100.0;
    float frequency = 1000;
    float amplitude = 0.5;
    float phase = 0.0;
    
    int sample, i;
    float time, value;
    
    // Process each sample in the buffer
    for(i=0; i<buffer_size; i+=2) {
        // Calculate time and sample value
        time = (float)i / (float)sample_rate;
        value = amplitude * sin(2.0 * M_PI * frequency * time + phase);
        
        // Convert value from float to short and store in buffer
        sample = (int)(value * 32767.0);
        buffer[i] = sample & 0xff;
        buffer[i+1] = (sample >> 8) & 0xff;
    }
}

int main() {
    unsigned char buffer[BUFFER_SIZE];
    
    // Fill buffer with silence
    int i;
    for(i=0; i<BUFFER_SIZE; i++) {
        buffer[i] = 128;
    }
    
    // Process audio
    processing(buffer, BUFFER_SIZE);
    
    // Write audio to file
    FILE *file;
    file = fopen("output.pcm", "wb");
    if(file != NULL) {
        fwrite(buffer, sizeof(unsigned char), BUFFER_SIZE, file);
        fclose(file);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall processing(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (000000014000165C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[8192]; // [rsp+20h] [rbp-60h] BYREF
  FILE *Stream; // [rsp+2020h] [rbp+1FA0h]
  int i; // [rsp+202Ch] [rbp+1FACh]

  _main(argc, argv, envp);
  for ( i = 0; i <= 0x1FFF; ++i )
    Buffer[i] = 0x80;
  processing(Buffer, 0x2000i64);
  Stream = fopen("output.pcm", "wb");
  if ( Stream )
  {
    fwrite(Buffer, 1ui64, 0x2000ui64, Stream);
    fclose(Stream);
  }
  return 0;
}
// 140001540: using guessed type __int64 __fastcall processing(_QWORD, _QWORD);
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000165C: using guessed type char Buffer[8192];

// nfuncs=84 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Spell checking ; Style: cheerful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// function to check if a word is correctly spelled
int spell_check(char *word)
{
    // list of correctly spelled words
    char *dictionary[] = {"happy", "cheerful", "excited", "joyful", "friendly", "fun"};

    // loop through the dictionary to check if the word is present
    for (int i = 0; i < 6; i++) {
        if (strcmp(word, dictionary[i]) == 0) {
            return 1; // word is correctly spelled
        }
    }

    return 0; // word is misspelled
}

// function to convert all letters to lowercase
void lowercase(char *string)
{
    for (int i = 0; i < strlen(string); i++) {
        string[i] = tolower(string[i]);
    }
}

int main()
{
    char input[100];

    printf("Hello! I am the cheerful spell checker!\n\n");

    while (1) {
        // get user input
        printf("Please enter a word to check (enter 'quit' to exit): ");
        fgets(input, sizeof(input), stdin);

        // remove newline character from input
        input[strcspn(input, "\n")] = 0;

        // convert input to lowercase
        lowercase(input);

        // check if user wants to quit
        if (strcmp(input, "quit") == 0) {
            printf("\nGoodbye! Have a great day!\n");
            break;
        }

        // check if word is correctly spelled
        if (spell_check(input)) {
            printf("\n%s is spelled correctly!\n\n", input);
        } else {
            printf("\nOops! It looks like %s is misspelled. Please try again.\n\n", input);
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall spell_check(_QWORD); // weak
__int64 __fastcall lowercase(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001686) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[112]; // [rsp+20h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Hello! I am the cheerful spell checker!\n\n");
  while ( 1 )
  {
    printf("Please enter a word to check (enter 'quit' to exit): ");
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 100, v3);
    Buffer[strcspn(Buffer, "\n")] = 0;
    lowercase(Buffer);
    if ( !strcmp(Buffer, "quit") )
      break;
    if ( (unsigned int)spell_check(Buffer) )
      printf("\n%s is spelled correctly!\n\n", Buffer);
    else
      printf("\nOops! It looks like %s is misspelled. Please try again.\n\n", Buffer);
  }
  printf("\nGoodbye! Have a great day!\n");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall spell_check(_QWORD);
// 14000161E: using guessed type __int64 __fastcall lowercase(_QWORD);
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001686: using guessed type char Buffer[112];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Hotel Management System ; Style: accurate
#include<stdio.h>
#include<string.h>

#define MAX_ROOMS 50

//Structure for Room
typedef struct {
    int roomNumber;
    char occupantName[30];
    int occupancyStatus;
} Room;

//Function prototypes
void addRoom(Room rooms[], int *numRooms);
void removeRoom(Room rooms[], int *numRooms);
void displayRooms(Room rooms[], int numRooms);
void checkIn(Room rooms[], int numRooms);
void checkOut(Room rooms[], int numRooms);

int main() {
    Room rooms[MAX_ROOMS];
    int numRooms = 0, option;

    //Menu driven code
    do {
        printf("\n-- Hotel Management System --\n");
        printf("1. Add Room\n");
        printf("2. Remove Room\n");
        printf("3. Display Rooms\n");
        printf("4. Check In\n");
        printf("5. Check Out\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &option);

        switch(option) {
            case 1: //Add Room
                addRoom(rooms, &numRooms);
                break;
            case 2: //Remove Room
                removeRoom(rooms, &numRooms);
                break;
            case 3: //Display Rooms
                displayRooms(rooms, numRooms);
                break;
            case 4: //Check In
                checkIn(rooms, numRooms);
                break;
            case 5: //Check Out
                checkOut(rooms, numRooms);
                break;
            case 6: //Exit
                printf("\nExiting Hotel Management System...\n");
                break;
            default:
                printf("\nInvalid option. Please enter a valid option.\n");
                break;
        }
    } while(option != 6);

    return 0;
}

//Function to add a room
void addRoom(Room rooms[], int *numRooms) {
    int i, roomNumber;

    //Checking if maximum number of rooms are already present
    if(*numRooms == MAX_ROOMS) {
        printf("\nMaximum limit of rooms reached.\n");
        return;
    }

    //Checking if room already exists
    printf("\nEnter room number: ");
    scanf("%d", &roomNumber);
    for(i=0; i<*numRooms; i++) {
        if(roomNumber == rooms[i].roomNumber) {
            printf("\nRoom already exists.\n");
            return;
        }
    }

    //Adding new room
    rooms[*numRooms].roomNumber = roomNumber;
    strcpy(rooms[*numRooms].occupantName, "Not Occupied");
    rooms[*numRooms].occupancyStatus = 0;
    printf("\nRoom added successfully.\n");
    (*numRooms)++;
}

//Function to remove a room
void removeRoom(Room rooms[], int *numRooms) {
    int i, j, roomNumber, flag=0;

    //Checking if no rooms are present
    if(*numRooms == 0) {
        printf("\nNo rooms present.\n");
        return;
    }

    //Checking if room exists
    printf("\nEnter room number: ");
    scanf("%d", &roomNumber);
    for(i=0; i<*numRooms; i++) {
        if(roomNumber == rooms[i].roomNumber) {
            flag = 1;
            break;
        }
    }
    if(!flag) {
        printf("\nRoom does not exist.\n");
        return;
    }

    //Removing the room
    for(j=i+1; j<*numRooms; j++) {
        rooms[j-1].roomNumber = rooms[j].roomNumber;
        strcpy(rooms[j-1].occupantName, rooms[j].occupantName);
        rooms[j-1].occupancyStatus = rooms[j].occupancyStatus;
    }
    (*numRooms)--;
    printf("\nRoom removed successfully.\n");
}

//Function to display all rooms
void displayRooms(Room rooms[], int numRooms) {
    int i;

    //Checking if no rooms are present
    if(numRooms == 0) {
        printf("\nNo rooms present.\n");
        return;
    }

    //Displaying all rooms
    for(i=0; i<numRooms; i++) {
        printf("\nRoom Number: %d", rooms[i].roomNumber);
        printf("\nOccupant Name: %s", rooms[i].occupantName);
        printf("\nOccupancy Status: %d", rooms[i].occupancyStatus);
        printf("\n\n");
    }
}

//Function to check in a room
void checkIn(Room rooms[], int numRooms) {
    int i, roomNumber;

    //Checking if no rooms are present
    if(numRooms == 0) {
        printf("\nNo rooms present.\n");
        return;
    }

    //Checking if room already occupied
    printf("\nEnter room number: ");
    scanf("%d", &roomNumber);
    for(i=0; i<numRooms; i++) {
        if(roomNumber == rooms[i].roomNumber) {
            if(rooms[i].occupancyStatus == 1) {
                printf("\nRoom already occupied.\n");
                return;
            }
            printf("\nEnter occupant name: ");
            scanf("%s", rooms[i].occupantName);
            rooms[i].occupancyStatus = 1;
            printf("\nRoom checked in successfully.\n");
            return;
        }
    }
    printf("\nRoom does not exist.\n");
}

//Function to check out a room
void checkOut(Room rooms[], int numRooms) {
    int i, roomNumber;

    //Checking if no rooms are present
    if(numRooms == 0) {
        printf("\nNo rooms present.\n");
        return;
    }

    //Checking if room already vacant
    printf("\nEnter room number: ");
    scanf("%d", &roomNumber);
    for(i=0; i<numRooms; i++) {
        if(roomNumber == rooms[i].roomNumber) {
            if(rooms[i].occupancyStatus == 0) {
                printf("\nRoom already vacant.\n");
                return;
            }
            strcpy(rooms[i].occupantName, "Not Occupied");
            rooms[i].occupancyStatus = 0;
            printf("\nRoom checked out successfully.\n");
            return;
        }
    }
    printf("\nRoom does not exist.\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall addRoom(_QWORD, _QWORD); // weak
__int64 __fastcall removeRoom(_QWORD, _QWORD); // weak
__int64 __fastcall displayRooms(_QWORD, _QWORD); // weak
__int64 __fastcall checkIn(_QWORD, _QWORD); // weak
__int64 __fastcall checkOut(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[2000]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  do
  {
    printf("\n-- Hotel Management System --\n");
    printf("1. Add Room\n");
    printf("2. Remove Room\n");
    printf("3. Display Rooms\n");
    printf("4. Check In\n");
    printf("5. Check Out\n");
    printf("6. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        addRoom(v6, &v5);
        break;
      case 2:
        removeRoom(v6, &v5);
        break;
      case 3:
        displayRooms(v6, v5);
        break;
      case 4:
        checkIn(v6, v5);
        break;
      case 5:
        checkOut(v6, v5);
        break;
      case 6:
        printf("\nExiting Hotel Management System...\n");
        break;
      default:
        printf("\nInvalid option. Please enter a valid option.\n");
        break;
    }
  }
  while ( v4 != 6 );
  return 0;
}
// 14000174C: using guessed type __int64 __fastcall addRoom(_QWORD, _QWORD);
// 1400018A2: using guessed type __int64 __fastcall removeRoom(_QWORD, _QWORD);
// 140001A77: using guessed type __int64 __fastcall displayRooms(_QWORD, _QWORD);
// 140001B68: using guessed type __int64 __fastcall checkIn(_QWORD, _QWORD);
// 140001CC6: using guessed type __int64 __fastcall checkOut(_QWORD, _QWORD);
// 140001ED0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Drone Remote Control ; Style: cheerful
#include <stdio.h>
#include <stdlib.h>

int main()
{
    printf("Welcome to the C Drone Remote Control Program! \n");
    printf("Enter '1' to take off, '2' to land, '3' to move forward, '4' to move backward, '5' to turn left, '6' to turn right, '7' to increase altitude, '8' to decrease altitude, and '9' to exit the program. \n");

    int droneState = 0; // 0 = landed, 1 = in air
    int altitude = 0;
    int input;

    while(1) // infinite loop
    {
        printf("Enter command: ");
        scanf("%d", &input);

        if(input == 1) // take off
        {
            if(droneState == 0)
            {
                printf("Drone taking off... \n");
                droneState = 1;
                altitude += 10;
            }
            else
            {
                printf("Drone already in air! \n");
            }
        }
        else if(input == 2) // land
        {
            if(droneState == 1)
            {
                printf("Drone landing... \n");
                droneState = 0;
                altitude = 0;
            }
            else
            {
                printf("Drone already landed! \n");
            }
        }
        else if(input == 3) // move forward
        {
            if(droneState == 1)
            {
                printf("Drone moving forward... \n");
            }
            else
            {
                printf("Drone must be in air to move! \n");
            }
        }
        else if(input == 4) // move backward
        {
            if(droneState == 1)
            {
                printf("Drone moving backward... \n");
            }
            else
            {
                printf("Drone must be in air to move! \n");
            }
        }
        else if(input == 5) // turn left
        {
            if(droneState == 1)
            {
                printf("Drone turning left... \n");
            }
            else
            {
                printf("Drone must be in air to turn! \n");
            }
        }
        else if(input == 6) // turn right
        {
            if(droneState == 1)
            {
                printf("Drone turning right... \n");
            }
            else
            {
                printf("Drone must be in air to turn! \n");
            }
        }
        else if(input == 7) // increase altitude
        {
            if(droneState == 1)
            {
                printf("Drone increasing altitude... \n");
                altitude += 5;
            }
            else
            {
                printf("Drone must be in air to increase altitude! \n");
            }
        }
        else if(input == 8) // decrease altitude
        {
            if(droneState == 1)
            {
                if(altitude > 5)
                {
                    printf("Drone decreasing altitude... \n");
                    altitude -= 5;
                }
                else
                {
                    printf("Drone can't decrease altitude any further! \n");
                }
            }
            else
            {
                printf("Drone must be in air to decrease altitude! \n");
            }
        }
        else if(input == 9) // exit program
        {
            printf("Exiting drone control program... \n");
            exit(0);
        }
        else // invalid input
        {
            printf("Invalid command! \n");
        }

        printf("Drone state: %d | Altitude: %d \n", droneState, altitude); // print drone state and altitude
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int v5; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the C Drone Remote Control Program! \n");
  printf(
    "Enter '1' to take off, '2' to land, '3' to move forward, '4' to move backward, '5' to turn left, '6' to turn right, "
    "'7' to increase altitude, '8' to decrease altitude, and '9' to exit the program. \n");
  v5 = 0;
  for ( i = 0; ; printf("Drone state: %d | Altitude: %d \n", v5, i) )
  {
    printf("Enter command: ");
    scanf("%d", &v3);
    switch ( v3 )
    {
      case 1:
        if ( v5 )
        {
          printf("Drone already in air! \n");
        }
        else
        {
          printf("Drone taking off... \n");
          v5 = 1;
          i += 10;
        }
        break;
      case 2:
        if ( v5 == 1 )
        {
          printf("Drone landing... \n");
          v5 = 0;
          i = 0;
        }
        else
        {
          printf("Drone already landed! \n");
        }
        break;
      case 3:
        if ( v5 == 1 )
        {
          printf("Drone moving forward... \n");
          continue;
        }
LABEL_13:
        printf("Drone must be in air to move! \n");
        continue;
      case 4:
        if ( v5 != 1 )
          goto LABEL_13;
        printf("Drone moving backward... \n");
        break;
      case 5:
        if ( v5 == 1 )
        {
          printf("Drone turning left... \n");
          continue;
        }
LABEL_21:
        printf("Drone must be in air to turn! \n");
        continue;
      case 6:
        if ( v5 != 1 )
          goto LABEL_21;
        printf("Drone turning right... \n");
        break;
      case 7:
        if ( v5 == 1 )
        {
          printf("Drone increasing altitude... \n");
          i += 5;
        }
        else
        {
          printf("Drone must be in air to increase altitude! \n");
        }
        break;
      case 8:
        if ( v5 == 1 )
        {
          if ( (int)i <= 5 )
          {
            printf("Drone can't decrease altitude any further! \n");
          }
          else
          {
            printf("Drone decreasing altitude... \n");
            i -= 5;
          }
        }
        else
        {
          printf("Drone must be in air to decrease altitude! \n");
        }
        break;
      case 9:
        printf("Exiting drone control program... \n");
        exit(0);
      default:
        printf("Invalid command! \n");
        break;
    }
  }
}
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: shocked
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    int *a = (int*) malloc(n * sizeof(int));
    for(int i=0; i<n; i++) {
        scanf("%d", &a[i]);
    }
    int *b = (int*) malloc(m * sizeof(int));
    for(int i=0; i<m; i++) {
        scanf("%d", &b[i]);
    }
    int ans = 0;
    for(int i=0; i<n; i++) {
        int max_val = a[i];
        for(int j=0; j<m; j++) {
            if(b[j] < max_val) {
                continue;
            }
            if(b[j] >= max_val) {
                ans++;
                b[j] = 0;
                break;
            }
        }
    }
    printf("%d", ans);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-34h] BYREF
  int v5; // [rsp+30h] [rbp-30h] BYREF
  int v6; // [rsp+34h] [rbp-2Ch]
  _DWORD *v7; // [rsp+38h] [rbp-28h]
  _DWORD *v8; // [rsp+40h] [rbp-20h]
  int m; // [rsp+4Ch] [rbp-14h]
  int k; // [rsp+50h] [rbp-10h]
  unsigned int v11; // [rsp+54h] [rbp-Ch]
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  scanf("%d %d", &v5, &v4);
  v8 = malloc(4i64 * v5);
  for ( i = 0; i < v5; ++i )
    scanf("%d", &v8[i]);
  v7 = malloc(4i64 * v4);
  for ( j = 0; j < v4; ++j )
    scanf("%d", &v7[j]);
  v11 = 0;
  for ( k = 0; k < v5; ++k )
  {
    v6 = v8[k];
    for ( m = 0; m < v4; ++m )
    {
      if ( v6 <= v7[m] )
      {
        ++v11;
        v7[m] = 0;
        break;
      }
    }
  }
  printf("%d", v11);
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File system simulation ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_FILES 100
#define MAX_FILE_NAME_LENGTH 20
#define BLOCK_SIZE 4096
#define TOTAL_BLOCKS 256
#define SIZE_OF_BITMAP 8

typedef struct {
  char name[MAX_FILE_NAME_LENGTH];
  int inode_num;
  int size;
  int blocks[10];
  bool is_free; // if the file was deleted or not
} File;

File files[MAX_FILES];
bool bitmap[TOTAL_BLOCKS / SIZE_OF_BITMAP]; // To keep track of which blocks are free or not

int create_file(char *name, int size) {
  int i, j = 0;
  int blocks_needed = size / BLOCK_SIZE + 1;
  for(i = 0; i < MAX_FILES; i++) {
    if(files[i].is_free == true) {
      files[i].is_free = false;
      files[i].inode_num = i;
      files[i].size = size;
      strcpy(files[i].name, name);
      while(j < blocks_needed && j < 10) {
        int block_num = get_next_free_block(); // implemented below
        files[i].blocks[j] = block_num;
        j++;
      }
      // if all blocks were assigned
      if(j == blocks_needed) {
        return i; // returning inode number of the file
      } else {
        // free up the partially assigned blocks
        for(int k = 0; k < j; k++) {
          free_block(files[i].blocks[k]);
        }
        files[i].is_free = true;
      }
    }
  }
  // If the control reaches here, it means that no free inode was found
  printf("Cannot create file. Max limit for files reached.\n");
  return -1;
}

void delete_file(char* name) {
  for(int i = 0; i < MAX_FILES; i++) {
    if(strcmp(files[i].name, name) == 0 && files[i].is_free == false) {
      files[i].is_free = true;
      for(int j = 0; j < 10; j++) {
        free_block(files[i].blocks[j]);
        files[i].blocks[j] = -1;
      }
      printf("Deleted file: %s\n", name);
      return;
    }
  }
  printf("File not found: %s\n", name);
}

int get_next_free_block() {
  for(int i = 0; i < TOTAL_BLOCKS / SIZE_OF_BITMAP; i++) {
    if(bitmap[i] != 0xFF) { // if this byte is not full
      for(int j = 0; j < 8; j++) {
        if((bitmap[i] & (1 << j)) == 0) { // check unused bits
          bitmap[i] |= (1 << j); // mark as used
          return i * SIZE_OF_BITMAP + j;
        }
      }
    }
  }
  printf("No free blocks available\n");
  return -1;
}

void free_block(int block_num) {
  int i = block_num / SIZE_OF_BITMAP;
  int j = block_num % SIZE_OF_BITMAP;
  bitmap[i] &= ~(1 << j); // * bitwise NOT
}

int main() {
  // initialize bitmap with all zeros
  memset(bitmap, 0, sizeof(bitmap));
  // set first block as reserved
  bitmap[0] |= 1;

  // Example usage
  int inode_num = create_file("example.txt", 8192);
  printf("Created file with inode number: %d\n", inode_num);
  delete_file("example.txt");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall create_file(_QWORD, _QWORD); // weak
__int64 __fastcall delete_file(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memset(void *, int Val, size_t Size);

//-------------------------------------------------------------------------
// Data declarations

char bitmap; // weak


//----- (0000000140001A06) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int file; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  memset(&bitmap, 0, 0x20ui64);
  bitmap = 1;
  file = create_file("example.txt", 0x2000i64);
  printf("Created file with inode number: %d\n", file);
  delete_file("example.txt");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall create_file(_QWORD, _QWORD);
// 140001781: using guessed type __int64 __fastcall delete_file(_QWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140010C60: using guessed type char bitmap;

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: visionary
#include <stdio.h>
#include <stdbool.h>

#define ROW 10
#define COL 15

// Function to print the maze
void printMaze(char maze[][COL]){
    for (int i=0; i<ROW; i++)
    {
        for (int j=0; j<COL; j++)
        {
            printf("%c", maze[i][j]);
        }
        printf("\n");
    }
}

// Function to check if a given position is valid or not
bool isValid(int row, int col, char maze[][COL], bool visited[][COL]){

    // Check if row and column are within limits
    if (row >= 0 && row < ROW && col >= 0 && col < COL)

        // Check if the cell is not visited and is not a wall
        if (maze[row][col] != '#' && !visited[row][col])
            return true;

    return false;
}

// Recursive function to find the path through the maze
bool findPathUtil(int row, int col, char maze[][COL], bool visited[][COL])
{
    // If the destination is reached, mark it as visited and return true
    if (maze[row][col] == 'D'){
        visited[row][col] = true;
        return true;
    }

    // Check if the current position is valid or not
    if (isValid(row, col, maze, visited))
    {
        // Mark the current cell as visited
        visited[row][col] = true;

        // Check in all 4 directions
        if (findPathUtil(row+1, col, maze, visited))
            return true;

        if (findPathUtil(row-1, col, maze, visited))
            return true;

        if (findPathUtil(row, col+1, maze, visited))
            return true;

        if (findPathUtil(row, col-1, maze, visited))
            return true;

        // If none of the directions work, backtrack and mark the current cell as unvisited
        visited[row][col] = false;
        return false;
    }

    return false;
}

// Function to find the path through the maze
void findPath(char maze[][COL])
{
    // Initialize the visited array with false
    bool visited[ROW][COL];
    for (int i=0; i<ROW; i++)
        for (int j=0; j<COL; j++)
            visited[i][j] = false;

    // Find the starting position
    int start_row, start_col;
    for (int i=0; i<ROW; i++)
        for (int j=0; j<COL; j++)
            if (maze[i][j] == 'S'){
                start_row = i;
                start_col = j;
            }

    // Find the path through the maze
    if (findPathUtil(start_row, start_col, maze, visited))
        printf("Path Found!\n");
    else
        printf("No Path Found!\n");

    // Print the maze with the path marked
    for (int i=0; i<ROW; i++)
    {
        for (int j=0; j<COL; j++)
        {
            if (maze[i][j] != '#' && visited[i][j])
                printf(".");
            else
                printf("%c", maze[i][j]);
        }
        printf("\n");
    }
}

int main(){

    // Define the maze
    char maze[ROW][COL] = {
        {'#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
        {'#', 'S', '#', ' ', ' ', ' ', '#', ' ', '#', ' ', ' ', ' ', '#', ' ', '#'},
        {'#', '#', ' ', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#'},
        {'#', '#', '#', ' ', '#', '#', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#'},
        {'#', ' ', '#', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#', ' ', '#', ' ', '#'},
        {'#', ' ', '#', '#', '#', ' ', '#', '#', '#', ' ', '#', ' ', '#', ' ', '#'},
        {'#', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', '#', ' ', '#'},
        {'#', ' ', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#'},
        {'#', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', '#'},
        {'#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', 'D', '#'},
    };

    // Print the initial maze
    printf("Initial Maze:\n");
    printMaze(maze);

    // Find the path through the maze
    findPath(maze);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printMaze(_QWORD); // weak
__int64 __fastcall findPath(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A0B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[20]; // [rsp+20h] [rbp-A0h] BYREF

  _main(argc, argv, envp);
  qmemcpy(
    v4,
    "################S#   # #   # ###  # # # # # #### ### # # # ## #     # # # ## ### ### # # ##     #   # # ## ##### # #"
    " # ##   #   #   # ##############D#",
    150);
  printf("Initial Maze:\n");
  printMaze(v4);
  findPath(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printMaze(_QWORD);
// 140001830: using guessed type __int64 __fastcall findPath(_QWORD);
// 140001C50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double calculate_euler_number(int n);

int main() {
    int n;
    double e;

    printf("Enter a value for n: ");
    scanf("%d", &n);

    e = calculate_euler_number(n);

    printf("The Euler number for n = %d is: %.15lf\n", n, e);

    return 0;
}

double calculate_euler_number(int n) {
    double e = 0;
    int i;

    for(i = 0; i <= n; i++) {
        e += 1 / pow(2, i) ;
    }

    return e;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
double __fastcall calculate_euler_number(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch] BYREF
  double v5; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a value for n: ");
  scanf("%d", &v4);
  v5 = calculate_euler_number(v4);
  printf("The Euler number for n = %d is: %.15lf\n", v4, v5);
  return 0;
}
// 140001656: using guessed type double __fastcall calculate_euler_number(_QWORD);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image to ASCII art converter ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_WIDTH 100
#define MAX_HEIGHT 100

char image[MAX_HEIGHT][MAX_WIDTH];

char ascii_chars[] = {' ', '.', ':', '-', '=', '+', '*', '#', '%', '@'};

int max_gray_level;

void read_image(char *filename) {
    FILE *fp;
    char buffer[100];

    fp = fopen(filename, "r");

    // Skip the first two lines
    fgets(buffer, 100, fp);
    fgets(buffer, 100, fp);

    // Read the image information
    fscanf(fp, "%d %d\n", &max_gray_level, &max_gray_level);

    // Read the image pixels
    for (int i = 0; i < MAX_HEIGHT; i++) {
        for (int j = 0; j < MAX_WIDTH; j++) {
            int pixel;
            fscanf(fp, "%d", &pixel);
            image[i][j] = pixel;
        }
    }

    fclose(fp);
}

void convert_to_ascii() {
    for (int i = 0; i < MAX_HEIGHT; i++) {
        for (int j = 0; j < MAX_WIDTH; j++) {
            int gray_level = image[i][j] * 10 / max_gray_level;

            if (gray_level >= 10) {
                gray_level = 9;
            }

            char ascii_char = ascii_chars[gray_level];

            printf("%c", ascii_char);
        }

        printf("\n");
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        exit(1);
    }
    
    read_image(argv[1]);

    convert_to_ascii();

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall read_image(_QWORD); // weak
__int64 convert_to_ascii(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400017B7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  if ( argc != 2 )
  {
    printf("Usage: %s <filename>\n", *argv);
    exit(1);
  }
  read_image(argv[1]);
  convert_to_ascii();
  return 0;
}
// 1400015D4: using guessed type __int64 __fastcall read_image(_QWORD);
// 1400016E1: using guessed type __int64 convert_to_ascii(void);
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue ; Style: grateful
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

struct queue {
    int items[MAX_SIZE];
    int front;
    int rear;
};

struct queue* createQueue() {
    struct queue* q = malloc(sizeof(struct queue));
    q->front = -1;
    q->rear = -1;
    return q;
}

int isFull(struct queue* q) {
    if(q->rear == MAX_SIZE - 1) {
        return 1;
    } else {
        return 0;
    }
}

int isEmpty(struct queue* q) {
    if(q->front == -1 && q->rear == -1) {
        return 1;
    } else {
        return 0;
    }
}

void enqueue(struct queue* q, int value) {
    if(isFull(q)) {
        printf("Queue is full! Cannot add another item.\n");
    } else {
        if(q->front == -1) {
            q->front = 0;
        }
        q->rear++;
        q->items[q->rear] = value;
        printf("%d added to the queue.\n", value);
    }
}

int dequeue(struct queue* q) {
    int item = 0;
    if(isEmpty(q)) {
        printf("Queue is empty! Cannot dequeue anything.\n");
        return -1;
    } else {
        item = q->items[q->front];
        q->front++;
    }
    return item;
}

void printQueue(struct queue* q) {
    if(isEmpty(q)) {
        printf("Queue is empty!\n");
    } else {
        printf("Current queue:\n");
        for(int i = q->front; i <= q->rear; i++) {
            printf("%d ", q->items[i]);
        }
        printf("\n");
    }
}

int main() {
    struct queue* q = createQueue();

    enqueue(q, 1);
    enqueue(q, 2);
    enqueue(q, 3);
    enqueue(q, 4);
    enqueue(q, 5);
    printf("\n");
    printQueue(q);

    dequeue(q);
    dequeue(q);
    printf("\n");
    printQueue(q);

    enqueue(q, 6);
    printf("\n");
    printQueue(q);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 createQueue(void); // weak
__int64 __fastcall enqueue(_QWORD, _QWORD); // weak
__int64 __fastcall dequeue(_QWORD); // weak
__int64 __fastcall printQueue(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001788) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 Queue; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  Queue = createQueue();
  enqueue(Queue, 1i64);
  enqueue(Queue, 2i64);
  enqueue(Queue, 3i64);
  enqueue(Queue, 4i64);
  enqueue(Queue, 5i64);
  printf("\n");
  printQueue(Queue);
  dequeue(Queue);
  dequeue(Queue);
  printf("\n");
  printQueue(Queue);
  enqueue(Queue, 6i64);
  printf("\n");
  printQueue(Queue);
  return 0;
}
// 140001591: using guessed type __int64 createQueue(void);
// 140001617: using guessed type __int64 __fastcall enqueue(_QWORD, _QWORD);
// 14000169B: using guessed type __int64 __fastcall dequeue(_QWORD);
// 1400016FF: using guessed type __int64 __fastcall printQueue(_QWORD);
// 140001930: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Graph representation ; Style: invasive
#include<stdio.h>
#include<stdlib.h>

#define MAX_SIZE 20

//Node struct to hold each vertex in the graph
typedef struct node
{
    int vertex;
    struct node* next;
} node;

//Graph struct to hold a list of vertices and their neighbors
typedef struct graph
{
    int num_vertices;
    node** adj_list;
    int* visited;
} graph;

//Function to create a new node
node* create_node(int v)
{
    node* new_node = malloc(sizeof(node));
    new_node->vertex = v;
    new_node->next = NULL;
    return new_node;
}

//Function to create a new graph
graph* create_graph(int vertices)
{
    graph* new_graph = malloc(sizeof(graph));
    new_graph->num_vertices = vertices;
    new_graph->adj_list = malloc(vertices * sizeof(node*));
    new_graph->visited = malloc(vertices * sizeof(int));

    for(int i=0;i<vertices;i++)
    {
        new_graph->adj_list[i]=NULL;//initialize all vertices to NULL
        new_graph->visited[i]=0;//set visited status to 0
    }

    return new_graph;
}

//Function to add edges to the graph
void add_edge(graph* g, int src, int dest)
{
    //Add edge from src to dest
    node* new_node=create_node(dest);
    new_node->next=g->adj_list[src];
    g->adj_list[src]=new_node;

    //Add edge from dest to src
    new_node=create_node(src);
    new_node->next=g->adj_list[dest];
    g->adj_list[dest]=new_node;
}

//Function to print the graph
void print_graph(graph* g)
{
    for(int i=0;i<g->num_vertices;i++)
    {
        printf("Vertex %d : ",i);
        node* temp=g->adj_list[i];
        while(temp)
        {
            printf("%d -> ",temp->vertex);
            temp=temp->next;
        }
        printf("NULL\n");
    }
}

int main()
{
    graph* g=create_graph(5);

    add_edge(g, 0, 1);
    add_edge(g, 0, 4);
    add_edge(g, 1, 2);
    add_edge(g, 1, 3);
    add_edge(g, 1, 4);
    add_edge(g, 2, 3);
    add_edge(g, 3, 4);

    print_graph(g);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall create_graph(_QWORD); // weak
__int64 __fastcall add_edge(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall print_graph(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017B7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 graph; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  graph = create_graph(5i64);
  add_edge(graph, 0i64, 1i64);
  add_edge(graph, 0i64, 4i64);
  add_edge(graph, 1i64, 2i64);
  add_edge(graph, 1i64, 3i64);
  add_edge(graph, 1i64, 4i64);
  add_edge(graph, 2i64, 3i64);
  add_edge(graph, 3i64, 4i64);
  print_graph(graph);
  return 0;
}
// 1400015C9: using guessed type __int64 __fastcall create_graph(_QWORD);
// 140001677: using guessed type __int64 __fastcall add_edge(_QWORD, _QWORD, _QWORD);
// 140001721: using guessed type __int64 __fastcall print_graph(_QWORD);
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: active
#include <stdio.h>
#include <stdlib.h>

#define FLOORS 10
#define ELEVATORS 3

enum Status { UP, DOWN, STOPPED };

struct Elevator {
  int currentFloor;
  int destinationFloor;
  enum Status status;
};

typedef struct Elevator elevator_t;

int main() {
  elevator_t elevators[ELEVATORS];
  int requests[FLOORS] = {0};
  int i, j;

  // initialize all elevators and set their starting floor to 1
  for (i = 0; i < ELEVATORS; i++) {
    elevators[i].currentFloor = 1;
    elevators[i].destinationFloor = -1;
    elevators[i].status = STOPPED;
  }

  printf("Welcome to the Elevator Simulation\n");

  // Start simulation loop
  while (1) {
    // Print current status of elevators
    for (i = 0; i < ELEVATORS; i++) {
      printf("Elevator %d is currently on Floor %d and is ", i + 1, elevators[i].currentFloor);

      if (elevators[i].status == UP) {
        printf("going UP\n");
      } else if (elevators[i].status == DOWN) {
        printf("going DOWN\n");
      } else {
        printf("STOPPED\n");
      }
    }

    printf("\n");

    // Check for elevator requests and assign the closest elevator to the floor
    for (i = 0; i < FLOORS; i++) {
      if (requests[i] != 0) {
        // find the closest elevator to the requested floor
        int min_dist = 100;
        int closest_elevator;
        for (j = 0; j < ELEVATORS; j++) {
          int dist = abs(i+1 - elevators[j].currentFloor);
          if (dist < min_dist) {
            min_dist = dist;
            closest_elevator = j;
          }
        }

        // assign closest elevator to the floor
        elevators[closest_elevator].destinationFloor = i+1;
        if (elevators[closest_elevator].currentFloor < i+1) {
          elevators[closest_elevator].status = UP;
        } else if (elevators[closest_elevator].currentFloor > i+1) {
          elevators[closest_elevator].status = DOWN;
        }

        // reset request flag for the floor
        requests[i] = 0;

        printf("Elevator %d has been assigned to Floor %d\n", closest_elevator+1, i+1);
      }
    }

    printf("\n");

    // Move all elevators
    for (i = 0; i < ELEVATORS; i++) {
      if (elevators[i].status == UP) {
        elevators[i].currentFloor++;
        printf("Elevator %d is on Floor %d\n", i+1, elevators[i].currentFloor);
        if (elevators[i].currentFloor == elevators[i].destinationFloor) {
          elevators[i].status = STOPPED;
        }
      } else if (elevators[i].status == DOWN) {
        elevators[i].currentFloor--;
        printf("Elevator %d is on Floor %d\n", i+1, elevators[i].currentFloor);
        if (elevators[i].currentFloor == elevators[i].destinationFloor) {
          elevators[i].status = STOPPED;
        }
      }
    }

    printf("\n");

    // Check for new requests
    printf("Choose Floor to Request Elevator (1 - 10): ");
    int floor;
    scanf("%d", &floor);
    if (floor > 0 && floor <= FLOORS) {
      requests[floor-1] = 1;
    }

    printf("\n");
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int v5; // [rsp+2Ch] [rbp-74h] BYREF
  __int64 v6[11]; // [rsp+30h] [rbp-70h] BYREF
  int v7; // [rsp+8Ch] [rbp-14h]
  int v8; // [rsp+90h] [rbp-10h]
  int v9; // [rsp+94h] [rbp-Ch]
  int j; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  memset(v6, 0, 40);
  for ( i = 0; i <= 2; ++i )
  {
    *((_DWORD *)&v6[6] + 3 * i) = 1;
    *((_DWORD *)&v6[6] + 3 * i + 1) = -1;
    *((_DWORD *)&v6[7] + 3 * i) = 2;
  }
  printf("Welcome to the Elevator Simulation\n");
  while ( 1 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      printf("Elevator %d is currently on Floor %d and is ", (unsigned int)(i + 1), *((unsigned int *)&v6[6] + 3 * i));
      if ( *((_DWORD *)&v6[7] + 3 * i) )
      {
        if ( *((_DWORD *)&v6[7] + 3 * i) == 1 )
          printf("going DOWN\n");
        else
          printf("STOPPED\n");
      }
      else
      {
        printf("going UP\n");
      }
    }
    printf("\n");
    for ( i = 0; i <= 9; ++i )
    {
      if ( *((_DWORD *)v6 + i) )
      {
        v9 = 100;
        for ( j = 0; j <= 2; ++j )
        {
          v3 = i + 1 - *((_DWORD *)&v6[6] + 3 * j);
          if ( *((_DWORD *)&v6[6] + 3 * j) - (i + 1) >= 0 )
            v3 = *((_DWORD *)&v6[6] + 3 * j) - (i + 1);
          v7 = v3;
          if ( v3 < v9 )
          {
            v9 = v7;
            v8 = j;
          }
        }
        *((_DWORD *)&v6[6] + 3 * v8 + 1) = i + 1;
        if ( i < *((_DWORD *)&v6[6] + 3 * v8) )
        {
          if ( *((_DWORD *)&v6[6] + 3 * v8) > i + 1 )
            *((_DWORD *)&v6[7] + 3 * v8) = 1;
        }
        else
        {
          *((_DWORD *)&v6[7] + 3 * v8) = 0;
        }
        *((_DWORD *)v6 + i) = 0;
        printf("Elevator %d has been assigned to Floor %d\n", (unsigned int)(v8 + 1), (unsigned int)(i + 1));
      }
    }
    printf("\n");
    for ( i = 0; i <= 2; ++i )
    {
      if ( *((_DWORD *)&v6[7] + 3 * i) )
      {
        if ( *((_DWORD *)&v6[7] + 3 * i) == 1 )
        {
          printf("Elevator %d is on Floor %d\n", (unsigned int)(i + 1), (unsigned int)--*((_DWORD *)&v6[6] + 3 * i));
          if ( *((_DWORD *)&v6[6] + 3 * i) == *((_DWORD *)&v6[6] + 3 * i + 1) )
            *((_DWORD *)&v6[7] + 3 * i) = 2;
        }
      }
      else
      {
        printf("Elevator %d is on Floor %d\n", (unsigned int)(i + 1), (unsigned int)++*((_DWORD *)&v6[6] + 3 * i));
        if ( *((_DWORD *)&v6[6] + 3 * i) == *((_DWORD *)&v6[6] + 3 * i + 1) )
          *((_DWORD *)&v6[7] + 3 * i) = 2;
      }
    }
    printf("\n");
    printf("Choose Floor to Request Elevator (1 - 10): ");
    scanf("%d", &v5);
    if ( v5 > 0 && v5 <= 10 )
      *((_DWORD *)v6 + v5 - 1) = 1;
    printf("\n");
  }
}
// 140001C00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Calculator ; Style: creative
#include <stdio.h>

int main() {

    int num1, num2, option, result;

    printf("Welcome to the Calculator\n");

    printf("Enter first number: ");
    scanf("%d", &num1);

    printf("Enter second number: ");
    scanf("%d", &num2);

    printf("\nPlease select an operation:\n1. Addition\n2. Subtraction\n3. Multiplication\n4. Division\n");
    scanf("%d", &option);

    switch (option) {

        case 1:
            result = num1 + num2;
            printf("\n%d + %d = %d\n", num1, num2, result);
            break;

        case 2:
            result = num1 - num2;
            printf("\n%d - %d = %d\n", num1, num2, result);
            break;

        case 3:
            result = num1 * num2;
            printf("\n%d * %d = %d\n", num1, num2, result);
            break;

        case 4:
            if (num2 != 0) {
                result = num1 / num2;
                printf("\n%d / %d = %d\n", num1, num2, result);
            } else {
                printf("\nCannot divide by zero\n");
            }
            break;

        default:
            printf("\nInvalid option selected\n");
            break;
    }

    return 0;

}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v5; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int v6; // [rsp+28h] [rbp-8h] BYREF
  int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Calculator\n");
  printf("Enter first number: ");
  scanf("%d", &v6);
  printf("Enter second number: ");
  scanf("%d", &v5);
  printf("\nPlease select an operation:\n1. Addition\n2. Subtraction\n3. Multiplication\n4. Division\n");
  scanf("%d", &v4);
  if ( v4 == 4 )
  {
    if ( v5 )
    {
      v7 = (int)v6 / (int)v5;
      printf("\n%d / %d = %d\n", v6, v5, (unsigned int)((int)v6 / (int)v5));
    }
    else
    {
      printf("\nCannot divide by zero\n");
    }
  }
  else
  {
    if ( v4 > 4 )
    {
LABEL_13:
      printf("\nInvalid option selected\n");
      return 0;
    }
    switch ( v4 )
    {
      case 3:
        v7 = v6 * v5;
        printf("\n%d * %d = %d\n", v6, v5, v6 * v5);
        break;
      case 1:
        v7 = v6 + v5;
        printf("\n%d + %d = %d\n", v6, v5, v6 + v5);
        break;
      case 2:
        v7 = v6 - v5;
        printf("\n%d - %d = %d\n", v6, v5, v6 - v5);
        break;
      default:
        goto LABEL_13;
    }
  }
  return 0;
}
// 14000168A: conditional instruction was optimized away because %var_10.4<3
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Time Travel Simulator ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    time_t currentTime;
    struct tm *localTime;

    time( &currentTime );
    localTime = localtime( &currentTime );

    int year = localTime->tm_year + 1900;

    int currentYear = year;
    int simulatedYear;

    printf("Welcome to the Time Travel Simulator\n\n");
    printf("What year would you like to travel to? (e.g. 1985): ");
    scanf("%d", &simulatedYear);

    if (simulatedYear > currentYear) {
        printf("\nSorry, time machines can only travel back in time.\n");
        return 0;
    } else if (simulatedYear == currentYear) {
        printf("\nYou're already in the present!\n");
        return 0;
    } else {
        printf("\nTravelling back to %d...\n\n", simulatedYear);
    }

    int currentAge, simulatedAge;

    printf("What is your current age? ");
    scanf("%d", &currentAge);
    
    if (currentAge <= 0) {
        printf("\nSorry, invalid age.\n");
        return 0;
    } else if (currentAge >= (currentYear - simulatedYear)) {
        printf("\nSorry, you would not exist in %d.\n", simulatedYear);
        return 0;
    }

    simulatedAge = currentAge - (currentYear - simulatedYear);

    printf("\nWelcome to %d!\n\n", simulatedYear);
    printf("You are now %d years old.\n", simulatedAge);
    printf("Enjoy your time travel experience!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static struct tm *__cdecl localtime(const time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001620) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-28h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-24h] BYREF
  time_t Time; // [rsp+30h] [rbp-20h] BYREF
  unsigned int v7; // [rsp+3Ch] [rbp-14h]
  int v8; // [rsp+40h] [rbp-10h]
  int v9; // [rsp+44h] [rbp-Ch]
  struct tm *v10; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  time(&Time);
  v10 = localtime(&Time);
  v9 = v10->tm_year + 1900;
  v8 = v9;
  printf("Welcome to the Time Travel Simulator\n\n");
  printf("What year would you like to travel to? (e.g. 1985): ");
  scanf("%d", &v5);
  if ( v8 >= (int)v5 )
  {
    if ( v8 == v5 )
    {
      printf("\nYou're already in the present!\n");
      return 0;
    }
    else
    {
      printf("\nTravelling back to %d...\n\n", v5);
      printf("What is your current age? ");
      scanf("%d", &v4);
      if ( v4 > 0 )
      {
        if ( (int)(v8 - v5) > v4 )
        {
          v7 = v4 - (v8 - v5);
          printf("\nWelcome to %d!\n\n", v5);
          printf("You are now %d years old.\n", v7);
          printf("Enjoy your time travel experience!\n");
        }
        else
        {
          printf("\nSorry, you would not exist in %d.\n", v5);
        }
        return 0;
      }
      else
      {
        printf("\nSorry, invalid age.\n");
        return 0;
      }
    }
  }
  else
  {
    printf("\nSorry, time machines can only travel back in time.\n");
    return 0;
  }
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Disk space analyzer ; Style: scalable
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>

#define K 1024
#define M K*K
#define G M*K

struct folder {
    char name[256];
    long long int size;
    struct folder *subfolders;
    int num_subfolders;
} current_folder;

char* size_format(long long int size) {
    char* format = (char*)malloc(sizeof(char)*16);
    if(size >= G) {
        sprintf(format, "%.2f GB", (float)size/G);
    }
    else if(size >= M) {
        sprintf(format, "%.2f MB", (float)size/M);
    }
    else if(size >= K) {
        sprintf(format, "%.2f KB", (float)size/K);
    }
    else {
        sprintf(format, "%lld B", size);
    }
    return format;
}

void analyze_folder(char* folder_name) {
    printf("Analyzing folder: %s\n", folder_name);
    
    DIR* dp;
    struct dirent* entry;
    struct stat file_stat;
    long long int total_size = 0;
    int num_subfolders = 0;
    struct folder* subfolders = NULL;

    dp = opendir(folder_name);
    if(dp == NULL) {
        printf("Error: Unable to open directory: %s\n", folder_name);
        return;
    }

    while((entry = readdir(dp))) {
        char entry_name[256];
        sprintf(entry_name, "%s/%s", folder_name, entry->d_name);

        if(stat(entry_name, &file_stat) == -1) {
            printf("Error: Unable to read file/folder: %s\n", entry_name);
            continue;
        }

        if(S_ISDIR(file_stat.st_mode)) {
            if(strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
                continue;
            }

            num_subfolders++;
            subfolders = (struct folder*)realloc(subfolders, sizeof(struct folder)*num_subfolders);
            memset(&subfolders[num_subfolders-1], 0, sizeof(struct folder));
            strcpy(subfolders[num_subfolders-1].name, entry->d_name);

            analyze_folder(entry_name);

            total_size += subfolders[num_subfolders-1].size;
        }
        else if(S_ISREG(file_stat.st_mode)) {
            total_size += file_stat.st_size;
        }
    }

    closedir(dp);

    current_folder.size = total_size;
    current_folder.subfolders = subfolders;
    current_folder.num_subfolders = num_subfolders;

    printf("\nFolder: %s\nSize: %s\n", folder_name, size_format(total_size));

    for(int i=0; i<num_subfolders; i++) {
        printf("\nSubfolder: %s\nSize: %s\n", subfolders[i].name, size_format(subfolders[i].size));
    }
}

int main(int argc, char* argv[]) {
    if(argc < 2) {
        printf("Usage: ./disk_analyzer folder_path\n");
        return 1;
    }

    analyze_folder(argv[1]);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall analyze_folder(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A69) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  if ( argc > 1 )
  {
    analyze_folder(argv[1]);
    return 0;
  }
  else
  {
    printf("Usage: ./disk_analyzer folder_path\n");
    return 1;
  }
}
// 14000172C: using guessed type __int64 __fastcall analyze_folder(_QWORD);
// 140001B70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=158 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Palindrome Checker ; Style: ultraprecise
#include <stdio.h>
#include <string.h>

void reverseString(char str[]) {
    int len = strlen(str);
    int i, j = len-1;
    char temp;
    for(i=0; i<len/2; i++) {
        temp = str[i];
        str[i] = str[j];
        str[j] = temp;
        j--;
    }
}

int isPalindrome(char str[]) {
    char copyStr[strlen(str)+1];
    strcpy(copyStr, str);
    
    reverseString(copyStr);
    
    if(strcmp(str, copyStr) == 0)
        return 1;
    else
        return 0;
}

int main() {
    char str[100];
    printf("Enter a string: ");
    fgets(str, 100, stdin);
    str[strcspn(str, "\n")] = '\0'; // remove \n character from fgets
    
    if(isPalindrome(str))
        printf("%s is a palindrome.", str);
    else
        printf("%s is not a palindrome.", str);
        
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall isPalindrome(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016D2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[112]; // [rsp+20h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter a string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  if ( (unsigned int)isPalindrome(Buffer) )
    printf("%s is a palindrome.", Buffer);
  else
    printf("%s is not a palindrome.", Buffer);
  return 0;
}
// 140001621: using guessed type __int64 __fastcall isPalindrome(_QWORD);
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016D2: using guessed type char Buffer[112];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Wi-Fi Signal Strength Analyzer ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIGNALS 50

// A structure to hold the data of a WiFi network signal
struct SignalInfo {
    char ssid[20];
    int signal_strength;
};

// A function to sort an array of SignalInfo structures based on signal strength
void sortSignals(struct SignalInfo signals[], int numSignals) {
    struct SignalInfo temp;
    int i, j;

    for (i = 0; i < numSignals-1; i++) {
        for (j = i+1; j < numSignals; j++) {
            if (signals[i].signal_strength < signals[j].signal_strength) {
                temp = signals[i];
                signals[i] = signals[j];
                signals[j] = temp;
            }
        }
    }
}

int main() {
    struct SignalInfo signals[MAX_SIGNALS];
    int numSignals = 0;

    printf("Wi-Fi Signal Strength Analyzer\n");
    printf("==============================\n");

    // Read in signal data from file
    FILE* fp = fopen("signals.txt", "r");
    if (fp == NULL) {
        printf("Error: could not open signals.txt\n");
        return 1;
    }
    char line[50];
    while (fgets(line, sizeof(line), fp)) {
        // Split the line into SSID and signal strength
        char ssid[20];
        int signal_strength;
        sscanf(line, "%s %d", ssid, &signal_strength);

        // Store the signal data in a SignalInfo structure and add it to the array
        struct SignalInfo signal;
        strcpy(signal.ssid, ssid);
        signal.signal_strength = signal_strength;
        signals[numSignals] = signal;
        numSignals++;
    }
    fclose(fp);

    // Sort the signals based on signal strength
    sortSignals(signals, numSignals);

    // Print out the sorted signals
    printf("Signal Strengths (strongest to weakest)\n");
    printf("---------------------------------------\n");
    int i;
    for (i = 0; i < numSignals; i++) {
        printf("%d. %s: %d dBm\n", i+1, signals[i].ssid, signals[i].signal_strength);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sscanf(const char *const Buffer, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall sortSignals(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strcpy(char *Destination, const char *Source);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (000000014000172C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _QWORD *v4; // rcx
  __int64 v5; // rdx
  char Destination[8]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v7; // [rsp+28h] [rbp-58h]
  __int64 v8; // [rsp+30h] [rbp-50h]
  int v9; // [rsp+3Ch] [rbp-44h] BYREF
  char Source[32]; // [rsp+40h] [rbp-40h] BYREF
  char Buffer[32]; // [rsp+60h] [rbp-20h] BYREF
  _BYTE v12[32]; // [rsp+80h] [rbp+0h] BYREF
  char v13[1200]; // [rsp+A0h] [rbp+20h] BYREF
  FILE *Stream; // [rsp+550h] [rbp+4D0h]
  int i; // [rsp+558h] [rbp+4D8h]
  unsigned int v16; // [rsp+55Ch] [rbp+4DCh]

  _main(argc, argv, envp);
  v16 = 0;
  printf("Wi-Fi Signal Strength Analyzer\n");
  printf("==============================\n");
  Stream = fopen("signals.txt", "r");
  if ( Stream )
  {
    while ( fgets(Buffer, 50, Stream) )
    {
      sscanf(Buffer, "%s %d", Source, &v9);
      strcpy(Destination, Source);
      HIDWORD(v8) = v9;
      v4 = &v12[24 * v16 + 32];
      v5 = v7;
      *v4 = *(_QWORD *)Destination;
      v4[1] = v5;
      v4[2] = v8;
      ++v16;
    }
    fclose(Stream);
    sortSignals(v13, v16);
    printf("Signal Strengths (strongest to weakest)\n");
    printf("---------------------------------------\n");
    for ( i = 0; i < (int)v16; ++i )
      printf("%d. %s: %d dBm\n", (unsigned int)(i + 1), &v13[24 * i], *(unsigned int *)&v12[24 * i + 52]);
    return 0;
  }
  else
  {
    printf("Error: could not open signals.txt\n");
    return 1;
  }
}
// 1400015D4: using guessed type __int64 __fastcall sortSignals(_QWORD, _QWORD);
// 1400019E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000172C: using guessed type char Source[32];
// 14000172C: using guessed type char var_4C0[1200];

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home light control ; Style: recursive
#include <stdio.h>
#include <stdbool.h>

int switchLamp(int bulbNum, bool isOn) {
    if (isOn) {
        printf("Bulb %d is now turned on.\n", bulbNum);
    } else {
        printf("Bulb %d is now turned off.\n", bulbNum);
    }
    return 0;
}

int turnOnAllLamps(int numLamps) {
    if (numLamps == 1) {
        switchLamp(numLamps, true);
    } else {
        turnOnAllLamps(numLamps-1);
        switchLamp(numLamps, true);
    }
    return 0;
}

int turnOffAllLamps(int numLamps) {
    if (numLamps == 1) {
        switchLamp(numLamps, false);
    } else {
        switchLamp(numLamps, false);
        turnOffAllLamps(numLamps-1);
    }
    return 0;
}

int main() {
    int numLamps, option;
    bool isOn;

    printf("Enter the number of lamps in the house: ");
    scanf("%d", &numLamps);

    printf("\n--- Menu ---");
    printf("\n1. Turn on all lamps");
    printf("\n2. Turn off all lamps");
    printf("\n3. Exit");

    do {
        printf("\nEnter your option: ");
        scanf("%d", &option);

        switch(option) {
            case 1:
                turnOnAllLamps(numLamps);
                break;

            case 2:
                turnOffAllLamps(numLamps);
                break;

            case 3:
                printf("\nExiting program...");
                break;

            default:
                printf("\nInvalid option. Please try again.");
        }

    } while(option != 3);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall turnOnAllLamps(_QWORD); // weak
__int64 __fastcall turnOffAllLamps(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016B3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-8h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the number of lamps in the house: ");
  scanf("%d", &v5);
  printf("\n--- Menu ---");
  printf("\n1. Turn on all lamps");
  printf("\n2. Turn off all lamps");
  printf("\n3. Exit");
  do
  {
    printf("\nEnter your option: ");
    scanf("%d", &v4);
    if ( v4 == 3 )
    {
      printf("\nExiting program...");
    }
    else
    {
      if ( v4 > 3 )
        goto LABEL_10;
      if ( v4 == 1 )
      {
        turnOnAllLamps(v5);
        continue;
      }
      if ( v4 == 2 )
        turnOffAllLamps(v5);
      else
LABEL_10:
        printf("\nInvalid option. Please try again.");
    }
  }
  while ( v4 != 3 );
  return 0;
}
// 140001629: using guessed type __int64 __fastcall turnOnAllLamps(_QWORD);
// 14000166E: using guessed type __int64 __fastcall turnOffAllLamps(_QWORD);
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: active
#include <stdio.h>
#include <stdlib.h>

int main() {
   int* ptr;
   int size = 5;
   int i;
   
   printf("Memory allocation for %d integers\n", size);
   ptr = (int*) malloc(size * sizeof(int));
   
   if(ptr == NULL) {
      printf("Memory allocation failed\n");
      exit(0);
   }
   
   for(i = 0; i < size; i++) {
      *(ptr + i) = i + 1;
   }
   
   printf("Printing the %d integers allocated dynamically\n", size);
   for(i = 0; i < size; i++) {
      printf("%d\n", *(ptr + i));
   }
   
   size = 10;
   
   printf("Changing the size of allocated memory to %d integers\n", size);
   ptr = realloc(ptr, size * sizeof(int));
   
   if(ptr == NULL) {
      printf("Memory reallocation failed\n");
      exit(0);
   }
   
   for(i = 5; i < size; i++) {
      *(ptr + i) = i + 1;
   }
   
   printf("Printing the %d integers allocated dynamically\n", size);
   for(i = 0; i < size; i++) {
      printf("%d\n", *(ptr + i));
   }
   
   free(ptr);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _DWORD *Block; // [rsp+20h] [rbp-10h]
  _DWORD *Blocka; // [rsp+20h] [rbp-10h]
  int i; // [rsp+2Ch] [rbp-4h]
  int j; // [rsp+2Ch] [rbp-4h]
  int k; // [rsp+2Ch] [rbp-4h]
  int m; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Memory allocation for %d integers\n", 5i64);
  Block = malloc(0x14ui64);
  if ( !Block )
  {
    printf("Memory allocation failed\n");
    exit(0);
  }
  for ( i = 0; i < 5; ++i )
    Block[i] = i + 1;
  printf("Printing the %d integers allocated dynamically\n", 5i64);
  for ( j = 0; j < 5; ++j )
    printf("%d\n", (unsigned int)Block[j]);
  printf("Changing the size of allocated memory to %d integers\n", 10i64);
  Blocka = realloc(Block, 0x28ui64);
  if ( !Blocka )
  {
    printf("Memory reallocation failed\n");
    exit(0);
  }
  for ( k = 5; k < 10; ++k )
    Blocka[k] = k + 1;
  printf("Printing the %d integers allocated dynamically\n", 10i64);
  for ( m = 0; m < 10; ++m )
    printf("%d\n", (unsigned int)Blocka[m]);
  free(Blocka);
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Haunted House Simulator ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL));
    int room = 1;
    int choice;
    int ghost = 0;
    int skeleton = 0;
    int spider = 0;
    int treasure = 0;

    printf("Welcome to the Haunted House!\n\n");
    printf("You find yourself standing outside a large, old house.\n");
    printf("Do you dare to enter? (1: yes / 2: no): ");
    scanf("%d", &choice);

    if (choice == 1) {
        printf("You hesitantly push the door open and step inside.\n");
        printf("The door slams shut behind you, and you hear it lock.\n\n");

        while (room <= 6) {
            printf("You are in Room %d. Choose your next move: \n", room);
            printf("1: Go forward\n2: Turn left\n3: Turn right\n4: Go back\n\n");
            scanf("%d", &choice);

            switch (choice) {
                case 1:
                    printf("You move forward and enter Room %d.\n", room+1);
                    room++;
                    break;
                case 2:
                    printf("You turn left and enter Room %d.\n", room+3);
                    room += 3;
                    break;
                case 3:
                    printf("You turn right and enter Room %d.\n", room+2);
                    room += 2;
                    break;
                case 4:
                    printf("You turn around and enter Room %d.\n", room-1);
                    room--;
                    break;
                default:
                    printf("Invalid choice. Try again.\n\n");
            }

            if (ghost == 1 && skeleton == 1 && spider == 1 && treasure == 1) {
                printf("\nYou have completed the game!\nCongratulations, you have found the treasure and escaped alive!\n");
                exit(0);
            }

            int event = rand() % 10 + 1;
            if (event <= 4) {
                printf("You hear strange noises...\n");

                int creature = rand() % 3 + 1;
                switch (creature) {
                    case 1:
                        if (ghost == 0) {
                            printf("A ghost appears out of nowhere and scares you!\n");
                            ghost = 1;
                        } else {
                            printf("The ghost appears again, but you are no longer scared.\n");
                        }
                        break;
                    case 2:
                        if (skeleton == 0) {
                            printf("A skeleton rises from the ground and attacks you!\n");
                            skeleton = 1;
                        } else {
                            printf("The skeleton is still there, but you have already defeated it.\n");
                        }
                        break;
                    case 3:
                        if (spider == 0) {
                            printf("A giant spider drops down from the ceiling and attacks you!\n");
                            spider = 1;
                        } else {
                            printf("The spider is still there, but you have already defeated it.\n");
                        }
                        break;
                }
            } else if (event == 10) {
                if (treasure == 0) {
                    printf("Congratulations! You have found the treasure!\n");
                    treasure = 1;
                } else {
                    printf("You have already found the treasure in this room.\n");
                }
            }
        }

        printf("\nYou have been trapped in the house forever...\nGAME OVER.\n");
    } else {
        printf("You chicken out and leave.\nGAME OVER.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // edx
  int v6; // [rsp+20h] [rbp-20h] BYREF
  int v7; // [rsp+24h] [rbp-1Ch]
  int v8; // [rsp+28h] [rbp-18h]
  int v9; // [rsp+2Ch] [rbp-14h]
  int v10; // [rsp+30h] [rbp-10h]
  int v11; // [rsp+34h] [rbp-Ch]
  int v12; // [rsp+38h] [rbp-8h]
  unsigned int v13; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v13 = 1;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  printf("Welcome to the Haunted House!\n\n");
  printf("You find yourself standing outside a large, old house.\n");
  printf("Do you dare to enter? (1: yes / 2: no): ");
  scanf("%d", &v6);
  if ( v6 != 1 )
  {
    printf("You chicken out and leave.\nGAME OVER.\n");
    return 0;
  }
  printf("You hesitantly push the door open and step inside.\n");
  printf("The door slams shut behind you, and you hear it lock.\n\n");
  while ( (int)v13 <= 6 )
  {
    printf("You are in Room %d. Choose your next move: \n", v13);
    printf("1: Go forward\n2: Turn left\n3: Turn right\n4: Go back\n\n");
    scanf("%d", &v6);
    if ( v6 == 4 )
    {
      printf("You turn around and enter Room %d.\n", --v13);
    }
    else
    {
      if ( v6 > 4 )
        goto LABEL_13;
      switch ( v6 )
      {
        case 3:
          printf("You turn right and enter Room %d.\n", v13 + 2);
          v13 += 2;
          break;
        case 1:
          printf("You move forward and enter Room %d.\n", ++v13);
          break;
        case 2:
          printf("You turn left and enter Room %d.\n", v13 + 3);
          v13 += 3;
          break;
        default:
LABEL_13:
          printf("Invalid choice. Try again.\n\n");
          break;
      }
    }
    if ( v12 == 1 && v11 == 1 && v10 == 1 && v9 == 1 )
    {
      printf("\nYou have completed the game!\nCongratulations, you have found the treasure and escaped alive!\n");
      exit(0);
    }
    v8 = rand() % 10 + 1;
    if ( v8 > 4 )
    {
      if ( v8 == 10 )
      {
        if ( v9 )
        {
          printf("You have already found the treasure in this room.\n");
        }
        else
        {
          printf("Congratulations! You have found the treasure!\n");
          v9 = 1;
        }
      }
    }
    else
    {
      printf("You hear strange noises...\n");
      v4 = rand() % 3;
      v7 = v4 + 1;
      if ( v4 == 2 )
      {
        if ( v10 )
        {
          printf("The spider is still there, but you have already defeated it.\n");
        }
        else
        {
          printf("A giant spider drops down from the ceiling and attacks you!\n");
          v10 = 1;
        }
      }
      else if ( v7 <= 3 )
      {
        if ( v7 == 1 )
        {
          if ( v12 )
          {
            printf("The ghost appears again, but you are no longer scared.\n");
          }
          else
          {
            printf("A ghost appears out of nowhere and scares you!\n");
            v12 = 1;
          }
        }
        else if ( v7 == 2 )
        {
          if ( v11 )
          {
            printf("The skeleton is still there, but you have already defeated it.\n");
          }
          else
          {
            printf("A skeleton rises from the ground and attacks you!\n");
            v11 = 1;
          }
        }
      }
    }
  }
  printf("\nYou have been trapped in the house forever...\nGAME OVER.\n");
  return 0;
}
// 140001706: conditional instruction was optimized away because %var_20.4<3
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature Converter ; Style: systematic
#include <stdio.h>

int celsius_to_fahrenheit(int celsius) {
  return (celsius * 9/5) + 32;
}

int fahrenheit_to_celsius(int fahrenheit) {
  return (fahrenheit - 32) * 5/9;
}

int main() {
  int choice, temp;

  printf("Welcome to the temperature converter!\n");
  printf("1. Convert Celsius to Fahrenheit\n");
  printf("2. Convert Fahrenheit to Celsius\n");
  printf("Enter your choice: ");
  scanf("%d", &choice);

  switch (choice) {
    case 1:
      printf("Enter temperature in Celsius: ");
      scanf("%d", &temp);
      printf("%d degrees Celsius is %d degrees Fahrenheit.\n", temp, celsius_to_fahrenheit(temp));
      break;
    case 2:
      printf("Enter temperature in Fahrenheit: ");
      scanf("%d", &temp);
      printf("%d degrees Fahrenheit is %d degrees Celsius.\n", temp, fahrenheit_to_celsius(temp));
      break;
    default:
      printf("Invalid choice. Please try again.\n");
      break;
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall celsius_to_fahrenheit(_QWORD); // weak
__int64 __fastcall fahrenheit_to_celsius(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001640) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v6; // [rsp+28h] [rbp-8h] BYREF
  int v7; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the temperature converter!\n");
  printf("1. Convert Celsius to Fahrenheit\n");
  printf("2. Convert Fahrenheit to Celsius\n");
  printf("Enter your choice: ");
  scanf("%d", &v7);
  if ( v7 == 1 )
  {
    printf("Enter temperature in Celsius: ");
    scanf("%d", &v6);
    v3 = celsius_to_fahrenheit(v6);
    printf("%d degrees Celsius is %d degrees Fahrenheit.\n", v6, v3);
  }
  else if ( v7 == 2 )
  {
    printf("Enter temperature in Fahrenheit: ");
    scanf("%d", &v6);
    v4 = fahrenheit_to_celsius(v6);
    printf("%d degrees Fahrenheit is %d degrees Celsius.\n", v6, v4);
  }
  else
  {
    printf("Invalid choice. Please try again.\n");
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall celsius_to_fahrenheit(_QWORD);
// 140001611: using guessed type __int64 __fastcall fahrenheit_to_celsius(_QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to Morse code conversion ; Style: Alan Touring
#include <stdio.h>
#include <string.h>

// Function to convert text to Morse code
void textToMorse(char text[])
{
    char morseCode[100][10] = {
      ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--..",
      ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----.", "-----"
    };
    
    int len = strlen(text);
    int i, j;
    for(i = 0; i < len; i++)
    {
        // Check for space
        if(text[i] == ' ')
        {
            printf(" ");
        }
        else
        {
            // Convert the character to uppercase to match the Morse code table
            char c = toupper(text[i]);
            
            // Find the index of the character in the Morse code table
            int index = (int)c - 65;
            
            // Print the Morse code for the character
            printf("%s ", morseCode[index]);
        }
    }
    printf("\n");
}

int main()
{
    char text[100];
    printf("Enter some text: ");
    fgets(text, 100, stdin);
    printf("Morse code: ");
    textToMorse(text);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall textToMorse(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001926) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[112]; // [rsp+20h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter some text: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  printf("Morse code: ");
  textToMorse(Buffer);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall textToMorse(_QWORD);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: User Input Sanitizer ; Style: Romeo and Juliet
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
    char input[1000]; // variable to store user input
    int length, i;

    printf("Good morrow, gentle user! Pray tell, what tidings bringeth thee?\n"); // ask for user input
    fgets(input, sizeof(input), stdin); // get user input

    length = strlen(input); // get length of the input

    // loop through each character in the input and replace non-alphanumeric characters with spaces
    for(i = 0; i < length; i++){
        if(!isalnum(input[i])){ // check if the character is non-alphanumeric
            input[i] = ' '; // replace with space
        }
    }

    printf("Thou hast spoken thusly: %s\nThank thee for thy words, and fare thee well!\n", input); // print sanitized user input

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl isalnum(int C);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1000]; // [rsp+20h] [rbp-60h] BYREF
  int v6; // [rsp+408h] [rbp+388h]
  int i; // [rsp+40Ch] [rbp+38Ch]

  _main(argc, argv, envp);
  printf("Good morrow, gentle user! Pray tell, what tidings bringeth thee?\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v6 = strlen(Buffer);
  for ( i = 0; i < v6; ++i )
  {
    if ( !isalnum(Buffer[i]) )
      Buffer[i] = 32;
  }
  printf("Thou hast spoken thusly: %s\nThank thee for thy words, and fare thee well!\n", Buffer);
  return 0;
}
// 140001710: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[1000];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Weather simulation ; Style: optimized
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define NUM_DAYS 7
#define NUM_HOURS 24
#define MAX_TEMP 100
#define MIN_TEMP -100

int main()
{
    srand(time(NULL)); // seed the random number generator with current time
    int temperatures[NUM_DAYS][NUM_HOURS];
    
    // Generate random temperatures for each hour of each day
    for(int i = 0; i < NUM_DAYS; i++)
    {
        for(int j = 0; j < NUM_HOURS; j++)
        {
            temperatures[i][j] = (rand() % (MAX_TEMP - MIN_TEMP + 1)) + MIN_TEMP;
        }
    }
    
    // Print average temperature for each day
    int totalTemp, averageTemp;
    printf("Average temperatures for each day:\n");
    for(int i = 0; i < NUM_DAYS; i++)
    {
        totalTemp = 0;
        for(int j = 0; j < NUM_HOURS; j++)
        {
            totalTemp += temperatures[i][j];
        }
        averageTemp = totalTemp / NUM_HOURS;
        printf("Day %d: %d\n", i+1, averageTemp);
    }
    
    // Print temperature change percentage from previous hour for each hour of each day
    int changePerc;
    printf("Temperature change percentage from previous hour:\n");
    for(int i = 0; i < NUM_DAYS; i++)
    {
        for(int j = 1; j < NUM_HOURS; j++)
        {
            changePerc = ((double)(temperatures[i][j]-temperatures[i][j-1])/temperatures[i][j-1]) * 100;
            printf("Day %d, Hour %d: %d%%\n", i+1, j, changePerc);
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[172]; // [rsp+20h] [rbp-60h]
  unsigned int v6; // [rsp+2D0h] [rbp+250h]
  unsigned int ii; // [rsp+2D4h] [rbp+254h]
  int n; // [rsp+2D8h] [rbp+258h]
  int m; // [rsp+2DCh] [rbp+25Ch]
  int k; // [rsp+2E0h] [rbp+260h]
  int v11; // [rsp+2E4h] [rbp+264h]
  int j; // [rsp+2E8h] [rbp+268h]
  int i; // [rsp+2ECh] [rbp+26Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 6; ++i )
  {
    for ( j = 0; j <= 23; ++j )
      v5[24 * i + j] = rand() % 201 - 100;
  }
  printf("Average temperatures for each day:\n");
  for ( k = 0; k <= 6; ++k )
  {
    v11 = 0;
    for ( m = 0; m <= 23; ++m )
      v11 += v5[24 * k + m];
    v5[171] = v11 / 24;
    printf("Day %d: %d\n", (unsigned int)(k + 1), (unsigned int)(v11 / 24));
  }
  printf("Temperature change percentage from previous hour:\n");
  for ( n = 0; n <= 6; ++n )
  {
    for ( ii = 1; (int)ii <= 23; ++ii )
    {
      v6 = (int)(100.0 * ((double)(v5[24 * n + ii] - v5[24 * n + ii - 1]) / (double)v5[24 * n + ii - 1]));
      printf("Day %d, Hour %d: %d%%\n", (unsigned int)(n + 1), ii, v6);
    }
  }
  return 0;
}
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Graph representation ; Style: unmistakable
#include <stdio.h>

#define MAX_VERTICES 10

// Graph Struct
typedef struct {
    int n;
    int adjacency_matrix[MAX_VERTICES][MAX_VERTICES];
} Graph;

// Initialize Graph
void initialize_graph(Graph *g) 
{
    int i, j;
    g -> n = 0;
    for (i = 0; i < MAX_VERTICES; i++)
        for (j = 0; j < MAX_VERTICES; j++)
            g -> adjacency_matrix[i][j] = 0;
}

// Add Edge
void add_edge(Graph *g, int u, int v) 
{
    g -> adjacency_matrix[u][v] = 1;
}

// Print Graph
void print_graph(Graph *g)
{
    int i, j;
    for (i = 0; i < g->n; i++) {
        printf("%d: ", i);
        for (j = 0; j < g->n; j++)
            printf("%d ", g->adjacency_matrix[i][j]);
        printf("\n");
    }
}

// Main Method
int main() 
{
    Graph g;
    initialize_graph(&g);
    
    g.n = 6;
    add_edge(&g, 0, 1);
    add_edge(&g, 1, 2);
    add_edge(&g, 1, 3);
    add_edge(&g, 2, 3);
    add_edge(&g, 3, 4);
    add_edge(&g, 4, 0);
    add_edge(&g, 4, 1);
    add_edge(&g, 4, 5);
    
    printf("Graph Connections: \n");
    print_graph(&g);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall initialize_graph(_QWORD); // weak
__int64 __fastcall add_edge(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall print_graph(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016D3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[104]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  initialize_graph(v4);
  v4[0] = 6;
  add_edge(v4, 0i64, 1i64);
  add_edge(v4, 1i64, 2i64);
  add_edge(v4, 1i64, 3i64);
  add_edge(v4, 2i64, 3i64);
  add_edge(v4, 3i64, 4i64);
  add_edge(v4, 4i64, 0i64);
  add_edge(v4, 4i64, 1i64);
  add_edge(v4, 4i64, 5i64);
  printf("Graph Connections: \n");
  print_graph(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall initialize_graph(_QWORD);
// 1400015FD: using guessed type __int64 __fastcall add_edge(_QWORD, _QWORD, _QWORD);
// 140001637: using guessed type __int64 __fastcall print_graph(_QWORD);
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Error handling ; Style: introspective
#include <stdio.h>
#include <stdlib.h>

int main() {
    int x = 10, y = 0, result;
    // Divide x by y, which results in a divide-by-zero error
    if (y == 0) {
        fprintf(stderr, "Error: Attempted to divide by zero\n");
        exit(EXIT_FAILURE);
    }
    result = x / y; // This line will never be reached due to the exit above
    printf("%d divided by %d is %d\n", x, y, result); // This line will also never be reached
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax

  _main(argc, argv, envp);
  v3 = __acrt_iob_func(2u);
  fprintf_0(v3, "Error: Attempted to divide by zero\n");
  exit(1);
}
// 140001710: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Personal Finance Planner ; Style: all-encompassing
#include <stdio.h>

float calculateMonthlySavings(float income, float expenses);
float calculateSavingsGoal(float monthlySavings, float targetSavings);
void printFinancialPlan(float income, float expenses, float monthlySavings, float targetSavings);

int main()
{
    float income, expenses, targetSavings;
    
    printf("Welcome to your Personal Finance Planner\n\n");
    
    printf("Please enter your monthly income: ");
    scanf("%f", &income);
    
    printf("Please enter your monthly expenses: ");
    scanf("%f", &expenses);
    
    printf("Please enter your target monthly savings: ");
    scanf("%f", &targetSavings);
    
    float monthlySavings = calculateMonthlySavings(income, expenses);
    float totalSavings = calculateSavingsGoal(monthlySavings, targetSavings);
    
    printFinancialPlan(income, expenses, monthlySavings, totalSavings);
    
    return 0;
}

float calculateMonthlySavings(float income, float expenses)
{
    return income - expenses;
}

float calculateSavingsGoal(float monthlySavings, float targetSavings)
{
    return targetSavings / monthlySavings;
}

void printFinancialPlan(float income, float expenses, float monthlySavings, float targetSavings)
{
    printf("\n\n**************\n");
    printf("Your Financial Plan\n");
    printf("**************\n\n");
    
    printf("Monthly Income: $%.2f\n", income);
    printf("Monthly Expenses: $%.2f\n", expenses);
    printf("Monthly Savings: $%.2f\n", monthlySavings);
    printf("Target Monthly Savings Goal: $%.2f\n", targetSavings);
    
    if (monthlySavings < targetSavings) {
        printf("\nYou need to increase your monthly savings by $%.2f to reach your savings goals.", 
                targetSavings - monthlySavings);
    } else {
        printf("\nCongratulations! You are on track to reach your savings goals.");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
double calculateMonthlySavings(void); // weak
double calculateSavingsGoal(void); // weak
__int64 printFinancialPlan(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  int v6; // [rsp+2Ch] [rbp-14h] BYREF
  int v7; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v8[2]; // [rsp+34h] [rbp-Ch] BYREF
  unsigned int v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to your Personal Finance Planner\n\n");
  printf("Please enter your monthly income: ");
  scanf("%f", v8);
  printf("Please enter your monthly expenses: ");
  scanf("%f", &v7);
  printf("Please enter your target monthly savings: ");
  scanf("%f", &v6);
  v3 = _mm_cvtsi32_si128(v8[0]);
  *(double *)v3.m128i_i64 = calculateMonthlySavings();
  v9 = _mm_cvtsi128_si32(v3);
  v4 = _mm_cvtsi32_si128(v9);
  *(double *)v4.m128i_i64 = calculateSavingsGoal();
  v8[1] = _mm_cvtsi128_si32(v4);
  printFinancialPlan();
  return 0;
}
// 1400016D2: using guessed type double calculateMonthlySavings(void);
// 1400016EC: using guessed type double calculateSavingsGoal(void);
// 140001706: using guessed type __int64 printFinancialPlan(void);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define NUM_FLOORS 10
#define ELEVATOR_CAPACITY 10

typedef struct{
    int current_floor;
    int destination_floor;
    bool in_elevator;
    bool is_busy;
} person;

typedef struct {
    int current_floor;
    int destination_floor;
    bool is_busy;
} elevator;

int main() {
    person people[NUM_FLOORS];
    elevator elevator1;
    elevator1.current_floor = 1; //Elevator starts at the first floor
    elevator1.destination_floor = 1; //Elevator has no destination initially
    elevator1.is_busy = false;
    
    for(int i = 0; i < NUM_FLOORS; i++) {
        people[i].current_floor = i+1; //People are initially at their own floors
        people[i].in_elevator = false;
        people[i].is_busy = false;
    }
    
    int num_people_waiting = 0;
    int num_people_in_elevator = 0;
    int current_time = 0;
    
    while(current_time < 100) { //Run simulation for 100 seconds
        //Add random people to different floors
        for(int i = 0; i < NUM_FLOORS; i++) {
            if(rand()%2 == 0) {
                people[i].is_busy = true;
                people[i].destination_floor = (rand()%(NUM_FLOORS-1))+1;
                num_people_waiting++;
            }
        }
        
        //Elevator moves to destination floor
        if(elevator1.is_busy) {
            if(elevator1.current_floor > elevator1.destination_floor)
                elevator1.current_floor--;
            else if(elevator1.current_floor < elevator1.destination_floor)
                elevator1.current_floor++;
            else {
                elevator1.is_busy = false;
                num_people_in_elevator = 0;
            }
        }
        else { //Elevator is not busy, pick up people
            for(int i = 0; i < NUM_FLOORS; i++) {
                if(num_people_in_elevator < ELEVATOR_CAPACITY && people[i].is_busy && people[i].current_floor == elevator1.current_floor) {
                    people[i].in_elevator = true;
                    people[i].is_busy = false;
                    num_people_waiting--;
                    num_people_in_elevator++;
                }
            }
            //Set new destination floor
            if(num_people_in_elevator > 0) {
                int min_distance = NUM_FLOORS;
                for(int i = 0; i < NUM_FLOORS; i++) {
                    if(!people[i].in_elevator) {
                        int distance = abs(people[i].destination_floor - elevator1.current_floor);
                        if(distance < min_distance) {
                            elevator1.destination_floor = people[i].destination_floor;
                            min_distance = distance;
                        }
                    }
                }
                elevator1.is_busy = true;
            }
        }
        
        //Print current state of simulation
        printf("TIME: %d\n", current_time);
        printf("ELEVATOR AT FLOOR: %d\n", elevator1.current_floor);
        printf("DESTINATION FLOOR: %d\n", elevator1.destination_floor);
        printf("NUMBER OF PEOPLE WAITING: %d\n", num_people_waiting);
        printf("NUMBER OF PEOPLE INSIDE ELEVATOR: %d\n", num_people_in_elevator);
        printf("-----------------------------------\n");
        
        current_time++;
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int v5; // [rsp+24h] [rbp-ACh]
  int v6; // [rsp+28h] [rbp-A8h]
  char v7; // [rsp+2Ch] [rbp-A4h]
  _BYTE v8[124]; // [rsp+30h] [rbp-A0h]
  int v9; // [rsp+ACh] [rbp-24h]
  int n; // [rsp+B0h] [rbp-20h]
  int v11; // [rsp+B4h] [rbp-1Ch]
  int m; // [rsp+B8h] [rbp-18h]
  int k; // [rsp+BCh] [rbp-14h]
  unsigned int j; // [rsp+C0h] [rbp-10h]
  int v15; // [rsp+C4h] [rbp-Ch]
  unsigned int v16; // [rsp+C8h] [rbp-8h]
  int i; // [rsp+CCh] [rbp-4h]

  _main(argc, argv, envp);
  v5 = 1;
  v6 = 1;
  v7 = 0;
  for ( i = 0; i <= 9; ++i )
  {
    *(_DWORD *)&v8[12 * i] = i + 1;
    v8[12 * i + 8] = 0;
    v8[12 * i + 9] = 0;
  }
  v16 = 0;
  v15 = 0;
  for ( j = 0; (int)j <= 99; ++j )
  {
    for ( k = 0; k <= 9; ++k )
    {
      if ( (rand() & 1) == 0 )
      {
        v8[12 * k + 9] = 1;
        *(_DWORD *)&v8[12 * k + 4] = rand() % 9 + 1;
        ++v16;
      }
    }
    if ( v7 )
    {
      if ( v5 <= v6 )
      {
        if ( v5 >= v6 )
        {
          v7 = 0;
          v15 = 0;
        }
        else
        {
          ++v5;
        }
      }
      else
      {
        --v5;
      }
    }
    else
    {
      for ( m = 0; m <= 9; ++m )
      {
        if ( v15 <= 9 && v8[12 * m + 9] && *(_DWORD *)&v8[12 * m] == v5 )
        {
          v8[12 * m + 8] = 1;
          v8[12 * m + 9] = 0;
          --v16;
          ++v15;
        }
      }
      if ( v15 > 0 )
      {
        v11 = 10;
        for ( n = 0; n <= 9; ++n )
        {
          if ( v8[12 * n + 8] != 1 )
          {
            v3 = *(_DWORD *)&v8[12 * n + 4] - v5;
            if ( v5 - *(_DWORD *)&v8[12 * n + 4] >= 0 )
              v3 = v5 - *(_DWORD *)&v8[12 * n + 4];
            v9 = v3;
            if ( v3 < v11 )
            {
              v6 = *(_DWORD *)&v8[12 * n + 4];
              v11 = v9;
            }
          }
        }
        v7 = 1;
      }
    }
    printf("TIME: %d\n", j);
    printf("ELEVATOR AT FLOOR: %d\n", (unsigned int)v5);
    printf("DESTINATION FLOOR: %d\n", (unsigned int)v6);
    printf("NUMBER OF PEOPLE WAITING: %d\n", v16);
    printf("NUMBER OF PEOPLE INSIDE ELEVATOR: %d\n", (unsigned int)v15);
    printf("-----------------------------------\n");
  }
  return 0;
}
// 140001A00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File system simulation ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_BLOCKS 100

typedef struct DirectoryEntry {
    char name[20];
    int firstBlock;
} DirectoryEntry;

typedef struct FileSystem {
    int freeBlockCount;
    int allocatedBlockCount;
    int blocks[MAX_BLOCKS];
    DirectoryEntry dir[MAX_BLOCKS];
} FileSystem;

void initializeFileSystem(FileSystem *fs) {
    fs->freeBlockCount = MAX_BLOCKS;
    fs->allocatedBlockCount = 0;
    
    for (int i = 0; i < MAX_BLOCKS; i++) {
        fs->blocks[i] = 0;
        strcpy(fs->dir[i].name, "");
        fs->dir[i].firstBlock = -1;
    }
}

int allocateBlock(FileSystem *fs) {
    if (fs->freeBlockCount > 0) {
        int randBlock = rand() % MAX_BLOCKS;
        while (fs->blocks[randBlock] == 1) {
            randBlock = rand() % MAX_BLOCKS;
        }
        fs->blocks[randBlock] = 1;
        fs->freeBlockCount--;
        fs->allocatedBlockCount++;
        return randBlock;
    }
    else {
        return -1;
    }
}

void addDirectoryEntry(FileSystem *fs, char *name, int firstBlock) {
    for (int i = 0; i < MAX_BLOCKS; i++) {
        if (strcmp(fs->dir[i].name, "") == 0) {
            strcpy(fs->dir[i].name, name);
            fs->dir[i].firstBlock = firstBlock;
            break;
        }
    }
}

void printDirectory(FileSystem *fs) {
    printf("DIRECTORY CONTENTS:\n");
    for (int i = 0; i < MAX_BLOCKS; i++) {
        if (strcmp(fs->dir[i].name, "") != 0) {
            printf("%s - firstBlock: %d\n", fs->dir[i].name, fs->dir[i].firstBlock);
        }
    }
}

int main() {
    srand(time(0));
    
    FileSystem fs;
    initializeFileSystem(&fs);
    
    printf("Creating file 'alice'...\n");
    int aliceBlock = allocateBlock(&fs);
    addDirectoryEntry(&fs, "alice", aliceBlock);
    printf("Created file 'alice' in block %d\n", aliceBlock);
    printf("Free blocks remaining: %d\n", fs.freeBlockCount);
    
    printf("\nCreating file 'bob'...\n");
    int bobBlock = allocateBlock(&fs);
    addDirectoryEntry(&fs, "bob", bobBlock);
    printf("Created file 'bob' in block %d\n", bobBlock);
    printf("Free blocks remaining: %d\n", fs.freeBlockCount);
    
    printf("\nCreating file 'charlie'...\n");
    int charlieBlock = allocateBlock(&fs);
    addDirectoryEntry(&fs, "charlie", charlieBlock);
    printf("Created file 'charlie' in block %d\n", charlieBlock);
    printf("Free blocks remaining: %d\n", fs.freeBlockCount);
    
    printf("\nCreating file 'david'...\n");
    int davidBlock = allocateBlock(&fs);
    addDirectoryEntry(&fs, "david", davidBlock);
    printf("Created file 'david' in block %d\n", davidBlock);
    printf("Free blocks remaining: %d\n", fs.freeBlockCount);
    
    printDirectory(&fs);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall initializeFileSystem(_QWORD); // weak
__int64 __fastcall allocateBlock(_QWORD); // weak
__int64 __fastcall addDirectoryEntry(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall printDirectory(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001899) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[704]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v6; // [rsp+B20h] [rbp+AA0h]
  unsigned int v7; // [rsp+B24h] [rbp+AA4h]
  unsigned int v8; // [rsp+B28h] [rbp+AA8h]
  unsigned int Block; // [rsp+B2Ch] [rbp+AACh]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  initializeFileSystem(v5);
  printf("Creating file 'alice'...\n");
  Block = allocateBlock(v5);
  addDirectoryEntry(v5, "alice", Block);
  printf("Created file 'alice' in block %d\n", Block);
  printf("Free blocks remaining: %d\n", (unsigned int)v5[0]);
  printf("\nCreating file 'bob'...\n");
  v8 = allocateBlock(v5);
  addDirectoryEntry(v5, "bob", v8);
  printf("Created file 'bob' in block %d\n", v8);
  printf("Free blocks remaining: %d\n", (unsigned int)v5[0]);
  printf("\nCreating file 'charlie'...\n");
  v7 = allocateBlock(v5);
  addDirectoryEntry(v5, "charlie", v7);
  printf("Created file 'charlie' in block %d\n", v7);
  printf("Free blocks remaining: %d\n", (unsigned int)v5[0]);
  printf("\nCreating file 'david'...\n");
  v6 = allocateBlock(v5);
  addDirectoryEntry(v5, "david", v6);
  printf("Created file 'david' in block %d\n", v6);
  printf("Free blocks remaining: %d\n", (unsigned int)v5[0]);
  printDirectory(v5);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall initializeFileSystem(_QWORD);
// 14000164C: using guessed type __int64 __fastcall allocateBlock(_QWORD);
// 140001713: using guessed type __int64 __fastcall addDirectoryEntry(_QWORD, _QWORD, _QWORD);
// 1400017D1: using guessed type __int64 __fastcall printDirectory(_QWORD);
// 140001B40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Phone Book ; Style: inquisitive
#include<stdlib.h>
#include<stdio.h>

struct contact{
    char name[50];
    long int phone_num;
};

int main(){
    int choice = 0, i, num_contacts, found = 0;
    struct contact *pb;
    char search_name[50];
    
    printf("***PHONE BOOK APPLICATION***\n");
    printf("Enter the number of contacts you want to add: ");
    scanf("%d", &num_contacts);
    
    //allocate memory for contact array
    pb = malloc(num_contacts * sizeof(struct contact));
    
    //get input for each contact
    for(i=0; i<num_contacts; i++){
        printf("Enter name for contact %d: ", i+1);
        scanf("%s", pb[i].name);
        printf("Enter phone number for contact %d: ", i+1);
        scanf("%ld", &pb[i].phone_num);
    }
    
    //menu for options
    while(choice != 3){
        printf("\nWhat would you like to do?\n");
        printf("1. List all contacts\n");
        printf("2. Search for a contact by name\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        
        switch(choice){
            case 1:
                //list all contacts
                printf("\nCONTACT LIST:\n");
                for(i=0; i<num_contacts; i++){
                    printf("%-25s%ld\n", pb[i].name, pb[i].phone_num);
                }
                break;
            case 2:
                //search for contact by name
                printf("\nEnter name to search for: ");
                scanf("%s", search_name);
                for(i=0; i<num_contacts; i++){
                    if(strcmp(search_name, pb[i].name) == 0){
                        printf("\n%s's phone number is %ld\n", pb[i].name, pb[i].phone_num);
                        found = 1;
                        break;
                    }
                }
                if(found == 0){
                    printf("\n%s not found in phone book\n", search_name);
                }
                found = 0;
                break;
            case 3:
                //exit
                printf("\nExiting phone book application...\n");
                break;
            default:
                printf("\nInvalid choice. Please try again.\n");
                break;
        }
    }
    
    //free memory allocated for pb
    free(pb);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[56]; // [rsp+20h] [rbp-50h] BYREF
  int v5; // [rsp+58h] [rbp-18h] BYREF
  int v6; // [rsp+5Ch] [rbp-14h] BYREF
  void *Block; // [rsp+60h] [rbp-10h]
  int v8; // [rsp+68h] [rbp-8h]
  int i; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  v8 = 0;
  printf("***PHONE BOOK APPLICATION***\n");
  printf("Enter the number of contacts you want to add: ");
  scanf("%d", &v5);
  Block = malloc(56i64 * v5);
  for ( i = 0; i < v5; ++i )
  {
    printf("Enter name for contact %d: ", (unsigned int)(i + 1));
    scanf("%s", (char *)Block + 56 * i);
    printf("Enter phone number for contact %d: ", (unsigned int)(i + 1));
    scanf("%ld", (char *)Block + 56 * i + 52);
  }
  while ( v6 != 3 )
  {
    printf("\nWhat would you like to do?\n");
    printf("1. List all contacts\n");
    printf("2. Search for a contact by name\n");
    printf("3. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v6);
    if ( v6 == 3 )
    {
      printf("\nExiting phone book application...\n");
    }
    else
    {
      if ( v6 > 3 )
        goto LABEL_23;
      if ( v6 == 1 )
      {
        printf("\nCONTACT LIST:\n");
        for ( i = 0; i < v5; ++i )
          printf("%-25s%ld\n", (const char *)Block + 56 * i, *((unsigned int *)Block + 14 * i + 13));
      }
      else if ( v6 == 2 )
      {
        printf("\nEnter name to search for: ");
        scanf("%s", Str1);
        for ( i = 0; i < v5; ++i )
        {
          if ( !strcmp(Str1, (const char *)Block + 56 * i) )
          {
            printf("\n%s's phone number is %ld\n", (const char *)Block + 56 * i, *((unsigned int *)Block + 14 * i + 13));
            v8 = 1;
            break;
          }
        }
        if ( !v8 )
          printf("\n%s not found in phone book\n", Str1);
        v8 = 0;
      }
      else
      {
LABEL_23:
        printf("\nInvalid choice. Please try again.\n");
      }
    }
  }
  free(Block);
  return 0;
}
// 140001A00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Electronic Voting System ; Style: shape shifting
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>

/* Global variables */
int num_of_candidates;
char **candidates_name;
int *candidates_votes;

void display_candidates()
{
    printf("\nList of Candidates:");
    for(int i=0; i<num_of_candidates; i++)
    {
        printf("\n%d. %s", i+1, candidates_name[i]);
    }
    printf("\n");
}

void cast_vote(int selection)
{
    if(selection > 0 && selection <= num_of_candidates)
    {
        candidates_votes[selection-1]++;
        printf("\nVote casted for %s\n", candidates_name[selection-1]);
    }
    else
    {
        printf("\nInvalid candidate selection.\n");
    }
}

void display_results()
{
    int max_votes_index = 0;
    printf("\nResults:\n");
    for(int i=0; i<num_of_candidates; i++)
    {
        printf("%d. %s - %d votes\n", i+1, candidates_name[i], candidates_votes[i]);
        if(candidates_votes[i] > candidates_votes[max_votes_index])
        {
            max_votes_index = i;
        }
    }
    printf("\nWinner: %s\n", candidates_name[max_votes_index]);
}

int main()
{
    printf("Welcome to the Shape-Shifting Electronic Voting System!");

    printf("\nEnter the number of candidates: ");
    scanf("%d", &num_of_candidates);

    candidates_name = (char**) malloc(num_of_candidates * sizeof(char*));
    candidates_votes = (int*) malloc(num_of_candidates * sizeof(int));

    for(int i=0; i<num_of_candidates; i++)
    {
        char buffer[100];
        printf("Enter the name of candidate %d: ", i+1);
        scanf("%s", buffer);
        candidates_name[i] = strdup(buffer);
        candidates_votes[i] = 0;
    }

    int is_voting_active = 1;
    while(is_voting_active)
    {
        int selection;
        printf("\n");
        display_candidates();
        printf("Enter the number of the candidate you want to cast your vote to (or enter 0 to exit): ");
        scanf("%d", &selection);
        if(selection == 0)
        {
            is_voting_active = 0;
            printf("\nExiting...");
        }
        else
        {
            cast_vote(selection);
        }
    }

    display_results();

    // Freeing allocated memory
    for(int i=0; i<num_of_candidates; i++)
    {
        free(candidates_name[i]);
    }
    free(candidates_name);
    free(candidates_votes);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 display_candidates(void); // weak
__int64 __fastcall cast_vote(_QWORD); // weak
__int64 display_results(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strdup(const char *String);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);

//-------------------------------------------------------------------------
// Data declarations

int num_of_candidates; // weak
void *candidates_name; // idb
void *candidates_votes; // idb


//----- (00000001400017BE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char **v3; // rbx
  char String[112]; // [rsp+20h] [rbp-80h] BYREF
  unsigned int v6; // [rsp+90h] [rbp-10h] BYREF
  int j; // [rsp+94h] [rbp-Ch]
  int v8; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Shape-Shifting Electronic Voting System!");
  printf("\nEnter the number of candidates: ");
  scanf("%d", &num_of_candidates);
  candidates_name = malloc(8i64 * num_of_candidates);
  candidates_votes = malloc(4i64 * num_of_candidates);
  for ( i = 0; i < num_of_candidates; ++i )
  {
    printf("Enter the name of candidate %d: ", (unsigned int)(i + 1));
    scanf("%s", String);
    v3 = (char **)((char *)candidates_name + 8 * i);
    *v3 = strdup(String);
    *((_DWORD *)candidates_votes + i) = 0;
  }
  v8 = 1;
  while ( v8 )
  {
    printf("\n");
    display_candidates();
    printf("Enter the number of the candidate you want to cast your vote to (or enter 0 to exit): ");
    scanf("%d", &v6);
    if ( v6 )
    {
      cast_vote(v6);
    }
    else
    {
      v8 = 0;
      printf("\nExiting...");
    }
  }
  display_results();
  for ( j = 0; j < num_of_candidates; ++j )
    free(*((void **)candidates_name + j));
  free(candidates_name);
  free(candidates_votes);
  return 0;
}
// 1400015E2: using guessed type __int64 display_candidates(void);
// 140001657: using guessed type __int64 __fastcall cast_vote(_QWORD);
// 1400016D6: using guessed type __int64 display_results(void);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019040: using guessed type int num_of_candidates;

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: minimalist
#include <stdio.h>

int search(int arr[], int n, int x)
{
    int i;
    for (i = 0; i < n; i++) {
        if (arr[i] == x) {
            return i;
        }
    }
    return -1;
}

int main()
{
    int arr[] = {25, 45, 56, 67, 89, 90, 101};
    int n = sizeof(arr)/sizeof(arr[0]);
    int x = 90;
    int result = search(arr, n, x);
    if(result == -1) {
        printf("Element is not found.");
    } else {
        printf("Element is found at index %d",result);
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall search(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[9]; // [rsp+20h] [rbp-30h] BYREF
  unsigned int v5; // [rsp+44h] [rbp-Ch]
  int v6; // [rsp+48h] [rbp-8h]
  int v7; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 25;
  v4[1] = 45;
  v4[2] = 56;
  v4[3] = 67;
  v4[4] = 89;
  v4[5] = 90;
  v4[6] = 101;
  v7 = 7;
  v6 = 90;
  v5 = search(v4, 7i64, 90i64);
  if ( v5 == -1 )
    printf("Element is not found.");
  else
    printf("Element is found at index %d", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall search(_QWORD, _QWORD, _QWORD);
// 140001730: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Network Quality of Service (QoS) monitor ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct {
    int packets_sent;
    int packets_dropped;
    float packet_loss;
} QoS;

int main(void) {
    int connection_speeds[3] = {10, 100, 1000};
    QoS net_quality[3];

    srand(time(NULL));

    for (int i = 0; i < 3; i++) {
        net_quality[i].packets_sent = rand() % 5000 + 1000; // random number of packets sent
        net_quality[i].packets_dropped = rand() % net_quality[i].packets_sent; // random number of packets dropped
        net_quality[i].packet_loss = (float)net_quality[i].packets_dropped / net_quality[i].packets_sent * 100;
        printf("QoS for connection speed %dMbps: %.2f%% packet loss\n", connection_speeds[i], net_quality[i].packet_loss);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  _BYTE v5[48]; // [rsp+20h] [rbp-40h]
  int v6[3]; // [rsp+50h] [rbp-10h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6[0] = 10;
  v6[1] = 100;
  v6[2] = 1000;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 2; ++i )
  {
    *(_DWORD *)&v5[12 * i] = rand() % 5000 + 1000;
    *(_DWORD *)&v5[12 * i + 4] = rand() % *(_DWORD *)&v5[12 * i];
    *(float *)&v5[12 * i + 8] = 100.0 * (float)((float)*(int *)&v5[12 * i + 4] / (float)*(int *)&v5[12 * i]);
    printf("QoS for connection speed %dMbps: %.2f%% packet loss\n", (unsigned int)v6[i], *(float *)&v5[12 * i + 8]);
  }
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bingo Simulator ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 5
#define COLS 5

// Function to check if a number is already present in the Bingo board
int checkDuplicate(int arr[ROWS][COLS], int num)
{
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (arr[i][j] == num) {
                return 1;
            }
        }
    }
    return 0;
}

// Function to check if any row, column or diagonal is completed
int checkBingo(int arr[ROWS][COLS])
{
    int count = 0;

    // Check rows
    for (int i = 0; i < ROWS; i++) {
        count = 0;
        for (int j = 0; j < COLS; j++) {
            if (arr[i][j] == -1) {
                count++;
            }
        }
        if (count == COLS) {
            printf("BINGO! You have completed row %d\n", i+1);
            return 1;
        }
    }

    // Check columns
    for (int i = 0; i < COLS; i++) {
        count = 0;
        for (int j = 0; j < ROWS; j++) {
            if (arr[j][i] == -1) {
                count++;
            }
        }
        if (count == ROWS) {
            printf("BINGO! You have completed column %d\n", i+1);
            return 1;
        }
    }

    // Check diagonal 1 (top-left to bottom-right)
    count = 0;
    for (int i = 0; i < ROWS; i++) {
        if (arr[i][i] == -1) {
            count++;
        }
    }
    if (count == ROWS) {
        printf("BINGO! You have completed diagonal 1\n");
        return 1;
    }

    // Check diagonal 2 (top-right to bottom-left)
    count = 0;
    for (int i = 0; i < ROWS; i++) {
        if (arr[i][COLS-i-1] == -1) {
            count++;
        }
    }
    if (count == ROWS) {
        printf("BINGO! You have completed diagonal 2\n");
        return 1;
    }

    return 0;
}

int main()
{
    int nums[75];
    for (int i = 0; i < 75; i++) {
        nums[i] = i+1;
    }

    srand(time(NULL));
    int board[ROWS][COLS];
    int index;

    // Initialize the Bingo board with -1
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            board[i][j] = -1;
        }
    }

    while (!checkBingo(board)) {
        // Generate a random number between 1 and 75
        index = rand() % 75;
        while (checkDuplicate(board, nums[index])) {
            index = rand() % 75;
        }

        // Mark the number on the Bingo board
        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                if (board[i][j] == nums[index]) {
                    board[i][j] = -1;
                }
            }
        }

        // Add the number to the board
        int added = 0;
        while (!added) {
            index = rand() % 25;
            if (board[index/5][index%5] == -1) {
                board[index/5][index%5] = nums[index];
                added = 1;
            }
        }

        // Print the updated Bingo board
        printf("\n");
        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                if (board[i][j] == -1) {
                    printf("   ");
                } else {
                    printf("%2d ", board[i][j]);
                }
            }
            printf("\n");
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall checkDuplicate(_QWORD, _QWORD); // weak
__int64 __fastcall checkBingo(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001815) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[103]; // [rsp+20h] [rbp-60h] BYREF
  int jj; // [rsp+1BCh] [rbp+13Ch]
  int ii; // [rsp+1C0h] [rbp+140h]
  int v8; // [rsp+1C4h] [rbp+144h]
  int n; // [rsp+1C8h] [rbp+148h]
  int m; // [rsp+1CCh] [rbp+14Ch]
  int k; // [rsp+1D0h] [rbp+150h]
  int j; // [rsp+1D4h] [rbp+154h]
  int v13; // [rsp+1D8h] [rbp+158h]
  int i; // [rsp+1DCh] [rbp+15Ch]

  _main(argc, argv, envp);
  for ( i = 0; i <= 74; ++i )
    v5[i + 28] = i + 1;
  v3 = time(0i64);
  srand(v3);
  for ( j = 0; j <= 4; ++j )
  {
    for ( k = 0; k <= 4; ++k )
      v5[5 * j + k] = -1;
  }
  while ( !(unsigned int)checkBingo(v5) )
  {
    do
      v13 = rand() % 75;
    while ( (unsigned int)checkDuplicate(v5, (unsigned int)v5[v13 + 28]) );
    for ( m = 0; m <= 4; ++m )
    {
      for ( n = 0; n <= 4; ++n )
      {
        if ( v5[5 * m + n] == v5[v13 + 28] )
          v5[5 * m + n] = -1;
      }
    }
    v8 = 0;
    while ( !v8 )
    {
      v13 = rand() % 25;
      if ( v5[5 * (v13 / 5) + v13 % 5] == -1 )
      {
        v5[5 * (v13 / 5) + v13 % 5] = v5[v13 + 28];
        v8 = 1;
      }
    }
    printf("\n");
    for ( ii = 0; ii <= 4; ++ii )
    {
      for ( jj = 0; jj <= 4; ++jj )
      {
        if ( v5[5 * ii + jj] == -1 )
          printf("   ");
        else
          printf("%2d ", (unsigned int)v5[5 * ii + jj]);
      }
      printf("\n");
    }
    printf("\n");
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall checkDuplicate(_QWORD, _QWORD);
// 140001622: using guessed type __int64 __fastcall checkBingo(_QWORD);
// 140001CD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: brave
#include <stdio.h>
#include <stdlib.h>

#define KB 1024
#define MB (KB * 1024)

int main() {
    char *ptr1, *ptr2, *ptr3;

    // Allocate 1 MB of memory
    ptr1 = (char*) malloc(MB);
    if (ptr1 != NULL) {
        printf("1 MB of memory has been allocated at address: %p\n", ptr1);
    } else {
        printf("Error: Failed to allocate memory\n");
        exit(1);
    }

    // Allocate 512 KB of memory
    ptr2 = (char*) malloc(512 * KB);
    if (ptr2 != NULL) {
        printf("512 KB of memory has been allocated at address: %p\n", ptr2);
    } else {
        printf("Error: Failed to allocate memory\n");
        exit(1);
    }

    // Allocate 256 KB of memory
    ptr3 = (char*) malloc(256 * KB);
    if (ptr3 != NULL) {
        printf("256 KB of memory has been allocated at address: %p\n", ptr3);
    } else {
        printf("Error: Failed to allocate memory\n");
        exit(1);
    }

    // Free allocated memory
    free(ptr1);
    free(ptr2);
    free(ptr3);

    // Allocate 2 MB of memory using calloc
    ptr1 = (char*) calloc(2, MB);
    if (ptr1 != NULL) {
        printf("2 MB of memory has been allocated using calloc at address: %p\n", ptr1);
    } else {
        printf("Error: Failed to allocate memory\n");
        exit(1);
    }

    // Reallocate memory
    ptr1 = (char*) realloc(ptr1, 3 * MB);
    if (ptr1 != NULL) {
        printf("Memory reallocated to 3 MB at address: %p\n", ptr1);
    } else {
        printf("Error: Failed to reallocate memory\n");
        exit(1);
    }

    // Free allocated memory
    free(ptr1);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void __cdecl __noreturn exit(int Code);
// void *__cdecl calloc(size_t Count, size_t Size);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rax
  void *v4; // rax
  void *v5; // rax
  void *v7; // [rsp+28h] [rbp-18h]
  void *v8; // [rsp+30h] [rbp-10h]
  void *Block; // [rsp+38h] [rbp-8h]
  void *Blocka; // [rsp+38h] [rbp-8h]
  void *Blockb; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  Block = malloc(0x100000ui64);
  if ( !Block )
  {
    printf("Error: Failed to allocate memory\n");
    exit(1);
  }
  printf("1 MB of memory has been allocated at address: %p\n", Block);
  v8 = malloc(0x80000ui64);
  if ( !v8 )
  {
    printf("Error: Failed to allocate memory\n");
    exit(1);
  }
  printf("512 KB of memory has been allocated at address: %p\n", v8);
  v3 = malloc(0x40000ui64);
  v7 = v3;
  if ( !v3 )
  {
    printf("Error: Failed to allocate memory\n");
    exit(1);
  }
  printf("256 KB of memory has been allocated at address: %p\n", v3);
  free(Block);
  free(v8);
  free(v7);
  v4 = calloc(2ui64, 0x100000ui64);
  Blocka = v4;
  if ( !v4 )
  {
    printf("Error: Failed to allocate memory\n");
    exit(1);
  }
  printf("2 MB of memory has been allocated using calloc at address: %p\n", v4);
  v5 = realloc(Blocka, 0x300000ui64);
  Blockb = v5;
  if ( !v5 )
  {
    printf("Error: Failed to reallocate memory\n");
    exit(1);
  }
  printf("Memory reallocated to 3 MB at address: %p\n", v5);
  free(Blockb);
  return 0;
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Structure for diary entry */
struct diaryEntry {
    char date[11];
    char time[6];
    char title[100];
    char description[500];
};

/* Function to add a new diary entry */
void addEntry(struct diaryEntry *entry, int n) {
    printf("Enter date (dd/mm/yyyy): ");
    scanf("%10s", entry[n].date);
    printf("Enter time (hh:mm): ");
    scanf("%5s", entry[n].time);
    printf("Enter title: ");
    scanf(" %[^\n]", entry[n].title);
    printf("Enter description: ");
    scanf(" %[^\n]", entry[n].description);
}

/* Function to search for diary entries by date */
void searchEntry(struct diaryEntry *entry, int n) {
    char date[11];
    printf("Enter date to search (dd/mm/yyyy): ");
    scanf("%10s", date);
    for (int i = 0; i < n; i++) {
        if (strcmp(entry[i].date, date) == 0) {
            printf("Date: %s\nTime: %s\nTitle: %s\nDescription: %s\n", 
                entry[i].date, entry[i].time, entry[i].title, entry[i].description);
        }
    }
}

/* Function to display all diary entries */
void displayEntries(struct diaryEntry *entry, int n) {
    if (n == 0) {
        printf("No diary entries to display.\n");
    }
    else {
        printf("All diary entries:\n");
        for (int i = 0; i < n; i++) {
            printf("Date: %s\nTime: %s\nTitle: %s\nDescription: %s\n", 
                entry[i].date, entry[i].time, entry[i].title, entry[i].description);
        }
    }
}

/* Main function */
int main() {
    int choice, numEntries = 0;
    struct diaryEntry entry[100];
    do {
        printf("\nDigital Diary Menu:\n");
        printf("1. Add a new entry\n");
        printf("2. Search for entries by date\n");
        printf("3. Display all entries\n");
        printf("4. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                addEntry(entry, numEntries);
                numEntries++;
                break;
            case 2:
                searchEntry(entry, numEntries);
                break;
            case 3:
                displayEntries(entry, numEntries);
                break;
            case 4:
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice.\n");
        }
    } while (choice != 4);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addEntry(_QWORD, _QWORD); // weak
__int64 __fastcall searchEntry(_QWORD, _QWORD); // weak
__int64 __fastcall displayEntries(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001894) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[61704]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+F128h] [rbp+F0A8h] BYREF
  unsigned int v6; // [rsp+F12Ch] [rbp+F0ACh]

  _main(argc, argv, envp);
  v6 = 0;
  do
  {
    printf("\nDigital Diary Menu:\n");
    printf("1. Add a new entry\n");
    printf("2. Search for entries by date\n");
    printf("3. Display all entries\n");
    printf("4. Exit\n");
    printf("Enter choice: ");
    scanf("%d", &v5);
    if ( v5 == 4 )
    {
      printf("Exiting program.\n");
    }
    else
    {
      if ( v5 <= 4 )
      {
        switch ( v5 )
        {
          case 3:
            displayEntries(v4, v6);
            continue;
          case 1:
            addEntry(v4, v6++);
            continue;
          case 2:
            searchEntry(v4, v6);
            continue;
        }
      }
      printf("Invalid choice.\n");
    }
  }
  while ( v5 != 4 );
  return 0;
}
// 140001944: conditional instruction was optimized away because %var_8.4<3
// 1400015E2: using guessed type __int64 __fastcall addEntry(_QWORD, _QWORD);
// 1400016D4: using guessed type __int64 __fastcall searchEntry(_QWORD, _QWORD);
// 1400017C7: using guessed type __int64 __fastcall displayEntries(_QWORD, _QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Linked list operations ; Style: accurate
#include <stdio.h>
#include <stdlib.h>

struct node {
    int data;
    struct node* next;
};

struct node* create_node(int data) {
    struct node* new_node = (struct node*) malloc(sizeof(struct node));
    new_node->data = data;
    new_node->next = NULL;
    return new_node;
}

void insert_at_end(struct node** head, int data) {
    struct node* new_node = create_node(data);
    if (*head == NULL) {
        *head = new_node;
    } else {
        struct node* curr_node = *head;
        while (curr_node->next != NULL) {
            curr_node = curr_node->next;
        }
        curr_node->next = new_node;
    }
}

void delete_node(struct node** head, int data) {
    if (*head == NULL) {
        printf("List is empty.\n");
        return;
    }
    if ((*head)->data == data) {
        struct node* temp = *head;
        *head = (*head)->next;
        free(temp);
        return;
    }
    struct node* curr_node = *head;
    while (curr_node->next != NULL && curr_node->next->data != data) {
        curr_node = curr_node->next;
    }
    if (curr_node->next == NULL) {
        printf("Element %d not found in the list.\n", data);
        return;
    }
    struct node* temp = curr_node->next;
    curr_node->next = curr_node->next->next;
    free(temp);
}

void print_list(struct node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
    } else {
        struct node* curr_node = head;
        printf("List: ");
        while (curr_node != NULL) {
            printf("%d ", curr_node->data);
            curr_node = curr_node->next;
        }
        printf("\n");
    }
}

int main() {
    struct node* head = NULL;
    insert_at_end(&head, 1);
    insert_at_end(&head, 2);
    insert_at_end(&head, 3);
    insert_at_end(&head, 4);
    print_list(head);
    delete_node(&head, 3);
    print_list(head);
    delete_node(&head, 5);
    print_list(head);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall insert_at_end(_QWORD, _QWORD); // weak
__int64 __fastcall delete_node(_QWORD, _QWORD); // weak
__int64 __fastcall print_list(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017AB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v4 = 0i64;
  insert_at_end(&v4, 1i64);
  insert_at_end(&v4, 2i64);
  insert_at_end(&v4, 3i64);
  insert_at_end(&v4, 4i64);
  print_list(v4);
  delete_node(&v4, 3i64);
  print_list(v4);
  delete_node(&v4, 5i64);
  print_list(v4);
  return 0;
}
// 1400015C9: using guessed type __int64 __fastcall insert_at_end(_QWORD, _QWORD);
// 140001638: using guessed type __int64 __fastcall delete_node(_QWORD, _QWORD);
// 14000172E: using guessed type __int64 __fastcall print_list(_QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedurally Generated Maze ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROW_SIZE 10
#define COL_SIZE 10

void generateMaze(int maze[ROW_SIZE][COL_SIZE], int row, int col)
{
    int i, j;

    // Initialize the maze with walls
    for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++) {
            maze[i][j] = 1;
        }
    }

    // Generate random starting point
    srand(time(NULL));
    int startX = rand() % row;
    int startY = rand() % col;

    // Mark starting point as visited
    maze[startX][startY] = 0;

    // Generate maze using depth-first search algorithm
    int currentX = startX;
    int currentY = startY;
    int visitedCount = 1;

    while (visitedCount < row * col) {
        int possibleMoves[4][2] = {
            {currentX - 1, currentY}, // Move up
            {currentX, currentY + 1}, // Move right
            {currentX + 1, currentY}, // Move down
            {currentX, currentY - 1}  // Move left
        };

        // Shuffle the possible moves
        for (i = 0; i < 4; i++) {
            int randomIndex = rand() % 4;
            int tempX = possibleMoves[i][0];
            int tempY = possibleMoves[i][1];
            possibleMoves[i][0] = possibleMoves[randomIndex][0];
            possibleMoves[i][1] = possibleMoves[randomIndex][1];
            possibleMoves[randomIndex][0] = tempX;
            possibleMoves[randomIndex][1] = tempY;
        }

        // Try to move in each direction
        int moveSuccessful = 0;
        for (i = 0; i < 4; i++) {
            int moveX = possibleMoves[i][0];
            int moveY = possibleMoves[i][1];

            if (moveX >= 0 && moveX < row && moveY >= 0 && moveY < col && maze[moveX][moveY] != 0) {
                // Move is valid
                maze[moveX][moveY] = 0;
                currentX = moveX;
                currentY = moveY;
                visitedCount += 1;
                moveSuccessful = 1;
                break;
            }
        }

        // If no move was successful, backtrack
        if (!moveSuccessful) {
            for (i = 0; i < 4; i++) {
                int moveX = possibleMoves[i][0];
                int moveY = possibleMoves[i][1];

                if (moveX >= 0 && moveX < row && moveY >= 0 && moveY < col && maze[moveX][moveY] == 0) {
                    currentX = moveX;
                    currentY = moveY;
                    break;
                }
            }
        }
    }

    // Add entrance and exit to the maze
    maze[startX][startY] = -1;
    int exitX;
    int exitY;
    if (startX == 0) {
        exitX = rand() % row;
        exitY = col - 1;
    } else if (startX == row - 1) {
        exitX = rand() % row;
        exitY = 0;
    } else if (startY == 0) {
        exitX = row - 1;
        exitY = rand() % col;
    } else {
        exitX = 0;
        exitY = rand() % col;
    }
    maze[exitX][exitY] = -2;
}

void printMaze(int maze[ROW_SIZE][COL_SIZE], int row, int col)
{
    int i, j;

    for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++) {
            if (maze[i][j] == 1) {
                printf("#");
            } else if (maze[i][j] == 0) {
                printf(" ");
            } else if (maze[i][j] == -1) {
                printf("S");
            } else if (maze[i][j] == -2) {
                printf("E");
            }
        }
        printf("\n");
    }
}

int main()
{
    int maze[ROW_SIZE][COL_SIZE];
    generateMaze(maze, ROW_SIZE, COL_SIZE);
    printMaze(maze, ROW_SIZE, COL_SIZE);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall generateMaze(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall printMaze(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001AB3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[400]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  generateMaze(v4, 10i64, 10i64);
  printMaze(v4, 10i64, 10i64);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall generateMaze(_QWORD, _QWORD, _QWORD);
// 140001961: using guessed type __int64 __fastcall printMaze(_QWORD, _QWORD, _QWORD);
// 140001BC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Editor ; Style: introspective
#include <stdio.h>
#include <stdlib.h>

int main()
{
    // Display a Welcome Message
    printf("Welcome to my Image Editor!\n\n");

    // Ask the user for the file name
    char file_name[50];
    printf("Enter the file name: ");
    scanf("%s", file_name);

    // Open the input file
    FILE *input_file;
    input_file = fopen(file_name, "r");

    // Check if the input file exists
    if (input_file == NULL) {
        printf("Error: The file \"%s\" does not exist or could not be opened.\n", file_name);
        exit(1);
    }

    // Ask the user for the output file name
    char output_file_name[50];
    printf("Enter the output file name: ");
    scanf("%s", output_file_name);

    // Open the output file
    FILE *output_file;
    output_file = fopen(output_file_name, "w");

    // Check if the output file was successfully created
    if (output_file == NULL) {
        printf("Error: The output file \"%s\" could not be created.\n", output_file_name);
        exit(1);
    }

    // Read the contents of the input file and write it to the output file
    char c;
    while ((c = fgetc(input_file)) != EOF) {
        fputc(c, output_file);
    }

    // Close the input and output files
    fclose(input_file);
    fclose(output_file);

    // Display a message that the image has been successfully edited
    printf("The image has been successfully edited!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl fputc(int Character, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[64]; // [rsp+20h] [rbp-90h] BYREF
  char FileName[63]; // [rsp+60h] [rbp-50h] BYREF
  char v6; // [rsp+9Fh] [rbp-11h]
  FILE *Stream; // [rsp+A0h] [rbp-10h]
  FILE *v8; // [rsp+A8h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to my Image Editor!\n\n");
  printf("Enter the file name: ");
  scanf("%s", FileName);
  v8 = fopen(FileName, "r");
  if ( !v8 )
  {
    printf("Error: The file \"%s\" does not exist or could not be opened.\n", FileName);
    exit(1);
  }
  printf("Enter the output file name: ");
  scanf("%s", v4);
  Stream = fopen(v4, "w");
  if ( !Stream )
  {
    printf("Error: The output file \"%s\" could not be created.\n", v4);
    exit(1);
  }
  while ( 1 )
  {
    v6 = fgetc(v8);
    if ( v6 == -1 )
      break;
    fputc(v6, Stream);
  }
  fclose(v8);
  fclose(Stream);
  printf("The image has been successfully edited!\n");
  return 0;
}
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Auction System ; Style: introspective
/* 
   A Digital Auction System using C programming language. 
   This program is an example of what the backend architecture of an auction system can look like.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BIDDERS 100
#define MAX_ITEMS 50

// Struct for storing information about an item
typedef struct {
    char name[50];
    int starting_bid;
    int current_bid;
    char highest_bidder[50];
} Item;

// Struct for storing information about a user/bidder
typedef struct {
    char name[50];
    int balance;
    int num_bids_made;
} Bidder;

// Global variables
Item items[MAX_ITEMS];
Bidder bidders[MAX_BIDDERS];
int num_items = 0;
int num_bidders = 0;

// Function for adding a new item to the auction
void add_item() {
    if (num_items == MAX_ITEMS) {
        printf("Maximum number of items reached. No more can be added.\n");
        return;
    }
    
    Item new_item;
    printf("Enter the name of the item: ");
    fgets(new_item.name, 50, stdin);
    printf("Enter the starting bid: ");
    scanf("%d", &new_item.starting_bid);
    new_item.current_bid = new_item.starting_bid;
    strcpy(new_item.highest_bidder, "None");
    getchar(); // Consume the newline character left behind by scanf
    
    items[num_items] = new_item;
    num_items++;
    printf("Item successfully added to the auction.\n");
}

// Function for displaying all items currently in the auction
void view_items() {
    printf("%-25s %-15s %-15s\n", "ITEM", "CURRENT BID", "HIGHEST BIDDER");
    for (int i = 0; i < num_items; i++) {
        printf("%-25s %-15d %-15s\n", items[i].name, items[i].current_bid, items[i].highest_bidder);
    }
}

// Function for adding a new bidder to the auction
void add_bidder() {
    if (num_bidders == MAX_BIDDERS) {
        printf("Maximum number of bidders reached. No more can be added.\n");
        return;
    }
    
    Bidder new_bidder;
    printf("Enter the name of the bidder: ");
    fgets(new_bidder.name, 50, stdin);
    printf("Enter the starting balance: ");
    scanf("%d", &new_bidder.balance);
    getchar(); // Consume the newline character left behind by scanf
    
    bidders[num_bidders] = new_bidder;
    num_bidders++;
    printf("Bidder successfully added to the auction.\n");
}

// Function for displaying all bidders currently in the auction
void view_bidders() {
    printf("%-25s %-15s %-15s\n", "BIDDER", "BALANCE", "BIDS MADE");
    for (int i = 0; i < num_bidders; i++) {
        printf("%-25s %-15d %-15d\n", bidders[i].name, bidders[i].balance, bidders[i].num_bids_made);
    }
}

// Function for a bidder to place a bid on an item
void place_bid() {
    if (num_items == 0) {
        printf("No items currently in the auction.\n");
        return;
    }
    
    char item_name[50];
    printf("Enter the name of the item: ");
    fgets(item_name, 50, stdin);
    int item_index = -1;
    for (int i = 0; i < num_items; i++) {
        if (strcmp(item_name, items[i].name) == 0) {
            item_index = i;
            break;
        }
    }
    if (item_index == -1) {
        printf("Item not found.\n");
        return;
    }
    
    int bidder_index = -1;
    char bidder_name[50];
    printf("Enter your name: ");
    fgets(bidder_name, 50, stdin);
    for (int i = 0; i < num_bidders; i++) {
        if (strcmp(bidder_name, bidders[i].name) == 0) {
            bidder_index = i;
            break;
        }
    }
    if (bidder_index == -1) {
        printf("Bidder not found.\n");
        return;
    }
    
    if (items[item_index].current_bid >= bidders[bidder_index].balance) {
        printf("You do not have enough balance to place a bid.\n");
        return;
    }
    
    int new_bid;
    printf("Enter your bid: ");
    scanf("%d", &new_bid);
    getchar(); // Consume the newline character left behind by scanf
    
    if (new_bid <= items[item_index].current_bid) {
        printf("Your bid must be higher than the current bid.\n");
        return;
    }
    
    items[item_index].current_bid = new_bid;
    strcpy(items[item_index].highest_bidder, bidder_name);
    bidders[bidder_index].balance -= new_bid;
    bidders[bidder_index].num_bids_made++;
    
    printf("Bid successfully placed.\n");
}

int main() {
    int choice;
    
    do {
        printf("\n-- DIGITAL AUCTION SYSTEM --\n");
        printf("1. Add item to the auction\n");
        printf("2. View all items in the auction\n");
        printf("3. Add bidder to the auction\n");
        printf("4. View all bidders in the auction\n");
        printf("5. Place a bid on an item\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        getchar(); // Consume the newline character left behind by scanf
        
        switch (choice) {
            case 1:
                add_item();
                break;
            case 2:
                view_items();
                break;
            case 3:
                add_bidder();
                break;
            case 4:
                view_bidders();
                break;
            case 5:
                place_bid();
                break;
            case 6:
                printf("Exiting the program.\n");
                break;
            default:
                printf("Invalid choice. Please try again.\n");
        }
    } while (choice != 6);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_item(void); // weak
__int64 view_items(void); // weak
__int64 add_bidder(void); // weak
__int64 view_bidders(void); // weak
__int64 place_bid(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();


//----- (0000000140001D4B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("\n-- DIGITAL AUCTION SYSTEM --\n");
    printf("1. Add item to the auction\n");
    printf("2. View all items in the auction\n");
    printf("3. Add bidder to the auction\n");
    printf("4. View all bidders in the auction\n");
    printf("5. Place a bid on an item\n");
    printf("6. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    getchar();
    switch ( v4 )
    {
      case 1:
        add_item();
        break;
      case 2:
        view_items();
        break;
      case 3:
        add_bidder();
        break;
      case 4:
        view_bidders();
        break;
      case 5:
        place_bid();
        break;
      case 6:
        printf("Exiting the program.\n");
        break;
      default:
        printf("Invalid choice. Please try again.\n");
        break;
    }
  }
  while ( v4 != 6 );
  return 0;
}
// 1400015E2: using guessed type __int64 add_item(void);
// 140001753: using guessed type __int64 view_items(void);
// 140001826: using guessed type __int64 add_bidder(void);
// 14000193E: using guessed type __int64 view_bidders(void);
// 140001A0A: using guessed type __int64 place_bid(void);
// 140001F20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Recursive ; Style: retro
#include<stdio.h>

int findFactorial(int num) {
    if(num == 1) {
        return 1;
    } else {
        return (num * findFactorial(num - 1));
    }
}

int main() {
    int input;
    printf("Welcome to Retro Factorial!\n");
    printf("Enter a number between 1 and 10: ");
    scanf("%d", &input);

    if(input < 1 || input > 10) {
        printf("Invalid input. Please enter a number between 1 and 10.\n");
        return 0;
    }

    printf("%d! = %d\n", input, findFactorial(input));
    printf("Thank you for using Retro Factorial!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall findFactorial(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001611) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int Factorial; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to Retro Factorial!\n");
  printf("Enter a number between 1 and 10: ");
  scanf("%d", &v5);
  if ( (int)v5 > 0 && (int)v5 <= 10 )
  {
    Factorial = findFactorial(v5);
    printf("%d! = %d\n", v5, Factorial);
    printf("Thank you for using Retro Factorial!\n");
    return 0;
  }
  else
  {
    printf("Invalid input. Please enter a number between 1 and 10.\n");
    return 0;
  }
}
// 1400015E2: using guessed type __int64 __fastcall findFactorial(_QWORD);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: GPS Navigation Simulation ; Style: decentralized
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

#define MAX_CITIES 10
#define MIN_LATITUDE 10.0
#define MAX_LATITUDE 30.0
#define MIN_LONGITUDE 70.0
#define MAX_LONGITUDE 90.0

typedef struct{
    char* name;
    float latitude;
    float longitude;
}City;

City cities[MAX_CITIES];

void initialize_cities(){
    srand(time(0));
    for(int i=0;i<MAX_CITIES;i++){
        cities[i].name = (char*)malloc(sizeof(char)*10);
        sprintf(cities[i].name, "City%d", i+1);
        cities[i].latitude = ((float)rand()/(float)(RAND_MAX))*(MAX_LATITUDE-MIN_LATITUDE)+MIN_LATITUDE;
        cities[i].longitude = ((float)rand()/(float)(RAND_MAX))*(MAX_LONGITUDE-MIN_LONGITUDE)+MIN_LONGITUDE;
    }
}

float calculate_distance(float lat1, float long1, float lat2, float long2){
    float pi = 3.14159265358979323846;
    float theta1 = lat1 * pi / 180.0;
    float theta2 = lat2 * pi / 180.0;
    float delta_theta = (lat2 - lat1) * pi / 180.0;
    float delta_lambda = (long2 - long1) * pi / 180.0;
    
    float a = sin(delta_theta/2) * sin(delta_theta/2) +
            cos(theta1) * cos(theta2) *
            sin(delta_lambda/2) * sin(delta_lambda/2);
    float c = 2 * atan2(sqrt(a), sqrt(1-a));
    float distance = 6371 * c;
    return distance;
}

int main(){
    initialize_cities();
    float current_latitude = 20.0, current_longitude = 80.0;
    float total_distance = 0.0;
    printf("Starting GPS Navigation Simulation!\n\n");
    printf("Current Location: (%.2f,%.2f)\n",current_latitude,current_longitude);
    printf("Enter Destination City (1 to %d): ",MAX_CITIES);
    int destination;
    scanf("%d",&destination);
    destination--;
    printf("\n");
    while(destination >=0 && destination < MAX_CITIES){
        printf("Destination : %s (%.2f,%.2f)\n",cities[destination].name,cities[destination].latitude,cities[destination].longitude);
        printf("Route: %s", cities[destination].name);
        float distance = calculate_distance(current_latitude,current_longitude,cities[destination].latitude,cities[destination].longitude);
        printf(" (%.2f km)",distance);
        total_distance += distance;
        current_latitude = cities[destination].latitude;
        current_longitude = cities[destination].longitude;
        printf("\n\n");
        printf("Current Location: (%.2f,%.2f)\n",current_latitude,current_longitude);
        printf("Enter Destination City (1 to %d) or -1 to exit: ",MAX_CITIES);
        scanf("%d",&destination);
        destination--;
        printf("\n");
    }
    printf("Total Distance Travelled: %.2f km",total_distance);
    printf("\n\nEnd of GPS Navigation Simulation!");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 initialize_cities(void); // weak
double calculate_distance(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN cities; // weak
_UNKNOWN unk_140019048; // weak
float flt_14001904C[37]; // weak


//----- (00000001400019AB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  unsigned int v5; // [rsp+2Ch] [rbp-14h] BYREF
  float v6; // [rsp+30h] [rbp-10h]
  float v7; // [rsp+34h] [rbp-Ch]
  float v8; // [rsp+38h] [rbp-8h]
  float v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  initialize_cities();
  v9 = 20.0;
  v8 = 80.0;
  v7 = 0.0;
  printf("Starting GPS Navigation Simulation!\n\n");
  printf("Current Location: (%.2f,%.2f)\n", 20.0, 80.0);
  printf("Enter Destination City (1 to %d): ", 10i64);
  scanf("%d", &v5);
  --v5;
  printf("\n");
  while ( v5 < 0xA )
  {
    printf(
      "Destination : %s (%.2f,%.2f)\n",
      *((const char **)&cities + 2 * (int)v5),
      *((float *)&unk_140019048 + 4 * (int)v5),
      flt_14001904C[4 * v5]);
    printf("Route: %s", *((const char **)&cities + 2 * (int)v5));
    v3 = _mm_cvtsi32_si128(LODWORD(v9));
    *(double *)v3.m128i_i64 = calculate_distance();
    v6 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
    printf(" (%.2f km)", v6);
    v7 = v7 + v6;
    v9 = *((float *)&unk_140019048 + 4 * (int)v5);
    v8 = flt_14001904C[4 * v5];
    printf("\n\n");
    printf("Current Location: (%.2f,%.2f)\n", v9, v8);
    printf("Enter Destination City (1 to %d) or -1 to exit: ", 10i64);
    scanf("%d", &v5);
    --v5;
    printf("\n");
  }
  printf("Total Distance Travelled: %.2f km", v7);
  printf("\n\nEnd of GPS Navigation Simulation!");
  return 0;
}
// 140001644: using guessed type __int64 initialize_cities(void);
// 14000177C: using guessed type double calculate_distance(void);
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14001904C: using guessed type float flt_14001904C[37];

// nfuncs=190 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Benchmarking ; Style: secure
#include<stdio.h>
#include<time.h>

#define ARRAY_SIZE 1000000

// Function to generate a random array
void generate_array(int arr[])
{
    srand(time(NULL));
    for(int i=0; i<ARRAY_SIZE; i++)
    {
        arr[i] = rand()%100;
    }
}

// Function to perform selection sort
void selection_sort(int arr[])
{
    int min_idx;
    for (int i = 0; i < ARRAY_SIZE-1; i++)
    {
        min_idx = i;
        for (int j = i+1; j < ARRAY_SIZE; j++)
        {
            if (arr[j] < arr[min_idx])
            {
                min_idx = j;
            }
        }
        int temp = arr[i];
        arr[i] = arr[min_idx];
        arr[min_idx] = temp;
    }
}

// Function to perform insertion sort
void insertion_sort(int arr[])
{
    int key, j;
    for (int i = 1; i < ARRAY_SIZE; i++)
    {
        key = arr[i];
        j = i - 1;

        while (j >= 0 && arr[j] > key)
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

// Function to print the time taken by a function
void measure_time(void (*func)(int[]), int arr[], char* func_name)
{
    clock_t start, end;
    double cpu_time_used;

    start = clock();
    func(arr);
    end = clock();
    
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
    printf("%s took %f seconds\n", func_name, cpu_time_used);
}

int main()
{
    int arr[ARRAY_SIZE];

    generate_array(arr);
    measure_time(selection_sort, arr, "Selection sort");

    generate_array(arr);
    measure_time(insertion_sort, arr, "Insertion sort");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (0000000140001855) ----------------------------------------------------
#error "140001855: stack frame is too big (funcsize=0)"

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Antivirus scanner ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILE_SIZE 1024

// Define a structure to hold information about infected files
typedef struct {
    char filename[100];
    int is_infected;
} FileInfo;

// Define a function to check if a file is infected or not
int is_infected(char* buffer, int size) {
    for (int i = 0; i < size; i++) {
        if (buffer[i] == 'v' && buffer[i+1] == 'i' && buffer[i+2] == 'r' && buffer[i+3] == 'u' && buffer[i+4] == 's') {
            return 1;
        }
    }
    return 0;
}

// Define a function to scan a file for viruses
void scan_file(char* filename, FileInfo* file_info) {
    FILE* fp = fopen(filename, "rb");
    if (fp == NULL) {
        printf("Error: Can't open file '%s'\n", filename);
        return;
    }
    char buffer[MAX_FILE_SIZE];
    int n = fread(buffer, sizeof(char), MAX_FILE_SIZE, fp);
    fclose(fp);
    if (is_infected(buffer, n)) {
        printf("File '%s' is infected with viruses.\n", filename);
        file_info->is_infected = 1;
    } else {
        printf("File '%s' is clean.\n", filename);
        file_info->is_infected = 0;
    }
    strcpy(file_info->filename, filename);
}

int main() {
    char filepath[100];
    printf("Enter the full path of the file or folder to scan: ");
    scanf("%s", filepath);
    FileInfo file_list[100];
    int num_files = 0;
    if (strstr(filepath, ".exe") != NULL || strstr(filepath, ".dll") != NULL) {
        scan_file(filepath, &file_list[0]);
        num_files++;
    } else {
        FILE* fp = popen("ls -p | grep -v /", "r");
        char filename[100];
        while (fgets(filename, sizeof(filename), fp) != NULL) {
            filename[strlen(filename)-1] = '\0';
            char fullpath[100];
            sprintf(fullpath, "%s/%s", filepath, filename);
            if (strstr(fullpath, ".exe") != NULL || strstr(fullpath, ".dll") != NULL) {
                scan_file(fullpath, &file_list[num_files]);
                num_files++;
            }
        }
        pclose(fp);
    }
    printf("\nScan results:\n\n");
    for (int i = 0; i < num_files; i++) {
        printf("File %d: %s\n", i+1, file_list[i].filename);
        if (file_list[i].is_infected) {
            printf("This file is infected!\n");
        }
        printf("\n");
    }
    printf("\nScan complete.\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
__int64 __fastcall scan_file(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *_pclose)(FILE *Stream);
// extern FILE *(__cdecl *_popen)(const char *Command, const char *Mode);


//----- (00000001400017E5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[96]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[112]; // [rsp+90h] [rbp+10h] BYREF
  char v7[10400]; // [rsp+100h] [rbp+80h] BYREF
  char Str[112]; // [rsp+29A0h] [rbp+2920h] BYREF
  FILE *Stream; // [rsp+2A10h] [rbp+2990h]
  int i; // [rsp+2A18h] [rbp+2998h]
  int v11; // [rsp+2A1Ch] [rbp+299Ch]

  _main(argc, argv, envp);
  printf("Enter the full path of the file or folder to scan: ");
  scanf("%s", Str);
  v11 = 0;
  if ( strstr(Str, ".exe") || strstr(Str, ".dll") )
  {
    scan_file(Str, v7);
    ++v11;
  }
  else
  {
    Stream = _popen("ls -p | grep -v /", "r");
    while ( fgets(v4, 100, Stream) )
    {
      v4[strlen(v4) - 1] = 0;
      sprintf(Buffer, "%s/%s", Str, v4);
      if ( strstr(Buffer, ".exe") || strstr(Buffer, ".dll") )
        scan_file(Buffer, &v7[104 * v11++]);
    }
    _pclose(Stream);
  }
  printf("\nScan results:\n\n");
  for ( i = 0; i < v11; ++i )
  {
    printf("File %d: %s\n", (unsigned int)(i + 1), &v7[104 * i]);
    if ( *((_DWORD *)Buffer + 26 * i + 57) )
      printf("This file is infected!\n");
    printf("\n");
  }
  printf("\nScan complete.\n");
  return 0;
}
// 1400016CF: using guessed type __int64 __fastcall scan_file(_QWORD, _QWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400017E5: using guessed type char var_2920[10400];
// 1400017E5: using guessed type char var_2A00[96];

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Color Code Converter ; Style: high level of detail
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function prototype
void convertRGB(char color[]);
void convertHex(char color[]);
void convertHSL(char color[]);

int main() {
    char color[50];
    int choice;

    printf("Welcome to the Color Code Converter Program!\n\n");
    printf("1. Convert RGB color code to Hex color code\n");
    printf("2. Convert Hex color code to RGB color code\n");
    printf("3. Convert RGB color code to HSL color code\n\n");

    printf("Enter your choice: ");
    scanf("%d", &choice);

    switch(choice) {
        case 1:
            printf("Enter RGB color code in the format R,G,B: ");
            scanf("%s", color);
            convertRGB(color);
            break;
        case 2:
            printf("Enter Hex color code in the format #RRGGBB: ");
            scanf("%s", color);
            convertHex(color);
            break;
        case 3:
            printf("Enter RGB color code in the format R,G,B: ");
            scanf("%s", color);
            convertHSL(color);
            break;
        default:
            printf("Invalid choice. Exiting program.\n");
            break;
    }

    return 0;
}

// Function to convert RGB color code to Hex color code
void convertRGB(char color[]) {
    int r, g, b;

    sscanf(color, "%d,%d,%d", &r, &g, &b);
    
    char hex[8];
    sprintf(hex, "#%02X%02X%02X", r, g, b);

    printf("The RGB color code %s is equivalent to the Hex color code %s.\n", color, hex);
}

// Function to convert Hex color code to RGB color code
void convertHex(char color[]) {
    int r, g, b;

    sscanf(color, "#%02x%02x%02x", &r, &g, &b);

    printf("The Hex color code %s is equivalent to the RGB color code %d,%d,%d.\n", color, r, g, b);
}

// Function to convert RGB color code to HSL color code
void convertHSL(char color[]) {
    int r, g, b;
    double h, s, l;

    sscanf(color, "%d,%d,%d", &r, &g, &b);

    double red = r / 255.0;
    double green = g / 255.0;
    double blue = b / 255.0;

    double cmax = red > green ? (red > blue ? red : blue) : (green > blue ? green : blue);
    double cmin = red < green ? (red < blue ? red : blue) : (green < blue ? green : blue);
    double delta = cmax - cmin;

    // Hue calculation
    if (delta == 0) {
        h = 0;
    } else if (cmax == red) {
        h = fmod((green - blue) / delta, 6);
    } else if (cmax == green) {
        h = ((blue - red) / delta) + 2;
    } else {
        h = ((red - green) / delta) + 4;
    }

    h = h * 60;
    if (h < 0) {
        h = h + 360;
    }

    // Lightness calculation
    l = (cmax + cmin) / 2;

    // Saturation calculation
    if (delta == 0) {
        s = 0;
    } else {
        s = delta / (1 - abs(2 * l - 1));
    }

    printf("The RGB color code %s is equivalent to the HSL color code %d,%d%%,%d%%.\n", color, (int) h, (int) (s * 100), (int) (l * 100));
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall convertRGB(_QWORD); // weak
__int64 __fastcall convertHex(_QWORD); // weak
__int64 __fastcall convertHSL(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001668) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-44h] BYREF
  char v5[64]; // [rsp+30h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Color Code Converter Program!\n\n");
  printf("1. Convert RGB color code to Hex color code\n");
  printf("2. Convert Hex color code to RGB color code\n");
  printf("3. Convert RGB color code to HSL color code\n\n");
  printf("Enter your choice: ");
  scanf("%d", &v4);
  if ( v4 == 3 )
  {
    printf("Enter RGB color code in the format R,G,B: ");
    scanf("%s", v5);
    convertHSL(v5);
  }
  else
  {
    if ( v4 > 3 )
    {
LABEL_9:
      printf("Invalid choice. Exiting program.\n");
      return 0;
    }
    if ( v4 == 1 )
    {
      printf("Enter RGB color code in the format R,G,B: ");
      scanf("%s", v5);
      convertRGB(v5);
    }
    else
    {
      if ( v4 != 2 )
        goto LABEL_9;
      printf("Enter Hex color code in the format #RRGGBB: ");
      scanf("%s", v5);
      convertHex(v5);
    }
  }
  return 0;
}
// 1400017AA: using guessed type __int64 __fastcall convertRGB(_QWORD);
// 140001828: using guessed type __int64 __fastcall convertHex(_QWORD);
// 14000188B: using guessed type __int64 __fastcall convertHSL(_QWORD);
// 140001C40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Dice Roller ; Style: medieval
#include <stdio.h> // for standard input output operations
#include <stdlib.h> // for using random function

int main()
{
    int dice, players, i, j, total, maxTotal, maxPlayer;
    // Variables for dice, number of players, loop iterations, total score, max score and max player 
    
    printf("Welcome to Medieval Dice Roller game!\n");
    printf("Enter the number of players: ");
    scanf("%d",&players);
    printf("\n");
    printf("Let's Begin!\n");
    printf("-----------------\n");

    for(i=1;i<=players;i++) 
    {
        printf("Player %d's turn. Press 1 to roll the dice: ",i);
        scanf("%d",&dice);
        if(dice==1)  // if player chooses to roll dice, then only proceed
        {
            printf("Rolling Dice...\n");
            dice = (rand() % 6) + 1; // generating random number between 1 and 6 (inclusive)
            printf("\nYou rolled a %d!\n\n", dice);
            total=total+dice; // update the total score of the player

            if(total>=30) // if total score of player reaches 30, game ends
            {
                maxTotal = total;
                maxPlayer = i;
                printf("Congratulations Player %d, you won the game with a score of %d!", maxPlayer, maxTotal);
                return 0;
            }
        }
        else // if player does not select 1, skip their turn
        {
            printf("%d! You missed the turn.\n",dice);
        }
    }

    // at the end of all turns, calculate and display the winner with max score
    printf("\n\nAll players have finished their turn.\n");

    for(i=1;i<=players;i++) 
    {
        printf("Player %d's Total Score: ",i);
        printf("%d\n",total);
        if(total>maxTotal) 
        {
            maxTotal=total;
            maxPlayer=i;
        }

    }
    printf("-----------------\n");
    printf("Congratulations Player %d, you won the game with a score of %d!\n",maxPlayer,maxTotal);
    printf("-----------------\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-18h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v6; // [rsp+30h] [rbp-10h]
  unsigned int v7; // [rsp+34h] [rbp-Ch]
  unsigned int v8; // [rsp+38h] [rbp-8h]
  unsigned int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to Medieval Dice Roller game!\n");
  printf("Enter the number of players: ");
  scanf("%d", &v4);
  printf("\n");
  printf("Let's Begin!\n");
  printf("-----------------\n");
  for ( i = 1; (int)i <= v4; ++i )
  {
    printf("Player %d's turn. Press 1 to roll the dice: ", i);
    scanf("%d", &v5);
    if ( v5 == 1 )
    {
      printf("Rolling Dice...\n");
      v5 = rand() % 6 + 1;
      printf("\nYou rolled a %d!\n\n", v5);
      v8 += v5;
      if ( (int)v8 > 29 )
      {
        v7 = v8;
        v6 = i;
        printf("Congratulations Player %d, you won the game with a score of %d!", i, v8);
        return 0;
      }
    }
    else
    {
      printf("%d! You missed the turn.\n", v5);
    }
  }
  printf("\n\nAll players have finished their turn.\n");
  for ( i = 1; (int)i <= v4; ++i )
  {
    printf("Player %d's Total Score: ", i);
    printf("%d\n", v8);
    if ( (int)v8 > (int)v7 )
    {
      v7 = v8;
      v6 = i;
    }
  }
  printf("-----------------\n");
  printf("Congratulations Player %d, you won the game with a score of %d!\n", v6, v7);
  printf("-----------------\n");
  return 0;
}
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int option;

    printf("Welcome to the Automated Fortune Teller\n");
    printf("Please choose your reading:\n");
    printf("1. Love and Relationships\n");
    printf("2. Career and Finances\n");
    printf("3. Life and Success\n");
    scanf("%d", &option);

    switch(option)
    {
        case 1:
            printf("You will soon meet someone special who will bring great joy and happiness into your life.\n");
            break;
        case 2:
            printf("Your hard work and dedication will pay off in your career. Expect a promotion or raise soon.\n");
            break;
        case 3:
            printf("You are destined for great success. Keep working hard and never give up on your dreams.\n");
            break;
        default:
            printf("Invalid option selected. Please choose from 1-3.\n");
            break;
    }

    // Generate a random number to predict a lucky number
    srand(time(0));
    int lucky_number = rand() % 10 + 1;

    printf("Your lucky number for today is: %d\n", lucky_number);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+28h] [rbp-8h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Automated Fortune Teller\n");
  printf("Please choose your reading:\n");
  printf("1. Love and Relationships\n");
  printf("2. Career and Finances\n");
  printf("3. Life and Success\n");
  scanf("%d", &v5);
  if ( v5 == 3 )
  {
    printf("You are destined for great success. Keep working hard and never give up on your dreams.\n");
  }
  else
  {
    if ( v5 > 3 )
    {
LABEL_9:
      printf("Invalid option selected. Please choose from 1-3.\n");
      goto LABEL_10;
    }
    if ( v5 == 1 )
    {
      printf("You will soon meet someone special who will bring great joy and happiness into your life.\n");
    }
    else
    {
      if ( v5 != 2 )
        goto LABEL_9;
      printf("Your hard work and dedication will pay off in your career. Expect a promotion or raise soon.\n");
    }
  }
LABEL_10:
  v3 = time(0i64);
  srand(v3);
  v6 = rand() % 10 + 1;
  printf("Your lucky number for today is: %d\n", v6);
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

char* fortunes[] = {
    "You will have a great day today!",
    "Your fortunes will improve in the next few days.",
    "You will meet a new friend soon.",
    "Don't worry, things will work out in the end.",
    "Expect some good news in the near future.",
    "Be careful, danger may lurk ahead.",
    "Success is just around the corner!",
    "A little effort will go a long way.",
    "You will find happiness in unexpected places.",
    "Be careful with your words, they have power.",
    "Your hard work will be rewarded.",
    "Don't give up, success is within reach.",
    "You will make a big change in your life soon.",
    "Be prepared for a pleasant surprise.",
    "You will have a long and happy life.",
    "Look for the silver lining in every cloud.",
    "Be the change you wish to see in the world.",
    "Take a chance, it will pay off in the end.",
    "You will find love when you least expect it.",
    "The future is bright, keep moving forward.",
};

int main()
{
    srand(time(0));
    printf("Welcome to the Automated Fortune Teller!\n");
    printf("Please enter your name: ");

    char name[100];
    fgets(name, 100, stdin);
    name[strcspn(name, "\n")] = 0; // remove trailing newline

    printf("\nHello, %s! Here is your fortune for today:\n\n", name);
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n");

    int index = rand() % 20;
    printf("%s\n", fortunes[index]);

    printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("\nThank you for visiting the Automated Fortune Teller!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

char *fortunes[20] =
{
  "You will have a great day today!",
  "Your fortunes will improve in the next few days.",
  "You will meet a new friend soon.",
  "Don't worry, things will work out in the end.",
  "Expect some good news in the near future.",
  "Be careful, danger may lurk ahead.",
  "Success is just around the corner!",
  "A little effort will go a long way.",
  "You will find happiness in unexpected places.",
  "Be careful with your words, they have power.",
  "Your hard work will be rewarded.",
  "Don't give up, success is within reach.",
  "You will make a big change in your life soon.",
  "Be prepared for a pleasant surprise.",
  "You will have a long and happy life.",
  "Look for the silver lining in every cloud.",
  "Be the change you wish to see in the world.",
  "Take a chance, it will pay off in the end.",
  "You will find love when you least expect it.",
  "The future is bright, keep moving forward."
}; // weak


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  FILE *v4; // rax
  char Buffer[108]; // [rsp+20h] [rbp-70h] BYREF
  int v7; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Automated Fortune Teller!\n");
  printf("Please enter your name: ");
  v4 = __acrt_iob_func(0);
  fgets(Buffer, 100, v4);
  Buffer[strcspn(Buffer, "\n")] = 0;
  printf("\nHello, %s! Here is your fortune for today:\n\n", Buffer);
  printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n");
  v7 = rand() % 20;
  printf("%s\n", fortunes[v7]);
  printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
  printf("\nThank you for visiting the Automated Fortune Teller!\n");
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A020: using guessed type char *fortunes[20];
// 1400015B0: using guessed type char Buffer[108];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Weather simulation ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL));
    int temperature = rand() % 50;
    int humidity = rand() % 100;
    int windspeed = rand() % 50 + 1;

    printf("Welcome to the Weather Simulator!\n\n");

    if (temperature <= 10) {
        printf("Current temperature: %d°C. It's freezing outside, dress warmly!\n", temperature);
    } else if (temperature >= 30) {
        printf("Current temperature: %d°C. It's scorching outside, stay hydrated!\n", temperature);
    } else {
        printf("Current temperature: %d°C. It's a pleasant day outside.\n", temperature);
    }

    if (humidity <= 30) {
        printf("Current humidity: %d%%. It's dry outside, use moisturizer!\n", humidity);
    } else if (humidity >= 60) {
        printf("Current humidity: %d%%. It's humid outside, drink water regularly!\n", humidity);
    } else {
        printf("Current humidity: %d%%. It's a nice day outside.\n", humidity);
    }

    if (windspeed <= 10) {
        printf("Current windspeed: %d km/h. It's calm outside, enjoy the breeze!\n", windspeed);
    } else if (windspeed >= 30) {
        printf("Current windspeed: %d km/h. It's windy outside, hold onto your hats!\n", windspeed);
    } else {
        printf("Current windspeed: %d km/h. It's a peaceful day outside.\n", windspeed);
    }

    printf("\nThanks for using the Weather Simulator! Stay safe and be prepared!");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-Ch]
  int v6; // [rsp+28h] [rbp-8h]
  int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v7 = rand() % 50;
  v6 = rand() % 100;
  v5 = rand() % 50 + 1;
  printf("Welcome to the Weather Simulator!\n\n");
  if ( v7 > 10 )
  {
    if ( v7 <= 29 )
      printf("Current temperature: %d°C. It's a pleasant day outside.\n", (unsigned int)v7);
    else
      printf("Current temperature: %d°C. It's scorching outside, stay hydrated!\n", (unsigned int)v7);
  }
  else
  {
    printf("Current temperature: %d°C. It's freezing outside, dress warmly!\n", (unsigned int)v7);
  }
  if ( v6 > 30 )
  {
    if ( v6 <= 59 )
      printf("Current humidity: %d%%. It's a nice day outside.\n", (unsigned int)v6);
    else
      printf("Current humidity: %d%%. It's humid outside, drink water regularly!\n", (unsigned int)v6);
  }
  else
  {
    printf("Current humidity: %d%%. It's dry outside, use moisturizer!\n", (unsigned int)v6);
  }
  if ( v5 > 10 )
  {
    if ( v5 <= 29 )
      printf("Current windspeed: %d km/h. It's a peaceful day outside.\n", (unsigned int)v5);
    else
      printf("Current windspeed: %d km/h. It's windy outside, hold onto your hats!\n", (unsigned int)v5);
  }
  else
  {
    printf("Current windspeed: %d km/h. It's calm outside, enjoy the breeze!\n", (unsigned int)v5);
  }
  printf("\nThanks for using the Weather Simulator! Stay safe and be prepared!");
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Hexadecimal Converter ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void print_hex(int num);
char dec_to_hex(int dec);
int hex_to_dec(char hex);

int main()
{
    char input[50];
    int dec_num, i;

    printf("Hey there! I'm a humorous hexadecimal converter. Please enter a decimal number: ");
    fgets(input, 50, stdin);
    dec_num = atoi(input);

    printf("Oooh, %d, that's a good one. Let me convert it to hexadecimal for you...\n", dec_num);

    print_hex(dec_num);

    printf("\nWow, that was fun! Let's do it again with a new number. Enter another decimal number (or type exit to quit):\n");

    while (fgets(input, 50, stdin) != NULL) {
        if (strcasecmp(input, "exit\n") == 0) {
            printf("Aww, I guess I'll see you later then. Goodbye!");
            return 0;
        }

        dec_num = atoi(input);

        printf("Awesome, let me work my magic and convert %d to hexadecimal...here it is:\n", dec_num);

        print_hex(dec_num);

        printf("\nThat was amazing, let's do it again! Enter another decimal number (or type exit to quit):\n");

    }

    return 0;
}

void print_hex(int num) {
    char hex[50];
    int i = 0, remainder;

    while (num > 0) {
        remainder = num % 16;
        hex[i] = dec_to_hex(remainder);
        num /= 16;
        i++;
    }

    printf("0x");

    for (i = i-1; i >= 0; i--) {
        printf("%c", hex[i]);
    }
}

char dec_to_hex(int dec) {
    char hex;

    if (dec >= 0 && dec <= 9) {
        hex = dec + '0';
    } else {
        switch (dec) {
            case 10: hex = 'A'; break;
            case 11: hex = 'B'; break;
            case 12: hex = 'C'; break;
            case 13: hex = 'D'; break;
            case 14: hex = 'E'; break;
            case 15: hex = 'F'; break;
        }
    }

    return hex;
}

int hex_to_dec(char hex) {
    int dec;

    if (hex >= '0' && hex <= '9') {
        dec = hex - '0';
    } else {
        switch (hex) {
            case 'A':
            case 'a':
                dec = 10;
                break;
            case 'B':
            case 'b':
                dec = 11;
                break;
            case 'C':
            case 'c':
                dec = 12;
                break;
            case 'D':
            case 'd':
                dec = 13;
                break;
            case 'E':
            case 'e':
                dec = 14;
                break;
            case 'F':
            case 'f':
                dec = 15;
                break;
            default:
                printf("Oops, %c is not a valid hexadecimal digit. Please try again:\n", hex);
                return -1;
        }
    }

    return dec;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall print_hex(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl atoi(const char *String);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *_stricmp)(const char *String1, const char *String2);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v5; // rax
  char Buffer[60]; // [rsp+20h] [rbp-40h] BYREF
  unsigned int v7; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Hey there! I'm a humorous hexadecimal converter. Please enter a decimal number: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 50, v3);
  v7 = atoi(Buffer);
  printf("Oooh, %d, that's a good one. Let me convert it to hexadecimal for you...\n", v7);
  print_hex(v7);
  printf("\nWow, that was fun! Let's do it again with a new number. Enter another decimal number (or type exit to quit):\n");
  while ( 1 )
  {
    v5 = __acrt_iob_func(0);
    if ( !fgets(Buffer, 50, v5) )
      break;
    if ( !_stricmp(Buffer, "exit\n") )
    {
      printf("Aww, I guess I'll see you later then. Goodbye!");
      return 0;
    }
    v7 = atoi(Buffer);
    printf("Awesome, let me work my magic and convert %d to hexadecimal...here it is:\n", v7);
    print_hex(v7);
    printf("\nThat was amazing, let's do it again! Enter another decimal number (or type exit to quit):\n");
  }
  return 0;
}
// 1400016B6: using guessed type __int64 __fastcall print_hex(_QWORD);
// 140001930: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: puzzling
#include<stdio.h>

int main()
{
    printf("Welcome to the Maze Route Finder Game!\n");
    printf("In this game, you will navigate through a maze by inputting your movements.\n");
    printf("The maze is represented by a 2D array, where 0 represents an open cell and 1 represents a wall.\n");
    printf("You are represented by the letter 'O', and the exit is represented by the letter 'E'.\n");
    
    int maze[5][5] = { {0, 0, 1, 0, 1},
                       {1, 0, 1, 0, 1},
                       {0, 0, 0, 0, 1},
                       {1, 1, 1, 0, 0},
                       {1, 0, 0, 0, 1} };
    
    int row = 0;
    int col = 0;
    int exit_row = 4;
    int exit_col = 4;
    
    maze[row][col] = 'O';
    maze[exit_row][exit_col] = 'E';
    
    printf("Here is the maze:\n");
    for(int i = 0; i < 5; ++i)
    {
        for(int j = 0; j < 5; ++j)
        {
            if(maze[i][j] == 0 || maze[i][j] == 'O' || maze[i][j] == 'E')
            {
                printf("%c ", maze[i][j]);
            }
            else
            {
                printf("%d ", maze[i][j]);
            }
        }
        printf("\n");
    }
    
    char move;
    while(1)
    {
        printf("Enter your move: ");
        scanf(" %c", &move);
        
        if(move == 'w')
        {
            if(row > 0 && maze[row-1][col] == 0)
            {
                maze[row][col] = 0;
                --row;
                maze[row][col] = 'O';
            }
            else
            {
                printf("Invalid move! Try again.\n");
            }
        }
        else if(move == 'a')
        {
            if(col > 0 && maze[row][col-1] == 0)
            {
                maze[row][col] = 0;
                --col;
                maze[row][col] = 'O';
            }
            else
            {
                printf("Invalid move! Try again.\n");
            }
        }
        else if(move == 's')
        {
            if(row < 4 && maze[row+1][col] == 0)
            {
                maze[row][col] = 0;
                ++row;
                maze[row][col] = 'O';
            }
            else
            {
                printf("Invalid move! Try again.\n");
            }
        }
        else if(move == 'd')
        {
            if(col < 4 && maze[row][col+1] == 0)
            {
                maze[row][col] = 0;
                ++col;
                maze[row][col] = 'O';
            }
            else
            {
                printf("Invalid move! Try again.\n");
            }
        }
        else
        {
            printf("Invalid input! Try again.\n");
        }
        
        if(row == exit_row && col == exit_col)
        {
            printf("Congratulations! You escaped the maze!\n");
            break;
        }
        
        printf("Your location in the maze:\n");
        for(int i = 0; i < 5; ++i)
        {
            for(int j = 0; j < 5; ++j)
            {
                if(maze[i][j] == 0 || maze[i][j] == 'O' || maze[i][j] == 'E')
                {
                    printf("%c ", maze[i][j]);
                }
                else
                {
                    printf("%d ", maze[i][j]);
                }
            }
            printf("\n");
        }
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Fh] [rbp-91h] BYREF
  int v5[28]; // [rsp+30h] [rbp-90h]
  int v6; // [rsp+A0h] [rbp-20h]
  int v7; // [rsp+A4h] [rbp-1Ch]
  int m; // [rsp+A8h] [rbp-18h]
  int k; // [rsp+ACh] [rbp-14h]
  int j; // [rsp+B0h] [rbp-10h]
  int i; // [rsp+B4h] [rbp-Ch]
  int v12; // [rsp+B8h] [rbp-8h]
  int v13; // [rsp+BCh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Maze Route Finder Game!\n");
  printf("In this game, you will navigate through a maze by inputting your movements.\n");
  printf("The maze is represented by a 2D array, where 0 represents an open cell and 1 represents a wall.\n");
  printf("You are represented by the letter 'O', and the exit is represented by the letter 'E'.\n");
  v5[1] = 0;
  v5[2] = 1;
  v5[3] = 0;
  v5[4] = 1;
  v5[5] = 1;
  v5[6] = 0;
  v5[7] = 1;
  v5[8] = 0;
  v5[9] = 1;
  v5[10] = 0;
  v5[11] = 0;
  v5[12] = 0;
  v5[13] = 0;
  v5[14] = 1;
  v5[15] = 1;
  v5[16] = 1;
  v5[17] = 1;
  v5[18] = 0;
  v5[19] = 0;
  v5[20] = 1;
  v5[21] = 0;
  v5[22] = 0;
  v5[23] = 0;
  v13 = 0;
  v12 = 0;
  v7 = 4;
  v6 = 4;
  v5[0] = 79;
  v5[24] = 69;
  printf("Here is the maze:\n");
  for ( i = 0; i <= 4; ++i )
  {
    for ( j = 0; j <= 4; ++j )
    {
      if ( !v5[5 * i + j] || v5[5 * i + j] == 79 || v5[5 * i + j] == 69 )
        printf("%c ", (unsigned int)v5[5 * i + j]);
      else
        printf("%d ", (unsigned int)v5[5 * i + j]);
    }
    printf("\n");
  }
  while ( 1 )
  {
    printf("Enter your move: ");
    scanf(" %c", &v4);
    switch ( v4 )
    {
      case 'w':
        if ( v13 <= 0 || v5[5 * v13 - 5 + v12] )
          goto LABEL_31;
        v5[5 * v13-- + v12] = 0;
        v5[5 * v13 + v12] = 79;
        break;
      case 'a':
        if ( v12 <= 0 || v5[5 * v13 - 1 + v12] )
          goto LABEL_31;
        v5[5 * v13 + v12--] = 0;
        v5[5 * v13 + v12] = 79;
        break;
      case 's':
        if ( v13 > 3 || v5[5 * v13 + 5 + v12] )
          goto LABEL_31;
        v5[5 * v13++ + v12] = 0;
        v5[5 * v13 + v12] = 79;
        break;
      case 'd':
        if ( v12 > 3 || v5[5 * v13 + 1 + v12] )
        {
LABEL_31:
          printf("Invalid move! Try again.\n");
          break;
        }
        v5[5 * v13 + v12++] = 0;
        v5[5 * v13 + v12] = 79;
        break;
      default:
        printf("Invalid input! Try again.\n");
        break;
    }
    if ( v13 == v7 && v12 == v6 )
      break;
    printf("Your location in the maze:\n");
    for ( k = 0; k <= 4; ++k )
    {
      for ( m = 0; m <= 4; ++m )
      {
        if ( !v5[5 * k + m] || v5[5 * k + m] == 79 || v5[5 * k + m] == 69 )
          printf("%c ", (unsigned int)v5[5 * k + m]);
        else
          printf("%d ", (unsigned int)v5[5 * k + m]);
      }
      printf("\n");
    }
  }
  printf("Congratulations! You escaped the maze!\n");
  return 0;
}
// 140001D40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Arithmetic ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
   int num1, num2, operator, result, answer, correct = 0, incorrect = 0;
   time_t t;
   srand((unsigned) time(&t));

   for(int i = 0; i < 10; i++) {
      num1 = rand() % 100;
      num2 = rand() % 100;
      operator = rand() % 4;

      if(operator == 0) {
         printf("What is %d + %d? ", num1, num2);
         result = num1 + num2;
      } else if(operator == 1) {
         printf("What is %d - %d? ", num1, num2);
         result = num1 - num2;
      } else if(operator == 2) {
         printf("What is %d * %d? ", num1, num2);
         result = num1 * num2;
      } else if(operator == 3) {
         printf("What is %d / %d? ", num1, num2);
         result = num1 / num2;
      }

      scanf("%d", &answer);

      if(answer == result) {
         printf("Correct!\n");
         correct++;
      } else {
         printf("Incorrect!\n");
         incorrect++;
      }
   }

   printf("\nYou got %d questions correct and %d questions incorrect.\n", correct, incorrect);
   if(correct >= 7) {
      printf("Congratulations, you passed the arithmetic test!");
   } else {
      printf("Sorry, you did not pass the arithmetic test. Please try again.");
   }

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  time_t Time; // [rsp+28h] [rbp-28h] BYREF
  int v6; // [rsp+30h] [rbp-20h] BYREF
  int v7; // [rsp+34h] [rbp-1Ch]
  unsigned int v8; // [rsp+38h] [rbp-18h]
  unsigned int v9; // [rsp+3Ch] [rbp-14h]
  int i; // [rsp+40h] [rbp-10h]
  unsigned int v11; // [rsp+44h] [rbp-Ch]
  unsigned int v12; // [rsp+48h] [rbp-8h]
  int v13; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v12 = 0;
  v11 = 0;
  v3 = time(&Time);
  srand(v3);
  for ( i = 0; i <= 9; ++i )
  {
    v9 = rand() % 100;
    v8 = rand() % 100;
    v7 = rand() % 4;
    if ( v7 )
    {
      switch ( v7 )
      {
        case 1:
          printf("What is %d - %d? ", v9, v8);
          v13 = v9 - v8;
          break;
        case 2:
          printf("What is %d * %d? ", v9, v8);
          v13 = v8 * v9;
          break;
        case 3:
          printf("What is %d / %d? ", v9, v8);
          v13 = (int)v9 / (int)v8;
          break;
      }
    }
    else
    {
      printf("What is %d + %d? ", v9, v8);
      v13 = v9 + v8;
    }
    scanf("%d", &v6);
    if ( v13 == v6 )
    {
      printf("Correct!\n");
      ++v12;
    }
    else
    {
      printf("Incorrect!\n");
      ++v11;
    }
  }
  printf("\nYou got %d questions correct and %d questions incorrect.\n", v12, v11);
  if ( (int)v12 <= 6 )
    printf("Sorry, you did not pass the arithmetic test. Please try again.");
  else
    printf("Congratulations, you passed the arithmetic test!");
  return 0;
}
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Auction System ; Style: portable
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_BIDS 10
#define MAX_NAME_SIZE 20

typedef struct {
    char name[MAX_NAME_SIZE];
    int amount;
} Bid;

int main() {
    Bid bids[MAX_BIDS];
    int num_bids = 0, current_bid = 0;
    bool bidding_open = true;
    int highest_bid = 0;
    char winner[MAX_NAME_SIZE];

    printf("Welcome to the Digital Auction System!\n\n");
    printf("Bidding is now open.\n");

    while (bidding_open) {
        char name[MAX_NAME_SIZE];
        int amount;

        printf("Bid #%d, enter your name and amount (or 'q' to quit): ", current_bid + 1);
        scanf("%s", name);

        if (name[0] == 'q' && name[1] == '\0') {
            bidding_open = false;
            break;
        }

        scanf("%d", &amount);

        Bid new_bid = { .amount = amount };
        strncpy(new_bid.name, name, MAX_NAME_SIZE);

        if (amount <= highest_bid) {
            printf("Your bid must be higher than the current highest bid of %d.\n", highest_bid);
        } else if (num_bids == MAX_BIDS) {
            printf("Sorry, no more bids can be accepted.\n");
        } else {
            bids[num_bids++] = new_bid;
            highest_bid = amount;
            strncpy(winner, name, MAX_NAME_SIZE);
            printf("%s is currently the highest bidder with a bid of %d.\n", winner, highest_bid);
        }

        printf("\n");
        current_bid++;
    }

    printf("\nBidding is now closed. Here are the final bids:\n\n");

    for (int i = 0; i < num_bids; i++) {
        printf("%s: %d\n", bids[i].name, bids[i].amount);
    }

    printf("\nThe winner is %s with a bid of %d.\n", winner, highest_bid);
    printf("Thank you for using the Digital Auction System!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  _QWORD *v4; // rcx
  __int64 v5; // rdx
  char Destination[8]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v8; // [rsp+28h] [rbp-58h]
  __int64 v9; // [rsp+30h] [rbp-50h]
  int v10; // [rsp+3Ch] [rbp-44h] BYREF
  char Source[32]; // [rsp+40h] [rbp-40h] BYREF
  char v12[32]; // [rsp+60h] [rbp-20h] BYREF
  _QWORD v13[31]; // [rsp+80h] [rbp+0h] BYREF
  char v14; // [rsp+17Fh] [rbp+FFh]
  int i; // [rsp+180h] [rbp+100h]
  unsigned int v16; // [rsp+184h] [rbp+104h]
  int v17; // [rsp+188h] [rbp+108h]
  int v18; // [rsp+18Ch] [rbp+10Ch]

  _main(argc, argv, envp);
  v18 = 0;
  v17 = 0;
  v14 = 1;
  v16 = 0;
  printf("Welcome to the Digital Auction System!\n\n");
  printf("Bidding is now open.\n");
  while ( v14 )
  {
    printf("Bid #%d, enter your name and amount (or 'q' to quit): ", (unsigned int)(v17 + 1));
    scanf("%s", Source);
    if ( Source[0] == 113 && !Source[1] )
    {
      v14 = 0;
      break;
    }
    scanf("%d", &v10);
    *(_QWORD *)Destination = 0i64;
    v8 = 0i64;
    LODWORD(v9) = 0;
    HIDWORD(v9) = v10;
    strncpy(Destination, Source, 0x14ui64);
    if ( (int)v16 < v10 )
    {
      if ( v18 == 10 )
      {
        printf("Sorry, no more bids can be accepted.\n");
      }
      else
      {
        v3 = v18++;
        v4 = &v13[3 * v3];
        v5 = v8;
        *v4 = *(_QWORD *)Destination;
        v4[1] = v5;
        v4[2] = v9;
        v16 = v10;
        strncpy(v12, Source, 0x14ui64);
        printf("%s is currently the highest bidder with a bid of %d.\n", v12, v16);
      }
    }
    else
    {
      printf("Your bid must be higher than the current highest bid of %d.\n", v16);
    }
    printf("\n");
    ++v17;
  }
  printf("\nBidding is now closed. Here are the final bids:\n\n");
  for ( i = 0; i < v18; ++i )
    printf("%s: %d\n", (const char *)&v13[3 * i], HIDWORD(v13[3 * i + 2]));
  printf("\nThe winner is %s with a bid of %d.\n", v12, v16);
  printf("Thank you for using the Digital Auction System!\n");
  return 0;
}
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Banking Record System ; Style: random
#include <stdio.h>
#include <stdlib.h>

struct client {
    int id;
    char name[50];
    float balance;
};

void create_account(struct client *c) {
    printf("\nEnter client id: ");
    scanf("%d", &c->id);
    printf("Enter client name: ");
    scanf("%s", c->name);
    printf("Enter initial account balance: ");
    scanf("%f", &c->balance);
    printf("\nAccount successfully created!");
}

void withdraw(struct client *c) {
    float amount;
    printf("\nEnter amount to withdraw: ");
    scanf("%f", &amount);
    if (c->balance < amount) {
        printf("Insufficient balance!\n");
    } else {
        c->balance -= amount;
        printf("Transaction successful!\n");
    }
}

void deposit(struct client *c) {
    float amount;
    printf("\nEnter amount to deposit: ");
    scanf("%f", &amount);
    c->balance += amount;
    printf("Transaction successful!\n");
}

void display_balance(struct client *c) {
    printf("\nClient ID: %d\n", c->id);
    printf("Client Name: %s\n", c->name);
    printf("Account Balance: %.2f\n", c->balance);
}

int main() {
    int choice;
    struct client c;
    int account_created = 0;
    while (1) {
        printf("\n-- Bank Record System --\n");
        printf("1. Create Account\n");
        printf("2. Withdraw\n");
        printf("3. Deposit\n");
        printf("4. Display Balance\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                if (account_created) {
                    printf("\nAccount already created!\n");
                    break;
                }
                create_account(&c);
                account_created = 1;
                break;
            case 2:
                if (!account_created) {
                    printf("\nNo account found!\n");
                    break;
                }
                withdraw(&c);
                break;
            case 3:
                if (!account_created) {
                    printf("\nNo account found!\n");
                    break;
                }
                deposit(&c);
                break;
            case 4:
                if (!account_created) {
                    printf("\nNo account found!\n");
                    break;
                }
                display_balance(&c);
                break;
            case 5:
                printf("\nThank you for using our system!\n");
                exit(0);
            default:
                printf("\nInvalid choice!\n");
                break;
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall create_account(_QWORD); // weak
__int64 __fastcall withdraw(_QWORD); // weak
__int64 __fastcall deposit(_QWORD); // weak
__int64 __fastcall display_balance(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400017D7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[72]; // [rsp+20h] [rbp-50h] BYREF
  int v5; // [rsp+68h] [rbp-8h] BYREF
  int v6; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  while ( 1 )
  {
    printf("\n-- Bank Record System --\n");
    printf("1. Create Account\n");
    printf("2. Withdraw\n");
    printf("3. Deposit\n");
    printf("4. Display Balance\n");
    printf("5. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        if ( v6 )
        {
          printf("\nAccount already created!\n");
        }
        else
        {
          create_account(v4);
          v6 = 1;
        }
        continue;
      case 2:
        if ( !v6 )
          goto LABEL_12;
        withdraw(v4);
        break;
      case 3:
        if ( !v6 )
          goto LABEL_12;
        deposit(v4);
        break;
      case 4:
        if ( v6 )
          display_balance(v4);
        else
LABEL_12:
          printf("\nNo account found!\n");
        break;
      case 5:
        printf("\nThank you for using our system!\n");
        exit(0);
      default:
        printf("\nInvalid choice!\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 __fastcall create_account(_QWORD);
// 14000167B: using guessed type __int64 __fastcall withdraw(_QWORD);
// 140001701: using guessed type __int64 __fastcall deposit(_QWORD);
// 140001763: using guessed type __int64 __fastcall display_balance(_QWORD);
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Encryption ; Style: irregular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to encrypt the message
void encrypt(char *message, int key)
{
    int i;
    for(i = 0; i < strlen(message); i++)
    {
        if(i % 2 == 0)
        {
            message[i] = (message[i] + key) % 127;
        }
        else
        {
            message[i] = (message[i] - key) % 127;
        }
    }
}

// Function to decrypt the message
void decrypt(char *message, int key)
{
    int i;
    for(i = 0; i < strlen(message); i++)
    {
        if(i % 2 == 0)
        {
            message[i] = (message[i] - key) % 127;
        }
        else
        {
            message[i] = (message[i] + key) % 127;
        }
    }
}

int main()
{
    char message[1000];
    int key;
    printf("Enter message to encrypt: ");
    fgets(message, sizeof(message), stdin);
    printf("Enter key: ");
    scanf("%d", &key);
    
    // Encrypt the message
    encrypt(message, key);
    
    // Print the encrypted message
    printf("\nEncrypted message: ");
    for(int i=0; i<strlen(message); i++)
    {
        printf("%c", message[i]);
    }
    
    // Decrypt the message
    decrypt(message, key);
    
    // Print the decrypted message
    printf("\nDecrypted message: ");
    for(int i=0; i<strlen(message); i++)
    {
        printf("%c", message[i]);
    }
    printf("\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
__int64 __fastcall decrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400017C8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char Buffer[1000]; // [rsp+30h] [rbp-50h] BYREF
  int j; // [rsp+418h] [rbp+398h]
  int i; // [rsp+41Ch] [rbp+39Ch]

  _main(argc, argv, envp);
  printf("Enter message to encrypt: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  printf("Enter key: ");
  scanf("%d", &v5);
  encrypt(Buffer, v5);
  printf("\nEncrypted message: ");
  for ( i = 0; i < strlen(Buffer); ++i )
    printf("%c", (unsigned int)Buffer[i]);
  decrypt(Buffer, v5);
  printf("\nDecrypted message: ");
  for ( j = 0; j < strlen(Buffer); ++j )
    printf("%c", (unsigned int)Buffer[j]);
  printf("\n");
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 1400016D5: using guessed type __int64 __fastcall decrypt(_QWORD, _QWORD);
// 1400019E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400017C8: using guessed type char Buffer[1000];

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: inquisitive
#include <stdio.h>
#include <stdbool.h>

int main() {
    int num, i;
    bool isPrime;

    printf("Please enter a number to check if it's prime: ");
    scanf("%d", &num);

    // Two is the only even prime number
    if(num == 2) {
        isPrime = true;
    } else if(num < 2 || num%2 == 0) {
        // If number is less than 2 or is even, it's not prime
        isPrime = false;
    } else {
        isPrime = true;
        // Check odd divisors from 3 up to square root of number
        for(i = 3; i*i <= num; i += 2) {
            if(num%i == 0) {
                isPrime = false;
                break;
            }
        }
    }

    // Output the result
    if(isPrime) {
        printf("%d is a prime number\n", num);
    } else {
        printf("%d is not a prime number\n", num);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  char v5; // [rsp+2Bh] [rbp-5h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Please enter a number to check if it's prime: ");
  scanf("%d", &v4);
  if ( v4 == 2 )
  {
    v5 = 1;
  }
  else if ( v4 > 1 && (v4 & 1) != 0 )
  {
    v5 = 1;
    for ( i = 3; i * i <= v4; i += 2 )
    {
      if ( !(v4 % i) )
      {
        v5 = 0;
        break;
      }
    }
  }
  else
  {
    v5 = 0;
  }
  if ( v5 )
    printf("%d is a prime number\n", (unsigned int)v4);
  else
    printf("%d is not a prime number\n", (unsigned int)v4);
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type int var_C;

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text processing ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*function to replace all occurrences of a character in a string*/
char *replaceChar(char *str, char oldChar, char newChar) {
    int i;
    int len = strlen(str);
    /*iterate through the string*/
    for (i = 0; i < len; i++) {
        /*if a character in the string matches the oldChar, replace it with the newChar*/
        if (str[i] == oldChar) {
            str[i] = newChar;
        }
    }
    return str;
}

/*function to count the number of occurrences of a character in a string*/
int countChar(char *str, char ch) {
    int i;
    int count = 0;
    /*iterate through the string*/
    for (i = 0; str[i] != '\0'; i++) {
        /*if a character in the string matches the searched character, increment the count*/
        if (str[i] == ch) {
            count++;
        }
    }
    return count;
}

int main() {
    char str[100];
    char oldChar, newChar;
    printf("Enter a string: ");
    scanf("%[^\n]%*c", str); /*read input including spaces*/
    printf("Enter the character you want to replace: ");
    scanf("%c", &oldChar);
    printf("Enter the new character: ");
    scanf(" %c", &newChar); /*the space before %c is to consume the newline character*/
    
    /*replace all occurrences of the oldChar with newChar in the string*/
    char *newStr = replaceChar(str, oldChar, newChar);
    printf("String after replacing '%c' with '%c': %s\n", oldChar, newChar, newStr);
    
    /*count the number of occurrences of a character*/
    printf("Enter a character: ");
    char ch;
    scanf(" %c", &ch);
    int count = countChar(str, ch);
    printf("The character '%c' appears %d times in the string.\n", ch, count);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall replaceChar(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall countChar(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016A9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Dh] [rbp-73h] BYREF
  char v5; // [rsp+2Eh] [rbp-72h] BYREF
  char v6; // [rsp+2Fh] [rbp-71h] BYREF
  char v7[100]; // [rsp+30h] [rbp-70h] BYREF
  unsigned int v8; // [rsp+94h] [rbp-Ch]
  const char *v9; // [rsp+98h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a string: ");
  scanf("%[^\n]%*c", v7);
  printf("Enter the character you want to replace: ");
  scanf("%c", &v6);
  printf("Enter the new character: ");
  scanf(" %c", &v5);
  v9 = (const char *)replaceChar(v7, (unsigned int)v6, (unsigned int)v5);
  printf("String after replacing '%c' with '%c': %s\n", (unsigned int)v6, (unsigned int)v5, v9);
  printf("Enter a character: ");
  scanf(" %c", &v4);
  v8 = countChar(v7, (unsigned int)v4);
  printf("The character '%c' appears %d times in the string.\n", (unsigned int)v4, v8);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall replaceChar(_QWORD, _QWORD, _QWORD);
// 14000164E: using guessed type __int64 __fastcall countChar(_QWORD, _QWORD);
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define WIDTH 16
#define HEIGHT 16

void draw_pixel(char grid[WIDTH][HEIGHT], int x, int y, char color) {
  grid[x][y] = color;
}

void print_grid(char grid[WIDTH][HEIGHT]) {
  for (int y = 0; y < HEIGHT; y++) {
    for (int x = 0; x < WIDTH; x++) {
      printf("%c ", grid[x][y]);
    }
    printf("\n");
  }
}

int main() {
  char grid[WIDTH][HEIGHT];

  // Initialize grid to all white pixels
  for (int y = 0; y < HEIGHT; y++) {
    for (int x = 0; x < WIDTH; x++) {
      grid[x][y] = '.';
    }
  }

  // Randomly generate pixels
  srand(time(NULL));
  for (int i = 0; i < WIDTH * HEIGHT / 4; i++) {
    int x = rand() % WIDTH;
    int y = rand() % HEIGHT;
    char color = (rand() % 2 == 0) ? 'X' : 'O';
    draw_pixel(grid, x, y, color);
  }

  // Print the final grid
  print_grid(grid);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 __fastcall draw_pixel(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall print_grid(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001661) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v4; // al
  char v6[268]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v7; // [rsp+12Ch] [rbp+ACh]
  unsigned int v8; // [rsp+130h] [rbp+B0h]
  int k; // [rsp+134h] [rbp+B4h]
  int j; // [rsp+138h] [rbp+B8h]
  int i; // [rsp+13Ch] [rbp+BCh]

  _main(argc, argv, envp);
  for ( i = 0; i <= 15; ++i )
  {
    for ( j = 0; j <= 15; ++j )
      v6[16 * j + i] = 46;
  }
  v3 = time(0i64);
  srand(v3);
  for ( k = 0; k <= 63; ++k )
  {
    v8 = rand() % 16;
    v7 = rand() % 16;
    if ( (rand() & 1) != 0 )
      v4 = 79;
    else
      v4 = 88;
    v6[267] = v4;
    draw_pixel(v6, v8, v7, (unsigned int)v4);
  }
  print_grid(v6);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall draw_pixel(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400015E8: using guessed type __int64 __fastcall print_grid(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Auction System ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//Struct for the item being auctioned
struct Item {
    char name[50];
    int current_bid;
    int bid_count;
    char highest_bidder[50];
};

//Function to update the current bid of the item
void update_bid(struct Item *item, int bid, char bidder[]) {
    if (bid > item->current_bid) {
        item->current_bid = bid;
        strcpy(item->highest_bidder, bidder);
        item->bid_count++;
        printf("Bid successfully placed by %s for %d\n", bidder, bid);
    } else {
        printf("Bid should be higher than current bid of %d\n", item->current_bid);
    }
}

int main() {
    //Array of items being auctioned
    struct Item items[5];

    //Initializing each item with a name and initial bid of $10
    strcpy(items[0].name, "Painting");
    items[0].current_bid = 10;
    items[0].bid_count = 0;

    strcpy(items[1].name, "Antique vase");
    items[1].current_bid = 10;
    items[1].bid_count = 0;

    strcpy(items[2].name, "Gold watch");
    items[2].current_bid = 10;
    items[2].bid_count = 0;

    strcpy(items[3].name, "Signed baseball");
    items[3].current_bid = 10;
    items[3].bid_count = 0;

    strcpy(items[4].name, "Rare stamp collection");
    items[4].current_bid = 10;
    items[4].bid_count = 0;

    //Displaying the items being auctioned
    printf("Items being auctioned:\n");
    for (int i = 0; i < 5; i++) {
        printf("%d. %s - Current bid: $%d\n", i+1, items[i].name, items[i].current_bid);
    }

    //Starting the auction
    int item_choice, bid;
    char bidder[50];

    while (1) {
        //Asking for item choice and bid amount
        printf("Enter item number to bid on (0 to exit): ");
        scanf("%d", &item_choice);

        if (item_choice == 0) {
            break;
        }

        printf("Enter bid amount: $");
        scanf("%d", &bid);

        printf("Enter bidder name: ");
        scanf("%s", bidder);

        //Making sure the item being bid on exists
        if (item_choice < 1 || item_choice > 5) {
            printf("Invalid item number\n");
            continue;
        }

        //Updating the bid for the selected item
        update_bid(&items[item_choice-1], bid, bidder);
    }

    //Displaying the results of the auction
    printf("Results of auction:\n");
    for (int i = 0; i < 5; i++) {
        printf("%s - Highest bid: $%d (by %s), number of bids: %d\n", items[i].name, items[i].current_bid, items[i].highest_bidder, items[i].bid_count);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall update_bid(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000166D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // r8
  __int64 v5; // [rsp+20h] [rbp-60h]
  char v6[56]; // [rsp+30h] [rbp-50h] BYREF
  unsigned int v7; // [rsp+68h] [rbp-18h] BYREF
  int v8; // [rsp+6Ch] [rbp-14h] BYREF
  char v9[16]; // [rsp+70h] [rbp-10h] BYREF
  _DWORD v10[24]; // [rsp+80h] [rbp+0h] BYREF
  char v11[16]; // [rsp+E0h] [rbp+60h] BYREF
  int v12; // [rsp+114h] [rbp+94h]
  int v13; // [rsp+118h] [rbp+98h]
  char v14[16]; // [rsp+150h] [rbp+D0h] BYREF
  int v15; // [rsp+184h] [rbp+104h]
  int v16; // [rsp+188h] [rbp+108h]
  char v17[16]; // [rsp+1C0h] [rbp+140h] BYREF
  int v18; // [rsp+1F4h] [rbp+174h]
  int v19; // [rsp+1F8h] [rbp+178h]
  char v20[24]; // [rsp+230h] [rbp+1B0h] BYREF
  int v21; // [rsp+264h] [rbp+1E4h]
  int v22; // [rsp+268h] [rbp+1E8h]
  int j; // [rsp+2A8h] [rbp+228h]
  int i; // [rsp+2ACh] [rbp+22Ch]

  _main(argc, argv, envp);
  strcpy(v9, "Painting");
  v10[9] = 10;
  v10[10] = 0;
  strcpy(v11, "Antique vase");
  v12 = 10;
  v13 = 0;
  strcpy(v14, "Gold watch");
  v15 = 10;
  v16 = 0;
  strcpy(v17, "Signed baseball");
  v18 = 10;
  v19 = 0;
  strcpy(v20, "Rare stamp collection");
  v21 = 10;
  v22 = 0;
  printf("Items being auctioned:\n");
  for ( i = 0; i <= 4; ++i )
    printf("%d. %s - Current bid: $%d\n", (unsigned int)(i + 1), &v9[112 * i], (unsigned int)v10[28 * i + 9]);
  while ( 1 )
  {
    printf("Enter item number to bid on (0 to exit): ");
    scanf("%d", &v8);
    if ( !v8 )
      break;
    printf("Enter bid amount: $");
    scanf("%d", &v7);
    printf("Enter bidder name: ");
    scanf("%s", v6);
    if ( v8 > 0 && v8 <= 5 )
      update_bid(&v9[112 * v8 - 112], v7, v6);
    else
      printf("Invalid item number\n");
  }
  printf("Results of auction:\n");
  for ( j = 0; j <= 4; ++j )
  {
    v3 = (unsigned int)v10[28 * j + 9];
    LODWORD(v5) = v10[28 * j + 10];
    printf("%s - Highest bid: $%d (by %s), number of bids: %d\n", &v9[112 * j], v3, &v9[112 * j + 60], v5);
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall update_bid(_QWORD, _QWORD, _QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedurally Generated Maze ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 20
#define COLS 20

void generateMaze(int maze[][COLS], int startX, int startY);
void displayMaze(int maze[][COLS]);

int main(void)
{
    int maze[ROWS][COLS];
    int startX = 1;
    int startY = 1;
    
    srand(time(NULL)); // Use current time as seed for random generator
    
    generateMaze(maze, startX, startY);
    displayMaze(maze);
    
    return 0;
}

// Generate a maze using a random Prim's algorithm
void generateMaze(int maze[][COLS], int startX, int startY)
{
    // Initialize maze
    for (int i = 0; i < ROWS; i++)
    {
        for (int j = 0; j < COLS; j++)
        {
            maze[i][j] = 1; // 1 represents a wall
        }
    }
    
    maze[startX][startY] = 0; // Set starting point as path
    
    // Perform Prim's algorithm to create maze
    int frontier[ROWS*COLS][2];
    int numFrontier = 0;
    
    // Add surrounding cells of starting point to frontier
    if (startX+1 < ROWS && maze[startX+1][startY] == 1) // Down
    {
        frontier[numFrontier][0] = startX+1;
        frontier[numFrontier][1] = startY;
        numFrontier++;
    }
    if (startX-1 >= 0 && maze[startX-1][startY] == 1) // Up
    {
        frontier[numFrontier][0] = startX-1;
        frontier[numFrontier][1] = startY;
        numFrontier++;
    }
    if (startY+1 < COLS && maze[startX][startY+1] == 1) // Right
    {
        frontier[numFrontier][0] = startX;
        frontier[numFrontier][1] = startY+1;
        numFrontier++;
    }
    if (startY-1 >= 0 && maze[startX][startY-1] == 1) // Left
    {
        frontier[numFrontier][0] = startX;
        frontier[numFrontier][1] = startY-1;
        numFrontier++;
    }
    
    while (numFrontier > 0)
    {
        // Choose a random frontier cell
        int randIndex = rand() % numFrontier;
        int x = frontier[randIndex][0];
        int y = frontier[randIndex][1];
        
        // Get neighboring walls
        int walls[4][2] = {{x+1, y}, {x-1, y}, {x, y+1}, {x, y-1}};
        int numWalls = 0;
        
        for (int i = 0; i < 4; i++)
        {
            int wallX = walls[i][0];
            int wallY = walls[i][1];
            
            if (wallX >= 0 && wallX < ROWS && wallY >= 0 && wallY < COLS && maze[wallX][wallY] == 1)
            {
                walls[numWalls][0] = wallX;
                walls[numWalls][1] = wallY;
                numWalls++;
            }
        }
        
        // Choose a random wall and break it
        if (numWalls > 0)
        {
            int randIndex = rand() % numWalls;
            int wallX = walls[randIndex][0];
            int wallY = walls[randIndex][1];
            
            maze[wallX][wallY] = 0; // Set wall as path
            
            // Add surrounding cells of wall to frontier
            if (wallX+1 < ROWS && maze[wallX+1][wallY] == 1) // Down
            {
                frontier[numFrontier][0] = wallX+1;
                frontier[numFrontier][1] = wallY;
                numFrontier++;
            }
            if (wallX-1 >= 0 && maze[wallX-1][wallY] == 1) // Up
            {
                frontier[numFrontier][0] = wallX-1;
                frontier[numFrontier][1] = wallY;
                numFrontier++;
            }
            if (wallY+1 < COLS && maze[wallX][wallY+1] == 1) // Right
            {
                frontier[numFrontier][0] = wallX;
                frontier[numFrontier][1] = wallY+1;
                numFrontier++;
            }
            if (wallY-1 >= 0 && maze[wallX][wallY-1] == 1) // Left
            {
                frontier[numFrontier][0] = wallX;
                frontier[numFrontier][1] = wallY-1;
                numFrontier++;
            }
        }
        
        // Delete random frontier cell
        frontier[randIndex][0] = frontier[numFrontier-1][0];
        frontier[randIndex][1] = frontier[numFrontier-1][1];
        numFrontier--;
    }
}

// Display maze in console using ASCII characters
void displayMaze(int maze[][COLS])
{
    for (int i = 0; i < ROWS; i++)
    {
        for (int j = 0; j < COLS; j++)
        {
            if (maze[i][j] == 0) // 0 represents a path
            {
                printf(" ");
            }
            else
            {
                printf("#");
            }
        }
        
        printf("\n");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall generateMaze(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall displayMaze(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[1608]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v6; // [rsp+668h] [rbp+5E8h]
  unsigned int v7; // [rsp+66Ch] [rbp+5ECh]

  _main(argc, argv, envp);
  v7 = 1;
  v6 = 1;
  v3 = time(0i64);
  srand(v3);
  generateMaze(v5, v7, v6);
  displayMaze(v5);
  return 0;
}
// 14000161F: using guessed type __int64 __fastcall generateMaze(_QWORD, _QWORD, _QWORD);
// 140001C8D: using guessed type __int64 __fastcall displayMaze(_QWORD);
// 140001DD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Huffman Coding Implementation ; Style: artistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CHARS 256

// A node of Huffman tree 
struct Node {
    int freq;
    char data;
    struct Node *left;
    struct Node *right;
};

// Priority queue node 
struct PQNode {
    struct Node *data;
    struct PQNode *next;
};

// The priority queue 
struct PriorityQueue {
    struct PQNode *head;
};

// Initialize the priority queue 
struct PriorityQueue* initializePriorityQueue() {
    struct PriorityQueue* pq = (struct PriorityQueue*) malloc(sizeof(struct PriorityQueue));
    pq->head = NULL;
    return pq;
}

// Insert a node into the priority queue 
void insert(struct PriorityQueue* pq, struct Node *node) {
    struct PQNode *newPQNode = (struct PQNode*) malloc(sizeof(struct PQNode));
    newPQNode->next = NULL;
    newPQNode->data = node;
    if (pq->head == NULL) {
        pq->head = newPQNode;
    }
    else if(newPQNode->data->freq <= pq->head->data->freq){
        newPQNode->next = pq->head;
        pq->head = newPQNode;
    }
    else{
        struct PQNode *curr = pq->head;
        while(curr->next!=NULL && curr->next->data->freq <= newPQNode->data->freq) {
            curr = curr->next;
        }
        newPQNode->next = curr->next;
        curr->next = newPQNode;
    }
}

// Get the minimum node from the priority queue 
struct Node* getMin(struct PriorityQueue* pq) {
    struct Node* temp = pq->head->data;
    pq->head = pq->head->next;
    return temp;
}

// Check if the node is a leaf node 
int isLeaf(struct Node* node) {
    return node->left == NULL && node->right == NULL;
}

// Traverse the tree and build the huffman code 
void encode(struct Node* node, char *arr, int top, char **codes) {
    if (node->left) {
        arr[top] = '0';
        encode(node->left, arr, top + 1, codes);
    }
    if (node->right) {
        arr[top] = '1';
        encode(node->right, arr, top + 1, codes);
    }
    if (isLeaf(node)) {
        arr[top] = '\0';
        char *temp = (char*) malloc(sizeof(char) * CHARS);
        strcpy(temp,arr);
        codes[(int)node->data] = temp;
    }
}

// Build the Huffman tree 
struct Node* buildHuffmanTree(int freqs[]) {
    struct PriorityQueue* pq = initializePriorityQueue();
    for (int i = 0; i < CHARS; ++i) {
        if (freqs[i] != 0) {
            struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
            newNode->left = newNode->right = NULL;
            newNode->data = (char) i;
            newNode->freq = freqs[i];
            insert(pq, newNode);
        }
    }
    while (pq->head->next) {
        struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
        newNode->left = getMin(pq);
        newNode->right = getMin(pq);
        newNode->data = '\0';
        newNode->freq = newNode->left->freq + newNode->right->freq;
        insert(pq, newNode);
    }
    return getMin(pq);
}

// Huffman code generation 
char ** generateCodes(int freqs[]) {
    char arr[CHARS];
    char **codes = (char**) malloc(sizeof(char*) * CHARS);
    for (int i = 0; i < CHARS; i++) {
        codes[i] = NULL;
    }
    struct Node* root = buildHuffmanTree(freqs);
    encode(root, arr, 0, codes);
    return codes;
}

// Encode a string using the Huffman codes 
void encodeString(char **codes, char *input, char *output) {
    int i = 0;
    while(input[i]!='\0'){
        strcat(output,codes[(int)input[i++]]);
    }
}

// Decode a string using the Huffman codes 
void decodeString(struct Node* root, char *input, char *output) {
    struct Node* curr = root;
    for (int i = 0; input[i]!='\0'; i++) {
        if (input[i] == '0') {
            curr = curr->left;
        }
        else {
            curr = curr->right;
        }
        if (isLeaf(curr)) {
            strncat(output,&curr->data,1);
            curr = root;
        }
    }
}

// Main function 
int main() {
    char input[CHARS], output[CHARS];
    int freqs[CHARS];
    for(int i=0;i<CHARS;i++){
        freqs[i]=0;
    }
    printf("Enter the input string: ");
    scanf("%[^\n]s", input);
    for(int i=0;i<strlen(input);i++){
        freqs[(int)input[i]]++;
    }
    char **codes = generateCodes(freqs);
    encodeString(codes,input,output);
    printf("\nHuffman Encoded Output: %s\n", output);
    decodeString(buildHuffmanTree(freqs),output,output);
    printf("\nDecoded Output: %s\n", output);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall buildHuffmanTree(_QWORD); // weak
__int64 __fastcall generateCodes(_QWORD); // weak
__int64 __fastcall encodeString(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall decodeString(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (0000000140001B56) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rax
  int v5[256]; // [rsp+20h] [rbp-60h] BYREF
  char v6[256]; // [rsp+420h] [rbp+3A0h] BYREF
  char Str[256]; // [rsp+520h] [rbp+4A0h] BYREF
  __int64 Codes; // [rsp+620h] [rbp+5A0h]
  int j; // [rsp+628h] [rbp+5A8h]
  int i; // [rsp+62Ch] [rbp+5ACh]

  _main(argc, argv, envp);
  for ( i = 0; i <= 255; ++i )
    v5[i] = 0;
  printf("Enter the input string: ");
  scanf("%[^\n]s", Str);
  for ( j = 0; j < strlen(Str); ++j )
    ++v5[Str[j]];
  Codes = generateCodes(v5);
  encodeString(Codes, Str, v6);
  printf("\nHuffman Encoded Output: %s\n", v6);
  v3 = buildHuffmanTree(v5);
  decodeString(v3, v6, v6);
  printf("\nDecoded Output: %s\n", v6);
  return 0;
}
// 140001856: using guessed type __int64 __fastcall buildHuffmanTree(_QWORD);
// 140001992: using guessed type __int64 __fastcall generateCodes(_QWORD);
// 140001A40: using guessed type __int64 __fastcall encodeString(_QWORD, _QWORD, _QWORD);
// 140001AB1: using guessed type __int64 __fastcall decodeString(_QWORD, _QWORD, _QWORD);
// 140001D70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001B56: using guessed type int var_620[256];
// 140001B56: using guessed type char Str[256];

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game ; Style: portable
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int number, guess, attempts = 0;
    srand(time(0));
    number = rand() % 100 + 1;
    printf("Welcome to Guess the Number Game!\n");
    printf("Guess a number between 1 to 100\n");

    do {
        scanf("%d", &guess);
        attempts++;
        if (guess > number) {
            printf("Lower number please!\n");
        }
        else if (guess < number) {
            printf("Higher number please!\n");
        }
        else {
            printf("Congratulations! You guessed it in %d attempts\n", attempts);
        }
    } while (guess != number);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  int v6; // [rsp+28h] [rbp-8h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 0;
  v3 = time(0i64);
  srand(v3);
  v6 = rand() % 100 + 1;
  printf("Welcome to Guess the Number Game!\n");
  printf("Guess a number between 1 to 100\n");
  do
  {
    scanf("%d", &v5);
    ++v7;
    if ( v6 >= v5 )
    {
      if ( v6 <= v5 )
        printf("Congratulations! You guessed it in %d attempts\n", v7);
      else
        printf("Higher number please!\n");
    }
    else
    {
      printf("Lower number please!\n");
    }
  }
  while ( v6 != v5 );
  return 0;
}
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Music Library Management System ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Define constants */
#define MAX_LENGTH 100
#define MAX_SONGS 100

/* Define functions */
void display_menu();
void add_song();
void delete_song();
void search_song();
void display_songs();

/* Define structures */
struct Song {
    char title[MAX_LENGTH];
    char artist[MAX_LENGTH];
    char genre[MAX_LENGTH];
    int year;
};

/* Declare global variables */
struct Song music_library[MAX_SONGS];
int num_songs = 0;

int main() {
    display_menu();
    return 0;
}

void display_menu() {
    int option = 0;

    do {
        printf("Music Library Management System\n");
        printf("-------------------------------\n");
        printf("1. Add Song\n");
        printf("2. Delete Song\n");
        printf("3. Search Song\n");
        printf("4. Display Songs\n");
        printf("5. Exit\n");

        printf("Enter your choice: ");
        scanf("%d", &option);

        switch (option) {
            case 1:
                add_song();
                break;
            case 2:
                delete_song();
                break;
            case 3:
                search_song();
                break;
            case 4:
                display_songs();
                break;
            case 5:
                printf("Exiting program...\n");
                break;
            default:
                printf("Invalid option. Please try again.\n");

        }
    } while (option != 5);

}

void add_song() {
    printf("Enter the song title: ");
    scanf("%s", music_library[num_songs].title);

    printf("Enter the artist name: ");
    scanf("%s", music_library[num_songs].artist);

    printf("Enter the genre: ");
    scanf("%s", music_library[num_songs].genre);

    printf("Enter the year the song was released: ");
    scanf("%d", &music_library[num_songs].year);

    printf("Song successfully added!\n");

    num_songs++;
}

void delete_song() {
    int i, j;
    char title[MAX_LENGTH];

    printf("Enter the title of the song you want to delete: ");
    scanf("%s", title);

    for (i = 0; i < num_songs; i++) {
        if (strcmp(music_library[i].title, title) == 0) {
            for (j = i; j < num_songs - 1; j++) {
                music_library[j] = music_library[j + 1];
            }

            num_songs--;
            printf("Song successfully deleted!\n");
            return;
        }
    }

    printf("Song not found. Please try again.\n");
}

void search_song() {
    int i;
    char title[MAX_LENGTH];

    printf("Enter the title of the song you want to search: ");
    scanf("%s", title);

    for (i = 0; i < num_songs; i++) {
        if (strcmp(music_library[i].title, title) == 0) {
            printf("Song title: %s\n", music_library[i].title);
            printf("Artist name: %s\n", music_library[i].artist);
            printf("Genre: %s\n", music_library[i].genre);
            printf("Year released: %d\n", music_library[i].year);
            return;
        }
    }

    printf("Song not found. Please try again.\n");
}

void display_songs() {
    int i;

    printf("Song List\n");
    printf("---------\n");

    for (i = 0; i < num_songs; i++) {
        printf("Song title: %s\n", music_library[i].title);
        printf("Artist name: %s\n", music_library[i].artist);
        printf("Genre: %s\n", music_library[i].genre);
        printf("Year released: %d\n\n", music_library[i].year);
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 display_menu(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  display_menu();
  return 0;
}
// 1400015FF: using guessed type __int64 display_menu(void);
// 140001D40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data mining ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Define a custom data structure for storing surreal numbers
typedef struct surreal_number {
    double real_part;
    double imaginary_part;
} surreal_number;

// Define a custom data structure for storing data mining results
typedef struct data_mining_result {
    surreal_number max_value;
    surreal_number min_value;
    surreal_number average_value;
} data_mining_result;

// Define a function to generate surreal numbers randomly
surreal_number generate_surreal_number() {
    surreal_number number;
    number.real_part = (double)rand() / (double)RAND_MAX;
    number.imaginary_part = (double)rand() / (double)RAND_MAX;
    return number;
}

// Define a function to check whether a surreal number is positive
bool is_positive(surreal_number number) {
    return (number.real_part > 0 || number.imaginary_part > 0);
}

// Define a function to perform data mining on an array of surreal numbers
data_mining_result perform_data_mining(surreal_number* numbers, int length) {
    data_mining_result result;
    surreal_number sum = {0, 0};
    result.max_value = numbers[0];
    result.min_value = numbers[0];
    for (int i = 0; i < length; i++) {
        if (is_positive(numbers[i])) {
            if (numbers[i].real_part > result.max_value.real_part || numbers[i].imaginary_part > result.max_value.imaginary_part) {
                result.max_value = numbers[i];
            }
            if (numbers[i].real_part < result.min_value.real_part && numbers[i].imaginary_part < result.min_value.imaginary_part) {
                result.min_value = numbers[i];
            }
            sum.real_part += numbers[i].real_part;
            sum.imaginary_part += numbers[i].imaginary_part;
        }
    }
    result.average_value.real_part = sum.real_part / length;
    result.average_value.imaginary_part = sum.imaginary_part / length;
    return result;
}

int main() {
    int length = 10;
    surreal_number numbers[length];
    srand(time(NULL));
    for (int i = 0; i < length; i++) {
        numbers[i] = generate_surreal_number();
        printf("Generated surreal number: %lf + %lfi\n", numbers[i].real_part, numbers[i].imaginary_part);
    }
    data_mining_result result = perform_data_mining(numbers, length);
    printf("\nData mining result:\n");
    printf("Max value: %lf + %lfi\n", result.max_value.real_part, result.max_value.imaginary_part);
    printf("Min value: %lf + %lfi\n", result.min_value.real_part, result.min_value.imaginary_part);
    printf("Average value: %lf + %lfi\n", result.average_value.real_part, result.average_value.imaginary_part);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall generate_surreal_number(_QWORD); // weak
__int64 __fastcall perform_data_mining(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// static time_t __cdecl time(time_t *const Time);
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001876) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  unsigned int v4; // eax
  __int64 *v5; // rbx
  __int64 v6; // rdx
  __int64 v8[2]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v9[7]; // [rsp+30h] [rbp-50h] BYREF
  __int64 *v10; // [rsp+68h] [rbp-18h]
  __int64 v11; // [rsp+70h] [rbp-10h]
  unsigned int v12; // [rsp+78h] [rbp-8h]
  int i; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  v12 = 10;
  v11 = 9i64;
  v3 = alloca(160i64);
  v10 = v8;
  v4 = time(0i64);
  srand(v4);
  for ( i = 0; i < (int)v12; ++i )
  {
    v5 = &v10[2 * i];
    generate_surreal_number(v8);
    v6 = v8[1];
    *v5 = v8[0];
    v5[1] = v6;
    printf("Generated surreal number: %lf + %lfi\n", v10[2 * i], v10[2 * i + 1]);
  }
  perform_data_mining(v9, v10, v12);
  printf("\nData mining result:\n");
  printf("Max value: %lf + %lfi\n", v9[0], v9[1]);
  printf("Min value: %lf + %lfi\n", v9[2], v9[3]);
  printf("Average value: %lf + %lfi\n", v9[4], v9[5]);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall generate_surreal_number(_QWORD);
// 140001647: using guessed type __int64 __fastcall perform_data_mining(_QWORD, _QWORD, _QWORD);
// 140001B70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Hotel Management System ; Style: interoperable
#include<stdio.h>
#include<string.h>

// Structure for storing Reservation Details
struct Reservation {
    char name[50];
    char room_type[20];
    int num_guests;
    int num_nights;
    float cost;
};

// Structure for storing Room Details
struct Room {
    char room_type[20];
    int num_available;
    float cost_per_night;
};

// Function to display Room Details
void display_rooms(struct Room rooms[], int num_rooms) {
    printf("\n--------------------------------------------------------\n");
    printf("| %-15s | %-15s | %-15s |\n", "Room Type", "Available Rooms", "Cost per Night");
    printf("--------------------------------------------------------\n");
    for(int i=0; i<num_rooms; i++) {
        printf("| %-15s | %-15d | %-15.2f |\n", rooms[i].room_type, rooms[i].num_available, rooms[i].cost_per_night);
    }
    printf("--------------------------------------------------------\n");
}

// Function to make Reservation
void make_reservation(struct Room rooms[], int num_rooms, struct Reservation reservations[], int *num_reservations) {
    char room_type[20];
    int num_guests, num_nights, room_index=-1;
    float cost;
    struct Reservation reservation;
    printf("\nEnter your name: ");
    scanf("%s", reservation.name);
    printf("\nEnter number of guests: ");
    scanf("%d", &reservation.num_guests);
    printf("\nEnter number of nights: ");
    scanf("%d", &reservation.num_nights);
    printf("\nEnter room type (Standard/Deluxe/Suite): ");
    scanf("%s", room_type);
    for(int i=0; i<num_rooms; i++) {
        if(strcmp(rooms[i].room_type, room_type) == 0 && rooms[i].num_available > 0) {
            room_index = i;
            rooms[i].num_available--;
            cost = reservations[*num_reservations].num_nights * rooms[i].cost_per_night;
            break;
        }
    }
    if(room_index == -1) {
        printf("\nSorry, %s rooms are not available.\n", room_type);
    } else {
        reservation.cost = cost;
        strcpy(reservation.room_type, room_type);
        reservations[*num_reservations] = reservation;
        (*num_reservations)++;
        printf("\nYour reservation has been successfully made.\n");
    }
}

// Function to display Reservation Details
void display_reservations(struct Reservation reservations[], int num_reservations) {
    printf("\n------------------------------------------------------------------------\n");
    printf("| %-30s | %-20s | %-15s | %-10s |\n", "Name", "Room Type", "Number of Nights", "Cost");
    printf("------------------------------------------------------------------------\n");
    for(int i=0; i<num_reservations; i++) {
        printf("| %-30s | %-20s | %-15d | %-10.2f |\n", reservations[i].name, reservations[i].room_type, reservations[i].num_nights, reservations[i].cost);
    }
    printf("------------------------------------------------------------------------\n");
}

// Function to cancel Reservation
void cancel_reservation(struct Room rooms[], int num_rooms, struct Reservation reservations[], int *num_reservations) {
    char name[50];
    int reservation_index=-1;
    printf("\nEnter your name: ");
    scanf("%s", name);
    for(int i=0; i<*num_reservations; i++) {
        if(strcmp(reservations[i].name, name) == 0) {
            reservation_index = i;
            for(int j=0; j<num_rooms; j++) {
                if(strcmp(rooms[j].room_type, reservations[i].room_type) == 0) {
                    rooms[j].num_available++;
                    break;
                }
            }
            break;
        }
    }
    if(reservation_index == -1) {
        printf("\nSorry, no reservation found under %s.\n", name);
    } else {
        for(int i=reservation_index+1; i<*num_reservations; i++) {
            reservations[i-1] = reservations[i];
        }
        (*num_reservations)--;
        printf("\nYour reservation has been successfully cancelled.\n");
    }
}

// Function to display available options
void display_options() {
    printf("\n*************************************************************\n");
    printf("                            OPTIONS\n");
    printf("*************************************************************\n");
    printf("1. Display Available Rooms\n");
    printf("2. Make a Reservation\n");
    printf("3. Display Reservations\n");
    printf("4. Cancel a Reservation\n");
    printf("5. Exit\n");
}

int main() {
    int num_rooms = 3;
    int num_reservations = 0;
    struct Room rooms[3] = {{"Standard", 5, 1000.00}, {"Deluxe", 3, 1500.00}, {"Suite", 2, 2200.00}};
    struct Reservation reservations[10];

    printf("\n*************************************************************\n");
    printf("               C HOTEL MANAGEMENT SYSTEM\n");
    printf("*************************************************************\n");

    int option;
    do {
        display_options();
        printf("\nEnter your option: ");
        scanf("%d", &option);
        switch(option) {
            case 1:
                display_rooms(rooms, num_rooms);
                break;
            case 2:
                make_reservation(rooms, num_rooms, reservations, &num_reservations);
                break;
            case 3:
                display_reservations(reservations, num_reservations);
                break;
            case 4:
                cancel_reservation(rooms, num_rooms, reservations, &num_reservations);
                break;
            case 5:
                printf("\nThank you for using C Hotel Management System!\n");
                break;
            default:
                printf("\nInvalid option. Please try again.\n");
        }
    } while(option != 5);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall display_rooms(_QWORD, _QWORD); // weak
__int64 __fastcall make_reservation(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall display_reservations(_QWORD, _QWORD); // weak
__int64 __fastcall cancel_reservation(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 display_options(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001DC8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-54h] BYREF
  char v5[848]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v6[2]; // [rsp+380h] [rbp+300h] BYREF
  int v7; // [rsp+390h] [rbp+310h]
  int v8; // [rsp+394h] [rbp+314h]
  int v9; // [rsp+398h] [rbp+318h]
  __int64 v10; // [rsp+39Ch] [rbp+31Ch]
  __int64 v11; // [rsp+3A4h] [rbp+324h]
  int v12; // [rsp+3ACh] [rbp+32Ch]
  int v13; // [rsp+3B0h] [rbp+330h]
  int v14; // [rsp+3B4h] [rbp+334h]
  __int64 v15; // [rsp+3B8h] [rbp+338h]
  __int64 v16; // [rsp+3C0h] [rbp+340h]
  int v17; // [rsp+3C8h] [rbp+348h]
  int v18; // [rsp+3CCh] [rbp+34Ch]
  int v19; // [rsp+3D0h] [rbp+350h]
  unsigned int v20; // [rsp+3D8h] [rbp+358h] BYREF
  unsigned int v21; // [rsp+3DCh] [rbp+35Ch]

  _main(argc, argv, envp);
  v21 = 3;
  v20 = 0;
  v6[0] = 0x647261646E617453i64;
  v6[1] = 0i64;
  v7 = 0;
  v8 = 5;
  v9 = 1148846080;
  v10 = 0x6578756C6544i64;
  v11 = 0i64;
  v12 = 0;
  v13 = 3;
  v14 = 1153138688;
  v15 = 0x6574697553i64;
  v16 = 0i64;
  v17 = 0;
  v18 = 2;
  v19 = 1158250496;
  printf("\n*************************************************************\n");
  printf("               C HOTEL MANAGEMENT SYSTEM\n");
  printf("*************************************************************\n");
  do
  {
    display_options();
    printf("\nEnter your option: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        display_rooms(v6, v21);
        break;
      case 2:
        make_reservation(v6, v21, v5, &v20);
        break;
      case 3:
        display_reservations(v5, v20);
        break;
      case 4:
        cancel_reservation(v6, v21, v5, &v20);
        break;
      case 5:
        printf("\nThank you for using C Hotel Management System!\n");
        break;
      default:
        printf("\nInvalid option. Please try again.\n");
        break;
    }
  }
  while ( v4 != 5 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall display_rooms(_QWORD, _QWORD);
// 1400016F7: using guessed type __int64 __fastcall make_reservation(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400019A7: using guessed type __int64 __fastcall display_reservations(_QWORD, _QWORD);
// 140001AF8: using guessed type __int64 __fastcall cancel_reservation(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001D41: using guessed type __int64 display_options(void);
// 1400020B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: HTML beautifier ; Style: excited
#include <stdio.h>
#include <stdbool.h>

int main() {
    bool tags = false; // Are we currently in an HTML tag?
    int indent_level = 0; // How many tabs should we indent with?
    char current_char; // The current character being processed
    FILE *input_file = fopen("index.html", "r"); // Open the input file
    FILE *output_file = fopen("beautified.html", "w"); // Open the output file

    // Loop through the input file, processing each character
    while ((current_char = fgetc(input_file)) != EOF) {
        // Is the current character a < tag?
        if (current_char == '<') {
            tags = true; // We're in a tag now!
            fputc(current_char, output_file); // Write the < to the output file
            fputc('\n', output_file); // Start the next line
            indent_level++; // Indent the next line
            for (int i = 0; i < indent_level; i++) {
                fputc('\t', output_file); // Indent with tabs
            }
        }
        // Is the current character a > tag?
        else if (current_char == '>') {
            tags = false; // We're out of the tag
            fputc(current_char, output_file); // Write the > to the output file
            fputc('\n', output_file); // Start the next line
        }
        // Is the current character a newline?
        else if (current_char == '\n') {
            if (tags) {
                fputc(current_char, output_file); // Write the newline to the output file
                for (int i = 0; i < indent_level; i++) {
                    fputc('\t', output_file); // Indent with tabs
                }
            }
            else {
                fputc(' ', output_file); // If we're not in a tag, replace the newline with a space
            }
        }
        else {
            fputc(current_char, output_file); // If it's not a tag or newline, just write it to the output file
        }
    }

    // Close the files and end the program
    fclose(input_file);
    fclose(output_file);
    printf("HTML file has been beautified! Check out the new file 'beautified.html'.\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl fputc(int Character, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Fh] [rbp-21h]
  FILE *Stream; // [rsp+30h] [rbp-20h]
  FILE *v6; // [rsp+38h] [rbp-18h]
  int j; // [rsp+40h] [rbp-10h]
  int i; // [rsp+44h] [rbp-Ch]
  int v9; // [rsp+48h] [rbp-8h]
  char v10; // [rsp+4Fh] [rbp-1h]

  _main(argc, argv, envp);
  v10 = 0;
  v9 = 0;
  v6 = fopen("index.html", "r");
  Stream = fopen("beautified.html", "w");
  while ( 1 )
  {
    v4 = fgetc(v6);
    if ( v4 == -1 )
      break;
    switch ( v4 )
    {
      case 60:
        v10 = 1;
        fputc(60, Stream);
        fputc(10, Stream);
        ++v9;
        for ( i = 0; i < v9; ++i )
          fputc(9, Stream);
        break;
      case 62:
        v10 = 0;
        fputc(62, Stream);
        fputc(10, Stream);
        break;
      case 10:
        if ( v10 )
        {
          fputc(10, Stream);
          for ( j = 0; j < v9; ++j )
            fputc(9, Stream);
        }
        else
        {
          fputc(32, Stream);
        }
        break;
      default:
        fputc(v4, Stream);
        break;
    }
  }
  fclose(v6);
  fclose(Stream);
  printf("HTML file has been beautified! Check out the new file 'beautified.html'.\n");
  return 0;
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Resume Parsing System ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//Struct for storing resume information
struct resume {
    char name[50];
    char email[50];
    char phone[20];
    char skills[1000];
};

//Function for parsing resumes
int parse_resume(char* filename, struct resume* r) {
    FILE* fp = fopen(filename, "r");

    if(fp == NULL) {
        printf("Error: file not found.\n");
        return 0;
    }

    char line[1000];

    //Loop through each line of the file
    while(fgets(line, 1000, fp) != NULL) {
        //Check for name
        if(strstr(line, "Name:")) {
            char* name = strstr(line, ":") + 1;
            strcpy(r->name, name);
        }
        //Check for email
        if(strstr(line, "Email:")) {
            char* email = strstr(line, ":") + 1;
            strcpy(r->email, email);
        }
        //Check for phone number
        if(strstr(line, "Phone:")) {
            char* phone = strstr(line, ":") + 1;
            strcpy(r->phone, phone);
        }
        //Check for skills
        if(strstr(line, "Skills:")) {
            char* skills = strstr(line, ":") + 1;
            strcpy(r->skills, skills);
        }
    }

    fclose(fp);

    return 1;
}

int main() {
    char filename[50];
    printf("Enter filename: ");
    scanf("%s", filename);

    struct resume r;
    int success = parse_resume(filename, &r);

    if(success) {
        printf("Name: %s\nEmail: %s\nPhone: %s\nSkills: %s\n", r.name, r.email, r.phone, r.skills);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall parse_resume(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017B9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[50]; // [rsp+30h] [rbp-50h] BYREF
  char v5[50]; // [rsp+62h] [rbp-1Eh] BYREF
  char v6[20]; // [rsp+94h] [rbp+14h] BYREF
  char v7[1000]; // [rsp+A8h] [rbp+28h] BYREF
  char v8[60]; // [rsp+490h] [rbp+410h] BYREF

  _main(argc, argv, envp);
  printf("Enter filename: ");
  scanf("%s", v8);
  if ( (unsigned int)parse_resume(v8, v4) )
    printf("Name: %s\nEmail: %s\nPhone: %s\nSkills: %s\n", v4, v5, v6, v7);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall parse_resume(_QWORD, _QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400017B9: using guessed type char anonymous_0[50];
// 1400017B9: using guessed type char anonymous_1[20];
// 1400017B9: using guessed type char anonymous_2[1000];

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Chess engine ; Style: cheerful
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

//Board representation of chess game
char board[8][8] = {
    {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'},
    {'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'},
    {' ', '.', ' ', '.', ' ', '.', ' ', '.'},
    {'.', ' ', '.', ' ', '.', ' ', '.', ' '},
    {' ', '.', ' ', '.', ' ', '.', ' ', '.'},
    {'.', ' ', '.', ' ', '.', ' ', '.', ' '},
    {'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'},
    {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'}
};

//Function to display the chess board
void display()
{
    printf("\n\n");
    for(int i=0;i<8;++i)
    {
        for(int j=0;j<8;++j)
        {
            printf("%c ", board[i][j]);
        }
        printf("\n");
    }
}

//Function to initialize the board
void initialize_board()
{
    for(int i=0;i<8;++i)
    {
        for(int j=0;j<8;++j)
        {
            board[i][j] = ' ';
        }
    }
    board[0][0] = 'R';
    board[0][1] = 'N';
    board[0][2] = 'B';
    board[0][3] = 'Q';
    board[0][4] = 'K';
    board[0][5] = 'B';
    board[0][6] = 'N';
    board[0][7] = 'R';

    board[1][0] = 'P';
    board[1][1] = 'P';
    board[1][2] = 'P';
    board[1][3] = 'P';
    board[1][4] = 'P';
    board[1][5] = 'P';
    board[1][6] = 'P';
    board[1][7] = 'P';

    board[7][0] = 'r';
    board[7][1] = 'n';
    board[7][2] = 'b';
    board[7][3] = 'q';
    board[7][4] = 'k';
    board[7][5] = 'b';
    board[7][6] = 'n';
    board[7][7] = 'r';

    board[6][0] = 'p';
    board[6][1] = 'p';
    board[6][2] = 'p';
    board[6][3] = 'p';
    board[6][4] = 'p';
    board[6][5] = 'p';
    board[6][6] = 'p';
    board[6][7] = 'p';
}

//Function to play chess
void play_chess()
{
    while(1)
    {
        display();
        //code for playing chess
        //random move
        int move = rand()%4;
        switch(move)
        {
            case 0:
                board[0][0] = ' ';
                board[2][2] = 'R';
                break;
            case 1:
                board[0][7] = ' ';
                board[2][5] = 'R';
                break;
            case 2:
                board[7][0] = ' ';
                board[5][2] = 'r';
                break;
            case 3:
                board[7][7] = ' ';
                board[5][5] = 'r';
                break;
        }
    }
}

int main()
{
    srand(time(NULL));
    initialize_board();
    play_chess();
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 initialize_board(void); // weak
void __noreturn play_chess(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400017F2) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  initialize_board();
  play_chess();
}
// 140001637: using guessed type __int64 initialize_board(void);
// 14000176B: using guessed type void __noreturn play_chess(void);
// 1400018E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: minimalist
#include <stdio.h>

int binarySearch(int arr[], int l, int r, int x) {
    while (l <= r) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x) return mid; 
        if (arr[mid] < x) l = mid + 1; 
        else r = mid - 1;
    } 
    return -1; 
}

int main() {
    int arr[] = {2, 3, 4, 10, 40};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    int result = binarySearch(arr, 0, n - 1, x);
    (result == -1) ? printf("Element is not present in array")
                   : printf("Element is present at index %d", result);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[5]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v5; // [rsp+34h] [rbp-Ch]
  int v6; // [rsp+38h] [rbp-8h]
  int v7; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 2;
  v4[1] = 3;
  v4[2] = 4;
  v4[3] = 10;
  v4[4] = 40;
  v7 = 5;
  v6 = 10;
  v5 = ((__int64 (__fastcall *)(int *, _QWORD, __int64, __int64))binarySearch)(v4, 0i64, 4i64, 10i64);
  if ( v5 == -1 )
    printf("Element is not present in array");
  else
    printf("Element is present at index %d", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Movie Rating System ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>

int main() {
  int age, rating;
  char movie_title[50];
  printf("Welcome to the C Movie Rating System!\n");
  printf("Please enter the title of the movie you'd like to rate: ");
  scanf("%s", movie_title);
  
  printf("Great! Now, please enter your age: ");
  scanf("%d", &age);
  
  if (age >= 18) {
    printf("Thank you! Please rate the movie from 1 to 10: ");
    scanf("%d", &rating);
    if (rating >= 1 && rating <= 4) {
      printf("We're sorry to hear that you didn't enjoy the movie.\n");
    }
    else if (rating >= 5 && rating <= 7) {
      printf("Glad to hear that you liked the movie!\n");
    }
    else if (rating >= 8 && rating <= 10) {
      printf("Wow! It seems like you absolutely loved the movie!\n");
    }
    else {
      printf("Invalid rating, please enter a number between 1 to 10.\n");
    }
  }
  else {
    printf("We're sorry, but you are not old enough to rate this movie. Please come back when you're older.\n");
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[56]; // [rsp+20h] [rbp-40h] BYREF
  int v5; // [rsp+58h] [rbp-8h] BYREF
  int v6; // [rsp+5Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the C Movie Rating System!\n");
  printf("Please enter the title of the movie you'd like to rate: ");
  scanf("%s", v4);
  printf("Great! Now, please enter your age: ");
  scanf("%d", &v6);
  if ( v6 <= 17 )
  {
    printf("We're sorry, but you are not old enough to rate this movie. Please come back when you're older.\n");
  }
  else
  {
    printf("Thank you! Please rate the movie from 1 to 10: ");
    scanf("%d", &v5);
    if ( v5 <= 0 || v5 > 4 )
    {
      if ( v5 <= 4 || v5 > 7 )
      {
        if ( v5 <= 7 || v5 > 10 )
          printf("Invalid rating, please enter a number between 1 to 10.\n");
        else
          printf("Wow! It seems like you absolutely loved the movie!\n");
      }
      else
      {
        printf("Glad to hear that you liked the movie!\n");
      }
    }
    else
    {
      printf("We're sorry to hear that you didn't enjoy the movie.\n");
    }
  }
  return 0;
}
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_40[56];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Math exercise ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  printf("Welcome to the Math Exercise program!\n\n");

  // Generate two random numbers to use for the problem
  srand(time(NULL));
  int num1 = rand() % 21;  // Range from 0 to 20
  int num2 = rand() % 21;

  // Ask the user what operation to perform
  printf("What operation would you like to perform?\n");
  printf("\t1) Addition\n");
  printf("\t2) Subtraction\n");
  printf("\t3) Multiplication\n");
  printf("\t4) Division (round down to nearest integer)\n\n");

  int choice;
  printf("Enter your choice: ");
  scanf("%d", &choice);

  // Perform the selected operation and get the user's answer
  int expected_answer;
  char operation;
  switch (choice) {
    case 1:
      expected_answer = num1 + num2;
      operation = '+';
      break;
    case 2:
      expected_answer = num1 - num2;
      operation = '-';
      break;
    case 3:
      expected_answer = num1 * num2;
      operation = '*';
      break;
    case 4:
      expected_answer = num1 / num2;
      operation = '/';
      break;
    default:
      printf("Invalid choice. Exiting...\n");
      return 1;
  }

  printf("\nWhat is %d %c %d? ", num1, operation, num2);

  int user_answer;
  scanf("%d", &user_answer);

  // Check if the user's answer is correct
  if (user_answer == expected_answer) {
    printf("Congratulations! You got it right!\n");
  } else {
    printf("Sorry, that's incorrect. The correct answer is %d.\n", expected_answer);
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+28h] [rbp-18h] BYREF
  int v6; // [rsp+2Ch] [rbp-14h] BYREF
  int v7; // [rsp+30h] [rbp-10h]
  int v8; // [rsp+34h] [rbp-Ch]
  char v9; // [rsp+3Bh] [rbp-5h]
  unsigned int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Math Exercise program!\n\n");
  v3 = time(0i64);
  srand(v3);
  v8 = rand() % 21;
  v7 = rand() % 21;
  printf("What operation would you like to perform?\n");
  printf("\t1) Addition\n");
  printf("\t2) Subtraction\n");
  printf("\t3) Multiplication\n");
  printf("\t4) Division (round down to nearest integer)\n\n");
  printf("Enter your choice: ");
  scanf("%d", &v6);
  if ( v6 == 4 )
  {
    v10 = v8 / v7;
    v9 = 47;
  }
  else
  {
    if ( v6 > 4 )
    {
LABEL_11:
      printf("Invalid choice. Exiting...\n");
      return 1;
    }
    switch ( v6 )
    {
      case 3:
        v10 = v7 * v8;
        v9 = 42;
        break;
      case 1:
        v10 = v8 + v7;
        v9 = 43;
        break;
      case 2:
        v10 = v8 - v7;
        v9 = 45;
        break;
      default:
        goto LABEL_11;
    }
  }
  printf("\nWhat is %d %c %d? ", (unsigned int)v8, (unsigned int)v9, (unsigned int)v7);
  scanf("%d", &v5);
  if ( v10 == v5 )
    printf("Congratulations! You got it right!\n");
  else
    printf("Sorry, that's incorrect. The correct answer is %d.\n", v10);
  return 0;
}
// 14000171F: conditional instruction was optimized away because %var_14.4<3
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific Calculator Implementation ; Style: grateful
#include <stdio.h>
#include <math.h>

int main() {
    printf("Welcome to the Grateful Scientific Calculator!\n");

    // Display menu options
    printf("Menu:\n");
    printf("1. Addition\n");
    printf("2. Subtraction\n");
    printf("3. Multiplication\n");
    printf("4. Division\n");
    printf("5. Exponentiation\n");
    printf("6. Square Root\n");
    printf("7. Logarithm\n");
    printf("8. Trigonometric functions\n");
    printf("9. Quit\n");

    int choice = 0;

    while (choice != 9) {
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        double num1, num2, result;

        switch (choice) {
            case 1:
                printf("\nEnter the first number: ");
                scanf("%lf", &num1);
                printf("Enter the second number: ");
                scanf("%lf", &num2);
                result = num1 + num2;
                printf("%.2lf + %.2lf = %.2lf\n", num1, num2, result);
                break;

            case 2:
                printf("\nEnter the first number: ");
                scanf("%lf", &num1);
                printf("Enter the second number: ");
                scanf("%lf", &num2);
                result = num1 - num2;
                printf("%.2lf - %.2lf = %.2lf\n", num1, num2, result);
                break;

            case 3:
                printf("\nEnter the first number: ");
                scanf("%lf", &num1);
                printf("Enter the second number: ");
                scanf("%lf", &num2);
                result = num1 * num2;
                printf("%.2lf * %.2lf = %.2lf\n", num1, num2, result);
                break;

            case 4:
                printf("\nEnter the first number: ");
                scanf("%lf", &num1);
                printf("Enter the second number: ");
                scanf("%lf", &num2);
                result = num1 / num2;
                printf("%.2lf / %.2lf = %.2lf\n", num1, num2, result);
                break;

            case 5:
                printf("\nEnter the base: ");
                scanf("%lf", &num1);
                printf("Enter the exponent: ");
                scanf("%lf", &num2);
                result = pow(num1, num2);
                printf("%.2lf ^ %.2lf = %.2lf\n", num1, num2, result);
                break;

            case 6:
                printf("\nEnter the number: ");
                scanf("%lf", &num1);
                result = sqrt(num1);
                printf("sqrt(%.2lf) = %.2lf\n", num1, result);
                break;

            case 7:
                printf("\nEnter the number: ");
                scanf("%lf", &num1);
                result = log(num1);
                printf("log(%.2lf) = %.2lf\n", num1, result);
                break;

            case 8:
                printf("\nEnter the angle in degrees: ");
                scanf("%lf", &num1);
                result = sin(num1 * M_PI / 180);
                printf("sin(%.2lf) = %.2lf\n", num1, result);
                result = cos(num1 * M_PI / 180);
                printf("cos(%.2lf) = %.2lf\n", num1, result);
                result = tan(num1 * M_PI / 180);
                printf("tan(%.2lf) = %.2lf\n", num1, result);
                break;

            case 9:
                printf("\nThank you for using the Grateful Scientific Calculator! Goodbye!\n");
                break;

            default:
                printf("\nInvalid input. Please try again.\n");
                break;
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl cos(double X);
double __cdecl log(double X);
double __cdecl pow(double X, double Y);
double __cdecl sin(double X);
// double __cdecl tan(double X);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double Y; // [rsp+20h] [rbp-20h] BYREF
  double X; // [rsp+28h] [rbp-18h] BYREF
  int v6; // [rsp+34h] [rbp-Ch] BYREF
  __int64 v7; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to the Grateful Scientific Calculator!\n");
  printf("Menu:\n");
  printf("1. Addition\n");
  printf("2. Subtraction\n");
  printf("3. Multiplication\n");
  printf("4. Division\n");
  printf("5. Exponentiation\n");
  printf("6. Square Root\n");
  printf("7. Logarithm\n");
  printf("8. Trigonometric functions\n");
  printf("9. Quit\n");
  v6 = 0;
  while ( v6 != 9 )
  {
    printf("\nEnter your choice: ");
    scanf("%d", &v6);
    switch ( v6 )
    {
      case 1:
        printf("\nEnter the first number: ");
        scanf("%lf", &X);
        printf("Enter the second number: ");
        scanf("%lf", &Y);
        *(double *)&v7 = Y + X;
        printf("%.2lf + %.2lf = %.2lf\n", X, Y, Y + X);
        break;
      case 2:
        printf("\nEnter the first number: ");
        scanf("%lf", &X);
        printf("Enter the second number: ");
        scanf("%lf", &Y);
        *(double *)&v7 = X - Y;
        printf("%.2lf - %.2lf = %.2lf\n", X, Y, X - Y);
        break;
      case 3:
        printf("\nEnter the first number: ");
        scanf("%lf", &X);
        printf("Enter the second number: ");
        scanf("%lf", &Y);
        *(double *)&v7 = Y * X;
        printf("%.2lf * %.2lf = %.2lf\n", X, Y, Y * X);
        break;
      case 4:
        printf("\nEnter the first number: ");
        scanf("%lf", &X);
        printf("Enter the second number: ");
        scanf("%lf", &Y);
        *(double *)&v7 = X / Y;
        printf("%.2lf / %.2lf = %.2lf\n", X, Y, X / Y);
        break;
      case 5:
        printf("\nEnter the base: ");
        scanf("%lf", &X);
        printf("Enter the exponent: ");
        scanf("%lf", &Y);
        *(double *)&v7 = pow(X, Y);
        printf("%.2lf ^ %.2lf = %.2lf\n", X, Y, v7);
        break;
      case 6:
        printf("\nEnter the number: ");
        scanf("%lf", &X);
        *(double *)&v7 = sqrt(X);
        printf("sqrt(%.2lf) = %.2lf\n", X, v7);
        break;
      case 7:
        printf("\nEnter the number: ");
        scanf("%lf", &X);
        *(double *)&v7 = log(X);
        printf("log(%.2lf) = %.2lf\n", X, v7);
        break;
      case 8:
        printf("\nEnter the angle in degrees: ");
        scanf("%lf", &X);
        *(double *)&v7 = sin(3.141592653589793 * X / 180.0);
        printf("sin(%.2lf) = %.2lf\n", X, v7);
        *(double *)&v7 = cos(3.141592653589793 * X / 180.0);
        printf("cos(%.2lf) = %.2lf\n", X, v7);
        *(double *)&v7 = tan(3.141592653589793 * X / 180.0);
        printf("tan(%.2lf) = %.2lf\n", X, v7);
        break;
      case 9:
        printf("\nThank you for using the Grateful Scientific Calculator! Goodbye!\n");
        break;
      default:
        printf("\nInvalid input. Please try again.\n");
        break;
    }
  }
  return 0;
}
// 140001DA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=189 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Medical Store Management System ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define maximum length for string inputs
#define MAX_INPUT_LENGTH 50

// Define structure for medication items
typedef struct {
    int id;
    char name[MAX_INPUT_LENGTH];
    float price;
    int quantity;
} Medication;

// Function to add medication item to inventory
void addMedication(Medication* inventory, int* itemCount) {
    printf("Enter medication name: ");
    scanf("%s", inventory[*itemCount].name);

    printf("Enter medication price: ");
    scanf("%f", &inventory[*itemCount].price);

    printf("Enter medication quantity: ");
    scanf("%d", &inventory[*itemCount].quantity);

    inventory[*itemCount].id = (*itemCount) + 1;

    (*itemCount)++;

    printf("Medication added successfully!\n");
}

// Function to remove medication item from inventory
void removeMedication(Medication* inventory, int* itemCount) {
    int idToRemove;
    printf("Enter medication ID to remove: ");
    scanf("%d", &idToRemove);

    // Find index of medication item with matching ID
    int indexToRemove = -1;
    for (int i = 0; i < *itemCount; i++) {
        if (inventory[i].id == idToRemove) {
            indexToRemove = i;
            break;
        }
    }

    // Shift all remaining items over to fill gap
    if (indexToRemove != -1) {
        for (int i = indexToRemove; i < (*itemCount) - 1; i++) {
            inventory[i] = inventory[i + 1];
        }

        (*itemCount)--;

        printf("Medication removed successfully!\n");
    } else {
        printf("Medication with ID %d not found.\n", idToRemove);
    }
}

// Function to display all medication items in inventory
void displayInventory(Medication* inventory, int* itemCount) {
    printf("ID\tName\tPrice\tQuantity\n");
    for (int i = 0; i < *itemCount; i++) {
        printf("%d\t%s\t%.2f\t%d\n", inventory[i].id, inventory[i].name, inventory[i].price, inventory[i].quantity);
    }
}

int main() {
    Medication inventory[50];
    int itemCount = 0;
    int choice;

    printf("Welcome to the Medical Store Management System!\n");

    // Loop through menu options until user chooses to exit
    do {
        printf("\nPlease choose from the following options:\n");
        printf("1. Add medication\n");
        printf("2. Remove medication\n");
        printf("3. Display inventory\n");
        printf("4. Exit\n");

        scanf("%d", &choice);

        switch (choice) {
            case 1:
                addMedication(inventory, &itemCount);
                break;
            case 2:
                removeMedication(inventory, &itemCount);
                break;
            case 3:
                displayInventory(inventory, &itemCount);
                break;
            case 4:
                printf("Exiting Medical Store Management System...\n");
                break;
            default:
                printf("Invalid input. Please try again.\n");
        }
    } while (choice != 4);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addMedication(_QWORD, _QWORD); // weak
__int64 __fastcall removeMedication(_QWORD, _QWORD); // weak
__int64 __fastcall displayInventory(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018F9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[3200]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  printf("Welcome to the Medical Store Management System!\n");
  do
  {
    printf("\nPlease choose from the following options:\n");
    printf("1. Add medication\n");
    printf("2. Remove medication\n");
    printf("3. Display inventory\n");
    printf("4. Exit\n");
    scanf("%d", &v4);
    if ( v4 == 4 )
    {
      printf("Exiting Medical Store Management System...\n");
    }
    else
    {
      if ( v4 <= 4 )
      {
        switch ( v4 )
        {
          case 3:
            displayInventory(v6, &v5);
            continue;
          case 1:
            addMedication(v6, &v5);
            continue;
          case 2:
            removeMedication(v6, &v5);
            continue;
        }
      }
      printf("Invalid input. Please try again.\n");
    }
  }
  while ( v4 != 4 );
  return 0;
}
// 14000199A: conditional instruction was optimized away because %var_C88.4<3
// 1400015E2: using guessed type __int64 __fastcall addMedication(_QWORD, _QWORD);
// 1400016E9: using guessed type __int64 __fastcall removeMedication(_QWORD, _QWORD);
// 14000182C: using guessed type __int64 __fastcall displayInventory(_QWORD, _QWORD);
// 140001AD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Alien Language Translator ; Style: recursive
#include <stdio.h>
#include <string.h>

void translate(char c[], int length, int i) {
    char result[100] = "";
    // Base case: reached end of string
    if (i == length) {
        printf("%s", c);
        return;
    }
    // Check each letter
    switch(c[i]) {
        case 'A':
            strcat(result, "<>");
            break;
        case 'B':
            strcat(result, "{}");
            break;
        case 'C':
            strcat(result, "()");
            break;
        case 'D':
            strcat(result, "[]");
            break;
        case 'E':
            strcat(result, "$$");
            break;
        default:
            strcat(result, "!");
    }
    printf("%s", result);
    // Recurse to next letter
    translate(c, length, i+1);
}

int main() {
    // Get user input
    char input[100];
    printf("Enter C Alien Language: ");
    scanf("%s", input);
    // Translate and print
    printf("Translated: ");
    translate(input, strlen(input), 0);
    printf("\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall translate(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (00000001400017BA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char Str[112]; // [rsp+20h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter C Alien Language: ");
  scanf("%s", Str);
  printf("Translated: ");
  v3 = strlen(Str);
  translate(Str, v3, 0i64);
  printf("\n");
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall translate(_QWORD, _QWORD, _QWORD);
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Watermarking ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 1024
#define WATERMARK_SIZE 32

/* Surreal digital watermarking algorithm */

int main(int argc, char *argv[]) {
    FILE *infile, *outfile;
    char wm[WATERMARK_SIZE] = "The sky is not what it seems";
    char buffer[MAX_SIZE];
    int i, j = 0, buffer_size, wm_size = strlen(wm);

    if (argc != 3) {
        printf("Usage: %s <input_file> <output_file>\n", argv[0]);
        exit(1);
    }

    infile = fopen(argv[1], "rb");
    if (!infile) {
        printf("Error: Failed to open file %s\n", argv[1]);
        exit(1);
    }

    outfile = fopen(argv[2], "wb");
    if (!outfile) {
        printf("Error: Failed to open file %s\n", argv[2]);
        exit(1);
    }

    while ((buffer_size = fread(buffer, 1, MAX_SIZE, infile)) != 0) {
        for (i = 0; i < buffer_size && j < wm_size; ++i, ++j) {
            buffer[i] ^= wm[j];
        }

        fwrite(buffer, 1, buffer_size, outfile);

        if (j >= wm_size) {
            j = 0;
        }
    }

    printf("Surrealist watermarking complete!\n");

    fclose(infile);
    fclose(outfile);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[1024]; // [rsp+20h] [rbp-60h] BYREF
  char Str[30]; // [rsp+420h] [rbp+3A0h] BYREF
  __int16 v6; // [rsp+43Eh] [rbp+3BEh]
  int v7; // [rsp+44Ch] [rbp+3CCh]
  FILE *Stream; // [rsp+450h] [rbp+3D0h]
  FILE *v9; // [rsp+458h] [rbp+3D8h]
  int v10; // [rsp+464h] [rbp+3E4h]
  int v11; // [rsp+468h] [rbp+3E8h]
  int i; // [rsp+46Ch] [rbp+3ECh]

  _main(argc, argv, envp);
  strcpy(Str, "The sky is not what it seems");
  Str[29] = 0;
  v6 = 0;
  v11 = 0;
  v10 = strlen(Str);
  if ( argc != 3 )
  {
    printf("Usage: %s <input_file> <output_file>\n", *argv);
    exit(1);
  }
  v9 = fopen(argv[1], "rb");
  if ( !v9 )
  {
    printf("Error: Failed to open file %s\n", argv[1]);
    exit(1);
  }
  Stream = fopen(argv[2], "wb");
  if ( !Stream )
  {
    printf("Error: Failed to open file %s\n", argv[2]);
    exit(1);
  }
  while ( 1 )
  {
    v7 = fread(Buffer, 1ui64, 0x400ui64, v9);
    if ( !v7 )
      break;
    for ( i = 0; i < v7 && v11 < v10; Buffer[i++] ^= Str[v11++] )
      ;
    fwrite(Buffer, 1ui64, v7, Stream);
    if ( v11 >= v10 )
      v11 = 0;
  }
  printf("Surrealist watermarking complete!\n");
  fclose(v9);
  fclose(Stream);
  return 0;
}
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[1024];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Spell checking ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define MAXWORD 100
#define MAXLINE 1000

struct tnode {
    char *word;
    int count;
    struct tnode *left;
    struct tnode *right;
};

struct tnode *addtree(struct tnode *, char *);
void treeprint(struct tnode *);
int getword(char *, int);
int is_valid(char *);

int main()
{
    struct tnode *root;
    char word[MAXWORD];
    root = NULL;

    while (getword(word, MAXWORD) != EOF) {
        if (isalpha(word[0]) && is_valid(word))
            root = addtree(root, word);
    }

    treeprint(root);
    return 0;
}

struct tnode *talloc(void);
char *strdup_custom(char *);

struct tnode *addtree(struct tnode *p, char *w)
{
    int cond;

    if (p == NULL) {
        p = talloc();
        p->word = strdup_custom(w);
        p->count = 1;
        p->left = p->right = NULL;
    } else if ((cond = strcmp(w, p->word)) == 0) {
        p->count++;
    } else if (cond < 0) {
        p->left = addtree(p->left, w);
    } else {
        p->right = addtree(p->right, w);
    }
    return p;
}

char *strdup_custom(char *s)
{
    char *p;
    p = (char *) malloc(strlen(s) + 1);
    if (p != NULL) {
        strcpy(p, s);
    }
    return p;
}

void treeprint(struct tnode *p)
{
    if (p != NULL) {
        treeprint(p->left);
        printf("%4d %s\n", p->count, p->word);
        treeprint(p->right);
    }
}

int getch(void);
void ungetch(int);

int getword(char *word, int lim)
{
    int c, d, comment, string;
    char *w = word;

    while (isspace(c = getch()))
        ;

    if (c == '/') {
        if ((d = getch()) == '*') {
            comment = 1;
        } else {
            ungetch(d);
            *w = c;
            return c;
        }
    } else if (c == '"') {
        string = 1;
    }

    if (c != EOF) {
        *w++ = c;
    }
    if (!isalpha(c) && c != '_' && c != '/'
            && c != '*' && !string) {
        *w = '\0';
        return c;
    }

    for (; --lim > 0; w++) {
        *w = getch();
        if (*w == '/' && *(w-1) == '*' && comment) {
            comment = 0;
            w--;
        } else if (*w == '"') {
            string = !string;
            w--;
        } else if (!isalnum(*w) && *w != '_'
                && !comment && !string) {
            ungetch(*w);
            break;
        }
    }
    *w = '\0';
    return word[0];
}

#define BUFSIZE 100

char buf[BUFSIZE];
int bufp = 0;

int getch(void)
{
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c)
{
    if (bufp >= BUFSIZE) {
        printf("ungetch: too many characters\n");
    } else {
        buf[bufp++] = c;
    }
}

int is_valid(char *word)
{
    char *keywords[] = {
          "auto", "break", "case", "char", "const", "continue", "default",
          "do", "double", "else", "enum", "extern", "float", "for", "goto",
          "if", "int", "long", "register", "return", "short", "signed",
          "sizeof", "static", "struct", "switch", "typedef", "union",
          "unsigned", "void", "volatile", "while"
          };
    int n_keywords = sizeof(keywords) / sizeof(keywords[0]);

    int i;
    for (i = 0; i < n_keywords; ++i) {
        if (strcmp(word, keywords[i]) == 0) {
            return 0;
        }
    }

    return 1;
}

struct tnode *talloc(void)
{
    return (struct tnode *) malloc(sizeof(struct tnode));
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall addtree(_QWORD, _QWORD); // weak
__int64 __fastcall treeprint(_QWORD); // weak
__int64 __fastcall getword(_QWORD, _QWORD); // weak
__int64 __fastcall is_valid(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isalpha)(int C);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[104]; // [rsp+20h] [rbp-70h] BYREF
  __int64 v5; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  v5 = 0i64;
  while ( (unsigned int)getword(v4, 100i64) != -1 )
  {
    if ( isalpha(v4[0]) && (unsigned int)is_valid(v4) )
      v5 = addtree(v5, v4);
  }
  treeprint(v5);
  return 0;
}
// 140001615: using guessed type __int64 __fastcall addtree(_QWORD, _QWORD);
// 140001730: using guessed type __int64 __fastcall treeprint(_QWORD);
// 14000178C: using guessed type __int64 __fastcall getword(_QWORD, _QWORD);
// 1400019C2: using guessed type __int64 __fastcall is_valid(_QWORD);
// 140001C70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=151 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Firewall ; Style: irregular
/* This program will demonstrate a unique way of implementing a firewall in C */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char packet[100];
    int i;

    printf("Welcome to the firewall program!\n");

    while(1)
    {
        printf("\nEnter the packet to be filtered: ");
        fgets(packet, sizeof(packet), stdin);

        if(strlen(packet) == 1)
        {
            printf("Empty packet detected! Please try again.\n");
            continue;
        }

        for(i = 0; i < strlen(packet); i++)
        {
            if(i % 2 == 0)
            {
                packet[i] = packet[i] + 1;
            }
            else
            {
                packet[i] = packet[i] - 1;
            }
        }

        for(i = 0; i < strlen(packet); i++)
        {
            if(packet[i] == '@' || packet[i] == '#' || packet[i] == '$' || packet[i] == '%')
            {
                printf("\nPacket blocked! Contains invalid characters!\n");
                break;
            }
        }

        if(i == strlen(packet))
        {
            printf("\nPacket filtered successfully! Passes security check!\n");

            for(i = 0; i < strlen(packet); i++)
            {
                if(packet[i] == 'p')
                {
                    packet[i] = 'm';
                }
                else if(packet[i] == 'P')
                {
                    packet[i] = 'M';
                }
            }

            printf("\nPacket after filtering: %s\n", packet);
        }
    }

    printf("Exiting firewall program.");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char v4; // dl
  char Buffer[108]; // [rsp+20h] [rbp-70h] BYREF
  int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the firewall program!\n");
  while ( 1 )
  {
    while ( 1 )
    {
      printf("\nEnter the packet to be filtered: ");
      v3 = __acrt_iob_func(0);
      fgets(Buffer, 100, v3);
      if ( strlen(Buffer) != 1 )
        break;
      printf("Empty packet detected! Please try again.\n");
    }
    for ( i = 0; i < strlen(Buffer); ++i )
    {
      if ( (i & 1) != 0 )
        v4 = Buffer[i] - 1;
      else
        v4 = Buffer[i] + 1;
      Buffer[i] = v4;
    }
    for ( i = 0; ; ++i )
    {
      if ( i >= strlen(Buffer) )
        goto LABEL_18;
      if ( Buffer[i] == 64 || Buffer[i] == 35 || Buffer[i] == 36 || Buffer[i] == 37 )
        break;
    }
    printf("\nPacket blocked! Contains invalid characters!\n");
LABEL_18:
    if ( i == strlen(Buffer) )
    {
      printf("\nPacket filtered successfully! Passes security check!\n");
      for ( i = 0; i < strlen(Buffer); ++i )
      {
        if ( Buffer[i] == 112 )
        {
          Buffer[i] = 109;
        }
        else if ( Buffer[i] == 80 )
        {
          Buffer[i] = 77;
        }
      }
      printf("\nPacket after filtering: %s\n", Buffer);
    }
  }
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[108];

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bingo Simulator ; Style: irregular
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<stdbool.h>

void generate_board(int arr[3][3]);
bool check_bingo(int arr[3][3]);

int main()
{
    int board[3][3];
    generate_board(board);
    printf("Your bingo board:\n\n");
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(board[i][j]==-1){
                printf("  \t");
            }
            else{
                printf("%d\t",board[i][j]);
            }
        }
        printf("\n\n");
    }

    printf("Press Enter to start the game!\n");
    getchar();

    srand(time(NULL));
    int num;
    bool bingo=false;
    while(!bingo){
        num=rand()%9+1;
        printf("\n\nThe number is: %d\n\n",num);
        for(int i=0;i<3;i++){
            for(int j=0;j<3;j++){
                if(board[i][j]==num){
                    board[i][j]=-1;
                }
            }
        }
        for(int i=0;i<3;i++){
            for(int j=0;j<3;j++){
                if(board[i][j]!=-1){
                    printf("%d\t",board[i][j]);
                }
                else{
                    printf(" \t");
                }
            }
            printf("\n\n");
        }
        if(check_bingo(board)){
            bingo=true;
        }
    }
    printf("Bingo!!! You won the game!\n");
}

void generate_board(int arr[3][3])
{
    int nums[9];
    for(int i=0;i<9;i++){
        nums[i]=rand()%9+1;
        for(int j=0;j<i;j++){
            if(nums[j]==nums[i]){
                i--;
                break;
            }
        }
    }
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            arr[i][j]=nums[i*3+j];
        }
    }
    arr[1][1]=-1;
}

bool check_bingo(int arr[3][3])
{
    bool bingo=false;
    for(int i=0;i<3;i++){
        if(arr[i][0]==-1 && arr[i][1]==-1 && arr[i][2]==-1){
            bingo=true;
        }
    }
    for(int i=0;i<3;i++){
        if(arr[0][i]==-1 && arr[1][i]==-1 && arr[2][i]==-1){
            bingo=true;
        }
    }
    if(arr[0][0]==-1 && arr[1][1]==-1 && arr[2][2]==-1){
        bingo=true;
    }
    if(arr[0][2]==-1 && arr[1][1]==-1 && arr[2][0]==-1){
        bingo=true;
    }
    return bingo;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall generate_board(_QWORD); // weak
__int64 __fastcall check_bingo(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[12]; // [rsp+20h] [rbp-50h] BYREF
  unsigned int v6; // [rsp+50h] [rbp-20h]
  int ii; // [rsp+54h] [rbp-1Ch]
  int n; // [rsp+58h] [rbp-18h]
  int m; // [rsp+5Ch] [rbp-14h]
  int k; // [rsp+60h] [rbp-10h]
  char v11; // [rsp+67h] [rbp-9h]
  int j; // [rsp+68h] [rbp-8h]
  int i; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  generate_board(v5);
  printf("Your bingo board:\n\n");
  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
    {
      if ( v5[3 * i + j] == -1 )
        printf("  \t");
      else
        printf("%d\t", (unsigned int)v5[3 * i + j]);
    }
    printf("\n\n");
  }
  printf("Press Enter to start the game!\n");
  getchar();
  v3 = time(0i64);
  srand(v3);
  v11 = 0;
  while ( v11 != 1 )
  {
    v6 = rand() % 9 + 1;
    printf("\n\nThe number is: %d\n\n", v6);
    for ( k = 0; k <= 2; ++k )
    {
      for ( m = 0; m <= 2; ++m )
      {
        if ( v6 == v5[3 * k + m] )
          v5[3 * k + m] = -1;
      }
    }
    for ( n = 0; n <= 2; ++n )
    {
      for ( ii = 0; ii <= 2; ++ii )
      {
        if ( v5[3 * n + ii] == -1 )
          printf(" \t");
        else
          printf("%d\t", (unsigned int)v5[3 * n + ii]);
      }
      printf("\n\n");
    }
    if ( (unsigned __int8)check_bingo(v5) )
      v11 = 1;
  }
  printf("Bingo!!! You won the game!\n");
  return 0;
}
// 140001821: using guessed type __int64 __fastcall generate_board(_QWORD);
// 14000191D: using guessed type __int64 __fastcall check_bingo(_QWORD);
// 140001B20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type int var_50[12];

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: ephemeral
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int calculate_levenshtein_distance(char *string1, char *string2) {
    int length1 = strlen(string1);
    int length2 = strlen(string2);

    int levenshtein_matrix[length1 + 1][length2 + 1];

    for(int i = 0; i <= length1; i++) {
        for(int j = 0; j <= length2; j++) {
            if(i == 0) {
                levenshtein_matrix[i][j] = j;
            }
            else if(j == 0) {
                levenshtein_matrix[i][j] = i;
            }
            else {
                if(string1[i-1] == string2[j-1]) {
                    levenshtein_matrix[i][j] = levenshtein_matrix[i-1][j-1];
                }
                else {
                    int minimum = levenshtein_matrix[i-1][j-1];
                    if(levenshtein_matrix[i][j-1] < minimum) {
                        minimum = levenshtein_matrix[i][j-1];
                    }
                    if(levenshtein_matrix[i-1][j] < minimum) {
                        minimum = levenshtein_matrix[i-1][j];
                    }

                    levenshtein_matrix[i][j] = minimum + 1;
                }
            }
        }
    }

    return levenshtein_matrix[length1][length2];
}

int main() {
    char string1[100];
    char string2[100];

    printf("Enter first string: ");
    scanf("%s", string1);

    printf("Enter second string: ");
    scanf("%s", string2);

    int distance = calculate_levenshtein_distance(string1, string2);

    printf("The Levenshtein distance between \"%s\" and \"%s\" is %d", string1, string2, distance);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall calculate_levenshtein_distance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001951) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[112]; // [rsp+20h] [rbp-60h] BYREF
  char v5[108]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v6; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter first string: ");
  scanf("%s", v5);
  printf("Enter second string: ");
  scanf("%s", v4);
  v6 = calculate_levenshtein_distance(v5, v4);
  printf("The Levenshtein distance between \"%s\" and \"%s\" is %d", v5, v4, v6);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall calculate_levenshtein_distance(_QWORD, _QWORD);
// 140001AB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Light Controller ; Style: brave
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#define RED 0
#define YELLOW 1
#define GREEN 2

void setLights(int red, int yellow, int green);
void runTrafficLight();

int main()
{
    runTrafficLight();

    return 0;
}

void setLights(int red, int yellow, int green)
{
    printf("\n************************************\n");

    if (red)
        printf("*\t\tRED LIGHT ON\t\t *\n");

    if (yellow)
        printf("*\tYELLOW LIGHT ON FOR 2 SECONDS\t *\n");

    if (green)
        printf("*\t\tGREEN LIGHT ON\t\t *\n");

    printf("************************************\n\n");
}

void runTrafficLight()
{
    srand(time(NULL));
    int light = rand() % 3;
    int previousLight = -1;

    while (1)
    {
        switch (light)
        {
        case RED:
            if (previousLight != RED)
                setLights(1, 0, 0);

            sleep(5); // red light stays on for 5 seconds
            previousLight = RED;
            light = YELLOW;
            setLights(0, 1, 0);

            break;
        case YELLOW:
            if (previousLight == RED)
                sleep(2); // yellow light stays on for 2 seconds if coming from red
            else
                sleep(3); // yellow light stays on for 3 seconds if coming from green

            previousLight = YELLOW;
            light = GREEN;
            setLights(0, 0, 1);

            break;
        case GREEN:
            if (previousLight != GREEN)
                setLights(0, 0, 1);

            sleep(5); // green light stays on for 5 seconds
            previousLight = GREEN;
            light = YELLOW;
            setLights(0, 1, 0);

            break;
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 runTrafficLight(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  runTrafficLight();
  return 0;
}
// 140001643: using guessed type __int64 runTrafficLight(void);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Geometric algorithms ; Style: innovative
#include <stdio.h>
#include <math.h>

typedef struct Point {
    int x, y;
} Point;

double dist(Point p1, Point p2) {
    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
}

int isTriangle(Point p1, Point p2, Point p3) {
    double a = dist(p1, p2), b = dist(p2, p3), c = dist(p3, p1);
    return (a + b > c) && (b + c > a) && (c + a > b);
}

int isCollinear(Point p1, Point p2, Point p3) {
    return (p1.y - p2.y) * (p1.x - p3.x) == (p1.y - p3.y) * (p1.x - p2.x);
}

int isConvex(Point p1, Point p2, Point p3, Point p4) {
    double ab = dist(p1, p2), bc = dist(p2, p3), cd = dist(p3, p4), da = dist(p4, p1), ac = dist(p1, p3), bd = dist(p2, p4);
    double abc = acos((ab * ab + ac * ac - bc * bc) / (2 * ab * ac)), bcd = acos((bc * bc + cd * cd - bd * bd) / (2 * bc * cd)), cda = acos((cd * cd + da * da - ac * ac) / (2 * cd * da)), dab = acos((da * da + ab * ab - bd * bd) / (2 * da * ab));
    double sum = abc + bcd + cda + dab;
    return (fabs(sum - 2 * M_PI) < 1e-9);
}

int main() {
    Point p1 = {0, 0}, p2 = {3, 0}, p3 = {0, 4}, p4 = {3, 4};
    printf("%s\n", isTriangle(p1, p2, p3) ? "p1 p2 p3 form a triangle" : "p1 p2 p3 do not form a triangle");
    printf("%s\n", isTriangle(p1, p2, p4) ? "p1 p2 p4 form a triangle" : "p1 p2 p4 do not form a triangle");
    printf("%s\n", isCollinear(p1, p2, p3) ? "p1 p2 p3 are collinear" : "p1 p2 p3 are not collinear");
    printf("%s\n", isCollinear(p1, p2, p4) ? "p1 p2 p4 are collinear" : "p1 p2 p4 are not collinear");
    printf("%s\n", isConvex(p1, p2, p3, p4) ? "p1 p2 p3 p4 form a convex quadrilateral" : "p1 p2 p3 p4 do not form a convex quadrilateral");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall isTriangle(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall isCollinear(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall isConvex(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001958) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rax
  const char *v4; // rax
  const char *v5; // rax
  const char *v6; // rax
  const char *v7; // rax

  _main(argc, argv, envp);
  if ( (unsigned int)isTriangle(0i64, 3i64, 0x400000000i64) )
    v3 = "p1 p2 p3 form a triangle";
  else
    v3 = "p1 p2 p3 do not form a triangle";
  printf("%s\n", v3);
  if ( (unsigned int)isTriangle(0i64, 3i64, 0x400000003i64) )
    v4 = "p1 p2 p4 form a triangle";
  else
    v4 = "p1 p2 p4 do not form a triangle";
  printf("%s\n", v4);
  if ( (unsigned int)isCollinear(0i64, 3i64, 0x400000000i64) )
    v5 = "p1 p2 p3 are collinear";
  else
    v5 = "p1 p2 p3 are not collinear";
  printf("%s\n", v5);
  if ( (unsigned int)isCollinear(0i64, 3i64, 0x400000003i64) )
    v6 = "p1 p2 p4 are collinear";
  else
    v6 = "p1 p2 p4 are not collinear";
  printf("%s\n", v6);
  if ( (unsigned int)isConvex(0i64, 3i64, 0x400000000i64, 0x400000003i64) )
    v7 = "p1 p2 p3 p4 form a convex quadrilateral";
  else
    v7 = "p1 p2 p3 p4 do not form a convex quadrilateral";
  printf("%s\n", v7);
  return 0;
}
// 140001628: using guessed type __int64 __fastcall isTriangle(_QWORD, _QWORD, _QWORD);
// 1400016CC: using guessed type __int64 __fastcall isCollinear(_QWORD, _QWORD, _QWORD);
// 140001714: using guessed type __int64 __fastcall isConvex(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001B90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=148 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: funny
#include <stdio.h>

int main () {
   int pushUps = 0;
   int squats = 0;
   int sitUps = 0;
   int burpees = 0;
   
   printf("Welcome to the C Fitness Tracker!\n");
   printf("Let's get started! Enter your name: ");
   
   char name[20];
   scanf("%s", name);
   
   printf("Hi %s, let's start tracking your workouts!\n", name);
   
   while (1) {
      printf("\nWhich exercise would you like to track?\n");
      printf("1. Push-Ups\n");
      printf("2. Squats\n");
      printf("3. Sit-Ups\n");
      printf("4. Burpees\n");
      printf("5. Quit\n");
      
      int choice;
      scanf("%d", &choice);
      
      switch (choice) {
         case 1:
            printf("Enter the number of push-ups you did: ");
            
            int p;
            scanf("%d", &p);
            pushUps += p;
            
            printf("Total push-ups: %d", pushUps);
            
            break;
         
         case 2:
            printf("Enter the number of squats you did: ");
            
            int s;
            scanf("%d", &s);
            squats += s;
            
            printf("Total squats: %d", squats);
            
            break;
         
         case 3:
            printf("Enter the number of sit-ups you did: ");
            
            int su;
            scanf("%d", &su);
            sitUps += su;
            
            printf("Total sit-ups: %d", sitUps);
            
            break;
         
         case 4:
            printf("Enter the number of burpees you did: ");
            
            int b;
            scanf("%d", &b);
            burpees += b;
            
            printf("Total burpees: %d", burpees);
            
            break;
            
         case 5:
            printf("Thanks for using the C Fitness Tracker! See you next time, %s!", name);
            return 0;
            
         default:
            printf("Invalid choice!");
            break;
      }
   }
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-44h] BYREF
  int v5; // [rsp+30h] [rbp-40h] BYREF
  int v6; // [rsp+34h] [rbp-3Ch] BYREF
  int v7; // [rsp+38h] [rbp-38h] BYREF
  int v8; // [rsp+3Ch] [rbp-34h] BYREF
  char v9[32]; // [rsp+40h] [rbp-30h] BYREF
  unsigned int v10; // [rsp+60h] [rbp-10h]
  unsigned int v11; // [rsp+64h] [rbp-Ch]
  unsigned int v12; // [rsp+68h] [rbp-8h]
  unsigned int v13; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  printf("Welcome to the C Fitness Tracker!\n");
  printf("Let's get started! Enter your name: ");
  scanf("%s", v9);
  printf("Hi %s, let's start tracking your workouts!\n", v9);
  while ( 1 )
  {
    printf("\nWhich exercise would you like to track?\n");
    printf("1. Push-Ups\n");
    printf("2. Squats\n");
    printf("3. Sit-Ups\n");
    printf("4. Burpees\n");
    printf("5. Quit\n");
    scanf("%d", &v8);
    switch ( v8 )
    {
      case 1:
        printf("Enter the number of push-ups you did: ");
        scanf("%d", &v7);
        v13 += v7;
        printf("Total push-ups: %d", v13);
        break;
      case 2:
        printf("Enter the number of squats you did: ");
        scanf("%d", &v6);
        v12 += v6;
        printf("Total squats: %d", v12);
        break;
      case 3:
        printf("Enter the number of sit-ups you did: ");
        scanf("%d", &v5);
        v11 += v5;
        printf("Total sit-ups: %d", v11);
        break;
      case 4:
        printf("Enter the number of burpees you did: ");
        scanf("%d", &v4);
        v10 += v4;
        printf("Total burpees: %d", v10);
        break;
      case 5:
        printf("Thanks for using the C Fitness Tracker! See you next time, %s!", v9);
        return 0;
      default:
        printf("Invalid choice!");
        break;
    }
  }
}
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File system simulation ; Style: Claude Shannon
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define constants for file system
#define MAX_FILES 100
#define MAX_NAME_LENGTH 20
#define MAX_CONTENT_LENGTH 500

// Define a struct for files
struct file {
    char name[MAX_NAME_LENGTH];
    char content[MAX_CONTENT_LENGTH];
};

// Define the file system
struct file_system {
    struct file files[MAX_FILES];
    int num_files;
};

// Function to create a new file
struct file create_file(char *name, char *content) {
    struct file new_file;
    strcpy(new_file.name, name);
    strcpy(new_file.content, content);
    return new_file;
}

int main() {
    // Create a new file system
    struct file_system my_files;
    my_files.num_files = 0;

    // Add some files to the file system
    my_files.files[0] = create_file("file1.txt", "This is the first file.");
    my_files.num_files++;
    my_files.files[1] = create_file("file2.txt", "This is the second file.");
    my_files.num_files++;

    // Print out the files in the file system
    for (int i = 0; i < my_files.num_files; i++) {
        printf("File %d:\n", i+1);
        printf("Name: %s\n", my_files.files[i].name);
        printf("Content: %s\n", my_files.files[i].content);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall create_file(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000164F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[528]; // [rsp+20h] [rbp-60h] BYREF
  char v5[520]; // [rsp+230h] [rbp+1B0h] BYREF
  char v6[520]; // [rsp+438h] [rbp+3B8h] BYREF
  int v7; // [rsp+CD50h] [rbp+CCD0h]
  int i; // [rsp+CD5Ch] [rbp+CCDCh]

  _main(argc, argv, envp);
  v7 = 0;
  create_file(v4, "file1.txt", "This is the first file.");
  qmemcpy(v5, v4, sizeof(v5));
  ++v7;
  create_file(v4, "file2.txt", "This is the second file.");
  qmemcpy(v6, v4, sizeof(v6));
  ++v7;
  for ( i = 0; i < v7; ++i )
  {
    printf("File %d:\n", (unsigned int)(i + 1));
    printf("Name: %s\n", &v5[520 * i]);
    printf("Content: %s\n", &v5[520 * i + 20]);
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall create_file(_QWORD, _QWORD, _QWORD);
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000164F: using guessed type char var_CB40[520];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mortgage Calculator ; Style: relaxed
#include <stdio.h>
#include <math.h>

int main() {
    float loan_amount, interest_rate, monthly_payment;
    int num_months;
    
    printf("Welcome to the Mortgage Calculator!\n");
    
    printf("Please enter the loan amount: ");
    scanf("%f", &loan_amount);
    
    printf("Please enter the interest rate (in percentage): ");
    scanf("%f", &interest_rate);
    
    printf("Please enter the number of months for the loan term: ");
    scanf("%d", &num_months);
    
    // Calculating monthly interest rate
    float monthly_interest_rate = (interest_rate / 100) / 12;
    
    float numerator = monthly_interest_rate * pow(1 + monthly_interest_rate, num_months);
    float denominator = pow(1 + monthly_interest_rate, num_months) - 1;
    
    monthly_payment = loan_amount * (numerator / denominator);
    
    printf("\nFor a loan amount of %.2f, an interest rate of %.2f%%\n", loan_amount, interest_rate);
    printf("and a loan term of %d months, your monthly payment is: $%.2f\n", num_months, monthly_payment);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm6_8
  float v4; // xmm0_4
  float v5; // xmm0_4
  unsigned int v7; // [rsp+24h] [rbp-1Ch] BYREF
  float v8; // [rsp+28h] [rbp-18h] BYREF
  float v9; // [rsp+2Ch] [rbp-14h] BYREF
  float v10; // [rsp+30h] [rbp-10h]
  float v11; // [rsp+34h] [rbp-Ch]
  float v12; // [rsp+38h] [rbp-8h]
  float v13; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Mortgage Calculator!\n");
  printf("Please enter the loan amount: ");
  scanf("%f", &v9);
  printf("Please enter the interest rate (in percentage): ");
  scanf("%f", &v8);
  printf("Please enter the number of months for the loan term: ");
  scanf("%d", &v7);
  v13 = (float)(v8 / 100.0) / 12.0;
  v3 = v13;
  v4 = pow((float)(v13 + 1.0), (double)(int)v7) * v3;
  v12 = v4;
  v5 = pow((float)(v13 + 1.0), (double)(int)v7) - 1.0;
  v11 = v5;
  v10 = v9 * (float)(v12 / v5);
  printf("\nFor a loan amount of %.2f, an interest rate of %.2f%%\n", v9, v8);
  printf("and a loan term of %d months, your monthly payment is: $%.2f\n", v7, v10);
  return 0;
}
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: modular
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

#define MAX_BUFFER_SIZE 1024

//Struct represents XML tag
typedef struct XMLtag {
    char* tagName;
    struct Attributes* attributeList;
    struct XMLtag* childList;
    char* text;
} XMLtag;

//Struct represents XML attribute
typedef struct Attribute {
    char* name;
    char* value;
    struct Attribute* next;
} Attribute;

//Function to parse XML string and return the root tag
XMLtag* parseXML(char* xmlString);

//Function to create new XML tag
XMLtag* createXMLtag(char* tagName, Attribute* attributeList, char* text, XMLtag* childList);

//Function to create new XML attribute
Attribute* createAttribute(char* attributeName, char* attributeValue);

//Function to print XML tag
void printXMLtag(XMLtag* tag);

//Function to print XML attribute
void printAttribute(Attribute* attr);

//Driver code
int main() {

    //Sample XML String
    char xmlString[MAX_BUFFER_SIZE] = "<person name=\"John\"><age>28</age><occupation>Software Engineer</occupation></person>";

    //Parse the xml string
    XMLtag* rootTag = parseXML(xmlString);

    //Print the root tag
    printXMLtag(rootTag);

    return 0;
}

//Function to parse the XML string recursively and return root tag
XMLtag* parseXML(char* xmlString) {
    int length = strlen(xmlString);
    int i = 0;

    //Skip until the first opening tag
    while (xmlString[i] != '<' && i < length) {
        i++;
    }

    //Find the tag name
    char* tagName = (char*)malloc(MAX_BUFFER_SIZE);
    int j = i + 1;
    while (xmlString[j] != ' ' && xmlString[j] != '>' && j < length) {
        tagName[j - i - 1] = xmlString[j];
        j++;
    }
    tagName[j - i - 1] = '\0';

    //Find the attributes
    Attribute* attributeList = NULL;
    while (xmlString[j] != '>' && j < length) {
        char* attributeName = (char*)malloc(MAX_BUFFER_SIZE);
        char* attributeValue = (char*)malloc(MAX_BUFFER_SIZE);

        while (xmlString[j] != '=' && xmlString[j] != '>' && j < length) {
            j++;
        }

        if (xmlString[j] == '>') {
            break;
        }

        j++;

        //Extract the attribute name
        int k = 0;
        while (xmlString[j] != '=' && j < length) {
            attributeName[k++] = xmlString[j++];
        }
        attributeName[k] = '\0';

        j++;

        //Extract the attribute value
        k = 0;
        while (xmlString[j] != '\"' && j < length) {
            j++;
        }

        j++;
        while (xmlString[j] != '\"' && j < length) {
            attributeValue[k++] = xmlString[j++];
        }
        attributeValue[k] = '\0';

        Attribute* newAttribute = createAttribute(attributeName, attributeValue);
        if (attributeList == NULL) {
            attributeList = newAttribute;
        }
        else {
            Attribute* temp = attributeList;
            while (temp->next != NULL) {
                temp = temp->next;
            }
            temp->next = newAttribute;
        }
        j++;
    }

    j++;

    //Find the text
    char* text = (char*)malloc(MAX_BUFFER_SIZE);
    int k = 0;
    while (xmlString[j] != '<' && j < length) {
        text[k++] = xmlString[j++];
    }
    text[k] = '\0';

    //Find the child tags
    XMLtag* childList = NULL;
    int nestedTagCounter = 0;
    int start = j;
    int end = -1;

    while (j < length) {
        if (xmlString[j] == '<') {
            if (xmlString[j + 1] == '/') {
                //End tag
                if (nestedTagCounter == 0) {
                    end = j - 1;
                    break;
                }
                else {
                    nestedTagCounter--;
                    j++;
                }
            }
            else {
                //Start tag
                if (nestedTagCounter == 0) {
                    end = j - 1;

                    char* childXMLstring = (char*)malloc(MAX_BUFFER_SIZE);
                    strncpy(childXMLstring, &xmlString[start], end - start + 1);
                    childXMLstring[end - start + 1] = '\0';
                    XMLtag* childTag = parseXML(childXMLstring);

                    if (childList == NULL) {
                        childList = childTag;
                    }
                    else {
                        XMLtag* temp = childList;
                        while (temp->childList != NULL) {
                            temp = temp->childList;
                        }
                        temp->childList = childTag;
                    }
                    start = j;
                    nestedTagCounter++;
                }
                else {
                    nestedTagCounter++;
                }
                j++;
            }
        }
        else {
            j++;
        }
    }

    //Create the tag
    char* tagText = NULL;
    if (end != -1) {
        tagText = (char*)malloc(MAX_BUFFER_SIZE);
        strncpy(tagText, &xmlString[start], end - start + 1);
        tagText[end - start + 1] = '\0';
    }
    else {
        tagText = (char*)malloc(strlen(text) + 1);
        strcpy(tagText, text);
    }

    XMLtag* tag = createXMLtag(tagName, attributeList, tagText, childList);
    return tag;
}

//Function to create new XML tag
XMLtag* createXMLtag(char* tagName, Attribute* attributeList, char* text, XMLtag* childList) {
    XMLtag* tag = (XMLtag*)malloc(sizeof(XMLtag));
    tag->tagName = (char*)malloc(strlen(tagName) + 1);
    strcpy(tag->tagName, tagName);
    tag->attributeList = attributeList;
    tag->childList = childList;
    tag->text = (char*)malloc(strlen(text) + 1);
    strcpy(tag->text, text);
    return tag;
}

//Function to create new XML attribute
Attribute* createAttribute(char* attributeName, char* attributeValue) {
    Attribute* attribute = (Attribute*)malloc(sizeof(Attribute));
    attribute->name = (char*)malloc(strlen(attributeName) + 1);
    strcpy(attribute->name, attributeName);
    attribute->value = (char*)malloc(strlen(attributeValue) + 1);
    strcpy(attribute->value, attributeValue);
    attribute->next = NULL;
    return attribute;
}

//Function to print XML tag
void printXMLtag(XMLtag* tag) {
    printf("<%s ", tag->tagName);
    Attribute* tempAttr = tag->attributeList;
    while (tempAttr != NULL) {
        printAttribute(tempAttr);
        tempAttr = tempAttr->next;
    }
    printf(">");

    if (tag->childList == NULL) {
        printf("%s", tag->text);
    }
    else {
        printf("\n");
        XMLtag* tempTag = tag->childList;
        while (tempTag != NULL) {
            printXMLtag(tempTag);
            tempTag = tempTag->childList;
        }
        printf("\n");
    }

    printf("</%s>\n", tag->tagName);
}

//Function to print XML attribute
void printAttribute(Attribute* attr) {
    printf("%s=\"%s\" ", attr->name, attr->value);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall parseXML(_QWORD, _QWORD); // weak
__int64 __fastcall printXMLtag(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _WORD v4[44]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5; // [rsp+78h] [rbp-8h]
  _BYTE v6[936]; // [rsp+80h] [rbp+0h] BYREF
  __int64 v7; // [rsp+428h] [rbp+3A8h]

  _main(argc, argv, envp);
  strcpy((char *)v4, "<person name=\"John\"><age>28</age><occupation>Software Engineer</occupation></person>");
  HIBYTE(v4[42]) = 0;
  v4[43] = 0;
  v5 = 0i64;
  memset(v6, 0, 0x3A0ui64);
  v7 = parseXML(v4, v6);
  printXMLtag(v7);
  return 0;
}
// 140001687: using guessed type __int64 __fastcall parseXML(_QWORD, _QWORD);
// 140001D0F: using guessed type __int64 __fastcall printXMLtag(_QWORD);
// 140001EF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: User Input Sanitizer ; Style: multiplayer
#include <stdio.h>
#include <string.h>

void sanitize(char input[50]){
    int i, j=0;
    char temp[50];

    for(i=0;input[i]!='\0';i++){
        // Check if input character is alphanumeric or a space
        if(isalnum(input[i]) || input[i]==' '){
            temp[j] = input[i];
            j++;
        }
    }

    temp[j] = '\0'; // Add null character at the end of sanitized string
    strcpy(input, temp); // Copy sanitized string back to original input string
}

int main(){
    char player1_input[50], player2_input[50];

    printf("Welcome to Sanitize It! A multiplayer input sanitizer game.\n\n");
    printf("Player 1 enter your input (less than 50 characters): ");
    fgets(player1_input, 50, stdin);
    sanitize(player1_input);

    printf("Player 2 enter your input (less than 50 characters): ");
    fgets(player2_input, 50, stdin);
    sanitize(player2_input);

    printf("\nPlayer 1's sanitized input: %s\n", player1_input);
    printf("Player 2's sanitized input: %s\n", player2_input);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall sanitize(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001635) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char v6[64]; // [rsp+20h] [rbp-80h] BYREF
  char Buffer[64]; // [rsp+60h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to Sanitize It! A multiplayer input sanitizer game.\n\n");
  printf("Player 1 enter your input (less than 50 characters): ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 50, v3);
  sanitize(Buffer);
  printf("Player 2 enter your input (less than 50 characters): ");
  v4 = __acrt_iob_func(0);
  fgets(v6, 50, v4);
  sanitize(v6);
  printf("\nPlayer 1's sanitized input: %s\n", Buffer);
  printf("Player 2's sanitized input: %s\n", v6);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall sanitize(_QWORD);
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System boot optimizer ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init() {
    printf("Starting the System Boot Optimizer.\n");
}

void scan_boot_files() {
    printf("Scanning system boot files...\n");
}

void optimize_boot_files() {
    printf("Optimizing system boot files...\n");
}

void fix_errors() {
    printf("Fixing errors in system boot files...\n");
}

void defrag() {
    printf("Defragmenting system boot files...\n");
}

int main() {
    init();
    scan_boot_files();
    optimize_boot_files();
    fix_errors();
    defrag();

    printf("System Boot Optimizer is complete.\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 init(void); // weak
__int64 scan_boot_files(void); // weak
__int64 optimize_boot_files(void); // weak
__int64 fix_errors(void); // weak
__int64 defrag(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001627) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  init();
  scan_boot_files();
  optimize_boot_files();
  fix_errors();
  defrag();
  printf("System Boot Optimizer is complete.\n");
  return 0;
}
// 140001591: using guessed type __int64 init(void);
// 1400015AF: using guessed type __int64 scan_boot_files(void);
// 1400015CD: using guessed type __int64 optimize_boot_files(void);
// 1400015EB: using guessed type __int64 fix_errors(void);
// 140001609: using guessed type __int64 defrag(void);
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to ASCII art generator ; Style: systematic
#include <stdio.h>

// Define the height and width of the art
#define ART_HEIGHT 5
#define ART_WIDTH 10

// Define the ASCII characters used to draw the art
#define ART_BLANK ' '
#define ART_FILL '-'
#define ART_BORDER '|'

int main() {
    // Declare and initialize the art character array
    char art[ART_HEIGHT][ART_WIDTH] = { { ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL },
                                         { ART_FILL, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_FILL },
                                         { ART_FILL, ART_BORDER, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BORDER, ART_FILL },
                                         { ART_FILL, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_FILL },
                                         { ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL } };

    // Draw the art
    for (int row = 0; row < ART_HEIGHT; row++) {
        for (int col = 0; col < ART_WIDTH; col++) {
            printf("%c", art[row][col]);
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[7]; // [rsp+20h] [rbp-40h] BYREF
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]
  __int64 savedregs; // [rsp+60h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v4, "-----------        --|      |--        -----------", 50);
  for ( i = 0; i <= 4; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      printf("%c", (unsigned int)*((char *)&savedregs + 10 * i + j - 64));
    printf("\n");
  }
  return 0;
}
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data structures visualization ; Style: statistical
// C Data Structures Visualization Example Program

#include <stdio.h>
#include <stdlib.h>

// Define the Inverted Triangle Struct
typedef struct {
    int size;       // Size of the triangle
    char fillChar;  // Character to fill the triangle with
} InvertedTriangle;

// Define the Statistics Struct
typedef struct {
    int max;        // Maximum value in the dataset
    int min;        // Minimum value in the dataset
    float avg;      // Average value in the dataset
} Statistics;

// Function to create a new Inverted Triangle
InvertedTriangle* createInvertedTriangle(int size, char fillChar) {
    InvertedTriangle* triangle = malloc(sizeof(InvertedTriangle));
    triangle->size = size;
    triangle->fillChar = fillChar;

    return triangle;
}

// Function to print the Inverted Triangle
void printInvertedTriangle(InvertedTriangle* triangle) {
    int spacesBefore = triangle->size - 1;
    int stars = 1;

    for (int i = 0; i < triangle->size; i++) {
        for (int j = 0; j < spacesBefore; j++) {
            printf(" ");
        }

        for (int j = 0; j < stars; j++) {
            printf("%c", triangle->fillChar);
        }

        printf("\n");

        spacesBefore--;
        stars += 2;
    }
}

// Function to create a new Statistics Struct
Statistics* createStatistics(int* dataset, int size) {
    Statistics* stats = malloc(sizeof(Statistics));
    int sum = 0;
    int max = dataset[0];
    int min = dataset[0];

    for (int i = 0; i < size; i++) {
        sum += dataset[i];

        if (dataset[i] > max) {
            max = dataset[i];
        }

        if (dataset[i] < min) {
            min = dataset[i];
        }
    }

    stats->max = max;
    stats->min = min;
    stats->avg = (float) sum / size;

    return stats;
}

// Function to print the Statistics Struct
void printStatistics(Statistics* stats) {
    printf("Maximum value: %d\n", stats->max);
    printf("Minimum value: %d\n", stats->min);
    printf("Average value: %.2f\n", stats->avg);
}

int main() {
    // Create an Inverted Triangle and print it
    InvertedTriangle* triangle = createInvertedTriangle(5, '*');
    printf("Inverted Triangle:\n");
    printInvertedTriangle(triangle);
    printf("\n");

    // Create a dataset and calculate the statistics
    int dataset[5] = {5, 10, 15, 20, 25};
    Statistics* stats = createStatistics(dataset, 5);

    // Print the statistics
    printf("Statistics:\n");
    printStatistics(stats);
    printf("\n");

    // Free the memory
    free(triangle);
    free(stats);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall createInvertedTriangle(_QWORD, _QWORD); // weak
__int64 __fastcall printInvertedTriangle(_QWORD); // weak
__int64 __fastcall createStatistics(_QWORD, _QWORD); // weak
__int64 __fastcall printStatistics(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (00000001400017F9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[8]; // [rsp+20h] [rbp-30h] BYREF
  void *Statistics; // [rsp+40h] [rbp-10h]
  void *Block; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  Block = (void *)createInvertedTriangle(5i64, 42i64);
  printf("Inverted Triangle:\n");
  printInvertedTriangle(Block);
  printf("\n");
  v4[0] = 5;
  v4[1] = 10;
  v4[2] = 15;
  v4[3] = 20;
  v4[4] = 25;
  Statistics = (void *)createStatistics(v4, 5i64);
  printf("Statistics:\n");
  printStatistics(Statistics);
  printf("\n");
  free(Block);
  free(Statistics);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall createInvertedTriangle(_QWORD, _QWORD);
// 1400015CD: using guessed type __int64 __fastcall printInvertedTriangle(_QWORD);
// 140001678: using guessed type __int64 __fastcall createStatistics(_QWORD, _QWORD);
// 140001787: using guessed type __int64 __fastcall printStatistics(_QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Tower of Hanoi Problem ; Style: real-life
#include <stdio.h>

void move(char from, char to)
{
    printf("Move a disk from %c to %c\n", from, to);
}

void towerOfHanoi(int n, char source, char temp, char destination)
{
    if (n == 1)
    {
        move(source, destination);
        return;
    }
    towerOfHanoi(n - 1, source, destination, temp);
    move(source, destination);
    towerOfHanoi(n - 1, temp, source, destination);
}

int main()
{
    int numDisks;
    printf("Welcome to the Tower of Hanoi problem!\n");
    printf("Please enter the number of disks: ");
    scanf("%d", &numDisks);
    if (numDisks > 0)
    {
        printf("\nYour moves for solving this puzzle are:\n");
        towerOfHanoi(numDisks, 'A', 'B', 'C');
    }
    else
    {
        printf("Invalid input. Number of disks must be greater than 0.\n");
        return 1;
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall towerOfHanoi(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000169A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Tower of Hanoi problem!\n");
  printf("Please enter the number of disks: ");
  scanf("%d", &v4);
  if ( (int)v4 <= 0 )
  {
    printf("Invalid input. Number of disks must be greater than 0.\n");
    return 1;
  }
  else
  {
    printf("\nYour moves for solving this puzzle are:\n");
    towerOfHanoi(v4, 65i64, 66i64, 67i64);
    return 0;
  }
}
// 140001617: using guessed type __int64 __fastcall towerOfHanoi(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: Cryptic
/*Cryptic Pixel Art Generator*/
#include<stdio.h>
#include<time.h>

int main(){
    srand(time(NULL));
    int i,j,k,l,t,m,n,o,x,y,a,b,c,d,e,f,g,h;
    char pixel[16][16];
    printf("Welcome to the Cryptic Pixel Art Generator!\n");
    printf("Generating Pixel Art...\n");
    for(i=0;i<16;i++){
        for(j=0;j<16;j++){
            pixel[i][j] = '.';
        }
    }
    for(k=0;k<4;k++){
        t = rand()%16;
        m = rand()%16;
        n = rand()%16;
        o = rand()%16;
        for(l=0;l<16;l++){
            pixel[l][t] = '=';
            pixel[t][l] = '=';
            pixel[l][m] = '?';
            pixel[m][l] = '?';
            pixel[l][n] = '*';
            pixel[n][l] = '*';
            pixel[l][o] = '#';
            pixel[o][l] = '#';
        }
    }
    for(x=0;x<2;x++){
        a = rand()%16;
        b = rand()%16;
        c = rand()%16;
        d = rand()%16;
        for(y=0;y<16;y++){
            pixel[y][a] = '|';
            pixel[a][y] = '|';
            pixel[y][b] = '.';
            pixel[b][y] = '.';
            pixel[y][c] = '+';
            pixel[c][y] = '+';
            pixel[y][d] = '-';
            pixel[d][y] = '-';
        }
    }
    printf("Your Cryptic Pixel Art:\n\n");
    for(e=0;e<16;e++){
        for(f=0;f<16;f++){
            printf("%c ", pixel[e][f]);
        }
        printf("\n");
    }
    printf("\nHave fun deciphering the art!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  _OWORD v5[10]; // [rsp+80h] [rbp+0h] BYREF
  int v6; // [rsp+120h] [rbp+A0h]
  int v7; // [rsp+124h] [rbp+A4h]
  int v8; // [rsp+128h] [rbp+A8h]
  int v9; // [rsp+12Ch] [rbp+ACh]
  int v10; // [rsp+130h] [rbp+B0h]
  int v11; // [rsp+134h] [rbp+B4h]
  int v12; // [rsp+138h] [rbp+B8h]
  int v13; // [rsp+13Ch] [rbp+BCh]
  int kk; // [rsp+140h] [rbp+C0h]
  int jj; // [rsp+144h] [rbp+C4h]
  int ii; // [rsp+148h] [rbp+C8h]
  int n; // [rsp+14Ch] [rbp+CCh]
  int m; // [rsp+150h] [rbp+D0h]
  int k; // [rsp+154h] [rbp+D4h]
  int j; // [rsp+158h] [rbp+D8h]
  int i; // [rsp+15Ch] [rbp+DCh]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Cryptic Pixel Art Generator!\n");
  printf("Generating Pixel Art...\n");
  for ( i = 0; i <= 15; ++i )
  {
    for ( j = 0; j <= 15; ++j )
      *((_BYTE *)&v5[i - 6] + j) = 46;
  }
  for ( k = 0; k <= 3; ++k )
  {
    v9 = rand() % 16;
    v8 = rand() % 16;
    v7 = rand() % 16;
    v6 = rand() % 16;
    for ( m = 0; m <= 15; ++m )
    {
      *((_BYTE *)&v5[m - 6] + v9) = 61;
      *((_BYTE *)&v5[v9 - 6] + m) = 61;
      *((_BYTE *)&v5[m - 6] + v8) = 63;
      *((_BYTE *)&v5[v8 - 6] + m) = 63;
      *((_BYTE *)&v5[m - 6] + v7) = 42;
      *((_BYTE *)&v5[v7 - 6] + m) = 42;
      *((_BYTE *)&v5[m - 6] + v6) = 35;
      *((_BYTE *)&v5[v6 - 6] + m) = 35;
    }
  }
  for ( n = 0; n <= 1; ++n )
  {
    v13 = rand() % 16;
    v12 = rand() % 16;
    v11 = rand() % 16;
    v10 = rand() % 16;
    for ( ii = 0; ii <= 15; ++ii )
    {
      *((_BYTE *)&v5[ii - 6] + v13) = 124;
      *((_BYTE *)&v5[v13 - 6] + ii) = 124;
      *((_BYTE *)&v5[ii - 6] + v12) = 46;
      *((_BYTE *)&v5[v12 - 6] + ii) = 46;
      *((_BYTE *)&v5[ii - 6] + v11) = 43;
      *((_BYTE *)&v5[v11 - 6] + ii) = 43;
      *((_BYTE *)&v5[ii - 6] + v10) = 45;
      *((_BYTE *)&v5[v10 - 6] + ii) = 45;
    }
  }
  printf("Your Cryptic Pixel Art:\n\n");
  for ( jj = 0; jj <= 15; ++jj )
  {
    for ( kk = 0; kk <= 15; ++kk )
      printf("%c ", (unsigned int)*((char *)&v5[jj - 6] + kk));
    printf("\n");
  }
  printf("\nHave fun deciphering the art!\n");
  return 0;
}
// 140001BB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Robot movement control ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_MOVES 20

int main()
{
    srand(time(NULL));
    int moves[MAX_MOVES];
    int i, moveCount;

    // generate random moves
    for(i=0; i<MAX_MOVES; i++)
    {
        moves[i] = rand()%4; //randomly choose 0-3 for up, down, left, right respectively 
    }

    printf("The robot will perform the following moves:\n");
    for(i=0; i<MAX_MOVES; i++)
    {
        switch(moves[i])
        {
            case 0:
                printf("Up\n");
                break;
            case 1:
                printf("Down\n");
                break;
            case 2:
                printf("Left\n");
                break;
            case 3:
                printf("Right\n");
                break;
        }
    }

    // execute moves
    int xPos = 0, yPos = 0; //starting position
    moveCount = 0;
    while(moveCount < MAX_MOVES)
    {
        switch(moves[moveCount])
        {
            case 0: //up
                yPos++;
                break;
            case 1: //down
                yPos--;
                break;
            case 2: //left
                xPos--;
                break;
            case 3: //right
                xPos++;
                break;
        }
        moveCount++;
        printf("(%d, %d)\n", xPos, yPos); //output new position after each move
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax
  int v5; // eax
  int v7[20]; // [rsp+20h] [rbp-60h]
  unsigned int v8; // [rsp+70h] [rbp-10h]
  unsigned int v9; // [rsp+74h] [rbp-Ch]
  int v10; // [rsp+78h] [rbp-8h]
  int i; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 19; ++i )
    v7[i] = rand() % 4;
  printf("The robot will perform the following moves:\n");
  for ( i = 0; i <= 19; ++i )
  {
    v4 = v7[i];
    if ( v4 == 3 )
    {
      printf("Right\n");
    }
    else if ( v4 <= 3 )
    {
      if ( v4 == 2 )
      {
        printf("Left\n");
      }
      else if ( v4 )
      {
        if ( v4 == 1 )
          printf("Down\n");
      }
      else
      {
        printf("Up\n");
      }
    }
  }
  v9 = 0;
  v8 = 0;
  v10 = 0;
  while ( v10 <= 19 )
  {
    v5 = v7[v10];
    if ( v5 == 3 )
    {
      ++v9;
    }
    else if ( v5 <= 3 )
    {
      if ( v5 == 2 )
      {
        --v9;
      }
      else if ( v5 )
      {
        if ( v5 == 1 )
          --v8;
      }
      else
      {
        ++v8;
      }
    }
    ++v10;
    printf("(%d, %d)\n", v9, v8);
  }
  return 0;
}
// 14000162F: conditional instruction was optimized away because eax.4<2
// 1400016BB: conditional instruction was optimized away because eax.4<2
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type int var_60[20];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: grateful
#include <stdio.h>
#include <stdlib.h>

int main() {

  printf("Welcome to my unique C Memory management program!\n");

  // Allocating memory for an array of integers with the help of malloc() function
  int *ptr;
  ptr = (int*)malloc(5*sizeof(int)); // Allocating memory for 5 integers

  if(ptr == NULL) {
    printf("Memory allocation failed. Exiting the program...\n");
    exit(0);
  }

  printf("Memory allocation for 5 integers successful. Enter the values of the array:\n");

  // Taking user input to fill the array with values
  for(int i=0; i<5; i++) {
    scanf("%d", &ptr[i]);
  }

  // Displaying the elements of the array
  printf("Array elements entered by the user:\n");
  for(int i=0; i<5; i++) {
    printf("%d\n", ptr[i]);
  }

  // Reallocating memory for the array with the help of realloc() function
  int *ptr_new;
  ptr_new = (int*)realloc(ptr, 10*sizeof(int)); // Resizing the array to fit 10 integers

  if(ptr_new == NULL) {
    printf("Memory reallocation failed. Exiting the program...\n");
    free(ptr); // Freeing up the previously allocated memory before exiting
    exit(0);
  }

  printf("Memory reallocation for 5 more integers successful. Enter the values of the expanded array:\n");

  // Taking user input to fill the expanded array with values
  for(int i=5; i<10; i++) {
    scanf("%d", &ptr_new[i]);
  }

  // Displaying the elements of the expanded array
  printf("Expanded array elements entered by the user:\n");
  for(int i=0; i<10; i++) {
    printf("%d\n", ptr_new[i]);
  }

  // Freeing up the allocated memory before exiting the program
  free(ptr_new);
  printf("Memory has been freed up successfully. Exiting the program...\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v4; // [rsp+20h] [rbp-20h]
  char *Block; // [rsp+28h] [rbp-18h]
  int m; // [rsp+30h] [rbp-10h]
  int k; // [rsp+34h] [rbp-Ch]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to my unique C Memory management program!\n");
  Block = (char *)malloc(0x14ui64);
  if ( !Block )
  {
    printf("Memory allocation failed. Exiting the program...\n");
    exit(0);
  }
  printf("Memory allocation for 5 integers successful. Enter the values of the array:\n");
  for ( i = 0; i <= 4; ++i )
    scanf("%d", &Block[4 * i]);
  printf("Array elements entered by the user:\n");
  for ( j = 0; j <= 4; ++j )
    printf("%d\n", *(unsigned int *)&Block[4 * j]);
  v4 = (char *)realloc(Block, 0x28ui64);
  if ( !v4 )
  {
    printf("Memory reallocation failed. Exiting the program...\n");
    free(Block);
    exit(0);
  }
  printf("Memory reallocation for 5 more integers successful. Enter the values of the expanded array:\n");
  for ( k = 5; k <= 9; ++k )
    scanf("%d", &v4[4 * k]);
  printf("Expanded array elements entered by the user:\n");
  for ( m = 0; m <= 9; ++m )
    printf("%d\n", *(unsigned int *)&v4[4 * m]);
  free(v4);
  printf("Memory has been freed up successfully. Exiting the program...\n");
  return 0;
}
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: decentralized
/*

The following C program simulates percolation in a decentralized way.
The program creates a 2D percolation grid of size n x n.
Each grid cell is either filled (1) or empty (0).
The system percolates when there is a connected path of filled cells from the top row to the bottom row.
The program uses union-find algorithm to connect grid cells in a decentralized way.

*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_GRID_SIZE 100

int n;  // size of grid
int grid[MAX_GRID_SIZE][MAX_GRID_SIZE];  // 2D grid for percolation
int parent[MAX_GRID_SIZE * MAX_GRID_SIZE];
int size[MAX_GRID_SIZE * MAX_GRID_SIZE];
int top_root, bottom_root;  // virtual roots for top and bottom rows
int num_open_sites = 0;  // number of open sites in grid

// function to initialize the grid and parent array
// all cells are set to 0, and all parent index are set to -1
void initialize() {
  int i, j;
  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      grid[i][j] = 0;
    }
  }
  for (i = 0; i < n * n; i++) {
    parent[i] = -1;
    size[i] = 1;
  }
  top_root = n * n;
  bottom_root = n * n + 1;
}

// function to print the grid
void print_grid() {
  int i, j;
  printf("Grid:\n");
  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      printf("%d ", grid[i][j]);
    }
    printf("\n");
  }
}

// function to get the index of a cell in the 1D parent array
int get_index(int row, int col) {
  return row * n + col;
}

// function to check if a given cell is within the grid boundaries
int is_valid_cell(int row, int col) {
  if (row < 0 || row >= n || col < 0 || col >= n) {
    return 0;
  }
  return 1;
}

// function to connect two cells in the union-find structure
void connect_cells(int row1, int col1, int row2, int col2) {
  int index1 = get_index(row1, col1);
  int index2 = get_index(row2, col2);
  while (parent[index1] != -1) {
    index1 = parent[index1];
  }
  while (parent[index2] != -1) {
    index2 = parent[index2];
  }
  if (index1 != index2) {
    if (size[index1] >= size[index2]) {
      parent[index2] = index1;
      size[index1] += size[index2];
    } else {
      parent[index1] = index2;
      size[index2] += size[index1];
    }
  }
}

// function to check if two cells are connected
int is_connected(int row1, int col1, int row2, int col2) {
  int index1 = get_index(row1, col1);
  int index2 = get_index(row2, col2);
  while (parent[index1] != -1) {
    index1 = parent[index1];
  }
  while (parent[index2] != -1) {
    index2 = parent[index2];
  }
  if (index1 == index2) {
    return 1;
  }
  return 0;
}

// function to open a cell in the grid
void open_cell(int row, int col) {
  if (grid[row][col] == 0) {
    grid[row][col] = 1;
    num_open_sites++;
    int index = get_index(row, col);
    if (row == 0) {
      connect_cells(row, col, n, n);
    }
    if (row == n - 1) {
      connect_cells(row, col, n + 1, n + 1);
    }
    if (is_valid_cell(row - 1, col) && grid[row - 1][col] == 1) {
      connect_cells(row, col, row - 1, col);
    }
    if (is_valid_cell(row, col - 1) && grid[row][col - 1] == 1) {
      connect_cells(row, col, row, col - 1);
    }
    if (is_valid_cell(row, col + 1) && grid[row][col + 1] == 1) {
      connect_cells(row, col, row, col + 1);
    }
    if (is_valid_cell(row + 1, col) && grid[row + 1][col] == 1) {
      connect_cells(row, col, row + 1, col);
    }
  }
}

// function to check if the system percolates
int does_percolate() {
  return is_connected(n, n, n + 1, n + 1);
}

int main() {
  srand(time(NULL));
  printf("Enter the size of grid (maximum %d): ", MAX_GRID_SIZE);
  scanf("%d", &n);
  if (n > MAX_GRID_SIZE) {
    printf("Invalid grid size!\n");
    return 1;
  }
  initialize();
  while (!does_percolate()) {
    int row = rand() % n;
    int col = rand() % n;
    open_cell(row, col);
  }
  printf("Percolation achieved!\n");
  printf("Number of open sites: %d\n", num_open_sites);
  printf("Percolation grid:\n");
  print_grid();
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 initialize(void); // weak
__int64 print_grid(void); // weak
__int64 __fastcall open_cell(_QWORD, _QWORD); // weak
__int64 does_percolate(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();

//-------------------------------------------------------------------------
// Data declarations

int n; // weak
int num_open_sites; // weak


//----- (0000000140001D7F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+28h] [rbp-8h]
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Enter the size of grid (maximum %d): ", 100i64);
  scanf("%d", &n);
  if ( n <= 100 )
  {
    initialize();
    while ( !(unsigned int)does_percolate() )
    {
      v6 = rand() % n;
      v5 = rand() % n;
      open_cell(v6, v5);
    }
    printf("Percolation achieved!\n");
    printf("Number of open sites: %d\n", (unsigned int)num_open_sites);
    printf("Percolation grid:\n");
    print_grid();
    return 0;
  }
  else
  {
    printf("Invalid grid size!\n");
    return 1;
  }
}
// 140001601: using guessed type __int64 initialize(void);
// 140001702: using guessed type __int64 print_grid(void);
// 140001A75: using guessed type __int64 __fastcall open_cell(_QWORD, _QWORD);
// 140001D45: using guessed type __int64 does_percolate(void);
// 140001F20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019040: using guessed type int n;
// 140036528: using guessed type int num_open_sites;

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to Morse code conversion ; Style: scalable
#include <stdio.h>
#include <string.h>

// Function to convert a character to Morse code
char* convertToMorse(char c) {
    switch(c) {
        case 'a': 
            return ".-"; // Morse code for a
        case 'b':
            return "-..."; // Morse code for b
        case 'c':
            return "-.-."; // Morse code for c
        case 'd':
            return "-.."; // Morse code for d
        case 'e':
            return "."; // Morse code for e
        case 'f':
            return "..-."; // Morse code for f
        case 'g':
            return "--."; // Morse code for g
        case 'h':
            return "...."; // Morse code for h
        case 'i':
            return ".."; // Morse code for i
        case 'j':
            return ".---"; // Morse code for j
        case 'k':
            return "-.-"; // Morse code for k
        case 'l':
            return ".-.."; // Morse code for l
        case 'm':
            return "--"; // Morse code for m
        case 'n':
            return "-."; // Morse code for n
        case 'o':
            return "---"; // Morse code for o
        case 'p':
            return ".--."; // Morse code for p
        case 'q':
            return "--.-"; // Morse code for q
        case 'r':
            return ".-."; // Morse code for r
        case 's':
            return "..."; // Morse code for s
        case 't':
            return "-"; // Morse code for t
        case 'u':
            return "..-"; // Morse code for u
        case 'v':
            return "...-"; // Morse code for v
        case 'w':
            return ".--"; // Morse code for w
        case 'x':
            return "-..-"; // Morse code for x
        case 'y':
            return "-.--"; // Morse code for y
        case 'z':
            return "--.."; // Morse code for z
        case '0':
            return "-----"; // Morse code for 0
        case '1':
            return ".----"; // Morse code for 1
        case '2':
            return "..---"; // Morse code for 2
        case '3':
            return "...--"; // Morse code for 3
        case '4':
            return "....-"; // Morse code for 4
        case '5':
            return "....."; // Morse code for 5
        case '6':
            return "-...."; // Morse code for 6
        case '7':
            return "--..."; // Morse code for 7
        case '8':
            return "---.."; // Morse code for 8
        case '9':
            return "----."; // Morse code for 9
        case ' ':
            return "/"; // Morse code for space
        default:
            return ""; // Return empty string if character is not supported
    }
}

int main() {
    char message[1000]; // Maximum length of message is 1000 characters
    printf("Enter message to be converted to Morse code:\n");
    fgets(message, 1000, stdin); // Get input from user
    int messageLength=strlen(message); // Determine length of message

    printf("Morse code:\n");
    for(int i=0; i<messageLength; i++) {
        char c = tolower(message[i]); // Convert character to lowercase to match Morse code
        char* morseCode = convertToMorse(c); // Call function to convert character to Morse code
        printf("%s ", morseCode); // Print Morse code for character
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall convertToMorse(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl tolower(int C);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001767) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1000]; // [rsp+20h] [rbp-60h] BYREF
  const char *v6; // [rsp+408h] [rbp+388h]
  char v7; // [rsp+417h] [rbp+397h]
  int v8; // [rsp+418h] [rbp+398h]
  int i; // [rsp+41Ch] [rbp+39Ch]

  _main(argc, argv, envp);
  printf("Enter message to be converted to Morse code:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v8 = strlen(Buffer);
  printf("Morse code:\n");
  for ( i = 0; i < v8; ++i )
  {
    v7 = tolower(Buffer[i]);
    v6 = (const char *)convertToMorse((unsigned int)v7);
    printf("%s ", v6);
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall convertToMorse(_QWORD);
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001767: using guessed type char Buffer[1000];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Personal Finance Planner ; Style: thoughtful
#include <stdio.h>

int main() {
  // Declare variables
  float salary, expenses, savings, investment_percentage;
  int months;

  // Take user input
  printf("Enter your monthly salary: ");
  scanf("%f", &salary);
  printf("Enter your monthly expenses: ");
  scanf("%f", &expenses);

  // Calculate monthly savings
  savings = salary - expenses;

  // Display monthly savings
  printf("Your monthly savings is: $%.2f\n", savings);

  // Take user input for desired investment percentage
  printf("Enter the percentage of your savings you want to invest (e.g. 10 for 10%%): ");
  scanf("%f", &investment_percentage);

  // Convert investment percentage to decimal format
  investment_percentage /= 100;

  // Calculate amount to invest each month
  float investment = savings * investment_percentage;

  // Calculate projected savings after specified number of months
  printf("Enter the number of months you want to project your savings for: ");
  scanf("%d", &months);
  float projected_savings = savings * months;

  // Calculate projected investment earnings after specified number of months
  float projected_earnings = investment * months * 1.05; // assuming 5% annual interest rate

  // Display projection results
  printf("\nProjection Results:\n");
  printf("Savings after %d months: $%.2f\n", months, projected_savings);
  printf("Investment earnings after %d months: $%.2f\n", months, projected_earnings);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  unsigned int v5; // [rsp+20h] [rbp-20h] BYREF
  float v6; // [rsp+24h] [rbp-1Ch] BYREF
  float v7; // [rsp+28h] [rbp-18h] BYREF
  float v8; // [rsp+2Ch] [rbp-14h] BYREF
  float v9; // [rsp+30h] [rbp-10h]
  float v10; // [rsp+34h] [rbp-Ch]
  float v11; // [rsp+38h] [rbp-8h]
  float v12; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter your monthly salary: ");
  scanf("%f", &v8);
  printf("Enter your monthly expenses: ");
  scanf("%f", &v7);
  v12 = v8 - v7;
  printf("Your monthly savings is: $%.2f\n", (float)(v8 - v7));
  printf("Enter the percentage of your savings you want to invest (e.g. 10 for 10%%): ");
  scanf("%f", &v6);
  v6 = v6 / 100.0;
  v11 = v6 * v12;
  printf("Enter the number of months you want to project your savings for: ");
  scanf("%d", &v5);
  v10 = (float)(int)v5 * v12;
  v3 = 1.05 * (float)((float)(int)v5 * v11);
  v9 = v3;
  printf("\nProjection Results:\n");
  printf("Savings after %d months: $%.2f\n", v5, v10);
  printf("Investment earnings after %d months: $%.2f\n", v5, v9);
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Airport Baggage Handling Simulation ; Style: paranoid
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_BAGGAGE 1000
#define MAX_FLIGHTS 10
#define MAX_LOADERS 5
#define MAX_BELTS 5

int main() {
  srand(time(NULL)); // seed the random number generator

  int num_bags = rand() % MAX_BAGGAGE + 1; // randomly generate the number of bags
  printf("Number of bags: %d\n", num_bags);

  int num_flights = rand() % MAX_FLIGHTS + 1; // randomly generate the number of flights
  printf("Number of flights: %d\n\n", num_flights);

  int total_bags_loaded = 0; // initialize the total number of bags loaded

  // initialize the loaders and belts arrays
  int loaders[MAX_LOADERS] = {0};
  int belts[MAX_BELTS] = {0};

  // begin the simulation
  printf("Simulation starting...\n\n");

  for (int i = 1; i <= num_flights; i++) {
    printf("Flight %d arriving...\n", i);

    int bags_loaded = 0; // initialize the number of bags loaded on this flight

    for (int j = 0; j < MAX_LOADERS; j++) {
      if (loaders[j] == 0) { // if the loader is available
        printf("Loader %d is loading baggage...\n", j+1);

        // simulate loading bags onto the loader
        int bags_on_loader = rand() % 4 + 1;
        printf("Loader %d is loading %d bags.\n", j+1, bags_on_loader);

        // move the bags from the loader to the belts
        for (int k = 0; k < MAX_BELTS; k++) {
          if (belts[k] == 0) { // if the belt is available
            printf("Belt %d is moving bags...\n", k+1);

            // simulate moving bags from the loader to the belt
            int bags_on_belt = rand() % 3 + 1;
            printf("Belt %d is receiving %d bags.\n", k+1, bags_on_belt);

            // update the number of bags loaded and the total number of bags loaded
            bags_loaded += bags_on_belt;
            total_bags_loaded += bags_on_belt;

            // mark the loader and belt as busy
            loaders[j] = 1;
            belts[k] = 1;

            // break out of the loop once the bags have been moved
            break;
          }
        }

        // break out of the loop once the bags have been loaded onto the loader
        break;
      }
    }

    printf("Flight %d loaded with %d bags.\n\n", i, bags_loaded);
  }

  // output the results
  printf("Simulation complete.\nTotal number of bags loaded: %d\n", total_bags_loaded);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5[2]; // [rsp+20h] [rbp-60h]
  int v6; // [rsp+30h] [rbp-50h]
  __int64 v7[2]; // [rsp+40h] [rbp-40h]
  int v8; // [rsp+50h] [rbp-30h]
  unsigned int v9; // [rsp+5Ch] [rbp-24h]
  unsigned int v10; // [rsp+60h] [rbp-20h]
  int v11; // [rsp+64h] [rbp-1Ch]
  unsigned int v12; // [rsp+68h] [rbp-18h]
  int k; // [rsp+6Ch] [rbp-14h]
  int j; // [rsp+70h] [rbp-10h]
  unsigned int v15; // [rsp+74h] [rbp-Ch]
  unsigned int i; // [rsp+78h] [rbp-8h]
  unsigned int v17; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v12 = rand() % 1000 + 1;
  printf("Number of bags: %d\n", v12);
  v11 = rand() % 10 + 1;
  printf("Number of flights: %d\n\n", (unsigned int)v11);
  v17 = 0;
  v7[0] = 0i64;
  v7[1] = 0i64;
  v8 = 0;
  v5[0] = 0i64;
  v5[1] = 0i64;
  v6 = 0;
  printf("Simulation starting...\n\n");
  for ( i = 1; (int)i <= v11; ++i )
  {
    printf("Flight %d arriving...\n", i);
    v15 = 0;
    for ( j = 0; j <= 4; ++j )
    {
      if ( !*((_DWORD *)v7 + j) )
      {
        printf("Loader %d is loading baggage...\n", (unsigned int)(j + 1));
        v10 = rand() % 4 + 1;
        printf("Loader %d is loading %d bags.\n", (unsigned int)(j + 1), v10);
        for ( k = 0; k <= 4; ++k )
        {
          if ( !*((_DWORD *)v5 + k) )
          {
            printf("Belt %d is moving bags...\n", (unsigned int)(k + 1));
            v9 = rand() % 3 + 1;
            printf("Belt %d is receiving %d bags.\n", (unsigned int)(k + 1), v9);
            v15 += v9;
            v17 += v9;
            *((_DWORD *)v7 + j) = 1;
            *((_DWORD *)v5 + k) = 1;
            goto LABEL_12;
          }
        }
        break;
      }
    }
LABEL_12:
    printf("Flight %d loaded with %d bags.\n\n", i, v15);
  }
  printf("Simulation complete.\nTotal number of bags loaded: %d\n", v17);
  return 0;
}
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: statistical
#include <stdio.h>

int main() {
    printf("This program prints a unique C pattern in statistical style!\n");

    int rows = 15; // Change this value to adjust the size of the pattern
    int i, j, k;

    for (i = 1; i <= rows; i++) {
        printf("C\t"); // Prints the first column of the C pattern
        for (j = 1; j <= i; j++) {
            printf("*"); // Prints the asterisk at the bottom of the C pattern
        }
        for (k = i; k <= rows; k++) {
            printf(" "); // Prints spaces to form the left side of the C pattern
        }
        printf("*\n"); // Prints the last asterisk to complete the C pattern
    }

    for (i = rows; i >= 1; i--) {
        printf("C\t"); // Prints the first column of the C pattern
        for (j = 1; j <= i; j++) {
            printf("*"); // Prints the asterisk at the top of the C pattern
        }
        for (k = i; k <= rows; k++) {
            printf(" "); // Prints spaces to form the right side of the C pattern
        }
        printf("*\n"); // Prints the last asterisk to complete the C pattern
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int k; // [rsp+24h] [rbp-Ch]
  int ii; // [rsp+24h] [rbp-Ch]
  int j; // [rsp+28h] [rbp-8h]
  int n; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]
  int m; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("This program prints a unique C pattern in statistical style!\n");
  for ( i = 1; i <= 15; ++i )
  {
    printf("C\t");
    for ( j = 1; j <= i; ++j )
      printf("*");
    for ( k = i; k <= 15; ++k )
      printf(" ");
    printf("*\n");
  }
  for ( m = 15; m > 0; --m )
  {
    printf("C\t");
    for ( n = 1; n <= m; ++n )
      printf("*");
    for ( ii = m; ii <= 15; ++ii )
      printf(" ");
    printf("*\n");
  }
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Antivirus scanner ; Style: immersive
#include <stdio.h>
#include <string.h>

#define MAX_FILENAME_LENGTH 100
#define MAX_VIRUS_SIGNATURES 100

typedef struct {
    char signature[30];
    int length;
} virus_signature;

int main() {
    int num_virus_signatures;
    char filename[MAX_FILENAME_LENGTH];
    virus_signature virus_signatures[MAX_VIRUS_SIGNATURES];
    int scanned_file_size;
    char *scanned_file_content;

    printf("Welcome to the C Antivirus Scanner!\n");

    // Input virus signatures from the user
    printf("Enter the number of virus signatures: ");
    scanf("%d", &num_virus_signatures);

    printf("Enter the virus signatures one by one:\n");
    for(int i = 0; i < num_virus_signatures; i++) {
        printf("Virus signature %d: ", i + 1);
        scanf("%s", virus_signatures[i].signature);
        virus_signatures[i].length = strlen(virus_signatures[i].signature);
    }

    // Input the filename to scan
    printf("Enter the name of the file to scan: ");
    scanf("%s", filename);

    // Open the file and read its content
    FILE *file = fopen(filename, "rb");
    if(file == NULL) {
        printf("Error: Unable to open file!\n");
        return 1;
    }

    fseek(file, 0, SEEK_END);
    scanned_file_size = ftell(file);
    fseek(file, 0, SEEK_SET);

    scanned_file_content = (char *) malloc(scanned_file_size + 1);
    fread(scanned_file_content, scanned_file_size, 1, file);
    fclose(file);
    scanned_file_content[scanned_file_size] = '\0';

    // Scan the file for virus signatures
    int infected = 0;
    for(int i = 0; i < num_virus_signatures; i++) {
        char *match = strstr(scanned_file_content, virus_signatures[i].signature);
        if(match != NULL) {
            printf("Virus signature %d detected at position %d.\n", i + 1, (int) (match - scanned_file_content));
            infected = 1;
        }
    }

    // Print the result of the scan
    if(infected) {
        printf("The file '%s' is infected with a virus!\n", filename);
    } else {
        printf("The file '%s' is clean.\n", filename);
    }

    free(scanned_file_content);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// size_t __cdecl strlen(const char *Str);
// void *__cdecl malloc(size_t Size);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// void __cdecl free(void *Block);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[96]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5; // [rsp+80h] [rbp+0h] BYREF
  char FileName[108]; // [rsp+E30h] [rbp+DB0h] BYREF
  int v7; // [rsp+E9Ch] [rbp+E1Ch] BYREF
  char *v8; // [rsp+EA0h] [rbp+E20h]
  void *Buffer; // [rsp+EA8h] [rbp+E28h]
  int v10; // [rsp+EB4h] [rbp+E34h]
  FILE *Stream; // [rsp+EB8h] [rbp+E38h]
  int j; // [rsp+EC4h] [rbp+E44h]
  int v13; // [rsp+EC8h] [rbp+E48h]
  int i; // [rsp+ECCh] [rbp+E4Ch]

  _main(argc, argv, envp);
  printf("Welcome to the C Antivirus Scanner!\n");
  printf("Enter the number of virus signatures: ");
  scanf("%d", &v7);
  printf("Enter the virus signatures one by one:\n");
  for ( i = 0; i < v7; ++i )
  {
    printf("Virus signature %d: ", (unsigned int)(i + 1));
    scanf("%s", &v4[36 * i]);
    *((_DWORD *)&v5 + 9 * i - 16) = strlen(&v4[36 * i]);
  }
  printf("Enter the name of the file to scan: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "rb");
  if ( Stream )
  {
    fseek(Stream, 0, 2);
    v10 = ftell(Stream);
    fseek(Stream, 0, 0);
    Buffer = malloc(v10 + 1);
    fread(Buffer, v10, 1ui64, Stream);
    fclose(Stream);
    *((_BYTE *)Buffer + v10) = 0;
    v13 = 0;
    for ( j = 0; j < v7; ++j )
    {
      v8 = strstr((const char *)Buffer, &v4[36 * j]);
      if ( v8 )
      {
        printf(
          "Virus signature %d detected at position %d.\n",
          (unsigned int)(j + 1),
          (unsigned int)((_DWORD)v8 - (_DWORD)Buffer));
        v13 = 1;
      }
    }
    if ( v13 )
      printf("The file '%s' is infected with a virus!\n", FileName);
    else
      printf("The file '%s' is clean.\n", FileName);
    free(Buffer);
    return 0;
  }
  else
  {
    printf("Error: Unable to open file!\n");
    return 1;
  }
}
// 1400019D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_EB0[96];

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Encryption ; Style: complete
#include<stdio.h>
#include<string.h>

void encrypt(char* message, int key){

    int i;
    char ch;
    
    for(i=0; message[i] != '\0'; i++){

        ch = message[i];

        if(ch >= 'a' && ch <= 'z'){
            ch = ch + key;

            if(ch > 'z'){
                ch = ch - 'z' + 'a' - 1;
            }

            message[i] = ch;
        }
        else if(ch >= 'A' && ch <= 'Z'){
            ch = ch + key;

            if(ch > 'Z'){
                ch = ch - 'Z' + 'A' - 1;
            }

            message[i] = ch;
        }
    }

    printf("Encrypted message: %s\n", message);
}

void decrypt(char* message, int key){

    int i;
    char ch;

    for(i=0; message[i] != '\0'; i++){

        ch = message[i];

        if(ch >= 'a' && ch <= 'z'){
            ch = ch - key;

            if(ch < 'a'){
                ch = ch + 'z' - 'a' + 1;
            }

            message[i] = ch;
        }
        else if(ch >= 'A' && ch <= 'Z'){
            ch = ch - key;

            if(ch < 'A'){
                ch = ch + 'Z' - 'A' + 1;
            }

            message[i] = ch;
        }
    }

    printf("Decrypted message: %s\n", message);
}

int main(){

    char message[100];
    int key;

    printf("Enter message to encrypt: ");
    scanf("%s", message);

    printf("Enter key: ");
    scanf("%d", &key);

    encrypt(message, key);
    decrypt(message, key);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
__int64 __fastcall decrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000179E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-74h] BYREF
  char v5[112]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter message to encrypt: ");
  scanf("%s", v5);
  printf("Enter key: ");
  scanf("%d", &v4);
  encrypt(v5, v4);
  decrypt(v5, v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 1400016C2: using guessed type __int64 __fastcall decrypt(_QWORD, _QWORD);
// 1400018E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Checksum Calculator ; Style: lively
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

uint16_t calc_checksum(int data[], int len) {
    uint32_t sum = 0;
    for (int i = 0; i < len; i++) {
        sum += data[i];
    }

    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }

    return ~sum;
}

int main() {
    int n;
    printf("Enter the number of elements in the data: ");
    scanf("%d", &n);

    int* data = malloc(n * sizeof(int));
    printf("Enter the data: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &data[i]);
    }

    uint16_t checksum = calc_checksum(data, n);
    printf("Checksum: %04X\n", checksum);

    free(data);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall calc_checksum(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (000000014000164E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-18h] BYREF
  unsigned __int16 v5; // [rsp+2Eh] [rbp-12h]
  void *Block; // [rsp+30h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of elements in the data: ");
  scanf("%d", &v4);
  Block = malloc(4i64 * (int)v4);
  printf("Enter the data: ");
  for ( i = 0; i < (int)v4; ++i )
    scanf("%d", (char *)Block + 4 * i);
  v5 = calc_checksum(Block, v4);
  printf("Checksum: %04X\n", v5);
  free(Block);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall calc_checksum(_QWORD, _QWORD);
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000164E: using guessed type unsigned int var_18;

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_PRODUCTS 100
#define MAX_CLIENTS 50
#define MAX_ORDERS 500

typedef struct Product {
    char name[20];
    int quantity;
} Product;

typedef struct Client {
    char name[20];
    int id;
    int orderIDs[10];
    int numOrders;
} Client;

typedef struct Order {
    int id;
    int clientID;
    Product products[10];
    int numProducts;
} Order;

Product products[MAX_PRODUCTS];
Client clients[MAX_CLIENTS];
Order orders[MAX_ORDERS];
int numProducts = 0;
int numClients = 0;
int numOrders = 0;

void addProduct(char name[20], int quantity) {
    if (numProducts == MAX_PRODUCTS) {
        printf("Sorry, warehouse is full!\n");
        return;
    }
    Product newProduct;
    strcpy(newProduct.name, name);
    newProduct.quantity = quantity;
    products[numProducts] = newProduct;
    numProducts++;

    printf("New product added: %s\n", name);
}

void addClient(char name[20]) {
    if (numClients == MAX_CLIENTS) {
        printf("Sorry, clients list is full!\n");
        return;
    }
    Client newClient;
    strcpy(newClient.name, name);
    newClient.id = rand() % 1000 + 1;
    clients[numClients] = newClient;
    numClients++;

    printf("New client added: %s with ID: %d\n", name, newClient.id);
}

void placeOrder(int clientID, char productsList[10][20]) {
    if (numOrders == MAX_ORDERS) {
        printf("Sorry, order list is full!\n");
        return;
    }
    Order newOrder;
    newOrder.id = rand() % 10000 + 1;
    newOrder.clientID = clientID;

    for (int i = 0; i < 10; i++) {
        if (productsList[i][0] == '\0')
            break;

        int productFound = 0;
        for (int j = 0; j < numProducts; j++) {
            if (strcmp(productsList[i], products[j].name) == 0) {
                productFound = 1;
                if (products[j].quantity > 0) {
                    products[j].quantity--;
                    newOrder.products[newOrder.numProducts] = products[j];
                    newOrder.numProducts++;
                    break;
                }
                else {
                    printf("Product %s is out of stock!\n", products[j].name);
                    break;
                }
            }
        }
        if (!productFound)
            printf("Product %s does not exist in the warehouse!\n", productsList[i]);
    }

    if (newOrder.numProducts > 0) {
        orders[numOrders] = newOrder;
        numOrders++;
        clients[clientID].orderIDs[clients[clientID].numOrders] = newOrder.id;
        clients[clientID].numOrders++;
        printf("New order placed with ID: %d\n", newOrder.id);
    }
    else {
        printf("No products were ordered!\n");
    }
}

void printClients() {
    printf("--- CLIENTS LIST ---\n");

    for (int i = 0; i < numClients; i++) {
        printf("%s (ID: %d)\n", clients[i].name, clients[i].id);

        if (clients[i].numOrders > 0) {
            printf("Orders:");
            for (int j = 0; j < clients[i].numOrders; j++) {
                printf(" %d", clients[i].orderIDs[j]);
            }
            printf("\n");
        }
        else {
            printf("No orders found for this client.\n");
        }
    }

    printf("--------------------\n");
}

void printOrders() {
    printf("--- ORDERS LIST ---\n");

    for (int i = 0; i < numOrders; i++) {
        printf("Order ID: %d - Client ID: %d\n", orders[i].id, orders[i].clientID);

        for (int j = 0; j < orders[i].numProducts; j++) {
            printf("- %s\n", orders[i].products[j].name);
        }
    }

    printf("-------------------\n");
}

int main() {
    srand(time(0));

    printf("Welcome to the Funny Warehouse Management System!\n");

    while (1) {
        printf("\n");
        printf("Type 'add_product' to add a new product\n");
        printf("Type 'add_client' to add a new client\n");
        printf("Type 'place_order' to place a new order\n");
        printf("Type 'print_clients' to print the clients list\n");
        printf("Type 'print_orders' to print the orders list\n");
        printf("Type 'exit' to exit\n");

        char command[20];
        scanf("%s", command);

        if (strcmp(command, "add_product") == 0) {
            printf("Enter product name: ");
            char name[20];
            scanf("%s", name);
            printf("Enter quantity: ");
            int quantity;
            scanf("%d", &quantity);
            addProduct(name, quantity);
        }
        else if (strcmp(command, "add_client") == 0) {
            printf("Enter client name: ");
            char name[20];
            scanf("%s", name);
            addClient(name);
        }
        else if (strcmp(command, "place_order") == 0) {
            printf("Enter client ID: ");
            int clientID;
            scanf("%d", &clientID);
            printf("Enter products (comma separated): ");
            char productsList[10][20];
            char productsInput[100];
            scanf("%s", productsInput);
            char* product = strtok(productsInput, ",");
            int index = 0;
            while (product != NULL) {
                strcpy(productsList[index], product);
                index++;
                product = strtok(NULL, ",");
            }
            placeOrder(clientID, productsList);
        }
        else if (strcmp(command, "print_clients") == 0) {
            printClients();
        }
        else if (strcmp(command, "print_orders") == 0) {
            printOrders();
        }
        else if (strcmp(command, "exit") == 0) {
            printf("Goodbye!\n");
            break;
        }
        else {
            printf("Command not recognized, try again.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall addProduct(_QWORD, _QWORD); // weak
__int64 __fastcall addClient(_QWORD); // weak
__int64 __fastcall placeOrder(_QWORD, _QWORD); // weak
__int64 printClients(void); // weak
__int64 printOrders(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001E57) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char String[112]; // [rsp+20h] [rbp-60h] BYREF
  char v6[204]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v7; // [rsp+15Ch] [rbp+DCh] BYREF
  char v8[28]; // [rsp+160h] [rbp+E0h] BYREF
  unsigned int v9; // [rsp+17Ch] [rbp+FCh] BYREF
  char v10[32]; // [rsp+180h] [rbp+100h] BYREF
  char Str1[20]; // [rsp+1A0h] [rbp+120h] BYREF
  int v12; // [rsp+1B4h] [rbp+134h]
  char *Source; // [rsp+1B8h] [rbp+138h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Funny Warehouse Management System!\n");
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              printf("\n");
              printf("Type 'add_product' to add a new product\n");
              printf("Type 'add_client' to add a new client\n");
              printf("Type 'place_order' to place a new order\n");
              printf("Type 'print_clients' to print the clients list\n");
              printf("Type 'print_orders' to print the orders list\n");
              printf("Type 'exit' to exit\n");
              scanf("%s", Str1);
              if ( strcmp(Str1, "add_product") )
                break;
              printf("Enter product name: ");
              scanf("%s", v10);
              printf("Enter quantity: ");
              scanf("%d", &v9);
              addProduct(v10, v9);
            }
            if ( strcmp(Str1, "add_client") )
              break;
            printf("Enter client name: ");
            scanf("%s", v8);
            addClient(v8);
          }
          if ( strcmp(Str1, "place_order") )
            break;
          printf("Enter client ID: ");
          scanf("%d", &v7);
          printf("Enter products (comma separated): ");
          scanf("%s", String);
          Source = strtok(String, ",");
          v12 = 0;
          while ( Source )
          {
            strcpy(&v6[20 * v12++], Source);
            Source = strtok(0i64, ",");
          }
          placeOrder(v7, v6);
        }
        if ( strcmp(Str1, "print_clients") )
          break;
        printClients();
      }
      if ( strcmp(Str1, "print_orders") )
        break;
      printOrders();
    }
    if ( !strcmp(Str1, "exit") )
      break;
    printf("Command not recognized, try again.\n");
  }
  printf("Goodbye!\n");
  return 0;
}
// 140001601: using guessed type __int64 __fastcall addProduct(_QWORD, _QWORD);
// 1400016A5: using guessed type __int64 __fastcall addClient(_QWORD);
// 1400017AF: using guessed type __int64 __fastcall placeOrder(_QWORD, _QWORD);
// 140001BC7: using guessed type __int64 printClients(void);
// 140001D32: using guessed type __int64 printOrders(void);
// 140002230: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001E57: using guessed type char var_130[204];

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Natural Language Date Converter ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to check if given year is a leap year
int isLeapYear(int year)
{
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
        return 1;
    else
        return 0;
}

// Function to get number of days in a month of a year
int getDaysInMonth(int year, int month)
{
    // Standard number of days in a month
    int days_in_month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    // If leap year, February has 29 days
    if (month == 2 && isLeapYear(year))
        return 29;
    else
        return days_in_month[month - 1];
}

// Function to convert natural language date to ISO date format
void convertDate(char* natural_lang_date)
{
    // Tokenize the input string
    char* tokens[10];
    int count = 0;
    char* token = strtok(natural_lang_date, " ");
    while (token != NULL)
    {
        tokens[count++] = token;
        token = strtok(NULL, " ");
    }

    // Get day, month and year values from tokens
    int day = atoi(tokens[1]);
    int month = 0;
    char* month_string = tokens[0];
    if (strcmp(month_string, "January") == 0)
        month = 1;
    else if (strcmp(month_string, "February") == 0)
        month = 2;
    else if (strcmp(month_string, "March") == 0)
        month = 3;
    else if (strcmp(month_string, "April") == 0)
        month = 4;
    else if (strcmp(month_string, "May") == 0)
        month = 5;
    else if (strcmp(month_string, "June") == 0)
        month = 6;
    else if (strcmp(month_string, "July") == 0)
        month = 7;
    else if (strcmp(month_string, "August") == 0)
        month = 8;
    else if (strcmp(month_string, "September") == 0)
        month = 9;
    else if (strcmp(month_string, "October") == 0)
        month = 10;
    else if (strcmp(month_string, "November") == 0)
        month = 11;
    else if (strcmp(month_string, "December") == 0)
        month = 12;

    int year = atoi(tokens[2]);

    // Check if input date is valid
    if (day <= 0 || month <= 0 || month > 12 || year <= 0)
    {
        printf("Invalid date.\n");
        return;
    }

    // Check if day is valid for given month and year
    int days_in_month = getDaysInMonth(year, month);
    if (day > days_in_month)
    {
        printf("Invalid date.\n");
        return;
    }

    // Print ISO date format
    printf("%04d-%02d-%02d\n", year, month, day);
}

int main()
{
    char natural_lang_date[256];
    printf("Enter natural language date (e.g. August 25 2021): ");
    fgets(natural_lang_date, 256, stdin);
    natural_lang_date[strcspn(natural_lang_date, "\n")] = '\0'; // Remove trailing newline

    convertDate(natural_lang_date);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall convertDate(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000192A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[256]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  printf("Enter natural language date (e.g. August 25 2021): ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 256, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  convertDate(Buffer);
  return 0;
}
// 14000168C: using guessed type __int64 __fastcall convertDate(_QWORD);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000192A: using guessed type char Buffer[256];

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Matrix operations ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>

#define ROWS 3
#define COLS 3

void printMatrix(int mat[][COLS], int rows, int cols);
void addMatrix(int mat1[][COLS], int mat2[][COLS], int result[][COLS], int rows, int cols);
void multiplyMatrix(int mat1[][COLS], int mat2[][COLS], int result[][COLS], int rows, int cols);

int main() {
    int mat1[ROWS][COLS], mat2[ROWS][COLS], sum[ROWS][COLS], product[ROWS][COLS];

    printf("Enter values for matrix 1:\n");
    for(int i=0; i<ROWS; i++) {
        for(int j=0; j<COLS; j++) {
            printf("Enter value for mat1[%d][%d]: ", i, j);
            scanf("%d", &mat1[i][j]);
        }
    }

    printf("\nEnter values for matrix 2:\n");
    for(int i=0; i<ROWS; i++) {
        for(int j=0; j<COLS; j++) {
            printf("Enter value for mat2[%d][%d]: ", i, j);
            scanf("%d", &mat2[i][j]);
        }
    }

    printf("\nMatrix 1:\n");
    printMatrix(mat1, ROWS, COLS);

    printf("\nMatrix 2:\n");
    printMatrix(mat2, ROWS, COLS);

    // Add the matrices
    addMatrix(mat1, mat2, sum, ROWS, COLS);

    printf("\nSum of matrices:\n");
    printMatrix(sum, ROWS, COLS);

    // Multiply the matrices
    multiplyMatrix(mat1, mat2, product, ROWS, COLS);

    printf("\nProduct of matrices:\n");
    printMatrix(product, ROWS, COLS);

    return 0;
}

void printMatrix(int mat[][COLS], int rows, int cols) {
    for(int i=0; i<rows; i++) {
        for(int j=0; j<cols; j++) {
            printf("%d ", mat[i][j]);
        }
        printf("\n");
    }
}

void addMatrix(int mat1[][COLS], int mat2[][COLS], int result[][COLS], int rows, int cols) {
    for(int i=0; i<rows; i++) {
        for(int j=0; j<cols; j++) {
            result[i][j] = mat1[i][j] + mat2[i][j];
        }
    }
}

void multiplyMatrix(int mat1[][COLS], int mat2[][COLS], int result[][COLS], int rows, int cols) {
    for(int i=0; i<rows; i++) {
        for(int j=0; j<cols; j++) {
            result[i][j] = 0;

            for(int k=0; k<cols; k++) {
                result[i][j] += mat1[i][k] * mat2[k][j];
            }
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall printMatrix(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall addMatrix(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
__int64 __fastcall multiplyMatrix(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[48]; // [rsp+30h] [rbp-50h] BYREF
  char v5[48]; // [rsp+60h] [rbp-20h] BYREF
  _DWORD v6[12]; // [rsp+90h] [rbp+10h] BYREF
  _DWORD v7[12]; // [rsp+C0h] [rbp+40h] BYREF
  unsigned int m; // [rsp+F0h] [rbp+70h]
  unsigned int k; // [rsp+F4h] [rbp+74h]
  unsigned int j; // [rsp+F8h] [rbp+78h]
  unsigned int i; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter values for matrix 1:\n");
  for ( i = 0; (int)i <= 2; ++i )
  {
    for ( j = 0; (int)j <= 2; ++j )
    {
      printf("Enter value for mat1[%d][%d]: ", i, j);
      scanf("%d", &v7[3 * i + j]);
    }
  }
  printf("\nEnter values for matrix 2:\n");
  for ( k = 0; (int)k <= 2; ++k )
  {
    for ( m = 0; (int)m <= 2; ++m )
    {
      printf("Enter value for mat2[%d][%d]: ", k, m);
      scanf("%d", &v6[3 * k + m]);
    }
  }
  printf("\nMatrix 1:\n");
  printMatrix(v7, 3i64, 3i64);
  printf("\nMatrix 2:\n");
  printMatrix(v6, 3i64, 3i64);
  addMatrix((unsigned int)v7, (unsigned int)v6, (unsigned int)v5, 3, 3);
  printf("\nSum of matrices:\n");
  printMatrix(v5, 3i64, 3i64);
  multiplyMatrix((unsigned int)v7, (unsigned int)v6, (unsigned int)v4, 3, 3);
  printf("\nProduct of matrices:\n");
  printMatrix(v4, 3i64, 3i64);
  return 0;
}
// 1400017EF: using guessed type __int64 __fastcall printMatrix(_QWORD, _QWORD, _QWORD);
// 140001879: using guessed type __int64 __fastcall addMatrix(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14000193D: using guessed type __int64 __fastcall multiplyMatrix(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Encyptor ; Style: Ken Thompson
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Usage: ./enc <input_file> <output_file>\n");
        return 1;
    }

    // open input file
    FILE *in_file = fopen(argv[1], "r");
    if (!in_file) {
        printf("Error: cannot open input file\n");
        return 1;
    }

    // open output file
    FILE *out_file = fopen(argv[2], "w");
    if (!out_file) {
        printf("Error: cannot open output file\n");
        return 1;
    }

    // key for file encryption
    char key[] = "S3cr3tK3y";

    // read input file
    char c;
    while ((c = fgetc(in_file)) != EOF) {
        if (isalpha(c)) {
            // encrypt character
            int index = toupper(c) - 'A';
            c = key[index % strlen(key)];
        }

        // write encrypted character to output file
        fputc(c, out_file);
    }

    // close files
    fclose(in_file);
    fclose(out_file);

    printf("Encryption completed successfully!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl fputc(int Character, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isalpha)(int C);
// extern int (__cdecl *toupper)(int C);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[10]; // [rsp+2Ah] [rbp-26h] BYREF
  int v5; // [rsp+34h] [rbp-1Ch]
  FILE *Stream; // [rsp+38h] [rbp-18h]
  FILE *v7; // [rsp+40h] [rbp-10h]
  char v8; // [rsp+4Fh] [rbp-1h]

  _main(argc, argv, envp);
  if ( argc > 2 )
  {
    v7 = fopen(argv[1], "r");
    if ( v7 )
    {
      Stream = fopen(argv[2], "w");
      if ( Stream )
      {
        strcpy(Str, "S3cr3tK3y");
        while ( 1 )
        {
          v8 = fgetc(v7);
          if ( v8 == -1 )
            break;
          if ( isalpha(v8) )
          {
            v5 = toupper(v8) - 65;
            v8 = Str[v5 % strlen(Str)];
          }
          fputc(v8, Stream);
        }
        fclose(v7);
        fclose(Stream);
        printf("Encryption completed successfully!\n");
        return 0;
      }
      else
      {
        printf("Error: cannot open output file\n");
        return 1;
      }
    }
    else
    {
      printf("Error: cannot open input file\n");
      return 1;
    }
  }
  else
  {
    printf("Usage: ./enc <input_file> <output_file>\n");
    return 1;
  }
}
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: Donald Knuth
#include <stdio.h>

void sorting(int arr[], int size) {
  int i, j, temp;

  for(i = 0; i < size - 1; i++) {
    for(j = i + 1; j < size; j++) {
      if(arr[i] > arr[j]) {
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
  }
}

void display(int arr[], int size) {
  int i;

  printf("Sorted Array\n");
  for(i = 0; i < size; i++) {
    printf("%d\n", arr[i]);
  }
}

int main() {
  int arr[] = {5, 1, 4, 2, 0, 6, 3};
  int size = sizeof(arr)/sizeof(arr[0]);

  printf("Unsorted Array\n");
  display(arr, size);

  sorting(arr, size);

  display(arr, size);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall sorting(_QWORD, _QWORD); // weak
__int64 __fastcall display(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016D6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[7]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v5; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 5;
  v4[1] = 1;
  v4[2] = 4;
  v4[3] = 2;
  v4[4] = 0;
  v4[5] = 6;
  v4[6] = 3;
  v5 = 7;
  printf("Unsorted Array\n");
  display(v4, 7i64);
  sorting(v4, v5);
  display(v4, v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall sorting(_QWORD, _QWORD);
// 140001674: using guessed type __int64 __fastcall display(_QWORD, _QWORD);
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to Morse code conversion ; Style: synchronous
#include <stdio.h>
#include <string.h>

#define MAX_LEN 100 // Maximum length of input string

// Morse code alphabet
char *morse_alphabet[] = {".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."};

// Corresponding letters of Morse code
char letters[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

/**
 * Function to convert a character to its Morse code equivalent
 */
char *char_to_morse(char c) {
    int pos = -1;
    char upper_c = toupper(c);
    char *morse_char = NULL;
    
    // Find the position of character in letters string
    for(int i=0; i<26; i++) {
        if(letters[i] == upper_c) {
            pos = i;
            break;
        }
    }
    
    if(pos != -1) { // If character is found in letters
        
        // Copy the Morse code of the character
        morse_char = malloc(strlen(morse_alphabet[pos]));
        strcpy(morse_char, morse_alphabet[pos]);
    }
    
    return morse_char;
}

/**
 * Function to convert text to Morse code
 */
void text_to_morse(char *text, char *morse) {
    int text_len = strlen(text);
    
    for(int i=0; i<text_len; i++) {
        char *morse_char = char_to_morse(text[i]);
        
        if(morse_char != NULL) { // If character is one of the 26 letters
            
            // Append Morse code of character to morse string
            strcat(morse, morse_char);
            strcat(morse, " "); // Add space between Morse code of characters
        }
        
        free(morse_char);
    }
}

int main() {
    char text[MAX_LEN], morse[MAX_LEN*5] = {0}; // Morse code can be up to 5 times longer than original text
    
    printf("Enter text to convert to Morse code:\n");
    fgets(text, MAX_LEN, stdin);
    
    text_to_morse(text, morse);
    
    printf("Morse code:\n%s\n", morse);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall text_to_morse(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016E0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  __int64 v5[62]; // [rsp+20h] [rbp-60h] BYREF
  int v6; // [rsp+210h] [rbp+190h]
  char Buffer[128]; // [rsp+220h] [rbp+1A0h] BYREF

  _main(argc, argv, envp);
  memset(v5, 0, sizeof(v5));
  v6 = 0;
  printf("Enter text to convert to Morse code:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  text_to_morse(Buffer, v5);
  printf("Morse code:\n%s\n", (const char *)v5);
  return 0;
}
// 14000164B: using guessed type __int64 __fastcall text_to_morse(_QWORD, _QWORD);
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Movie Rating System ; Style: visionary
#include <stdio.h>

// Define struct for movie rating
struct rating {
    int five_star;
    int four_star;
    int three_star;
    int two_star;
    int one_star;
};

int main() {

    // initialize movie rating with 0
    struct rating movie_rating = {0, 0, 0, 0, 0};

    // get user's rating for the movie
    int rating;
    printf("Please rate the movie (1-5 stars): ");
    scanf("%d", &rating);

    // update movie rating with user's rating
    switch (rating) {
        case 1:
            movie_rating.one_star++;
            break;
        case 2:
            movie_rating.two_star++;
            break;
        case 3:
            movie_rating.three_star++;
            break;
        case 4:
            movie_rating.four_star++;
            break;
        case 5:
            movie_rating.five_star++;
            break;
        default:
            printf("Invalid rating.\n");
    }

    // display current movie rating
    printf("\nCurrent movie rating:\n");
    printf(" 5 stars: %d\n", movie_rating.five_star);
    printf(" 4 stars: %d\n", movie_rating.four_star);
    printf(" 3 stars: %d\n", movie_rating.three_star);
    printf(" 2 stars: %d\n", movie_rating.two_star);
    printf(" 1 star : %d\n", movie_rating.one_star);

    // calculate and display the average rating
    int total_ratings = movie_rating.five_star + movie_rating.four_star +
                        movie_rating.three_star + movie_rating.two_star +
                        movie_rating.one_star;
    float average_rating = (5 * movie_rating.five_star + 4 * movie_rating.four_star +
                            3 * movie_rating.three_star + 2 * movie_rating.two_star +
                            1 * movie_rating.one_star) / (float)total_ratings;

    printf("\nAverage rating: %.2f\n", average_rating);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-24h] BYREF
  unsigned int v5; // [rsp+30h] [rbp-20h]
  unsigned int v6; // [rsp+34h] [rbp-1Ch]
  unsigned int v7; // [rsp+38h] [rbp-18h]
  unsigned int v8; // [rsp+3Ch] [rbp-14h]
  unsigned int v9; // [rsp+40h] [rbp-10h]

  _main(argc, argv, envp);
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  printf("Please rate the movie (1-5 stars): ");
  scanf("%d", &v4);
  switch ( v4 )
  {
    case 1:
      ++v9;
      break;
    case 2:
      ++v8;
      break;
    case 3:
      ++v7;
      break;
    case 4:
      ++v6;
      break;
    case 5:
      ++v5;
      break;
    default:
      printf("Invalid rating.\n");
      break;
  }
  printf("\nCurrent movie rating:\n");
  printf(" 5 stars: %d\n", v5);
  printf(" 4 stars: %d\n", v6);
  printf(" 3 stars: %d\n", v7);
  printf(" 2 stars: %d\n", v8);
  printf(" 1 star : %d\n", v9);
  printf(
    "\nAverage rating: %.2f\n",
    (float)((float)(int)(2 * v8 + 5 * v5 + 4 * v6 + 3 * v7 + v9) / (float)(int)(v8 + v7 + v6 + v5 + v9)));
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: systematic
#include <stdio.h>
#include <ctype.h>
#include <stdbool.h>
#include <string.h>

/*
* Function that checks if the password contains alphabets
*/

bool containsAlphabets(char* password) {
    for(int i = 0; i < strlen(password); i++) {
        if(isalpha(password[i])) {
            return true;
        }
    }
    return false;
}

/*
* Function that checks if the password contains digits
*/

bool containsDigits(char* password) {
    for(int i = 0; i < strlen(password); i++) {
        if(isdigit(password[i])) {
            return true;
        }
    }
    return false;
}

/*
* Function that checks if the password contains special characters
*/

bool containsSpecialCharacters(char* password) {
    for(int i = 0; i < strlen(password); i++) {
        if(!isalpha(password[i]) && !isdigit(password[i])) {
            return true;
        }
    }
    return false;
}

/*
 * Function that checks if the password is too short or too long
 */

bool isLengthValid(char* password) {
    if(strlen(password)<8 || strlen(password)>20) {
        return false;
    }
    return true;
}

/*
 * Function to check the strength of the password
 */

char* checkPasswordStrength(char* password) {
    bool alphabets = containsAlphabets(password);
    bool digits = containsDigits(password);
    bool specialCharacters = containsSpecialCharacters(password);
    bool lengthValid = isLengthValid(password);
    
    if(lengthValid==false) {
        return "Password length should be between 8 and 20 characters";
    }
    if(alphabets==false) {
        return "Password must contain alphabets";
    }   
    if(digits==false) {
        return "Password must contain digits";
    }   
    if(specialCharacters==false) {
        return "Password must contain special characters";
    }
    
    return "Password is strong";
}

/*
 * Main function to run the program
 */

int main() {
    char password[100];
    
    printf("Enter a password to check its strength: ");
    scanf("%s", password);
    
    char* result = checkPasswordStrength(password);
    
    printf("%s\n", result);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall checkPasswordStrength(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017FA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[104]; // [rsp+20h] [rbp-70h] BYREF
  const char *v5; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a password to check its strength: ");
  scanf("%s", v4);
  v5 = (const char *)checkPasswordStrength(v4);
  printf("%s\n", v5);
  return 0;
}
// 140001761: using guessed type __int64 __fastcall checkPasswordStrength(_QWORD);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: shocked
#include <stdio.h>
#include <string.h>

int min(int x, int y, int z) {
    if(x < y && x < z) return x;
    else if(y < x && y < z) return y;
    else return z;
}

int levenshtein_dist(char* s1, char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);
    int dp[len1+1][len2+1];

    for(int i=0; i<=len1; i++) {
        for(int j=0; j<=len2; j++) {
            if(i == 0) dp[i][j] = j;
            else if(j == 0) dp[i][j] = i;
            else if(s1[i-1] == s2[j-1]) dp[i][j] = dp[i-1][j-1];
            else dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1;
        }
    }

    return dp[len1][len2];
}

int main() {
    char s1[100], s2[100];

    printf("Enter the first string: ");
    scanf("%s", s1);

    printf("Enter the second string: ");
    scanf("%s", s2);

    int dist = levenshtein_dist(s1, s2);

    printf("The Levenshtein Distance between \"%s\" and \"%s\" is %d\n", s1, s2, dist);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall levenshtein_dist(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001931) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[112]; // [rsp+20h] [rbp-60h] BYREF
  char v5[108]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v6; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter the first string: ");
  scanf("%s", v5);
  printf("Enter the second string: ");
  scanf("%s", v4);
  v6 = levenshtein_dist(v5, v4);
  printf("The Levenshtein Distance between \"%s\" and \"%s\" is %d\n", v5, v4, v6);
  return 0;
}
// 14000161F: using guessed type __int64 __fastcall levenshtein_dist(_QWORD, _QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: introspective
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

int main() {
  printf("Welcome to the C Internet Speed Test Application!\n\n");
  
  // Ask user for input
  char input[20];
  printf("Please enter the size of the test data in MB (e.g. 50): ");
  fgets(input, 20, stdin);
  int testSize = atoi(input);

  // Check for valid input
  if (testSize <= 0) {
    printf("Invalid test size. Please enter a positive integer.\n");
    return 1;
  }

  // Generate test data
  char* testData = (char*) malloc(sizeof(char) * 1024 * 1024 * testSize);
  
  // Start timer
  clock_t start = clock();

  // Perform test
  for (int i = 0; i < 1024 * 1024 * testSize; i++) {
    testData[i] = 'a';
  }

  // Stop timer
  clock_t end = clock();

  // Calculate results
  double totalTime = (double)(end - start) / CLOCKS_PER_SEC;
  double speed = (double) testSize / totalTime;

  // Display results
  printf("\nTest complete!\n");
  printf("Data size: %d MB\n", testSize);
  printf("Time taken: %.2lf seconds\n", totalTime);
  printf("Internet speed: %.2lf megabytes per second\n", speed);

  // Free memory
  free(testData);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// clock_t __cdecl clock();
// int __cdecl atoi(const char *String);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[24]; // [rsp+20h] [rbp-40h] BYREF
  double v6; // [rsp+38h] [rbp-28h]
  double v7; // [rsp+40h] [rbp-20h]
  clock_t v8; // [rsp+48h] [rbp-18h]
  clock_t v9; // [rsp+4Ch] [rbp-14h]
  void *Block; // [rsp+50h] [rbp-10h]
  int v11; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the C Internet Speed Test Application!\n\n");
  printf("Please enter the size of the test data in MB (e.g. 50): ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 20, v3);
  v11 = atoi(Buffer);
  if ( v11 > 0 )
  {
    Block = malloc((__int64)v11 << 20);
    v9 = clock();
    for ( i = 0; i < v11 << 20; ++i )
      *((_BYTE *)Block + i) = 97;
    v8 = clock();
    v7 = (double)(v8 - v9) / 1000.0;
    v6 = (double)v11 / v7;
    printf("\nTest complete!\n");
    printf("Data size: %d MB\n", (unsigned int)v11);
    printf("Time taken: %.2lf seconds\n", v7);
    printf("Internet speed: %.2lf megabytes per second\n", v6);
    free(Block);
    return 0;
  }
  else
  {
    printf("Invalid test size. Please enter a positive integer.\n");
    return 1;
  }
}
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to Morse code conversion ; Style: protected
#include <stdio.h>
#include <string.h>

int main() {
    char message[1000];
    printf("Enter a message to be converted to Morse code: ");
    fgets(message, sizeof(message), stdin);
    
    int i, j;
    const char *morseCode[] = {".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--..", "-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----."};
    const char *letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    char convertedMessage[1000] = "";

    for (i = 0; i < strlen(message) - 1; i++) {
        if (message[i] == ' ') {
            strcat(convertedMessage, " / ");
        } else {
            for (j = 0; j < strlen(letters); j++) {
                if (toupper(message[i]) == letters[j]) {
                    strcat(convertedMessage, morseCode[j]);
                    strcat(convertedMessage, " ");
                    break;
                }
            }
        }
    }
    
    printf("The message converted to Morse code is: %s", convertedMessage);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl toupper(int C);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcat(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

char *off_14000A020[36] =
{
  ".-",
  "-...",
  "-.-.",
  "-..",
  ".",
  "..-.",
  "--.",
  "....",
  "..",
  ".---",
  "-.-",
  ".-..",
  "--",
  "-.",
  "---",
  ".--.",
  "--.-",
  ".-.",
  "...",
  "-",
  "..-",
  "...-",
  ".--",
  "-..-",
  "-.--",
  "--..",
  "-----",
  ".----",
  "..---",
  "...--",
  "....-",
  ".....",
  "-....",
  "--...",
  "---..",
  "----."
}; // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Str[8]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v6; // [rsp+28h] [rbp-58h]
  char v7[984]; // [rsp+30h] [rbp-50h] BYREF
  char *Source[36]; // [rsp+410h] [rbp+390h] BYREF
  char Buffer[1008]; // [rsp+530h] [rbp+4B0h] BYREF
  char *v10; // [rsp+920h] [rbp+8A0h]
  int j; // [rsp+928h] [rbp+8A8h]
  int i; // [rsp+92Ch] [rbp+8ACh]

  _main(argc, argv, envp);
  printf("Enter a message to be converted to Morse code: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  qmemcpy(Source, off_14000A020, sizeof(Source));
  v10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  *(_QWORD *)Str = 0i64;
  v6 = 0i64;
  memset(v7, 0, sizeof(v7));
  for ( i = 0; i < strlen(Buffer) - 1; ++i )
  {
    if ( Buffer[i] == 32 )
    {
      *(_DWORD *)&Str[strlen(Str)] = 2109216;
    }
    else
    {
      for ( j = 0; j < strlen(v10); ++j )
      {
        if ( toupper(Buffer[i]) == v10[j] )
        {
          strcat(Str, Source[j]);
          *(_WORD *)&Str[strlen(Str)] = 32;
          break;
        }
      }
    }
  }
  printf("The message converted to Morse code is: %s", Str);
  return 0;
}
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A020: using guessed type char *off_14000A020[36];
// 140001591: using guessed type char Buffer[1008];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific ; Style: minimalist
#include <stdio.h>

int main() {
   int num1, num2, result;
   
   printf("Enter first number: ");
   scanf("%d", &num1);

   printf("Enter second number: ");
   scanf("%d", &num2);
   
   result = gcd(num1, num2);
   
   printf("GCD of %d and %d is %d.\n", num1, num2, result);
   
   return 0;
}

int gcd(int x, int y) {
   int r;
   
   while (y != 0) {
      r = x % y;
      x = y;
      y = r;
   }
   
   return x;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall gcd(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int v5; // [rsp+28h] [rbp-8h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter first number: ");
  scanf("%d", &v5);
  printf("Enter second number: ");
  scanf("%d", &v4);
  v6 = gcd(v5, v4);
  printf("GCD of %d and %d is %d.\n", v5, v4, v6);
  return 0;
}
// 140001674: using guessed type __int64 __fastcall gcd(_QWORD, _QWORD);
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Music Library Management System ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>

typedef struct song{
    char name[30];
    char artist[30];
    int year;
    int rating;
    struct song* next;
}song;

song *head = NULL, *tail = NULL;

int main(){
    int choice;

    do{
        printf("Welcome to the CyberPunk Music Library Management System.\n");
        printf("1. Add a new song\n");
        printf("2. Delete a song\n");
        printf("3. Display all songs\n");
        printf("4. Search for a song\n");
        printf("5. Sort songs by artist name\n");
        printf("6. Sort songs by year released\n");
        printf("7. Quit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch(choice){
            case 1:
                add_song();
                break;
            case 2:
                delete_song();
                break;
            case 3:
                display_songs();
                break;
            case 4:
                search_song();
                break;
            case 5:
                sort_by_artist();
                break;
            case 6:
                sort_by_year();
                break;
            case 7:
                printf("Exiting program...");
                break;
            default:
                printf("Invalid choice! Try again.\n");
        }
    
    }while(choice != 7);

    return 0;
}

void add_song(){
    song *new_song = (song*) malloc(sizeof(song));

    printf("Enter song name: ");
    scanf("%s", new_song->name);
    printf("Enter artist name: ");
    scanf("%s", new_song->artist);
    printf("Enter release year: ");
    scanf("%d", &new_song->year);
    printf("Enter rating (out of 10): ");
    scanf("%d", &new_song->rating);

    new_song->next = NULL;

    if(head == NULL){
        head = new_song;
        tail = new_song;
    }else{
        tail->next = new_song;
        tail = new_song;
    }

    printf("New song added successfully!\n");
}

void delete_song(){
    char name[30], artist[30];
    int flag = 0;   // to keep track if song was found or not
    
    if(head == NULL){
        printf("No songs in library!\n");
        return;
    }

    printf("Enter name of song to delete: ");
    scanf("%s", name);
    printf("Enter artist name: ");
    scanf("%s", artist);

    song *curr = head, *prev = NULL;

    while(curr != NULL){
        if(strcmp(curr->name, name) == 0 && strcmp(curr->artist, artist) == 0){
            flag = 1;
            if(curr == head){
                head = curr->next;
                free(curr);
            }else if(curr == tail){
                prev->next = NULL;
                tail = prev;
                free(curr);
            }else{
                prev->next = curr->next;
                free(curr);
            }
            printf("Song %s by %s deleted successfully!\n", name, artist);
            break;
        }
        prev = curr;
        curr = curr->next;
    }

    if(flag == 0){
        printf("Song not found!\n");
    }
}

void display_songs(){
    if(head == NULL){
        printf("No songs in library!\n");
        return;
    }

    printf("Name\tArtist\tYear\tRating\n");
    printf("----\t------\t----\t------\n");

    song *curr = head;

    while(curr != NULL){
        printf("%s\t%s\t%d\t%d\n", curr->name, curr->artist, curr->year, curr->rating);
        curr = curr->next;
    }
}

void search_song(){
    char name[30];
    int flag = 0;
    
    if(head == NULL){
        printf("No songs in library!\n");
        return;
    }

    printf("Enter name of song to search: ");
    scanf("%s", name);

    song *curr = head;

    while(curr != NULL){
        if(strcmp(curr->name, name) == 0){
            flag = 1;
            printf("%s\t%s\t%d\t%d\n", curr->name, curr->artist, curr->year, curr->rating);
        }
        curr = curr->next;
    }

    if(flag == 0){
        printf("Song not found!\n");
    }
}

void sort_by_artist(){
    if(head == NULL){
        printf("No songs in library!\n");
        return;
    }

    song *p, *q;
    char temp[30];

    for(p = head; p != NULL; p = p->next){
        for(q = p->next; q != NULL; q = q->next){
            if(strcmp(p->artist, q->artist) > 0){
                strcpy(temp, p->name);
                strcpy(p->name, q->name);
                strcpy(q->name, temp);
                strcpy(temp, p->artist);
                strcpy(p->artist, q->artist);
                strcpy(q->artist, temp);
                int t = p->year;
                p->year = q->year;
                q->year = t;
                t = p->rating;
                p->rating = q->rating;
                q->rating = t;
            }
        }
    }

    printf("Songs sorted by artist successfully!\n");
}

void sort_by_year(){
    if(head == NULL){
        printf("No songs in library!\n");
        return;
    }

    song *p, *q;
    char temp[30];

    for(p = head; p != NULL; p = p->next){
        for(q = p->next; q != NULL; q = q->next){
            if(p->year > q->year){
                strcpy(temp, p->name);
                strcpy(p->name, q->name);
                strcpy(q->name, temp);
                strcpy(temp, p->artist);
                strcpy(p->artist, q->artist);
                strcpy(q->artist, temp);
                int t = p->year;
                p->year = q->year;
                q->year = t;
                t = p->rating;
                p->rating = q->rating;
                q->rating = t;
            }
        }
    }

    printf("Songs sorted by year successfully!\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 add_song(void); // weak
__int64 delete_song(void); // weak
__int64 display_songs(void); // weak
__int64 search_song(void); // weak
__int64 sort_by_artist(void); // weak
__int64 sort_by_year(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("Welcome to the CyberPunk Music Library Management System.\n");
    printf("1. Add a new song\n");
    printf("2. Delete a song\n");
    printf("3. Display all songs\n");
    printf("4. Search for a song\n");
    printf("5. Sort songs by artist name\n");
    printf("6. Sort songs by year released\n");
    printf("7. Quit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        add_song();
        break;
      case 2:
        delete_song();
        break;
      case 3:
        display_songs();
        break;
      case 4:
        search_song();
        break;
      case 5:
        sort_by_artist();
        break;
      case 6:
        sort_by_year();
        break;
      case 7:
        printf("Exiting program...");
        break;
      default:
        printf("Invalid choice! Try again.\n");
        break;
    }
  }
  while ( v4 != 7 );
  return 0;
}
// 140001717: using guessed type __int64 add_song(void);
// 14000182D: using guessed type __int64 delete_song(void);
// 1400019CB: using guessed type __int64 display_songs(void);
// 140001A67: using guessed type __int64 search_song(void);
// 140001B45: using guessed type __int64 sort_by_artist(void);
// 140001CA6: using guessed type __int64 sort_by_year(void);
// 140001EB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: satisfied
#include <stdio.h>

#define MAX_ACTIVITIES 100

struct activity {
    int start, end;
};

int compare_activities(const void *a, const void *b) {
    struct activity *act_a = (struct activity*) a;
    struct activity *act_b = (struct activity*) b;
    return act_a->end - act_b->end;
}

void select_activities(struct activity activities[], int n) {
    qsort(activities, n, sizeof(struct activity), compare_activities);
    int selected[MAX_ACTIVITIES];
    int count = 0, last = -1;
    for (int i = 0; i < n; ++i) {
        if (activities[i].start >= last) {
            selected[count++] = i;
            last = activities[i].end;
        }
    }
    printf("Selected activities: ");
    for (int i = 0; i < count; ++i) {
        printf("(%d,%d) ", activities[selected[i]].start, activities[selected[i]].end);
    }
}

int main() {
    struct activity activities[] = {
        {1, 3},
        {5, 7},
        {2, 4},
        {6, 8},
        {8, 10},
        {9, 11},
        {11, 13},
        {12, 14},
        {3, 5},
        {4, 6}
    };
    int n = sizeof(activities) / sizeof(struct activity);
    select_activities(activities, n);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall select_activities(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001732) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[24]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  v4[0] = 1;
  v4[1] = 3;
  v4[2] = 5;
  v4[3] = 7;
  v4[4] = 2;
  v4[5] = 4;
  v4[6] = 6;
  v4[7] = 8;
  v4[8] = 8;
  v4[9] = 10;
  v4[10] = 9;
  v4[11] = 11;
  v4[12] = 11;
  v4[13] = 13;
  v4[14] = 12;
  v4[15] = 14;
  v4[16] = 3;
  v4[17] = 5;
  v4[18] = 4;
  v4[19] = 6;
  v4[23] = 10;
  select_activities(v4, 10i64);
  return 0;
}
// 1400015C9: using guessed type __int64 __fastcall select_activities(_QWORD, _QWORD);
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System boot optimizer ; Style: creative
#include <stdio.h>

int main() {
    printf("Welcome to the C System boot optimizer!\n");
    printf("This program will optimize the boot process of your system to make it faster and more efficient.\n");

    int num_of_processes;
    printf("How many processes do you want to optimize? ");
    scanf("%d", &num_of_processes);

    int processes[num_of_processes];
    printf("Enter the process IDs to optimize:\n");
    for (int i=0; i<num_of_processes; i++) {
        printf("Process %d: ", i+1);
        scanf("%d", &processes[i]);
    }

    printf("\nOptimizing boot process...\n");
    for (int i=0; i<num_of_processes; i++) {
        printf("Killing process %d...\n", processes[i]);
        // code to kill the specified process goes here
    }
    printf("All specified processes have been optimized!\n");

    printf("\nDisabling unnecessary startup programs...\n");
    // code to disable unnecessary startup programs goes here
    printf("All unnecessary startup programs have been disabled!\n");

    printf("\nCleaning up system files...\n");
    // code to clean up system files goes here
    printf("All system files have been cleaned up!\n");

    printf("\nSystem optimization complete!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  char v5; // [rsp+20h] [rbp-20h] BYREF
  int v6; // [rsp+24h] [rbp-1Ch] BYREF
  char *v7; // [rsp+28h] [rbp-18h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the C System boot optimizer!\n");
  printf("This program will optimize the boot process of your system to make it faster and more efficient.\n");
  printf("How many processes do you want to optimize? ");
  scanf("%d", &v6);
  v8 = v6 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(4i64 * v6 + 15) >> 4));
  v7 = &v5;
  printf("Enter the process IDs to optimize:\n");
  for ( i = 0; i < v6; ++i )
  {
    printf("Process %d: ", (unsigned int)(i + 1));
    scanf("%d", &v7[4 * i]);
  }
  printf("\nOptimizing boot process...\n");
  for ( j = 0; j < v6; ++j )
    printf("Killing process %d...\n", *(unsigned int *)&v7[4 * j]);
  printf("All specified processes have been optimized!\n");
  printf("\nDisabling unnecessary startup programs...\n");
  printf("All unnecessary startup programs have been disabled!\n");
  printf("\nCleaning up system files...\n");
  printf("All system files have been cleaned up!\n");
  printf("\nSystem optimization complete!\n");
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Binary search trees ; Style: Claude Shannon
#include<stdio.h>
#include<stdlib.h>

//Defining the structure of the Binary Search Tree
struct node{
    int data;
    struct node* left;
    struct node* right;
};

//Function to create a new node in the Binary Search Tree
struct node* newNode(int data){
    struct node* temp = (struct node*)malloc(sizeof(struct node));
    temp->data = data;
    temp->left = NULL;
    temp->right = NULL;
    return temp;
}

//Function to insert a new node in the Binary Search Tree
struct node* insert(struct node* root, int data){
    if(root == NULL){
        return newNode(data);
    }
    if(data < root->data){
        root->left = insert(root->left, data);
    }
    else if(data > root->data){
        root->right = insert(root->right, data);
    }
    return root;
}

//Function to search for a node in the Binary Search Tree
struct node* search(struct node* root, int data){
    if(root == NULL || root->data == data){
        return root;
    }
    if(root->data < data){
        return search(root->right, data);
    }
    return search(root->left, data);
}

//Function to delete a node in the Binary Search Tree
struct node* delete(struct node* root, int data){
    if(root == NULL){
        return root;
    }
    if(data < root->data){
        root->left = delete(root->left, data);
    }
    else if(data > root->data){
        root->right = delete(root->right, data);
    }
    else{
        //Case when the node has only one child or no child
        if(root->left == NULL){
            struct node* temp = root->right;
            free(root);
            return temp;
        }
        else if(root->right == NULL){
            struct node* temp = root->left;
            free(root);
            return temp;
        }
        //Case when the node has two children
        struct node* temp = root->right;
        while(temp && temp->left != NULL){
            temp = temp->left;
        }
        root->data = temp->data;
        root->right = delete(root->right, temp->data);
    }
    return root;
}

//Function to print the Binary Search Tree in an in-order traversal
void inorder(struct node* root){
    if(root != NULL){
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

//Main function
int main(){
    struct node* root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);

    printf("In-order traversal of the Binary Search Tree: \n");
    inorder(root);

    printf("\nDeleting the node with data 20: \n");
    root = delete(root, 20);
    printf("In-order traversal of the modified Binary Search Tree: \n");
    inorder(root);

    printf("\nDeleting the node with data 30: \n");
    root = delete(root, 30);
    printf("In-order traversal of the modified Binary Search Tree: \n");
    inorder(root);

    printf("\nDeleting the node with data 50: \n");
    root = delete(root, 50);
    printf("In-order traversal of the modified Binary Search Tree: \n");
    inorder(root);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall insert(_QWORD, _QWORD); // weak
__int64 __fastcall delete(_QWORD, _QWORD); // weak
__int64 __fastcall inorder(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000182A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-8h]
  __int64 v5; // [rsp+28h] [rbp-8h]
  __int64 v6; // [rsp+28h] [rbp-8h]
  __int64 v7; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v4 = insert(0i64, 50i64);
  insert(v4, 30i64);
  insert(v4, 20i64);
  insert(v4, 40i64);
  insert(v4, 70i64);
  insert(v4, 60i64);
  insert(v4, 80i64);
  printf("In-order traversal of the Binary Search Tree: \n");
  inorder(v4);
  printf("\nDeleting the node with data 20: \n");
  v5 = delete(v4, 20i64);
  printf("In-order traversal of the modified Binary Search Tree: \n");
  inorder(v5);
  printf("\nDeleting the node with data 30: \n");
  v6 = delete(v5, 30i64);
  printf("In-order traversal of the modified Binary Search Tree: \n");
  inorder(v6);
  printf("\nDeleting the node with data 50: \n");
  v7 = delete(v6, 50i64);
  printf("In-order traversal of the modified Binary Search Tree: \n");
  inorder(v7);
  return 0;
}
// 1400015D5: using guessed type __int64 __fastcall insert(_QWORD, _QWORD);
// 1400016AF: using guessed type __int64 __fastcall delete(_QWORD, _QWORD);
// 1400017D9: using guessed type __int64 __fastcall inorder(_QWORD);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fractal Generation ; Style: expert-level
#include <stdio.h>
#include <math.h>

#define WIDTH 80
#define HEIGHT 40
#define MAX_ITERATIONS 50

int main() {
  int x, y, i;
  double sm, s;
  char image[WIDTH][HEIGHT];

  // initialize image
  for (y = 0; y < HEIGHT; y++) {
    for (x = 0; x < WIDTH; x++) {
      image[x][y] = ' ';
    }
  }

  // calculate fractal
  for (y = 0; y < HEIGHT; y++) {
    for (x = 0; x < WIDTH; x++) {
      sm = 0;
      s = 0;

      for (i = 0; i < MAX_ITERATIONS; i++) {
        double r = (double)x / WIDTH * 3.5 - 2.5;
        double c = (double)y / HEIGHT * 2 - 1;
        double a = r * r - c * c + sm;
        double b = 2 * r * c + s;

        if (a * a + b * b > 4) {
          break;
        }

        sm += a;
        s += b;
      }

      if (i == MAX_ITERATIONS) {
        image[x][y] = '.';
      }
    }
  }

  // print image
  for (y = 0; y < HEIGHT; y++) {
    for (x = 0; x < WIDTH; x++) {
      putchar(image[x][y]);
    }
    putchar('\n');
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl putchar(int Character);


//----- (0000000140001540) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _QWORD v4[388]; // [rsp+80h] [rbp+0h] BYREF
  double v5; // [rsp+CA0h] [rbp+C20h]
  double v6; // [rsp+CA8h] [rbp+C28h]
  double v7; // [rsp+CB0h] [rbp+C30h]
  double v8; // [rsp+CB8h] [rbp+C38h]
  double v9; // [rsp+CC0h] [rbp+C40h]
  double v10; // [rsp+CC8h] [rbp+C48h]
  int k; // [rsp+CD4h] [rbp+C54h]
  int i; // [rsp+CD8h] [rbp+C58h]
  int j; // [rsp+CDCh] [rbp+C5Ch]

  _main(argc, argv, envp);
  for ( i = 0; i <= 39; ++i )
  {
    for ( j = 0; j <= 79; ++j )
      *((_BYTE *)&v4[5 * j - 12] + i) = 32;
  }
  for ( i = 0; i <= 39; ++i )
  {
    for ( j = 0; j <= 79; ++j )
    {
      v10 = 0.0;
      v9 = 0.0;
      for ( k = 0; k <= 49; ++k )
      {
        v8 = 3.5 * ((double)j / 80.0) - 2.5;
        v7 = (double)i / 40.0 + (double)i / 40.0 - 1.0;
        v6 = v8 * v8 - v7 * v7 + v10;
        v5 = (v8 + v8) * v7 + v9;
        if ( v5 * v5 + v6 * v6 > 4.0 )
          break;
        v10 = v10 + v6;
        v9 = v9 + v5;
      }
      if ( k == 50 )
        *((_BYTE *)&v4[5 * j - 12] + i) = 46;
    }
  }
  for ( i = 0; i <= 39; ++i )
  {
    for ( j = 0; j <= 79; ++j )
      putchar(*((char *)&v4[5 * j - 12] + i));
    putchar(10);
  }
  return 0;
}
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=79 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#define G 6.67384e-11

typedef struct vector{
    double x;
    double y;
    double z;
} vector;

typedef struct planet{
    char name[50];
    double mass;
    vector position;
    vector velocity;
} planet;

void updatePosition(planet *p, double timeStep){
    double x = p->position.x + (p->velocity.x * timeStep);
    double y = p->position.y + (p->velocity.y * timeStep);
    double z = p->position.z + (p->velocity.z * timeStep);
    p->position.x = x;
    p->position.y = y;
    p->position.z = z;
}

void updateVelocity(planet *p, vector acceleration, double timeStep){
    double vx = p->velocity.x + (acceleration.x * timeStep);
    double vy = p->velocity.y + (acceleration.y * timeStep);
    double vz = p->velocity.z + (acceleration.z * timeStep);
    p->velocity.x = vx;
    p->velocity.y = vy;
    p->velocity.z = vz;
}

double calculateDistance(planet p1, planet p2){
    double xDist = p2.position.x - p1.position.x;
    double yDist = p2.position.y - p1.position.y;
    double zDist = p2.position.z - p1.position.z;
    double distance = sqrt((xDist * xDist) + (yDist * yDist) + (zDist * zDist));
    return distance;
}

vector calculateGravity(planet p1, planet p2){
    double dist = calculateDistance(p1, p2);
    double force = (G * p1.mass * p2.mass) / (dist * dist);
    double xForce = force * (p2.position.x - p1.position.x) / dist;
    double yForce = force * (p2.position.y - p1.position.y) / dist;
    double zForce = force * (p2.position.z - p1.position.z) / dist;
    vector gravity = {xForce, yForce, zForce};
    return gravity;
}

int main(){
    srand(time(NULL));
    int numPlanets = 3;
    double timeStep = 1.0;
    planet planets[numPlanets];
    double universeSize = 1e14; // 10^14 meters
    double maxVelocity = 10000; // m/s
    double maxMass = 1e25; // 10^25 kg

    // Initialize random planets
    for (int i=0; i<numPlanets; i++){
        sprintf(planets[i].name, "Planet %d", i+1);
        planets[i].mass = (double)rand()/(RAND_MAX/maxMass);
        planets[i].position.x = ((double)rand()/RAND_MAX)*universeSize;
        planets[i].position.y = ((double)rand()/RAND_MAX)*universeSize;
        planets[i].position.z = ((double)rand()/RAND_MAX)*universeSize;
        planets[i].velocity.x = ((double)rand()/RAND_MAX)*maxVelocity;
        planets[i].velocity.y = ((double)rand()/RAND_MAX)*maxVelocity;
        planets[i].velocity.z = ((double)rand()/RAND_MAX)*maxVelocity;
    }

    // Simulation loop
    for (int i=0; i<100; i++){
        printf("\nTime = %d seconds\n", i);
        for (int j=0; j<numPlanets; j++){
            vector totalGravity = {0, 0, 0};
            for (int k=0; k<numPlanets; k++){
                if (j != k){
                    vector gravity = calculateGravity(planets[j], planets[k]);
                    totalGravity.x += gravity.x;
                    totalGravity.y += gravity.y;
                    totalGravity.z += gravity.z;
                }
            }
            updateVelocity(&planets[j], totalGravity, timeStep);
            updatePosition(&planets[j], timeStep);
            printf("%s - Position: (%.2f, %.2f, %.2f), Velocity: (%.2f, %.2f, %.2f)\n", planets[j].name, planets[j].position.x, planets[j].position.y, planets[j].position.z, planets[j].velocity.x, planets[j].velocity.y, planets[j].velocity.z);
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall updatePosition(_QWORD); // weak
__int64 __fastcall updateVelocity(_QWORD, _QWORD); // weak
__int64 __fastcall calculateGravity(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001A00) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  void *v4; // rsp
  __int64 *v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rbx
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rdx
  __int64 *v13; // rax
  double v14; // rbx
  __int64 v15; // rbx
  __int64 v16; // rbx
  __int64 v17; // rbx
  __int64 v18; // rbx
  __int64 v19; // rbx
  __int64 v20; // rdx
  double v22; // [rsp+40h] [rbp-40h] BYREF
  double v23; // [rsp+48h] [rbp-38h]
  double v24; // [rsp+50h] [rbp-30h]
  __int64 v25; // [rsp+58h] [rbp-28h]
  __int64 v26; // [rsp+60h] [rbp-20h]
  __int64 v27; // [rsp+68h] [rbp-18h]
  __int64 v28; // [rsp+70h] [rbp-10h]
  __int64 v29; // [rsp+78h] [rbp-8h]
  __int64 v30; // [rsp+80h] [rbp+0h]
  __int64 v31; // [rsp+88h] [rbp+8h]
  __int64 v32; // [rsp+90h] [rbp+10h]
  __int64 v33; // [rsp+98h] [rbp+18h]
  __int64 v34; // [rsp+A0h] [rbp+20h]
  __int64 v35; // [rsp+A8h] [rbp+28h]
  __int64 v36[14]; // [rsp+B0h] [rbp+30h] BYREF
  __int64 v37[4]; // [rsp+120h] [rbp+A0h] BYREF
  double v38; // [rsp+140h] [rbp+C0h]
  double v39; // [rsp+148h] [rbp+C8h]
  double v40; // [rsp+150h] [rbp+D0h]
  double v41; // [rsp+158h] [rbp+D8h]
  double v42; // [rsp+160h] [rbp+E0h]
  double v43; // [rsp+168h] [rbp+E8h]
  double *v44; // [rsp+170h] [rbp+F0h]
  __int64 v45; // [rsp+178h] [rbp+F8h]
  __int64 v46; // [rsp+180h] [rbp+100h]
  int v47; // [rsp+18Ch] [rbp+10Ch]
  int m; // [rsp+190h] [rbp+110h]
  int k; // [rsp+194h] [rbp+114h]
  unsigned int j; // [rsp+198h] [rbp+118h]
  int i; // [rsp+19Ch] [rbp+11Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v47 = 3;
  v46 = 0x3FF0000000000000i64;
  v45 = 2i64;
  v4 = alloca(336i64);
  v44 = &v22;
  v43 = 1.0e14;
  v42 = 10000.0;
  v41 = 1.0e25;
  for ( i = 0; i < v47; ++i )
  {
    sprintf((char *const)&v44[14 * i], "Planet %d", (unsigned int)(i + 1));
    v44[14 * i + 7] = (double)rand() / (32767.0 / v41);
    v44[14 * i + 8] = (double)rand() / 32767.0 * v43;
    v44[14 * i + 9] = (double)rand() / 32767.0 * v43;
    v44[14 * i + 10] = (double)rand() / 32767.0 * v43;
    v44[14 * i + 11] = (double)rand() / 32767.0 * v42;
    v44[14 * i + 12] = (double)rand() / 32767.0 * v42;
    v44[14 * i + 13] = (double)rand() / 32767.0 * v42;
  }
  for ( j = 0; (int)j <= 99; ++j )
  {
    printf("\nTime = %d seconds\n", j);
    for ( k = 0; k < v47; ++k )
    {
      v38 = 0.0;
      v39 = 0.0;
      v40 = 0.0;
      for ( m = 0; m < v47; ++m )
      {
        if ( k != m )
        {
          v5 = (__int64 *)&v44[14 * k];
          v6 = v5[1];
          v36[0] = *v5;
          v36[1] = v6;
          v7 = v5[3];
          v36[2] = v5[2];
          v36[3] = v7;
          v8 = v5[5];
          v36[4] = v5[4];
          v36[5] = v8;
          v9 = v5[7];
          v36[6] = v5[6];
          v36[7] = v9;
          v10 = v5[9];
          v36[8] = v5[8];
          v36[9] = v10;
          v11 = v5[11];
          v36[10] = v5[10];
          v36[11] = v11;
          v12 = v5[13];
          v36[12] = v5[12];
          v36[13] = v12;
          v13 = (__int64 *)&v44[14 * m];
          v14 = *((double *)v13 + 1);
          v22 = *(double *)v13;
          v23 = v14;
          v15 = v13[3];
          v24 = *((double *)v13 + 2);
          v25 = v15;
          v16 = v13[5];
          v26 = v13[4];
          v27 = v16;
          v17 = v13[7];
          v28 = v13[6];
          v29 = v17;
          v18 = v13[9];
          v30 = v13[8];
          v31 = v18;
          v19 = v13[11];
          v32 = v13[10];
          v33 = v19;
          v20 = v13[13];
          v34 = v13[12];
          v35 = v20;
          calculateGravity(v37, v36, &v22);
          v38 = *(double *)v37 + v38;
          v39 = *(double *)&v37[1] + v39;
          v40 = *(double *)&v37[2] + v40;
        }
      }
      v22 = v38;
      v23 = v39;
      v24 = v40;
      updateVelocity(&v44[14 * k], &v22);
      updatePosition(&v44[14 * k]);
      printf(
        "%s - Position: (%.2f, %.2f, %.2f), Velocity: (%.2f, %.2f, %.2f)\n",
        (const char *)&v44[14 * k],
        v44[14 * k + 8],
        v44[14 * k + 9],
        v44[14 * k + 10],
        v44[14 * k + 11],
        v44[14 * k + 12],
        v44[14 * k + 13]);
    }
  }
  return 0;
}
// 1400015F3: using guessed type __int64 __fastcall updatePosition(_QWORD);
// 140001695: using guessed type __int64 __fastcall updateVelocity(_QWORD, _QWORD);
// 1400017D2: using guessed type __int64 __fastcall calculateGravity(_QWORD, _QWORD, _QWORD);
// 1400022C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=148 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Steganography ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct BMPHeader{
    char fileType[2];
    int fileSize;
    short reserved1;
    short reserved2;
    int dataOffset;
    int headerSize;
    int width;
    int height;
    short planes;
    short bitsPerPixel;
    int compression;
    int imageSize;
    int horizontalPPM;
    int verticalPPM;
    int colors;
    int importantColors;
};

void hideMessage(FILE *img, char *message){
    struct BMPHeader header;
    fread(&header, sizeof(header), 1, img);
    int imageSize = header.width * header.height;
    char *pixels = malloc(imageSize * 3);
    fread(pixels, imageSize * 3, 1, img);
    int messageLength = strlen(message);
    char *binaryMessage = malloc(messageLength * 8 + 1);
    int index = 0;
    for(int i = 0; i < messageLength; i++){
        char c = message[i];
        for(int j = 0; j < 8; j++){
            char bit = ((c >> j) & 1) + '0';
            binaryMessage[index++] = bit;
        }
    }
    for(int i = 0; i < index;){
        char *pixel = pixels + i / 3;
        char *byte = pixel + i % 3;
        *byte = ((*byte >> 1) << 1) | (binaryMessage[i++] - '0');
        *byte = ((*byte >> 1) << 1) | (binaryMessage[i++] - '0');
        *byte = ((*byte >> 1) << 1) | (binaryMessage[i++] - '0');
    }
    fseek(img, sizeof(header), SEEK_SET);
    fwrite(pixels, imageSize * 3, 1, img);
    free(pixels);
    free(binaryMessage);
}

char *showMessage(FILE *img){
    struct BMPHeader header;
    fread(&header, sizeof(header), 1, img);
    int imageSize = header.width * header.height;
    char *pixels = malloc(imageSize * 3);
    fread(pixels, imageSize * 3, 1, img);
    char *message = malloc(imageSize);
    int index = 0;
    for(int i = 0; i < imageSize * 3;){
        char *pixel = pixels + i / 3;
        char *byte = pixel + i % 3;
        char bit = ((*byte & 1) + '0');
        message[index++] = bit;
        if(index % 8 == 0 && message[index - 1] == '0') break;
        i++;
    }
    message[index / 8] = '\0';
    char *text = malloc(index / 8);
    for(int i = 0; i < index; i += 8){
        char byte = 0;
        for(int j = 0; j < 8; j++){
            byte |= ((message[i + j] - '0') << j);
        }
        text[i / 8] = byte;
    }
    free(pixels);
    free(message);
    return text;
}

int main(){
    FILE *img = fopen("image.bmp", "rb+");
    if(!img){
        printf("Can't open image.bmp\n");
        return 1;
    }
    char message[] = "This is a secret message";
    hideMessage(img, message);
    printf("Message hidden successfully\n");
    rewind(img);
    char *text = showMessage(img);
    printf("Hidden message: %s\n", text);
    fclose(img);
    free(text);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall hideMessage(_QWORD, _QWORD); // weak
__int64 __fastcall showMessage(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl rewind(FILE *Stream);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001A17) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[32]; // [rsp+20h] [rbp-30h] BYREF
  void *Block; // [rsp+40h] [rbp-10h]
  FILE *Stream; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  Stream = fopen("image.bmp", "rb+");
  if ( Stream )
  {
    strcpy(v4, "This is a secret message");
    hideMessage(Stream, v4);
    printf("Message hidden successfully\n");
    rewind(Stream);
    Block = (void *)showMessage(Stream);
    printf("Hidden message: %s\n", (const char *)Block);
    fclose(Stream);
    free(Block);
    return 0;
  }
  else
  {
    printf("Can't open image.bmp\n");
    return 1;
  }
}
// 140001591: using guessed type __int64 __fastcall hideMessage(_QWORD, _QWORD);
// 1400017FC: using guessed type __int64 __fastcall showMessage(_QWORD);
// 140001BC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Random ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int i, n;
    double x;
    printf("Enter the number of random numbers to generate: ");
    scanf("%d", &n);
    printf("\n");
    srand(time(NULL));
    for (i = 0; i < n; i++) {
        x = (double) rand() / RAND_MAX;
        printf("%lf\n", x);
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+2Ch] [rbp-14h] BYREF
  double v6; // [rsp+30h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of random numbers to generate: ");
  scanf("%d", &v5);
  printf("\n");
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i < v5; ++i )
  {
    v6 = (double)rand() / 32767.0;
    printf("%lf\n", v6);
  }
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bitwise operations ; Style: invasive
#include <stdio.h>

int main() {
    printf("Welcome to the Bitwise Invasion!\n");

    int num1 = 6;
    int num2 = 3;

    printf("Before bitwise operations:\n");
    printf("num1 = %d\n", num1);
    printf("num2 = %d\n", num2);

    // Bitwise AND operation
    num1 = num1 & num2;
    printf("\nAfter performing Bitwise AND operation:\n");
    printf("num1 = %d\n", num1);
    printf("num2 = %d\n", num2);

    // Bitwise OR operation
    num1 = num1 | num2;
    printf("\nAfter performing Bitwise OR operation:\n");
    printf("num1 = %d\n", num1);
    printf("num2 = %d\n", num2);

    // Bitwise XOR operation
    num1 = num1 ^ num2;
    printf("\nAfter performing Bitwise XOR operation:\n");
    printf("num1 = %d\n", num1);
    printf("num2 = %d\n", num2);

    // Bitwise NOT operation
    num1 = ~num1;
    printf("\nAfter performing Bitwise NOT operation:\n");
    printf("num1 = %d\n", num1);

    // Bitwise left shift operation
    num1 = num1 << 2;
    printf("\nAfter performing Bitwise left shift operation:\n");
    printf("num1 = %d\n", num1);

    // Bitwise right shift operation
    num1 = num1 >> 2;
    printf("\nAfter performing Bitwise right shift operation:\n");
    printf("num1 = %d\n", num1);

    printf("\nThank you for using the Bitwise Invasion program!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("Welcome to the Bitwise Invasion!\n");
  printf("Before bitwise operations:\n");
  printf("num1 = %d\n", 6i64);
  printf("num2 = %d\n", 3i64);
  printf("\nAfter performing Bitwise AND operation:\n");
  printf("num1 = %d\n", 2i64);
  printf("num2 = %d\n", 3i64);
  printf("\nAfter performing Bitwise OR operation:\n");
  printf("num1 = %d\n", 3i64);
  printf("num2 = %d\n", 3i64);
  printf("\nAfter performing Bitwise XOR operation:\n");
  printf("num1 = %d\n", 0i64);
  printf("num2 = %d\n", 3i64);
  printf("\nAfter performing Bitwise NOT operation:\n");
  printf("num1 = %d\n", 0xFFFFFFFFi64);
  printf("\nAfter performing Bitwise left shift operation:\n");
  printf("num1 = %d\n", 4294967292i64);
  printf("\nAfter performing Bitwise right shift operation:\n");
  printf("num1 = %d\n", 0xFFFFFFFFi64);
  printf("\nThank you for using the Bitwise Invasion program!\n");
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: grateful
#include <stdio.h>
#include <stdlib.h>

// Define constants for menu prices
#define COFFEE_PRICE 2.00
#define TEA_PRICE 1.50
#define PASTRY_PRICE 3.00
#define SANDWICH_PRICE 4.50

int main() {
    int option, quantity;
    float subtotal = 0.00, tax = 0.00, total = 0.00;
    
    printf("Welcome to Grateful Cafe!\n");
    printf("Here is our menu:\n");
    printf("1. Coffee ($%.2f)\n", COFFEE_PRICE);
    printf("2. Tea ($%.2f)\n", TEA_PRICE);
    printf("3. Pastry ($%.2f)\n", PASTRY_PRICE);
    printf("4. Sandwich ($%.2f)\n", SANDWICH_PRICE);
    
    printf("Enter the number of the item you would like to order (or 0 to exit): ");
    scanf("%d", &option);
    
    while (option != 0) {
        switch(option) {
            case 1:
                printf("How many coffees would you like to order? ");
                scanf("%d", &quantity);
                subtotal += COFFEE_PRICE * quantity;
                break;
            case 2:
                printf("How many teas would you like to order? ");
                scanf("%d", &quantity);
                subtotal += TEA_PRICE * quantity;
                break;
            case 3:
                printf("How many pastries would you like to order? ");
                scanf("%d", &quantity);
                subtotal += PASTRY_PRICE * quantity;
                break;
            case 4:
                printf("How many sandwiches would you like to order? ");
                scanf("%d", &quantity);
                subtotal += SANDWICH_PRICE * quantity;
                break;
            default:
                printf("Invalid option. Please select a valid option.\n");
                break;
        }
        
        // Ask for another order or end the loop
        printf("Enter the number of the item you would like to order (or 0 to exit): ");
        scanf("%d", &option);
    }
    
    // Calculate tax and total
    tax = subtotal * 0.08;
    total = subtotal + tax;
    
    // Print receipt
    printf("\n\n\n");
    printf("*********************************************\n");
    printf("************| THANK YOU! |********************\n");
    printf("*********************************************\n");
    printf("================= RECEIPT ====================\n");
    printf("==============================================\n");
    printf("\n");
    printf("Subtotal: $%.2f\n", subtotal);
    printf("Tax (8%%): $%.2f\n", tax);
    printf("Total: $%.2f\n", total);
    printf("\n");
    printf("==============================================\n");
    printf("==============================================\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  float v7; // xmm0_4
  int v9; // [rsp+2Ch] [rbp-14h] BYREF
  int v10; // [rsp+30h] [rbp-10h] BYREF
  float v11; // [rsp+34h] [rbp-Ch]
  float v12; // [rsp+38h] [rbp-8h]
  float v13; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v13 = 0.0;
  v12 = 0.0;
  v11 = 0.0;
  printf("Welcome to Grateful Cafe!\n");
  printf("Here is our menu:\n");
  printf("1. Coffee ($%.2f)\n", 2.0);
  printf("2. Tea ($%.2f)\n", 1.5);
  printf("3. Pastry ($%.2f)\n", 3.0);
  printf("4. Sandwich ($%.2f)\n", 4.5);
  printf("Enter the number of the item you would like to order (or 0 to exit): ");
  scanf("%d", &v10);
  while ( v10 )
  {
    if ( v10 == 4 )
    {
      printf("How many sandwiches would you like to order? ");
      scanf("%d", &v9);
      v6 = 4.5 * (double)v9 + v13;
      v13 = v6;
    }
    else
    {
      if ( v10 <= 4 )
      {
        switch ( v10 )
        {
          case 3:
            printf("How many pastries would you like to order? ");
            scanf("%d", &v9);
            v5 = 3.0 * (double)v9 + v13;
            v13 = v5;
            goto LABEL_13;
          case 1:
            printf("How many coffees would you like to order? ");
            scanf("%d", &v9);
            v3 = (double)v9 + (double)v9 + v13;
            v13 = v3;
            goto LABEL_13;
          case 2:
            printf("How many teas would you like to order? ");
            scanf("%d", &v9);
            v4 = 1.5 * (double)v9 + v13;
            v13 = v4;
            goto LABEL_13;
        }
      }
      printf("Invalid option. Please select a valid option.\n");
    }
LABEL_13:
    printf("Enter the number of the item you would like to order (or 0 to exit): ");
    scanf("%d", &v10);
  }
  v7 = 0.08 * v13;
  v12 = v7;
  v11 = v13 + v7;
  printf("\n\n\n");
  printf("*********************************************\n");
  printf("************| THANK YOU! |********************\n");
  printf("*********************************************\n");
  printf("================= RECEIPT ====================\n");
  printf("==============================================\n");
  printf("\n");
  printf("Subtotal: $%.2f\n", v13);
  printf("Tax (8%%): $%.2f\n", v12);
  printf("Total: $%.2f\n", v11);
  printf("\n");
  printf("==============================================\n");
  printf("==============================================\n");
  return 0;
}
// 140001713: conditional instruction was optimized away because %var_10.4 is in (1..2|<0)
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: thoughtful
#include <stdio.h>

// Function to calculate Fibonacci sequence for n terms
void fibonacci(int n)
{
    int i, first = 0, second = 1, next;
    printf("Fibonacci Sequence:\n");
    for (i = 1; i <= n; i++)
    {
        printf("%d ", first);
        next = first + second;
        first = second;
        second = next;
    }
}

// Function to draw Fibonacci sequence as a shape
void drawFibonacci(int n)
{
    int i, first = 0, second = 1, next, space = 5;
    printf("\n\nFibonacci Shape:\n\n");
    for (i = 1; i <= n; i++)
    {
        next = first + second;
        first = second;
        second = next;
        for (int j = 1; j <= space; j++)
        {
            printf(" ");
        }
        space -= 2;
        for (int j = 1; j <= i; j++)
        {
            printf("%d ", next);
        }
        printf("\n");
    }
}

// Driver code
int main()
{
    int n;
    printf("Enter the number of terms for Fibonacci sequence:\n");
    scanf("%d", &n);
    fibonacci(n);
    drawFibonacci(n);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall fibonacci(_QWORD); // weak
__int64 __fastcall drawFibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001719) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the number of terms for Fibonacci sequence:\n");
  scanf("%d", &v4);
  fibonacci(v4);
  drawFibonacci(v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001652: using guessed type __int64 __fastcall drawFibonacci(_QWORD);
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Compression algorithms ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#define MAX_LENGTH 100

char* compress(char* str);

int main() {
    char str[MAX_LENGTH];
    printf("Enter a string to compress: ");
    scanf("%[^\n]", str);
    char* compressed_str = compress(str);
    printf("Compressed string: %s\n", compressed_str);
    free(compressed_str); // free memory to avoid memory leaks
    return 0;
}

char* compress(char* str) {
    int len = strlen(str);
    char* compressed_str = malloc((len + 1) * sizeof(char)); // allocate memory to store compressed string
    int index = 0;
    for (int i = 0; i < len; i++) {
        if (isalpha(str[i])) { // if current character is a letter
            compressed_str[index++] = tolower(str[i]); // add lowercase version of character to compressed string
        } else if (isdigit(str[i])) { // if current character is a digit
            int count = str[i] - '0'; // get the count of repetitions of previous character
            while (count > 1) { // add count - 1 copies of previous character to compressed string
                compressed_str[index++] = compressed_str[index-2];
                count--;
            }
        } else { // if current character is not a letter or digit, ignore it
            continue;
        }
    }
    compressed_str[index] = '\0'; // add null terminator to compressed string
    return compressed_str;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall compress(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[104]; // [rsp+20h] [rbp-70h] BYREF
  void *Block; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a string to compress: ");
  scanf("%[^\n]", v4);
  Block = (void *)compress(v4);
  printf("Compressed string: %s\n", (const char *)Block);
  free(Block);
  return 0;
}
// 140001657: using guessed type __int64 __fastcall compress(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Benchmarking ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int num_iterations = 1000000000;
    clock_t start_time, end_time;
    double time_elapsed;

    // Benchmarking function
    start_time = clock();
    for (int i = 0; i < num_iterations; i++) {
        // Do some computation here
    }
    end_time = clock();

    time_elapsed = ((double) (end_time - start_time)) / CLOCKS_PER_SEC;

    printf("Time elapsed: %f seconds\n", time_elapsed);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// clock_t __cdecl clock();


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+28h] [rbp-18h]
  clock_t v5; // [rsp+34h] [rbp-Ch]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5 = clock();
  for ( i = 0; i < 1000000000; ++i )
    ;
  v4 = (double)(clock() - v5) / 1000.0;
  printf("Time elapsed: %f seconds\n", v4);
  return 0;
}
// 1400016D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Unit converter ; Style: retro
#include<stdio.h>
#include<stdlib.h>

int main()
{
    int choice;
    float inch, feet, meter, cel, fahr, mile, km, pound, kg;

    printf("***Retro Style Unit Converter***\n\n");

    printf("Enter your choice:\n");
    printf("1. Inches to Feet\n");
    printf("2. Feet to Inches\n");
    printf("3. Meters to Feet\n");
    printf("4. Feet to Meters\n");
    printf("5. Celsius to Fahrenheit\n");
    printf("6. Fahrenheit to Celsius\n");
    printf("7. Miles to Kilometers\n");
    printf("8. Kilometers to Miles\n");
    printf("9. Pounds to Kilograms\n");
    printf("10. Kilograms to Pounds\n");
    scanf("%d", &choice);

    switch(choice){

        case 1:
            printf("Enter the value in inches: ");
            scanf("%f",&inch);
            feet = inch/12.0;
            printf("%.2f inches is equal to %.2f feet.\n", inch, feet);
            break;

        case 2:
            printf("Enter the value in feet: ");
            scanf("%f",&feet);
            inch = feet*12.0;
            printf("%.2f feet is equal to %.2f inches.\n", feet, inch);
            break;

        case 3:
            printf("Enter the value in meters: ");
            scanf("%f",&meter);
            feet = meter/0.3048;
            printf("%.2f meters is equal to %.2f feet.\n", meter, feet);
            break;

        case 4:
            printf("Enter the value in feet: ");
            scanf("%f",&feet);
            meter = feet*0.3048;
            printf("%.2f feet is equal to %.2f meters.\n", feet, meter);
            break;

        case 5:
            printf("Enter the temperature in Celsius: ");
            scanf("%f",&cel);
            fahr = (cel*1.8)+32;
            printf("%.2f Celsius is equal to %.2f Fahrenheit.\n", cel, fahr);
            break;

        case 6:
            printf("Enter the temperature in Fahrenheit: ");
            scanf("%f",&fahr);
            cel = (fahr-32)/1.8;
            printf("%.2f Fahrenheit is equal to %.2f Celsius.\n", fahr, cel);
            break;

        case 7:
            printf("Enter the value in miles: ");
            scanf("%f",&mile);
            km = mile*1.60934;
            printf("%.2f miles is equal to %.2f kilometers.\n", mile, km);
            break;

        case 8:
            printf("Enter the value in kilometers: ");
            scanf("%f",&km);
            mile = km/1.60934;
            printf("%.2f kilometers is equal to %.2f miles.\n", km, mile);
            break;

        case 9:
            printf("Enter the weight in pounds: ");
            scanf("%f",&pound);
            kg = pound*0.453592;
            printf("%.2f pounds is equal to %.2f kilograms.\n", pound, kg);
            break;

        case 10:
            printf("Enter the weight in kilograms: ");
            scanf("%f",&kg);
            pound = kg/0.453592;
            printf("%.2f kilograms is equal to %.2f pounds.\n", kg, pound);
            break;

        default:
            printf("Invalid choice! Try again.");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  float v7; // xmm0_4
  float v8; // xmm0_4
  float v9; // xmm0_4
  float v10; // xmm0_4
  float v12; // [rsp+28h] [rbp-28h] BYREF
  float v13; // [rsp+2Ch] [rbp-24h] BYREF
  float v14; // [rsp+30h] [rbp-20h] BYREF
  float v15; // [rsp+34h] [rbp-1Ch] BYREF
  float v16; // [rsp+38h] [rbp-18h] BYREF
  float v17; // [rsp+3Ch] [rbp-14h] BYREF
  float v18; // [rsp+40h] [rbp-10h] BYREF
  float v19; // [rsp+44h] [rbp-Ch] BYREF
  float v20; // [rsp+48h] [rbp-8h] BYREF
  int v21; // [rsp+4Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("***Retro Style Unit Converter***\n\n");
  printf("Enter your choice:\n");
  printf("1. Inches to Feet\n");
  printf("2. Feet to Inches\n");
  printf("3. Meters to Feet\n");
  printf("4. Feet to Meters\n");
  printf("5. Celsius to Fahrenheit\n");
  printf("6. Fahrenheit to Celsius\n");
  printf("7. Miles to Kilometers\n");
  printf("8. Kilometers to Miles\n");
  printf("9. Pounds to Kilograms\n");
  printf("10. Kilograms to Pounds\n");
  scanf("%d", &v21);
  switch ( v21 )
  {
    case 1:
      printf("Enter the value in inches: ");
      scanf("%f", &v20);
      v19 = v20 / 12.0;
      printf("%.2f inches is equal to %.2f feet.\n", v20, (float)(v20 / 12.0));
      break;
    case 2:
      printf("Enter the value in feet: ");
      scanf("%f", &v19);
      v20 = 12.0 * v19;
      printf("%.2f feet is equal to %.2f inches.\n", v19, (float)(12.0 * v19));
      break;
    case 3:
      printf("Enter the value in meters: ");
      scanf("%f", &v18);
      v3 = v18 / 0.3048;
      v19 = v3;
      printf("%.2f meters is equal to %.2f feet.\n", v18, v3);
      break;
    case 4:
      printf("Enter the value in feet: ");
      scanf("%f", &v19);
      v4 = 0.3048 * v19;
      v18 = v4;
      printf("%.2f feet is equal to %.2f meters.\n", v19, v4);
      break;
    case 5:
      printf("Enter the temperature in Celsius: ");
      scanf("%f", &v17);
      v5 = v17 * 1.8 + 32.0;
      v16 = v5;
      printf("%.2f Celsius is equal to %.2f Fahrenheit.\n", v17, v5);
      break;
    case 6:
      printf("Enter the temperature in Fahrenheit: ");
      scanf("%f", &v16);
      v6 = (float)(v16 - 32.0) / 1.8;
      v17 = v6;
      printf("%.2f Fahrenheit is equal to %.2f Celsius.\n", v16, v6);
      break;
    case 7:
      printf("Enter the value in miles: ");
      scanf("%f", &v15);
      v7 = 1.60934 * v15;
      v14 = v7;
      printf("%.2f miles is equal to %.2f kilometers.\n", v15, v7);
      break;
    case 8:
      printf("Enter the value in kilometers: ");
      scanf("%f", &v14);
      v8 = v14 / 1.60934;
      v15 = v8;
      printf("%.2f kilometers is equal to %.2f miles.\n", v14, v8);
      break;
    case 9:
      printf("Enter the weight in pounds: ");
      scanf("%f", &v13);
      v9 = 0.453592 * v13;
      v12 = v9;
      printf("%.2f pounds is equal to %.2f kilograms.\n", v13, v9);
      break;
    case 10:
      printf("Enter the weight in kilograms: ");
      scanf("%f", &v12);
      v10 = v12 / 0.453592;
      v13 = v10;
      printf("%.2f kilograms is equal to %.2f pounds.\n", v12, v10);
      break;
    default:
      printf("Invalid choice! Try again.");
      break;
  }
  return 0;
}
// 140001DC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database simulation ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_DB_SIZE 100

struct student {
    int id;
    char name[50];
    float score;
};

struct student_db {
    struct student students[MAX_DB_SIZE];
    int count;
};

void add_student(struct student_db *db) {
    if (db->count == MAX_DB_SIZE) {
        printf("Error: Database is full.\n");
        return;
    }

    struct student new_student;
    printf("Enter student ID: ");
    scanf("%d", &new_student.id);
    printf("Enter student name: ");
    scanf("%s", new_student.name);
    printf("Enter student score: ");
    scanf("%f", &new_student.score);

    db->students[db->count] = new_student;
    db->count++;
    printf("Student added to database.\n");
}

void print_database(struct student_db *db) {
    printf("ID\tName\tScore\n");
    for (int i = 0; i < db->count; i++) {
        struct student s = db->students[i];
        printf("%d\t%s\t%.2f\n", s.id, s.name, s.score);
    }
}

void save_database(struct student_db *db) {
    char filename[50];
    printf("Enter filename: ");
    scanf("%s", filename);

    FILE *fp = fopen(filename, "w");
    for (int i = 0; i < db->count; i++) {
        struct student s = db->students[i];
        fprintf(fp, "%d,%s,%.2f\n", s.id, s.name, s.score);
    }
    fclose(fp);
    printf("Database saved to file.\n");
}

void load_database(struct student_db *db) {
    char filename[50];
    printf("Enter filename: ");
    scanf("%s", filename);

    FILE *fp = fopen(filename, "r");
    if (fp == NULL) {
        printf("Error: Could not open file.\n");
        return;
    }

    char line[100];
    while (fgets(line, 100, fp) != NULL) {
        struct student s;
        char *token = strtok(line, ",");
        s.id = atoi(token);
        token = strtok(NULL, ",");
        strcpy(s.name, token);
        token = strtok(NULL, ",");
        s.score = atof(token);
        db->students[db->count] = s;
        db->count++;
    }

    fclose(fp);
    printf("Database loaded from file.\n");
}

int main() {
    struct student_db db = {0};

    int choice = 0;
    while (choice != 5) {
        printf("\n1. Add student\n");
        printf("2. Print database\n");
        printf("3. Save database\n");
        printf("4. Load database\n");
        printf("5. Quit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1: add_student(&db); break;
            case 2: print_database(&db); break;
            case 3: save_database(&db); break;
            case 4: load_database(&db); break;
            case 5: printf("Goodbye!\n"); break;
            default: printf("Invalid choice.\n"); break;
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_student(_QWORD); // weak
__int64 __fastcall print_database(_QWORD); // weak
__int64 __fastcall save_database(_QWORD); // weak
__int64 __fastcall load_database(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001B46) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-54h] BYREF
  char v5[6000]; // [rsp+30h] [rbp-50h] BYREF
  int v6; // [rsp+17A0h] [rbp+1720h]

  _main(argc, argv, envp);
  memset(v5, 0, sizeof(v5));
  v6 = 0;
  v4 = 0;
  while ( v4 != 5 )
  {
    printf("\n1. Add student\n");
    printf("2. Print database\n");
    printf("3. Save database\n");
    printf("4. Load database\n");
    printf("5. Quit\n");
    printf("Enter choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        add_student(v5);
        break;
      case 2:
        print_database(v5);
        break;
      case 3:
        save_database(v5);
        break;
      case 4:
        load_database(v5);
        break;
      case 5:
        printf("Goodbye!\n");
        break;
      default:
        printf("Invalid choice.\n");
        break;
    }
  }
  return 0;
}
// 140001625: using guessed type __int64 __fastcall add_student(_QWORD);
// 14000175B: using guessed type __int64 __fastcall print_database(_QWORD);
// 14000183C: using guessed type __int64 __fastcall save_database(_QWORD);
// 14000196D: using guessed type __int64 __fastcall load_database(_QWORD);
// 140001D50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: RAM usage monitor ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int main(void) {
    FILE *fp;
    char buffer[1024], *ptr;
    int total_mem, used_mem, free_mem;
    float mem_used_pct;

    fp = fopen("/proc/meminfo", "r");
    if (fp == NULL) {
        printf("Error opening /proc/meminfo.\n");
        exit(EXIT_FAILURE);
    }

    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
        if (strstr(buffer, "MemTotal:") != NULL) {
            ptr = buffer + strlen("MemTotal:");
            total_mem = strtol(ptr, &ptr, 10) * 1024;
        }
        else if (strstr(buffer, "MemFree:") != NULL) {
            ptr = buffer + strlen("MemFree:");
            free_mem = strtol(ptr, &ptr, 10) * 1024;
        }
        else if (strstr(buffer, "Buffers:") != NULL || strstr(buffer, "Cached:") != NULL) {
            ptr = buffer + strcspn(buffer, "0123456789");
            used_mem += strtol(ptr, &ptr, 10) * 1024;
        }
    }

    fclose(fp);

    used_mem = total_mem - free_mem;

    mem_used_pct = ((float) used_mem / (float) total_mem) * 100.0;

    printf("Total memory: %d KB\n", total_mem / 1024);
    printf("Used memory: %d KB\n", used_mem / 1024);
    printf("Free memory: %d KB\n", free_mem / 1024);
    printf("Memory usage: %.2f%%\n", mem_used_pct);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  char *String; // [rsp+28h] [rbp-58h] BYREF
  char Str[8]; // [rsp+30h] [rbp-50h] BYREF
  char v7; // [rsp+38h] [rbp-48h] BYREF
  char v8[1019]; // [rsp+39h] [rbp-47h] BYREF
  float v9; // [rsp+434h] [rbp+3B4h]
  FILE *Stream; // [rsp+438h] [rbp+3B8h]
  int v11; // [rsp+444h] [rbp+3C4h]
  int v12; // [rsp+448h] [rbp+3C8h]
  int v13; // [rsp+44Ch] [rbp+3CCh]

  _main(argc, argv, envp);
  Stream = fopen("/proc/meminfo", "r");
  if ( !Stream )
  {
    printf("Error opening /proc/meminfo.\n");
    exit(1);
  }
  while ( fgets(Str, 1024, Stream) )
  {
    if ( strstr(Str, "MemTotal:") )
    {
      String = v8;
      v13 = strtol(v8, &String, 10) << 10;
    }
    else if ( strstr(Str, "MemFree:") )
    {
      String = &v7;
      v11 = strtol(&v7, &String, 10) << 10;
    }
    else if ( strstr(Str, "Buffers:") || strstr(Str, "Cached:") )
    {
      String = &Str[strcspn(Str, "0123456789")];
      v3 = strtol(String, &String, 10);
      v12 += v3 << 10;
    }
  }
  fclose(Stream);
  v12 = v13 - v11;
  v9 = 100.0 * (float)((float)(v13 - v11) / (float)v13);
  printf("Total memory: %d KB\n", (unsigned int)(v13 / 1024));
  printf("Used memory: %d KB\n", (unsigned int)(v12 / 1024));
  printf("Free memory: %d KB\n", (unsigned int)(v11 / 1024));
  printf("Memory usage: %.2f%%\n", v9);
  return 0;
}
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Str[8];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct WarehouseItem {
    int ID;
    char itemName[50];
    int quantity;
    float price;
};

struct Warehouse {
    struct WarehouseItem* items;
    int capacity;
    int itemCount;
};

void initWarehouse(struct Warehouse* warehouse) {
    warehouse->capacity = 10;
    warehouse->itemCount = 0;
    warehouse->items = (struct WarehouseItem*)malloc(warehouse->capacity * sizeof(struct WarehouseItem));
}

void addItem(struct Warehouse* warehouse, struct WarehouseItem item) {
    if (warehouse->itemCount >= warehouse->capacity) {
        warehouse->capacity *= 2;
        warehouse->items = (struct WarehouseItem*)realloc(warehouse->items, warehouse->capacity * sizeof(struct WarehouseItem));
    }
    warehouse->items[warehouse->itemCount] = item;
    warehouse->itemCount++;
}

void removeItem(struct Warehouse* warehouse, int id) {
    int index = -1;
    for (int i = 0; i < warehouse->itemCount; i++) {
        if (warehouse->items[i].ID == id) {
            index = i;
            break;
        }
    }

    if (index == -1) {
        printf("Item with ID %d not found in warehouse.\n", id);
        return;
    }

    for (int i = index; i < warehouse->itemCount - 1; i++) {
        warehouse->items[i] = warehouse->items[i + 1];
    }
    warehouse->itemCount--;
}

void displayWarehouse(struct Warehouse* warehouse) {
    printf("Warehouse inventory:\n");
    for (int i = 0; i < warehouse->itemCount; i++) {
        struct WarehouseItem item = warehouse->items[i];
        printf("Item ID: %d | Item Name: %s | Quantity: %d | Price: $%.2f\n", item.ID, item.itemName, item.quantity, item.price);
    }
}

int main() {
    struct Warehouse warehouse;
    initWarehouse(&warehouse);

    struct WarehouseItem item1 = { 1, "Shoes", 20, 49.99 };
    addItem(&warehouse, item1);
    struct WarehouseItem item2 = { 2, "Bags", 15, 29.99 };
    addItem(&warehouse, item2);
    struct WarehouseItem item3 = { 3, "Hats", 30, 9.99 };
    addItem(&warehouse, item3);

    removeItem(&warehouse, 4);
    removeItem(&warehouse, 2);

    displayWarehouse(&warehouse);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall initWarehouse(_QWORD); // weak
__int64 __fastcall addItem(_QWORD, _QWORD); // weak
__int64 __fastcall removeItem(_QWORD, _QWORD); // weak
__int64 __fastcall displayWarehouse(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001886) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-60h] BYREF
  __int128 v5; // [rsp+28h] [rbp-58h]
  __int128 v6; // [rsp+38h] [rbp-48h]
  __int128 v7; // [rsp+48h] [rbp-38h]
  __int64 v8; // [rsp+58h] [rbp-28h]
  _BYTE v9[56]; // [rsp+60h] [rbp-20h] BYREF
  __int64 v10; // [rsp+98h] [rbp+18h]
  _BYTE v11[56]; // [rsp+A0h] [rbp+20h] BYREF
  __int64 v12; // [rsp+D8h] [rbp+58h]
  _BYTE v13[56]; // [rsp+E0h] [rbp+60h] BYREF
  __int64 v14; // [rsp+118h] [rbp+98h]
  char v15[16]; // [rsp+120h] [rbp+A0h] BYREF

  _main(argc, argv, envp);
  initWarehouse(v15);
  *(_DWORD *)v13 = 1;
  *(_OWORD *)&v13[4] = 0x73656F6853ui64;
  memset(&v13[20], 0, 34);
  v14 = 0x4247F5C300000014i64;
  v4 = *(_QWORD *)v13;
  v5 = *(_OWORD *)&v13[8];
  v6 = *(_OWORD *)&v13[24];
  v7 = *(_OWORD *)&v13[40];
  v8 = 0x4247F5C300000014i64;
  addItem(v15, &v4);
  *(_DWORD *)v11 = 2;
  *(_OWORD *)&v11[4] = 0x73676142ui64;
  memset(&v11[20], 0, 34);
  v12 = 0x41EFEB850000000Fi64;
  v4 = *(_QWORD *)v11;
  v5 = *(_OWORD *)&v11[8];
  v6 = *(_OWORD *)&v11[24];
  v7 = *(_OWORD *)&v11[40];
  v8 = 0x41EFEB850000000Fi64;
  addItem(v15, &v4);
  *(_DWORD *)v9 = 3;
  *(_OWORD *)&v9[4] = 0x73746148ui64;
  memset(&v9[20], 0, 34);
  v10 = 0x411FD70A0000001Ei64;
  v4 = *(_QWORD *)v9;
  v5 = *(_OWORD *)&v9[8];
  v6 = *(_OWORD *)&v9[24];
  v7 = *(_OWORD *)&v9[40];
  v8 = 0x411FD70A0000001Ei64;
  addItem(v15, &v4);
  removeItem(v15, 4i64);
  removeItem(v15, 2i64);
  displayWarehouse(v15);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall initWarehouse(_QWORD);
// 1400015D9: using guessed type __int64 __fastcall addItem(_QWORD, _QWORD);
// 1400016A2: using guessed type __int64 __fastcall removeItem(_QWORD, _QWORD);
// 1400017B0: using guessed type __int64 __fastcall displayWarehouse(_QWORD);
// 140001BB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home light control ; Style: ultraprecise
#include <stdio.h>
#include <string.h>

/* Define the maximum number of devices */
#define MAX_DEVICES 10

/* Define the structure for each device */
struct device {
    char name[20];
    int state;
};

/* Function prototypes */
void print_devices(struct device * devices, int num_devices);
void toggle_device(struct device * devices, int device_num);

/* Main program */
int main() {
    /* Initialize devices */
    struct device devices[MAX_DEVICES] = {
        {"Bedroom Light", 0},
        {"Living Room Light", 0},
        {"Kitchen Light", 0},
        {"Bathroom Light", 0}
    };
    int num_devices = 4;
    
    /* Print initial device states */
    printf("Initial device states:\n");
    print_devices(devices, num_devices);
    
    /* Loop until user quits */
    char input[20];
    while (1) {
        printf("Enter device name to toggle (or 'quit' to exit): ");
        fgets(input, 20, stdin);
        input[strlen(input)-1] = '\0';  // Remove newline character
        
        if (strcmp(input, "quit") == 0) {
            break;
        }
        
        /* Find device with matching name */
        int found = 0;
        for (int i = 0; i < num_devices; i++) {
            if (strcmp(input, devices[i].name) == 0) {
                /* Toggle device state */
                toggle_device(devices, i);
                found = 1;
                break;
            }
        }
        
        if (!found) {
            printf("Device not found.\n");
        } else {
            /* Print updated device states */
            print_devices(devices, num_devices);
        }
    }
    
    return 0;
}

/* Function definitions */

/* Prints the current state of each device */
void print_devices(struct device * devices, int num_devices) {
    printf("Device states:\n");
    for (int i = 0; i < num_devices; i++) {
        printf("%s: %s\n", devices[i].name, devices[i].state ? "On" : "Off");
    }
}

/* Toggles the state of a device */
void toggle_device(struct device * devices, int device_num) {
    devices[device_num].state = !devices[device_num].state;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall print_devices(_QWORD, _QWORD); // weak
__int64 __fastcall toggle_device(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[32]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v6[30]; // [rsp+40h] [rbp-40h] BYREF
  unsigned int v7; // [rsp+134h] [rbp+B4h]
  unsigned int i; // [rsp+138h] [rbp+B8h]
  int v9; // [rsp+13Ch] [rbp+BCh]

  _main(argc, argv, envp);
  memset(v6, 0, sizeof(v6));
  strcpy((char *)v6, "Bedroom Light");
  HIWORD(v6[1]) = 0;
  LODWORD(v6[2]) = 0;
  strcpy((char *)&v6[3], "Living Room Light");
  WORD1(v6[5]) = 0;
  strcpy((char *)&v6[6], "Kitchen Light");
  HIWORD(v6[7]) = 0;
  LODWORD(v6[8]) = 0;
  strcpy((char *)&v6[9], "Bathroom Light");
  HIBYTE(v6[10]) = 0;
  LODWORD(v6[11]) = 0;
  v7 = 4;
  printf("Initial device states:\n");
  print_devices(v6, v7);
  while ( 1 )
  {
    printf("Enter device name to toggle (or 'quit' to exit): ");
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 20, v3);
    Buffer[strlen(Buffer) - 1] = 0;
    if ( !strcmp(Buffer, "quit") )
      return 0;
    v9 = 0;
    for ( i = 0; (int)i < (int)v7; ++i )
    {
      if ( !strcmp(Buffer, (const char *)&v6[3 * (int)i]) )
      {
        toggle_device(v6, i);
        v9 = 1;
        break;
      }
    }
    if ( v9 )
      print_devices(v6, v7);
    else
      printf("Device not found.\n");
  }
}
// 140001791: using guessed type __int64 __fastcall print_devices(_QWORD, _QWORD);
// 140001832: using guessed type __int64 __fastcall toggle_device(_QWORD, _QWORD);
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[32];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Classification system ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_IMAGES 1000
#define MAX_CLASSES 10
#define MAX_DIMENSION 784

// Image structure
typedef struct
{
    int pixels[MAX_DIMENSION];  // flattened pixel data
    int class;                  // class label
} Image;

// Class structure
typedef struct
{
    Image images[MAX_IMAGES];   // images belonging to this class
    int count;                  // number of images in this class
} Class;

// Dataset structure
typedef struct
{
    Class classes[MAX_CLASSES]; // classes in dataset
    int count;                  // number of classes in dataset
} Dataset;

// Function prototypes
void load_dataset(Dataset* dataset, char* filename);
double cosine_similarity(int* a, int* b, int size);
int classify_image(Image* image, Dataset* dataset);

// Main function
int main(int argc, char* argv[])
{
    // Load dataset
    Dataset dataset;
    load_dataset(&dataset, "dataset.txt");

    // Test image
    Image test_image;
    test_image.pixels[0] = 1;
    test_image.pixels[1] = 2;
    test_image.pixels[2] = 3;

    // Classify image
    int class = classify_image(&test_image, &dataset);

    // Print result
    printf("The image is classified as class %d\n", class);

    return 0;
}

// Function to load dataset from file
void load_dataset(Dataset* dataset, char* filename)
{
    // Open file
    FILE* file = fopen(filename, "r");
    if (file == NULL)
    {
        printf("Failed to open file %s\n", filename);
        exit(1);
    }

    // Initialize dataset
    dataset->count = 0;

    // Read classes from file
    while (!feof(file))
    {
        // Read class label
        int class_label;
        fscanf(file, "%d", &class_label);

        // Create new class
        Class class;
        class.count = 0;

        // Read images belonging to class
        while (!feof(file))
        {
            // Read image pixels
            Image image;
            for (int i = 0; i < MAX_DIMENSION; i++)
            {
                fscanf(file, "%d", &image.pixels[i]);
            }

            // Set image class label
            image.class = class_label;

            // Add image to class
            class.images[class.count++] = image;

            // Check if class is full
            if (class.count == MAX_IMAGES)
            {
                break;
            }
        }

        // Add class to dataset
        dataset->classes[dataset->count++] = class;

        // Check if dataset is full
        if (dataset->count == MAX_CLASSES)
        {
            break;
        }
    }

    // Close file
    fclose(file);
}

// Function to calculate cosine similarity between two vectors
double cosine_similarity(int* a, int* b, int size)
{
    double dot_product = 0.0;
    double a_norm = 0.0;
    double b_norm = 0.0;

    for (int i = 0; i < size; i++)
    {
        dot_product += a[i] * b[i];
        a_norm += a[i] * a[i];
        b_norm += b[i] * b[i];
    }

    a_norm = sqrt(a_norm);
    b_norm = sqrt(b_norm);

    double similarity = dot_product / (a_norm * b_norm);

    return similarity;
}

// Function to classify image using nearest neighbor algorithm
int classify_image(Image* image, Dataset* dataset)
{
    int best_class = -1;
    double best_similarity = -1.0;

    // Compare image against all images in dataset
    for (int i = 0; i < dataset->count; i++)
    {
        for (int j = 0; j < dataset->classes[i].count; j++)
        {
            double similarity = cosine_similarity(image->pixels, dataset->classes[i].images[j].pixels, MAX_DIMENSION);

            if (similarity > best_similarity)
            {
                best_similarity = similarity;
                best_class = dataset->classes[i].images[j].class;
            }
        }
    }

    return best_class;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (00000001400015D4) ----------------------------------------------------
#error "1400015D4: stack frame is too big (funcsize=0)"

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Binary search trees ; Style: inquisitive
#include<stdio.h>
#include<stdlib.h>

struct Node{ // defining a structure for binary search tree node
    int data; 
    struct Node *left; // pointer to left child
    struct Node *right; // pointer to right child
};

// function to create a new node and initialize its data and its left and right child pointers
struct Node* createNode(int value){
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node)); //creating dynamic memory allocation
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// function to insert a new node in BST
struct Node* insert(struct Node* root, int value){
    if(root == NULL){ // If the tree is empty, return a new node
        return createNode(value);
    }
    if(value < root->data){ //if the given value is less than the root value, recur for the left subtree
        root->left = insert(root->left, value);
    }
    else{ // else, recur for the right subtree
        root->right = insert(root->right, value);
    }
    return root;
}

// function to traverse the tree in inorder (left, root, right)
void inorder(struct Node* root){
    if(root!=NULL){
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

int main(){
    struct Node *root = NULL;  // pointer to the root node
    int value;
    char choice = 'y';
    printf("Welcome to Binary Search Tree Program!\n");
    while(choice == 'y'){ // continue taking input until user wishes to add more nodes
        printf("\nPlease enter a new node value: ");
        scanf("%d", &value);
        root = insert(root, value); //inserting value in the BST
        printf("\nDo you want to add another node? (y/n): ");
        scanf(" %c", &choice);
    }
    printf("\nInorder Traversal of Binary Search Tree: ");
    inorder(root); //traversing the BST in inorder
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall insert(_QWORD, _QWORD); // weak
__int64 __fastcall inorder(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016E6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+23h] [rbp-Dh] BYREF
  unsigned int v5; // [rsp+24h] [rbp-Ch] BYREF
  __int64 v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v6 = 0i64;
  v4 = 121;
  printf("Welcome to Binary Search Tree Program!\n");
  while ( v4 == 121 )
  {
    printf("\nPlease enter a new node value: ");
    scanf("%d", &v5);
    v6 = insert(v6, v5);
    printf("\nDo you want to add another node? (y/n): ");
    scanf(" %c", &v4);
  }
  printf("\nInorder Traversal of Binary Search Tree: ");
  inorder(v6);
  return 0;
}
// 140001626: using guessed type __int64 __fastcall insert(_QWORD, _QWORD);
// 140001695: using guessed type __int64 __fastcall inorder(_QWORD);
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Product Inventory System ; Style: romantic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  char name[50];
  int quantity;
  float price;
} Product;

int main() {
  int choice, num_products = 0, i;
  float total_value = 0;
  Product products[100];
  
  printf("Welcome to our Product Inventory System!\n");
  
  do {
    printf("\n");
    printf("1. Add a product\n");
    printf("2. Remove a product\n");
    printf("3. List all products\n");
    printf("4. Check total value of inventory\n");
    printf("5. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
    
    switch(choice) {
      case 1: // Add a product
        printf("\nEnter product name: ");
        scanf("%s", products[num_products].name);
        
        printf("Enter product quantity: ");
        scanf("%d", &products[num_products].quantity);
        
        printf("Enter product price: ");
        scanf("%f", &products[num_products].price);
        
        num_products++;
        printf("\nProduct added successfully!\n");
        break;
        
      case 2: // Remove a product
        if (num_products == 0) {
          printf("\nNo products to remove.\n");
          break;
        }
        
        char name[50];
        int found = 0, j;
        printf("\nEnter product name: ");
        scanf("%s", name);
        
        for (j = 0; j < num_products; j++) {
          if (strcmp(name, products[j].name) == 0) {
            found = 1;
            printf("Removed product: %s\n", name);
            total_value -= (products[j].price * products[j].quantity);
            
            for (i = j; i < num_products - 1; i++) {
              strcpy(products[i].name, products[i+1].name);
              products[i].quantity = products[i+1].quantity;
              products[i].price = products[i+1].price;
            }
            
            num_products--;
            break;
          }
        }
        
        if (found == 0) {
          printf("\nProduct not found.\n");
        }
        
        break;
        
      case 3: // List all products
        if (num_products == 0) {
          printf("\nNo products to list.\n");
          break;
        }
        
        printf("\n%-50s %-10s %-10s\n", "Name", "Quantity", "Price");
        for (i = 0; i < num_products; i++) {
          printf("%-50s %-10d $%-9.2f\n", products[i].name, products[i].quantity, products[i].price);
        }
        
        break;
        
      case 4: // Check total value of inventory
        if (num_products == 0) {
          printf("\nInventory is empty.\n");
          break;
        }
        
        total_value = 0;
        for (i = 0; i < num_products; i++) {
          total_value += (products[i].price * products[i].quantity);
        }
        
        printf("\nTotal inventory value: $%.2f\n", total_value);
        break;
        
      case 5: // Exit
        printf("\nThank you for using our Product Inventory System!\n");
        break;
        
      default:
        printf("\nInvalid choice, please try again.\n");
        break;
    }
    
  } while (choice != 5);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[96]; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v5[5976]; // [rsp+80h] [rbp+0h] BYREF
  int v6; // [rsp+17D8h] [rbp+1758h] BYREF
  int i; // [rsp+17DCh] [rbp+175Ch]
  int v8; // [rsp+17E0h] [rbp+1760h]
  float v9; // [rsp+17E4h] [rbp+1764h]
  int j; // [rsp+17E8h] [rbp+1768h]
  int v11; // [rsp+17ECh] [rbp+176Ch]

  _main(argc, argv, envp);
  v11 = 0;
  v9 = 0.0;
  printf("Welcome to our Product Inventory System!\n");
  do
  {
    printf("\n");
    printf("1. Add a product\n");
    printf("2. Remove a product\n");
    printf("3. List all products\n");
    printf("4. Check total value of inventory\n");
    printf("5. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v6);
    switch ( v6 )
    {
      case 1:
        printf("\nEnter product name: ");
        scanf("%s", &Str1[60 * v11 + 64]);
        printf("Enter product quantity: ");
        scanf("%d", &Str1[60 * v11 + 116]);
        printf("Enter product price: ");
        scanf("%f", &Str1[60 * v11++ + 120]);
        printf("\nProduct added successfully!\n");
        break;
      case 2:
        if ( v11 )
        {
          v8 = 0;
          printf("\nEnter product name: ");
          scanf("%s", Str1);
          for ( i = 0; i < v11; ++i )
          {
            if ( !strcmp(Str1, &Str1[60 * i + 64]) )
            {
              v8 = 1;
              printf("Removed product: %s\n", Str1);
              v9 = v9 - (float)(*(float *)&v5[60 * i + 24] * (float)*(int *)&v5[60 * i + 20]);
              for ( j = i; j < v11 - 1; ++j )
              {
                strcpy(&Str1[60 * j + 64], &Str1[60 * j + 124]);
                *(_DWORD *)&v5[60 * j + 20] = *(_DWORD *)&v5[60 * j + 80];
                *(_DWORD *)&v5[60 * j + 24] = *(_DWORD *)&v5[60 * j + 84];
              }
              --v11;
              break;
            }
          }
          if ( !v8 )
            printf("\nProduct not found.\n");
        }
        else
        {
          printf("\nNo products to remove.\n");
        }
        break;
      case 3:
        if ( v11 )
        {
          printf("\n%-50s %-10s %-10s\n", "Name", "Quantity", "Price");
          for ( j = 0; j < v11; ++j )
            printf(
              "%-50s %-10d $%-9.2f\n",
              &Str1[60 * j + 64],
              *(unsigned int *)&v5[60 * j + 20],
              *(float *)&v5[60 * j + 24]);
        }
        else
        {
          printf("\nNo products to list.\n");
        }
        break;
      case 4:
        if ( v11 )
        {
          v9 = 0.0;
          for ( j = 0; j < v11; ++j )
            v9 = (float)((float)*(int *)&v5[60 * j + 20] * *(float *)&v5[60 * j + 24]) + v9;
          printf("\nTotal inventory value: $%.2f\n", v9);
        }
        else
        {
          printf("\nInventory is empty.\n");
        }
        break;
      case 5:
        printf("\nThank you for using our Product Inventory System!\n");
        break;
      default:
        printf("\nInvalid choice, please try again.\n");
        break;
    }
  }
  while ( v6 != 5 );
  return 0;
}
// 140001D40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    double start_time, elapsed_time;
    int download_speed, upload_speed;
    int download_size = 10000000; // 10 megabytes
    int upload_size = 5000000; // 5 megabytes

    // Start timer
    start_time = clock();

    // Simulate download speed test
    printf("Starting download test...\n");
    for (int i = 0; i < download_size; i++) {
        // Simulate download of 1 byte
        // Random delay between 1 and 10 milliseconds
        delay(rand() % 10 + 1);
    }

    // Calculate elapsed time and speed
    elapsed_time = (clock() - start_time) / CLOCKS_PER_SEC;
    download_speed = download_size / elapsed_time;
    printf("Download speed: %d bytes per second\n", download_speed);

    // Start timer
    start_time = clock();

    // Simulate upload speed test
    printf("Starting upload test...\n");
    for (int i = 0; i < upload_size; i++) {
        // Simulate upload of 1 byte
        // Random delay between 1 and 10 milliseconds
        delay(rand() % 10 + 1);
    }

    // Calculate elapsed time and speed
    elapsed_time = (clock() - start_time) / CLOCKS_PER_SEC;
    upload_speed = upload_size / elapsed_time;
    printf("Upload speed: %d bytes per second\n", upload_speed);

    return 0;
}

void delay(int milliseconds) {
    // Delay function
    // Parameter: milliseconds
    clock_t start_time = clock();
    while (clock() < start_time + milliseconds) {}
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall delay(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();
// clock_t __cdecl clock();


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int v4; // eax
  clock_t v5; // eax
  unsigned int v7; // [rsp+2Ch] [rbp-24h]
  double v8; // [rsp+38h] [rbp-18h]
  double v9; // [rsp+38h] [rbp-18h]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = (double)clock();
  printf("Starting download test...\n");
  for ( i = 0; i < 10000000; ++i )
  {
    v3 = rand();
    delay((unsigned int)(v3 % 10 + 1));
  }
  v7 = (int)((double)10000000 / (((double)clock() - v8) / 1000.0));
  printf("Download speed: %d bytes per second\n", v7);
  v9 = (double)clock();
  printf("Starting upload test...\n");
  for ( j = 0; j < 5000000; ++j )
  {
    v4 = rand();
    delay((unsigned int)(v4 % 10 + 1));
  }
  v5 = clock();
  printf("Upload speed: %d bytes per second\n", (unsigned int)(int)((double)5000000 / (((double)v5 - v9) / 1000.0)));
  return 0;
}
// 140001731: using guessed type __int64 __fastcall delay(_QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Math exercise ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_NUM 100     // the maximum number for the calculation
#define MAX_FACTOR 10   // the maximum factor for the multiplication
#define MAX_TIME 60     // the maximum time limit for the game

int main(void) {
    int score = 0;      // initialize the score as 0
    time_t start, end;  // variables for recording the time

    printf("Welcome to the Math Game!\n\n");

    printf("Rules: You will have %d seconds to answer as many multiplication questions as possible.\n", MAX_TIME);
    printf("       Each question will have a random factor between 1 and %d.\n", MAX_FACTOR);
    printf("       The result will be less than or equal to %d.\n", MAX_NUM);
    printf("       Type your answer and press Enter.\n");
    printf("       Each correct answer will earn you 1 point. No penalties for wrong answers.\n");
    printf("\nReady? Press Enter to start the game!");
    getchar();

    // start the game
    time(&start);   // record the start time
    while (difftime(time(NULL), start) < MAX_TIME) {    // keep playing until time's up
        // generate two random factors and ask the user to multiply them
        int factor1 = rand() % MAX_FACTOR + 1;
        int factor2 = rand() % MAX_FACTOR + 1;
        int expected = factor1 * factor2;
        printf("%d. What is %d x %d?  ", score + 1, factor1, factor2);

        // read the user's answer
        char input[10];
        fgets(input, 10, stdin);
        int answer = atoi(input);

        // check the answer and update the score
        if (answer == expected) {
            printf("Correct!\n");
            score++;
        } else {
            printf("Wrong. The correct answer is %d.\n", expected);
        }
    }
    time(&end); // record the end time

    // show the final score and time used
    printf("\nTime's up! Your final score is: %d\n", score);
    printf("You played for %.0f seconds.\n", difftime(end, start));

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static double __cdecl difftime(const time_t Time1, const time_t Time2);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl atoi(const char *String);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  time_t v4; // rbx
  time_t v5; // rax
  double v6; // xmm0_8
  char Buffer[10]; // [rsp+2Eh] [rbp-32h] BYREF
  time_t Time1; // [rsp+38h] [rbp-28h] BYREF
  time_t Time; // [rsp+40h] [rbp-20h] BYREF
  int v11; // [rsp+4Ch] [rbp-14h]
  unsigned int v12; // [rsp+50h] [rbp-10h]
  unsigned int v13; // [rsp+54h] [rbp-Ch]
  unsigned int v14; // [rsp+58h] [rbp-8h]
  unsigned int v15; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v15 = 0;
  printf("Welcome to the Math Game!\n\n");
  printf("Rules: You will have %d seconds to answer as many multiplication questions as possible.\n", 60i64);
  printf("       Each question will have a random factor between 1 and %d.\n", 10i64);
  printf("       The result will be less than or equal to %d.\n", 100i64);
  printf("       Type your answer and press Enter.\n");
  printf("       Each correct answer will earn you 1 point. No penalties for wrong answers.\n");
  printf("\nReady? Press Enter to start the game!");
  getchar();
  time(&Time);
  while ( 1 )
  {
    v4 = Time;
    v5 = time(0i64);
    if ( difftime(v5, v4) >= 60.0 )
      break;
    v14 = rand() % 10 + 1;
    v13 = rand() % 10 + 1;
    v12 = v13 * v14;
    printf("%d. What is %d x %d?  ", v15 + 1, v14, v13);
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 10, v3);
    v11 = atoi(Buffer);
    if ( v11 == v12 )
    {
      printf("Correct!\n");
      ++v15;
    }
    else
    {
      printf("Wrong. The correct answer is %d.\n", v12);
    }
  }
  time(&Time1);
  printf("\nTime's up! Your final score is: %d\n", v15);
  v6 = difftime(Time1, Time);
  printf("You played for %.0f seconds.\n", v6);
  return 0;
}
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System event logger ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to generate a random event ID
int generateEventID() {
    srand(time(NULL));
    return rand();
}

// Function to write to the log file
void writeToLog(char* message) {
    FILE *file = fopen("event_log.txt", "a");
    fputs(message, file);
    fclose(file);
}

// Struct to hold information about an event
typedef struct {
    int id;
    char* name;
    char* description;
    time_t timestamp;
} Event;

// Function to create a new event
Event* createEvent(char* name, char* description) {
    Event* e = (Event*) malloc(sizeof(Event));
    e->id = generateEventID();
    e->name = name;
    e->description = description;
    e->timestamp = time(NULL);
    return e;
}

int main() {
    // Create a new event and write it to the log file
    Event* e = createEvent("System Restart", "The system has been restarted");
    char* message = (char*) malloc(sizeof(char) * 100);
    sprintf(message, "Event ID: %d, Name: %s, Description: %s, Timestamp: %ld\n", e->id, e->name, e->description, e->timestamp);
    writeToLog(message);
    
    // Create another event and write it to the log file
    e = createEvent("File Modified", "A file has been modified");
    sprintf(message, "Event ID: %d, Name: %s, Description: %s, Timestamp: %ld\n", e->id, e->name, e->description, e->timestamp);
    writeToLog(message);
    
    // Create a third event and write it to the log file
    e = createEvent("User Login", "A user has logged in");
    sprintf(message, "Event ID: %d, Name: %s, Description: %s, Timestamp: %ld\n", e->id, e->name, e->description, e->timestamp);
    writeToLog(message);
    
    printf("Events logged successfully\n");
    free(message);
    free(e);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
__int64 __fastcall writeToLog(_QWORD); // weak
__int64 __fastcall createEvent(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400016C0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char **Event; // rax
  char *Buffer; // [rsp+30h] [rbp-10h]
  const char **Block; // [rsp+38h] [rbp-8h]
  const char **Blocka; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  Block = (const char **)createEvent("System Restart", "The system has been restarted");
  Buffer = (char *)malloc(0x64ui64);
  sprintf(
    Buffer,
    "Event ID: %d, Name: %s, Description: %s, Timestamp: %ld\n",
    *(unsigned int *)Block,
    Block[1],
    Block[2],
    Block[3]);
  writeToLog(Buffer);
  Event = (const char **)createEvent("File Modified", "A file has been modified");
  sprintf(
    Buffer,
    "Event ID: %d, Name: %s, Description: %s, Timestamp: %ld\n",
    *(unsigned int *)Event,
    Event[1],
    Event[2],
    Event[3]);
  writeToLog(Buffer);
  Blocka = (const char **)createEvent("User Login", "A user has logged in");
  sprintf(
    Buffer,
    "Event ID: %d, Name: %s, Description: %s, Timestamp: %ld\n",
    *(unsigned int *)Blocka,
    Blocka[1],
    Blocka[2],
    Blocka[3]);
  writeToLog(Buffer);
  printf("Events logged successfully\n");
  free(Buffer);
  free(Blocka);
  return 0;
}
// 140001617: using guessed type __int64 __fastcall writeToLog(_QWORD);
// 140001663: using guessed type __int64 __fastcall createEvent(_QWORD, _QWORD);
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=149 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Natural Language Date Converter ; Style: peaceful
#include<stdio.h>
#include<stdlib.h>

//Function to check if year is leap year or not
int isLeapYear(int year){
    if((year%4==0 && year%100!=0) || year%400==0){
        return 1;
    }
    return 0;
}

//Function to get the total number of days till that month using an array
int daysInMonth(int month, int year){
    int days[12]={31,28,31,30,31,30,31,31,30,31,30,31};
    if(month==2 && isLeapYear(year)){
        return 29;
    }
    return days[month-1];
}

//Function to convert date into number of days from year 1 AD
int daysFromYear1AD(int day, int month, int year){
    int days=0,i;
    for(i=1;i<year;i++){
        days+=isLeapYear(i) ? 366 : 365;
    }
    for(i=1;i<month;i++){
        days+=daysInMonth(i,year);
    }
    days+=day;
    return days;
}

//Function to convert number of days into date
void getDayMonthYearFromDays(int *day, int *month, int *year, int days){
    int i;
    for(i=1;;i++){
        int daysInCurrentYear=isLeapYear(i) ? 366 : 365;
        if(days<=daysInCurrentYear){
            *year=i;
            break;
        }
        days-=daysInCurrentYear;
    }
    for(i=1;;i++){
        int daysInCurrentMonth=daysInMonth(i,*year);
        if(days<=daysInCurrentMonth){
            *month=i;
            break;
        }
        days-=daysInCurrentMonth;
    }
    *day=days;
}

int main(){
    int day,month,year;
    printf("Enter date in the format of dd-mm-yyyy: ");
    scanf("%d-%d-%d",&day,&month,&year);
    int totalDays=daysFromYear1AD(day,month,year);
    printf("Total number of days from year 1 AD: %d\n",totalDays);
    getDayMonthYearFromDays(&day,&month,&year,totalDays);
    printf("Date in the format of dd-mm-yyyy: %d-%d-%d\n",day,month,year);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall daysFromYear1AD(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall getDayMonthYearFromDays(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001803) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v5; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int v6; // [rsp+28h] [rbp-8h] BYREF
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter date in the format of dd-mm-yyyy: ");
  scanf("%d-%d-%d", &v6, &v5, &v4);
  v7 = daysFromYear1AD(v6, v5, v4);
  printf("Total number of days from year 1 AD: %d\n", v7);
  getDayMonthYearFromDays(&v6, &v5, &v4, v7);
  printf("Date in the format of dd-mm-yyyy: %d-%d-%d\n", v6, v5, v4);
  return 0;
}
// 1400016DF: using guessed type __int64 __fastcall daysFromYear1AD(_QWORD, _QWORD, _QWORD);
// 14000175E: using guessed type __int64 __fastcall getDayMonthYearFromDays(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int test_speed() {
    int speed_limit = 100; // set the maximum speed limit as 100 Mbps
    int speed = 0;
    int time_taken = 0;
    time_t start_time, end_time;
    double diff;

    start_time = time(NULL); // get the current time in seconds

    // download a file of size 100 MB to test internet speed
    system("wget -O /dev/null http://speedtest.dal01.softlayer.com/downloads/test100.zip");

    end_time = time(NULL); // get the time when the download completes
    diff = difftime(end_time, start_time);

    time_taken = (int) diff; // calculate the time taken to download the file in seconds

    if (time_taken == 0) {
        // if time taken is less than 1 second, set it to 1 second to avoid division by zero
        time_taken = 1;
    }

    speed = (100 / time_taken) * 8; // calculate the internet speed in Mbps

    if (speed > speed_limit) {
        return speed_limit; // if speed is greater than maximum speed limit, return maximum speed limit
    } else {
        return speed; // otherwise return the actual speed
    }
}

int main() {
    int speed = test_speed();

    printf("Your internet speed is %d Mbps.\n", speed);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 test_speed(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001683) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4 = test_speed();
  printf("Your internet speed is %d Mbps.\n", v4);
  return 0;
}
// 1400015E4: using guessed type __int64 test_speed(void);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: shocked
#include <stdio.h>
#include <ctype.h>
#include <string.h>

int main()
{
    int len, i, upper_case = 0, lower_case = 0, digits = 0, special_chars = 0;
    char password[100];

    printf("Enter your password: ");
    scanf("%s", password);

    len = strlen(password);

    if(len < 8){
        printf("Error: Password must be at least 8 characters long\n");
        exit(1);
    }

    for(i = 0; i < len; i++){
        if(isupper(password[i])) upper_case++;
        if(islower(password[i])) lower_case++;
        if(isdigit(password[i])) digits++;
        if(strchr("!@#$%^&*()-_+=~``[]{}\\|;:'\",.<>?/", password[i])) special_chars++;
    }

    if(upper_case == 0){
        printf("Error: Password must contain at least one uppercase letter\n");
    }

    if(lower_case == 0){
        printf("Error: Password must contain at least one lowercase letter\n");
    }

    if(digits == 0){
        printf("Error: Password must contain at least one digit\n");
    }

    if(special_chars == 0){
        printf("Error: Password must contain at least one special character\n");
    }

    if(upper_case > 0 && lower_case > 0 && digits > 0 && special_chars > 0){
        printf("Password meets the required strength\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strchr(const char *Str, int Val);
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *islower)(int C);
// extern int (__cdecl *isupper)(int C);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[104]; // [rsp+20h] [rbp-80h] BYREF
  int v5; // [rsp+88h] [rbp-18h]
  int v6; // [rsp+8Ch] [rbp-14h]
  int v7; // [rsp+90h] [rbp-10h]
  int v8; // [rsp+94h] [rbp-Ch]
  int v9; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  printf("Enter your password: ");
  scanf("%s", Str);
  v5 = strlen(Str);
  if ( v5 <= 7 )
  {
    printf("Error: Password must be at least 8 characters long\n");
    exit(1);
  }
  for ( i = 0; i < v5; ++i )
  {
    if ( isupper(Str[i]) )
      ++v9;
    if ( islower(Str[i]) )
      ++v8;
    if ( (unsigned int)(Str[i] - 48) <= 9 )
      ++v7;
    if ( strchr("!@#$%^&*()-_+=~``[]{}\\|;:'\",.<>?/", Str[i]) )
      ++v6;
  }
  if ( !v9 )
    printf("Error: Password must contain at least one uppercase letter\n");
  if ( !v8 )
    printf("Error: Password must contain at least one lowercase letter\n");
  if ( !v7 )
    printf("Error: Password must contain at least one digit\n");
  if ( !v6 )
    printf("Error: Password must contain at least one special character\n");
  if ( v9 > 0 && v8 > 0 && v7 > 0 && v6 > 0 )
    printf("Password meets the required strength\n");
  return 0;
}
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[104];

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data mining ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define N 500
#define K 3
#define MAX_ITER 100

typedef struct {
    double x, y;
} data_t;

data_t data[N];

int assignments[N];
data_t means[K];

double distance(data_t a, data_t b) {
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx*dx + dy*dy);
}

int main() {
    // Read data from file
    FILE *fp = fopen("data.txt", "r");
    for (int i = 0; i < N; i++) {
        fscanf(fp, "%lf %lf", &data[i].x, &data[i].y);
    }
    fclose(fp);

    // Initialize means
    for (int i = 0; i < K; i++) {
        means[i].x = data[(int)(rand()/(double)RAND_MAX*N)].x;
        means[i].y = data[(int)(rand()/(double)RAND_MAX*N)].y;
    }

    // Run kmeans
    for (int iter = 0; iter < MAX_ITER; iter++) {
        // Assign points to nearest mean
        for (int i = 0; i < N; i++) {
            double min_dist = INFINITY;
            for (int j = 0; j < K; j++) {
                double dist = distance(data[i], means[j]);
                if (dist < min_dist) {
                    min_dist = dist;
                    assignments[i] = j;
                }
            }
        }

        // Recalculate means
        for (int i = 0; i < K; i++) {
            double sum_x = 0, sum_y = 0;
            int count = 0;
            for (int j = 0; j < N; j++) {
                if (assignments[j] == i) {
                    sum_x += data[j].x;
                    sum_y += data[j].y;
                    count++;
                }
            }
            if (count > 0) {
                means[i].x = sum_x / count;
                means[i].y = sum_y / count;
            }
        }
    }

    // Print results
    for (int i = 0; i < K; i++) {
        printf("Cluster %d: (%lf, %lf)\n", i+1, means[i].x, means[i].y);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
double __fastcall distance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN data; // weak
double dbl_140019048[999]; // weak
_DWORD assignments[504]; // weak
_UNKNOWN means; // weak
double dbl_14001B768[7]; // weak


//----- (0000000140001663) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 *v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 *v6; // rdx
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v10[2]; // [rsp+20h] [rbp-70h] BYREF
  __int64 v11[2]; // [rsp+30h] [rbp-60h] BYREF
  double v12; // [rsp+40h] [rbp-50h]
  FILE *Stream; // [rsp+48h] [rbp-48h]
  int kk; // [rsp+54h] [rbp-3Ch]
  int jj; // [rsp+58h] [rbp-38h]
  int v16; // [rsp+5Ch] [rbp-34h]
  double v17; // [rsp+60h] [rbp-30h]
  double v18; // [rsp+68h] [rbp-28h]
  int ii; // [rsp+70h] [rbp-20h]
  int n; // [rsp+74h] [rbp-1Ch]
  double v21; // [rsp+78h] [rbp-18h]
  int m; // [rsp+80h] [rbp-10h]
  int k; // [rsp+84h] [rbp-Ch]
  int j; // [rsp+88h] [rbp-8h]
  int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  Stream = fopen("data.txt", "r");
  for ( i = 0; i <= 499; ++i )
    fscanf(Stream, "%lf %lf", (char *)&data + 16 * i, (char *)&data + 16 * i + 8);
  fclose(Stream);
  for ( j = 0; j <= 2; ++j )
  {
    *((_QWORD *)&means + 2 * j) = *((_QWORD *)&data + 2 * (int)(500.0 * ((double)rand() / 32767.0)));
    dbl_14001B768[2 * j] = dbl_140019048[2 * (int)(500.0 * ((double)rand() / 32767.0))];
  }
  for ( k = 0; k <= 99; ++k )
  {
    for ( m = 0; m <= 499; ++m )
    {
      v21 = INFINITY;
      for ( n = 0; n <= 2; ++n )
      {
        v3 = (__int64 *)((char *)&data + 16 * m);
        v4 = *v3;
        v5 = v3[1];
        v11[0] = v4;
        v11[1] = v5;
        v6 = (__int64 *)((char *)&means + 16 * n);
        v7 = *v6;
        v8 = v6[1];
        v10[0] = v7;
        v10[1] = v8;
        v12 = distance(v11, v10);
        if ( v21 > v12 )
        {
          v21 = v12;
          assignments[m] = n;
        }
      }
    }
    for ( ii = 0; ii <= 2; ++ii )
    {
      v18 = 0.0;
      v17 = 0.0;
      v16 = 0;
      for ( jj = 0; jj <= 499; ++jj )
      {
        if ( ii == assignments[jj] )
        {
          v18 = *((double *)&data + 2 * jj) + v18;
          v17 = dbl_140019048[2 * jj] + v17;
          ++v16;
        }
      }
      if ( v16 > 0 )
      {
        *((double *)&means + 2 * ii) = v18 / (double)v16;
        dbl_14001B768[2 * ii] = v17 / (double)v16;
      }
    }
  }
  for ( kk = 0; kk <= 2; ++kk )
    printf("Cluster %d: (%lf, %lf)\n", (unsigned int)(kk + 1), *((_QWORD *)&means + 2 * kk), dbl_14001B768[2 * kk]);
  return 0;
}
// 1400015D4: using guessed type double __fastcall distance(_QWORD, _QWORD);
// 140001B10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019048: using guessed type double dbl_140019048[999];
// 14001AF80: using guessed type _DWORD assignments[504];
// 14001B768: using guessed type double dbl_14001B768[7];

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: A* Pathfinding Algorithm ; Style: real-life
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define ROW 10
#define COL 10

typedef struct Node {
    int f, g, h;
    int row, col;
    bool isBlocked;
    struct Node *parent;
} Node;

int heuristicCostEstimate(int startRow, int startCol, int endRow, int endCol) {
    int x = abs(startRow - endRow);
    int y = abs(startCol - endCol);
    int heuristic = x + y;
    return heuristic;
}

bool isNodeValid(int row, int col) {
    if (row < 0 || row >= ROW || col < 0 || col >= COL) {
        return false;
    }
    return true;
}

Node* getNode(int grid[][COL], int row, int col) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->f = 0;
    node->g = 0;
    node->h = 0;
    node->row = row;
    node->col = col;
    node->isBlocked = (grid[row][col] == 1) ? true : false;
    node->parent = NULL;
    return node;
}

void printPath(Node* node) {
    if (node != NULL) {
        printPath(node->parent);
        printf("[(%d,%d)] -> ", node->row, node->col);
    }
}

void aStar(int grid[][COL], int startRow, int startCol, int endRow, int endCol) {
    Node* startNode = getNode(grid, startRow, startCol);
    Node* endNode = getNode(grid, endRow, endCol);
    
    bool visited[ROW][COL] = {false};
    bool isFound = false;
    
    Node* openList[ROW*COL] = {NULL};
    int openCount = 0;
    
    startNode->f = startNode->g + heuristicCostEstimate(startRow, startCol, endRow, endCol);
    openList[openCount++] = startNode;
    
    while (openCount > 0) {
        Node* currentNode = openList[0];
        int currentIndex = 0;
        
        for (int i = 1; i < openCount; i++) {
            if (openList[i]->f < currentNode->f) {
                currentNode = openList[i];
                currentIndex = i;
            }
        }
        
        openList[currentIndex] = openList[--openCount];
        
        if (currentNode == endNode) {
            isFound = true;
            printf("Path found: ");
            printPath(currentNode);
            break;
        }
        
        int row = currentNode->row;
        int col = currentNode->col;
        
        visited[row][col] = true;
        
        for (int i = -1; i <= 1; i++) {
            for (int j = -1; j <= 1; j++) {
                if (i == 0 && j == 0) {
                    continue;
                }
                int nRow = row + i;
                int nCol = col + j;
                
                if (isNodeValid(nRow, nCol) && !visited[nRow][nCol]) {
                    Node* neighborNode = getNode(grid, nRow, nCol);
                    if (neighborNode->isBlocked) {
                        visited[nRow][nCol] = true;
                        continue;
                    }
                    int newG = currentNode->g + 1;
                    if (newG < neighborNode->g || neighborNode->g == 0) {
                        neighborNode->parent = currentNode;
                        neighborNode->g = newG;
                        neighborNode->h = heuristicCostEstimate(nRow, nCol, endRow, endCol);
                        neighborNode->f = neighborNode->g + neighborNode->h;
                        
                        if (openCount == 0) {
                            openList[openCount++] = neighborNode;
                        } else {
                            int k;
                            for (k = 0; k < openCount; k++) {
                                if (openList[k]->f > neighborNode->f) {
                                    break;
                                }
                            }
                            for (int m = openCount; m > k; m--) {
                                openList[m] = openList[m - 1];
                            }
                            openList[k] = neighborNode;
                            openCount++;
                        }
                    }
                }
            }
        }
    }
    
    if (!isFound) {
        printf("Path not found!\n");
    }
}

int main() {
    int grid[ROW][COL] = {
        {0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
        {0, 1, 1, 0, 1, 0, 0, 1, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
        {1, 1, 0, 0, 0, 0, 1, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},
        {0, 1, 0, 0, 1, 0, 0, 1, 0, 1},
        {0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 1, 0, 1, 1, 0},
        {0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
    };
    
    int startRow = 0;
    int startCol = 0;
    int endRow = 0;
    int endCol = 8;
    
    aStar(grid, startRow, startCol, endRow, endCol);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall aStar(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001C22) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[108]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  memset(v4, 0, 0x190ui64);
  v4[7] = 1;
  v4[11] = 1;
  v4[12] = 1;
  v4[14] = 1;
  v4[17] = 1;
  v4[33] = 1;
  v4[35] = 1;
  v4[40] = 1;
  v4[41] = 1;
  v4[46] = 1;
  v4[56] = 1;
  v4[58] = 1;
  v4[61] = 1;
  v4[64] = 1;
  v4[67] = 1;
  v4[69] = 1;
  v4[72] = 1;
  v4[85] = 1;
  v4[87] = 1;
  v4[88] = 1;
  v4[97] = 1;
  v4[103] = 0;
  v4[102] = 0;
  v4[101] = 0;
  v4[100] = 8;
  aStar((unsigned int)v4, 0, 0, 0, 8);
  return 0;
}
// 1400016F5: using guessed type __int64 __fastcall aStar(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001E20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Phone Book ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define maximum number of contacts
#define MAX_CONTACTS 1000

// Define structure for contacts
typedef struct {
    char name[50];
    char phone[20];
    char email[50];
} Contact;

// Define the phone book array and current number of contacts
Contact phone_book[MAX_CONTACTS];
int num_contacts = 0;

// Function to add a new contact to the phone book
void add_contact() {
    // Check if we have room for another contact
    if (num_contacts >= MAX_CONTACTS) {
        printf("The phone book is full!\n");
        return;
    }
    
    // Get user input for the new contact
    Contact new_contact;
    printf("Enter name: ");
    scanf("%s", new_contact.name);
    printf("Enter phone number: ");
    scanf("%s", new_contact.phone);
    printf("Enter email: ");
    scanf("%s", new_contact.email);
    
    // Add the new contact to the phone book
    phone_book[num_contacts] = new_contact;
    num_contacts++;
}

// Function to list all contacts in the phone book
void list_contacts() {
    // Print header
    printf("Phone Book:\n");
    printf("------------\n");
    
    // Loop through all contacts and print their info
    for (int i = 0; i < num_contacts; i++) {
        printf("Name: %s\n", phone_book[i].name);
        printf("Phone: %s\n", phone_book[i].phone);
        printf("Email: %s\n", phone_book[i].email);
        printf("\n");
    }
}

// Function to search for a contact by name
void search_contact() {
    // Get user input for the name to search for
    char search_name[50];
    printf("Enter name to search for: ");
    scanf("%s", search_name);
    
    // Loop through all contacts and search for the name
    for (int i = 0; i < num_contacts; i++) {
        if (strcmp(phone_book[i].name, search_name) == 0) {
            printf("Name: %s\n", phone_book[i].name);
            printf("Phone: %s\n", phone_book[i].phone);
            printf("Email: %s\n", phone_book[i].email);
            return;
        }
    }
    
    // If we haven't found the contact, print an error message
    printf("Contact not found!\n");
}

int main() {
    // Loop to prompt the user for commands
    while (1) {
        printf("Enter a command (add, list, search, exit): ");
        char command[10];
        scanf("%s", command);
        
        if (strcmp(command, "add") == 0) {
            add_contact();
        }
        else if (strcmp(command, "list") == 0) {
            list_contacts();
        }
        else if (strcmp(command, "search") == 0) {
            search_contact();
        }
        else if (strcmp(command, "exit") == 0) {
            return 0;
        }
        else {
            printf("Invalid command! Please try again.\n");
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_contact(void); // weak
__int64 list_contacts(void); // weak
__int64 search_contact(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (000000014000197E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[10]; // [rsp+26h] [rbp-Ah] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          printf("Enter a command (add, list, search, exit): ");
          scanf("%s", Str1);
          if ( strcmp(Str1, "add") )
            break;
          add_contact();
        }
        if ( strcmp(Str1, "list") )
          break;
        list_contacts();
      }
      if ( strcmp(Str1, "search") )
        break;
      search_contact();
    }
    if ( !strcmp(Str1, "exit") )
      break;
    printf("Invalid command! Please try again.\n");
  }
  return 0;
}
// 1400015E2: using guessed type __int64 add_contact(void);
// 14000174B: using guessed type __int64 list_contacts(void);
// 140001847: using guessed type __int64 search_contact(void);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Intrusion detection system ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 1024
#define MAX_IP_LENGTH 16
#define MAX_TIME_LENGTH 9

typedef struct{
    char ip[MAX_IP_LENGTH];
    char time[MAX_TIME_LENGTH];
} LogEntry;

typedef struct{
    LogEntry *entries;
    int size;
    int capacity;
} Log;

void log_append(Log *log, LogEntry new_entry){
    if(log->size >= log->capacity){
        log->capacity *= 2;
        log->entries = realloc(log->entries, log->capacity * sizeof(LogEntry));
    }
    log->entries[log->size++] = new_entry;
}

void parse_line(char *line, LogEntry *entry){
    int i, j;

    // parse IP address
    for(i = 0; i < MAX_IP_LENGTH - 1 && line[i] != ' '; i++){
        entry->ip[i] = line[i];
    }
    entry->ip[i] = '\0';

    // parse time
    for(i++; i < MAX_LINE_LENGTH - 1 && line[i] != '\n' && line[i] != '\r'; i++){
        entry->time[j++] = line[i];
    }
    entry->time[j] = '\0';
}

int is_suspect(const Log *log, const char *ip){
    int i, count = 0;

    for(i = log->size - 1; i >= 0 && count < 10; i--){
        if(strcmp(log->entries[i].ip, ip) == 0){
            count++;
            if(count == 10){
                return 1;
            }
        }
    }

    return 0;
}

int main(){
    Log log = {.entries = malloc(16 * sizeof(LogEntry)), .size = 0, .capacity = 16};
    char line[MAX_LINE_LENGTH];

    while(fgets(line, MAX_LINE_LENGTH, stdin)){
        LogEntry entry;
        parse_line(line, &entry);

        if(is_suspect(&log, entry.ip)){
            printf("Intruder detected: %s\n", entry.ip);
        }

        log_append(&log, entry);
    }

    free(log.entries);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall log_append(_QWORD, _QWORD); // weak
__int64 __fastcall parse_line(_QWORD, _QWORD); // weak
__int64 __fastcall is_suspect(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400017B1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  __int64 v5[3]; // [rsp+20h] [rbp-60h] BYREF
  char v6; // [rsp+38h] [rbp-48h]
  __int64 v7[3]; // [rsp+40h] [rbp-40h] BYREF
  char v8; // [rsp+58h] [rbp-28h]
  char Buffer[1024]; // [rsp+60h] [rbp-20h] BYREF
  void *Block; // [rsp+460h] [rbp+3E0h] BYREF
  int v11; // [rsp+468h] [rbp+3E8h]
  int v12; // [rsp+46Ch] [rbp+3ECh]

  _main(argc, argv, envp);
  Block = malloc(0x190ui64);
  v11 = 0;
  v12 = 16;
  while ( 1 )
  {
    v3 = __acrt_iob_func(0);
    if ( !fgets(Buffer, 1024, v3) )
      break;
    parse_line(Buffer, v7);
    if ( (unsigned int)is_suspect(&Block, v7) )
      printf("Intruder detected: %s\n", (const char *)v7);
    v5[0] = v7[0];
    v5[1] = v7[1];
    v5[2] = v7[2];
    v6 = v8;
    log_append(&Block, v5);
  }
  free(Block);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall log_append(_QWORD, _QWORD);
// 140001653: using guessed type __int64 __fastcall parse_line(_QWORD, _QWORD);
// 140001727: using guessed type __int64 __fastcall is_suspect(_QWORD, _QWORD);
// 140001960: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Building a JSON Parser ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// define the structure for the JSON object
typedef struct {
    char* key;
    char* value;
} json_object;

// parse a json string and return an array of json objects
json_object* parse_json(char* input){
    json_object* objects = malloc(sizeof(json_object)*10);
    memset(objects, 0, sizeof(json_object)*10);

    int object_index = 0;
    char* token = strtok(input, "{}, ");
    char* key = NULL;
    int in_string = 0;
    while(token != NULL){
        if(*token == '\"' && *(token-1) != '\\'){
            if(in_string){
                in_string = 0;
                objects[object_index].value = (char*)malloc(strlen(token));
                memset(objects[object_index].value, 0, strlen(token));
                memcpy(objects[object_index].value, key, strlen(key));
                key = NULL;
                object_index++;
            }
            else{
                in_string = 1;
                key = token;
            }
        }
        else if(!in_string && (*token == ',' || *token == '}')){
            in_string = 0;
            if(key != NULL){
                objects[object_index].value = (char*)malloc(strlen(token));
                memset(objects[object_index].value, 0, strlen(token));
                memcpy(objects[object_index].value, key, strlen(key));
                key = NULL;
                object_index++;
            }
        }
        token = strtok(NULL, "{}, ");
    }
    return objects;
}

// main function
int main(){
    char* input = "{\"name\": \"John\",\"age\": 24}";
    json_object* objects = parse_json(input);
    for(int i=0;i<strlen(input);i++){
        printf("%c", input[i]);
    }
    printf("\nParsed JSON:\n");
    for(int i=0;i<2;i++){
        printf("%s\n", objects[i].value);
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall parse_json(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);

//-------------------------------------------------------------------------
// Data declarations

char aNameJohnAge24[27] = "{\"name\": \"John\",\"age\": 24}"; // weak


//----- (00000001400017EF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-18h]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4 = parse_json("{\"name\": \"John\",\"age\": 24}");
  for ( i = 0; i < strlen("{\"name\": \"John\",\"age\": 24}"); ++i )
    printf("%c", (unsigned int)aNameJohnAge24[i]);
  printf("\nParsed JSON:\n");
  for ( j = 0; j <= 1; ++j )
    printf("%s\n", *(const char **)(16i64 * j + v4 + 8));
  return 0;
}
// 140001591: using guessed type __int64 __fastcall parse_json(_QWORD);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Steganography ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// function to convert decimal to binary
int *decToBinary(int num, int array[]){
    for(int i=0; i<8; i++){
        array[i] = num % 2;
        num = num / 2;
    }
    return array;
}

// function to convert binary to decimal
int binaryToDec(int array[]){
    int num = 0, pow = 1;
    for(int i=0; i<8; i++){
        num = num + array[i] * pow;
        pow = pow * 2;
    }
    return num;
}

// function to hide message in image
void hideMessage(char message[], char imageName[]){
    FILE *fp1, *fp2;
    int count = 0, byte, pos = 0, binaryMessage[8], binaryByte[8], length;
    fp1 = fopen(imageName, "rb");
    fp2 = fopen("output.bmp", "wb");
    int headerSize;
    fread(&headerSize, 4, 1, fp1);
    fwrite(&headerSize, 4, 1, fp2);
    fseek(fp1, 4, SEEK_CUR);
    fread(&length, 4, 1, fp1);
    fwrite(&length, 4, 1, fp2);
    fseek(fp1, 12, SEEK_CUR);
    while(1){
        byte = fgetc(fp1);
        if(byte == EOF)
            break;
        decToBinary(byte, binaryByte);
        if(count < strlen(message)){
            decToBinary(message[count], binaryMessage);
            binaryByte[7] = binaryMessage[pos++];
            if(pos == 8){
                pos = 0;
                count++;
            }
        }
        byte = binaryToDec(binaryByte);
        fputc(byte, fp2);
    }
    fclose(fp1);
    fclose(fp2);
    printf("Message hidden successfully in %s image!", imageName);
}

// function to reveal message from image
void revealMessage(char imageName[]){
    FILE *fp;
    int byte, binaryByte[8], count = 0, pos = 0, length;
    char message[100];
    fp = fopen(imageName, "rb");
    int headerSize;
    fread(&headerSize, 4, 1, fp);
    fseek(fp, 4, SEEK_CUR);
    fread(&length, 4, 1, fp);
    fseek(fp, 12, SEEK_CUR);
    while(1){
        byte = fgetc(fp);
        if(byte == EOF)
            break;
        decToBinary(byte, binaryByte);
        if(count < length){
            message[count] = binaryByte[7] + '0';
            pos++;
            if(pos == 8){
                pos = 0;
                count++;
            }
        }
    }
    printf("Message revealed from %s image: %.*s", imageName, length, message);
}

int main(){
    char message[100], imageName[20];
    int choice;
    printf("Enter message to hide (max 100 characters): ");
    fgets(message, 100, stdin);
    message[strcspn(message, "\n")] = 0;
    printf("Enter name of image file to hide message in (max 20 characters): ");
    fgets(imageName, 20, stdin);
    imageName[strcspn(imageName, "\n")] = 0;
    printf("Do you want to hide message or reveal message?\n");
    printf("1. Hide message\n");
    printf("2. Reveal message\n");
    scanf("%d", &choice);
    switch(choice){
        case 1:
            hideMessage(message, imageName);
            break;
        case 2:
            revealMessage(imageName);
            break;
        default:
            printf("Invalid choice!");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall hideMessage(_QWORD, _QWORD); // weak
__int64 __fastcall revealMessage(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001999) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  int v6; // [rsp+2Ch] [rbp-94h] BYREF
  char Str[32]; // [rsp+30h] [rbp-90h] BYREF
  char Buffer[112]; // [rsp+50h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter message to hide (max 100 characters): ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  printf("Enter name of image file to hide message in (max 20 characters): ");
  v4 = __acrt_iob_func(0);
  fgets(Str, 20, v4);
  Str[strcspn(Str, "\n")] = 0;
  printf("Do you want to hide message or reveal message?\n");
  printf("1. Hide message\n");
  printf("2. Reveal message\n");
  scanf("%d", &v6);
  if ( v6 == 1 )
  {
    hideMessage(Buffer, Str);
  }
  else if ( v6 == 2 )
  {
    revealMessage(Str);
  }
  else
  {
    printf("Invalid choice!");
  }
  return 0;
}
// 14000169B: using guessed type __int64 __fastcall hideMessage(_QWORD, _QWORD);
// 140001874: using guessed type __int64 __fastcall revealMessage(_QWORD);
// 140001BA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001999: using guessed type char Buffer[112];
// 140001999: using guessed type char Str[32];

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Product Inventory System ; Style: Sherlock Holmes
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

// Define the maximum number of records that can be stored
#define MAX_RECORDS 100

// Define the length of each field in a record
#define FIELD_LENGTH 50

// Define the size of the record in bytes
#define RECORD_SIZE (4 + (3 * FIELD_LENGTH))

// Define the structure of a record
typedef struct {
    int id;
    char name[FIELD_LENGTH];
    char category[FIELD_LENGTH];
    int quantity;
} Record;

// Define the function to add a new record
void addRecord(Record *records, int *count) {
    Record newRecord;
    printf("Enter the product name: ");
    scanf("%s", newRecord.name);
    printf("Enter the product category: ");
    scanf("%s", newRecord.category);
    printf("Enter the product quantity: ");
    scanf("%d", &newRecord.quantity);
    newRecord.id = *count;
    records[*count] = newRecord;
    *count += 1;
    printf("Product added succesfully!\n");
}

// Define the function to remove a record
void removeRecord(Record *records, int *count) {
    int id;
    printf("Enter the product ID to remove: ");
    scanf("%d", &id);
    for(int i = 0; i < *count; i++) {
        if(records[i].id == id) {
            for(int j = i; j < *count - 1; j++) {
                records[j] = records[j+1];
            }
            *count -= 1;
            printf("Product removed succesfully!\n");
            return;
        }
    }
    printf("Product ID not found.\n");
}

// Define the function to search for a record by name
void searchRecord(Record *records, int *count) {
    char name[FIELD_LENGTH];
    printf("Enter the product name to search: ");
    scanf("%s", name);
    for(int i = 0; i < *count; i++) {
        if(strcmp(records[i].name, name) == 0) {
            printf("Product ID: %d\n", records[i].id);
            printf("Product name: %s\n", records[i].name);
            printf("Product category: %s\n", records[i].category);
            printf("Product quantity: %d\n", records[i].quantity);
            return;
        }
    }
    printf("Product name not found.\n");
}

// Define the function to print all records
void printRecords(Record *records, int *count) {
    printf("Product Inventory:\n");
    for(int i = 0; i < *count; i++) {
        printf("Product ID: %d\n", records[i].id);
        printf("Product name: %s\n", records[i].name);
        printf("Product category: %s\n", records[i].category);
        printf("Product quantity: %d\n", records[i].quantity);
    }
    if(*count == 0) {
        printf("No products found.\n");
    }
}

int main() {

    // Initialize the records and count
    Record records[MAX_RECORDS];
    int count = 0;

    // Define the menu options
    int choice;
    do {
        printf("1. Add new product\n");
        printf("2. Remove product\n");
        printf("3. Search product\n");
        printf("4. Print all products\n");
        printf("0. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch(choice) {
            case 1:
                addRecord(records, &count);
                break;
            case 2:
                removeRecord(records, &count);
                break;
            case 3:
                searchRecord(records, &count);
                break;
            case 4:
                printRecords(records, &count);
                break;
            case 0:
                printf("Goodbye!\n");
                break;
            default:
                printf("Invalid choice.\n");
                break;
        }
    } while(choice != 0);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addRecord(_QWORD, _QWORD); // weak
__int64 __fastcall removeRecord(_QWORD, _QWORD); // weak
__int64 __fastcall searchRecord(_QWORD, _QWORD); // weak
__int64 __fastcall printRecords(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001BD3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[10800]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  do
  {
    printf("1. Add new product\n");
    printf("2. Remove product\n");
    printf("3. Search product\n");
    printf("4. Print all products\n");
    printf("0. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 0:
        printf("Goodbye!\n");
        break;
      case 1:
        addRecord(v6, &v5);
        break;
      case 2:
        removeRecord(v6, &v5);
        break;
      case 3:
        searchRecord(v6, &v5);
        break;
      case 4:
        printRecords(v6, &v5);
        break;
      default:
        printf("Invalid choice.\n");
        break;
    }
  }
  while ( v4 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall addRecord(_QWORD, _QWORD);
// 140001740: using guessed type __int64 __fastcall removeRecord(_QWORD, _QWORD);
// 1400018E3: using guessed type __int64 __fastcall searchRecord(_QWORD, _QWORD);
// 140001A82: using guessed type __int64 __fastcall printRecords(_QWORD, _QWORD);
// 140001DD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game of Life ; Style: Ada Lovelace
/*
Title: Ada Lovelace's Game of Life
Author: Ada Lovelace
Date: October 21, 1843
Description: A program that simulates John Conway's Game of Life using
             Ada's analytical engine and printing the output to the terminal.
*/

#include <stdio.h>

#define ROWS 20
#define COLS 20

void initialize_board(int board[ROWS][COLS]);
void update_board(int board[ROWS][COLS]);

int main() {
    int board[ROWS][COLS] = {0};

    initialize_board(board);

    for (int i = 0; i < 10; i++) {
        update_board(board);

        printf("Generation %d:\n", i+1);
        for (int row = 0; row < ROWS; row++) {
            for (int col = 0; col < COLS; col++) {
                if (board[row][col] == 0) {
                    printf(".");
                } else {
                    printf("*");
                }
            }
            printf("\n");
        }
        printf("\n");
    }

    return 0;
}

void initialize_board(int board[ROWS][COLS]) {
    // Set up the initial configuration of the board
    board[5][5] = 1;
    board[5][6] = 1;
    board[6][5] = 1;
    board[6][6] = 1;
    board[3][3] = 1;
    board[3][4] = 1;
    board[3][5] = 1;
}

void update_board(int board[ROWS][COLS]) {
    int temp_board[ROWS][COLS] = {0};

    for (int row = 0; row < ROWS; row++) {
        for (int col = 0; col < COLS; col++) {
            int live_neighbors = 0;

            // Check each neighbor cell
            for (int nb_row = row-1; nb_row <= row+1; nb_row++) {
                for (int nb_col = col-1; nb_col <= col+1; nb_col++) {
                    if (nb_row != row || nb_col != col) {
                        if (nb_row >= 0 && nb_row < ROWS && nb_col >= 0 && nb_col < COLS) {
                            live_neighbors += board[nb_row][nb_col];
                        }
                    }
                }
            }

            // Apply the rules of the game
            if (board[row][col] == 1) {
                if (live_neighbors < 2 || live_neighbors > 3) {
                    temp_board[row][col] = 0;
                } else {
                    temp_board[row][col] = 1;
                }
            } else {
                if (live_neighbors == 3) {
                    temp_board[row][col] = 1;
                } else {
                    temp_board[row][col] = 0;
                }
            }
        }
    }

    // Copy the updated board to the original board
    for (int row = 0; row < ROWS; row++) {
        for (int col = 0; col < COLS; col++) {
            board[row][col] = temp_board[row][col];
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall initialize_board(_QWORD, _QWORD); // weak
__int64 __fastcall update_board(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[401]; // [rsp+20h] [rbp-60h] BYREF
  int k; // [rsp+664h] [rbp+5E4h]
  int j; // [rsp+668h] [rbp+5E8h]
  int i; // [rsp+66Ch] [rbp+5ECh]

  _main(argc, argv, envp);
  memset(v4, 0, 0x640ui64);
  initialize_board(v4, v4);
  for ( i = 0; i <= 9; ++i )
  {
    update_board(v4);
    printf("Generation %d:\n", (unsigned int)(i + 1));
    for ( j = 0; j <= 19; ++j )
    {
      for ( k = 0; k <= 19; ++k )
      {
        if ( v4[20 * j + k] )
          printf(L"*\n");
        else
          printf(L".*\n");
      }
      printf(L"\n");
    }
    printf(L"\n");
  }
  return 0;
}
// 1400016C4: using guessed type __int64 __fastcall initialize_board(_QWORD, _QWORD);
// 140001746: using guessed type __int64 __fastcall update_board(_QWORD);
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type int var_660[401];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text processing ; Style: Sherlock Holmes
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

struct word_frequency {
    char *word;
    int frequency;
};

void remove_punctuation(char *word) {
    int i, j = 0;
    for(i = 0; word[i] != '\0'; i++) {
        if(isalpha(word[i])) {
            word[j++] = tolower(word[i]);
        }
    }
    word[j] = '\0';
}

void print_frequencies(struct word_frequency *frequencies, int count) {
    int i;
    printf("Word Frequencies:\n");
    for(i = 0; i < count; i++) {
        printf("%s: %d\n", frequencies[i].word, frequencies[i].frequency);
    }
}

const char *SHERLOCK = "It is a capital mistake to theorize before one has data. Insensibly one begins to twist facts to suit theories, instead of theories to suit facts.";

int main() {
    char *text = strdup(SHERLOCK);
    char *word = strtok(text, " ");
    struct word_frequency *frequencies = NULL;
    int count = 0;
    while(word) {
        remove_punctuation(word);
        int i;
        for(i = 0; i < count; i++) {
            if(strcmp(frequencies[i].word, word) == 0) {
                frequencies[i].frequency++;
                break;
            }
        }
        if(i == count) {
            count++;
            frequencies = realloc(frequencies, count * sizeof(struct word_frequency));
            frequencies[count-1].word = strdup(word);
            frequencies[count-1].frequency = 1;
        }
        word = strtok(NULL, " ");
    }
    print_frequencies(frequencies, count);
    free(text);
    int i;
    for(i = 0; i < count; i++) {
        free(frequencies[i].word);
    }
    free(frequencies);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall remove_punctuation(_QWORD); // weak
__int64 __fastcall print_frequencies(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strdup(const char *String);
// char *__cdecl strtok(char *String, const char *Delimiter);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl realloc(void *Block, size_t Size);
// void __cdecl free(void *Block);

//-------------------------------------------------------------------------
// Data declarations

char *SHERLOCK = "It is a capital mistake to theorize before one has data. Insensibly one begins to twist facts to suit theories, instead of theories to suit facts."; // idb


//----- (00000001400016B1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *String; // [rsp+28h] [rbp-28h]
  int j; // [rsp+34h] [rbp-1Ch]
  int i; // [rsp+38h] [rbp-18h]
  signed int v7; // [rsp+3Ch] [rbp-14h]
  _DWORD *Block; // [rsp+40h] [rbp-10h]
  const char *Str2; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  String = strdup(SHERLOCK);
  Str2 = strtok(String, " ");
  Block = 0i64;
  v7 = 0;
  while ( Str2 )
  {
    remove_punctuation(Str2);
    for ( i = 0; i < v7; ++i )
    {
      if ( !strcmp(*(const char **)&Block[4 * i], Str2) )
      {
        ++Block[4 * i + 2];
        break;
      }
    }
    if ( i == v7 )
    {
      Block = realloc(Block, 16i64 * ++v7);
      *(_QWORD *)&Block[4 * v7 - 4] = strdup(Str2);
      Block[4 * v7 - 2] = 1;
    }
    Str2 = strtok(0i64, " ");
  }
  print_frequencies(Block, (unsigned int)v7);
  free(String);
  for ( j = 0; j < v7; ++j )
    free(*(void **)&Block[4 * j]);
  free(Block);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall remove_punctuation(_QWORD);
// 140001635: using guessed type __int64 __fastcall print_frequencies(_QWORD, _QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Performance-Critical Component ; Style: brave
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ARRAY_SIZE 1000000
#define LOOP_COUNT 10000

int main() {
    srand(time(NULL));

    int array1[ARRAY_SIZE], array2[ARRAY_SIZE];

    // Initialize arrays with random values
    for (int i = 0; i < ARRAY_SIZE; i++) {
        array1[i] = rand() % 100;
        array2[i] = rand() % 100;
    }

    int result = 0;

    // Multiply the elements of the arrays
    clock_t start_time = clock();

    for (int j = 0; j < LOOP_COUNT; j++) {
        for (int i = 0; i < ARRAY_SIZE; i++) {
            result += array1[i] * array2[i];
        }
    }

    clock_t end_time = clock();

    double elapsed_time = ((double) (end_time - start_time)) / CLOCKS_PER_SEC;

    printf("Result: %d\n", result);
    printf("Elapsed time: %f seconds\n", elapsed_time);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (00000001400015B0) ----------------------------------------------------
#error "1400015B0: stack frame is too big (funcsize=0)"

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Smart home light control ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>

#define LIGHT_ON 1
#define LIGHT_OFF 0

// Function to turn on the light
void turn_on_light() {
    printf("Light turned ON\n");
}

// Function to turn off the light
void turn_off_light() {
    printf("Light turned OFF\n");
}

// Main function
int main() {
    bool motion_detected = false;
    int current_light_status = LIGHT_OFF;

    while (true) {
        if (motion_detected) {
            if (current_light_status == LIGHT_OFF) {
                turn_on_light();
                current_light_status = LIGHT_ON;
            }
        } else {
            if (current_light_status == LIGHT_ON) {
                turn_off_light();
                current_light_status = LIGHT_OFF;
            }
        }

        // Wait for 2 seconds
        sleep(2);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 turn_on_light(void); // weak
__int64 turn_off_light(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak


//----- (00000001400015CD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  while ( 1 )
    sleep(2i64);
}
// 1400015E9: conditional instruction was optimized away because %var_5.1==0
// 140001603: conditional instruction was optimized away because %var_4.4==0
// 140001591: using guessed type __int64 turn_on_light(void);
// 1400015AF: using guessed type __int64 turn_off_light(void);
// 1400016D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002730: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Planet Gravity Simulation ; Style: protected
#include <stdio.h>
#include <math.h>

#define G 6.674e-11

typedef struct planet {
    char name[20];
    double mass;
    double radius;
    double x;
    double y;
    double vx;
    double vy;
} planet_t;

typedef struct force {
    double x;
    double y;
} force_t;

void calculate_forces(planet_t *planets, int num_planets, force_t *forces);
void update_positions(planet_t *planets, int num_planets, force_t *forces, double timestep);

int main() {
    int num_planets;
    double timestep;
    printf("Enter the number of planets: ");
    scanf("%d", &num_planets);
    planet_t planets[num_planets];
    force_t forces[num_planets];

    printf("Enter the timestep: ");
    scanf("%lf", &timestep);

    for (int i = 0; i < num_planets; i++) {
        printf("Enter the name, mass, radius, x position, y position, vx velocity and vy velocity of planet %d: ", i+1);
        scanf("%s %lf %lf %lf %lf %lf %lf", planets[i].name, &planets[i].mass, &planets[i].radius,
                &planets[i].x, &planets[i].y, &planets[i].vx, &planets[i].vy);
    }

    while (1) {
        calculate_forces(planets, num_planets, forces);
        update_positions(planets, num_planets, forces, timestep);
        printf("Positions:\n");
        for (int i = 0; i < num_planets; i++) {
            printf("%s: x=%lf y=%lf\n", planets[i].name, planets[i].x, planets[i].y);
        }
    }
    return 0;
}

void calculate_forces(planet_t *planets, int num_planets, force_t *forces) {
    for (int i = 0; i < num_planets; i++) {
        forces[i].x = 0;
        forces[i].y = 0;
        for (int j = 0; j < num_planets; j++) {
            if (i == j) continue;
            double dx = planets[j].x - planets[i].x;
            double dy = planets[j].y - planets[i].y;
            double r = sqrt(dx*dx + dy*dy);
            double f = G*planets[i].mass*planets[j].mass/(r*r);
            forces[i].x += f*dx/r;
            forces[i].y += f*dy/r;
        }
    }
}

void update_positions(planet_t *planets, int num_planets, force_t *forces, double timestep) {
    for (int i = 0; i < num_planets; i++) {
        double ax = forces[i].x/planets[i].mass;
        double ay = forces[i].y/planets[i].mass;
        planets[i].vx += ax*timestep;
        planets[i].vy += ay*timestep;
        planets[i].x += planets[i].vx*timestep;
        planets[i].y += planets[i].vy*timestep;
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall calculate_forces(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall update_positions(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  void *v4; // rsp
  __int64 v6[3]; // [rsp+40h] [rbp-50h] BYREF
  __int64 v7; // [rsp+58h] [rbp-38h] BYREF
  unsigned int v8; // [rsp+64h] [rbp-2Ch] BYREF
  __int64 *v9; // [rsp+68h] [rbp-28h]
  __int64 v10; // [rsp+70h] [rbp-20h]
  __int64 *v11; // [rsp+78h] [rbp-18h]
  __int64 v12; // [rsp+80h] [rbp-10h]
  int j; // [rsp+88h] [rbp-8h]
  int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of planets: ");
  scanf("%d", &v8);
  v12 = (int)v8 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(72i64 * (int)v8 + 15) >> 4));
  v11 = v6;
  v10 = v12;
  v6[0] = (int)v8;
  v6[1] = 0i64;
  v4 = alloca(16 * ((unsigned __int64)(16i64 * (int)v8 + 15) >> 4));
  v9 = v6;
  printf("Enter the timestep: ");
  scanf("%lf", &v7);
  for ( i = 0; i < (int)v8; ++i )
  {
    printf(
      "Enter the name, mass, radius, x position, y position, vx velocity and vy velocity of planet %d: ",
      (unsigned int)(i + 1));
    scanf(
      "%s %lf %lf %lf %lf %lf %lf",
      &v11[9 * i],
      &v11[9 * i + 3],
      &v11[9 * i + 4],
      &v11[9 * i + 5],
      &v11[9 * i + 6],
      &v11[9 * i + 7],
      &v11[9 * i + 8]);
  }
  while ( 1 )
  {
    calculate_forces(v11, v8, v9);
    update_positions(v11, v8, v9);
    printf("Positions:\n");
    for ( j = 0; j < (int)v8; ++j )
      printf("%s: x=%lf y=%lf\n", &v11[9 * j], v11[9 * j + 5], v11[9 * j + 6]);
  }
}
// 140001994: using guessed type __int64 __fastcall calculate_forces(_QWORD, _QWORD, _QWORD);
// 140001BF1: using guessed type __int64 __fastcall update_positions(_QWORD, _QWORD, _QWORD);
// 140001EF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type __int64 var_78;

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: medieval
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define FLOOR_MAX 5 // total number of floors in the building
#define ELEVATOR_MAX 3 // total number of elevators in the building

enum Direction {UP, DOWN, HOLD}; // elevator Direction
enum State {IDLE, BUSY}; // elevator State

typedef struct {
    int id;
    int currentFloor;
    int targetFloor;
    enum Direction direction;
    enum State state;
} Elevator;

Elevator elevators[ELEVATOR_MAX]; // array of elevators
int requests[FLOOR_MAX] = {0}; // array of requests on each floor

void move_elevator(Elevator *elevator, int targetFloor);
void process_requests();
void display_building_status();

int main() {
    srand(time(NULL)); // seed the random number generator
    
    // initialize elevators
    for (int i=0; i<ELEVATOR_MAX; i++) {
        elevators[i].id = i + 1;
        elevators[i].currentFloor = 1;
        elevators[i].targetFloor = 1;
        elevators[i].direction = HOLD;
        elevators[i].state = IDLE;
    }
    
    // simulate elevator requests for 10 minutes
    for (int i=0; i<10; i++) {
        int floor = rand() % FLOOR_MAX + 1;
        int direction = rand() % 2;
        requests[floor-1] |= (1 << direction);
        printf("Request received on Floor %d, going %s.\n", floor, direction == UP ? "UP" : "DOWN");
    }
    
    // process requests until all elevators are idle
    while (1) {
        process_requests();
        display_building_status();
        int idle_count = 0;
        for (int i=0; i<ELEVATOR_MAX; i++) {
            if (elevators[i].state == IDLE) {
                idle_count++;
            }
        }
        if (idle_count == ELEVATOR_MAX) {
            break;
        }
    }
    
    printf("All elevators are idle. Simulation ended.");
    
    return 0;
}

void move_elevator(Elevator *elevator, int targetFloor) {
    if (elevator->currentFloor == targetFloor) {
        elevator->state = IDLE;
        printf("Elevator %d has arrived at Floor %d.\n", elevator->id, targetFloor);
        return;
    }
    
    elevator->state = BUSY;
    if (elevator->currentFloor < targetFloor) {
        elevator->currentFloor++;
        elevator->direction = UP;
    }
    else {
        elevator->currentFloor--;
        elevator->direction = DOWN;
    }
    printf("Elevator %d is at Floor %d, going %s.\n", elevator->id, elevator->currentFloor, elevator->direction == UP ? "UP" : "DOWN");
}

void process_requests() {
    // for each floor, check if there are any requests going up or down
    for (int i=0; i<FLOOR_MAX; i++) {
        if (requests[i] != 0) {
            for (int j=0; j<ELEVATOR_MAX; j++) {
                Elevator *elevator = &elevators[j];
                if (elevator->state == IDLE) {
                    int direction = requests[i] & (1 << elevator->currentFloor-1);
                    if (direction) {
                        elevator->targetFloor = i + 1;
                        move_elevator(elevator, elevator->targetFloor);
                        requests[i] &= ~(1 << elevator->targetFloor-1);
                        break;
                    }
                }
                else {
                    if ((elevator->direction == UP && i+1 > elevator->currentFloor && i+1 < elevator->targetFloor) ||
                        (elevator->direction == DOWN && i+1 < elevator->currentFloor && i+1 > elevator->targetFloor)) {
                        elevator->targetFloor = i + 1;
                        requests[i] &= ~(1 << elevator->targetFloor-1);
                        break;
                    }
                }
            }
        }
    }
}

void display_building_status() {
    printf("\n");
    for (int i=FLOOR_MAX; i>=1; i--) {
        printf("Floor %d | ", i);
        for (int j=0; j<ELEVATOR_MAX; j++) {
            if (elevators[j].currentFloor == i) {
                printf("[E%d]", elevators[j].id);
            }
            else {
                printf("[   ]");
            }
        }
        if (requests[i-1] & (1 << UP)) {
            printf("  ^");
        }
        if (requests[i-1] & (1 << DOWN)) {
            printf("  v");
        }
        printf("\n");
    }
    printf("        ");
    for (int i=0; i<ELEVATOR_MAX; i++) {
        printf("---- ");
    }
    printf("\n");
    printf("        ");
    for (int i=1; i<=ELEVATOR_MAX; i++) {
        printf("E%d   ", i);
    }
    printf("\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 process_requests(void); // weak
__int64 display_building_status(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000B000; // weak
_UNKNOWN elevators; // weak
_UNKNOWN unk_14000F044; // weak
_UNKNOWN unk_14000F048; // weak
_UNKNOWN unk_14000F04C; // weak
_DWORD dword_14000F050[12]; // weak
_DWORD requests[8]; // weak


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  const char *v4; // rax
  int v6; // [rsp+28h] [rbp-18h]
  unsigned int v7; // [rsp+2Ch] [rbp-14h]
  int k; // [rsp+30h] [rbp-10h]
  int v9; // [rsp+34h] [rbp-Ch]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 2; ++i )
  {
    *((_DWORD *)&elevators + 5 * i) = i + 1;
    *((_DWORD *)&unk_14000F044 + 5 * i) = 1;
    *((_DWORD *)&unk_14000F048 + 5 * i) = 1;
    *((_DWORD *)&unk_14000F04C + 5 * i) = 2;
    dword_14000F050[5 * i] = 0;
  }
  for ( j = 0; j <= 9; ++j )
  {
    v7 = rand() % 5 + 1;
    v6 = rand() % 2;
    requests[v7 - 1] |= 1 << v6;
    if ( v6 )
      v4 = "DOWN";
    else
      v4 = (const char *)&unk_14000B000;
    printf("Request received on Floor %d, going %s.\n", v7, v4);
  }
  do
  {
    process_requests();
    display_building_status();
    v9 = 0;
    for ( k = 0; k <= 2; ++k )
    {
      if ( !dword_14000F050[5 * k] )
        ++v9;
    }
  }
  while ( v9 != 3 );
  printf("All elevators are idle. Simulation ended.");
  return 0;
}
// 1400018BC: using guessed type __int64 process_requests(void);
// 140001AAB: using guessed type __int64 display_building_status(void);
// 140001D20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F050: using guessed type _DWORD dword_14000F050[12];
// 14000F080: using guessed type _DWORD requests[8];

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: lively
#include <stdio.h>

int linear_search(int arr[], int n, int x) {
  int i;
  for(i=0; i<n; i++) {
    if(arr[i] == x) {
      return i;   // element found
    }
  }
  return -1;   // element not found
}

int main() {
  int arr[] = {1, 5, 3, 9, 8, 4};
  int n = sizeof(arr) / sizeof(arr[0]);
  int x = 9;
  int result = linear_search(arr, n, x);
  if(result == -1) {
    printf("Element not found.\n");
  }
  else {
    printf("Element found at index %d.\n", result);
  }
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall linear_search(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[9]; // [rsp+20h] [rbp-30h] BYREF
  unsigned int v5; // [rsp+44h] [rbp-Ch]
  int v6; // [rsp+48h] [rbp-8h]
  int v7; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 1;
  v4[1] = 5;
  v4[2] = 3;
  v4[3] = 9;
  v4[4] = 8;
  v4[5] = 4;
  v7 = 6;
  v6 = 9;
  v5 = linear_search(v4, 6i64, 9i64);
  if ( v5 == -1 )
    printf("Element not found.\n");
  else
    printf("Element found at index %d.\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall linear_search(_QWORD, _QWORD, _QWORD);
// 140001730: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image compression ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PIXELS 1000000 // maximum number of pixels possible in an image
#define MAX_COLOR 256 // maximum pixel color value

// struct to hold pixel data
typedef struct Pixel {
    int red;
    int green;
    int blue;
} Pixel;

int main() {

    // read input file name
    char file_name[100];
    printf("Enter the name of the input file: ");
    scanf("%s", file_name);

    // read output file name
    char output_file_name[100];
    printf("\nEnter the name of the output file (without extension): ");
    scanf("%s", output_file_name);
    strcat(output_file_name, ".cmp");

    // open input file
    FILE *input_file = fopen(file_name, "r");
    if(input_file == NULL) {
        printf("\nError: Could not open input file!\n");
        return -1;
    }

    // read image data
    Pixel pixels[MAX_PIXELS];
    int num_pixels = 0;
    int red, green, blue;
    while(fscanf(input_file, "%d %d %d", &red, &green, &blue) != EOF) {
        if(num_pixels == MAX_PIXELS) {
            printf("\nError: Image has too many pixels!\n");
            fclose(input_file);
            return -1;
        }
        Pixel p = {red, green, blue};
        pixels[num_pixels++] = p;
    }
    fclose(input_file);

    // open output file
    FILE *output_file = fopen(output_file_name, "wb");
    if(output_file == NULL) {
        printf("\nError: Could not create output file!\n");
        return -1;
    }

    // write number of pixels to output file
    fwrite(&num_pixels, sizeof(int), 1, output_file);

    // write pixel data to output file
    int i, j;
    unsigned char r, g, b;
    for(i = 0; i < num_pixels; i++) {
        r = (unsigned char)((double)pixels[i].red / MAX_COLOR * 255);
        g = (unsigned char)((double)pixels[i].green / MAX_COLOR * 255);
        b = (unsigned char)((double)pixels[i].blue / MAX_COLOR * 255);
        fwrite(&r, sizeof(unsigned char), 1, output_file);
        fwrite(&g, sizeof(unsigned char), 1, output_file);
        fwrite(&b, sizeof(unsigned char), 1, output_file);
    }
    fclose(output_file);

    printf("\nImage compression complete!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (0000000140001625) ----------------------------------------------------
#error "140001625: stack frame is too big (funcsize=0)"

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Digital Watermarking ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 1024
#define MAX_WATERMARK_LENGTH 256
#define MAX_FILENAME_LENGTH 256
#define MAX_BUFFER_SIZE 1024

// Function prototypes
void add_watermark(char* input_file, char* output_file, char* watermark);
void extract_watermark(char* input_file, char* watermark, int watermark_length);

// Main function
int main()
{
    char input_file[MAX_FILENAME_LENGTH];
    char output_file[MAX_FILENAME_LENGTH];
    char watermark[MAX_WATERMARK_LENGTH];
    int choice, watermark_length;

    printf("Enter the input file name:\n");
    scanf("%s", input_file);
    
    printf("Enter the output file name:\n");
    scanf("%s", output_file);

    printf("Enter the watermark:\n");
    scanf("%s", watermark);
    watermark_length = strlen(watermark);

    printf("Choose an operation:\n");
    printf("1. Add watermark\n");
    printf("2. Extract watermark\n");
    scanf("%d", &choice);

    switch (choice)
    {
        case 1:
            add_watermark(input_file, output_file, watermark);
            break;

        case 2:
            extract_watermark(input_file, watermark, watermark_length);
            break;

        default:
            printf("Invalid choice\n");
            break;
    }

    return 0;
}

// Function to add a digital watermark to a file
void add_watermark(char* input_file, char* output_file, char* watermark)
{
    FILE* input_fp = fopen(input_file, "r");
    FILE* output_fp = fopen(output_file, "w");

    if (input_fp == NULL)
    {
        perror("Error: ");
        return;
    }

    if (output_fp == NULL)
    {
        perror("Error: ");
        return;
    }

    char buffer[MAX_BUFFER_SIZE];
    int watermark_pos = 0;
    int watermark_length = strlen(watermark);

    while (fgets(buffer, MAX_LINE_LENGTH, input_fp) != NULL)
    {
        if (watermark_pos < watermark_length)
        {
            int len = strlen(buffer);

            if (len > 0)
            {
                buffer[len-1] = watermark[watermark_pos];
                watermark_pos++;
            }
        }

        fprintf(output_fp, "%s", buffer);
    }

    fclose(input_fp);
    fclose(output_fp);

    printf("Watermark added to file successfully\n");
}

// Function to extract a digital watermark from a file
void extract_watermark(char* input_file, char* watermark, int watermark_length)
{
    FILE* input_fp = fopen(input_file, "r");

    if (input_fp == NULL)
    {
        perror("Error: ");
        return;
    }

    char buffer[MAX_BUFFER_SIZE];
    int watermark_pos = 0;

    while (fgets(buffer, MAX_LINE_LENGTH, input_fp) != NULL)
    {
        int len = strlen(buffer);

        if (len > 0)
        {
            char last_char = buffer[len-1];
            if (watermark_pos < watermark_length && last_char == watermark[watermark_pos])
            {
                watermark_pos++;
            }
        }
    }

    fclose(input_fp);

    if (watermark_pos == watermark_length)
    {
        printf("Watermark extracted successfully\n");
    }
    else
    {
        printf("Watermark not found in file\n");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall add_watermark(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall extract_watermark(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-54h] BYREF
  char Str[256]; // [rsp+30h] [rbp-50h] BYREF
  char v6[256]; // [rsp+130h] [rbp+B0h] BYREF
  char v7[268]; // [rsp+230h] [rbp+1B0h] BYREF
  unsigned int v8; // [rsp+33Ch] [rbp+2BCh]

  _main(argc, argv, envp);
  printf("Enter the input file name:\n");
  scanf("%s", v7);
  printf("Enter the output file name:\n");
  scanf("%s", v6);
  printf("Enter the watermark:\n");
  scanf("%s", Str);
  v8 = strlen(Str);
  printf("Choose an operation:\n");
  printf("1. Add watermark\n");
  printf("2. Extract watermark\n");
  scanf("%d", &v4);
  if ( v4 == 1 )
  {
    add_watermark(v7, v6, Str);
  }
  else if ( v4 == 2 )
  {
    extract_watermark(v7, Str, v8);
  }
  else
  {
    printf("Invalid choice\n");
  }
  return 0;
}
// 14000176E: using guessed type __int64 __fastcall add_watermark(_QWORD, _QWORD, _QWORD);
// 1400018F8: using guessed type __int64 __fastcall extract_watermark(_QWORD, _QWORD, _QWORD);
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NAME_LENGTH 50
#define MAX_AGE 120

struct Person {
    char name[MAX_NAME_LENGTH];
    int age;
};

void write_person_struct_to_file(struct Person* person, FILE* file) {
    fwrite(person->name, sizeof(char), MAX_NAME_LENGTH, file);
    fwrite(&person->age, sizeof(int), 1, file);
}

void read_person_struct_from_file(struct Person* person, FILE* file) {
    fread(person->name, sizeof(char), MAX_NAME_LENGTH, file);
    fread(&person->age, sizeof(int), 1, file);
}

void parse_args(int argc, char** argv, char* read_file_name, char* write_file_name) {
    if (argc < 3) {
        printf("Usage: %s <read_file> <write_file>\n", argv[0]);
        exit(1);
    }
    strcpy(read_file_name, argv[1]);
    strcpy(write_file_name, argv[2]);
}

int main(int argc, char** argv) {
    char read_file_name[MAX_NAME_LENGTH];
    char write_file_name[MAX_NAME_LENGTH];
    FILE* read_file;
    FILE* write_file;
    struct Person* person;
    int num_people;

    parse_args(argc, argv, read_file_name, write_file_name);

    // Open input and output files
    read_file = fopen(read_file_name, "rb");
    if (read_file == NULL) {
        printf("Error: could not open file '%s'\n", read_file_name);
        exit(1);
    }
    write_file = fopen(write_file_name, "wb");
    if (write_file == NULL) {
        printf("Error: could not open file '%s'\n", write_file_name);
        fclose(read_file); // Clean up read file handle
        exit(1);
    }

    // Read input file and write to output file
    printf("Reading from file '%s' and writing to file '%s'\n", read_file_name, write_file_name);
    fread(&num_people, sizeof(int), 1, read_file);
    printf("Number of people: %d\n", num_people);
    for (int i = 0; i < num_people; i++) {
        person = malloc(sizeof(struct Person));
        if (person == NULL) {
            printf("Error: out of memory\n");
            fclose(read_file); // Clean up file handles
            fclose(write_file);
            exit(1);
        }
        read_person_struct_from_file(person, read_file);
        printf("Person %d: name='%s', age=%d\n", i+1, person->name, person->age);
        person->age += 1; // Increment age by 1
        write_person_struct_to_file(person, write_file);
        free(person); // Clean up person struct
    }

    // Clean up file handles
    fclose(read_file);
    fclose(write_file);

    printf("Done!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall write_person_struct_to_file(_QWORD, _QWORD); // weak
__int64 __fastcall read_person_struct_from_file(_QWORD, _QWORD); // weak
__int64 __fastcall parse_args(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400016B4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int Buffer; // [rsp+2Ch] [rbp-A4h] BYREF
  char v5[64]; // [rsp+30h] [rbp-A0h] BYREF
  char FileName[64]; // [rsp+70h] [rbp-60h] BYREF
  void *Block; // [rsp+B0h] [rbp-20h]
  FILE *v8; // [rsp+B8h] [rbp-18h]
  FILE *Stream; // [rsp+C0h] [rbp-10h]
  int i; // [rsp+CCh] [rbp-4h]

  _main(argc, argv, envp);
  parse_args((unsigned int)argc, argv, FileName, v5);
  Stream = fopen(FileName, "rb");
  if ( !Stream )
  {
    printf("Error: could not open file '%s'\n", FileName);
    exit(1);
  }
  v8 = fopen(v5, "wb");
  if ( !v8 )
  {
    printf("Error: could not open file '%s'\n", v5);
    fclose(Stream);
    exit(1);
  }
  printf("Reading from file '%s' and writing to file '%s'\n", FileName, v5);
  fread(&Buffer, 4ui64, 1ui64, Stream);
  printf("Number of people: %d\n", Buffer);
  for ( i = 0; i < (int)Buffer; ++i )
  {
    Block = malloc(0x38ui64);
    if ( !Block )
    {
      printf("Error: out of memory\n");
      fclose(Stream);
      fclose(v8);
      exit(1);
    }
    read_person_struct_from_file(Block, Stream);
    printf("Person %d: name='%s', age=%d\n", (unsigned int)(i + 1), (const char *)Block, *((unsigned int *)Block + 13));
    ++*((_DWORD *)Block + 13);
    write_person_struct_to_file(Block, v8);
    free(Block);
  }
  fclose(Stream);
  fclose(v8);
  printf("Done!\n");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall write_person_struct_to_file(_QWORD, _QWORD);
// 1400015E8: using guessed type __int64 __fastcall read_person_struct_from_file(_QWORD, _QWORD);
// 14000163F: using guessed type __int64 __fastcall parse_args(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Editor ; Style: puzzling
#include <stdio.h>

int main() {
  char image[10][10] = {
    {'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X'},
    {'X', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'X', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'X', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'X', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X'}
  };
  
  printf("Image Editor Program\n");
  printf("Original Image:\n");
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
      printf("%c", image[i][j]);
    }
    printf("\n");
  }
  
  // Task 1: Flip the image vertically
  for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 10; j++) {
      char temp = image[i][j];
      image[i][j] = image[9-i][j];
      image[9-i][j] = temp;
    }
  }
  printf("\nTask 1: Flipped Image Vertically:\n");
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
      printf("%c", image[i][j]);
    }
    printf("\n");
  }
  
  // Task 2: Flip the image horizontally
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 5; j++) {
      char temp = image[i][j];
      image[i][j] = image[i][9-j];
      image[i][9-j] = temp;
    }
  }
  printf("\nTask 2: Flipped Image Horizontally:\n");
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
      printf("%c", image[i][j]);
    }
    printf("\n");
  }
  
  // Task 3: Invert the colors of the image
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
      if (image[i][j] == 'X') {
        image[i][j] = 'O';
      } else {
        image[i][j] = 'X';
      }
    }
  }
  printf("\nTask 3: Inverted Colors Image:\n");
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
      printf("%c", image[i][j]);
    }
    printf("\n");
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _BYTE v4[100]; // [rsp+20h] [rbp-A0h] BYREF
  char v5; // [rsp+86h] [rbp-3Ah]
  char v6; // [rsp+87h] [rbp-39h]
  int i4; // [rsp+88h] [rbp-38h]
  int i3; // [rsp+8Ch] [rbp-34h]
  int i2; // [rsp+90h] [rbp-30h]
  int i1; // [rsp+94h] [rbp-2Ch]
  int nn; // [rsp+98h] [rbp-28h]
  int mm; // [rsp+9Ch] [rbp-24h]
  int kk; // [rsp+A0h] [rbp-20h]
  int jj; // [rsp+A4h] [rbp-1Ch]
  int ii; // [rsp+A8h] [rbp-18h]
  int n; // [rsp+ACh] [rbp-14h]
  int m; // [rsp+B0h] [rbp-10h]
  int k; // [rsp+B4h] [rbp-Ch]
  int j; // [rsp+B8h] [rbp-8h]
  int i; // [rsp+BCh] [rbp-4h]
  __int64 savedregs; // [rsp+C0h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  qmemcpy(
    v4,
    "XXXXXXXXXXXOOOOOOOOXXOOXOOOOOXXOOXOOOOOXXOOXOOOOOXXOOOOOOOOXXOOOOOOOOXXOOOOOOOOXXOOOOOOOOXXXXXXXXXXX",
    sizeof(v4));
  printf("Image Editor Program\n");
  printf("Original Image:\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      printf("%c", (unsigned int)*((char *)&savedregs + 10 * i + j - 160));
    printf("\n");
  }
  for ( k = 0; k <= 4; ++k )
  {
    for ( m = 0; m <= 9; ++m )
    {
      v5 = *((_BYTE *)&savedregs + 10 * k + m - 160);
      *((_BYTE *)&savedregs + 10 * k + m - 160) = *((_BYTE *)&savedregs + 10 * (9 - k) + m - 160);
      *((_BYTE *)&savedregs + 10 * (9 - k) + m - 160) = v5;
    }
  }
  printf("\nTask 1: Flipped Image Vertically:\n");
  for ( n = 0; n <= 9; ++n )
  {
    for ( ii = 0; ii <= 9; ++ii )
      printf("%c", (unsigned int)*((char *)&savedregs + 10 * n + ii - 160));
    printf("\n");
  }
  for ( jj = 0; jj <= 9; ++jj )
  {
    for ( kk = 0; kk <= 4; ++kk )
    {
      v6 = *((_BYTE *)&savedregs + 10 * jj + kk - 160);
      *((_BYTE *)&savedregs + 10 * jj + kk - 160) = *((_BYTE *)&savedregs + 10 * jj + 9 - kk - 160);
      *((_BYTE *)&savedregs + 10 * jj + 9 - kk - 160) = v6;
    }
  }
  printf("\nTask 2: Flipped Image Horizontally:\n");
  for ( mm = 0; mm <= 9; ++mm )
  {
    for ( nn = 0; nn <= 9; ++nn )
      printf("%c", (unsigned int)*((char *)&savedregs + 10 * mm + nn - 160));
    printf("\n");
  }
  for ( i1 = 0; i1 <= 9; ++i1 )
  {
    for ( i2 = 0; i2 <= 9; ++i2 )
    {
      if ( *((_BYTE *)&savedregs + 10 * i1 + i2 - 160) == 88 )
        *((_BYTE *)&savedregs + 10 * i1 + i2 - 160) = 79;
      else
        *((_BYTE *)&savedregs + 10 * i1 + i2 - 160) = 88;
    }
  }
  printf("\nTask 3: Inverted Colors Image:\n");
  for ( i3 = 0; i3 <= 9; ++i3 )
  {
    for ( i4 = 0; i4 <= 9; ++i4 )
      printf("%c", (unsigned int)*((char *)&savedregs + 10 * i3 + i4 - 160));
    printf("\n");
  }
  return 0;
}
// 140001B80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    const int width = 40;
    const int height = 20;
    
    srand(time(NULL)); // seed the random number generator
    
    char canvas[height][width];
    
    // fill the canvas with random ASCII characters
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            int random_num = rand() % 95 + 32; // get a random number between 32 and 126 (inclusive)
            canvas[i][j] = (char) random_num; // convert the random number to its corresponding ASCII character
        }
    }
    
    // print the canvas
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            printf("%c", canvas[i][j]);
        }
        printf("\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v4; // rbx
  void *v5; // rsp
  int v6; // eax
  __int64 v8; // [rsp+0h] [rbp-90h] BYREF
  char v9; // [rsp+20h] [rbp-70h] BYREF
  __int64 *v10; // [rsp+28h] [rbp-68h]
  __int64 v11; // [rsp+30h] [rbp-60h]
  __int64 v12; // [rsp+38h] [rbp-58h]
  __int64 v13; // [rsp+40h] [rbp-50h]
  __int64 v14; // [rsp+48h] [rbp-48h]
  int v15; // [rsp+5Ch] [rbp-34h]
  char *v16; // [rsp+60h] [rbp-30h]
  __int64 v17; // [rsp+68h] [rbp-28h]
  __int64 v18; // [rsp+70h] [rbp-20h]
  int v19; // [rsp+78h] [rbp-18h]
  int v20; // [rsp+7Ch] [rbp-14h]
  int m; // [rsp+80h] [rbp-10h]
  int k; // [rsp+84h] [rbp-Ch]
  int j; // [rsp+88h] [rbp-8h]
  int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = &v8;
  v20 = 40;
  v19 = 20;
  v3 = time(0i64);
  srand(v3);
  v18 = v20 - 1i64;
  v11 = v20;
  v12 = 0i64;
  v4 = v20;
  v17 = v19 - 1i64;
  v13 = v20;
  v14 = 0i64;
  v5 = alloca(16 * ((unsigned __int64)(v20 * (__int64)v19 + 15) >> 4));
  v16 = &v9;
  for ( i = 0; i < v19; ++i )
  {
    for ( j = 0; j < v20; ++j )
    {
      v6 = rand();
      v15 = v6 % 95 + 32;
      v16[j + v4 * i] = v6 % 95 + 32;
    }
  }
  for ( k = 0; k < v19; ++k )
  {
    for ( m = 0; m < v20; ++m )
      printf("%c", (unsigned int)v16[m + v4 * k]);
    printf("\n");
  }
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Typing Speed Test ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void print_instructions() {
    printf("Welcome to the Genius Typing Speed Test!\n");
    printf("Type the words as fast as you can and press enter after each word.\n");
    printf("When you are ready, press Enter to start the test.\n");
    getchar();
    printf("3..\n");
    sleep(1);
    printf("2..\n");
    sleep(1);
    printf("1..\n");
    sleep(1);
    printf("Go!\n");
}

int main() {
    char* words[] = {"genius", "programming", "algorithm", "informatics", "problem", "solution", "software", "engineering", "code", "compiler", "data", "structure", "computer", "science", "keyboard", "internet", "network", "function", "library", "variable"};
    srand(time(0));
    int score = 0;
    print_instructions();
    time_t start_time = time(0);
    while (score < 20) {
        int random_index = rand() % 20;
        char word[15];
        printf("%s: ", words[random_index]);
        scanf("%s", word);
        if (strcmp(word, words[random_index]) == 0) {
            score++;
            printf("Correct!\n");
        } else {
            printf("Incorrect!\n");
        }
        sleep(1);
    }
    time_t end_time = time(0);
    int total_time = (int)(end_time - start_time);
    printf("\nCongratulations! You typed 20 words in %d seconds.\n", total_time);
    printf("Your typing speed is %.2f words per minute.\n", (float)score * 60 / total_time);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 print_instructions(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (000000014000169C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char Str1[15]; // [rsp+21h] [rbp-CFh] BYREF
  char *Str2[20]; // [rsp+30h] [rbp-C0h]
  int v7; // [rsp+D0h] [rbp-20h]
  int v8; // [rsp+D4h] [rbp-1Ch]
  time_t v9; // [rsp+D8h] [rbp-18h]
  time_t v10; // [rsp+E0h] [rbp-10h]
  int v11; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  Str2[0] = "genius";
  Str2[1] = "programming";
  Str2[2] = "algorithm";
  Str2[3] = "informatics";
  Str2[4] = "problem";
  Str2[5] = "solution";
  Str2[6] = "software";
  Str2[7] = "engineering";
  Str2[8] = "code";
  Str2[9] = "compiler";
  Str2[10] = "data";
  Str2[11] = "structure";
  Str2[12] = "computer";
  Str2[13] = "science";
  Str2[14] = "keyboard";
  Str2[15] = "internet";
  Str2[16] = "network";
  Str2[17] = "function";
  Str2[18] = "library";
  Str2[19] = "variable";
  v3 = time(0i64);
  srand(v3);
  v11 = 0;
  print_instructions();
  v10 = time(0i64);
  while ( v11 <= 19 )
  {
    v7 = rand() % 20;
    printf("%s: ", Str2[v7]);
    scanf("%s", Str1);
    if ( !strcmp(Str1, Str2[v7]) )
    {
      ++v11;
      printf("Correct!\n");
    }
    else
    {
      printf("Incorrect!\n");
    }
    sleep(1i64);
  }
  v9 = time(0i64);
  v8 = v9 - v10;
  printf("\nCongratulations! You typed 20 words in %d seconds.\n", (unsigned int)(v9 - v10));
  printf("Your typing speed is %.2f words per minute.\n", (float)((float)(60.0 * (float)v11) / (float)v8));
  return 0;
}
// 140001601: using guessed type __int64 print_instructions(void);
// 1400019D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002A30: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Count Tool ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char input_string[10000];
    int count = 0;
    printf("Welcome to the C Word Count Tool!\n");
    printf("Please enter a sentence or paragraph:\n");
    fgets(input_string, 10000, stdin);
    char *word = strtok(input_string, " ");
    while (word != NULL) {
        count++;
        word = strtok(NULL, " ");
    }
    printf("Your input has %d words!\n", count);
    if (count >= 69) {
        printf("Nice\n");
    }
    printf("Would you like to try again? (Y/N)\n");
    char response = getchar();
    if (response == 'Y' || response == 'y') {
        printf("Yay! Let's do it again!\n");
        main();
    } else {
        printf("Goodbye! Thanks for using the C Word Count Tool, hope it counted up to your expectations!\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  const char **v4; // rdx
  int v5; // ecx
  const char **v6; // r8
  char Buffer[10015]; // [rsp+20h] [rbp-60h] BYREF
  char v9; // [rsp+273Fh] [rbp+26BFh]
  char *i; // [rsp+2740h] [rbp+26C0h]
  unsigned int v11; // [rsp+274Ch] [rbp+26CCh]

  _main(argc, argv, envp);
  v11 = 0;
  printf("Welcome to the C Word Count Tool!\n");
  printf("Please enter a sentence or paragraph:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 10000, v3);
  for ( i = strtok(Buffer, " "); i; i = strtok(0i64, " ") )
    ++v11;
  printf("Your input has %d words!\n", v11);
  if ( (int)v11 > 68 )
    printf("Nice\n");
  printf("Would you like to try again? (Y/N)\n");
  v9 = getchar();
  if ( v9 == 89 || v9 == 121 )
  {
    printf("Yay! Let's do it again!\n");
    main(v5, v4, v6);
  }
  else
  {
    printf("Goodbye! Thanks for using the C Word Count Tool, hope it counted up to your expectations!\n");
  }
  return 0;
}
// 1400016AB: variable 'v5' is possibly undefined
// 1400016AB: variable 'v4' is possibly undefined
// 1400016AB: variable 'v6' is possibly undefined
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: User Input Sanitizer ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int main() {
    char input[100]; //input buffer
    
    printf("Welcome to the User Input Sanitizer Program\n");
    printf("Please enter your input:\n");
    fgets(input, sizeof(input), stdin); //read user input
    
    //Sanitizing Input
    char sanitizedInput[100];
    int len = strlen(input);
    for(int i = 0, j = 0; i < len; i++) {
        if(isalnum(input[i])) {
            sanitizedInput[j] = input[i];
            j++;
        }
    }
    
    printf("\nYour original input was: %s", input);
    printf("\nYour sanitized input is: %s\n", sanitizedInput);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isalnum)(int C);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char v5[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[100]; // [rsp+90h] [rbp+10h] BYREF
  int v7; // [rsp+F4h] [rbp+74h]
  int v8; // [rsp+F8h] [rbp+78h]
  int v9; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Welcome to the User Input Sanitizer Program\n");
  printf("Please enter your input:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  v7 = strlen(Buffer);
  v9 = 0;
  v8 = 0;
  while ( v9 < v7 )
  {
    if ( isalnum(Buffer[v9]) )
      v5[v8++] = Buffer[v9];
    ++v9;
  }
  printf("\nYour original input was: %s", Buffer);
  printf("\nYour sanitized input is: %s\n", v5);
  return 0;
}
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[100];
// 140001591: using guessed type char var_E0[112];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Syntax parsing ; Style: Claude Shannon
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define MAX_EXPR_LEN 100

struct Stack {
    char items[MAX_EXPR_LEN];
    int top;
};

void push(struct Stack* stack, char item) {
    if (stack->top == MAX_EXPR_LEN - 1) {
        printf("Stack overflow\n");
        exit(1);
    }
    stack->top++;
    stack->items[stack->top] = item;
}

char pop(struct Stack* stack) {
    if (stack->top == -1) {
        printf("Stack underflow\n");
        exit(1);
    }
    char item = stack->items[stack->top];
    stack->top--;
    return item;
}

int is_operator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/';
}

int precedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        default:
            return -1;
    }
}

int parse_expression(char* expr) {
    struct Stack operators;
    operators.top = -1;

    struct Stack operands;
    operands.top = -1;

    for (int i = 0; expr[i] != '\0'; i++) {
        char c = expr[i];
        if (isdigit(c)) {
            push(&operands, c);
        } else if (is_operator(c)) {
            while (operators.top != -1 && precedence(c) <= precedence(operators.items[operators.top])) {
                char op = pop(&operators);
                char rhs = pop(&operands);
                char lhs = pop(&operands);
                switch(op) {
                    case '+':
                        push(&operands, lhs + rhs);
                        break;
                    case '-':
                        push(&operands, lhs - rhs);
                        break;
                    case '*':
                        push(&operands, lhs * rhs);
                        break;
                    case '/':
                        push(&operands, lhs / rhs);
                        break;
                }
            }
            push(&operators, c);
        }
    }

    while (operators.top != -1) {
        char op = pop(&operators);
        char rhs = pop(&operands);
        char lhs = pop(&operands);
        switch(op) {
            case '+':
                push(&operands, lhs + rhs);
                break;
            case '-':
                push(&operands, lhs - rhs);
                break;
            case '*':
                push(&operands, lhs * rhs);
                break;
            case '/':
                push(&operands, lhs / rhs);
                break;
        }
    }

    return pop(&operands);
}

int main() {
    char expr[MAX_EXPR_LEN];
    printf("Enter an arithmetic expression: ");
    scanf("%s", expr);
    int result = parse_expression(expr);
    printf("Result: %d\n", result);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall parse_expression(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A1C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[108]; // [rsp+20h] [rbp-70h] BYREF
  unsigned int v5; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter an arithmetic expression: ");
  scanf("%s", v4);
  v5 = parse_expression(v4);
  printf("Result: %d\n", v5);
  return 0;
}
// 140001713: using guessed type __int64 __fastcall parse_expression(_QWORD);
// 140001B40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fractal Generation ; Style: enthusiastic
#include <stdio.h>

int main() {
    printf("Welcome to the world of fractals!\n");
    printf("Are you ready to witness the beauty of the Mandelbrot set?\n");
    printf("Buckle up, because this is going to be an adventure!\n");

    int x, y;
    double zx, zy, cX, cY, tmp;

    int max_iterations = 50;
    double zoom = 1.0;
    double moveX = -0.5;
    double moveY = 0.0;

    int width = 80;
    int height = 40;

    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            zx = zy = 0;
            cX = (x - width / 2.0) / (0.5 * zoom * width) + moveX;
            cY = (y - height / 2.0) / (0.5 * zoom * height) + moveY;
            int i = max_iterations;

            while (zx * zx + zy * zy < 4 && i-- > 0) {
                tmp = zx * zx - zy * zy + cX;
                zy = 2.0 * zx * zy + cY;
                zx = tmp;
            }

            if (i > 0) {
                putchar('#');
            } else {
                putchar('.');
            }
        }
        putchar('\n');
    }

    printf("Wow, wasn't that amazing?\n");
    printf("Fractals are truly a magical thing.\n");
    printf("Now that you've seen the Mandelbrot set, what other fractals would you like to explore?\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl putchar(int Character);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  double v5; // [rsp+28h] [rbp-58h]
  int v6; // [rsp+64h] [rbp-1Ch]
  double v7; // [rsp+68h] [rbp-18h]
  double v8; // [rsp+70h] [rbp-10h]
  int i; // [rsp+78h] [rbp-8h]
  int j; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the world of fractals!\n");
  printf("Are you ready to witness the beauty of the Mandelbrot set?\n");
  printf("Buckle up, because this is going to be an adventure!\n");
  for ( i = 0; i < 40; ++i )
  {
    for ( j = 0; j < 80; ++j )
    {
      v7 = 0.0;
      v8 = 0.0;
      v6 = 50;
      while ( v8 * v8 + v7 * v7 < 4.0 )
      {
        v3 = v6--;
        if ( v3 <= 0 )
          break;
        v5 = v8 * v8 - v7 * v7 + ((double)j - (double)80 / 2.0) / ((double)80 * (1.0 * 0.5)) + -0.5;
        v7 = (v8 + v8) * v7 + ((double)i - (double)40 / 2.0) / ((double)40 * (1.0 * 0.5)) + 0.0;
        v8 = v5;
      }
      if ( v6 <= 0 )
        putchar(46);
      else
        putchar(35);
    }
    putchar(10);
  }
  printf("Wow, wasn't that amazing?\n");
  printf("Fractals are truly a magical thing.\n");
  printf("Now that you've seen the Mandelbrot set, what other fractals would you like to explore?\n");
  return 0;
}
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text processing ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const int MAX_WORDS = 1000; // maximum number of words expected in input file

// function to read words from a file and return the number of words read
int read_file(FILE *fptr, char *words[]) {
    int count = 0;
    char buf[100];

    while(fscanf(fptr, "%s", buf) != EOF) {
        words[count] = strdup(buf); // strdup dynamically allocates memory and returns a pointer to it
        count++;
    }

    return count;
}

// function to sort the words in alphabetical order
void sort_words(char *words[], int count) {
    for(int i = 0; i < count - 1; i++) {
        for(int j = i + 1; j < count; j++) {
            if(strcmp(words[i], words[j]) > 0) {
                char *temp = words[i];
                words[i] = words[j];
                words[j] = temp;
            }
        }
    }
}

// function to write the sorted words to a file
void write_file(FILE *fptr, char *words[], int count) {
    for(int i = 0; i < count; i++) {
        fprintf(fptr, "%s\n", words[i]);
    }
}

int main() {
    char *words[MAX_WORDS];
    FILE *input_file, *output_file;
    int count;

    // open input and output files
    input_file = fopen("input.txt", "r");
    if(input_file == NULL) {
        printf("Error opening input file.\n");
        return 1;
    }

    output_file = fopen("output.txt", "w");
    if(output_file == NULL) {
        printf("Error opening output file.\n");
        return 1;
    }

    // read words from input file
    count = read_file(input_file, words);

    // sort words in alphabetical order
    sort_words(words, count);

    // write sorted words to output file
    write_file(output_file, words, count);

    // close files and free memory used
    fclose(input_file);
    fclose(output_file);
    for(int i = 0; i < count; i++) {
        free(words[i]);
    }

    printf("Words sorted successfully!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall read_file(_QWORD, _QWORD); // weak
__int64 __fastcall sort_words(_QWORD, _QWORD); // weak
__int64 __fastcall write_file(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400017DE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  char v5; // [rsp+20h] [rbp-30h] BYREF
  unsigned int file; // [rsp+24h] [rbp-2Ch]
  FILE *v7; // [rsp+28h] [rbp-28h]
  FILE *Stream; // [rsp+30h] [rbp-20h]
  char *v9; // [rsp+38h] [rbp-18h]
  __int64 v10; // [rsp+40h] [rbp-10h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 999i64;
  v3 = alloca(8000i64);
  v9 = &v5;
  Stream = fopen("input.txt", "r");
  if ( Stream )
  {
    v7 = fopen("output.txt", "w");
    if ( v7 )
    {
      file = read_file(Stream, v9);
      sort_words(v9, file);
      write_file(v7, v9, file);
      fclose(Stream);
      fclose(v7);
      for ( i = 0; i < (int)file; ++i )
        free(*(void **)&v9[8 * i]);
      printf("Words sorted successfully!\n");
      return 0;
    }
    else
    {
      printf("Error opening output file.\n");
      return 1;
    }
  }
  else
  {
    printf("Error opening input file.\n");
    return 1;
  }
}
// 140001617: using guessed type __int64 __fastcall read_file(_QWORD, _QWORD);
// 14000168D: using guessed type __int64 __fastcall sort_words(_QWORD, _QWORD);
// 140001780: using guessed type __int64 __fastcall write_file(_QWORD, _QWORD, _QWORD);
// 140001A30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Terminal Based Game ; Style: Romeo and Juliet
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(0));
    int romeo_health = 100, juliet_health = 100;

    printf("Welcome to Romeo and Juliet Battle Game!\n");
    printf("Romeo and Juliet will fight to the death!\n");

    // Start game loop
    while (1) {
        int round = rand() % 2; // Randomly choose turn order 1 for Romeo 0 for Juliet
        int damage, dodge;

        if (round) { // Romeo goes first
            dodge = rand() % 2; // Randomly choose if Juliet can dodge Romeo's attack
            printf("Romeo attacks Juliet!\n");
            if (dodge) {
                printf("Juliet dodges Romeo's attack!\n");
                continue;
            }
            damage = rand() % 30 + 10; // Randomly generate damage between 10 and 40
            juliet_health -= damage;
            printf("Juliet takes %d damage from Romeo's attack!\n", damage);
            printf("Juliet's health is now %d!\n", juliet_health);
        } else { // Juliet goes first
            dodge = rand() % 2; // Randomly choose if Romeo can dodge Juliet's attack
            printf("Juliet attacks Romeo!\n");
            if (dodge) {
                printf("Romeo dodges Juliet's attack!\n");
                continue;
            }
            damage = rand() % 30 + 10; // Randomly generate damage between 10 and 40
            romeo_health -= damage;
            printf("Romeo takes %d damage from Juliet's attack!\n", damage);
            printf("Romeo's health is now %d!\n", romeo_health);
        }

        // Check if either character has died
        if (romeo_health <= 0) {
            printf("Juliet has defeated Romeo! Romeo is dead!\n");
            break;
        }
        if (juliet_health <= 0) {
            printf("Romeo has defeated Juliet! Juliet is dead!\n");
            break;
        }
    }

    printf("\nThanks for playing Romeo and Juliet Battle Game!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-14h]
  unsigned int v6; // [rsp+2Ch] [rbp-14h]
  int v7; // [rsp+30h] [rbp-10h]
  int v8; // [rsp+30h] [rbp-10h]
  int v9; // [rsp+38h] [rbp-8h]
  int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v10 = 100;
  v9 = 100;
  printf("Welcome to Romeo and Juliet Battle Game!\n");
  printf("Romeo and Juliet will fight to the death!\n");
  do
  {
    while ( 1 )
    {
      while ( rand() % 2 )
      {
        v7 = rand() % 2;
        printf("Romeo attacks Juliet!\n");
        if ( !v7 )
        {
          v5 = rand() % 30 + 10;
          v9 -= v5;
          printf("Juliet takes %d damage from Romeo's attack!\n", v5);
          printf("Juliet's health is now %d!\n", (unsigned int)v9);
          goto LABEL_9;
        }
        printf("Juliet dodges Romeo's attack!\n");
      }
      v8 = rand() % 2;
      printf("Juliet attacks Romeo!\n");
      if ( !v8 )
        break;
      printf("Romeo dodges Juliet's attack!\n");
    }
    v6 = rand() % 30 + 10;
    v10 -= v6;
    printf("Romeo takes %d damage from Juliet's attack!\n", v6);
    printf("Romeo's health is now %d!\n", (unsigned int)v10);
LABEL_9:
    if ( v10 <= 0 )
    {
      printf("Juliet has defeated Romeo! Romeo is dead!\n");
      goto LABEL_13;
    }
  }
  while ( v9 > 0 );
  printf("Romeo has defeated Juliet! Juliet is dead!\n");
LABEL_13:
  printf("\nThanks for playing Romeo and Juliet Battle Game!\n");
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Checksum Calculator ; Style: relaxed
#include <stdio.h>

int main() {
    char message[] = "hello world";
    int sum = 0;
    int i;

    // Iterate over each character in the message
    for (i = 0; message[i] != '\0'; i++) {
        // Add the ASCII value of the character to the sum
        sum += (int) message[i];
    }

    // Print the sum as the checksum
    printf("Checksum: %d\n", sum);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _DWORD v4[4]; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v5; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  strcpy((char *)v4, "hello world");
  v5 = 0;
  for ( v4[3] = 0; *((_BYTE *)v4 + v4[3]); ++v4[3] )
    v5 += *((char *)v4 + v4[3]);
  printf("Checksum: %d\n", v5);
  return 0;
}
// 1400016C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Random Conspiracy Theory Generator ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

char *conspiracy_theories[] = {
    "The moon landing was faked by the government to win the space race against Russia.",
    "The Illuminati are controlling world events from the shadows.",
    "Chemtrails are being used by the government to control the population.",
    "The world is flat and the government is lying to us about it.",
    "Aliens have been visiting Earth for centuries and the government is covering it up.",
    "911 was an inside job orchestrated by the government to justify war in the Middle East.",
    "The CIAs mind control experiments are still being used today to manipulate the masses.",
    "The Denver airport is hiding secret underground bunkers for the elite in case of a global disaster.",
    "The government is hiding the cure for cancer to keep the medical industry profitable.",
    "The major world religions are all part of a vast conspiracy to control and manipulate humanity."
};

void print_conspiracy_theory(char **conspiracy_theories)
{
    srand(time(NULL));
    int random_index = rand() % 10;
    printf("%s\n", conspiracy_theories[random_index]);
}

int main()
{
    print_conspiracy_theory(conspiracy_theories);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall print_conspiracy_theory(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char *conspiracy_theories[10] =
{
  "The moon landing was faked by the government to win the space race against Russia.",
  "The Illuminati are controlling world events from the shadows.",
  "Chemtrails are being used by the government to control the population.",
  "The world is flat and the government is lying to us about it.",
  "Aliens have been visiting Earth for centuries and the government is covering it up.",
  "911 was an inside job orchestrated by the government to justify war in the Middle East.",
  "The CIAs mind control experiments are still being used today to manipulate the masses.",
  "The Denver airport is hiding secret underground bunkers for the elite in case of a global disaster.",
  "The government is hiding the cure for cancer to keep the medical industry profitable.",
  "The major world religions are all part of a vast conspiracy to control and manipulate humanity."
}; // weak


//----- (0000000140001630) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  print_conspiracy_theory(conspiracy_theories);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall print_conspiracy_theory(_QWORD);
// 140001710: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A020: using guessed type char *conspiracy_theories[10];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Intrusion detection system ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_TOLERABLE_TIME 10 // maximum time allowed for the same IP address
#define MAX_PACKETS_PER_REQUEST 3 // maximum number of packets allowed in a request

struct Packet {
    char* ip_address;
    int time_sent;
    int packet_size;
};

// Function to check if a given IP address has sent more than MAX_PACKETS_PER_REQUEST packets in the last MAX_TOLERABLE_TIME seconds
bool check_IP(struct Packet packets[], int num_packets, char* current_ip_address) {
    int count = 0;
    for (int i = 0; i < num_packets; i++) {
        if (strcmp(current_ip_address, packets[i].ip_address) == 0) {
            if (packets[num_packets - 1].time_sent - packets[i].time_sent <= MAX_TOLERABLE_TIME) {
                count++;
            }
        }
    }
    return (count > MAX_PACKETS_PER_REQUEST);
}

// Function to check if a given packet is a part of a DOS attack
bool check_dos_attack(struct Packet packets[], int num_packets, struct Packet current_packet) {
    if (current_packet.packet_size > 10000) {
        return true;
    }
    if (check_IP(packets, num_packets, current_packet.ip_address)) {
        return true;
    }
    return false;
}

int main() {
    struct Packet packets[100];
    int num_packets = 0;

    // Read packets from a file
    FILE* fp = fopen("packets.txt", "r");
    if (fp == NULL) {
        printf("Error opening file\n");
        exit(1);
    }

    while (!feof(fp)) {
        struct Packet current_packet;
        fscanf(fp, "%s %d %d", current_packet.ip_address, &current_packet.time_sent, &current_packet.packet_size);
        if (check_dos_attack(packets, num_packets, current_packet)) {
            printf("DOS attack detected\n");
            // Take appropriate action: block IP address, disconnect user, etc.
        }
        packets[num_packets] = current_packet;
        num_packets++;
    }

    fclose(fp);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall check_dos_attack(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl feof(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400016D0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 *v3; // rcx
  __int64 v4; // rdx
  __int64 v6[2]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v7; // [rsp+40h] [rbp-40h]
  __int64 v8; // [rsp+48h] [rbp-38h] BYREF
  char v9[48]; // [rsp+50h] [rbp-30h] BYREF
  __int64 v10; // [rsp+80h] [rbp+0h] BYREF
  FILE *Stream; // [rsp+690h] [rbp+610h]
  unsigned int v12; // [rsp+69Ch] [rbp+61Ch]

  _main(argc, argv, envp);
  v12 = 0;
  Stream = fopen("packets.txt", "r");
  if ( !Stream )
  {
    printf("Error opening file\n");
    exit(1);
  }
  while ( !feof(Stream) )
  {
    fscanf(Stream, "%s %d %d", v7, &v8, (char *)&v8 + 4);
    v6[0] = v7;
    v6[1] = v8;
    if ( (unsigned __int8)check_dos_attack(v9, v12, v6) )
      printf("DOS attack detected\n");
    v3 = &v10 + 2 * (int)v12 - 6;
    v4 = v8;
    *v3 = v7;
    v3[1] = v4;
    ++v12;
  }
  fclose(Stream);
  return 0;
}
// 14000166F: using guessed type __int64 __fastcall check_dos_attack(_QWORD, _QWORD, _QWORD);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016D0: using guessed type char var_650[48];

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: RAM usage monitor ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

int main()
{
    printf("Welcome to the C RAM usage monitor program in post-apocalyptic style!\n");

    // Seed the random number generator
    srand(time(NULL));

    while(1)
    {
        // Simulate RAM usage by generating a random amount of memory usage
        int ram_used = rand() % 100 + 1;
        printf("RAM usage: %d%%\n", ram_used);

        if(ram_used >= 90)
        {
            printf("WARNING: RAM usage is critical!\n");
            // Play a siren sound to alert the user
            system("afplay siren.mp3 &");
        }

        // Wait for 3 seconds before generating the next RAM usage value
        sleep(3);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// int __cdecl system(const char *Command);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the C RAM usage monitor program in post-apocalyptic style!\n");
  v3 = time(0i64);
  srand(v3);
  while ( 1 )
  {
    v5 = rand() % 100 + 1;
    printf("RAM usage: %d%%\n", (unsigned int)v5);
    if ( v5 > 89 )
    {
      printf("WARNING: RAM usage is critical!\n");
      system("afplay siren.mp3 &");
    }
    sleep(3i64);
  }
}
// 140001700: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002760: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Poker Game ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DECK_SIZE 52
#define HAND_SIZE 5

typedef enum {HEARTS, DIAMONDS, CLUBS, SPADES} Suit;
typedef enum {ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING} Rank;

typedef struct {
    Suit suit;
    Rank rank;
} Card;

Card deck[DECK_SIZE];
Card hand[HAND_SIZE];

void ShuffleDeck() {
    srand(time(NULL));
    
    for (int i = 0; i < DECK_SIZE; i++) {
        Card temp = deck[i];
        int randomIndex = rand() % DECK_SIZE;
        deck[i] = deck[randomIndex];
        deck[randomIndex] = temp;
    }
}

void DealHand() {
    for (int i = 0; i < HAND_SIZE; i++) {
        hand[i] = deck[i];
    }
}

void PrintHand() {
    for (int i = 0; i < HAND_SIZE; i++) {
        printf("%d %d\n", hand[i].rank + 1, hand[i].suit + 1);
    }
}

int main() {
    // Initialize the deck
    int index = 0;
    for (int suit = HEARTS; suit <= SPADES; suit++) {
        for (int rank = ACE; rank <= KING; rank++) {
            deck[index].suit = suit;
            deck[index].rank = rank;
            index++;
        }
    }
    
    printf("Welcome to the Surprise Poker Game!\n");
    
    printf("Shuffling the deck...\n");
    ShuffleDeck();
    
    printf("Dealing your hand...\n");
    DealHand();
    
    printf("Your hand:\n");
    PrintHand();
    
    printf("Wow, what a surprise! You got a Royal Flush!\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 ShuffleDeck(void); // weak
__int64 DealHand(void); // weak
__int64 PrintHand(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN deck; // weak
_DWORD dword_14000F044[103]; // weak


//----- (000000014000173C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int j; // [rsp+24h] [rbp-Ch]
  int i; // [rsp+28h] [rbp-8h]
  int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  for ( i = 0; i <= 3; ++i )
  {
    for ( j = 0; j <= 12; ++j )
    {
      *((_DWORD *)&deck + 2 * v6) = i;
      dword_14000F044[2 * v6++] = j;
    }
  }
  printf("Welcome to the Surprise Poker Game!\n");
  printf("Shuffling the deck...\n");
  ShuffleDeck();
  printf("Dealing your hand...\n");
  DealHand();
  printf("Your hand:\n");
  PrintHand();
  printf("Wow, what a surprise! You got a Royal Flush!\n");
  return 0;
}
// 1400015B0: using guessed type __int64 ShuffleDeck(void);
// 14000167E: using guessed type __int64 DealHand(void);
// 1400016D1: using guessed type __int64 PrintHand(void);
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F044: using guessed type _DWORD dword_14000F044[103];

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: String manipulation ; Style: all-encompassing
#include <stdio.h>
#include <string.h>

int main() {
    char str1[100], str2[100];
    printf("Enter first string: ");
    fgets(str1, 100, stdin);
    printf("Enter second string: ");
    fgets(str2, 100, stdin);

    // Finding the length of the strings
    int length1 = strlen(str1) - 1; // fgets inputs '\n' while Enter is pressed, thus subtracting 1.
    int length2 = strlen(str2) - 1;

    // Concatenating the two strings and displaying the result
    printf("\nAfter concatenating the two strings: ");
    strcat(str1, str2);
    printf("%s", str1);

    // Reversing the first string and displaying the result
    printf("\n\nAfter reversing the first string: ");
    for(int i=0, j=length1-1; i<length1/2; i++, j--) {
        char temp = str1[i];
        str1[i] = str1[j];
        str1[j] = temp;
    }
    printf("%s", str1);

    // Checking if the second string is a palindrome
    int flag=1; // flag=1 means the string is a palindrome, flag=0 means the string is not a palindrome
    for(int i=0, j=length2-1; i<length2/2; i++, j--) {
        if(str2[i] != str2[j]) {
            flag=0;
            break;
        }
    }
    if(flag) printf("\n\nThe second string is a palindrome.");
    else printf("\n\nThe second string is not a palindrome.");

    // Counting the number of vowels in the first string and displaying the result
    int vowel_count=0;
    for(int i=0; i<length1; i++) {
        if(str1[i]=='a' || str1[i]=='e' || str1[i]=='i' || str1[i]=='o' || str1[i]=='u'
            || str1[i]=='A' || str1[i]=='E' || str1[i]=='I' || str1[i]=='O' || str1[i]=='U') {
            vowel_count++;
        }
    }
    printf("\n\nThe first string contains %d vowels.", vowel_count);

    // Replacing all occurrences of a with x in the second string and displaying the result
    for(int i=0; i<length2; i++) {
        if(str2[i]=='a') {
            str2[i] = 'x';
        }
    }
    printf("\n\nAfter replacing all occurrences of a with x in the second string: %s", str2);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcat(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Str[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[103]; // [rsp+90h] [rbp+10h] BYREF
  char v8; // [rsp+F7h] [rbp+77h]
  int v9; // [rsp+F8h] [rbp+78h]
  int v10; // [rsp+FCh] [rbp+7Ch]
  int j; // [rsp+100h] [rbp+80h]
  int i; // [rsp+104h] [rbp+84h]
  unsigned int v13; // [rsp+108h] [rbp+88h]
  int v14; // [rsp+10Ch] [rbp+8Ch]
  int v15; // [rsp+110h] [rbp+90h]
  int v16; // [rsp+114h] [rbp+94h]
  int v17; // [rsp+118h] [rbp+98h]
  int v18; // [rsp+11Ch] [rbp+9Ch]

  _main(argc, argv, envp);
  printf("Enter first string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  printf("Enter second string: ");
  v4 = __acrt_iob_func(0);
  fgets(Str, 100, v4);
  v10 = strlen(Buffer) - 1;
  v9 = strlen(Str) - 1;
  printf("\nAfter concatenating the two strings: ");
  strcat(Buffer, Str);
  printf("%s", Buffer);
  printf("\n\nAfter reversing the first string: ");
  v18 = 0;
  v17 = v10 - 1;
  while ( v18 < v10 / 2 )
  {
    v8 = Buffer[v18];
    Buffer[v18] = Buffer[v17];
    Buffer[v17] = v8;
    ++v18;
    --v17;
  }
  printf("%s", Buffer);
  v16 = 1;
  v15 = 0;
  v14 = v9 - 1;
  while ( v15 < v9 / 2 )
  {
    if ( Str[v15] != Str[v14] )
    {
      v16 = 0;
      break;
    }
    ++v15;
    --v14;
  }
  if ( v16 )
    printf("\n\nThe second string is a palindrome.");
  else
    printf("\n\nThe second string is not a palindrome.");
  v13 = 0;
  for ( i = 0; i < v10; ++i )
  {
    if ( Buffer[i] == 97
      || Buffer[i] == 101
      || Buffer[i] == 105
      || Buffer[i] == 111
      || Buffer[i] == 117
      || Buffer[i] == 65
      || Buffer[i] == 69
      || Buffer[i] == 73
      || Buffer[i] == 79
      || Buffer[i] == 85 )
    {
      ++v13;
    }
  }
  printf("\n\nThe first string contains %d vowels.", v13);
  for ( j = 0; j < v9; ++j )
  {
    if ( Str[j] == 97 )
      Str[j] = 120;
  }
  printf("\n\nAfter replacing all occurrences of a with x in the second string: %s", Str);
  return 0;
}
// 1400019B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[103];
// 140001591: using guessed type char Str[112];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Recursive ; Style: visionary
#include<stdio.h>
void fun(int n) 
{
    if (n == 1) //base condition
    {
        printf("1\n");
    }
    else if (n % 2 == 0) //condition for even numbers
    {
        printf("%d\n", n);
        fun(n/2);
    }
    else //condition for odd numbers
    {
        printf("%d\n", n);
        fun(3*n+1);
    }
}

int main() 
{
    int num;
    printf("Enter a positive integer: ");
    scanf("%d", &num);
    if (num <= 0) //error handling for negative or zero input
    {
        printf("Invalid input. Please enter a positive integer\n");
    }
    else //if input is positive, call the function
    {
        fun(num);
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall fun(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001661) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter a positive integer: ");
  scanf("%d", &v4);
  if ( (int)v4 > 0 )
    fun(v4);
  else
    printf("Invalid input. Please enter a positive integer\n");
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall fun(_QWORD);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: safe
#include <stdio.h>

// Define maximum array length
#define MAX_ARRAY 100

// Define search function
int search(int arr[], int n, int num)
{
    // Initialize left and right pointers
    int left = 0, right = n - 1;
    
    // Iterate until left pointer is less than or equal to right pointer
    while (left <= right)
    {
        // Calculate middle index of the array
        int mid = (left + right) / 2;
        
        // If the middle element is equal to the target number, return mid
        if (arr[mid] == num)
        {
            return mid;
        }
        
        // If the middle element is greater than the target number, update right pointer
        else if (arr[mid] > num)
        {
            right = mid - 1;
        }
        
        // If the middle element is less than the target number, update left pointer
        else
        {
            left = mid + 1;
        }
    }
    
    // If the number is not found, return -1
    return -1;
}

int main()
{
    int arr[MAX_ARRAY];
    int n, num;
    
    // Read the size of the array
    printf("Enter the size of the array (maximum %d): ", MAX_ARRAY);
    scanf("%d", &n);
    
    // Read the elements of the array
    printf("Enter %d elements of the array in ascending order:\n", n);
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }
    
    // Read the number to be searched
    printf("Enter the number to be searched: ");
    scanf("%d", &num);
    
    // Call the search function
    int index = search(arr, n, num);
    
    // Print the result
    if (index != -1)
    {
        printf("Number found at index %d\n", index);
    }
    else
    {
        printf("Number not found\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall search(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000167D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  _DWORD v6[102]; // [rsp+30h] [rbp-50h] BYREF
  unsigned int v7; // [rsp+1C8h] [rbp+148h]
  int i; // [rsp+1CCh] [rbp+14Ch]

  _main(argc, argv, envp);
  printf("Enter the size of the array (maximum %d): ", 100i64);
  scanf("%d", &v5);
  printf("Enter %d elements of the array in ascending order:\n", v5);
  for ( i = 0; i < (int)v5; ++i )
    scanf("%d", &v6[i]);
  printf("Enter the number to be searched: ");
  scanf("%d", &v4);
  v7 = search(v6, v5, v4);
  if ( v7 == -1 )
    printf("Number not found\n");
  else
    printf("Number found at index %d\n", v7);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall search(_QWORD, _QWORD, _QWORD);
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Syntax parsing ; Style: mind-bending
#include <stdio.h>

// Define a custom struct for operators
typedef struct Operator {
    char symbol;
    int precedence;
    int associativity;
} Operator;

// Define the operators and their properties
Operator ops[] = {
    {'+', 1, 0},
    {'-', 1, 0},
    {'*', 2, 0},
    {'/', 2, 0},
    {'^', 3, 1}
};

int isOperator(char c) {
    for (int i = 0; i < sizeof(ops)/sizeof(Operator); i++) {
        if (ops[i].symbol == c) {
            return 1;
        }
    }
    return 0;
}

Operator getOperator(char c) {
    for (int i = 0; i < sizeof(ops)/sizeof(Operator); i++) {
        if (ops[i].symbol == c) {
            return ops[i];
        }
    }
    // If no operator is found, return an empty operator
    Operator empty = {'\0', 0, 0};
    return empty;
}

int shouldDoFirst(char c1, char c2) {
    Operator op1 = getOperator(c1);
    Operator op2 = getOperator(c2);

    // If operators are of equal precedence and left associative, do first operation
    if (op1.precedence == op2.precedence && op1.associativity == 0) {
        return 1;
    }
    // If first operator has higher precedence, do first operation
    else if (op1.precedence > op2.precedence) {
        return 1;
    }
    // If the second operator has higher precedence or the operators are of equal precedence and right associative, do second operation
    else {
        return 0;
    }
}

double parseExpression(char* expression, int start, int end) {
    double total = 0;
    char lastOperator = '\0';

    for (int i = start; i < end; i++) {
        char c = expression[i];

        if (isdigit(c)) {
            // Convert digit to number and add to total
            double num = c - '0';
            total = total * 10 + num;
        }
        else if (isOperator(c)) {
            if (lastOperator != '\0' && shouldDoFirst(lastOperator, c)) {
                // If last operator should be done first, parse the rest of the expression and perform the operation
                double next = parseExpression(expression, i, end);
                Operator op = getOperator(lastOperator);
                if (op.symbol == '+') {
                    total += next;
                }
                else if (op.symbol == '-') {
                    total -= next;
                }
                else if (op.symbol == '*') {
                    total *= next;
                }
                else if (op.symbol == '/') {
                    total /= next;
                }
                else if (op.symbol == '^') {
                    total = pow(total, next);
                }
                return total;
            }
            else {
                // Set last operator and continue parsing
                lastOperator = c;
            }
        }
    }

    // If reached end of expression, return total
    return total;
}

int main() {
    char expression[] = "2+3*4^2-5/2";

    double result = parseExpression(expression, 0, sizeof(expression)/sizeof(char));
    printf("Result: %f\n", result);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
double __fastcall parseExpression(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000189D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[12]; // [rsp+2Ch] [rbp-14h] BYREF
  double v5; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  strcpy(v4, "2+3*4^2-5/2");
  v5 = parseExpression(v4, 0i64, 12i64);
  printf("Result: %f\n", v5);
  return 0;
}
// 1400016FB: using guessed type double __fastcall parseExpression(_QWORD, _QWORD, _QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System process viewer ; Style: excited
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <ctype.h>

#define MAX_NAME_LEN 256
#define MAX_PATH_LEN 1024
#define MAX_PID_LEN 10

/* This program lists all the running processes with their 
 * name, pid, and memory usage.
*/

struct proc_info {
    char name[MAX_NAME_LEN];
    int pid;
    unsigned long int mem;
};

/* Helper function to read the contents of a directory. */
int read_dir(const char *path, char ***entries) {
    DIR *dir = opendir(path);
    if (!dir) {
        return -1;
    }

    struct dirent *entry;
    int count = 0;
    while ((entry = readdir(dir)) != NULL) {
        if (isdigit(entry->d_name[0])) {
            count++;
        }
    }

    *entries = calloc(count, sizeof(char *));
    rewinddir(dir);

    int i = 0;
    while ((entry = readdir(dir)) != NULL) {
        if (isdigit(entry->d_name[0])) {
            (*entries)[i] = calloc(strlen(entry->d_name) + 1, sizeof(char));
            strcpy((*entries)[i], entry->d_name);
            i++;
        }
    }

    closedir(dir);
    return count;
}

/* Helper function to read the information about a process
 * given its pid.
 */
int read_proc_info(int pid, struct proc_info *info) {
    char path[MAX_PATH_LEN];
    snprintf(path, MAX_PATH_LEN, "/proc/%d/stat", pid);

    FILE *file = fopen(path, "r");
    if (!file) {
        return -1;
    }

    fscanf(file, "%d %s %*c %*d %*d %*d %*d %*d %*u %*lu %*lu %*lu %*lu %lu",
           &info->pid, info->name, &info->mem);

    fclose(file);
    return 0;
}

/* Entry point of the program. */
int main(int argc, char **argv) {
    char **entries;
    int proc_count = read_dir("/proc", &entries);

    printf("Name\tPID\tMemory\n");
    printf("===================================\n");

    for (int i = 0; i < proc_count; i++) {
        int pid = atoi(entries[i]);

        struct proc_info info;
        if (read_proc_info(pid, &info) == 0) {
            printf("%s\t%d\t%lu KB\n", info.name, pid, info.mem / 1024);
        }
    }

    /* Free up the memory allocated. */
    for (int i = 0; i < proc_count; i++) {
        free(entries[i]);
    }
    free(entries);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall read_dir(_QWORD, _QWORD); // weak
__int64 __fastcall read_proc_info(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);
// int __cdecl atoi(const char *String);


//----- (0000000140001823) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[260]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v5; // [rsp+124h] [rbp+A4h]
  void *Block; // [rsp+128h] [rbp+A8h] BYREF
  unsigned int v7; // [rsp+130h] [rbp+B0h]
  int v8; // [rsp+134h] [rbp+B4h]
  int j; // [rsp+138h] [rbp+B8h]
  int i; // [rsp+13Ch] [rbp+BCh]

  _main(argc, argv, envp);
  v8 = read_dir("/proc", &Block);
  printf("Name\tPID\tMemory\n");
  printf("===================================\n");
  for ( i = 0; i < v8; ++i )
  {
    v7 = atoi(*((const char **)Block + i));
    if ( !(unsigned int)read_proc_info(v7, v4) )
      printf("%s\t%d\t%lu KB\n", v4, v7, v5 >> 10);
  }
  for ( j = 0; j < v8; ++j )
    free(*((void **)Block + j));
  free(Block);
  return 0;
}
// 14000161E: using guessed type __int64 __fastcall read_dir(_QWORD, _QWORD);
// 14000175E: using guessed type __int64 __fastcall read_proc_info(_QWORD, _QWORD);
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=196 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Date and time ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
   time_t current_time;
   struct tm * time_info;
   char time_string[40];

   time(&current_time);
   time_info = localtime(&current_time);

   strftime(time_string, sizeof(time_string), "%m/%d/%Y %H:%M:%S", time_info);

   printf("Current time: %s\n", time_string);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static struct tm *__cdecl localtime(const time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strftime(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);


//----- (00000001400015CF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[48]; // [rsp+20h] [rbp-40h] BYREF
  time_t Time; // [rsp+50h] [rbp-10h] BYREF
  struct tm *Tm; // [rsp+58h] [rbp-8h]

  _main(argc, argv, envp);
  time(&Time);
  Tm = localtime(&Time);
  strftime(Buffer, 0x28ui64, "%m/%d/%Y %H:%M:%S", Tm);
  printf("Current time: %s\n", Buffer);
  return 0;
}
// 1400016F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Geometric algorithms ; Style: funny
#include <stdio.h>

int main(){
    int q, n, i, x, y;
    printf("Greetings, user! I am Sisyphus and I specialize in creating geometric algorithms for fun!\n");

    printf("Please enter the number of queries: ");
    scanf("%d", &q);

    for(i = 0; i < q; i++){
        printf("Please enter the number of points: ");
        scanf("%d", &n);

        int j, k, area = 0;
        int points[n][2];

        for(j = 0; j < n; j++){
            printf("Please enter an x,y coordinate for point %d: ", j+1);
            scanf("%d %d", &x, &y);
            points[j][0] = x;
            points[j][1] = y;
        }

        for(k = 0; k < n-2; k++){
            area += (points[k+1][0] - points[k][0]) * (points[k+2][1] - points[k][1]) - (points[k+1][1] - points[k][1]) * (points[k+2][0] - points[k][0]);
        }

        if(area < 0){
            printf("Wow, that was acute!\n");
        } else if(area > 0){
            printf("That's obtuse but alright!\n");
        } else {
            printf("That's a straight line! Magnificent.\n");
        }
    }

    printf("Thank you for using Sisyphus Geometric Algorithm Creation prompt.\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  int v5; // [rsp+20h] [rbp-30h] BYREF
  int v6; // [rsp+24h] [rbp-2Ch] BYREF
  int v7; // [rsp+28h] [rbp-28h] BYREF
  int v8; // [rsp+2Ch] [rbp-24h] BYREF
  int *v9; // [rsp+30h] [rbp-20h]
  __int64 v10; // [rsp+38h] [rbp-18h]
  int v11; // [rsp+40h] [rbp-10h]
  int k; // [rsp+44h] [rbp-Ch]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Greetings, user! I am Sisyphus and I specialize in creating geometric algorithms for fun!\n");
  printf("Please enter the number of queries: ");
  scanf("%d", &v8);
  for ( i = 0; i < v8; ++i )
  {
    printf("Please enter the number of points: ");
    scanf("%d", &v7);
    v11 = 0;
    v10 = v7 - 1i64;
    v3 = alloca(16 * ((unsigned __int64)(8i64 * v7 + 15) >> 4));
    v9 = &v5;
    for ( j = 0; j < v7; ++j )
    {
      printf("Please enter an x,y coordinate for point %d: ", (unsigned int)(j + 1));
      scanf("%d %d", &v6, &v5);
      v9[2 * j] = v6;
      v9[2 * j + 1] = v5;
    }
    for ( k = 0; k < v7 - 2; ++k )
      v11 += (v9[2 * k + 5] - v9[2 * k + 1]) * (v9[2 * k + 2] - v9[2 * k])
           - (v9[2 * k + 4] - v9[2 * k]) * (v9[2 * k + 3] - v9[2 * k + 1]);
    if ( v11 >= 0 )
    {
      if ( v11 <= 0 )
        printf("That's a straight line! Magnificent.\n");
      else
        printf("That's obtuse but alright!\n");
    }
    else
    {
      printf("Wow, that was acute!\n");
    }
  }
  printf("Thank you for using Sisyphus Geometric Algorithm Creation prompt.\n");
  return 0;
}
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Public-Key Algorithm Implementation ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

int gcd(int a, int b) {
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

int modInverse(int a, int m) {
    int m0 = m, t, q;
    int x0 = 0, x1 = 1;

    if (m == 1)
        return 0;

    while (a > 1) {
        q = a / m;
        t = m;

        m = a % m, a = t;
        t = x0;

        x0 = x1 - q * x0;
        x1 = t;
    }

    if (x1 < 0)
        x1 += m0;

    return x1;
}

int generateKeys(int *pub_key, int *prv_key) {
    int p, q, n, phiN, e, d, max, i, j, flag;
    int primes[10000];

    srand(time(0));

    printf("Generating prime numbers...\n");

    primes[0] = 2;
    primes[1] = 3;
    max = 2;

    for (i = 5; max < 10000; i += 2) {
        flag = 0;
        for (j = 1; primes[j] * primes[j] <= i; j++) {
            if (i % primes[j] == 0) {
                flag = 1;
                break;
            }
        }

        if (flag == 0) {
            primes[max++] = i;
        }
    }

    p = primes[rand() % 10000];
    q = primes[rand() % 10000];

    while (p == q) {
        q = primes[rand() % 10000];
    }

    n = p * q;
    phiN = (p - 1) * (q - 1);

    e = 10001;

    while (gcd(e, phiN) != 1) {
        e = primes[rand() % 10000];
    }

    d = modInverse(e, phiN);

    *pub_key = e;
    *prv_key = d;

    return n;
}

int main() {
    int pub_key, prv_key, n;
    int input, encrypted, decrypted;

    n = generateKeys(&pub_key, &prv_key);

    printf("Public Key: %d\nPrivate Key: %d\nN: %d\n", pub_key, prv_key, n);

    printf("Enter a number to encrypt: ");
    scanf("%d", &input);

    encrypted = (int)(pow(input, pub_key)) % n;
    decrypted = (int)(pow(encrypted, prv_key)) % n;

    printf("Encrypted: %d\n", encrypted);
    printf("Decrypted: %d\n", decrypted);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generateKeys(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);


//----- (000000014000193F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm0_8
  __int64 v4; // rtt
  int v6; // [rsp+28h] [rbp-18h] BYREF
  unsigned int v7; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v8; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v9; // [rsp+34h] [rbp-Ch]
  unsigned int v10; // [rsp+38h] [rbp-8h]
  unsigned int v11; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v11 = generateKeys(&v8, &v7);
  printf("Public Key: %d\nPrivate Key: %d\nN: %d\n", v8, v7, v11);
  printf("Enter a number to encrypt: ");
  scanf("%d", &v6);
  v3 = pow((double)v6, (double)(int)v8);
  v10 = (int)v3 % (int)v11;
  v4 = (int)pow((double)(int)v10, (double)(int)v7);
  v9 = v4 % (int)v11;
  printf("Encrypted: %d\n", v10);
  printf("Decrypted: %d\n", v9);
  return 0;
}
// 1400016BA: using guessed type __int64 __fastcall generateKeys(_QWORD, _QWORD);
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Phone Book ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure definition for contact in phone book
struct contact {
    char name[50];
    char number[12];
    int id;
};

// Function declarations
void displayMenu();
int getNextId();
void addContact(struct contact[], int*);
void searchContact(struct contact[], int);
void editContact(struct contact[], int);
void deleteContact(struct contact[], int*);

int main() {

    // Initialize phone book with capacity of 100 contacts
    struct contact phoneBook[100];
    int numOfContacts = 0;

    // Display menu and handle user choices until they exit
    int choice = 0;
    do {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                addContact(phoneBook, &numOfContacts);
                break;
            case 2:
                searchContact(phoneBook, numOfContacts);
                break;
            case 3:
                editContact(phoneBook, numOfContacts);
                break;
            case 4:
                deleteContact(phoneBook, &numOfContacts);
                break;
            case 5:
                printf("Thank you for using the phone book.\n\n");
                break;
            default:
                printf("Invalid choice. Please try again.\n\n");
                break;
        }
    } while (choice != 5);

    return 0;
}

// Function to display the menu of choices
void displayMenu() {
    printf("Phone Book\n");
    printf("-----------\n");
    printf("1. Add contact\n");
    printf("2. Search for contact\n");
    printf("3. Edit existing contact\n");
    printf("4. Delete contact\n");
    printf("5. Quit\n");
    printf("\nEnter your choice: ");
}

// Function to generate the next available ID for new contacts
int getNextId() {
    static int id = 0;
    return ++id;
}

// Function to add a new contact to the phone book
void addContact(struct contact phoneBook[], int *numOfContacts) {
    // Check if phone book is already full
    if (*numOfContacts == 100) {
        printf("Phone book is full. Cannot add new contact.\n\n");
        return;
    }

    // Create a new contact
    struct contact newContact;
    printf("Enter contact name: ");
    scanf("%s", newContact.name);
    printf("Enter contact number: ");
    scanf("%s", newContact.number);
    newContact.id = getNextId();

    // Add new contact to phone book
    phoneBook[*numOfContacts] = newContact;
    (*numOfContacts)++;

    printf("Contact added successfully.\n\n");
}

// Function to search for a contact by name or number
void searchContact(struct contact phoneBook[], int numOfContacts) {
    // Get search query from user
    char query[50];
    printf("Enter name or number to search: ");
    scanf("%s", query);

    // Search for contact
    printf("Search Results:\n");
    int resultsFound = 0;
    for (int i = 0; i < numOfContacts; i++) {
        if (strstr(phoneBook[i].name, query) != NULL || strstr(phoneBook[i].number, query) != NULL) {
            printf("%d. Name: %s - Number: %s\n", resultsFound+1, phoneBook[i].name, phoneBook[i].number);
            resultsFound++;
        }
    }

    // Display message if no results were found
    if (resultsFound == 0) {
        printf("No results found.\n");
    }

    printf("\n");
}

// Function to edit an existing contact
void editContact(struct contact phoneBook[], int numOfContacts) {
    // Get contact ID from user
    int contactId;
    printf("Enter ID of contact to edit: ");
    scanf("%d", &contactId);

    // Find contact with matching ID
    struct contact *contactToEdit = NULL;
    for (int i = 0; i < numOfContacts; i++) {
        if (phoneBook[i].id == contactId) {
            contactToEdit = &phoneBook[i];
            break;
        }
    }

    // Display error message if contact was not found
    if (contactToEdit == NULL) {
        printf("Contact with ID %d not found.\n\n", contactId);
        return;
    }

    // Edit contact
    printf("Enter new name (or leave blank to keep current): ");
    char newName[50];
    fflush(stdin);
    fgets(newName, 50, stdin);
    newName[strcspn(newName, "\r\n")] = 0; // Remove newline character at end of string

    if (strcmp(newName, "") != 0) {
        strcpy(contactToEdit->name, newName);
    }

    printf("Enter new number (or leave blank to keep current): ");
    char newNumber[12];
    fflush(stdin);
    fgets(newNumber, 12, stdin);
    newNumber[strcspn(newNumber, "\r\n")] = 0; // Remove newline character at end of string

    if (strcmp(newNumber, "") != 0) {
        strcpy(contactToEdit->number, newNumber);
    }

    printf("Contact edited successfully.\n\n");
}

// Function to delete an existing contact
void deleteContact(struct contact phoneBook[], int *numOfContacts) {
    // Get contact ID from user
    int contactId;
    printf("Enter ID of contact to delete: ");
    scanf("%d", &contactId);

    // Find index of contact with matching ID
    int indexToDelete = -1;
    for (int i = 0; i < *numOfContacts; i++) {
        if (phoneBook[i].id == contactId) {
            indexToDelete = i;
            break;
        }
    }

    // Display error message if contact was not found
    if (indexToDelete == -1) {
        printf("Contact with ID %d not found.\n\n", contactId);
        return;
    }

    // Shift all contacts after the one to be deleted back one index
    for (int i = indexToDelete; i < (*numOfContacts)-1; i++) {
        phoneBook[i] = phoneBook[i+1];
    }

    // Decrement number of contacts in phone book
    (*numOfContacts)--;

    printf("Contact deleted successfully.\n\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 displayMenu(void); // weak
__int64 __fastcall addContact(_QWORD, _QWORD); // weak
__int64 __fastcall searchContact(_QWORD, _QWORD); // weak
__int64 __fastcall editContact(_QWORD, _QWORD); // weak
__int64 __fastcall deleteContact(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[6800]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  v4 = 0;
  do
  {
    displayMenu();
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        addContact(v6, &v5);
        break;
      case 2:
        searchContact(v6, v5);
        break;
      case 3:
        editContact(v6, v5);
        break;
      case 4:
        deleteContact(v6, &v5);
        break;
      case 5:
        printf("Thank you for using the phone book.\n\n");
        break;
      default:
        printf("Invalid choice. Please try again.\n\n");
        break;
    }
  }
  while ( v4 != 5 );
  return 0;
}
// 1400016D1: using guessed type __int64 displayMenu(void);
// 140001773: using guessed type __int64 __fastcall addContact(_QWORD, _QWORD);
// 140001887: using guessed type __int64 __fastcall searchContact(_QWORD, _QWORD);
// 1400019E1: using guessed type __int64 __fastcall editContact(_QWORD, _QWORD);
// 140001BB2: using guessed type __int64 __fastcall deleteContact(_QWORD, _QWORD);
// 140001DE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database simulation ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_RECORDS 1000
#define MAX_NAME_LENGTH 30
#define MAX_PHONE_LENGTH 15

typedef struct {
    char name[MAX_NAME_LENGTH];
    char phone[MAX_PHONE_LENGTH];
} Record;

typedef struct {
    Record records[MAX_RECORDS];
    int num_records;
} Database;

void add_record(Database* db, char* name, char* phone) {
    if (db->num_records < MAX_RECORDS) {
        strcpy(db->records[db->num_records].name, name);
        strcpy(db->records[db->num_records].phone, phone);
        db->num_records++;
    } else {
        printf("Error: database is full.\n");
    }
}

bool delete_record(Database* db, int index) {
    if (index >= 0 && index < db->num_records) {
        for (int i = index; i < db->num_records - 1; i++) {
            db->records[i] = db->records[i + 1];
        }
        db->num_records--;
        return true;
    } else {
        printf("Error: invalid index.\n");
        return false;
    }
}

int find_record(Database* db, char* name) {
    for (int i = 0; i < db->num_records; i++) {
        if (strcmp(db->records[i].name, name) == 0) {
            return i;
        }
    }
    return -1;
}

void print_record(Record* record) {
    printf("Name: %s\nPhone: %s\n", record->name, record->phone);
}

void print_database(Database* db) {
    if (db->num_records == 0) {
        printf("Database is empty.\n");
    } else {
        for (int i = 0; i < db->num_records; i++) {
            printf("Record %d:\n", i + 1);
            print_record(&db->records[i]);
        }
    }
}

int main() {
    Database db = {0};
    char command;
    char name[MAX_NAME_LENGTH];
    char phone[MAX_PHONE_LENGTH];
    int index;

    do {
        printf("Enter a command (a: add, d: delete, f: find, p: print, q: quit): ");
        scanf(" %c", &command);

        switch (command) {
            case 'a':
                printf("Enter name: ");
                scanf("%s", name);
                printf("Enter phone: ");
                scanf("%s", phone);
                add_record(&db, name, phone);
                break;
            case 'd':
                printf("Enter index: ");
                scanf("%d", &index);
                delete_record(&db, index - 1);
                break;
            case 'f':
                printf("Enter name: ");
                scanf("%s", name);
                index = find_record(&db, name);
                if (index == -1) {
                    printf("Record not found.\n");
                } else {
                    printf("Record found at index %d:\n", index + 1);
                    print_record(&db.records[index]);
                }
                break;
            case 'p':
                print_database(&db);
                break;
            case 'q':
                printf("Quitting...\n");
                break;
            default:
                printf("Invalid command.\n");
                break;
        }
    } while (command != 'q');

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_record(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall delete_record(_QWORD, _QWORD); // weak
__int64 __fastcall find_record(_QWORD, _QWORD); // weak
__int64 __fastcall print_record(_QWORD); // weak
__int64 __fastcall print_database(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memset(void *, int Val, size_t Size);


//----- (00000001400018D9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int record; // [rsp+2Ch] [rbp-54h] BYREF
  char v5[15]; // [rsp+31h] [rbp-4Fh] BYREF
  char v6[31]; // [rsp+40h] [rbp-40h] BYREF
  char v7; // [rsp+5Fh] [rbp-21h] BYREF
  char v8[45008]; // [rsp+60h] [rbp-20h] BYREF

  _main(argc, argv, envp);
  memset(v8, 0, 0xAFCCui64);
  do
  {
    printf("Enter a command (a: add, d: delete, f: find, p: print, q: quit): ");
    scanf(" %c", &v7);
    switch ( v7 )
    {
      case 'a':
        printf("Enter name: ");
        scanf("%s", v6);
        printf("Enter phone: ");
        scanf("%s", v5);
        add_record(v8, v6, v5);
        break;
      case 'd':
        printf("Enter index: ");
        scanf("%d", &record);
        delete_record(v8, (unsigned int)(record - 1));
        break;
      case 'f':
        printf("Enter name: ");
        scanf("%s", v6);
        record = find_record(v8, v6);
        if ( record == -1 )
        {
          printf("Record not found.\n");
        }
        else
        {
          printf("Record found at index %d:\n", (unsigned int)(record + 1));
          print_record(&v8[45 * record]);
        }
        break;
      case 'p':
        print_database(v8);
        break;
      case 'q':
        printf("Quitting...\n");
        break;
      default:
        printf("Invalid command.\n");
        break;
    }
  }
  while ( v7 != 113 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall add_record(_QWORD, _QWORD, _QWORD);
// 1400016A9: using guessed type __int64 __fastcall delete_record(_QWORD, _QWORD);
// 1400017AB: using guessed type __int64 __fastcall find_record(_QWORD, _QWORD);
// 140001818: using guessed type __int64 __fastcall print_record(_QWORD);
// 14000184C: using guessed type __int64 __fastcall print_database(_QWORD);
// 140001BA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400018D9: using guessed type int var_B004;

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home automation ; Style: thoughtful
#include <stdio.h>

// Function to turn on/off the lights of the living room
void livingRoomLights(int option) {
    if(option == 1) {
        printf("Turning on the lights of the living room...\n");
    } else if(option == 0) {
        printf("Turning off the lights of the living room...\n");
    } else {
        printf("Invalid option...\n");
    }
}

// Function to control the temperature of the living room
void livingRoomTemperature(int temp) {
    printf("Setting the temperature of the living room to %d degrees...\n",temp);
}

// Function to control the blinds of the living room
void livingRoomBlinds(int option) {
    if(option == 1) {
        printf("Opening the blinds of the living room...\n");
    } else if(option == 0) {
        printf("Closing the blinds of the living room...\n");
    } else {
        printf("Invalid option...\n");
    }
}

// Function to turn on/off the lights of the bedroom
void bedroomLights(int option) {
    if(option == 1) {
        printf("Turning on the lights of the bedroom...\n");
    } else if(option == 0) {
        printf("Turning off the lights of the bedroom...\n");
    } else {
        printf("Invalid option...\n");
    }
}

// Function to control the temperature of the bedroom
void bedroomTemperature(int temp) {
    printf("Setting the temperature of the bedroom to %d degrees...\n",temp);
}

// Function to control the blinds of the bedroom
void bedroomBlinds(int option) {
    if(option == 1) {
        printf("Opening the blinds of the bedroom...\n");
    } else if(option == 0) {
        printf("Closing the blinds of the bedroom...\n");
    } else {
        printf("Invalid option...\n");
    }
}

int main() {
    int livingRoomLightOption = 0, livingRoomTemp = 0, livingRoomBlindsOption = 0; // Living room variables
    int bedroomLightOption = 0, bedroomTemp = 0,  bedroomBlindsOption = 0; // Bedroom variables
    
    printf("Welcome to the smart home automation system!\n\n");
    
    // Living room controls
    printf("Living Room controls:\n");
    printf("1. Lights\n");
    printf("2. Temperature\n");
    printf("3. Blinds\n");
    printf("Enter your choice: ");
    int livingRoomChoice = 0;
    scanf("%d",&livingRoomChoice);
    switch(livingRoomChoice) {
        case 1:
            printf("Enter 1 to turn on the lights or 0 to turn off the lights: ");
            scanf("%d",&livingRoomLightOption);
            livingRoomLights(livingRoomLightOption);
            break;
        case 2:
            printf("Enter the temperature that you want to set: ");
            scanf("%d",&livingRoomTemp);
            livingRoomTemperature(livingRoomTemp);
            break;
        case 3:
            printf("Enter 1 to open the blinds or 0 to close the blinds: ");
            scanf("%d",&livingRoomBlindsOption);
            livingRoomBlinds(livingRoomBlindsOption);
            break;
        default:
            printf("Invalid choice...\n");
            break;
    }
    printf("\n");
    
    // Bedroom controls
    printf("Bedroom controls:\n");
    printf("1. Lights\n");
    printf("2. Temperature\n");
    printf("3. Blinds\n");
    printf("Enter your choice: ");
    int bedroomChoice = 0;
    scanf("%d",&bedroomChoice);
    switch(bedroomChoice) {
        case 1:
            printf("Enter 1 to turn on the lights or 0 to turn off the lights: ");
            scanf("%d",&bedroomLightOption);
            bedroomLights(bedroomLightOption);
            break;
        case 2:
            printf("Enter the temperature that you want to set: ");
            scanf("%d",&bedroomTemp);
            bedroomTemperature(bedroomTemp);
            break;
        case 3:
            printf("Enter 1 to open the blinds or 0 to close the blinds: ");
            scanf("%d",&bedroomBlindsOption);
            bedroomBlinds(bedroomBlindsOption);
            break;
        default:
            printf("Invalid choice...\n");
            break;
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall livingRoomLights(_QWORD); // weak
__int64 __fastcall livingRoomTemperature(_QWORD); // weak
__int64 __fastcall livingRoomBlinds(_QWORD); // weak
__int64 __fastcall bedroomLights(_QWORD); // weak
__int64 __fastcall bedroomTemperature(_QWORD); // weak
__int64 __fastcall bedroomBlinds(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001766) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-20h] BYREF
  int v5; // [rsp+24h] [rbp-1Ch] BYREF
  unsigned int v6; // [rsp+28h] [rbp-18h] BYREF
  unsigned int v7; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v8; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v9; // [rsp+34h] [rbp-Ch] BYREF
  unsigned int v10; // [rsp+38h] [rbp-8h] BYREF
  unsigned int v11; // [rsp+3Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  printf("Welcome to the smart home automation system!\n\n");
  printf("Living Room controls:\n");
  printf("1. Lights\n");
  printf("2. Temperature\n");
  printf("3. Blinds\n");
  printf("Enter your choice: ");
  v5 = 0;
  scanf("%d", &v5);
  if ( v5 == 3 )
  {
    printf("Enter 1 to open the blinds or 0 to close the blinds: ");
    scanf("%d", &v9);
    livingRoomBlinds(v9);
  }
  else
  {
    if ( v5 > 3 )
      goto LABEL_9;
    if ( v5 == 1 )
    {
      printf("Enter 1 to turn on the lights or 0 to turn off the lights: ");
      scanf("%d", &v11);
      livingRoomLights(v11);
      goto LABEL_10;
    }
    if ( v5 == 2 )
    {
      printf("Enter the temperature that you want to set: ");
      scanf("%d", &v10);
      livingRoomTemperature(v10);
    }
    else
    {
LABEL_9:
      printf("Invalid choice...\n");
    }
  }
LABEL_10:
  printf("\n");
  printf("Bedroom controls:\n");
  printf("1. Lights\n");
  printf("2. Temperature\n");
  printf("3. Blinds\n");
  printf("Enter your choice: ");
  v4 = 0;
  scanf("%d", &v4);
  if ( v4 == 3 )
  {
    printf("Enter 1 to open the blinds or 0 to close the blinds: ");
    scanf("%d", &v6);
    bedroomBlinds(v6);
  }
  else
  {
    if ( v4 > 3 )
    {
LABEL_18:
      printf("Invalid choice...\n");
      return 0;
    }
    if ( v4 == 1 )
    {
      printf("Enter 1 to turn on the lights or 0 to turn off the lights: ");
      scanf("%d", &v8);
      bedroomLights(v8);
    }
    else
    {
      if ( v4 != 2 )
        goto LABEL_18;
      printf("Enter the temperature that you want to set: ");
      scanf("%d", &v7);
      bedroomTemperature(v7);
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall livingRoomLights(_QWORD);
// 140001631: using guessed type __int64 __fastcall livingRoomTemperature(_QWORD);
// 140001655: using guessed type __int64 __fastcall livingRoomBlinds(_QWORD);
// 1400016A4: using guessed type __int64 __fastcall bedroomLights(_QWORD);
// 1400016F3: using guessed type __int64 __fastcall bedroomTemperature(_QWORD);
// 140001717: using guessed type __int64 __fastcall bedroomBlinds(_QWORD);
// 140001AD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Geometric algorithms ; Style: shape shifting
#include<stdio.h>

int main(){
    int shape;
    float length, breadth, radius, side;
    printf("Enter the initial shape (1: Square, 2: Rectangle, 3: Circle): ");
    scanf("%d",&shape);
    switch(shape){
        case 1:
            printf("Enter the side length of the square: ");
            scanf("%f",&side);
            printf("The square with side length %.2f has perimeter %.2f and area %.2f\n",side,(4*side),(side*side));
            printf("Enter the radius of the circle: ");
            scanf("%f",&radius);
            printf("The circle with radius %.2f has circumference %.2f and area %.2f\n",radius,(2*3.1416*radius),(3.1416*radius*radius));
            printf("Enter the length and breadth of the rectangle: ");
            scanf("%f%f",&length,&breadth);
            printf("The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",length,breadth,(2*(length+breadth)),(length*breadth));
            break;
        case 2:
            printf("Enter the length and breadth of the rectangle: ");
            scanf("%f%f",&length,&breadth);
            printf("The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",length,breadth,(2*(length+breadth)),(length*breadth));
            printf("Enter the side length of the square: ");
            scanf("%f",&side);
            printf("The square with side length %.2f has perimeter %.2f and area %.2f\n",side,(4*side),(side*side));
            printf("Enter the radius of the circle: ");
            scanf("%f",&radius);
            printf("The circle with radius %.2f has circumference %.2f and area %.2f\n",radius,(2*3.1416*radius),(3.1416*radius*radius));
            break;
        case 3:
            printf("Enter the radius of the circle: ");
            scanf("%f",&radius);
            printf("The circle with radius %.2f has circumference %.2f and area %.2f\n",radius,(2*3.1416*radius),(3.1416*radius*radius));
            printf("Enter the length and breadth of the rectangle: ");
            scanf("%f%f",&length,&breadth);
            printf("The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",length,breadth,(2*(length+breadth)),(length*breadth));
            printf("Enter the side length of the square: ");
            scanf("%f",&side);
            printf("The square with side length %.2f has perimeter %.2f and area %.2f\n",side,(4*side),(side*side));
            break;
        default:
            printf("Invalid choice, please enter valid input!\n");
            break;
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+3Ch] [rbp-14h] BYREF
  float v5; // [rsp+40h] [rbp-10h] BYREF
  float v6; // [rsp+44h] [rbp-Ch] BYREF
  float v7; // [rsp+48h] [rbp-8h] BYREF
  int v8; // [rsp+4Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the initial shape (1: Square, 2: Rectangle, 3: Circle): ");
  scanf("%d", &v8);
  if ( v8 == 3 )
  {
    printf("Enter the radius of the circle: ");
    scanf("%f", &v5);
    printf("The circle with radius %.2f has circumference %.2f and area %.2f\n", v5, v5 * 6.2832, v5 * 3.1416 * v5);
    printf("Enter the length and breadth of the rectangle: ");
    scanf("%f%f", &v7, &v6);
    printf(
      "The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",
      v7,
      v6,
      (float)((float)(v6 + v7) + (float)(v6 + v7)),
      (float)(v6 * v7));
    printf("Enter the side length of the square: ");
    scanf("%f", &v4);
    printf(
      "The square with side length %.2f has perimeter %.2f and area %.2f\n",
      v4,
      (float)(4.0 * v4),
      (float)(v4 * v4));
  }
  else
  {
    if ( v8 > 3 )
    {
LABEL_9:
      printf("Invalid choice, please enter valid input!\n");
      return 0;
    }
    if ( v8 == 1 )
    {
      printf("Enter the side length of the square: ");
      scanf("%f", &v4);
      printf(
        "The square with side length %.2f has perimeter %.2f and area %.2f\n",
        v4,
        (float)(4.0 * v4),
        (float)(v4 * v4));
      printf("Enter the radius of the circle: ");
      scanf("%f", &v5);
      printf("The circle with radius %.2f has circumference %.2f and area %.2f\n", v5, v5 * 6.2832, v5 * 3.1416 * v5);
      printf("Enter the length and breadth of the rectangle: ");
      scanf("%f%f", &v7, &v6);
      printf(
        "The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",
        v7,
        v6,
        (float)((float)(v6 + v7) + (float)(v6 + v7)),
        (float)(v6 * v7));
    }
    else
    {
      if ( v8 != 2 )
        goto LABEL_9;
      printf("Enter the length and breadth of the rectangle: ");
      scanf("%f%f", &v7, &v6);
      printf(
        "The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",
        v7,
        v6,
        (float)((float)(v6 + v7) + (float)(v6 + v7)),
        (float)(v6 * v7));
      printf("Enter the side length of the square: ");
      scanf("%f", &v4);
      printf(
        "The square with side length %.2f has perimeter %.2f and area %.2f\n",
        v4,
        (float)(4.0 * v4),
        (float)(v4 * v4));
      printf("Enter the radius of the circle: ");
      scanf("%f", &v5);
      printf("The circle with radius %.2f has circumference %.2f and area %.2f\n", v5, v5 * 6.2832, v5 * 3.1416 * v5);
    }
  }
  return 0;
}
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: User Input Sanitizer ; Style: beginner-friendly
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#define MAX_INPUT_LENGTH 100

// This function trims leading and trailing spaces from a string
char *trimString(char *inputString) {
    char *end;

    // Trim leading spaces
    while (isspace((unsigned char)*inputString)) {
        inputString++;
    }

    // If all spaces are trimmed
    if (*inputString == '\0') {
        return inputString;
    }

    // Trim trailing spaces
    end = inputString + strlen(inputString) - 1;
    while (end > inputString && isspace((unsigned char)*end)) {
        end--;
    }

    // Null terminate the trimmed string
    *(end+1) = '\0';

    return inputString;
}

// This function converts all letters to lowercase
char *toLowerCase(char *inputString) {
    int i = 0;

    while (inputString[i]) {
        inputString[i] = tolower(inputString[i]);
        i++;
    }

    return inputString;
}

// This function checks if a string contains only digits
int isNumeric(const char *inputString) {
    while (*inputString) {
        if (!isdigit(*inputString)) {
            return 0;
        }
        inputString++;
    }
    return 1;
}

// Main function that sanitizes user input
int main() {
    char userInput[MAX_INPUT_LENGTH];

    // Prompt user for input
    printf("Enter a string: ");
    fgets(userInput, MAX_INPUT_LENGTH, stdin);

    // Remove newline character
    userInput[strcspn(userInput, "\n")] = 0;

    // Trim leading and trailing spaces
    char *trimmedInput = trimString(userInput);

    // Convert all letters to lowercase
    char *lowercaseInput = toLowerCase(trimmedInput);

    // Check if input contains only digits
    if (isNumeric(lowercaseInput)) {
        printf("You entered a numeric string: %s\n", lowercaseInput);
    } else {
        printf("You entered a non-numeric string: %s\n", lowercaseInput);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall trimString(_QWORD); // weak
__int64 __fastcall toLowerCase(_QWORD); // weak
__int64 __fastcall isNumeric(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016C5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[112]; // [rsp+20h] [rbp-80h] BYREF
  const char *v6; // [rsp+90h] [rbp-10h]
  __int64 v7; // [rsp+98h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  v7 = trimString(Buffer);
  v6 = (const char *)toLowerCase(v7);
  if ( (unsigned int)isNumeric(v6) )
    printf("You entered a numeric string: %s\n", v6);
  else
    printf("You entered a non-numeric string: %s\n", v6);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall trimString(_QWORD);
// 140001625: using guessed type __int64 __fastcall toLowerCase(_QWORD);
// 14000168B: using guessed type __int64 __fastcall isNumeric(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016C5: using guessed type char Buffer[112];

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: imaginative
#include <stdio.h>

int prime(int n) {
    int i;
    if (n <= 1) {
        return 0;
    }
    for (i = 2; i <= n/2; i++) {
        if (n%i == 0) {
            return 0;
        }
    }
    return 1;
}

void primeGenerator(int N) {
    int i, count = 0;
    printf("List of prime numbers between 1 and %d: \n", N);
    for (i = 2; i <= N; i++) {
        if (prime(i)) {
            printf("%d ", i);
            count++;
        }
    }
    printf("\nTotal number of prime numbers in the list: %d\n", count);
}

int main() {
    int n;
    printf("Enter the upper limit of the range you want to generate prime numbers for: ");
    scanf("%d", &n);
    primeGenerator(n);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall primeGenerator(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016B1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the upper limit of the range you want to generate prime numbers for: ");
  scanf("%d", &v4);
  primeGenerator(v4);
  return 0;
}
// 140001637: using guessed type __int64 __fastcall primeGenerator(_QWORD);
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Periodic Table Quiz ; Style: retro
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_ELEMENT_NAME_LENGTH 20
#define MAX_NUM_ELEMENTS 118

typedef struct {
    char name[MAX_ELEMENT_NAME_LENGTH];
    char symbol[3];
    int atomicNumber;
    float atomicWeight;
} Element;

void displayTable();
void displayMenu();
void playQuiz();

int main() {
    printf("Welcome to the Retro Periodic Table Quiz!\n\n");
    displayTable();
    displayMenu();
    return 0;
}

void displayTable() {
    Element elements[MAX_NUM_ELEMENTS];
    FILE* fptr;
    fptr = fopen("periodic_table.txt", "r");
    
    if (fptr == NULL) {
        printf("Error: Cannot open file.\n");
        exit(1);
    }
    
    int i = 0;
    char line[100];
    char* token;
    while (fgets(line, 100, fptr) != NULL) {
        token = strtok(line, ",");
        strcpy(elements[i].name, token);
        
        token = strtok(NULL, ",");
        strcpy(elements[i].symbol, token);
        
        token = strtok(NULL, ",");
        elements[i].atomicNumber = atoi(token);
        
        token = strtok(NULL, ",");
        elements[i].atomicWeight = atof(token);
        
        i++;
    }
    fclose(fptr);
    
    printf("\n");
    printf("     Retro Periodic Table Quiz\n");
    printf("------------------------------------\n\n");
    
    printf("  -----------------------------------------------------------------------------\n");
    for (i = 0; i < MAX_NUM_ELEMENTS; i++) {
        if (i == 0 || (elements[i-1].atomicNumber)/10 != (elements[i].atomicNumber)/10) {
            printf(" |");
        }
        printf(" %-2d %-20s ", elements[i].atomicNumber, elements[i].symbol);
        if (i == MAX_NUM_ELEMENTS-1 || (elements[i+1].atomicNumber)/10 != (elements[i].atomicNumber)/10) {
            printf("|\n");
            printf("  -----------------------------------------------------------------------------\n");
        }
    }
    printf("\n");
}

void displayMenu() {
    int choice;
    do {
        printf("Select an option:\n");
        printf("1. Play Quiz\n");
        printf("2. Exit\n");
        printf("Choice: ");
        scanf("%d", &choice);
        printf("\n");
        
        if (choice == 1) {
            playQuiz();
        }
        else if (choice != 2) {
            printf("Invalid choice. Please try again.\n\n");
        }
    } while (choice != 2);
}

void playQuiz() {
    Element elements[MAX_NUM_ELEMENTS];
    FILE* fptr;
    fptr = fopen("periodic_table.txt", "r");
    
    if (fptr == NULL) {
        printf("Error: Cannot open file.\n");
        exit(1);
    }
    
    int i = 0;
    char line[100];
    char* token;
    while (fgets(line, 100, fptr) != NULL) {
        token = strtok(line, ",");
        strcpy(elements[i].name, token);
        
        token = strtok(NULL, ",");
        strcpy(elements[i].symbol, token);
        
        token = strtok(NULL, ",");
        elements[i].atomicNumber = atoi(token);
        
        token = strtok(NULL, ",");
        elements[i].atomicWeight = atof(token);
        
        i++;
    }
    fclose(fptr);
    
    printf("\nWelcome to the Retro Periodic Table Quiz!\n\n");
    printf("Instructions:\n");
    printf("Guess the symbol of the element from its name or vice versa.\n");
    printf("Enter 'q' to quit the quiz.\n\n");
    
    int score = 0;
    char answer[MAX_ELEMENT_NAME_LENGTH];
    char guess[MAX_ELEMENT_NAME_LENGTH];
    srand(time(NULL));
    
    for (i = 0; i < 10; i++) {
        int index = rand() % MAX_NUM_ELEMENTS;
        printf("Question %d: ", i+1);
        if (rand() % 2) {
            printf("What is the symbol for %s?\n", elements[index].name);
            scanf("%s", guess);
            if (strcmp(guess, "q") == 0) {
                break;
            }
            for (int j = 0; guess[j]; j++) {
                guess[j] = toupper(guess[j]);
            }
            if (strcmp(guess, elements[index].symbol) == 0) {
                printf("Correct!\n");
                score++;
            }
            else {
                printf("Incorrect. The correct answer is %s.\n", elements[index].symbol);
            }
        }
        else {
            printf("What is the name of %s?\n", elements[index].symbol);
            scanf("%s", guess);
            if (strcmp(guess, "q") == 0) {
                break;
            }
            for (int j = 0; guess[j]; j++) {
                guess[j] = toupper(guess[j]);
            }
            if (strcmp(guess, elements[index].name) == 0) {
                printf("Correct!\n");
                score++;
            }
            else {
                printf("Incorrect. The correct answer is %s.\n", elements[index].name);
            }
        }
        printf("Current Score: %d\n\n", score);
    }
    printf("---------------\n");
    printf("Final Score: %d\n", score);
    printf("---------------\n\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 displayTable(void); // weak
__int64 displayMenu(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("Welcome to the Retro Periodic Table Quiz!\n\n");
  displayTable();
  displayMenu();
  return 0;
}
// 140001613: using guessed type __int64 displayTable(void);
// 1400019BC: using guessed type __int64 displayMenu(void);
// 140002030: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=191 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Benchmarking ; Style: Linus Torvalds
#include <stdio.h>
#include <time.h>

#define ARRAY_SIZE 100000

// Function to populate array with random integers
void populate_array(int *arr, int size)
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
}

// Function to print array
void print_array(int *arr, int size)
{
    printf("[");
    for (int i = 0; i < size; i++)
    {
        printf("%d", arr[i]);
        if (i < size - 1)
        {
            printf(",");
        }
    }
    printf("]\n");
}

// Function to bubble sort array
void bubble_sort(int *arr, int size)
{
    for (int i = 0; i < size - 1; i++)
    {
        for (int j = 0; j < size - i - 1; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// Function to measure time taken by a function to execute
double measure_time(void (*func)(int*, int), int *arr, int size)
{
    clock_t start, end;
    double time_taken;
    start = clock();
    func(arr, size);
    end = clock();
    time_taken = ((double) (end - start)) / CLOCKS_PER_SEC;
    return time_taken;
}

int main()
{
    int arr[ARRAY_SIZE];
    populate_array(arr, ARRAY_SIZE);
    printf("Unsorted Array: ");
    print_array(arr, ARRAY_SIZE);

    double bubble_sort_time = measure_time(bubble_sort, arr, ARRAY_SIZE);
    printf("Sorted Array: ");
    print_array(arr, ARRAY_SIZE);
    printf("Time taken by bubble sort: %f seconds\n", bubble_sort_time);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall populate_array(_QWORD, _QWORD); // weak
__int64 __fastcall print_array(_QWORD, _QWORD); // weak
__int64 __fastcall bubble_sort(); // weak
double __fastcall measure_time(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017E3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[400008]; // [rsp+20h] [rbp-60h] BYREF
  double v5; // [rsp+61AA8h] [rbp+61A28h]

  _main(argc, argv, envp);
  populate_array(v4, 100000i64);
  printf("Unsorted Array: ");
  print_array(v4, 100000i64);
  v5 = measure_time(bubble_sort, v4, 100000i64);
  printf("Sorted Array: ");
  print_array(v4, 100000i64);
  printf("Time taken by bubble sort: %f seconds\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall populate_array(_QWORD, _QWORD);
// 1400015FD: using guessed type __int64 __fastcall print_array(_QWORD, _QWORD);
// 140001687: using guessed type __int64 __fastcall bubble_sort();
// 14000177A: using guessed type double __fastcall measure_time(_QWORD, _QWORD, _QWORD);
// 140001960: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Linked list operations ; Style: sophisticated
#include<stdio.h>
#include<stdlib.h>

struct Node {
   int data;
   struct Node* next;
};

struct Node* head = NULL;

void insert_beginning(int new_data) {
   struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));
   new_node->data = new_data;
   new_node->next = head;
   head = new_node;
   printf("Element added successfully!\n");
}

void insert_end(int new_data) {
   struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));
   new_node->data = new_data;
   new_node->next = NULL;
   if(head == NULL) {
      head = new_node;
      printf("Element added successfully!\n");
      return;
   }
   struct Node* curr_node = head;
   while(curr_node->next != NULL) {
      curr_node = curr_node->next;
   }
   curr_node->next = new_node;
   printf("Element added successfully!\n");
}

void delete_beginning() {
   if(head == NULL) {
      printf("List is empty!\n");
      return;
   }
   struct Node* temp = head;
   head = head->next;
   free(temp);
   printf("Element deleted from beginning successfully!\n");
}

void delete_end() {
   if(head == NULL) {
      printf("List is empty!\n");
      return;
   }
   if(head->next == NULL) {
      free(head);
      head = NULL;
      printf("Element deleted from end successfully!\n");
      return;
   }
   struct Node* curr_node = head;
   while(curr_node->next->next != NULL) {
      curr_node = curr_node->next;
   }
   free(curr_node->next);
   curr_node->next = NULL;
   printf("Element deleted from end successfully!\n");
}

void display() {
   if(head == NULL) {
      printf("List is empty!\n");
      return;
   }
   struct Node* curr_node = head;
   printf("Elements in the list are: ");
   while(curr_node != NULL) {
      printf("%d ", curr_node->data);
      curr_node = curr_node->next;
   }
   printf("\n");
}

void main() {
   int choice, element;
   printf("1. Insert at beginning\n");
   printf("2. Insert at end\n");
   printf("3. Delete from beginning\n");
   printf("4. Delete from end\n");
   printf("5. Display\n");
   printf("6. Exit\n");
   while(1) {
      printf("Enter your choice: ");
      scanf("%d", &choice);
      switch(choice) {
         case 1:
            printf("Enter the element to be inserted at beginning: ");
            scanf("%d", &element);
            insert_beginning(element);
            break;
         case 2:
            printf("Enter the element to be inserted at end: ");
            scanf("%d", &element);
            insert_end(element);
            break;
         case 3:
            delete_beginning();
            break;
         case 4:
            delete_end();
            break;
         case 5:
            display();
            break;
         case 6:
            printf("Exiting program!");
            exit(0);
            break;
         default:
            printf("Invalid choice! Try again.\n");
      }
   }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall insert_beginning(_QWORD); // weak
__int64 __fastcall insert_end(_QWORD); // weak
__int64 delete_beginning(void); // weak
__int64 delete_end(void); // weak
__int64 display(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001876) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-8h] BYREF
  int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("1. Insert at beginning\n");
  printf("2. Insert at end\n");
  printf("3. Delete from beginning\n");
  printf("4. Delete from end\n");
  printf("5. Display\n");
  printf("6. Exit\n");
  while ( 1 )
  {
    printf("Enter your choice: ");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        printf("Enter the element to be inserted at beginning: ");
        scanf("%d", &v4);
        insert_beginning(v4);
        break;
      case 2:
        printf("Enter the element to be inserted at end: ");
        scanf("%d", &v4);
        insert_end(v4);
        break;
      case 3:
        delete_beginning();
        break;
      case 4:
        delete_end();
        break;
      case 5:
        display();
        break;
      case 6:
        printf("Exiting program!");
        exit(0);
      default:
        printf("Invalid choice! Try again.\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 __fastcall insert_beginning(_QWORD);
// 140001634: using guessed type __int64 __fastcall insert_end(_QWORD);
// 1400016D2: using guessed type __int64 delete_beginning(void);
// 140001736: using guessed type __int64 delete_end(void);
// 1400017F5: using guessed type __int64 display(void);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Checkers Game ; Style: detailed
/* A simple Checkers Game in C language */
#include <stdio.h>

#define SIZE 8 // board size
#define EMPTY '.' // empty cell
#define BLACK 'B' // black piece
#define WHITE 'W' // white piece
#define INVALID -1 // invalid move

/* Function prototypes */
void initialize_board(char board[][SIZE]);
void print_board(const char board[][SIZE]);
int make_move(char board[][SIZE], int i, int j, int x, int y);
int valid_move(int player, const char board[][SIZE], int i, int j, int x, int y);
int player_has_moves(int player, const char board[][SIZE]);

/* Main function */
int main()
{
    char board[SIZE][SIZE];
    int i, j, x, y, player, winner;
    
    // initialize the board
    initialize_board(board);
    
    // print the initial board
    print_board(board);
    
    // main game loop
    player = BLACK; // black starts
    winner = 0; // no one wins yet
    while (1)
    {
        // get player move
        printf("\nPlayer %c: enter move (x1 y1 x2 y2): ", player);
        scanf("%d %d %d %d", &i, &j, &x, &y);
        
        // check if move is valid
        if (!valid_move(player, board, i, j, x, y))
        {
            printf("Invalid move! Try again.\n");
            continue;
        }
        
        // make the move
        if (make_move(board, i, j, x, y) == INVALID)
        {
            printf("Invalid move! Try again.\n");
            continue;
        }
        
        // print the updated board
        print_board(board);
        
        // check for winner
        if (!player_has_moves(BLACK, board))
        {
            printf("White wins!\n");
            winner = WHITE;
            break;
        }
        if (!player_has_moves(WHITE, board))
        {
            printf("Black wins!\n");
            winner = BLACK;
            break;
        }
        
        // switch player
        player = (player == BLACK) ? WHITE : BLACK;
    }
    
    // print the final board
    print_board(board);
    
    return 0;
}

/* Function definitions */

/* Initializes the board with pieces */
void initialize_board(char board[][SIZE])
{
    int i, j;
    for (i = 0; i < SIZE; i++)
    {
        for (j = 0; j < SIZE; j++)
        {
            if ((i + j) % 2 == 0 && i < 3) // black pieces
            {
                board[i][j] = BLACK;
            }
            else if ((i + j) % 2 == 0 && i > SIZE - 4) // white pieces
            {
                board[i][j] = WHITE;
            }
            else // empty squares
            {
                board[i][j] = EMPTY;
            }
        }
    }
}

/* Prints the board */
void print_board(const char board[][SIZE])
{
    int i, j;
    printf("\n   0 1 2 3 4 5 6 7\n");
    for (i = 0; i < SIZE; i++)
    {
        printf("%d  ", i);
        for (j = 0; j < SIZE; j++)
        {
            printf("%c ", board[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

/* Makes a move on the board */
int make_move(char board[][SIZE], int i, int j, int x, int y)
{
    // check if move is valid
    if (!valid_move(board[i][j], board, i, j, x, y))
    {
        return INVALID;
    }
    
    // make the move
    board[x][y] = board[i][j];
    board[i][j] = EMPTY;
    if (x == 0 && board[x][y] == WHITE) // white piece reaches the end
    {
        board[x][y] = 'w';
    }
    else if (x == SIZE - 1 && board[x][y] == BLACK) // black piece reaches the end
    {
        board[x][y] = 'b';
    }
    
    // remove captured piece
    if (i - x == 2 && j - y == 2) // capture to the left
    {
        board[i-1][j-1] = EMPTY;
    }
    else if (i - x == 2 && j - y == -2) // capture to the right
    {
        board[i-1][j+1] = EMPTY;
    }
    else if (i - x == -2 && j - y == 2) // capture to the left (king)
    {
        board[i+1][j-1] = EMPTY;
    }
    else if (i - x == -2 && j - y == -2) // capture to the right (king)
    {
        board[i+1][j+1] = EMPTY;
    }
    
    return 0;
}

/* Checks if a move is valid */
int valid_move(int player, const char board[][SIZE], int i, int j, int x, int y)
{
    int dx, dy;
    
    // check if initial position is valid
    if (i < 0 || i >= SIZE || j < 0 || j >= SIZE || board[i][j] != player)
    {
        return 0;
    }
    
    // check if final position is empty
    if (x < 0 || x >= SIZE || y < 0 || y >= SIZE || board[x][y] != EMPTY)
    {
        return 0;
    }
    
    // calculate the direction of the move
    dx = x - i;
    dy = y - j;
    
    // check if move is valid for a regular piece
    if (player == BLACK && dx == 1 && (dy == 1 || dy == -1))
    {
        return 1;
    }
    if (player == WHITE && dx == -1 && (dy == 1 || dy == -1))
    {
        return 1;
    }
    
    // check if move is valid for a king piece
    if (board[i][j] == 'b' || board[i][j] == 'w')
    {
        if (dx == 1 || dx == -1)
        {
            if (dy == 1 || dy == -1)
            {
                return 1;
            }
            if (dy == 2) // capture to the left
            {
                if ((j > y) && (board[i+1][j-1] == WHITE || board[i+1][j-1] == 'w'))
                {
                    return 1;
                }
            }
            if (dy == -2) // capture to the right
            {
                if ((j < y) && (board[i+1][j+1] == WHITE || board[i+1][j+1] == 'w'))
                {
                    return 1;
                }
            }
        }
        if (dx == 2 || dx == -2) // capture
        {
            if (dy == 2) // to the left
            {
                if ((j > y) && (board[i-1][j-1] == WHITE || board[i-1][j-1] == 'w'))
                {
                    return 1;
                }
            }
            if (dy == -2) // to the right
            {
                if ((j < y) && (board[i-1][j+1] == WHITE || board[i-1][j+1] == 'w'))
                {
                    return 1;
                }
            }
        }
    }
    
    return 0;
}

/* Checks if a player has any valid moves */
int player_has_moves(int player, const char board[][SIZE])
{
    int i, j, x, y;
    
    for (i = 0; i < SIZE; i++)
    {
        for (j = 0; j < SIZE; j++)
        {
            if (board[i][j] == player || board[i][j] == 'b' || board[i][j] == 'w')
            {
                for (x = 0; x < SIZE; x++)
                {
                    for (y = 0; y < SIZE; y++)
                    {
                        if (valid_move(player, board, i, j, x, y))
                        {
                            return 1;
                        }
                    }
                }
            }
        }
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall initialize_board(_QWORD); // weak
__int64 __fastcall print_board(_QWORD); // weak
__int64 __fastcall make_move(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
__int64 __fastcall valid_move(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
__int64 __fastcall player_has_moves(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+30h] [rbp-60h] BYREF
  int v6; // [rsp+34h] [rbp-5Ch] BYREF
  int v7; // [rsp+38h] [rbp-58h] BYREF
  int v8; // [rsp+3Ch] [rbp-54h] BYREF
  char v9[72]; // [rsp+40h] [rbp-50h] BYREF
  int v10; // [rsp+88h] [rbp-8h]
  unsigned int v11; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  initialize_board(v9);
  print_board(v9);
  v11 = 66;
  v10 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      printf("\nPlayer %c: enter move (x1 y1 x2 y2): ", v11);
      scanf("%d %d %d %d", &v8, &v7, &v6, &v5);
      if ( (unsigned int)valid_move(v11, (unsigned int)v9, v8, v7, v6, v5) )
      {
        if ( (unsigned int)make_move((unsigned int)v9, v8, v7, v6, v5) != -1 )
          break;
      }
      printf("Invalid move! Try again.\n");
    }
    print_board(v9);
    if ( !(unsigned int)player_has_moves(66i64, v9) )
    {
      printf("White wins!\n");
      v10 = 87;
      goto LABEL_13;
    }
    if ( !(unsigned int)player_has_moves(87i64, v9) )
      break;
    if ( v11 == 66 )
      v3 = 87;
    else
      v3 = 66;
    v11 = v3;
  }
  printf("Black wins!\n");
  v10 = 66;
LABEL_13:
  print_board(v9);
  return 0;
}
// 140001768: using guessed type __int64 __fastcall initialize_board(_QWORD);
// 140001835: using guessed type __int64 __fastcall print_board(_QWORD);
// 1400018E0: using guessed type __int64 __fastcall make_move(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001B1F: using guessed type __int64 __fastcall valid_move(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001E27: using guessed type __int64 __fastcall player_has_moves(_QWORD, _QWORD);
// 140001FF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Color Code Converter ; Style: careful
#include <stdio.h>
#include <stdlib.h>

void rgb_to_hex(int r, int g, int b);
void hex_to_rgb(char *hex);

int main()
{
    int choice;

    printf("1. Convert RGB to HEX\n");
    printf("2. Convert HEX to RGB\n");
    printf("Choose your option: ");
    scanf("%d", &choice);

    if (choice == 1) {
        int r, g, b;
        printf("Enter the RGB values (0-255): ");
        scanf("%d %d %d", &r, &g, &b);
        rgb_to_hex(r, g, b);
    } else if (choice == 2) {
        char hex[7];
        printf("Enter the HEX value (example: FF00FF): ");
        scanf("%s", hex);
        hex_to_rgb(hex);
    } else {
        printf("Invalid choice!\n");
        exit(1);
    }

    return 0;
}

void rgb_to_hex(int r, int g, int b)
{
    char hex[7];
    sprintf(hex, "%02X%02X%02X", r, g, b);

    printf("HEX value: #%s\n", hex);
}

void hex_to_rgb(char *hex)
{
    if (hex[0] == '#') hex++;

    int r, g, b;
    sscanf(hex, "%02x%02x%02x", &r, &g, &b);

    printf("RGB values: %d %d %d\n", r, g, b);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall rgb_to_hex(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall hex_to_rgb(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001668) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[7]; // [rsp+29h] [rbp-17h] BYREF
  unsigned int v5; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v6; // [rsp+34h] [rbp-Ch] BYREF
  unsigned int v7; // [rsp+38h] [rbp-8h] BYREF
  int v8; // [rsp+3Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("1. Convert RGB to HEX\n");
  printf("2. Convert HEX to RGB\n");
  printf("Choose your option: ");
  scanf("%d", &v8);
  if ( v8 == 1 )
  {
    printf("Enter the RGB values (0-255): ");
    scanf("%d %d %d", &v7, &v6, &v5);
    rgb_to_hex(v7, v6, v5);
  }
  else
  {
    if ( v8 != 2 )
    {
      printf("Invalid choice!\n");
      exit(1);
    }
    printf("Enter the HEX value (example: FF00FF): ");
    scanf("%s", v4);
    hex_to_rgb(v4);
  }
  return 0;
}
// 140001767: using guessed type __int64 __fastcall rgb_to_hex(_QWORD, _QWORD, _QWORD);
// 1400017BA: using guessed type __int64 __fastcall hex_to_rgb(_QWORD);
// 1400018E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: calm
/*
  C Percolation Simulator
  This program simulates percolation in a given system of cells.
  Each cell has an equal probability of being opened or closed.
  The program keeps on trying to open cells until the system percolates.

  Author: [Your Name]
*/

// Essential header files

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to initialize a given N x N system

void initialize(int *system, int n) {
  srand(time(0)); // to get random number sequence every time

  int i, j;

  for(i = 0; i < n; i++) {
    for(j = 0; j < n; j++) {
      *(system + i*n + j) = rand() % 2;  // random cell value (0 or 1)
    }
  }
}

// Function to print the system

void print_system(int *system, int n) {
  int i, j;

  for(i = 0; i < n; i++) {
    for(j = 0; j < n; j++) {
      printf("%d ", *(system + i*n + j));
    }
    printf("\n");
  }
}

// Function to check if the system percolates

int percolates(int *system, int n) {
  int i, j;

  // Create two dummy nodes, top and bottom, and check if they are connected
  int top = n*n, bottom = n*n + 1;

  // Create disjoint set and initialize with dummy nodes
  int *set = (int *) malloc((n*n + 2) * sizeof(int));

  for(i = 0; i < n*n; i++) {
    *(set + i) = i;
  }

  *(set + top) = top;
  *(set + bottom) = bottom;

  for(i = 0; i < n; i++) {
    if(*system == 0) {
      *(set + i) = top;
    }
    if(*(system + (n-1)*n + i) == 0) {
      *(set + (n-1)*n + i) = bottom;
    }
  }

  // Union-find algorithm to keep on connecting adjacent cells
  for(i = 0; i < n; i++) {
    for(j = 0; j < n; j++) {
      if(*(system + i*n + j) == 0) { // connect adjacent open cells
        if(i > 0 && *(system + (i-1)*n + j) == 0) { // connect top cell
          int p = i*n + j;
          int q = (i-1)*n + j;
          while(p != *(set + p)) {
            *(set + p) = *(set + *(set + p)); // path compression
            p = *(set + p);
          }
          while(q != *(set + q)) {
            *(set + q) = *(set + *(set + q)); // path compression
            q = *(set + q);
          }
          if(p != q) { // connect
            *(set + p) = q;
          }
        }
        if(j > 0 && *(system + i*n + j-1) == 0) { // connect left cell
          int p = i*n + j;
          int q = i*n + j-1;
          while(p != *(set + p)) {
            *(set + p) = *(set + *(set + p)); // path compression
            p = *(set + p);
          }
          while(q != *(set + q)) {
            *(set + q) = *(set + *(set + q)); // path compression
            q = *(set + q);
          }
          if(p != q) { // connect
            *(set + p) = q;
          }
        }
        if(i < n-1 && *(system + (i+1)*n + j) == 0) { // connect bottom cell
          int p = i*n + j;
          int q = (i+1)*n + j;
          while(p != *(set + p)) {
            *(set + p) = *(set + *(set + p)); // path compression
            p = *(set + p);
          }
          while(q != *(set + q)) {
            *(set + q) = *(set + *(set + q)); // path compression
            q = *(set + q);
          }
          if(p != q) { // connect
            *(set + p) = q;
          }
        }
        if(j < n-1 && *(system + i*n + j+1) == 0) { // connect right cell
          int p = i*n + j;
          int q = i*n + j+1;
          while(p != *(set + p)) {
            *(set + p) = *(set + *(set + p)); // path compression
            p = *(set + p);
          }
          while(q != *(set + q)) {
            *(set + q) = *(set + *(set + q)); // path compression
            q = *(set + q);
          }
          if(p != q) { // connect
            *(set + p) = q;
          }
        }
      }
    }
  }

  // Check if top and bottom nodes are connected
  int perc = 0;

  while(top != *(set + top)) {
    *(set + top) = *(set + *(set + top));
    top = *(set + top);
  }

  while(bottom != *(set + bottom)) {
    *(set + bottom) = *(set + *(set + bottom));
    bottom = *(set + bottom);
  }

  if(top == bottom) { // percolates
    perc = 1;
  }

  free(set);
  return perc;
}

// Main driver code

int main() {
  int n = 5; // size of the system
  int *system = (int *) malloc(n * n * sizeof(int));

  initialize(system, n);

  printf("Initial system:\n");
  print_system(system, n);

  while(!percolates(system, n)) {
    initialize(system, n); // keep on trying
  }

  printf("Percolated system:\n");
  print_system(system, n);

  free(system);
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall initialize(_QWORD, _QWORD); // weak
__int64 __fastcall print_system(_QWORD, _QWORD); // weak
__int64 __fastcall percolates(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (0000000140001F19) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *Block; // [rsp+20h] [rbp-10h]

  _main(argc, argv, envp);
  Block = malloc(0x64ui64);
  initialize(Block, 5i64);
  printf("Initial system:\n");
  print_system(Block, 5i64);
  while ( !(unsigned int)percolates(Block, 5i64) )
    initialize(Block, 5i64);
  printf("Percolated system:\n");
  print_system(Block, 5i64);
  free(Block);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall initialize(_QWORD, _QWORD);
// 14000163A: using guessed type __int64 __fastcall print_system(_QWORD, _QWORD);
// 1400016BE: using guessed type __int64 __fastcall percolates(_QWORD, _QWORD);
// 140002080: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct item {
    char name[50];
    int quantity;
    float price;
};

struct warehouse {
    char name[50];
    struct item inventory[100];
    int num_items;
};

int main() {
    struct warehouse warehouse1;
    strcpy(warehouse1.name, "Warehouse 1");
    warehouse1.num_items = 0;

    struct item item1;
    strcpy(item1.name, "Item 1");
    item1.quantity = 50;
    item1.price = 10.99;
    warehouse1.inventory[0] = item1;
    warehouse1.num_items++;

    printf("Welcome to %s\n", warehouse1.name);
    printf("We currently have %d items in stock:\n", warehouse1.num_items);

    for (int i = 0; i < warehouse1.num_items; i++) {
        printf("%d) %s\n", i+1, warehouse1.inventory[i].name);
        printf("   Quantity: %d\n", warehouse1.inventory[i].quantity);
        printf("   Price: $%.2f\n", warehouse1.inventory[i].price);
    }

    struct item item2;
    strcpy(item2.name, "Item 2");
    item2.quantity = 100;
    item2.price = 5.99;
    warehouse1.inventory[1] = item2;
    warehouse1.num_items++;

    printf("\nWe just added %s to our inventory.\n", item2.name);
    printf("We now have %d items in stock:\n", warehouse1.num_items);

    for (int i = 0; i < warehouse1.num_items; i++) {
        printf("%d) %s\n", i+1, warehouse1.inventory[i].name);
        printf("   Quantity: %d\n", warehouse1.inventory[i].quantity);
        printf("   Price: $%.2f\n", warehouse1.inventory[i].price);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[6]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5; // [rsp+50h] [rbp-30h]
  int v6; // [rsp+58h] [rbp-28h]
  __int64 v7[4]; // [rsp+60h] [rbp-20h] BYREF
  __int64 v8[2]; // [rsp+80h] [rbp+0h] BYREF
  __int64 v9; // [rsp+90h] [rbp+10h]
  int v10; // [rsp+98h] [rbp+18h]
  char v11[52]; // [rsp+A0h] [rbp+20h] BYREF
  __int64 v12; // [rsp+D4h] [rbp+54h]
  __int64 v13; // [rsp+DCh] [rbp+5Ch]
  __int64 v14; // [rsp+E4h] [rbp+64h]
  __int64 v15; // [rsp+ECh] [rbp+6Ch]
  __int64 v16; // [rsp+F4h] [rbp+74h]
  __int64 v17; // [rsp+FCh] [rbp+7Ch]
  __int64 v18; // [rsp+104h] [rbp+84h]
  int v19; // [rsp+10Ch] [rbp+8Ch]
  __int64 v20; // [rsp+110h] [rbp+90h]
  __int64 v21; // [rsp+118h] [rbp+98h]
  __int64 v22; // [rsp+120h] [rbp+A0h]
  __int64 v23; // [rsp+128h] [rbp+A8h]
  __int64 v24; // [rsp+130h] [rbp+B0h]
  __int64 v25; // [rsp+138h] [rbp+B8h]
  __int64 v26; // [rsp+140h] [rbp+C0h]
  int v27; // [rsp+148h] [rbp+C8h]
  unsigned int v28; // [rsp+1844h] [rbp+17C4h]
  int j; // [rsp+1848h] [rbp+17C8h]
  int i; // [rsp+184Ch] [rbp+17CCh]

  _main(argc, argv, envp);
  strcpy(v11, "Warehouse 1");
  strcpy((char *)v7, "Item 1");
  HIDWORD(v9) = 50;
  v10 = 1093654282;
  v12 = v7[0];
  v13 = v7[1];
  v14 = v7[2];
  v15 = v7[3];
  v16 = v8[0];
  v17 = v8[1];
  v18 = v9;
  v19 = 1093654282;
  v28 = 1;
  printf("Welcome to %s\n", v11);
  printf("We currently have %d items in stock:\n", v28);
  for ( i = 0; i < (int)v28; ++i )
  {
    printf("%d) %s\n", (unsigned int)(i + 1), &v11[60 * i + 52]);
    printf("   Quantity: %d\n", *((unsigned int *)&v8[17] + 15 * i));
    printf("   Price: $%.2f\n", *((float *)&v8[17] + 15 * i + 1));
  }
  strcpy((char *)v4, "Item 2");
  HIDWORD(v5) = 100;
  v6 = 1086303764;
  v20 = v4[0];
  v21 = v4[1];
  v22 = v4[2];
  v23 = v4[3];
  v24 = v4[4];
  v25 = v4[5];
  v26 = v5;
  v27 = 1086303764;
  ++v28;
  printf("\nWe just added %s to our inventory.\n", (const char *)v4);
  printf("We now have %d items in stock:\n", v28);
  for ( j = 0; j < (int)v28; ++j )
  {
    printf("%d) %s\n", (unsigned int)(j + 1), &v11[60 * j + 52]);
    printf("   Quantity: %d\n", *((unsigned int *)&v8[17] + 15 * j));
    printf("   Price: $%.2f\n", *((float *)&v8[17] + 15 * j + 1));
  }
  return 0;
}
// 1400019E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sudoku solver ; Style: curious
#include <stdio.h>

// Function to check if placing a value in a particular position is valid
int is_valid(int puzzle[9][9], int row, int col, int value) {
    // Check if value exists in row
    for (int i = 0; i < 9; i++) {
        if (puzzle[row][i] == value) {
            return 0;
        }
    }
    // Check if value exists in column
    for (int i = 0; i < 9; i++) {
        if (puzzle[i][col] == value) {
            return 0;
        }
    }
    // Check if value exists in 3x3 box
    int box_row = row - (row % 3);
    int box_col = col - (col % 3);
    for (int i = box_row; i < box_row + 3; i++) {
        for (int j = box_col; j < box_col + 3; j++) {
            if (puzzle[i][j] == value) {
                return 0;
            }
        }
    }
    // If value passes all checks, return 1
    return 1;
}

// Function to solve the puzzle
int solve(int puzzle[9][9], int row, int col) {
    // Check if we have reached the end of the puzzle
    if (row == 9) {
        return 1;
    }
    // Check if we have reached the end of a row
    if (col == 9) {
        return solve(puzzle, row+1, 0);
    }
    // Check if the current spot is already filled
    if (puzzle[row][col] != 0) {
        return solve(puzzle, row, col+1);
    }
    // Try placing values in the current spot
    for (int i = 1; i <= 9; i++) {
        if (is_valid(puzzle, row, col, i)) {
            puzzle[row][col] = i;
            if (solve(puzzle, row, col+1)) {
                return 1;
            }
            puzzle[row][col] = 0;
        }
    }
    // If no values work, return 0
    return 0;
}

int main() {
    // Initialize puzzle
    int puzzle[9][9] = {
        {0, 0, 0, 0, 3, 0, 0, 6, 0},
        {0, 0, 7, 0, 0, 0, 0, 4, 8},
        {0, 0, 0, 8, 0, 4, 0, 0, 0},
        {0, 0, 5, 0, 7, 0, 0, 8, 0},
        {0, 0, 4, 0, 2, 0, 7, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 0, 5},
        {0, 9, 0, 0, 0, 0, 5, 0, 3},
        {4, 3, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 7, 0, 0, 0}
    };
    // Print original puzzle
    printf("Original Puzzle:\n");
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            printf("%d ", puzzle[i][j]);
        }
        printf("\n");
    }
    // Solve the puzzle
    solve(puzzle, 0, 0);
    // Print solved puzzle
    printf("Solved Puzzle:\n");
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            printf("%d ", puzzle[i][j]);
        }
        printf("\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall solve(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (0000000140001845) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[84]; // [rsp+20h] [rbp-60h] BYREF
  int m; // [rsp+170h] [rbp+F0h]
  int k; // [rsp+174h] [rbp+F4h]
  int j; // [rsp+178h] [rbp+F8h]
  int i; // [rsp+17Ch] [rbp+FCh]

  _main(argc, argv, envp);
  qmemcpy(v4, &unk_14000A020, 0x144ui64);
  printf("Original Puzzle:\n");
  for ( i = 0; i <= 8; ++i )
  {
    for ( j = 0; j <= 8; ++j )
      printf("%d ", (unsigned int)v4[9 * i + j]);
    printf("\n");
  }
  solve(v4, 0i64, 0i64);
  printf("Solved Puzzle:\n");
  for ( k = 0; k <= 8; ++k )
  {
    for ( m = 0; m <= 8; ++m )
      printf("%d ", (unsigned int)v4[9 * k + m]);
    printf("\n");
  }
  return 0;
}
// 140001701: using guessed type __int64 __fastcall solve(_QWORD, _QWORD, _QWORD);
// 140001A70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001845: using guessed type int var_170[84];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Alien Language Translator ; Style: Alan Touring
#include <stdio.h>
#include <string.h>

// Function to translate an input C-string in Alien language
void translateAL(char* str) {
    // Mapping of alien letters with equivalent English letters
    char letters[27] = "#ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    char englishLetters[27] = " !ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    
    // Check if input string contains a valid sequence of Alien words
    for (int i=0; i<strlen(str); i++) {
        // Get current letter and its position in the mapping array
        char current = str[i];
        int index = -1;
        for (int j=0; j<27; j++) {
            if (letters[j] == current) {
                index = j;
                break;
            }
        }
        
        // If current letter is not found in the mapping array, break the loop
        if (index == -1) {
            printf("\nInvalid Alien word found! Aborting translation...\n");
            return;
        }
    }
    
    // Translate each Alien word to English
    int wordStart = 0;
    int wordEnd = 0;
    for (int i=0; i<strlen(str); i++) {
        // Get current letter and its position in the mapping array
        char current = str[i];
        int index = -1;
        for (int j=0; j<27; j++) {
            if (letters[j] == current) {
                index = j;
                break;
            }
        }
        
        // If current letter is not found in the mapping array, translate the current word
        if (index == -1) {
            int wordLength = wordEnd - wordStart;
            char word[wordLength + 1];
            strncpy(word, &str[wordStart], wordLength);
            word[wordLength] = '\0';
            
            // Translate the current word from Alien to English
            for (int j=0; j<strlen(word); j++) {
                char letter = word[j];
                int letterIndex = -1;
                for (int k=0; k<27; k++) {
                    if (letters[k] == letter) {
                        letterIndex = k;
                        break;
                    }
                }
                
                printf("%c", englishLetters[letterIndex]);
            }
            
            // Reset the word start and end indices
            wordStart = i + 1;
            wordEnd = i + 1;
            
            // Print a space after each word
            printf(" ");
        }
        else {
            wordEnd++;
        }
    }
}

// Driver code
int main() {
    char alienStr[] = "#BACAA#DAB";
    
    printf("Alien string: %s\n", alienStr);
    printf("Translated string: ");
    translateAL(alienStr);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall translateAL(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001869) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char varB[19]; // [rsp+25h] [rbp-Bh] BYREF

  _main(argc, argv, envp);
  strcpy(varB, "#BACAA#DAB");
  printf("Alien string: %s\n", varB);
  printf("Translated string: ");
  translateAL(varB);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall translateAL(_QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database simulation ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int id;
    char name[20];
    int age;
    float salary;
} Employee;

int main() {
    Employee employees[50];
    int numEmployees = 0;
    char input[100];
    int inputLength;
    int id;
    char name[20];
    char ageString[3];
    int age;
    char salaryString[10];
    float salary;

    while (1) {
        printf("1: Add an employee\n");
        printf("2: Search for an employee\n");
        printf("3: Display all employees\n");
        printf("4: Quit\n");
        printf("Enter your choice: ");

        fgets(input, 100, stdin);
        inputLength = strlen(input);
        if (input[inputLength-1] == '\n') {
            input[inputLength-1] = '\0';
        }

        switch (atoi(input)) {
            case 1:
                printf("Enter employee id: ");
                fgets(input, 100, stdin);
                id = atoi(input);

                printf("Enter employee name: ");
                fgets(name, 20, stdin);
                name[strlen(name)-1] = '\0';

                printf("Enter employee age: ");
                fgets(ageString, 3, stdin);
                age = atoi(ageString);

                printf("Enter employee salary: ");
                fgets(salaryString, 10, stdin);
                salaryString[strlen(salaryString)-1] = '\0';
                salary = atof(salaryString);

                Employee newEmployee = {.id=id, .age=age, .salary=salary};
                strcpy(newEmployee.name, name);

                employees[numEmployees] = newEmployee;
                numEmployees++;

                printf("Employee added successfully.\n");
                break;
            case 2:
                printf("Enter employee id: ");
                fgets(input, 100, stdin);
                id = atoi(input);

                for (int i = 0; i < numEmployees; i++) {
                    if (employees[i].id == id) {
                        printf("ID: %d\n", employees[i].id);
                        printf("Name: %s\n", employees[i].name);
                        printf("Age: %d\n", employees[i].age);
                        printf("Salary: %.2f\n", employees[i].salary);
                    }
                }
                break;
            case 3:
                for (int i = 0; i < numEmployees; i++) {
                    printf("ID: %d\n", employees[i].id);
                    printf("Name: %s\n", employees[i].name);
                    printf("Age: %d\n", employees[i].age);
                    printf("Salary: %.2f\n", employees[i].salary);
                    printf("\n");
                }
                break;
            case 4:
                printf("Goodbye!\n");
                exit(0);
            default:
                printf("Invalid choice. Try again.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
// int __cdecl atoi(const char *String);
// double __cdecl atof(const char *String);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v4; // eax
  FILE *v5; // rax
  FILE *v6; // rax
  FILE *v7; // rax
  FILE *v8; // rax
  unsigned int v9; // xmm0_4
  _QWORD *v10; // rcx
  __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  FILE *v13; // rax
  __int64 v14; // [rsp+20h] [rbp-60h] BYREF
  __int64 v15; // [rsp+28h] [rbp-58h]
  __int64 v16; // [rsp+30h] [rbp-50h]
  unsigned __int64 v17; // [rsp+38h] [rbp-48h]
  char v18[10]; // [rsp+43h] [rbp-3Dh] BYREF
  char String[3]; // [rsp+4Dh] [rbp-33h] BYREF
  char Str[32]; // [rsp+50h] [rbp-30h] BYREF
  char Buffer[16]; // [rsp+70h] [rbp-10h] BYREF
  _DWORD v22[426]; // [rsp+80h] [rbp+0h] BYREF
  int v23; // [rsp+728h] [rbp+6A8h]
  unsigned int v24; // [rsp+72Ch] [rbp+6ACh]
  int v25; // [rsp+730h] [rbp+6B0h]
  int i; // [rsp+734h] [rbp+6B4h]
  int j; // [rsp+738h] [rbp+6B8h]
  int v28; // [rsp+73Ch] [rbp+6BCh]

  _main(argc, argv, envp);
  v28 = 0;
  while ( 1 )
  {
    printf("1: Add an employee\n");
    printf("2: Search for an employee\n");
    printf("3: Display all employees\n");
    printf("4: Quit\n");
    printf("Enter your choice: ");
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 100, v3);
    v25 = strlen(Buffer);
    if ( Buffer[v25 - 1] == 10 )
      Buffer[v25 - 1] = 0;
    v4 = atoi(Buffer);
    if ( v4 == 4 )
    {
      printf("Goodbye!\n");
      exit(0);
    }
    if ( v4 > 4 )
    {
LABEL_22:
      printf("Invalid choice. Try again.\n");
    }
    else
    {
      switch ( v4 )
      {
        case 3:
          for ( i = 0; i < v28; ++i )
          {
            printf("ID: %d\n", (unsigned int)v22[8 * i + 24]);
            printf("Name: %s\n", (const char *)&v22[8 * i + 25]);
            printf("Age: %d\n", (unsigned int)v22[8 * i + 30]);
            printf("Salary: %.2f\n", *(float *)&v22[8 * i + 31]);
            printf("\n");
          }
          break;
        case 1:
          printf("Enter employee id: ");
          v5 = __acrt_iob_func(0);
          fgets(Buffer, 100, v5);
          v24 = atoi(Buffer);
          printf("Enter employee name: ");
          v6 = __acrt_iob_func(0);
          fgets(Str, 20, v6);
          Str[strlen(Str) - 1] = 0;
          printf("Enter employee age: ");
          v7 = __acrt_iob_func(0);
          fgets(String, 3, v7);
          v23 = atoi(String);
          printf("Enter employee salary: ");
          v8 = __acrt_iob_func(0);
          fgets(v18, 10, v8);
          v18[strlen(v18) - 1] = 0;
          *(float *)&v9 = atof(v18);
          v22[425] = v9;
          v15 = 0i64;
          v16 = 0i64;
          v14 = v24;
          v17 = __PAIR64__(v9, v23);
          strcpy((char *)&v14 + 4, Str);
          v10 = &v22[8 * v28 + 24];
          v11 = v15;
          *v10 = v14;
          v10[1] = v11;
          v12 = v17;
          v10[2] = v16;
          v10[3] = v12;
          ++v28;
          printf("Employee added successfully.\n");
          break;
        case 2:
          printf("Enter employee id: ");
          v13 = __acrt_iob_func(0);
          fgets(Buffer, 100, v13);
          v24 = atoi(Buffer);
          for ( j = 0; j < v28; ++j )
          {
            if ( v24 == v22[8 * j + 24] )
            {
              printf("ID: %d\n", (unsigned int)v22[8 * j + 24]);
              printf("Name: %s\n", (const char *)&v22[8 * j + 25]);
              printf("Age: %d\n", (unsigned int)v22[8 * j + 30]);
              printf("Salary: %.2f\n", *(float *)&v22[8 * j + 31]);
            }
          }
          break;
        default:
          goto LABEL_22;
      }
    }
  }
}
// 140001680: conditional instruction was optimized away because eax.4<3
// 140001BD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[16];
// 140001591: using guessed type char Str[32];
// 140001591: using guessed type char var_6FD[10];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Natural Language Date Converter ; Style: romantic
#include <stdio.h>
#include <string.h>

int main() {
    char date[15];
    int day, month, year, leapYear = 0;

    printf("My love, please enter a date in natural language format (e.g. January 1st, 2022): ");
    fgets(date, sizeof(date), stdin);
    
    // Remove comma and convert month to lowercase
    int len = strlen(date);
    date[len-2] = '\0';
    date[0] = tolower(date[0]);
    for(int i=1; i<len-3; i++) {
        if(date[i] == ' ') {
            date[i+1] = tolower(date[i+1]);
        }
    }

    // Convert month to number
    if(strcmp(date, "january") == 0) {
        month = 1;
    } else if(strcmp(date, "february") == 0) {
        month = 2;
    } else if(strcmp(date, "march") == 0) {
        month = 3;
    } else if(strcmp(date, "april") == 0) {
        month = 4;
    } else if(strcmp(date, "may") == 0) {
        month = 5;
    } else if(strcmp(date, "june") == 0) {
        month = 6;
    } else if(strcmp(date, "july") == 0) {
        month = 7;
    } else if(strcmp(date, "august") == 0) {
        month = 8;
    } else if(strcmp(date, "september") == 0) {
        month = 9;
    } else if(strcmp(date, "october") == 0) {
        month = 10;
    } else if(strcmp(date, "november") == 0) {
        month = 11;
    } else if(strcmp(date, "december") == 0) {
        month = 12;
    } else {
        printf("My love, I'm sorry but that's not a valid date. Please try again.\n");
        return 0;
    }

    printf("My love, what year is it? ");
    scanf("%d", &year);

    // Check if it's a leap year
    if(year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {
        leapYear = 1;
    }
   
    printf("My love, what day is it? ");
    scanf("%d", &day);
    
    // Check if day is valid
    if(day < 1 || day > 31) {
        printf("My love, I'm sorry but that's not a valid day. Please try again.\n");
        return 0;
    }
    
    // Check if day is valid for the month
    if(month == 2) {
        if(leapYear == 1) {
            if(day > 29) {
                printf("My love, I'm sorry but February only has 29 days this year. Please try again.\n");
                return 0;
            }
        } else {
            if(day > 28) {
                printf("My love, I'm sorry but February only has 28 days this year. Please try again.\n");
                return 0;
            }
        }
    } else if((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {
        printf("My love, I'm sorry but that month only has 30 days. Please try again.\n");
        return 0;
    }
    
    printf("My love, the date you entered is: %d/%d/%d\n", month, day, year);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl tolower(int C);
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v5; // [rsp+28h] [rbp-28h] BYREF
  int v6; // [rsp+2Ch] [rbp-24h] BYREF
  char Buffer[15]; // [rsp+31h] [rbp-1Fh] BYREF
  int v8; // [rsp+40h] [rbp-10h]
  int i; // [rsp+44h] [rbp-Ch]
  int v10; // [rsp+48h] [rbp-8h]
  unsigned int v11; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 0;
  printf("My love, please enter a date in natural language format (e.g. January 1st, 2022): ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 15, v3);
  v8 = strlen(Buffer);
  Buffer[v8 - 2] = 0;
  Buffer[0] = tolower(Buffer[0]);
  for ( i = 1; i < v8 - 3; ++i )
  {
    if ( Buffer[i] == 32 )
      Buffer[i + 1] = tolower(Buffer[i + 1]);
  }
  if ( !strcmp(Buffer, "january") )
  {
    v11 = 1;
  }
  else if ( !strcmp(Buffer, "february") )
  {
    v11 = 2;
  }
  else if ( !strcmp(Buffer, "march") )
  {
    v11 = 3;
  }
  else if ( !strcmp(Buffer, "april") )
  {
    v11 = 4;
  }
  else if ( !strcmp(Buffer, "may") )
  {
    v11 = 5;
  }
  else if ( !strcmp(Buffer, "june") )
  {
    v11 = 6;
  }
  else if ( !strcmp(Buffer, "july") )
  {
    v11 = 7;
  }
  else if ( !strcmp(Buffer, "august") )
  {
    v11 = 8;
  }
  else if ( !strcmp(Buffer, "september") )
  {
    v11 = 9;
  }
  else if ( !strcmp(Buffer, "october") )
  {
    v11 = 10;
  }
  else if ( !strcmp(Buffer, "november") )
  {
    v11 = 11;
  }
  else
  {
    if ( strcmp(Buffer, "december") )
    {
      printf("My love, I'm sorry but that's not a valid date. Please try again.\n");
      return 0;
    }
    v11 = 12;
  }
  printf("My love, what year is it? ");
  scanf("%d", &v5);
  if ( (v5 & 3) == 0 && (v5 % 100 || !(v5 % 400)) )
    v10 = 1;
  printf("My love, what day is it? ");
  scanf("%d", &v6);
  if ( v6 <= 0 || v6 > 31 )
  {
    printf("My love, I'm sorry but that's not a valid day. Please try again.\n");
    return 0;
  }
  if ( v11 == 2 )
  {
    if ( v10 == 1 )
    {
      if ( v6 > 29 )
      {
        printf("My love, I'm sorry but February only has 29 days this year. Please try again.\n");
        return 0;
      }
    }
    else if ( v6 > 28 )
    {
      printf("My love, I'm sorry but February only has 28 days this year. Please try again.\n");
      return 0;
    }
  }
  else if ( (v11 == 4 || v11 == 6 || v11 == 9 || v11 == 11) && v6 > 30 )
  {
    printf("My love, I'm sorry but that month only has 30 days. Please try again.\n");
    return 0;
  }
  printf("My love, the date you entered is: %d/%d/%d\n", v11, (unsigned int)v6, (unsigned int)v5);
  return 0;
}
// 140001A80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Buffer[15];
// 1400015E2: using guessed type int var_24;

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Hexadecimal Converter ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char hex[17], ascii[16], binary[65] = {'\0'};
    int decimal, i, length;
    printf("Enter a hexadecimal number: ");
    scanf("%s", hex);
    
    // convert hexadecimal to decimal
    decimal = 0;
    length = strlen(hex);
    for(i = 0; i < length; i++) {
        if(hex[i] >= '0' && hex[i] <= '9') {
            decimal += (hex[i] - '0') * (int) pow(16, length - i - 1);
        } else if(hex[i] >= 'A' && hex[i] <= 'F') {
            decimal += (hex[i] - 'A' + 10) * (int) pow(16, length - i - 1);
        } else {
            printf("Invalid input.\n");
            return 1;
        }
    }
    
    // convert decimal to binary
    int j = 0;
    while(decimal > 0) {
        binary[j++] = decimal % 2 + '0';
        decimal /= 2;
    }
    
    // reverse binary string
    int k = 0;
    char temp;
    while(k < j - 1) {
        temp = binary[k];
        binary[k] = binary[j - 1];
        binary[j - 1] = temp;
        k++;
        j--;
    }
    
    // convert binary to ASCII
    length = strlen(binary);
    for(i = 0; i < length; i += 8) {
        memcpy(ascii + i / 8, binary + i, 8);
        ascii[i / 8 + 1] = '\0';
    }
    
    // output results
    printf("Hexadecimal input: %s\n", hex);
    printf("Decimal output: %d\n", decimal);
    printf("Binary output: %s\n", binary);
    printf("ASCII output: %s\n", ascii);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);
// size_t __cdecl strlen(const char *Str);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // ebx
  double v4; // xmm0_8
  int v5; // ebx
  double v6; // xmm0_8
  int v8; // eax
  char v9[8]; // [rsp+20h] [rbp-90h] BYREF
  __int64 v10; // [rsp+28h] [rbp-88h]
  __int64 v11; // [rsp+30h] [rbp-80h]
  __int64 v12; // [rsp+38h] [rbp-78h]
  __int64 v13; // [rsp+40h] [rbp-70h]
  __int64 v14; // [rsp+48h] [rbp-68h]
  __int64 v15; // [rsp+50h] [rbp-60h]
  __int64 v16; // [rsp+58h] [rbp-58h]
  char v17; // [rsp+60h] [rbp-50h]
  char v18[16]; // [rsp+70h] [rbp-40h] BYREF
  char Str[27]; // [rsp+80h] [rbp-30h] BYREF
  char v20; // [rsp+9Bh] [rbp-15h]
  int v21; // [rsp+9Ch] [rbp-14h]
  int v22; // [rsp+A0h] [rbp-10h]
  int v23; // [rsp+A4h] [rbp-Ch]
  int i; // [rsp+A8h] [rbp-8h]
  int v25; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  *(_QWORD *)v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0;
  printf("Enter a hexadecimal number: ");
  scanf("%s", Str);
  v25 = 0;
  v21 = strlen(Str);
  for ( i = 0; i < v21; ++i )
  {
    if ( Str[i] <= 47 || Str[i] > 57 )
    {
      if ( Str[i] <= 64 || Str[i] > 70 )
      {
        printf("Invalid input.\n");
        return 1;
      }
      v5 = Str[i] - 55;
      v6 = pow(16.0, (double)(v21 - i - 1));
      v25 += v5 * (int)v6;
    }
    else
    {
      v3 = Str[i] - 48;
      v4 = pow(16.0, (double)(v21 - i - 1));
      v25 += v3 * (int)v4;
    }
  }
  v23 = 0;
  while ( v25 > 0 )
  {
    v8 = v23++;
    v9[v8] = v25 % 2 + 48;
    v25 /= 2;
  }
  v22 = 0;
  while ( v22 < v23 - 1 )
  {
    v20 = v9[v22];
    v9[v22] = v9[v23 - 1];
    v9[v23 - 1] = v20;
    ++v22;
    --v23;
  }
  v21 = strlen(v9);
  for ( i = 0; i < v21; i += 8 )
  {
    *(_QWORD *)&v18[i / 8] = *(_QWORD *)&v9[i];
    v18[i / 8 + 1] = 0;
  }
  printf("Hexadecimal input: %s\n", Str);
  printf("Decimal output: %d\n", (unsigned int)v25);
  printf("Binary output: %s\n", v9);
  printf("ASCII output: %s\n", v18);
  return 0;
}
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[27];
// 1400015E2: using guessed type char var_50[16];

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Planet Gravity Simulation ; Style: scientific
#include <stdio.h>
#include <math.h>

#define G 6.67408e-11 // gravitational constant
#define DELTA_T 1 // time step
#define NUM_PLANETS 4 // number of planets

typedef struct {
    char name[20];
    double mass;
    double x, y, z; // position
    double vx, vy, vz; // velocity
} Planet;

int main() {
    Planet planets[NUM_PLANETS] = {
        {"Earth", 5.97e24, 0, 0, 0, 0, 0, 0},
        {"Moon", 7.34e22, 3.84e8, 0, 0, 0, 1022, 0},
        {"Mars", 6.39e23, 2.28e11, 0, 0, 0, 0, 24130},
        {"Jupiter", 1.9e27, 7.78e11, 0, 0, 0, 0, 13052}
    };

    for (int i = 0; i < NUM_PLANETS; i++) {
        printf("%s position: (%.2e, %.2e, %.2e)\n", 
            planets[i].name, planets[i].x, planets[i].y, planets[i].z);
    }

    for (int i = 0; i < 1000; i++) { // simulate for 1000 time steps
        for (int j = 0; j < NUM_PLANETS; j++) {
            double ax = 0, ay = 0, az = 0; // acceleration
            for (int k = 0; k < NUM_PLANETS; k++) {
                if (j == k) continue;
                double dx = planets[k].x - planets[j].x;
                double dy = planets[k].y - planets[j].y;
                double dz = planets[k].z - planets[j].z;
                double d = sqrt(dx * dx + dy * dy + dz * dz); // distance
                double f = G * planets[j].mass * planets[k].mass / (d * d); // force
                ax += f * dx / d / planets[j].mass;
                ay += f * dy / d / planets[j].mass;
                az += f * dz / d / planets[j].mass;
            }
            planets[j].vx += ax * DELTA_T;
            planets[j].vy += ay * DELTA_T;
            planets[j].vz += az * DELTA_T;
            planets[j].x += planets[j].vx * DELTA_T;
            planets[j].y += planets[j].vy * DELTA_T;
            planets[j].z += planets[j].vz * DELTA_T;
        }
    }

    for (int i = 0; i < NUM_PLANETS; i++) {
        printf("%s position: (%.2e, %.2e, %.2e)\n", 
            planets[i].name, planets[i].x, planets[i].y, planets[i].z);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);

//-------------------------------------------------------------------------
// Data declarations

char aEarth[6] = "Earth"; // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[328]; // [rsp+30h] [rbp-50h] BYREF
  double v5; // [rsp+178h] [rbp+F8h]
  double v6; // [rsp+180h] [rbp+100h]
  double v7; // [rsp+188h] [rbp+108h]
  double v8; // [rsp+190h] [rbp+110h]
  double v9; // [rsp+198h] [rbp+118h]
  int n; // [rsp+1A0h] [rbp+120h]
  int m; // [rsp+1A4h] [rbp+124h]
  double v12; // [rsp+1A8h] [rbp+128h]
  double v13; // [rsp+1B0h] [rbp+130h]
  double v14; // [rsp+1B8h] [rbp+138h]
  int k; // [rsp+1C4h] [rbp+144h]
  int j; // [rsp+1C8h] [rbp+148h]
  int i; // [rsp+1CCh] [rbp+14Ch]

  _main(argc, argv, envp);
  qmemcpy(v4, aEarth, 0x140ui64);
  for ( i = 0; i <= 3; ++i )
    printf(
      "%s position: (%.2e, %.2e, %.2e)\n",
      &v4[80 * i],
      *(double *)&v4[80 * i + 32],
      *(double *)&v4[80 * i + 40],
      *(double *)&v4[80 * i + 48]);
  for ( j = 0; j <= 999; ++j )
  {
    for ( k = 0; k <= 3; ++k )
    {
      v14 = 0.0;
      v13 = 0.0;
      v12 = 0.0;
      for ( m = 0; m <= 3; ++m )
      {
        if ( k != m )
        {
          v9 = *(double *)&v4[80 * m + 32] - *(double *)&v4[80 * k + 32];
          v8 = *(double *)&v4[80 * m + 40] - *(double *)&v4[80 * k + 40];
          v7 = *(double *)&v4[80 * m + 48] - *(double *)&v4[80 * k + 48];
          v6 = sqrt(v9 * v9 + v8 * v8 + v7 * v7);
          v5 = *(double *)&v4[80 * k + 24] * 6.67408e-11 * *(double *)&v4[80 * m + 24] / (v6 * v6);
          v14 = v5 * v9 / v6 / *(double *)&v4[80 * k + 24] + v14;
          v13 = v5 * v8 / v6 / *(double *)&v4[80 * k + 24] + v13;
          v12 = v5 * v7 / v6 / *(double *)&v4[80 * k + 24] + v12;
        }
      }
      *(double *)&v4[80 * k + 56] = *(double *)&v4[80 * k + 56] + v14;
      *(double *)&v4[80 * k + 64] = *(double *)&v4[80 * k + 64] + v13;
      *(double *)&v4[80 * k + 72] = *(double *)&v4[80 * k + 72] + v12;
      *(double *)&v4[80 * k + 32] = *(double *)&v4[80 * k + 56] + *(double *)&v4[80 * k + 32];
      *(double *)&v4[80 * k + 40] = *(double *)&v4[80 * k + 64] + *(double *)&v4[80 * k + 40];
      *(double *)&v4[80 * k + 48] = *(double *)&v4[80 * k + 72] + *(double *)&v4[80 * k + 48];
    }
  }
  for ( n = 0; n <= 3; ++n )
    printf(
      "%s position: (%.2e, %.2e, %.2e)\n",
      &v4[80 * n],
      *(double *)&v4[80 * n + 32],
      *(double *)&v4[80 * n + 40],
      *(double *)&v4[80 * n + 48]);
  return 0;
}
// 140001EF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char var_1B0[328];

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: modern Encryption ; Style: content
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define MAX_LEN 1000   // maximum length of string that can be encrypted

char* encrypt(char* str, int key){
    char* encrypted_str = (char*)malloc(MAX_LEN*sizeof(char));   // to store encrypted string
    int str_len = strlen(str);   // length of string to be encrypted
    for(int i=0; i<str_len; i++){
        char ch = str[i];
        if(ch >= 'A' && ch <= 'Z'){   // if uppercase letter
            encrypted_str[i] = ((((ch-'A') + key) % 26) + 'A') ;  // encrypt using Caesar Cipher
        }
        else if(ch >= 'a' && ch <= 'z'){   // if lowercase letter
            encrypted_str[i] = ((((ch-'a') + key) % 26) + 'a') ;  // encrypt using Caesar Cipher
        }
        else{   // if non-alphabetic character
            encrypted_str[i] = ch;
        }
    }
    encrypted_str[str_len] = '\0';   // add null character at the end of string to mark end of string
    return encrypted_str;
}

int main(){
    char str[MAX_LEN];   // to store string to be encrypted
    int key;   // key used for encryption
    printf("Enter the string to be encrypted: ");
    scanf("%[^\n]s", str);   // read the input string
    printf("Enter the key for encryption: ");
    scanf("%d", &key);   // read the encryption key
    char* encrypted_str = encrypt(str, key);   // call the encrypt function
    printf("Encrypted string: %s\n", encrypted_str);
    free(encrypted_str);   // deallocate memory used for encrypted string
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (0000000140001705) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-54h] BYREF
  char v5[1000]; // [rsp+30h] [rbp-50h] BYREF
  void *Block; // [rsp+418h] [rbp+398h]

  _main(argc, argv, envp);
  printf("Enter the string to be encrypted: ");
  scanf("%[^\n]s", v5);
  printf("Enter the key for encryption: ");
  scanf("%d", &v4);
  Block = (void *)encrypt(v5, v4);
  printf("Encrypted string: %s\n", (const char *)Block);
  free(Block);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Terminal Based Game ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>

// Snake game implementation
int main()
{
    // Game board dimensions
    const int width = 30;
    const int height = 15;

    // Initialize the game board as a 2D character array
    char gameBoard[height][width];

    // Initialize the snake at the center of the board
    int snakeX = width / 2;
    int snakeY = height / 2;

    // Initialize the apple at a random position on the board
    int appleX = rand() % width;
    int appleY = rand() % height;

    // Initialize the snake direction to be up
    enum Direction {UP, DOWN, LEFT, RIGHT};
    enum Direction currDirection = UP;

    // Initialize the game loop
    bool gameOver = false;
    int score = 0;
    while(!gameOver)
    {
        // Clear the game board
        system("clear");

        // Draw the game board border
        for (int col = 0; col < width; col++)
        {
            gameBoard[0][col] = '#';
            gameBoard[height-1][col] = '#';
        }
        for (int row = 1; row < height-1; row++)
        {
            gameBoard[row][0] = '#';
            gameBoard[row][width-1] = '#';
        }

        // Draw the snake and apple
        gameBoard[snakeY][snakeX] = 'O';
        gameBoard[appleY][appleX] = 'X';

        // Print the game board
        for (int row = 0; row < height; row++)
        {
            for (int col = 0; col < width; col++)
            {
                printf("%c", gameBoard[row][col]);
            }
            printf("\n");
        }

        // Handle user input
        char userMove;
        printf("Score: %d\n", score);
        printf("Use arrow keys to move the snake. Press q to quit.\n");
        scanf(" %c", &userMove);

        switch(userMove)
        {
            case 'q':
                gameOver = true;
                break;
            case 'w':
                currDirection = UP;
                break;
            case 's':
                currDirection = DOWN;
                break;
            case 'a':
                currDirection = LEFT;
                break;
            case 'd':
                currDirection = RIGHT;
                break;
        }

        // Move the snake
        switch(currDirection)
        {
            case UP:
                snakeY--;
                break;
            case DOWN:
                snakeY++;
                break;
            case LEFT:
                snakeX--;
                break;
            case RIGHT:
                snakeX++;
                break;
        }

        // Check for collisions
        if (snakeX == 0 || snakeX == width-1 || snakeY == 0 || snakeY == height-1)
        {
            gameOver = true;
        }
        else if (snakeX == appleX && snakeY == appleY)
        {
            score++;
            appleX = rand() % width;
            appleY = rand() % height;
        }

        // Slow down the game for better user experience
        usleep(100000);
    }

    // Game over
    printf("Game over! Your final score was %d.\n", score);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall usleep(_QWORD); // weak
// int __cdecl system(const char *Command);
// int __cdecl rand();


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  __int64 v5; // [rsp+0h] [rbp-B0h] BYREF
  char v6; // [rsp+20h] [rbp-90h] BYREF
  __int64 *v7; // [rsp+28h] [rbp-88h]
  __int64 v8; // [rsp+30h] [rbp-80h]
  __int64 v9; // [rsp+38h] [rbp-78h]
  __int64 v10; // [rsp+40h] [rbp-70h]
  __int64 v11; // [rsp+48h] [rbp-68h]
  char v12; // [rsp+5Fh] [rbp-51h] BYREF
  char *v13; // [rsp+60h] [rbp-50h]
  __int64 v14; // [rsp+68h] [rbp-48h]
  __int64 v15; // [rsp+70h] [rbp-40h]
  int v16; // [rsp+7Ch] [rbp-34h]
  int v17; // [rsp+80h] [rbp-30h]
  int m; // [rsp+84h] [rbp-2Ch]
  int k; // [rsp+88h] [rbp-28h]
  int j; // [rsp+8Ch] [rbp-24h]
  int i; // [rsp+90h] [rbp-20h]
  unsigned int v22; // [rsp+94h] [rbp-1Ch]
  char v23; // [rsp+9Bh] [rbp-15h]
  unsigned int v24; // [rsp+9Ch] [rbp-14h]
  int v25; // [rsp+A0h] [rbp-10h]
  int v26; // [rsp+A4h] [rbp-Ch]
  int v27; // [rsp+A8h] [rbp-8h]
  int v28; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v7 = &v5;
  v17 = 30;
  v16 = 15;
  v15 = 29i64;
  v8 = 30i64;
  v9 = 0i64;
  v14 = 14i64;
  v10 = 30i64;
  v11 = 0i64;
  v3 = alloca(464i64);
  v13 = &v6;
  v28 = 15;
  v27 = 7;
  v26 = rand() % 30;
  v25 = rand() % v16;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  while ( v23 != 1 )
  {
    system("clear");
    for ( i = 0; i < v17; ++i )
    {
      v13[i] = 35;
      v13[30 * v16 - 30 + i] = 35;
    }
    for ( j = 1; j < v16 - 1; ++j )
    {
      v13[30 * j] = 35;
      v13[30 * j - 1 + v17] = 35;
    }
    v13[30 * v27 + v28] = 79;
    v13[30 * v25 + v26] = 88;
    for ( k = 0; k < v16; ++k )
    {
      for ( m = 0; m < v17; ++m )
        printf("%c", (unsigned int)v13[30 * k + m]);
      printf("\n");
    }
    printf("Score: %d\n", v22);
    printf("Use arrow keys to move the snake. Press q to quit.\n");
    scanf(" %c", &v12);
    switch ( v12 )
    {
      case 'a':
        v24 = 2;
        break;
      case 'd':
        v24 = 3;
        break;
      case 'q':
        v23 = 1;
        break;
      case 's':
        v24 = 1;
        break;
      case 'w':
        v24 = 0;
        break;
      default:
        break;
    }
    if ( v24 == 3 )
    {
      ++v28;
    }
    else if ( v24 <= 3 )
    {
      if ( v24 == 2 )
      {
        --v28;
      }
      else if ( v24 )
      {
        ++v27;
      }
      else
      {
        --v27;
      }
    }
    if ( v28 && v28 != v17 - 1 && v27 && v27 != v16 - 1 )
    {
      if ( v28 == v26 && v27 == v25 )
      {
        ++v22;
        v26 = rand() % v17;
        v25 = rand() % v16;
      }
    }
    else
    {
      v23 = 1;
    }
    usleep(100000i64);
  }
  printf("Game over! Your final score was %d.\n", v22);
  return 0;
}
// 14000192A: conditional instruction was optimized away because %var_54.4<2u
// 140001936: conditional instruction was optimized away because %var_54.4==1
// 140001AA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002B00: using guessed type __int64 __fastcall usleep(_QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: QR code reader ; Style: scalable
// QR Code Reader Program in C

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#define QR_CODE_SIZE 25
#define MAX_INPUT_LENGTH 1000

// Helper function to get user input
void getInput(char *inputString){
    printf("Enter the QR Code (alphanumeric characters only, max %d characters): ", QR_CODE_SIZE);
    fgets(inputString, MAX_INPUT_LENGTH, stdin);
    strtok(inputString, "\n");  // remove the newline character from the input string
}

// Helper function to validate the QR code format
bool isValidQRCode(char *qrCodeString){
    int len = strlen(qrCodeString);
    if(len == QR_CODE_SIZE){
        for(int i=0; i<len; i++){
            if((qrCodeString[i]>='A' && qrCodeString[i]<='Z') || (qrCodeString[i]>='a' && qrCodeString[i]<='z') || (qrCodeString[i]>='0' && qrCodeString[i]<='9')){
                continue;
            }else{
                return false;
            }
        }
        return true;
    }
    return false;
}

// Helper function to decode the QR code
void decodeQRCode(char *qrCodeString){
    printf("\nQR Code Decoded: ");
    for(int i=0; i<QR_CODE_SIZE; i+=2){
        int num = (qrCodeString[i]-'0')*10 + (qrCodeString[i+1]-'0');
        printf("%c", (char)num);
    }
    printf("\n\n");
}

// Main function
int main(){
    char inputString[MAX_INPUT_LENGTH], qrCodeString[QR_CODE_SIZE+1];

    do{
        getInput(inputString);

        if(isValidQRCode(inputString)){
            strncpy(qrCodeString, inputString, QR_CODE_SIZE);
            decodeQRCode(qrCodeString);
        }else{
            printf("Invalid QR Code! Please try again!\n\n");
        }

    }while(true);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall getInput(_QWORD); // weak
__int64 __fastcall isValidQRCode(_QWORD); // weak
__int64 __fastcall decodeQRCode(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);


//----- (0000000140001754) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Destination[32]; // [rsp+20h] [rbp-60h] BYREF
  char Source[1008]; // [rsp+40h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    getInput(Source);
    if ( (unsigned __int8)isValidQRCode(Source) )
    {
      strncpy(Destination, Source, 0x19ui64);
      decodeQRCode(Destination);
    }
    else
    {
      printf("Invalid QR Code! Please try again!\n\n");
    }
  }
}
// 140001591: using guessed type __int64 __fastcall getInput(_QWORD);
// 1400015EA: using guessed type __int64 __fastcall isValidQRCode(_QWORD);
// 1400016BA: using guessed type __int64 __fastcall decodeQRCode(_QWORD);
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bitwise operations ; Style: genious
#include <stdio.h>

/* A genius example of bitwise operations in C */

int main() {
    int num1 = 13;    // Binary: 1101
    int num2 = 7;     // Binary: 0111
    int result;

    /* Bitwise AND operator (&) */
    result = num1 & num2;
    printf("The result of num1 & num2 is %d (Binary: %d)\n", result, result);

    /* Bitwise OR operator (|) */
    result = num1 | num2;
    printf("The result of num1 | num2 is %d (Binary: %d)\n", result, result);

    /* Bitwise XOR operator (^) */
    result = num1 ^ num2;
    printf("The result of num1 ^ num2 is %d (Binary: %d)\n", result, result);

    /* Bitwise NOT operator (~) */
    result = ~num1;
    printf("The result of ~num1 is %d (Binary: %d)\n", result, result);

    /* Bitwise left shift operator (<<) */
    result = num1 << 2;      // Shift left by 2 bits
    printf("The result of num1 << 2 is %d (Binary: %d)\n", result, result);

    /* Bitwise right shift operator (>>) */
    result = num2 >> 1;      // Shift right by 1 bit
    printf("The result of num2 >> 1 is %d (Binary: %d)\n", result, result);

    /* Genius bonus: Bitwise swap without using a temporary variable */
    int x = num1, y = num2;
    x = x ^ y;
    y = x ^ y;
    x = x ^ y;
    printf("After swapping, num1 = %d, num2 = %d\n", x, y);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("The result of num1 & num2 is %d (Binary: %d)\n", 5i64, 5i64);
  printf("The result of num1 | num2 is %d (Binary: %d)\n", 15i64, 15i64);
  printf("The result of num1 ^ num2 is %d (Binary: %d)\n", 10i64, 10i64);
  printf("The result of ~num1 is %d (Binary: %d)\n", 4294967282i64, 4294967282i64);
  printf("The result of num1 << 2 is %d (Binary: %d)\n", 52i64, 52i64);
  printf("The result of num2 >> 1 is %d (Binary: %d)\n", 3i64, 3i64);
  printf("After swapping, num1 = %d, num2 = %d\n", 7i64, 13i64);
  return 0;
}
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    char name[50];
    printf("Welcome to the Automated Fortune Teller! Please enter your name: ");
    scanf("%s", name);
    
    time_t now = time(NULL);
    
    srand(now);

    int fortune = rand() % 5;

    switch(fortune) {
        case 0:
            printf("\n%s, a great opportunity awaits you in the near future. Keep your eyes open!\n", name);
            break;
        case 1:
            printf("\n%s, your hard work will pay off soon. Stay focused!\n", name);
            break;
        case 2:
            printf("\n%s, be careful of making impulsive decisions. Take time to think things through.\n", name);
            break;
        case 3:
            printf("\n%s, a new person will enter your life and bring positivity and happiness.\n", name);
            break;
        case 4:
            printf("\n%s, let go of your worries and enjoy the present moment. Everything will fall into place.\n", name);
            break;
        default:
            printf("\n%s, the future is uncertain. Focus on the present and make the most of every opportunity.\n", name);
            break;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[52]; // [rsp+20h] [rbp-40h] BYREF
  int v5; // [rsp+54h] [rbp-Ch]
  unsigned int Seed[2]; // [rsp+58h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to the Automated Fortune Teller! Please enter your name: ");
  scanf("%s", v4);
  *(_QWORD *)Seed = time(0i64);
  srand(Seed[0]);
  v5 = rand() % 5;
  switch ( v5 )
  {
    case 0:
      printf("\n%s, a great opportunity awaits you in the near future. Keep your eyes open!\n", v4);
      break;
    case 1:
      printf("\n%s, your hard work will pay off soon. Stay focused!\n", v4);
      break;
    case 2:
      printf("\n%s, be careful of making impulsive decisions. Take time to think things through.\n", v4);
      break;
    case 3:
      printf("\n%s, a new person will enter your life and bring positivity and happiness.\n", v4);
      break;
    case 4:
      printf("\n%s, let go of your worries and enjoy the present moment. Everything will fall into place.\n", v4);
      break;
    default:
      printf("\n%s, the future is uncertain. Focus on the present and make the most of every opportunity.\n", v4);
      break;
  }
  return 0;
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Basic Image Processing: Simple tasks like flipping an image, changing brightness/contrast ; Style: funny
#include<stdio.h>

int main(){

	printf("Welcome to the magical world of image processing! Let's have some fun.\n");
	
	// Reading image
	printf("Enter the name of the image file: ");
	char file[100];
	scanf("%s", file);
	printf("Reading image %s...\n", file);
	
	// Flipping image
	printf("Would you like to flip the image horizontally or vertically? Enter 'H' for horizontal and 'V' for vertical: ");
	char flip_dir;
	scanf(" %c", &flip_dir);
	if(flip_dir == 'H'){
		printf("Flipping image %s horizontally...\n", file);
		// TODO: Implement horizontal flipping of image
	}
	else if(flip_dir == 'V'){
		printf("Flipping image %s vertically...\n", file);
		// TODO: Implement vertical flipping of image
	}
	else{
		printf("Invalid direction entered. Continuing with original image.\n");
	}
	
	// Adjusting brightness
	printf("The image looks a bit dull. Let's brighten it up! Enter a value between 1-10 for brightness adjustment: ");
	int brightness;
	scanf("%d", &brightness);
	if(brightness < 1 || brightness > 10){
		printf("Invalid brightness value entered. Brightness adjustment set to default value of 5.\n");
		brightness = 5;
	}
	printf("Adjusting brightness of image %s...\n", file);
	// TODO: Implement brightness adjustment of image
	
	// Adjusting contrast
	printf("Let's give the image some more pop! Enter a value between 1-10 for contrast adjustment: ");
	int contrast;
	scanf("%d", &contrast);
	if(contrast < 1 || contrast > 10){
		printf("Invalid contrast value entered. Contrast adjustment set to default value of 5.\n");
		contrast = 5;
	}
	printf("Adjusting contrast of image %s...\n", file);
	// TODO: Implement contrast adjustment of image
	
	printf("All set! Check out the updated image file %s.\n", file);
	
	return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-7Ch] BYREF
  int v5; // [rsp+28h] [rbp-78h] BYREF
  char v6; // [rsp+2Fh] [rbp-71h] BYREF
  char v7[112]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the magical world of image processing! Let's have some fun.\n");
  printf("Enter the name of the image file: ");
  scanf("%s", v7);
  printf("Reading image %s...\n", v7);
  printf("Would you like to flip the image horizontally or vertically? Enter 'H' for horizontal and 'V' for vertical: ");
  scanf(" %c", &v6);
  if ( v6 == 72 )
  {
    printf("Flipping image %s horizontally...\n", v7);
  }
  else if ( v6 == 86 )
  {
    printf("Flipping image %s vertically...\n", v7);
  }
  else
  {
    printf("Invalid direction entered. Continuing with original image.\n");
  }
  printf("The image looks a bit dull. Let's brighten it up! Enter a value between 1-10 for brightness adjustment: ");
  scanf("%d", &v5);
  if ( v5 <= 0 || v5 > 10 )
  {
    printf("Invalid brightness value entered. Brightness adjustment set to default value of 5.\n");
    v5 = 5;
  }
  printf("Adjusting brightness of image %s...\n", v7);
  printf("Let's give the image some more pop! Enter a value between 1-10 for contrast adjustment: ");
  scanf("%d", &v4);
  if ( v4 <= 0 || v4 > 10 )
  {
    printf("Invalid contrast value entered. Contrast adjustment set to default value of 5.\n");
    v4 = 5;
  }
  printf("Adjusting contrast of image %s...\n", v7);
  printf("All set! Check out the updated image file %s.\n", v7);
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type int var_78;

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Performance-Critical Component ; Style: Linus Torvalds
/*
 * This is a performance-critical component that optimizes matrix multiply.
 * I do not apologize for the complexity of the code. Optimization is not for the weak.
 *
 * Written by Linus Torvalds (not really)
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MATRIX_SIZE 1000

void multiply_matrices(double *A, double *B, double *C, int size)
{
    int i, j, k;

    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            C[i*size+j] = 0.0;
            for (k = 0; k < size; k++) {
                C[i*size+j] += A[i*size+k] * B[k*size+j];
            }
        }
    }
}

int main()
{
    double *A, *B, *C;
    clock_t start, end;
    double cpu_time_used;

    // Allocate memory for matrices
    A = (double*) malloc(MATRIX_SIZE * MATRIX_SIZE * sizeof(double));
    B = (double*) malloc(MATRIX_SIZE * MATRIX_SIZE * sizeof(double));
    C = (double*) malloc(MATRIX_SIZE * MATRIX_SIZE * sizeof(double));

    // Initialize matrices with random values between 0.0 and 1.0
    srand(time(NULL));
    for (int i = 0; i < MATRIX_SIZE * MATRIX_SIZE; i++) {
        A[i] = ((double) rand()) / ((double) RAND_MAX);
        B[i] = ((double) rand()) / ((double) RAND_MAX);
    }

    // Multiply matrices and time it
    start = clock();
    multiply_matrices(A, B, C, MATRIX_SIZE);
    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

    printf("Matrix size = %d x %d\n", MATRIX_SIZE, MATRIX_SIZE);
    printf("Execution time = %f seconds\n", cpu_time_used);

    // Free memory
    free(A);
    free(B);
    free(C);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall multiply_matrices(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// clock_t __cdecl clock();


//----- (00000001400016DF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  double v5; // [rsp+20h] [rbp-30h]
  clock_t v6; // [rsp+2Ch] [rbp-24h]
  void *v7; // [rsp+30h] [rbp-20h]
  double *v8; // [rsp+38h] [rbp-18h]
  double *Block; // [rsp+40h] [rbp-10h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  Block = (double *)malloc(0x7A1200ui64);
  v8 = (double *)malloc(0x7A1200ui64);
  v7 = malloc(0x7A1200ui64);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 999999; ++i )
  {
    Block[i] = (double)rand() / 32767.0;
    v8[i] = (double)rand() / 32767.0;
  }
  v6 = clock();
  multiply_matrices(Block, v8, v7, 1000i64);
  v5 = (double)(clock() - v6) / 1000.0;
  printf("Matrix size = %d x %d\n", 1000i64, 1000i64);
  printf("Execution time = %f seconds\n", v5);
  free(Block);
  free(v8);
  free(v7);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall multiply_matrices(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Physics simulation ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int mass_of_sun = 1.989 * pow(10, 30);
    int mass_of_earth = 5.972 * pow(10, 24);
    int distance = 149.6 * pow(10, 9);
    double gravitational_constant = 6.67 * pow(10, -11);
    
    printf("Welcome to the hilarious world of Physics Simulation!\n");
    printf("Today, we're going to simulate the interaction between the Sun and the Earth.\n");
    
    srand(time(NULL));
    float random_velocity = rand() % 10 + 15;
    float velocity_of_earth = random_velocity * pow(10, 3);
    float force_of_gravity = (gravitational_constant * mass_of_sun * mass_of_earth) / pow(distance, 2);
    float acceleration_of_earth = force_of_gravity / mass_of_earth;
    
    printf("The mass of the Sun is %d kg and the mass of the Earth is %d kg.\n", mass_of_sun, mass_of_earth);
    printf("The distance between them is %d m and the gravitational constant is %f m^3/(kg*s^2).\n", distance, gravitational_constant);
    printf("The Earth is moving at a speed of %f m/s.\n", velocity_of_earth);
    
    printf("3...\n");
    sleep(1);
    printf("2...\n");
    sleep(1);
    printf("1...\n");
    sleep(1);
    printf("Liftoff!\n");
    sleep(1);
    
    float time = 0;
    float velocity = velocity_of_earth;
    float position = 0;
    float force = force_of_gravity;
    float acceleration = acceleration_of_earth;
    
    while(1)
    {
        printf("The Earth is currently at a distance of %f m from the Sun. ", position);
        
        if(position >= distance)
        {
            printf("The Earth has escaped the gravitational pull of the Sun! Congratulations!\n");
            break;
        }
        
        position = position + velocity * 1 + 0.5 * acceleration * pow(1, 2);
        velocity = velocity + acceleration * 1;
        force = (gravitational_constant * mass_of_sun * mass_of_earth) / pow(distance, 2);
        acceleration = force / mass_of_earth;
        time += 1;
        
        printf("The time elapsed is %f s and the speed of the Earth is %f m/s.\n", time, velocity);
        
        if(velocity >= 29800)
        {
            printf("Houston, we have a problem! The Earth is travelling too fast!\n");
            break;
        }
        
        sleep(1);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
double __cdecl pow(double X, double Y);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  float v8; // [rsp+30h] [rbp-30h]
  float v9; // [rsp+50h] [rbp-10h]
  float v10; // [rsp+54h] [rbp-Ch]
  float v11; // [rsp+58h] [rbp-8h]
  float v12; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the hilarious world of Physics Simulation!\n");
  printf("Today, we're going to simulate the interaction between the Sun and the Earth.\n");
  v3 = time(0i64);
  srand(v3);
  v8 = 1000.0 * (float)(rand() % 10 + 15);
  v4 = (double)0x7FFFFFFF * 6.67e-11 * (double)0x7FFFFFFF / pow((double)0x7FFFFFFF, 2.0);
  printf("The mass of the Sun is %d kg and the mass of the Earth is %d kg.\n", 0x7FFFFFFFi64, 0x7FFFFFFFi64);
  printf(
    "The distance between them is %d m and the gravitational constant is %f m^3/(kg*s^2).\n",
    0x7FFFFFFFi64,
    6.67e-11);
  printf("The Earth is moving at a speed of %f m/s.\n", v8);
  printf("3...\n");
  sleep(1i64);
  printf("2...\n");
  sleep(1i64);
  printf("1...\n");
  sleep(1i64);
  printf("Liftoff!\n");
  sleep(1i64);
  v12 = 0.0;
  v11 = v8;
  v10 = 0.0;
  v9 = v4 / (float)0x7FFFFFFF;
  while ( 1 )
  {
    printf("The Earth is currently at a distance of %f m from the Sun. ", v10);
    if ( v10 >= (float)0x7FFFFFFF )
    {
      printf("The Earth has escaped the gravitational pull of the Sun! Congratulations!\n");
      return 0;
    }
    v5 = 0.5 * v9 + (float)(v10 + v11);
    v10 = v5;
    v11 = v11 + v9;
    v6 = (double)0x7FFFFFFF * 6.67e-11 * (double)0x7FFFFFFF / pow((double)0x7FFFFFFF, 2.0);
    v9 = v6 / (float)0x7FFFFFFF;
    v12 = v12 + 1.0;
    printf("The time elapsed is %f s and the speed of the Earth is %f m/s.\n", v12, v11);
    if ( v11 >= 29800.0 )
      break;
    sleep(1i64);
  }
  printf("Houston, we have a problem! The Earth is travelling too fast!\n");
  return 0;
}
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002AA0: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature monitor ; Style: lively
#include <stdio.h>

// function to check if temperature is in range
int checkTemperatureInRange(float temp)
{
    if(temp >= 0 && temp <= 100)
    {
        return 1; // temperature is within range
    }
    else
    {
        return 0; // temperature is out of range
    }
}

int main()
{
    float temperature;
    int inRange;

    printf("Welcome to the Temperature Monitor Program!\n");

    // get user input for temperature
    printf("Please enter the temperature in Celsius: ");
    scanf("%f", &temperature);

    // check if temperature is within range
    inRange = checkTemperatureInRange(temperature);

    // if temperature is within range, display message saying so
    if(inRange == 1)
    {
        printf("The temperature is within range.\n");
    }
    // if temperature is out of range, display message saying so
    else
    {
        printf("The temperature is out of range.\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 checkTemperatureInRange(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001615) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-8h] BYREF
  int v5; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Temperature Monitor Program!\n");
  printf("Please enter the temperature in Celsius: ");
  scanf("%f", &v4);
  v5 = checkTemperatureInRange();
  if ( v5 == 1 )
    printf("The temperature is within range.\n");
  else
    printf("The temperature is out of range.\n");
  return 0;
}
// 1400015E2: using guessed type __int64 checkTemperatureInRange(void);
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: RAM usage monitor ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Function to calculate RAM usage
// Returns the percentage of RAM used
float calculate_ram_usage() {
    FILE *fp;
    char buffer[1024];
    float ram_total, ram_free, ram_used;

    fp = fopen("/proc/meminfo", "r");
    fgets(buffer, 1024, fp);
    sscanf(buffer, "MemTotal: %f kB", &ram_total);

    fgets(buffer, 1024, fp);
    sscanf(buffer, "MemFree: %f kB", &ram_free);

    ram_used = ram_total - ram_free;

    fclose(fp);

    return (ram_used / ram_total) * 100;
}

// Main function
int main() {
    float ram_usage;
    while (1) {
        ram_usage = calculate_ram_usage();
        printf("RAM usage: %.2f%%\n", ram_usage);
        sleep(1);  // Sleep for 1 second before checking RAM usage again
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
double calculate_ram_usage(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak


//----- (00000001400016BC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  float v5; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  while ( 1 )
  {
    *(double *)v3.m128i_i64 = calculate_ram_usage();
    v5 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
    v3 = (__m128i)COERCE_UNSIGNED_INT64(v5);
    printf("RAM usage: %.2f%%\n", v5);
    sleep(1i64);
  }
}
// 1400016CE: variable 'v3' is possibly undefined
// 1400015D4: using guessed type double calculate_ram_usage(void);
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002820: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: Ada Lovelace
#include <stdio.h>
#include <string.h>

// Returns the minimum of three values
int min(int x, int y, int z) { 
    return x < y ? (x < z ? x : z) : (y < z ? y : z); 
}

// Calculates and returns the Levenshtein distance between two strings
int levenshtein_distance(char *str1, char *str2) {
    int len1 = strlen(str1);
    int len2 = strlen(str2);
    int distance[len1 + 1][len2 + 1]; // distance array
    int i, j;

    // initialize first row and column
    for (i = 0; i <= len1; i++)
        distance[i][0] = i;
    for (j = 0; j <= len2; j++)
        distance[0][j] = j;

    // calculate the distance array
    for (i = 1; i <= len1; i++) {
        for (j = 1; j <= len2; j++) {
            if (str1[i - 1] == str2[j - 1])
                distance[i][j] = distance[i - 1][j - 1];
            else
                distance[i][j] = 1 + min(distance[i][j - 1], distance[i - 1][j], distance[i - 1][j - 1]);
        }
    }

    // return the Levenshtein distance
    return distance[len1][len2];
}

int main() {
    char str1[] = "C programming";
    char str2[] = "Java programming";
    int distance = levenshtein_distance(str1, str2);
    printf("The Levenshtein distance between '%s' and '%s' is %d\n", str1, str2, distance);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall levenshtein_distance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018C8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[30]; // [rsp+20h] [rbp-30h] BYREF
  _WORD v5[9]; // [rsp+3Eh] [rbp-12h] BYREF

  _main(argc, argv, envp);
  strcpy((char *)v5, "C programming");
  strcpy(v4, "Java programming");
  *(_DWORD *)&v5[7] = levenshtein_distance(v5, v4);
  printf("The Levenshtein distance between '%s' and '%s' is %d\n", (const char *)v5, v4, *(unsigned int *)&v5[7]);
  return 0;
}
// 1400015C1: using guessed type __int64 __fastcall levenshtein_distance(_QWORD, _QWORD);
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STRING_LENGTH 100

int min(int a, int b, int c) {
    if(a < b && a < c)
        return a;
    else if(b < c)
        return b;
    else
        return c;
}

int calculateLevenshteinDistance(char *str1, char *str2, int len1, int len2) {
    int cost = 0;
    int i, j;
    int **matrix = (int **) malloc((len1+1) * sizeof(int *));
    for(i = 0; i <= len1; i++)
        matrix[i] = (int *) malloc((len2+1) * sizeof(int));

    for(i = 0; i <= len1; i++)
        matrix[i][0] = i;

    for(j = 0; j <= len2; j++)
        matrix[0][j] = j;

    for(i = 1; i <= len1; i++) {
        for(j = 1; j <= len2; j++) {
            cost = (str1[i-1] == str2[j-1]) ? 0 : 1;
            matrix[i][j] = min(matrix[i-1][j] + 1, matrix[i][j-1] + 1, matrix[i-1][j-1] + cost);
        }
    }
    int dist = matrix[len1][len2];

    for(i = 0; i <= len1; i++)
        free(matrix[i]);
    free(matrix);

    return dist;
}

int main() {
    char str1[MAX_STRING_LENGTH], str2[MAX_STRING_LENGTH];
    int len1, len2;

    printf("Enter the first string: ");
    fgets(str1, MAX_STRING_LENGTH, stdin);
    len1 = strlen(str1);
    str1[len1-1] = '\0';
    len1 -= 1;

    printf("Enter the second string: ");
    fgets(str2, MAX_STRING_LENGTH, stdin);
    len2 = strlen(str2);
    str2[len2-1] = '\0';
    len2 -= 1;

    int dist = calculateLevenshteinDistance(str1, str2, len1, len2);
    printf("The Levenshtein distance between '%s' and '%s' is %d.\n", str1, str2, dist);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall calculateLevenshteinDistance(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000182E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Str[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[100]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v8; // [rsp+F4h] [rbp+74h]
  unsigned int v9; // [rsp+F8h] [rbp+78h]
  unsigned int v10; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter the first string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  v10 = strlen(Buffer);
  Buffer[--v10] = 0;
  printf("Enter the second string: ");
  v4 = __acrt_iob_func(0);
  fgets(Str, 100, v4);
  v9 = strlen(Str);
  Str[--v9] = 0;
  v8 = calculateLevenshteinDistance(Buffer, Str, v10, v9);
  printf("The Levenshtein distance between '%s' and '%s' is %d.\n", Buffer, Str, v8);
  return 0;
}
// 1400015C6: using guessed type __int64 __fastcall calculateLevenshteinDistance(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400019F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000182E: using guessed type char Buffer[100];
// 14000182E: using guessed type char Str[112];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific Calculator Implementation ; Style: random
#include <stdio.h>
#include <math.h>

/* function declarations */
float add(float, float);
float subtract(float, float);
float multiply(float, float);
float divide(float, float);
float power(float, float);
float factorial(float);
float sin_func(float);
float cos_func(float);
float tan_func(float);
float sq_rt(float);

int main()
{
    int choice;
    float num1, num2, result;

    printf("\n Welcome to the C Scientific Calculator\n");
    printf(" -----------------------------\n");
    printf(" 1. Addition\n");
    printf(" 2. Subtraction\n");
    printf(" 3. Multiplication\n");
    printf(" 4. Division\n");
    printf(" 5. Power\n");
    printf(" 6. Factorial\n");
    printf(" 7. Sin\n");
    printf(" 8. Cos\n");
    printf(" 9. Tan\n");
    printf(" 10. Square Root\n");
    printf(" -----------------------------\n");

    printf("Enter your choice: ");
    scanf("%d", &choice);

    switch(choice)
    {
        case 1:
            printf("\n Enter number 1: ");
            scanf("%f", &num1);

            printf("\n Enter number 2: ");
            scanf("%f", &num2);

            result = add(num1, num2);
            printf("\n %.2f + %.2f = %.2f\n", num1, num2, result);
            break;

        case 2:
            printf("\n Enter number 1: ");
            scanf("%f", &num1);

            printf("\n Enter number 2: ");
            scanf("%f", &num2);

            result = subtract(num1, num2);
            printf("\n %.2f - %.2f = %.2f\n", num1, num2, result);
            break;

        case 3:
            printf("\n Enter number 1: ");
            scanf("%f", &num1);

            printf("\n Enter number 2: ");
            scanf("%f", &num2);

            result = multiply(num1, num2);
            printf("\n %.2f x %.2f = %.2f\n", num1, num2, result);
            break;

        case 4:
            printf("\n Enter number 1: ");
            scanf("%f", &num1);

            printf("\n Enter number 2: ");
            scanf("%f", &num2);

            result = divide(num1, num2);
            printf("\n %.2f / %.2f = %.2f\n", num1, num2, result);
            break;

        case 5:
            printf("\n Enter number: ");
            scanf("%f", &num1);

            printf("\n Enter power: ");
            scanf("%f", &num2);

            result = power(num1, num2);
            printf("\n %.2f ^ %.2f = %.2f\n", num1, num2, result);
            break;

        case 6:
            printf("\n Enter number: ");
            scanf("%f", &num1);

            result = factorial(num1);
            printf("\n Factorial of %.2f = %.2f\n", num1, result);
            break;

        case 7:
            printf("\n Enter angle in degrees: ");
            scanf("%f", &num1);

            result = sin_func(num1);
            printf("\n Sin(%.2f) = %.2f\n", num1, result);
            break;

        case 8:
            printf("\n Enter angle in degrees: ");
            scanf("%f", &num1);

            result = cos_func(num1);
            printf("\n Cos(%.2f) = %.2f\n", num1, result);
            break;

        case 9:
            printf("\n Enter angle in degrees: ");
            scanf("%f", &num1);

            result = tan_func(num1);
            printf("\n Tan(%.2f) = %.2f\n", num1, result);
            break;

        case 10:
            printf("\n Enter number: ");
            scanf("%f", &num1);

            result = sq_rt(num1);
            printf("\n Square root of %.2f = %.2f\n", num1, result);
            break;

        default:
            printf("\n Invalid choice! Please choose a number from 1-10. \n");
    }

    return 0;
}

float add(float num1, float num2)
{
    return num1 + num2;
}

float subtract(float num1, float num2)
{
    return num1 - num2;
}

float multiply(float num1, float num2)
{
    return num1 * num2;
}

float divide(float num1, float num2)
{
    return num1 / num2;
}

float power(float num1, float num2)
{
    return pow(num1, num2);
}

float factorial(float num)
{
    float result = 1;

    for (int i = num; i > 0; i--)
    {
        result *= i;
    }

    return result;
}

float sin_func(float num)
{
    return sin(num * M_PI / 180);
}

float cos_func(float num)
{
    return cos(num * M_PI / 180);
}

float tan_func(float num)
{
    return tan(num * M_PI / 180);
}

float sq_rt(float num)
{
    return sqrt(num);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
double add(void); // weak
double subtract(void); // weak
double multiply(void); // weak
double divide(void); // weak
double power(void); // weak
double factorial(void); // weak
double sin_func(void); // weak
double cos_func(void); // weak
double tan_func(void); // weak
double sq_rt(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  __m128i v9; // xmm0
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  __m128i v12; // xmm0
  float v14; // [rsp+20h] [rbp-10h] BYREF
  float v15; // [rsp+24h] [rbp-Ch] BYREF
  int v16; // [rsp+28h] [rbp-8h] BYREF
  float v17; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("\n Welcome to the C Scientific Calculator\n");
  printf(" -----------------------------\n");
  printf(" 1. Addition\n");
  printf(" 2. Subtraction\n");
  printf(" 3. Multiplication\n");
  printf(" 4. Division\n");
  printf(" 5. Power\n");
  printf(" 6. Factorial\n");
  printf(" 7. Sin\n");
  printf(" 8. Cos\n");
  printf(" 9. Tan\n");
  printf(" 10. Square Root\n");
  printf(" -----------------------------\n");
  printf("Enter your choice: ");
  scanf("%d", &v16);
  switch ( v16 )
  {
    case 1:
      printf("\n Enter number 1: ");
      scanf("%f", &v15);
      printf("\n Enter number 2: ");
      scanf("%f", &v14);
      v3 = _mm_cvtsi32_si128(LODWORD(v15));
      *(double *)v3.m128i_i64 = add();
      v17 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
      printf("\n %.2f + %.2f = %.2f\n", v15, v14, v17);
      break;
    case 2:
      printf("\n Enter number 1: ");
      scanf("%f", &v15);
      printf("\n Enter number 2: ");
      scanf("%f", &v14);
      v4 = _mm_cvtsi32_si128(LODWORD(v15));
      *(double *)v4.m128i_i64 = subtract();
      v17 = COERCE_FLOAT(_mm_cvtsi128_si32(v4));
      printf("\n %.2f - %.2f = %.2f\n", v15, v14, v17);
      break;
    case 3:
      printf("\n Enter number 1: ");
      scanf("%f", &v15);
      printf("\n Enter number 2: ");
      scanf("%f", &v14);
      v5 = _mm_cvtsi32_si128(LODWORD(v15));
      *(double *)v5.m128i_i64 = multiply();
      v17 = COERCE_FLOAT(_mm_cvtsi128_si32(v5));
      printf("\n %.2f x %.2f = %.2f\n", v15, v14, v17);
      break;
    case 4:
      printf("\n Enter number 1: ");
      scanf("%f", &v15);
      printf("\n Enter number 2: ");
      scanf("%f", &v14);
      v6 = _mm_cvtsi32_si128(LODWORD(v15));
      *(double *)v6.m128i_i64 = divide();
      v17 = COERCE_FLOAT(_mm_cvtsi128_si32(v6));
      printf("\n %.2f / %.2f = %.2f\n", v15, v14, v17);
      break;
    case 5:
      printf("\n Enter number: ");
      scanf("%f", &v15);
      printf("\n Enter power: ");
      scanf("%f", &v14);
      v7 = _mm_cvtsi32_si128(LODWORD(v15));
      *(double *)v7.m128i_i64 = power();
      v17 = COERCE_FLOAT(_mm_cvtsi128_si32(v7));
      printf("\n %.2f ^ %.2f = %.2f\n", v15, v14, v17);
      break;
    case 6:
      printf("\n Enter number: ");
      scanf("%f", &v15);
      v8 = _mm_cvtsi32_si128(LODWORD(v15));
      *(double *)v8.m128i_i64 = factorial();
      v17 = COERCE_FLOAT(_mm_cvtsi128_si32(v8));
      printf("\n Factorial of %.2f = %.2f\n", v15, v17);
      break;
    case 7:
      printf("\n Enter angle in degrees: ");
      scanf("%f", &v15);
      v9 = _mm_cvtsi32_si128(LODWORD(v15));
      *(double *)v9.m128i_i64 = sin_func();
      v17 = COERCE_FLOAT(_mm_cvtsi128_si32(v9));
      printf("\n Sin(%.2f) = %.2f\n", v15, v17);
      break;
    case 8:
      printf("\n Enter angle in degrees: ");
      scanf("%f", &v15);
      v10 = _mm_cvtsi32_si128(LODWORD(v15));
      *(double *)v10.m128i_i64 = cos_func();
      v17 = COERCE_FLOAT(_mm_cvtsi128_si32(v10));
      printf("\n Cos(%.2f) = %.2f\n", v15, v17);
      break;
    case 9:
      printf("\n Enter angle in degrees: ");
      scanf("%f", &v15);
      v11 = _mm_cvtsi32_si128(LODWORD(v15));
      *(double *)v11.m128i_i64 = tan_func();
      v17 = COERCE_FLOAT(_mm_cvtsi128_si32(v11));
      printf("\n Tan(%.2f) = %.2f\n", v15, v17);
      break;
    case 10:
      printf("\n Enter number: ");
      scanf("%f", &v15);
      v12 = _mm_cvtsi32_si128(LODWORD(v15));
      *(double *)v12.m128i_i64 = sq_rt();
      v17 = COERCE_FLOAT(_mm_cvtsi128_si32(v12));
      printf("\n Square root of %.2f = %.2f\n", v15, v17);
      break;
    default:
      printf("\n Invalid choice! Please choose a number from 1-10. \n");
      break;
  }
  return 0;
}
// 140001E0B: using guessed type double add(void);
// 140001E25: using guessed type double subtract(void);
// 140001E3F: using guessed type double multiply(void);
// 140001E59: using guessed type double divide(void);
// 140001E73: using guessed type double power(void);
// 140001EB4: using guessed type double factorial(void);
// 140001F08: using guessed type double sin_func(void);
// 140001F4F: using guessed type double cos_func(void);
// 140001F96: using guessed type double tan_func(void);
// 140001FDD: using guessed type double sq_rt(void);
// 1400020C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=197 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Error handling ; Style: brave
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int num1, num2, result;
    printf("Enter two integers: ");
    if(scanf("%d %d", &num1, &num2) != 2) {
        printf("Invalid input. Please enter two integers.\n");
        exit(1);
    }
    if(num2 == 0) {
        printf("Error: division by zero.\n");
        exit(1);
    }
    result = num1 / num2;
    if(result == 0) {
        printf("Error: division resulted in zero.\n");
        exit(1);
    }
    printf("%d divided by %d is %d\n", num1, num2, result);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  int v5; // [rsp+28h] [rbp-8h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter two integers: ");
  if ( scanf("%d %d", &v5, &v4) != 2 )
  {
    printf("Invalid input. Please enter two integers.\n");
    exit(1);
  }
  if ( !v4 )
  {
    printf("Error: division by zero.\n");
    exit(1);
  }
  v6 = v5 / v4;
  if ( !(v5 / v4) )
  {
    printf("Error: division resulted in zero.\n");
    exit(1);
  }
  printf("%d divided by %d is %d\n", (unsigned int)v5, (unsigned int)v4, v6);
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: detailed
#include <stdio.h>

// Function to perform insertion sort
void insertionSort(int arr[], int n)
{
    int i, key, j;
    for (i = 1; i < n; i++)
    {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key)
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

// Function to perform fractional knapsack algorithm
double fractionalKnapsack(int W, int n, int wt[], int val[])
{
    double maxVal = 0.0;
    double frac[n];
    int i;

    // Calculate the value per unit weight of each item
    for(i=0; i<n; i++)
        frac[i] = (double)val[i] / (double)wt[i];

    // Perform insertion sort on the array containing value per unit weight of each item
    insertionSort(frac, n);

    // Take items that give the maximum value till knapsack capacity is reached
    for(i=n-1; i>=0; i--)
    {
        if(wt[i] <= W)
        {
            W -= wt[i];
            maxVal += val[i];
        }
        else
        {
            maxVal += (double)W * frac[i];
            W = 0;
            break;
        }
    }

    return maxVal;
}

int main()
{
    int W = 50; // Maximum capacity of knapsack
    int val[] = {60, 100, 120}; // Array containing values of each item
    int wt[] = {10, 20, 30}; // Array containing weights of each item
    int n = sizeof(val)/sizeof(val[0]); // Number of items

    double maxVal = fractionalKnapsack(W, n, wt, val);

    printf("Maximum value in the knapsack = %f\n", maxVal);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
double __fastcall fractionalKnapsack(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001818) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[3]; // [rsp+28h] [rbp-28h] BYREF
  int v5[3]; // [rsp+34h] [rbp-1Ch] BYREF
  double v6; // [rsp+40h] [rbp-10h]
  int v7; // [rsp+48h] [rbp-8h]
  int v8; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 50;
  v5[0] = 60;
  v5[1] = 100;
  v5[2] = 120;
  v4[0] = 10;
  v4[1] = 20;
  v4[2] = 30;
  v7 = 3;
  v6 = fractionalKnapsack(50i64, 3i64, v4, v5);
  printf("Maximum value in the knapsack = %f\n", v6);
  return 0;
}
// 14000165B: using guessed type double __fastcall fractionalKnapsack(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001960: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cryptographic hash function ; Style: retro
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BLOCK_SIZE 64 // Block size in bytes
#define HASH_SIZE 32 // Hash size in bytes
#define WORD_SIZE 4 // Word size in bytes
#define ROTR(x, n) (((x) >> (n)) | ((x) << (32 - (n)))) // Rotate right
#define CH(x, y, z) (((x) & (y)) ^ ((~(x)) & (z))) // Choose
#define MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z))) // Majority
#define BSIG0(x) (ROTR((x), 2) ^ ROTR((x), 13) ^ ROTR((x), 22)) // Big sigma 0
#define BSIG1(x) (ROTR((x), 6) ^ ROTR((x), 11) ^ ROTR((x), 25)) // Big sigma 1
#define SSIG0(x) (ROTR((x), 7) ^ ROTR((x), 18) ^ ((x) >> 3)) // Small sigma 0
#define SSIG1(x) (ROTR((x), 17) ^ ROTR((x), 19) ^ ((x) >> 10)) // Small sigma 1

typedef struct state_t {
    unsigned char data[BLOCK_SIZE];
    unsigned int datalen;
    unsigned long long bitlen;
    unsigned int state[HASH_SIZE / WORD_SIZE];
} state;

const unsigned int K[] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

void init(state *s) {
    s->datalen = 0;
    s->bitlen = 0;
    s->state[0] = 0x6a09e667;
    s->state[1] = 0xbb67ae85;
    s->state[2] = 0x3c6ef372;
    s->state[3] = 0xa54ff53a;
    s->state[4] = 0x510e527f;
    s->state[5] = 0x9b05688c;
    s->state[6] = 0x1f83d9ab;
    s->state[7] = 0x5be0cd19;
}

void transform(state *s, const unsigned char* data) {
    unsigned int a, b, c, d, e, f, g, h, i, j, t1, t2, m[HASH_SIZE / WORD_SIZE];

    for (i = 0, j = 0; i < BLOCK_SIZE; ++i, j += 4) {
        m[i / WORD_SIZE] |= (unsigned int)data[j] << ((i % WORD_SIZE) * 8);
    }

    a = s->state[0];
    b = s->state[1];
    c = s->state[2];
    d = s->state[3];
    e = s->state[4];
    f = s->state[5];
    g = s->state[6];
    h = s->state[7];

    for (i = 0; i < 64; ++i) {
        if (i < 16) {
            t1 = m[i];
        } else {
            t1 = m[(i + 1) % 16];
            t1 = SSIG0(t1);
            t1 += m[(i + 14) % 16];
            t1 = SSIG1(t1);
            t1 += m[i % 16];
        }

        t1 += h;
        t1 += BSIG1(e);
        t1 += CH(e, f, g);
        t1 += K[i];
        t2 = BSIG0(a);
        t2 += MAJ(a, b, c);

        h = g;
        g = f;
        f = e;
        e = d + t1;
        d = c;
        c = b;
        b = a;
        a = t1 + t2;
    }

    s->state[0] += a;
    s->state[1] += b;
    s->state[2] += c;
    s->state[3] += d;
    s->state[4] += e;
    s->state[5] += f;
    s->state[6] += g;
    s->state[7] += h;
}

void update(state *s, const unsigned char *data, unsigned int len) {
    for (unsigned int i = 0; i < len; ++i) {
        s->data[s->datalen] = data[i];
        ++s->datalen;
        if (s->datalen == BLOCK_SIZE) {
            transform(s, s->data);
            s->bitlen += BLOCK_SIZE * 8;
            s->datalen = 0;
        }
    }
}

void final(state *s, unsigned char *hash) {
    unsigned int i;

    i = s->datalen;

    // Pad whatever data is left in the buffer.
    if (s->datalen < 56) {
        s->data[i++] = 0x80;
        while (i < 56) {
            s->data[i++] = 0x00;
        }
    } else {
        s->data[i++] = 0x80;
        while (i < BLOCK_SIZE) {
            s->data[i++] = 0x00;
        }
        transform(s, s->data);
        memset(s->data, 0, 56);
    }

    // Append to the padding the total message's length in bits and transform.
    s->bitlen += s->datalen * 8;
    s->data[63] = s->bitlen;
    s->data[62] = s->bitlen >> 8;
    s->data[61] = s->bitlen >> 16;
    s->data[60] = s->bitlen >> 24;
    s->data[59] = s->bitlen >> 32;
    s->data[58] = s->bitlen >> 40;
    s->data[57] = s->bitlen >> 48;
    s->data[56] = s->bitlen >> 56;
    transform(s, s->data);

    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.
    for (i = 0; i < 4; ++i) {
        hash[i] = (s->state[0] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 4] = (s->state[1] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 8] = (s->state[2] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 12] = (s->state[3] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 16] = (s->state[4] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 20] = (s->state[5] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 24] = (s->state[6] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 28] = (s->state[7] >> (24 - i * 8)) & 0x000000ff;
    }
}

int main() {
    state s;
    unsigned char hash[HASH_SIZE];
    char message[] = "The quick brown fox jumps over the lazy dog";
    init(&s);
    update(&s, (unsigned char*)message, strlen(message));
    final(&s, hash);

    printf("Hash: ");
    for (int i = 0; i < HASH_SIZE; ++i) {
        printf("%02x", hash[i]);
    }
    printf("\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall init(_QWORD); // weak
__int64 __fastcall update(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall final(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (0000000140001C24) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char Str[48]; // [rsp+20h] [rbp-D0h] BYREF
  char v6[32]; // [rsp+50h] [rbp-A0h] BYREF
  char v7[124]; // [rsp+70h] [rbp-80h] BYREF
  int i; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  strcpy(Str, "The quick brown fox jumps over the lazy dog");
  init(v7);
  v3 = strlen(Str);
  update(v7, Str, v3);
  final(v7, v6);
  printf("Hash: ");
  for ( i = 0; i <= 31; ++i )
    printf("%02x", (unsigned __int8)v6[i]);
  printf("\n");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall init(_QWORD);
// 1400018B0: using guessed type __int64 __fastcall update(_QWORD, _QWORD, _QWORD);
// 14000194D: using guessed type __int64 __fastcall final(_QWORD, _QWORD);
// 140001DF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001C24: using guessed type char var_A0[32];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Rogue-like Game with Procedural Generation ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define WIDTH 50
#define HEIGHT 20
#define MAX_ROOMS 10

typedef struct Room{
    int x, y, w, h;
} room;

typedef struct Map{
    char layout[WIDTH][HEIGHT];
    room rooms[MAX_ROOMS];
    int num_rooms;
} map;

void init_map(map* m){
    // Initialize layout to be all walls
    for(int i = 0; i < WIDTH; i++){
        for(int j = 0; j < HEIGHT; j++){
            m->layout[i][j] = '#';
        }
    }

    // Generate rooms
    for(int i = 0; i < MAX_ROOMS; i++){
        int x = rand() % (WIDTH - 10) + 1;
        int y = rand() % (HEIGHT - 6) + 1;
        int w = rand() % 8 + 4;
        int h = rand() % 4 + 3;

        // Check for overlapping rooms
        for(int j = 0; j < m->num_rooms; j++){
            room r = m->rooms[j];
            if(x < r.x + r.w && x + w > r.x && y < r.y + r.h && y + h > r.y){
                x = rand() % (WIDTH - 10) + 1;
                y = rand() % (HEIGHT - 6) + 1;
                j = -1;
            }
        }

        // Add room to map
        m->rooms[i].x = x;
        m->rooms[i].y = y;
        m->rooms[i].w = w;
        m->rooms[i].h = h;
        m->num_rooms++;
    }

    // Connect rooms with corridors
    for(int i = 0; i < m->num_rooms - 1; i++){
        int x1 = m->rooms[i].x + m->rooms[i].w/2;
        int y1 = m->rooms[i].y + m->rooms[i].h/2;
        int x2 = m->rooms[i+1].x + m->rooms[i+1].w/2;
        int y2 = m->rooms[i+1].y + m->rooms[i+1].h/2;
        
        while(x1 != x2 || y1 != y2){
            if(x1 < x2){
                x1++;
            } else if(x1 > x2){
                x1--;
            }

            if(y1 < y2){
                y1++;
            } else if(y1 > y2){
                y1--;
            }

            m->layout[x1][y1] = '.';
        }
    }
}

void print_map(map* m){
    for(int j = 0; j < HEIGHT; j++){
        for(int i = 0; i < WIDTH; i++){
            printf("%c ", m->layout[i][j]);
        }
        printf("\n");
    }
}

int main(){
    srand(time(NULL));

    map m;
    init_map(&m);
    print_map(&m);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 __fastcall init_map(_QWORD); // weak
__int64 __fastcall print_map(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001A63) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[1168]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  init_map(v5);
  print_map(v5);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall init_map(_QWORD);
// 1400019DF: using guessed type __int64 __fastcall print_map(_QWORD);
// 140001B60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Electronic Voting System ; Style: real-life
#include <stdio.h>
#include <stdlib.h>

struct candidate{
    int id;
    char name[50];
    int votes;
};

int main(){
    int num_candidates;
    printf("Enter the number of candidates: ");
    scanf("%d", &num_candidates);
    struct candidate candidates[num_candidates];
    int voter_id = 0;
    int has_voted[num_candidates];
    for(int i = 0; i < num_candidates; i++){
        has_voted[i] = 0;
        printf("Enter the name of candidate %d: ", i+1);
        scanf("%s", candidates[i].name);
        candidates[i].id = i+1;
        candidates[i].votes = 0;
    }
    while(voter_id != -1){
        printf("\nEnter voter ID (-1 to exit): ");
        scanf("%d", &voter_id);
        if(voter_id == -1){
            break;
        }
        if(voter_id > 1000 || voter_id < 1){
            printf("Invalid voter ID\n");
            continue;
        }
        int has_voted_before = 0;
        for(int i = 0; i < num_candidates; i++){
            if(has_voted[i] == voter_id){
                printf("This voter has already voted\n");
                has_voted_before = 1;
                break;
            }
        }
        if(has_voted_before){
            continue;
        }
        int vote_cast = 0;
        while(!vote_cast){
            printf("\nEnter candidate ID to vote for: ");
            int vote_id;
            scanf("%d", &vote_id);
            if(vote_id > num_candidates || vote_id < 1){
                printf("Invalid candidate ID\n");
                continue;
            }
            candidates[vote_id-1].votes++;
            has_voted[vote_id-1] = voter_id;
            printf("Vote successfully cast for %s\n", candidates[vote_id-1].name);
            vote_cast = 1;
        }
    }
    printf("\n** ELECTION RESULTS **\n");
    for(int i = 0; i < num_candidates; i++){
        printf("%d. %s - %d votes\n", candidates[i].id, candidates[i].name, candidates[i].votes);
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  void *v4; // rsp
  __int64 v6[3]; // [rsp+20h] [rbp-60h] BYREF
  int v7; // [rsp+3Ch] [rbp-44h] BYREF
  int v8; // [rsp+40h] [rbp-40h] BYREF
  int v9; // [rsp+44h] [rbp-3Ch] BYREF
  __int64 *v10; // [rsp+48h] [rbp-38h]
  __int64 v11; // [rsp+50h] [rbp-30h]
  __int64 *v12; // [rsp+58h] [rbp-28h]
  __int64 v13; // [rsp+60h] [rbp-20h]
  int k; // [rsp+6Ch] [rbp-14h]
  int v15; // [rsp+70h] [rbp-10h]
  int j; // [rsp+74h] [rbp-Ch]
  int v17; // [rsp+78h] [rbp-8h]
  int i; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of candidates: ");
  scanf("%d", &v9);
  v13 = v9 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(60i64 * v9 + 15) >> 4));
  v12 = v6;
  v8 = 0;
  v11 = v13;
  v6[0] = v9;
  v6[1] = 0i64;
  v4 = alloca(16 * ((unsigned __int64)(4i64 * v9 + 15) >> 4));
  v10 = v6;
  for ( i = 0; i < v9; ++i )
  {
    *((_DWORD *)v10 + i) = 0;
    printf("Enter the name of candidate %d: ", (unsigned int)(i + 1));
    scanf("%s", (char *)v12 + 60 * i + 4);
    *((_DWORD *)v12 + 15 * i) = i + 1;
    *((_DWORD *)v12 + 15 * i + 14) = 0;
  }
  while ( v8 != -1 )
  {
    printf("\nEnter voter ID (-1 to exit): ");
    scanf("%d", &v8);
    if ( v8 == -1 )
      break;
    if ( v8 <= 1000 && v8 > 0 )
    {
      v17 = 0;
      for ( j = 0; j < v9; ++j )
      {
        if ( *((_DWORD *)v10 + j) == v8 )
        {
          printf("This voter has already voted\n");
          v17 = 1;
          break;
        }
      }
      if ( !v17 )
      {
        v15 = 0;
        while ( !v15 )
        {
          printf("\nEnter candidate ID to vote for: ");
          scanf("%d", &v7);
          if ( v7 <= v9 && v7 > 0 )
          {
            ++*((_DWORD *)v12 + 15 * v7 - 1);
            *((_DWORD *)v10 + v7 - 1) = v8;
            printf("Vote successfully cast for %s\n", (const char *)v12 + 60 * v7 - 56);
            v15 = 1;
          }
          else
          {
            printf("Invalid candidate ID\n");
          }
        }
      }
    }
    else
    {
      printf("Invalid voter ID\n");
    }
  }
  printf("\n** ELECTION RESULTS **\n");
  for ( k = 0; k < v9; ++k )
    printf(
      "%d. %s - %d votes\n",
      *((unsigned int *)v12 + 15 * k),
      (const char *)v12 + 60 * k + 4,
      *((unsigned int *)v12 + 15 * k + 14));
  return 0;
}
// 140001B10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: irregular
#include <stdio.h>

// Function prototypes
void printFibonacci(int n);

int main() {
    int n;

    // Get input from user
    printf("Enter the number of terms for the Fibonacci sequence: ");
    scanf("%d", &n);

    // Print the sequence
    printFibonacci(n);

    return 0;
}

// Function to print the Fibonacci sequence
void printFibonacci(int n) {
    int a = 0, b = 1, c, i;

    // Print the first two terms of the sequence
    printf("%d %d ", a, b);

    // Print the rest of the terms in the sequence
    for(i = 2; i < n; i++) {
        c = a + b;
        a = b;
        b = c;

        // Print the term with some visual flair
        if(c % 3 == 0 && c % 5 == 0) {
            printf("*%d* ", c);
        }
        else if(c % 3 == 0) {
            printf("+%d+ ", c);
        }
        else if(c % 5 == 0) {
            printf("#%d# ", c);
        }
        else {
            printf("%d ", c);
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall printFibonacci(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the number of terms for the Fibonacci sequence: ");
  scanf("%d", &v4);
  printFibonacci(v4);
  return 0;
}
// 140001629: using guessed type __int64 __fastcall printFibonacci(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Global Variables */
char filename[] = "my_diary.txt";

/* Function Prototypes */
void menu();
void add_entry();
void view_entries();
void delete_entry();

int main()
{
    menu();
    return 0;
}

void menu()
{
    int choice;

    printf("Welcome to your Digital Diary!\n");
    printf("Please select an option:\n");
    printf("1. Add an entry\n");
    printf("2. View entries\n");
    printf("3. Delete an entry\n");
    printf("4. Exit\n");

    scanf("%d", &choice);

    switch(choice)
    {
        case 1:
            add_entry();
            break;
        case 2:
            view_entries();
            break;
        case 3:
            delete_entry();
            break;
        case 4:
            printf("Thank you for using Digital Diary!\n");
            exit(0);
            break;
        default:
            printf("Invalid option, please try again.\n");
            menu();
            break;
    }
}

void add_entry()
{
    char entry[500];
    FILE *fp;

    fp = fopen(filename, "a");

    printf("\nEnter your diary entry (max 500 characters):\n");
    scanf(" %[^\n]", entry);

    fprintf(fp, "%s\n", entry);

    printf("\nEntry added successfully!\n");

    fclose(fp);

    menu();
}

void view_entries()
{
    FILE *fp;
    char buffer[1000];

    fp = fopen(filename, "r");

    printf("\nYour previous entries:\n");

    while(fgets(buffer, 1000, fp))
    {
        printf("%s", buffer);
    }

    fclose(fp);

    menu();
}

void delete_entry()
{
    FILE *tempfp, *fp;
    char buffer[1000], entry[1000], confirm;
    int line = 1, count = 0;

    fp = fopen(filename, "r");

    printf("Enter the number of the entry you want to delete:\n");

    while(fgets(buffer, 1000, fp))
    {
        printf("%d. %s", line, buffer);
        line++;
    }

    fclose(fp);

    scanf("%d", &line);

    fp = fopen(filename, "r");
    tempfp = fopen("temp.txt", "w");

    while(fgets(buffer, 1000, fp))
    {
        count++;

        if(count != line)
        {
            fprintf(tempfp, "%s", buffer);
        }
        else
        {
            strcpy(entry, buffer);
        }
    }

    fclose(fp);
    fclose(tempfp);

    printf("\nAre you sure you want to delete this entry? (Y/N)\n");
    scanf(" %c", &confirm);

    if(confirm == 'Y' || confirm == 'y')
    {
        remove(filename);
        rename("temp.txt", filename);

        printf("\n%sEntry deleted successfully!\n", entry);
    }
    else
    {
        remove("temp.txt");
        printf("\nEntry not deleted.\n");
    }

    menu();
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 menu(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  menu();
  return 0;
}
// 140001642: using guessed type __int64 menu(void);
// 140001B40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Huffman Coding Implementation ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

typedef struct MinHeapNode {
  char data;
  unsigned freq;
  struct MinHeapNode *left, *right;
} MinHeapNode;

typedef struct MinHeap {
  unsigned size;
  unsigned capacity;
  struct MinHeapNode **array;
} MinHeap;

MinHeapNode* newNode(char data, unsigned freq) {
  MinHeapNode* temp = (MinHeapNode*)malloc(sizeof(MinHeapNode));
  temp->left = temp->right = NULL;
  temp->data = data;
  temp->freq = freq;
  return temp;
}

MinHeap* createMinHeap(unsigned capacity) {
  MinHeap* minHeap = (MinHeap*)malloc(sizeof(MinHeap));
  minHeap->size = 0;
  minHeap->capacity = capacity;
  minHeap->array = (MinHeapNode**)malloc(minHeap->capacity * sizeof(MinHeapNode*));
  return minHeap;
}

void swapMinHeapNode(MinHeapNode** a, MinHeapNode** b) {
  MinHeapNode* t = *a;
  *a = *b;
  *b = t;
}

void minHeapify(MinHeap* minHeap, int idx) {
  int smallest = idx;
  int left = 2 * idx + 1;
  int right = 2 * idx + 2;
  if (left < minHeap->size && minHeap->array[left]->freq < minHeap->array[smallest]->freq)
    smallest = left;
  if (right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq)
    smallest = right;
  if (smallest != idx) {
    swapMinHeapNode(&minHeap->array[smallest], &minHeap->array[idx]);
    minHeapify(minHeap, smallest);
  }
}

int isSizeOne(MinHeap* minHeap) {
  return minHeap->size == 1;
}

MinHeapNode* extractMin(MinHeap* minHeap) {
  MinHeapNode* temp = minHeap->array[0];
  minHeap->array[0] = minHeap->array[minHeap->size - 1];
  --minHeap->size;
  minHeapify(minHeap, 0);
  return temp;
}

void insertMinHeap(MinHeap* minHeap, MinHeapNode* minHeapNode) {
  ++minHeap->size;
  int i = minHeap->size - 1;
  while (i && minHeapNode->freq < minHeap->array[(i - 1) / 2]->freq) {
    minHeap->array[i] = minHeap->array[(i - 1) / 2];
    i = (i - 1) / 2;
  }
  minHeap->array[i] = minHeapNode;
}

void buildMinHeap(MinHeap* minHeap) {
  int n = minHeap->size - 1;
  int i;
  for (i = (n - 1) / 2; i >= 0; --i) minHeapify(minHeap, i);
}

void printArr(int arr[], int n) {
  int i;
  for (i = 0; i < n; ++i) printf("%d", arr[i]);
  printf("\n");
}

int isLeaf(MinHeapNode* root) {
  return !(root->left) && !(root->right);
}

MinHeap* createAndBuildMinHeap(char data[], int freq[], int size) {
  MinHeap* minHeap = createMinHeap(size);
  for (int i = 0; i < size; ++i) minHeap->array[i] = newNode(data[i], freq[i]);
  minHeap->size = size;
  buildMinHeap(minHeap);
  return minHeap;
}

MinHeapNode* buildHuffmanTree(char data[], int freq[], int size) {
  MinHeapNode *left, *right, *top;
  MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);
  while (!isSizeOne(minHeap)) {
    left = extractMin(minHeap);
    right = extractMin(minHeap);
    top = newNode('$', left->freq + right->freq);
    top->left = left;
    top->right = right;
    insertMinHeap(minHeap, top);
  }
  return extractMin(minHeap);
}

void printCodes(MinHeapNode* root, int arr[], int top) {
  if (root->left) {
    arr[top] = 0;
    printCodes(root->left, arr, top + 1);
  }
  if (root->right) {
    arr[top] = 1;
    printCodes(root->right, arr, top + 1);
  }
  if (isLeaf(root)) {
    printf("  %c | ", root->data);
    printArr(arr, top);
  }
}

void HuffmanCodes(char data[], int freq[], int size) {
  MinHeapNode* root = buildHuffmanTree(data, freq, size);
  int arr[100], top = 0;
  printCodes(root, arr, top);
}

int main() {
  char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'};
  int freq[] = {5, 9, 12, 13, 16, 45};
  int size = sizeof(arr) / sizeof(arr[0]);
  printf("\nHuffman codes for the given input:\n");
  HuffmanCodes(arr, freq, size);
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall HuffmanCodes(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001C79) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[9]; // [rsp+20h] [rbp-30h] BYREF
  _BYTE v5[6]; // [rsp+46h] [rbp-Ah] BYREF

  _main(argc, argv, envp);
  qmemcpy(v5, "abcdef", sizeof(v5));
  v4[0] = 5;
  v4[1] = 9;
  v4[2] = 12;
  v4[3] = 13;
  v4[4] = 16;
  v4[5] = 45;
  printf("\nHuffman codes for the given input:\n");
  HuffmanCodes(v5, v4, 6i64);
  return 0;
}
// 140001BFE: using guessed type __int64 __fastcall HuffmanCodes(_QWORD, _QWORD, _QWORD);
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=151 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System administration ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

void print_file_contents(char *filename) {
    int fd;
    char buffer[1024];

    fd = open(filename, O_RDONLY);
    if (fd == -1) {
        printf("Error opening file %s\n", filename);
        exit(1);
    }

    ssize_t bytes_read;
    do {
        bytes_read = read(fd, buffer, sizeof(buffer));
        if (bytes_read == -1) {
            printf("Error reading from file %s\n", filename);
            exit(1);
        }

        ssize_t bytes_written;
        bytes_written = write(STDOUT_FILENO, buffer, bytes_read);
        if (bytes_written == -1) {
            printf("Error writing to stdout\n");
            exit(1);
        }
    } while (bytes_read > 0);

    close(fd);
}

int main(int argc, char** argv) {
    if (argc != 2) {
        printf("Usage: %s filename\n", argv[0]);
        exit(1);
    }

    char *filename = argv[1];

    struct stat statbuf;
    if (stat(filename, &statbuf) == -1) {
        printf("Error getting file size for %s\n", filename);
        exit(1);
    }

    printf("File size: %lld bytes\n", (long long) statbuf.st_size);

    mode_t old_mode = statbuf.st_mode;
    mode_t new_mode = old_mode | S_IRUSR;  // Add read permission for owner

    if (chmod(filename, new_mode) == -1) {
        printf("Error setting permission for %s\n", filename);
        exit(1);
    }

    printf("Read permission for owner added to %s\n", filename);

    printf("File contents:\n");
    print_file_contents(filename);

    if (chmod(filename, old_mode) == -1) {
        printf("Error restoring old permission for %s\n", filename);
        exit(1);
    }

    printf("Old permission restored for %s\n", filename);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall print_file_contents(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
static int __cdecl stat(const char *const FileName, struct stat *const Stat);
// int __cdecl chmod(const char *FileName, int AccessMode);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400016A0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned __int16 v3; // ax
  struct stat v5; // [rsp+20h] [rbp-40h] BYREF
  unsigned __int16 v6; // [rsp+54h] [rbp-Ch]
  unsigned __int16 st_mode; // [rsp+56h] [rbp-Ah]
  char *FileName; // [rsp+58h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc != 2 )
  {
    printf("Usage: %s filename\n", *argv);
    exit(1);
  }
  FileName = (char *)argv[1];
  if ( stat(FileName, &v5) == -1 )
  {
    printf("Error getting file size for %s\n", FileName);
    exit(1);
  }
  printf("File size: %lld bytes\n", v5.st_size);
  st_mode = v5.st_mode;
  LOBYTE(v3) = v5.st_mode;
  HIBYTE(v3) = HIBYTE(v5.st_mode) | 1;
  v6 = v3;
  if ( chmod(FileName, v3) == -1 )
  {
    printf("Error setting permission for %s\n", FileName);
    exit(1);
  }
  printf("Read permission for owner added to %s\n", FileName);
  printf("File contents:\n");
  print_file_contents(FileName);
  if ( chmod(FileName, st_mode) == -1 )
  {
    printf("Error restoring old permission for %s\n", FileName);
    exit(1);
  }
  printf("Old permission restored for %s\n", FileName);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall print_file_contents(_QWORD);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Subnet Calculator ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {

  printf("Welcome to the Subnet Calculator!\n");

  int choice = 0;
  printf("Enter a number between 1 and 10 to determine the level of subnetting:\n");
  scanf("%d", &choice);

  if (choice > 10) {
    printf("Sorry, your choice must be between 1 and 10. Try again later.\n");
  } else {
    printf("Calculating subnets...\n");

    srand(time(NULL));
    int subnet = 256 / choice;

    for (int i = 1; i <= choice; i++) {
      int network = i * subnet;
      printf("Subnet #%d: 192.168.1.%d\n", i, network);

      int host1 = rand() % subnet + network;
      int host2 = rand() % subnet + network;
      int host3 = rand() % subnet + network;
      int host4 = rand() % subnet + network;

      printf("Hosts within this subnet:\n");
      printf("192.168.1.%d\n", host1);
      printf("192.168.1.%d\n", host2);
      printf("192.168.1.%d\n", host3);
      printf("192.168.1.%d\n\n", host4);
    }
  }

  printf("Thank you for using the Subnet Calculator. Goodbye!\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v6; // [rsp+24h] [rbp-1Ch]
  unsigned int v7; // [rsp+28h] [rbp-18h]
  unsigned int v8; // [rsp+2Ch] [rbp-14h]
  unsigned int v9; // [rsp+30h] [rbp-10h]
  unsigned int v10; // [rsp+34h] [rbp-Ch]
  int v11; // [rsp+38h] [rbp-8h]
  unsigned int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Subnet Calculator!\n");
  v5 = 0;
  printf("Enter a number between 1 and 10 to determine the level of subnetting:\n");
  scanf("%d", &v5);
  if ( v5 <= 10 )
  {
    printf("Calculating subnets...\n");
    v3 = time(0i64);
    srand(v3);
    v11 = 256 / v5;
    for ( i = 1; (int)i <= v5; ++i )
    {
      v10 = v11 * i;
      printf("Subnet #%d: 192.168.1.%d\n", i, v11 * i);
      v9 = rand() % v11 + v10;
      v8 = rand() % v11 + v10;
      v7 = rand() % v11 + v10;
      v6 = rand() % v11 + v10;
      printf("Hosts within this subnet:\n");
      printf("192.168.1.%d\n", v9);
      printf("192.168.1.%d\n", v8);
      printf("192.168.1.%d\n", v7);
      printf("192.168.1.%d\n\n", v6);
    }
  }
  else
  {
    printf("Sorry, your choice must be between 1 and 10. Try again later.\n");
  }
  printf("Thank you for using the Subnet Calculator. Goodbye!\n");
  return 0;
}
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Haunted House Simulator ; Style: retro
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>

/* function prototypes */
void print_boundary();
void print_intro();
void print_ghost();
void print_end();

int main() {
    char name[20];
    int choice, room_num = 1;
    int has_key = 0, has_flashlight = 0;
    int locked_room_num = rand() % 5 + 1;
    char answer;

    /* set random seed */
    srand(time(NULL));

    /* print intro */
    print_intro();

    /* get player name */
    printf("What's your name? ");
    fgets(name, 20, stdin);

    /* game loop */
    while (room_num <= 5) {
        printf("\n\nYou are in room %d.\n\n", room_num);

        /* print ghost in second room */
        if (room_num == 2) {
            print_ghost();
        }

        /* print locked door in random room */
        if (room_num == locked_room_num && !has_key) {
            printf("The door is locked. You need a key to open it.\n");
        }
        else {
            printf("There is a door to the next room.\n");
        }

        /* print flashlight in first room */
        if (room_num == 1 && !has_flashlight) {
            printf("There is a flashlight on the ground.\n");
        }

        /* get player choice */
        printf("What do you want to do?\n");
        printf("1. Go to the next room.\n");
        printf("2. Look for items.\n");
        printf("3. Quit.\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        fflush(stdin);

        /* handle player choice */
        switch (choice) {
            case 1:
                /* move to next room */
                if (room_num == locked_room_num && !has_key) {
                    printf("The door is locked. You need a key to open it.\n");
                }
                else {
                    printf("You go to the next room.\n");
                    room_num++;
                }
                break;
            case 2:
                /* search for items */
                if (room_num == 1 && !has_flashlight) {
                    printf("You pick up the flashlight.\n");
                    has_flashlight = 1;
                }
                else if (room_num == locked_room_num && !has_key) {
                    printf("You found a key!\n");
                    has_key = 1;
                }
                else {
                    printf("You didn't find anything.\n");
                }
                break;
            case 3:
                /* quit game */
                printf("Are you sure you want to quit? (y/n) ");
                scanf(" %c", &answer);
                if (tolower(answer) == 'y') {
                    printf("Thanks for playing, %s!\n", name);
                    return 0;
                }
                break;
            default:
                /* invalid input */
                printf("Invalid input. Please try again.\n");
        }
    }

    /* player reached the end */
    print_end();
    printf("Congratulations, %s! You made it out alive!\n", name);

    return 0;
}

/* function definitions */

void print_boundary() {
    printf("==============================================\n");
}

void print_intro() {
    print_boundary();
    printf("Welcome to the Haunted House Simulator!\n");
    print_boundary();
    printf("You find yourself trapped in a haunted house.\n");
    printf("Find your way out before it's too late!\n");
}

void print_ghost() {
    printf("You see a ghost standing in front of you!\n");
    printf("It vanishes as soon as you blink...\n");
}

void print_end() {
    print_boundary();
    printf("Congratulations, you made it to the END!\n");
    print_boundary();
    printf("          |         |         |\n");
    printf("        _/ \\_     _/ \\_     _/ \\_\n");
    printf("       |     |   |     |   |     |\n");
    printf("        \\_   _/     \\_   _/     \\_\n");
    printf("          | |         | |         |\n");
    printf("          | |         | |         |\n");
    printf("          | |         | |         |\n");
    printf("          | |         | |         |\n");
    printf("       ___| |_     ___| |_     ___| |_\n");
    printf("      /  _|   \\   /  _|   \\   /  _|  \\\n");
    printf("     / /      /  / /      /  / /    |\\\n");
    printf("    /_/      /_/ /_/      /_/ /_/\\_| \\\n");
    printf("                                \\____/\n");
    print_boundary();
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 print_intro(void); // weak
__int64 print_ghost(void); // weak
__int64 print_end(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fflush(FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *tolower)(int C);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  FILE *v4; // rax
  FILE *v5; // rax
  char v7; // [rsp+2Bh] [rbp-35h] BYREF
  int v8; // [rsp+2Ch] [rbp-34h] BYREF
  char Buffer[32]; // [rsp+30h] [rbp-30h] BYREF
  int v10; // [rsp+50h] [rbp-10h]
  int v11; // [rsp+54h] [rbp-Ch]
  int v12; // [rsp+58h] [rbp-8h]
  unsigned int v13; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v13 = 1;
  v12 = 0;
  v11 = 0;
  v10 = rand() % 5 + 1;
  v3 = time(0i64);
  srand(v3);
  print_intro();
  printf("What's your name? ");
  v4 = __acrt_iob_func(0);
  fgets(Buffer, 20, v4);
  while ( (int)v13 <= 5 )
  {
    printf("\n\nYou are in room %d.\n\n", v13);
    if ( v13 == 2 )
      print_ghost();
    if ( v13 != v10 || v12 )
      printf("There is a door to the next room.\n");
    else
      printf("The door is locked. You need a key to open it.\n");
    if ( v13 == 1 && !v11 )
      printf("There is a flashlight on the ground.\n");
    printf("What do you want to do?\n");
    printf("1. Go to the next room.\n");
    printf("2. Look for items.\n");
    printf("3. Quit.\n");
    printf("Enter your choice: ");
    scanf("%d", &v8);
    v5 = __acrt_iob_func(0);
    fflush(v5);
    if ( v8 == 3 )
    {
      printf("Are you sure you want to quit? (y/n) ");
      scanf(" %c", &v7);
      if ( tolower(v7) == 121 )
      {
        printf("Thanks for playing, %s!\n", Buffer);
        return 0;
      }
    }
    else
    {
      if ( v8 > 3 )
        goto LABEL_29;
      if ( v8 == 1 )
      {
        if ( v13 != v10 || v12 )
        {
          printf("You go to the next room.\n");
          ++v13;
        }
        else
        {
          printf("The door is locked. You need a key to open it.\n");
        }
      }
      else if ( v8 == 2 )
      {
        if ( v13 != 1 || v11 )
        {
          if ( v13 != v10 || v12 )
          {
            printf("You didn't find anything.\n");
          }
          else
          {
            printf("You found a key!\n");
            v12 = 1;
          }
        }
        else
        {
          printf("You pick up the flashlight.\n");
          v11 = 1;
        }
      }
      else
      {
LABEL_29:
        printf("Invalid input. Please try again.\n");
      }
    }
  }
  print_end();
  printf("Congratulations, %s! You made it out alive!\n", Buffer);
  return 0;
}
// 1400018EA: using guessed type __int64 print_intro(void);
// 140001930: using guessed type __int64 print_ghost(void);
// 14000195D: using guessed type __int64 print_end(void);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: multivariable
#include <stdio.h>
#include <math.h>

#define G 6.67408E-11 // Gravitational constant
#define TIME_STEP 10 // Time step in seconds

// Structure to store vector components
typedef struct {
    double x;
    double y;
    double z;
} Vector;

// Structure to store planet properties
typedef struct {
    char name[20];
    double mass;
    Vector position;
    Vector velocity;
} Planet;

// Function to calculate distance between two planets
double distance(Planet p1, Planet p2) {
    double dx = p1.position.x - p2.position.x;
    double dy = p1.position.y - p2.position.y;
    double dz = p1.position.z - p2.position.z;
    return sqrt(dx*dx + dy*dy + dz*dz);
}

// Function to calculate gravitational force between two planets
Vector gravity(Planet p1, Planet p2) {
    double r = distance(p1, p2);
    double f = (G * p1.mass * p2.mass) / (r*r);
    Vector dir = {p2.position.x - p1.position.x, p2.position.y - p1.position.y, p2.position.z - p1.position.z};
    double mag = sqrt(dir.x*dir.x + dir.y*dir.y + dir.z*dir.z);
    dir.x /= mag;
    dir.y /= mag;
    dir.z /= mag;
    Vector force = {dir.x * f, dir.y * f, dir.z * f};
    return force;
}

// Function to update planet position and velocity based on gravitational forces
void update(Planet *p, Planet *planets, int n) {
    Vector net_force = {0.0, 0.0, 0.0};
    for (int i = 0; i < n; i++) {
        if (p != &planets[i]) {
            net_force.x += gravity(*p, planets[i]).x;
            net_force.y += gravity(*p, planets[i]).y;
            net_force.z += gravity(*p, planets[i]).z;
        }
    }
    double ax = net_force.x / p->mass;
    double ay = net_force.y / p->mass;
    double az = net_force.z / p->mass;
    p->velocity.x += ax * TIME_STEP;
    p->velocity.y += ay * TIME_STEP;
    p->velocity.z += az * TIME_STEP;
    p->position.x += p->velocity.x * TIME_STEP;
    p->position.y += p->velocity.y * TIME_STEP;
    p->position.z += p->velocity.z * TIME_STEP;
}

int main() {
    // Define planets
    Planet sun = {"Sun", 1.989E+30, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
    Planet earth = {"Earth", 5.97E+24, {1.4710E+11, 0.0, 0.0}, {0.0, 30290.0, 0.0}};
    Planet mars = {"Mars", 6.39E+23, {0.0, 2.279E+11, 0.0}, {-24007.0, 0.0, 0.0}};
    Planet venus = {"Venus", 4.87E+24, {-1.0758E+11, 0.0, 0.0}, {0.0, -35020.0, 0.0}};
    Planet planets[4] = {sun, earth, mars, venus};
    int n = 4;

    // Run simulation for 1 year
    int seconds_in_year = 365*24*60*60;
    int steps = seconds_in_year / TIME_STEP; 
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < n; j++) {
            update(&planets[j], planets, n);
        }
    }

    // Print final positions of planets
    for (int i = 0; i < n; i++) {
        printf("%s position: %.2f, %.2f, %.2f\n", planets[i].name, planets[i].position.x, planets[i].position.y, planets[i].position.z);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall update(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001D63) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[10]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v5[32]; // [rsp+80h] [rbp+0h] BYREF
  __int64 v6; // [rsp+180h] [rbp+100h]
  __int64 v7; // [rsp+188h] [rbp+108h]
  __int64 v8; // [rsp+190h] [rbp+110h]
  __int64 v9; // [rsp+198h] [rbp+118h]
  __int64 v10; // [rsp+1A0h] [rbp+120h]
  __int64 v11; // [rsp+1A8h] [rbp+128h]
  __int64 v12; // [rsp+1B0h] [rbp+130h]
  __int64 v13; // [rsp+1B8h] [rbp+138h]
  __int64 v14; // [rsp+1C0h] [rbp+140h]
  __int64 v15; // [rsp+1C8h] [rbp+148h]
  __int64 v16; // [rsp+1D0h] [rbp+150h]
  __int64 v17; // [rsp+1D8h] [rbp+158h]
  __int64 v18; // [rsp+1E0h] [rbp+160h]
  __int64 v19; // [rsp+1E8h] [rbp+168h]
  __int64 v20; // [rsp+1F0h] [rbp+170h]
  __int64 v21; // [rsp+1F8h] [rbp+178h]
  __int64 v22; // [rsp+200h] [rbp+180h]
  __int64 v23; // [rsp+208h] [rbp+188h]
  __int64 v24; // [rsp+210h] [rbp+190h]
  __int64 v25; // [rsp+218h] [rbp+198h]
  __int64 v26; // [rsp+220h] [rbp+1A0h]
  __int64 v27; // [rsp+228h] [rbp+1A8h]
  __int64 v28; // [rsp+230h] [rbp+1B0h]
  __int64 v29; // [rsp+238h] [rbp+1B8h]
  __int64 v30; // [rsp+240h] [rbp+1C0h]
  __int64 v31; // [rsp+248h] [rbp+1C8h]
  __int64 v32; // [rsp+250h] [rbp+1D0h]
  __int64 v33; // [rsp+258h] [rbp+1D8h]
  __int64 v34; // [rsp+260h] [rbp+1E0h]
  __int64 v35; // [rsp+268h] [rbp+1E8h]
  __int64 v36; // [rsp+270h] [rbp+1F0h]
  __int64 v37; // [rsp+278h] [rbp+1F8h]
  __int64 v38; // [rsp+280h] [rbp+200h]
  __int64 v39; // [rsp+288h] [rbp+208h]
  __int64 v40; // [rsp+290h] [rbp+210h]
  __int64 v41; // [rsp+298h] [rbp+218h]
  __int64 v42; // [rsp+2A0h] [rbp+220h]
  __int64 v43; // [rsp+2A8h] [rbp+228h]
  int v44; // [rsp+2B8h] [rbp+238h]
  int v45; // [rsp+2BCh] [rbp+23Ch]
  int v46; // [rsp+2C0h] [rbp+240h]
  int k; // [rsp+2C4h] [rbp+244h]
  int j; // [rsp+2C8h] [rbp+248h]
  int i; // [rsp+2CCh] [rbp+24Ch]

  _main(argc, argv, envp);
  v34 = 7238995i64;
  v35 = 0i64;
  LODWORD(v36) = 0;
  v37 = 0x46391ACE3D05AEF4i64;
  v38 = 0i64;
  v39 = 0i64;
  v40 = 0i64;
  v41 = 0i64;
  v42 = 0i64;
  v43 = 0i64;
  v24 = 0x6874726145i64;
  v25 = 0i64;
  LODWORD(v26) = 0;
  v27 = 0x4513C0C964D9C187i64;
  v28 = 0x42411FEBEF800000i64;
  v29 = 0i64;
  v30 = 0i64;
  v31 = 0i64;
  v32 = 0x40DD948000000000i64;
  v33 = 0i64;
  v14 = 1936875853i64;
  v15 = 0i64;
  LODWORD(v16) = 0;
  v17 = 0x44E0EA084D181CD6i64;
  v18 = 0i64;
  v19 = 0x424A87F303800000i64;
  v20 = 0i64;
  v21 = 0xC0D771C000000000ui64;
  v22 = 0i64;
  v23 = 0i64;
  v5[30] = 0x73756E6556i64;
  v5[31] = 0i64;
  LODWORD(v6) = 0;
  v7 = 0x45101D0CEA7F08A4i64;
  v8 = 0xC2390C4487000000ui64;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0xC0E1198000000000ui64;
  v13 = 0i64;
  v4[0] = 7238995i64;
  v4[1] = 0i64;
  v4[2] = v36;
  v4[3] = 0x46391ACE3D05AEF4i64;
  memset(&v4[4], 0, 48);
  v5[0] = 0x6874726145i64;
  v5[1] = 0i64;
  v5[2] = v26;
  v5[3] = 0x4513C0C964D9C187i64;
  v5[4] = 0x42411FEBEF800000i64;
  memset(&v5[5], 0, 24);
  v5[8] = 0x40DD948000000000i64;
  v5[9] = 0i64;
  v5[10] = 1936875853i64;
  v5[11] = 0i64;
  v5[12] = v16;
  v5[13] = 0x44E0EA084D181CD6i64;
  v5[14] = 0i64;
  v5[15] = 0x424A87F303800000i64;
  v5[16] = 0i64;
  v5[17] = 0xC0D771C000000000ui64;
  v5[18] = 0i64;
  v5[19] = 0i64;
  v5[20] = 0x73756E6556i64;
  v5[21] = 0i64;
  v5[22] = v6;
  v5[23] = 0x45101D0CEA7F08A4i64;
  v5[24] = 0xC2390C4487000000ui64;
  memset(&v5[25], 0, 24);
  v5[28] = 0xC0E1198000000000ui64;
  v5[29] = 0i64;
  v46 = 4;
  v45 = 31536000;
  v44 = 3153600;
  for ( i = 0; i < v44; ++i )
  {
    for ( j = 0; j < v46; ++j )
      update(&v4[10 * j], v4, (unsigned int)v46);
  }
  for ( k = 0; k < v46; ++k )
    printf(
      "%s position: %.2f, %.2f, %.2f\n",
      (const char *)&v4[10 * k],
      *(double *)&v5[10 * k - 6],
      *(double *)&v5[10 * k - 5],
      *(double *)&v5[10 * k - 4]);
  return 0;
}
// 14000184D: using guessed type __int64 __fastcall update(_QWORD, _QWORD, _QWORD);
// 1400023E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Online Examination System ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//Struct for storing questions and answers
typedef struct {
    char question[100];
    char answer[50];
} Question;

//Function to display the questions and receive the answers from user
void display_questions(Question *questions, int num_questions)
{
    char input[50];
    int score = 0;

    for (int i = 0; i < num_questions; i++)
    {
        printf("\nQuestion %d: %s\n", i+1, questions[i].question);
        printf("Answer: ");
        scanf("%s", input);

        //If the answer is correct, increment score
        if (strcmp(input, questions[i].answer) == 0)
            score++;
    }

    printf("\n\nCongratulations! You have completed the exam.\n");
    printf("Your score: %d/%d\n", score, num_questions);
}

int main()
{
    //Creating questions and storing them in an array
    Question questions[5];
    strcpy(questions[0].question,"What is the capital of India?");
    strcpy(questions[0].answer,"New Delhi");
    strcpy(questions[1].question,"What is the currency of Japan?");
    strcpy(questions[1].answer,"Yen");
    strcpy(questions[2].question,"What is the largest continent?");
    strcpy(questions[2].answer,"Asia");
    strcpy(questions[3].question,"What is the smallest country in the world?");
    strcpy(questions[3].answer,"Vatican City");
    strcpy(questions[4].question,"What is the national animal of Australia?");
    strcpy(questions[4].answer,"Kangaroo");

    printf("Welcome to the C Online Examination System!\n");
    printf("You will be presented with 5 multiple choice questions.\n");
    printf("Please type your answer as a single word without spaces.\n\n");

    //Displaying the questions and receiving answers
    display_questions(questions, 5);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall display_questions(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016C4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[100]; // [rsp+20h] [rbp-60h] BYREF
  char v5[16]; // [rsp+84h] [rbp+4h] BYREF
  char v6[32]; // [rsp+B6h] [rbp+36h] BYREF
  int v7; // [rsp+11Ah] [rbp+9Ah]
  char v8[32]; // [rsp+14Ch] [rbp+CCh] BYREF
  char v9[8]; // [rsp+1B0h] [rbp+130h] BYREF
  char v10[48]; // [rsp+1E2h] [rbp+162h] BYREF
  char v11[16]; // [rsp+246h] [rbp+1C6h] BYREF
  char v12[48]; // [rsp+278h] [rbp+1F8h] BYREF
  char v13[16]; // [rsp+2DCh] [rbp+25Ch] BYREF

  _main(argc, argv, envp);
  strcpy(v4, "What is the capital of India?");
  strcpy(v5, "New Delhi");
  strcpy(v6, "What is the currency of Japan?");
  v7 = 7234905;
  strcpy(v8, "What is the largest continent?");
  strcpy(v9, "Asia");
  strcpy(v10, "What is the smallest country in the world?");
  strcpy(v11, "Vatican City");
  strcpy(v12, "What is the national animal of Australia?");
  strcpy(v13, "Kangaroo");
  printf("Welcome to the C Online Examination System!\n");
  printf("You will be presented with 5 multiple choice questions.\n");
  printf("Please type your answer as a single word without spaces.\n\n");
  display_questions(v4, 5i64);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall display_questions(_QWORD, _QWORD);
// 1400019D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Matrix operations ; Style: minimalist
#include <stdio.h>

void printMatrix(int rows, int cols, int mat[rows][cols]) {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      printf("%d ", mat[i][j]);
    }
    printf("\n");
  }
}

void addMatrices(int rows, int cols, int mat1[rows][cols], int mat2[rows][cols], int result[rows][cols]) {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      result[i][j] = mat1[i][j] + mat2[i][j];
    }
  }
}

void scalarMult(int rows, int cols, int mat[rows][cols], int scalar) {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      mat[i][j] *= scalar;
    }
  }
}

void transpose(int rows, int cols, int mat[rows][cols], int result[cols][rows]) {
  for (int i = 0; i < cols; i++) {
    for (int j = 0; j < rows; j++) {
      result[i][j] = mat[j][i];
    }
  }
}

int main() {
  int mat1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
  int mat2[3][3] = {{9, 8, 7}, {6, 5, 4}, {3, 2, 1}};
  int sumMat[3][3] = {0};
  int scalar = 2;
  int transMat[3][3] = {0};

  printf("Matrix 1:\n");
  printMatrix(3, 3, mat1);

  printf("\nMatrix 2:\n");
  printMatrix(3, 3, mat2);

  printf("\nSum of matrices:\n");
  addMatrices(3, 3, mat1, mat2, sumMat);
  printMatrix(3, 3, sumMat);

  printf("\nScalar multiplication of matrix 1:\n");
  scalarMult(3, 3, mat1, scalar);
  printMatrix(3, 3, mat1);

  printf("\nTranspose of matrix 2:\n");
  transpose(3, 3, mat2, transMat);
  printMatrix(3, 3, transMat);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printMatrix(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall addMatrices(_DWORD, _DWORD, _DWORD, _DWORD, __int64); // weak
__int64 __fastcall scalarMult(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall transpose(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018E4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[4]; // [rsp+30h] [rbp-C0h] BYREF
  int v5; // [rsp+50h] [rbp-A0h]
  __int64 v6[4]; // [rsp+60h] [rbp-90h] BYREF
  int v7; // [rsp+80h] [rbp-70h]
  int v8[12]; // [rsp+90h] [rbp-60h] BYREF
  int v9[11]; // [rsp+C0h] [rbp-30h] BYREF
  unsigned int v10; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  v9[0] = 1;
  v9[1] = 2;
  v9[2] = 3;
  v9[3] = 4;
  v9[4] = 5;
  v9[5] = 6;
  v9[6] = 7;
  v9[7] = 8;
  v9[8] = 9;
  v8[0] = 9;
  v8[1] = 8;
  v8[2] = 7;
  v8[3] = 6;
  v8[4] = 5;
  v8[5] = 4;
  v8[6] = 3;
  v8[7] = 2;
  v8[8] = 1;
  memset(v6, 0, sizeof(v6));
  v7 = 0;
  v10 = 2;
  memset(v4, 0, sizeof(v4));
  v5 = 0;
  printf("Matrix 1:\n");
  printMatrix(3i64, 3i64, v9);
  printf("\nMatrix 2:\n");
  printMatrix(3i64, 3i64, v8);
  printf("\nSum of matrices:\n");
  addMatrices(3, 3, (unsigned int)v9, (unsigned int)v8, (__int64)v6);
  printMatrix(3i64, 3i64, v6);
  printf("\nScalar multiplication of matrix 1:\n");
  scalarMult(3i64, 3i64, v9, v10);
  printMatrix(3i64, 3i64, v9);
  printf("\nTranspose of matrix 2:\n");
  transpose(3i64, 3i64, v8, v4);
  printMatrix(3i64, 3i64, v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printMatrix(_QWORD, _QWORD, _QWORD);
// 140001637: using guessed type __int64 __fastcall addMatrices(_DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 140001764: using guessed type __int64 __fastcall scalarMult(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001817: using guessed type __int64 __fastcall transpose(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001BC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Linked list operations ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>

// structure to represent a node in a linked list
struct ListNode {
    int val;
    struct ListNode *next;
};

// function to create a node with given value
struct ListNode* createNode(int val) {
    struct ListNode* new_node = (struct ListNode*) malloc(sizeof(struct ListNode));
    new_node->val = val;
    new_node->next = NULL;
    return new_node;
}

// function to add a node at the end of a linked list
void append(struct ListNode** head_ref, int val) {
    struct ListNode* new_node = createNode(val);
    if (*head_ref == NULL) {
        *head_ref = new_node;
    } else {
        struct ListNode* temp = *head_ref;
        while (temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = new_node;
    }
}

// function to add a node at the beginning of a linked list
void prepend(struct ListNode** head_ref, int val) {
    struct ListNode* new_node = createNode(val);
    new_node->next = *head_ref;
    *head_ref = new_node;
}

// function to print the elements of a linked list
void printList(struct ListNode* node) {
    while (node != NULL) {
        printf("%d ", node->val);
        node = node->next;
    }
    printf("\n");
}

// function to calculate the length of a linked list
int length(struct ListNode* node) {
    int len = 0;
    while (node != NULL) {
        len++;
        node = node->next;
    }
    return len;
}

// function to delete a node with given value from a linked list
void deleteNode(struct ListNode** head_ref, int val) {
    if (*head_ref == NULL) {
        return;
    }
    if ((*head_ref)->val == val) {
        *head_ref = (*head_ref)->next;
    } else {
        struct ListNode* temp = *head_ref;
        while (temp->next != NULL && temp->next->val != val) {
            temp = temp->next;
        }
        if (temp->next != NULL) {
            temp->next = temp->next->next;
        }
    }
}

// function to reverse a linked list
struct ListNode* reverseList(struct ListNode* head) {
    if (head == NULL || head->next == NULL) {
        return head;
    }
    struct ListNode* prev = NULL;
    struct ListNode* current = head;
    struct ListNode* next_node = NULL;
    while (current != NULL) {
        next_node = current->next;
        current->next = prev;
        prev = current;
        current = next_node;
    }
    return prev;
}

int main() {
    struct ListNode* head = NULL;

    // adding elements to the linked list
    append(&head, 1);
    append(&head, 2);
    prepend(&head, 3);
    prepend(&head, 4);

    // printing the linked list
    printf("Linked list: ");
    printList(head);

    // calculating the length of the linked list
    printf("Length of the linked list: %d\n", length(head));

    // deleting an element from the linked list
    deleteNode(&head, 3);
    printf("Linked list after deleting an element: ");
    printList(head);

    // reversing the linked list
    head = reverseList(head);
    printf("Reversed linked list: ");
    printList(head);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall append(_QWORD, _QWORD); // weak
__int64 __fastcall prepend(_QWORD, _QWORD); // weak
__int64 __fastcall printList(_QWORD); // weak
__int64 __fastcall length(_QWORD); // weak
__int64 __fastcall deleteNode(_QWORD, _QWORD); // weak
__int64 __fastcall reverseList(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000180E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5; // [rsp+28h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v5 = 0i64;
  append(&v5, 1i64);
  append(&v5, 2i64);
  prepend(&v5, 3i64);
  prepend(&v5, 4i64);
  printf("Linked list: ");
  printList(v5);
  v3 = length(v5);
  printf("Length of the linked list: %d\n", v3);
  deleteNode(&v5, 3i64);
  printf("Linked list after deleting an element: ");
  printList(v5);
  v5 = reverseList(v5);
  printf("Reversed linked list: ");
  printList(v5);
  return 0;
}
// 1400015C9: using guessed type __int64 __fastcall append(_QWORD, _QWORD);
// 140001638: using guessed type __int64 __fastcall prepend(_QWORD, _QWORD);
// 140001676: using guessed type __int64 __fastcall printList(_QWORD);
// 1400016C4: using guessed type __int64 __fastcall length(_QWORD);
// 1400016F9: using guessed type __int64 __fastcall deleteNode(_QWORD, _QWORD);
// 140001795: using guessed type __int64 __fastcall reverseList(_QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Online Examination System ; Style: scalable
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

/* define macros */
#define MAX_Q 50 /* maximum number of questions */
#define MAX_LEN 100 /* maximum length of a question or answer */
#define MAX_CHOICE 4 /* maximum number of choices for a multiple choice question */
#define CORRECT_ANS 10 /* marks for a correct answer */
#define INCORRECT_ANS -5 /* marks for an incorrect answer */
#define TOTAL_TIME 3600 /* total time for examination in seconds */

/* define structures */
typedef struct {
    char question[MAX_LEN+1];
    unsigned int num_options; /* 2 for true/false, 4 for MCQ */
    char options[MAX_CHOICE][MAX_LEN+1];
    int answer; /* index of the correct answer */
}Question;

/* define global variables */
Question questions[MAX_Q];
unsigned int num_questions = 0;

/* function prototypes */
int get_menu_choice(void);
void add_question(void);
void start_exam(void);
void ask_question(Question ques);
void give_result(int total_marks, int marks_obtained);

/* main function */
int main() {
    int choice;
    printf("Welcome to the Online Examination System!\n");
    do {
        choice = get_menu_choice();
        switch(choice) {
            case 1: add_question();
                    break;
            case 2: start_exam();
                    break;
            case 3: printf("Thank you for using the Online Examination System!\n");
                    break;
            default: printf("Invalid input, please try again.\n");
                     break;
        }
    } while(choice != 3);
    return 0;
}

/* function that displays the menu and returns user's choice */
int get_menu_choice(void) {
    int choice;
    printf("Please select one of the following options:\n");
    printf("1. Add a new question\n");
    printf("2. Start an exam\n");
    printf("3. Exit\n");
    scanf("%d", &choice);
    getchar();
    return choice;
}

/* function to add a new question */
void add_question(void) {
    if(num_questions == MAX_Q) {
        printf("Maximum number of questions reached.\n");
        return;
    }
    Question ques;
    printf("Enter the question:\n");
    fgets(ques.question, MAX_LEN+1, stdin);
    printf("Enter the number of options (2 for true/false, 4 for MCQ):\n");
    scanf("%u", &ques.num_options);
    getchar();
    for(int i=0; i<ques.num_options; i++) {
        printf("Enter option %d:\n", i+1);
        fgets(ques.options[i], MAX_LEN+1, stdin);
    }
    printf("Enter the index of the correct answer (1-%u):\n", ques.num_options);
    scanf("%d", &ques.answer);
    getchar();
    if(ques.answer < 1 || ques.answer > ques.num_options) {
        printf("Invalid input, question not added.\n");
        return;
    }
    questions[num_questions++] = ques; /* add question to database */
    printf("Question added successfully.\n");
}

/* function to start the exam */
void start_exam(void) {
    if(num_questions == 0) {
        printf("No questions in the database, please add questions first.\n");
        return;
    }
    int total_marks = 0, marks_obtained = 0;
    time_t start_time, end_time;
    time(&start_time);
    for(int i=0; i<num_questions; i++) {
        ask_question(questions[i]);
        printf("Enter your answer (1-%u):\n", questions[i].num_options);
        int ans;
        scanf("%d", &ans);
        getchar();
        if(ans == questions[i].answer) {
            marks_obtained += CORRECT_ANS;
        }
        else {
            marks_obtained += INCORRECT_ANS;
        }
        total_marks += CORRECT_ANS;
    }
    time(&end_time);
    int duration = (int) difftime(end_time, start_time);
    give_result(total_marks, marks_obtained);
    printf("Time taken: %d minutes %d seconds\n", duration/60, duration%60);
    if(duration > TOTAL_TIME) {
        printf("Time up! Exam ended.\n");
    }
}

/* function to ask a question */
void ask_question(Question ques) {
    printf("%s\n", ques.question);
    for(int i=0; i<ques.num_options; i++) {
        printf("%d) %s\n", i+1, ques.options[i]);
    }
}

/* function to display the result */
void give_result(int total_marks, int marks_obtained) {
    printf("Total marks: %d\n", total_marks);
    printf("Marks obtained: %d\n", marks_obtained);
    if(marks_obtained < 0) {
        printf("You failed the exam.\n");
    }
    else {
        printf("Congratulations! You passed the exam.\n");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 get_menu_choice(void); // weak
__int64 add_question(void); // weak
__int64 start_exam(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int menu_choice; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Online Examination System!\n");
  do
  {
    menu_choice = get_menu_choice();
    if ( menu_choice == 3 )
    {
      printf("Thank you for using the Online Examination System!\n");
    }
    else
    {
      if ( menu_choice > 3 )
        goto LABEL_10;
      if ( menu_choice == 1 )
      {
        add_question();
        continue;
      }
      if ( menu_choice == 2 )
        start_exam();
      else
LABEL_10:
        printf("Invalid input, please try again.\n");
    }
  }
  while ( menu_choice != 3 );
  return 0;
}
// 140001660: using guessed type __int64 get_menu_choice(void);
// 1400016C8: using guessed type __int64 add_question(void);
// 1400018E8: using guessed type __int64 start_exam(void);
// 140001CB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define XML tag structure
typedef struct XMLTag {
    char* name;
    struct XMLTag* parent;
    struct XMLTag** children;
    int num_children;
    char* text;
    int text_len;
} XMLTag;

// Define XML parser module
XMLTag* parse_xml(char* xml_string) {
    // TODO: Implement XML parsing logic here
    return NULL;
}

// Define XML printer module
void print_xml(XMLTag* root, int level) {
    if (root == NULL) {
        return;
    }

    // Print opening tag
    for (int i = 0; i < level; i++) {
        printf("  ");
    }
    printf("<%s>", root->name);

    // Print children
    for (int i = 0; i < root->num_children; i++) {
        printf("\n");
        print_xml(root->children[i], level + 1);
    }

    // Print closing tag and text
    if (root->text_len > 0) {
        printf("%s", root->text);
    }
    printf("</%s>", root->name);
}

// Define main function to test XML parsing and printing
int main() {
    // Example XML string
    char* xml_string = "<root><item id='1'>Hello</item><item id='2'>World!</item></root>";

    // Parse XML string into tree structure
    XMLTag* root = parse_xml(xml_string);

    // Print XML tree structure
    print_xml(root, 0);

    // Clean up memory
    // TODO: Implement memory cleanup logic here

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall parse_xml(_QWORD); // weak
__int64 __fastcall print_xml(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000168B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-10h]

  _main(argc, argv, envp);
  v4 = parse_xml("<root><item id='1'>Hello</item><item id='2'>World!</item></root>");
  print_xml(v4, 0i64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall parse_xml(_QWORD);
// 1400015A0: using guessed type __int64 __fastcall print_xml(_QWORD, _QWORD);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Basic Image Processing: Simple tasks like flipping an image, changing brightness/contrast ; Style: funny
#include<stdio.h>
#include<stdlib.h>

int main(){
    printf("Welcome to the image processing tool!\n");
    printf("Please enter the name of the image file you want to edit: ");

    char filename[100];
    scanf("%s", filename);

    // Opening the given file
    FILE* file = fopen(filename, "r");

    if(file == NULL) {
        printf("Oops! Unable to open file. Please make sure the file exists.\n");
        printf("Tip: Make sure the file name is correct and the file is not currently in use!\n");
        exit(0);
    }
    else {
        printf("File opened successfully!\n");
        printf("Please enter the task you want to perform:\n");
        printf("1. Flip the image\n");
        printf("2. Change brightness\n");
        printf("3. Change contrast\n");
        printf("Enter your choice (1/2/3): ");

        int choice;
        scanf("%d", &choice);
        printf("\nWait...processing your request...\n");

        // Processing the given task
        switch(choice) {
            case 1:
                printf("Flipping image...\n");
                // Code to flip the image
                break;
            case 2:
                printf("Changing brightness...\n");
                // Code to change brightness
                break;
            case 3:
                printf("Changing contrast...\n");
                // Code to change contrast
                break;
            default:
                printf("Invalid choice. Try again!\n");
                break;
        }
    }

    printf("\nDone processing your request! Thank you for using our tool!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-74h] BYREF
  char FileName[104]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the image processing tool!\n");
  printf("Please enter the name of the image file you want to edit: ");
  scanf("%s", FileName);
  if ( !fopen(FileName, "r") )
  {
    printf("Oops! Unable to open file. Please make sure the file exists.\n");
    printf("Tip: Make sure the file name is correct and the file is not currently in use!\n");
    exit(0);
  }
  printf("File opened successfully!\n");
  printf("Please enter the task you want to perform:\n");
  printf("1. Flip the image\n");
  printf("2. Change brightness\n");
  printf("3. Change contrast\n");
  printf("Enter your choice (1/2/3): ");
  scanf("%d", &v4);
  printf("\nWait...processing your request...\n");
  if ( v4 == 3 )
  {
    printf("Changing contrast...\n");
  }
  else
  {
    if ( v4 > 3 )
    {
LABEL_11:
      printf("Invalid choice. Try again!\n");
      goto LABEL_12;
    }
    if ( v4 == 1 )
    {
      printf("Flipping image...\n");
    }
    else
    {
      if ( v4 != 2 )
        goto LABEL_11;
      printf("Changing brightness...\n");
    }
  }
LABEL_12:
  printf("\nDone processing your request! Thank you for using our tool!\n");
  return 0;
}
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific ; Style: sophisticated
#include <stdio.h>
#include <math.h>

int main() {
  int num, power;
  double result;

  printf("Enter a number: ");
  scanf("%d", &num);

  printf("Enter a power: ");
  scanf("%d", &power);

  result = pow(num, power);

  printf("%d raised to the power of %d is %lf\n", num, power, result);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v5; // [rsp+24h] [rbp-Ch] BYREF
  double v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a number: ");
  scanf("%d", &v5);
  printf("Enter a power: ");
  scanf("%d", &v4);
  v6 = pow((double)(int)v5, (double)(int)v4);
  printf("%d raised to the power of %d is %lf\n", v5, v4, v6);
  return 0;
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific Calculator Implementation ; Style: curious
#include<stdio.h>
#include<math.h>

int main(){
    // Welcome Message
    printf("Welcome to the curious Scientific Calculator Program!\n");

    // User Input - Number 1
    printf("Enter your first number:\n");
    double num1;
    scanf("%lf", &num1);

    // User Input - Number 2
    printf("Enter your second number:\n");
    double num2;
    scanf("%lf", &num2);

    // User Input - Operation
    printf("Enter the operation you want to perform. Here are your options:\n");
    printf("+    - Addition\n");
    printf("-    - Subtraction\n");
    printf("*    - Multiplication\n");
    printf("/    - Division\n");
    printf("sin  - Sine\n");
    printf("cos  - Cosine\n");
    printf("tan  - Tangent\n");
    printf("log  - Logarithm with base 10\n");
    printf("ln   - Natural Logarithm\n");
    printf("pow  - Exponentiation\n");
    printf("sqrt - Square Root\n");
    printf("Enter the operation here:\n");

    char operation[10];
    scanf("%s", operation);

    // Calculation and Result
    if(strcmp(operation, "+") == 0){
        double result = num1 + num2;
        printf("%.2lf + %.2lf = %.2lf", num1, num2, result);
    } else if(strcmp(operation, "-") == 0){
        double result = num1 - num2;
        printf("%.2lf - %.2lf = %.2lf", num1, num2, result);
    } else if(strcmp(operation, "*") == 0){
        double result = num1 * num2;
        printf("%.2lf x %.2lf = %.2lf", num1, num2, result);
    } else if(strcmp(operation, "/") == 0){
        if(num2 == 0){
            printf("Undefined");
        } else {
            double result = num1 / num2;
            printf("%.2lf / %.2lf = %.2lf", num1, num2, result);
        }
    } else if(strcmp(operation, "sin") == 0){
        double result = sin(num1);
        printf("sin(%.2lf) = %.2lf", num1, result);
    } else if(strcmp(operation, "cos") == 0){
        double result = cos(num1);
        printf("cos(%.2lf) = %.2lf", num1, result);
    } else if(strcmp(operation, "tan") == 0){
        double result = tan(num1);
        printf("tan(%.2lf) = %.2lf", num1, result);
    } else if(strcmp(operation, "log") == 0){
        double result = log10(num1);
        printf("log(%.2lf) = %.2lf", num1, result);
    } else if(strcmp(operation, "ln") == 0){
        double result = log(num1);
        printf("ln(%.2lf) = %.2lf", num1, result);
    } else if(strcmp(operation, "pow") == 0){
        double result = pow(num1, num2);
        printf("%.2lf to the power of %.2lf = %.2lf", num1, num2, result);
    } else if(strcmp(operation, "sqrt") == 0){
        if(num1 < 0){
            printf("Undefined");
        } else {
            double result = sqrt(num1);
            printf("Square Root of %.2lf = %.2lf", num1, result);
        }
    } else{
        printf("Invalid Input");
    }

    // Thank You Message
    printf("\nThank you for using the curious Scientific Calculator Program!");

    // Program End
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl cos(double X);
double __cdecl log(double X);
double __cdecl pow(double X, double Y);
double __cdecl sin(double X);
// double __cdecl tan(double X);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// double __cdecl log10(double X);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[10]; // [rsp+2Eh] [rbp-72h] BYREF
  double Y; // [rsp+38h] [rbp-68h] BYREF
  double X[5]; // [rsp+40h] [rbp-60h] BYREF
  double v7; // [rsp+68h] [rbp-38h]
  double v8; // [rsp+70h] [rbp-30h]
  double v9; // [rsp+78h] [rbp-28h]
  double v10; // [rsp+80h] [rbp-20h]
  double v11; // [rsp+88h] [rbp-18h]
  double v12; // [rsp+90h] [rbp-10h]
  double v13; // [rsp+98h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to the curious Scientific Calculator Program!\n");
  printf("Enter your first number:\n");
  scanf("%lf", X);
  printf("Enter your second number:\n");
  scanf("%lf", &Y);
  printf("Enter the operation you want to perform. Here are your options:\n");
  printf("+    - Addition\n");
  printf("-    - Subtraction\n");
  printf("*    - Multiplication\n");
  printf("/    - Division\n");
  printf("sin  - Sine\n");
  printf("cos  - Cosine\n");
  printf("tan  - Tangent\n");
  printf("log  - Logarithm with base 10\n");
  printf("ln   - Natural Logarithm\n");
  printf("pow  - Exponentiation\n");
  printf("sqrt - Square Root\n");
  printf("Enter the operation here:\n");
  scanf("%s", Str1);
  if ( !strcmp(Str1, "+") )
  {
    X[1] = Y + X[0];
    printf("%.2lf + %.2lf = %.2lf", X[0], Y, Y + X[0]);
  }
  else if ( !strcmp(Str1, "-") )
  {
    X[2] = X[0] - Y;
    printf("%.2lf - %.2lf = %.2lf", X[0], Y, X[0] - Y);
  }
  else if ( !strcmp(Str1, "*") )
  {
    X[3] = Y * X[0];
    printf("%.2lf x %.2lf = %.2lf", X[0], Y, Y * X[0]);
  }
  else
  {
    if ( !strcmp(Str1, "/") )
    {
      if ( Y != 0.0 )
      {
        X[4] = X[0] / Y;
        printf("%.2lf / %.2lf = %.2lf", X[0], Y, X[0] / Y);
        goto LABEL_27;
      }
    }
    else
    {
      if ( !strcmp(Str1, "sin") )
      {
        v7 = sin(X[0]);
        printf("sin(%.2lf) = %.2lf", X[0], v7);
        goto LABEL_27;
      }
      if ( !strcmp(Str1, "cos") )
      {
        v8 = cos(X[0]);
        printf("cos(%.2lf) = %.2lf", X[0], v8);
        goto LABEL_27;
      }
      if ( !strcmp(Str1, "tan") )
      {
        v9 = tan(X[0]);
        printf("tan(%.2lf) = %.2lf", X[0], v9);
        goto LABEL_27;
      }
      if ( !strcmp(Str1, "log") )
      {
        v10 = log10(X[0]);
        printf("log(%.2lf) = %.2lf", X[0], v10);
        goto LABEL_27;
      }
      if ( !strcmp(Str1, "ln") )
      {
        v11 = log(X[0]);
        printf("ln(%.2lf) = %.2lf", X[0], v11);
        goto LABEL_27;
      }
      if ( !strcmp(Str1, "pow") )
      {
        v12 = pow(X[0], Y);
        printf("%.2lf to the power of %.2lf = %.2lf", X[0], Y, v12);
        goto LABEL_27;
      }
      if ( strcmp(Str1, "sqrt") )
      {
        printf("Invalid Input");
        goto LABEL_27;
      }
      if ( X[0] >= 0.0 )
      {
        v13 = sqrt(X[0]);
        printf("Square Root of %.2lf = %.2lf", X[0], v13);
        goto LABEL_27;
      }
    }
    printf("Undefined");
  }
LABEL_27:
  printf("\nThank you for using the curious Scientific Calculator Program!");
  return 0;
}
// 140001D30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=191 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Chess AI ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>

// Move struct to store the move of a chess piece
typedef struct Move{
    int x_src, y_src;
    int x_dest, y_dest;
} Move;

// Function to print the chess board
void print_board(char board[8][8]){
    printf("  a b c d e f g h\n");
    for(int i=0; i<8; i++){
        printf("%d ", 8-i);
        for(int j=0; j<8; j++){
            printf("%c ", board[i][j]);
        }
        printf("%d\n", 8-i);
    }
    printf("  a b c d e f g h\n");
}

// Function to check if a move is valid
bool is_valid_move(char board[8][8], Move move){
    // Check if it is a legal chess move
    // ...

    // Check if it is within the board
    if(move.x_src < 0 || move.x_src > 7 || move.y_src < 0 || move.y_src > 7 ||
       move.x_dest < 0 || move.x_dest > 7 || move.y_dest < 0 || move.y_dest > 7){
        return false;
    }

    // Check if source and destination are different
    if(move.x_src == move.x_dest && move.y_src == move.y_dest){
        return false;
    }

    // Check if the piece at source is not empty
    if(board[move.x_src][move.y_src] == ' '){
        return false;
    }

    // Check if the piece at destination is not of the same color
    if(isupper(board[move.x_dest][move.y_dest]) == isupper(board[move.x_src][move.y_src])){
        return false;
    }

    // Check if the move is valid for the specific piece (rook, queen, etc.)
    // ...

    // All checks passed, the move is valid
    return true;
}

// Function to make a move on the chess board
void make_move(char board[8][8], Move move){
    board[move.x_dest][move.y_dest] = board[move.x_src][move.y_src];
    board[move.x_src][move.y_src] = ' ';
}

int main(){
    // Initialize the chess board
    char board[8][8] = {{'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'}, 
                        {'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'},
                        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
                        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
                        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
                        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
                        {'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'},
                        {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'}};

    // Print the initial chess board
    print_board(board);

    // Game loop
    while(true){
        // Ask for the player's move
        Move move;
        printf("Enter your move (ex. 'e2 e4'): ");
        scanf("%c%d %c%d", &move.y_src, &move.x_src, &move.y_dest, &move.x_dest);
        move.x_src = 8 - move.x_src;
        move.x_dest = 8 - move.x_dest;
        move.y_src = move.y_src - 'a';
        move.y_dest = move.y_dest - 'a';
        // Clear the input buffer
        while(getchar() != '\n');

        // Check if the move is valid
        if(is_valid_move(board, move)){
            // Make the move
            make_move(board, move);
            // Print the updated board
            print_board(board);
            // Check if the game is over
            // ...
        }
        else{
            printf("Invalid move, please try again.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall print_board(_QWORD); // weak
__int64 __fastcall is_valid_move(_QWORD, _QWORD); // weak
__int64 __fastcall make_move(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();


//----- (000000014000183A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+30h] [rbp-60h] BYREF
  __int64 v5; // [rsp+38h] [rbp-58h]
  __int64 v6; // [rsp+40h] [rbp-50h] BYREF
  __int64 v7; // [rsp+48h] [rbp-48h] BYREF
  __int64 v8[8]; // [rsp+50h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v8, "rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR", sizeof(v8));
  print_board(v8);
  while ( 1 )
  {
    printf("Enter your move (ex. 'e2 e4'): ");
    scanf("%c%d %c%d", (char *)&v6 + 4, &v6, (char *)&v7 + 4, &v7);
    LODWORD(v6) = 8 - v6;
    LODWORD(v7) = 8 - v7;
    HIDWORD(v6) -= 97;
    HIDWORD(v7) -= 97;
    while ( getchar() != 10 )
      ;
    v4 = v6;
    v5 = v7;
    if ( (unsigned __int8)is_valid_move(v8, &v4) )
    {
      v4 = v6;
      v5 = v7;
      make_move(v8, &v4);
      print_board(v8);
    }
    else
    {
      printf("Invalid move, please try again.\n");
    }
  }
}
// 1400015E2: using guessed type __int64 __fastcall print_board(_QWORD);
// 14000169C: using guessed type __int64 __fastcall is_valid_move(_QWORD, _QWORD);
// 1400017B8: using guessed type __int64 __fastcall make_move(_QWORD, _QWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pathfinding algorithms ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>

#define ROWS 5
#define COLS 5

// Function to print the path from start to end
void printPath(int path[][COLS], int row, int col) {
    printf("(%d, %d) ", row, col);
    if (row == 0 && col == 0) {
        return;
    }
    if (path[row][col] == 1) {
        printPath(path, row, col-1);
    } else if (path[row][col] == 2) {
        printPath(path, row-1, col);
    } else if (path[row][col] == 3) {
        printPath(path, row, col+1);
    } else if (path[row][col] == 4) {
        printPath(path, row+1, col);
    }
}

// Function to find the shortest path
void shortestPath(int maze[][COLS], int startRow, int startCol, int endRow, int endCol) {
    int queue[ROWS*COLS][2], path[ROWS][COLS];
    int visited[ROWS][COLS], front = 0, rear = 0;
    int rowDiff[] = {-1, 0, 1, 0};
    int colDiff[] = {0, 1, 0, -1};
    
    visited[startRow][startCol] = 1;
    path[startRow][startCol] = -1;
    queue[rear][0] = startRow;
    queue[rear][1] = startCol;
    ++rear;

    while (front != rear) {
        int curRow = queue[front][0];
        int curCol = queue[front][1];
        ++front;
        
        if (curRow == endRow && curCol == endCol) {
            printf("\nThe shortest path is:\n");
            printPath(path, endRow, endCol);
            return;
        }
        
        for (int i = 0; i < 4; ++i) {
            int nextRow = curRow + rowDiff[i];
            int nextCol = curCol + colDiff[i];
            
            if (nextRow < 0 || nextRow >= ROWS || nextCol < 0 || nextCol >= COLS) {
                continue;
            }
            
            if (maze[nextRow][nextCol] == 0 || visited[nextRow][nextCol] == 1) {
                continue;
            }
            
            queue[rear][0] = nextRow;
            queue[rear][1] = nextCol;
            ++rear;
            visited[nextRow][nextCol] = 1;
            path[nextRow][nextCol] = i + 1;
        }
    }
    
    printf("\nThere is no possible path.\n");
    return;
}

int main() {
    int maze[][COLS] = {{1, 0, 1, 1, 1},
                        {1, 0, 1, 0, 1},
                        {1, 1, 1, 0, 1},
                        {0, 0, 0, 0, 1},
                        {1, 1, 1, 0, 1}};
    
    int startRow = 0, startCol = 0;
    int endRow = 4, endCol = 4;
    
    printf("The maze is:\n");
    for (int i = 0; i < ROWS; ++i) {
        for (int j = 0; j < COLS; ++j) {
            printf("%d ", maze[i][j]);
        }
        printf("\n");
    }

    shortestPath(maze, startRow, startCol, endRow, endCol);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall shortestPath(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A05) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[26]; // [rsp+30h] [rbp-80h] BYREF
  int v5; // [rsp+98h] [rbp-18h]
  int v6; // [rsp+9Ch] [rbp-14h]
  int v7; // [rsp+A0h] [rbp-10h]
  int v8; // [rsp+A4h] [rbp-Ch]
  int j; // [rsp+A8h] [rbp-8h]
  int i; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 1;
  v4[1] = 0;
  v4[2] = 1;
  v4[3] = 1;
  v4[4] = 1;
  v4[5] = 1;
  v4[6] = 0;
  v4[7] = 1;
  v4[8] = 0;
  v4[9] = 1;
  v4[10] = 1;
  v4[11] = 1;
  v4[12] = 1;
  v4[13] = 0;
  v4[14] = 1;
  v4[15] = 0;
  v4[16] = 0;
  v4[17] = 0;
  v4[18] = 0;
  v4[19] = 1;
  v4[20] = 1;
  v4[21] = 1;
  v4[22] = 1;
  v4[23] = 0;
  v4[24] = 1;
  v8 = 0;
  v7 = 0;
  v6 = 4;
  v5 = 4;
  printf("The maze is:\n");
  for ( i = 0; i <= 4; ++i )
  {
    for ( j = 0; j <= 4; ++j )
      printf("%d ", (unsigned int)v4[5 * i + j]);
    printf("\n");
  }
  shortestPath((unsigned int)v4, v8, v7, v6, v5);
  return 0;
}
// 1400016EB: using guessed type __int64 __fastcall shortestPath(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001C30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data structures visualization ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct node {
    int data;
    struct node* next;
} Node;

typedef struct queue {
    Node* front;
    Node* rear;
} Queue;

void initQueue(Queue* q) {
    q->front = q->rear = NULL;
}

int isQueueEmpty(Queue* q) {
    return q->front == NULL;
}

void enqueue(Queue* q, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;

    if (isQueueEmpty(q)) {
        q->front = q->rear = newNode;
    }
    else {
        q->rear->next = newNode;
        q->rear = newNode;
    }
}

int dequeue(Queue* q) {
    if (isQueueEmpty(q)) {
        return -1;
    }

    int data = q->front->data;
    Node* temp = q->front;

    if (q->front == q->rear) {
        q->front = q->rear = NULL;
    }
    else {
        q->front = q->front->next;
    }

    free(temp);

    return data;
}

void printQueue(Queue* q) {
    if (isQueueEmpty(q)) {
        printf("Queue is empty!\n");
        return;
    }

    Node* curr = q->front;

    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }

    printf("\n");
}

int main() {
    srand(time(NULL));

    Queue q;
    initQueue(&q);

    printf("********** Post-Apocalyptic Queue Visualizer **********\n");

    while (1) {
        printf("\n-------------\n");
        printf("Front: ");

        if (!isQueueEmpty(&q)) {
            printf("[%d]\n", q.front->data);
        }
        else {
            printf("[-]\n");
        }

        printf("Rear: ");

        if (!isQueueEmpty(&q)) {
            printf("[%d]\n", q.rear->data);
        }
        else {
            printf("[-]\n");
        }

        printf("\nQueue: ");
        printQueue(&q);

        if (rand() % 2) {
            int data = rand() % 100;
            enqueue(&q, data);
            printf("\n[+] Enqueued %d", data);
        }
        else {
            int data = dequeue(&q);
            if (data == -1) {
                printf("\n[-] Queue is empty!");
            }
            else {
                printf("\n[-] Dequeued %d", data);
            }
        }

        printf("\n");
        printf("\nPress enter to continue...\n");
        getchar();
        system("clear"); // for UNIX-like systems
        // system("cls"); // for Windows
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall initQueue(_QWORD); // weak
__int64 __fastcall isQueueEmpty(_QWORD); // weak
__int64 __fastcall enqueue(_QWORD, _QWORD); // weak
__int64 __fastcall dequeue(_QWORD); // weak
__int64 __fastcall printQueue(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl system(const char *Command);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();


//----- (0000000140001775) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5[3]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v6; // [rsp+38h] [rbp-8h]
  unsigned int v7; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  initQueue(v5);
  printf("********** Post-Apocalyptic Queue Visualizer **********\n");
  while ( 1 )
  {
    printf("\n-------------\n");
    printf("Front: ");
    if ( (unsigned int)isQueueEmpty(v5) )
      printf("[-]\n");
    else
      printf("[%d]\n", *(unsigned int *)v5[0]);
    printf("Rear: ");
    if ( (unsigned int)isQueueEmpty(v5) )
      printf("[-]\n");
    else
      printf("[%d]\n", *(unsigned int *)v5[1]);
    printf("\nQueue: ");
    printQueue(v5);
    if ( (rand() & 1) != 0 )
    {
      v6 = rand() % 100;
      enqueue(v5, v6);
      printf("\n[+] Enqueued %d", v6);
    }
    else
    {
      v7 = dequeue(v5);
      if ( v7 == -1 )
        printf("\n[-] Queue is empty!");
      else
        printf("\n[-] Dequeued %d", v7);
    }
    printf("\n");
    printf("\nPress enter to continue...\n");
    getchar();
    system("clear");
  }
}
// 1400015B0: using guessed type __int64 __fastcall initQueue(_QWORD);
// 1400015D6: using guessed type __int64 __fastcall isQueueEmpty(_QWORD);
// 1400015F0: using guessed type __int64 __fastcall enqueue(_QWORD, _QWORD);
// 14000166F: using guessed type __int64 __fastcall dequeue(_QWORD);
// 1400016FE: using guessed type __int64 __fastcall printQueue(_QWORD);
// 1400019F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=148 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char password[100];
    int length, lowerCaseCount = 0, upperCaseCount = 0, digitCount = 0, specialCharCount = 0;
    
    printf("Enter a password:\n");
    scanf("%s", password);
    
    length = strlen(password);
    
    for(int i=0; i<length; i++)
    {
        if('a'<=password[i] && password[i]<='z')
        {
            lowerCaseCount++;
        } 
        else if('A'<=password[i] && password[i]<='Z')
        {
            upperCaseCount++;
        }
        else if('0'<=password[i] && password[i]<='9')
        {
            digitCount++;
        }
        else
        {
            specialCharCount++;
        }
    }
    
    if(length>=10 && length<=20 && lowerCaseCount>=3 && upperCaseCount>=2 && digitCount>=2 && specialCharCount>=1)
    {
        printf("The password is strong. Good job!\n");
    }
    else if(length<8)
    {
        printf("The password is too short. It should be at least 8 characters long.\n");
    }
    else
    {
        printf("The password is weak. It should be between 10 and 20 characters long and should contain at least 3 lowercase letters, 2 uppercase letters, 2 digits, and 1 special character.\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[104]; // [rsp+20h] [rbp-80h] BYREF
  int v5; // [rsp+88h] [rbp-18h]
  int i; // [rsp+8Ch] [rbp-14h]
  int v7; // [rsp+90h] [rbp-10h]
  int v8; // [rsp+94h] [rbp-Ch]
  int v9; // [rsp+98h] [rbp-8h]
  int v10; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  printf("Enter a password:\n");
  scanf("%s", Str);
  v5 = strlen(Str);
  for ( i = 0; i < v5; ++i )
  {
    if ( Str[i] <= 96 || Str[i] > 122 )
    {
      if ( Str[i] <= 64 || Str[i] > 90 )
      {
        if ( Str[i] <= 47 || Str[i] > 57 )
          ++v7;
        else
          ++v8;
      }
      else
      {
        ++v9;
      }
    }
    else
    {
      ++v10;
    }
  }
  if ( v5 <= 9 || v5 > 20 || v10 <= 2 || v9 <= 1 || v8 <= 1 || v7 <= 0 )
  {
    if ( v5 > 7 )
      printf(
        "The password is weak. It should be between 10 and 20 characters long and should contain at least 3 lowercase let"
        "ters, 2 uppercase letters, 2 digits, and 1 special character.\n");
    else
      printf("The password is too short. It should be at least 8 characters long.\n");
  }
  else
  {
    printf("The password is strong. Good job!\n");
  }
  return 0;
}
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[104];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bitwise operations ; Style: sophisticated
#include <stdio.h>

int main() {

    unsigned int x = 10;
    unsigned int y = 20;
    
    printf("Bitwise AND operation result of %d & %d is %d.\n", x, y, x & y);
    printf("Bitwise OR operation result of %d | %d is %d.\n", x, y, x | y);
    printf("Bitwise XOR operation result of %d ^ %d is %d.\n", x, y, x ^ y);
    printf("Bitwise NOT operation result of ~%d is %d.\n", x, ~x);

    printf("Left shift operation of %d by 2 bit positions is %d.\n", x, x << 2);
    printf("Right shift operation of %d by 2 bit positions is %d.\n", y, y >> 2);
    
    // Clearing bit 0 and bit 1 of x
    x = x & (~3); 
    printf("After clearing bit 0 and bit 1 of %d, the result is %d.\n", 10, x);

    // Setting bit 3 of y
    y = y | (1 << 3); 
    printf("After setting bit 3 of %d, the result is %d.\n", 20, y); 
    
    // Toggling bit 2 of x
    x = x ^ (1 << 2);
    printf("After toggling bit 2 of %d, the result is %d.\n", 10, x); 
    
    return 0;

}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("Bitwise AND operation result of %d & %d is %d.\n", 10i64, 20i64, 0i64);
  printf("Bitwise OR operation result of %d | %d is %d.\n", 10i64, 20i64, 30i64);
  printf("Bitwise XOR operation result of %d ^ %d is %d.\n", 10i64, 20i64, 30i64);
  printf("Bitwise NOT operation result of ~%d is %d.\n", 10i64, 4294967285i64);
  printf("Left shift operation of %d by 2 bit positions is %d.\n", 10i64, 40i64);
  printf("Right shift operation of %d by 2 bit positions is %d.\n", 20i64, 5i64);
  printf("After clearing bit 0 and bit 1 of %d, the result is %d.\n", 10i64, 8i64);
  printf("After setting bit 3 of %d, the result is %d.\n", 20i64, 28i64);
  printf("After toggling bit 2 of %d, the result is %d.\n", 10i64, 12i64);
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Syntax parsing ; Style: portable
#include <stdio.h>
#include <stdlib.h>

/* Define a struct to store information about a parsed C function */
typedef struct ParsedCFunction {
    char* name;
    char* return_type;
    char** arguments;
    int num_arguments;
} ParsedCFunction;

/* Define a function to parse a C function declaration */
ParsedCFunction parse_c_function_declaration(char* declaration) {
    ParsedCFunction parsed_function;
    parsed_function.arguments = NULL;
    parsed_function.num_arguments = 0;

    /* Find the name of the function */
    char* name_start = declaration;
    while (*name_start == ' ' || *name_start == '\t' || *name_start == '\n') { // Skip whitespace
        name_start++;
    }
    char* name_end = name_start;
    while (*name_end != '(') {
        name_end++;
    }
    parsed_function.name = malloc(name_end - name_start + 1);
    memcpy(parsed_function.name, name_start, name_end - name_start);
    parsed_function.name[name_end - name_start] = '\0';

    /* Find the return type of the function */
    char* return_type_end = name_start - 1;
    while (*return_type_end == ' ' || *return_type_end == '\t' || *return_type_end == '\n') { // Skip whitespace
        return_type_end--;
    }
    char* return_type_start = return_type_end;
    while (*return_type_start != ' ') {
        return_type_start--;
    }
    return_type_start++;
    parsed_function.return_type = malloc(return_type_end - return_type_start + 1);
    memcpy(parsed_function.return_type, return_type_start, return_type_end - return_type_start);
    parsed_function.return_type[return_type_end - return_type_start] = '\0';

    /* Find the arguments of the function */
    char* argument_start = name_end + 1;
    char* argument_end = argument_start;
    while (*argument_end != ')') {
        if (*argument_end == ',') {
            parsed_function.num_arguments++;
            parsed_function.arguments = realloc(parsed_function.arguments, parsed_function.num_arguments * sizeof(char*));
            parsed_function.arguments[parsed_function.num_arguments - 1] = malloc(argument_end - argument_start + 1);
            memcpy(parsed_function.arguments[parsed_function.num_arguments - 1], argument_start, argument_end - argument_start);
            parsed_function.arguments[parsed_function.num_arguments - 1][argument_end - argument_start] = '\0';
            argument_start = argument_end + 1;
        }
        argument_end++;
    }
    parsed_function.num_arguments++;
    parsed_function.arguments = realloc(parsed_function.arguments, parsed_function.num_arguments * sizeof(char*));
    parsed_function.arguments[parsed_function.num_arguments - 1] = malloc(argument_end - argument_start + 1);
    memcpy(parsed_function.arguments[parsed_function.num_arguments - 1], argument_start, argument_end - argument_start);
    parsed_function.arguments[parsed_function.num_arguments - 1][argument_end - argument_start] = '\0';

    return parsed_function;
}

int main() {
    char* declaration = "int add(int a, int b)";
    ParsedCFunction parsed_function = parse_c_function_declaration(declaration);

    printf("Function name: %s\n", parsed_function.name);
    printf("Return type: %s\n", parsed_function.return_type);
    printf("Arguments:\n");
    for (int i = 0; i < parsed_function.num_arguments; i++) {
        printf("  %s\n", parsed_function.arguments[i]);
    }

    /* Free memory */
    free(parsed_function.name);
    free(parsed_function.return_type);
    for (int i = 0; i < parsed_function.num_arguments; i++) {
        free(parsed_function.arguments[i]);
    }
    free(parsed_function.arguments);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall parse_c_function_declaration(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (00000001400018AC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *Block; // [rsp+20h] [rbp-30h] BYREF
  void *v5; // [rsp+28h] [rbp-28h]
  void *v6; // [rsp+30h] [rbp-20h]
  int v7; // [rsp+38h] [rbp-18h]
  const char *v8; // [rsp+40h] [rbp-10h]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = "int add(int a, int b)";
  parse_c_function_declaration(&Block, "int add(int a, int b)");
  printf("Function name: %s\n", (const char *)Block);
  printf("Return type: %s\n", (const char *)v5);
  printf("Arguments:\n");
  for ( i = 0; i < v7; ++i )
    printf("  %s\n", *((const char **)v6 + i));
  free(Block);
  free(v5);
  for ( j = 0; j < v7; ++j )
    free(*((void **)v6 + j));
  free(v6);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall parse_c_function_declaration(_QWORD, _QWORD);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: Ada Lovelace
/* The following program demonstrates Ada Lovelace's pioneering work in computing, specifically her understanding of file handling principles.
She was able to recognize the need to convert data into a machine-readable format for processing. */
#include <stdio.h>

int main()
{
    FILE *filePointer; //Declaring file pointer
    char data[100]; //Data to be written to file
    char fileName[20]; //Name of file

    printf("Enter the filename to create: ");
    scanf("%s", fileName);

    filePointer = fopen(fileName, "w"); //Opening file in write mode

    if(filePointer == NULL)
    {
        printf("Failed to create file.");
        return 0;
    }

    printf("Enter data to write to file: ");
    scanf("%s", data);

    fprintf(filePointer, "%s", data); //Writing data to file

    printf("File created and data written!");

    fclose(filePointer); //Closing file

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char FileName[32]; // [rsp+20h] [rbp-90h] BYREF
  char v5[104]; // [rsp+40h] [rbp-70h] BYREF
  FILE *Stream; // [rsp+A8h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter the filename to create: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "w");
  if ( Stream )
  {
    printf("Enter data to write to file: ");
    scanf("%s", v5);
    fprintf_0(Stream, "%s", v5);
    printf("File created and data written!");
    fclose(Stream);
  }
  else
  {
    printf("Failed to create file.");
  }
  return 0;
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature Converter ; Style: funny
#include <stdio.h>
#include <stdlib.h>

int main()
{
    printf("Welcome to the Totally Accurate Temperature Converter!\n\n");

    printf("Please enter the temperature in Celsius (°C): ");
    float celsius;
    scanf("%f", &celsius);

    printf("Converting temperature...stand by...\n\n");

    printf("Hey, did you hear the one about Fahrenheit and Celsius?\n");
    printf("They were having a heated argument about who was hotter...\n\n");

    printf("Anyway, back to the task at hand...\n");

    float fahrenheit = (celsius * 9 / 5) + 32;
    printf("%.2f°C is equivalent to %.2f°F!\n\n", celsius, fahrenheit);

    printf("Now, let's convert that temperature to Kelvin!\n");
    printf("Hold on...let me check my notes...\n\n");

    float kelvin = celsius + 273.15;
    printf("%.2f°C is also equal to %.2fK!\n\n", celsius, kelvin);

    printf("Thanks for using the Totally Accurate Temperature Converter!\n");
    printf("If you need to convert temperatures again in the future, just remember the acronym...\n\n");

    printf("T\n");
    printf("A\n");
    printf("T\n");
    printf("C\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // xmm0_4
  int v5[2]; // [rsp+24h] [rbp-Ch] BYREF
  float v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Totally Accurate Temperature Converter!\n\n");
  printf("Please enter the temperature in Celsius (°C): ");
  scanf("%f", v5);
  printf("Converting temperature...stand by...\n\n");
  printf("Hey, did you hear the one about Fahrenheit and Celsius?\n");
  printf("They were having a heated argument about who was hotter...\n\n");
  printf("Anyway, back to the task at hand...\n");
  v6 = (float)((float)(9.0 * *(float *)v5) / 5.0) + 32.0;
  printf("%.2f°C is equivalent to %.2f°F!\n\n", *(float *)v5, v6);
  printf("Now, let's convert that temperature to Kelvin!\n");
  printf("Hold on...let me check my notes...\n\n");
  *(float *)&v3 = *(float *)v5 + 273.15;
  v5[1] = v3;
  printf("%.2f°C is also equal to %.2fK!\n\n", *(float *)v5, *(float *)&v3);
  printf("Thanks for using the Totally Accurate Temperature Converter!\n");
  printf("If you need to convert temperatures again in the future, just remember the acronym...\n\n");
  printf("T\n");
  printf("A\n");
  printf("T\n");
  printf("C\n");
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text-Based Adventure Game ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

void start_game();
void room_one();
void room_two();
void room_three();
void game_over();
void play_again();

int main() {
    start_game();
    return 0;
}

void start_game() {
    printf("Welcome to the Text-Based Adventure Game!\n");
    printf("You enter a dark, empty room. You can see three doors - one to the left, one straight ahead and one to the right.\n");
    printf("Which door do you choose? (L)eft, (S)traight or (R)ight?\n");

    char choice[10];
    scanf("%s", choice);

    if (strcmp(choice, "L") == 0) {
        room_one();
    } else if (strcmp(choice, "S") == 0) {
        room_two();
    } else if (strcmp(choice, "R") == 0) {
        room_three();
    } else {
        start_game();
    }
}

void room_one() {
    printf("You entered the left room and found a key on the table. Do you (T)ake the key or leave it there and continue to (E)xit?\n");

    char choice[10];
    scanf("%s", choice);

    if (strcmp(choice, "T") == 0) {
        printf("You took the key and proceed to the exit.\n");
        printf("Congratulations! You escaped the room!\n");
        play_again();
    } else if(strcmp(choice, "E") == 0) {
        printf("You decided to leave the key and continue to the exit.\n");
        printf("Congratulations! You escaped the room!\n");
        play_again();
    } else {
        room_one();
    }
}

void room_two() {
    printf("You entered the straight room and found a creature blocking your path.\n");
    printf("Do you (F)ight the creature or (R)un back to the starting room?\n");

    char choice[10];
    scanf("%s", choice);

    if (strcmp(choice, "F") == 0) {
        printf("Good job! You defeated the creature and found a note on the ground.\n");
        printf("The note says 'The exit is two rooms away from the left room.'\n");
        printf("Do you continue to the (L)eft room or go to the (R)ight room?\n");

        char choice_two[10];
        scanf("%s", choice_two);

        if (strcmp(choice_two, "L") == 0) {
            room_one();
        } else if (strcmp(choice_two, "R") == 0) {
            room_three();
        } else {
            room_two();
        }
    } else if (strcmp(choice, "R") == 0) {
        start_game();
    } else {
        room_two();
    }
}

void room_three() {
    printf("You entered the right room and it's full of traps.\n");
    printf("Do you (C)arefully navigate through the traps or (R)un back to the starting room?\n");

    char choice[10];
    scanf("%s", choice);

    if (strcmp(choice, "C") == 0) {
        printf("You carefully navigate through the traps and found a door.\n");
        printf("You tried to open the door but found it locked.\n");
        printf("Do you use the key you found in the left room (U)se or go back to the starting room and (S)tart over?\n");

        char choice_two[10];
        scanf("%s", choice_two);

        if (strcmp(choice_two, "U") == 0) {
            printf("Congratulations! You found the exit and escaped the room!\n");
            play_again();
        } else {
            start_game();
        }
    } else if (strcmp(choice, "R") == 0) {
        start_game();
    } else {
        room_three();
    }
}

void game_over() {
    printf("Game over! You died. Do you want to (P)lay again or (Q)uit?\n");

    char choice[10];
    scanf("%s", choice);

    if (strcmp(choice, "P") == 0) {
        start_game();
    } else if (strcmp(choice, "Q") == 0) {
        printf("Thanks for playing!\n");
        exit(0);
    } else {
        game_over();
    }
}

void play_again() {
    printf("Do you want to (P)lay again or (Q)uit?\n");

    char choice[10];
    scanf("%s", choice);

    if (strcmp(choice, "P") == 0) {
        start_game();
    } else if (strcmp(choice, "Q") == 0) {
        printf("Thanks for playing!\n");
        exit(0);
    } else {
        play_again();
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 start_game(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  start_game();
  return 0;
}
// 1400015FF: using guessed type __int64 start_game(void);
// 140001B20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Robot movement control ; Style: minimalist
#include <stdio.h>

#define FORWARD 1
#define BACKWARD -1
#define LEFT -1
#define RIGHT 1

void move(int distance, int direction, int turn){
    printf("Moving %d units %swards and turning %s\n", abs(distance), (direction == FORWARD) ? "for" : "back",
            (turn == LEFT) ? "left" : "right");
}

int main(){
    int dist = 10;
    
    printf("Starting Robot Movement Control Program\n");
    
    move(dist, FORWARD, RIGHT);
    move(dist, BACKWARD, LEFT);
    move(dist, FORWARD, LEFT);
    move(dist, BACKWARD, RIGHT);
    
    printf("Finishing Robot Movement Control Program\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall move(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015FA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("Starting Robot Movement Control Program\n");
  move(10i64, 1i64, 1i64);
  move(10i64, 0xFFFFFFFFi64, 0xFFFFFFFFi64);
  move(10i64, 1i64, 0xFFFFFFFFi64);
  move(10i64, 0xFFFFFFFFi64, 1i64);
  printf("Finishing Robot Movement Control Program\n");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall move(_QWORD, _QWORD, _QWORD);
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: relaxed
#include <stdio.h>

int main() {
  FILE *file;
  char text[100];

  // Open the file for writing
  file = fopen("example.txt", "w");

  // Check if the file was opened successfully
  if (file == NULL) {
    printf("Error opening file\n");
    return 1;
  }

  // Write some text to the file
  fprintf(file, "This is an example text that we will write to a file using C file handling.\n");

  // Close the file
  fclose(file);

  // Open the file for reading
  file = fopen("example.txt", "r");

  // Check if the file was opened successfully
  if (file == NULL) {
    printf("Error opening file\n");
    return 1;
  }

  // Read the text from the file
  printf("The contents of the file are:\n");
  while (fgets(text, 100, file) != NULL) {
    printf("%s", text);
  }

  // Close the file
  fclose(file);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[104]; // [rsp+20h] [rbp-70h] BYREF
  FILE *Stream; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  Stream = fopen("example.txt", "w");
  if ( Stream
    && (fprintf_0(Stream, "This is an example text that we will write to a file using C file handling.\n"),
        fclose(Stream),
        (Stream = fopen("example.txt", "r")) != 0i64) )
  {
    printf("The contents of the file are:\n");
    while ( fgets(Buffer, 100, Stream) )
      printf("%s", Buffer);
    fclose(Stream);
    return 0;
  }
  else
  {
    printf("Error opening file\n");
    return 1;
  }
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File system simulation ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BLOCK_SIZE 512 // Size of each block in bytes
#define NUM_BLOCKS 4096 // Number of blocks in the file system

typedef struct {
    char name[20];
    int size;
    int blockNum;
    int parent;
} File;

File fileList[50]; // Maximum of 50 files in the system
int numFiles = 0;
int freeBlocks[NUM_BLOCKS] = {0}; // Array of free blocks in the system

void initializeFileSystem() {
    // Set all blocks as free
    for (int i = 0; i < NUM_BLOCKS; i++) {
        freeBlocks[i] = 1;
    }
}

int allocateBlock() {
    // Find first free block and return its index
    for (int i = 0; i < NUM_BLOCKS; i++) {
        if (freeBlocks[i] == 1) {
            freeBlocks[i] = 0; // Mark block as used
            return i;
        }
    }
    return -1; // No free blocks available
}

int createFile(char name[], int size, int parent) {
    int blockNum = allocateBlock();
    if (blockNum == -1) {
        printf("Error: File system full\n");
        return -1;
    }
    File newFile;
    strcpy(newFile.name, name);
    newFile.size = size;
    newFile.blockNum = blockNum;
    newFile.parent = parent;
    fileList[numFiles++] = newFile; // Add new file to file list
    printf("File %s created with size %d in block %d\n", name, size, blockNum);
    return blockNum;
}

void deleteFile(int blockNum) {
    // Free block and remove file from file list
    freeBlocks[blockNum] = 1;
    int index = -1;
    for (int i = 0; i < numFiles; i++) {
        if (fileList[i].blockNum == blockNum) {
            index = i;
            break;
        }
    }
    if (index != -1) {
        for (int i = index; i < numFiles - 1; i++) {
            fileList[i] = fileList[i + 1];
        }
        numFiles--;
        printf("File in block %d deleted\n", blockNum);
    }
}

void displayFiles(int parent) {
    for (int i = 0; i < numFiles; i++) {
        if (fileList[i].parent == parent) {
            printf("%s (%d bytes)\n", fileList[i].name, fileList[i].size);
        }
    }
}

int main() {
    initializeFileSystem();

    // Create a root directory
    createFile("root", 0, -1);

    // Create some files in the root directory
    int file1 = createFile("file1", 1024, 0);
    int file2 = createFile("file2", 2048, 0);

    // Create a subdirectory
    int dir1 = createFile("dir1", 0, 0);

    // Create a file in the subdirectory
    int file3 = createFile("file3", 512, dir1);

    // Delete a file
    deleteFile(file2);

    // Display files in root directory
    printf("Files in root directory:\n");
    displayFiles(0);

    // Display files in subdirectory
    printf("Files in subdirectory:\n");
    displayFiles(dir1);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 initializeFileSystem(void); // weak
__int64 __fastcall createFile(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall deleteFile(_QWORD); // weak
__int64 __fastcall displayFiles(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001888) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch]
  unsigned int File; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  initializeFileSystem();
  createFile("root", 0i64, 0xFFFFFFFFi64);
  createFile("file1", 1024i64, 0i64);
  File = createFile("file2", 2048i64, 0i64);
  v4 = createFile("dir1", 0i64, 0i64);
  createFile("file3", 512i64, v4);
  deleteFile(File);
  printf("Files in root directory:\n");
  displayFiles(0i64);
  printf("Files in subdirectory:\n");
  displayFiles(v4);
  return 0;
}
// 140001591: using guessed type __int64 initializeFileSystem(void);
// 140001637: using guessed type __int64 __fastcall createFile(_QWORD, _QWORD, _QWORD);
// 1400016FD: using guessed type __int64 __fastcall deleteFile(_QWORD);
// 140001801: using guessed type __int64 __fastcall displayFiles(_QWORD);
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: standalone
#include <stdio.h>
#include <stdbool.h>

int main() {
  // Initializing variables
  bool isRunning = true;
  float weight, height, bmi;
  int age, steps = 0;

  // Asking for user inputs
  printf("Welcome to the C Fitness Tracker!\n");
  printf("Please enter your age: ");
  scanf("%d", &age);
  printf("Please enter your weight in kilograms: ");
  scanf("%f", &weight);
  printf("Please enter your height in meters: ");
  scanf("%f", &height);

  // Calculating initial BMI
  bmi = weight / (height * height);

  // Starting step tracking loop
  printf("Step tracking has started!\n");
  while (isRunning) {
    printf("Enter the number of steps you took (or -1 to end): ");
    scanf("%d", &steps);
    if (steps == -1) {
      isRunning = false;
      break;
    }

    // Updating BMI and displaying feedback based on steps taken
    bmi = weight / ((height + (steps * 0.0007)) * (height + (steps * 0.0007)));

    printf("Your current steps: %d\n", steps);
    printf("Your current BMI: %.1f\n", bmi);

    if (bmi < 18.5) {
      printf("You are underweight. Consider increasing your calorie intake.\n");
    } else if (bmi >= 18.5 && bmi <= 24.9) {
      printf("You are in the healthy weight range. Keep up the good work!\n");
    } else if (bmi >= 25 && bmi <= 29.9) {
      printf("You are overweight. Consider decreasing your calorie intake and increasing your exercise.\n");
    } else {
      printf("You are obese. Consider speaking with a healthcare professional for assistance.\n");
    }
  }

  printf("Thank you for using the C Fitness Tracker!");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  unsigned int v5; // [rsp+28h] [rbp-18h] BYREF
  char v6[4]; // [rsp+2Ch] [rbp-14h] BYREF
  float v7; // [rsp+30h] [rbp-10h] BYREF
  float v8; // [rsp+34h] [rbp-Ch] BYREF
  float v9; // [rsp+38h] [rbp-8h]
  char v10; // [rsp+3Fh] [rbp-1h]

  _main(argc, argv, envp);
  v10 = 1;
  v5 = 0;
  printf("Welcome to the C Fitness Tracker!\n");
  printf("Please enter your age: ");
  scanf("%d", v6);
  printf("Please enter your weight in kilograms: ");
  scanf("%f", &v8);
  printf("Please enter your height in meters: ");
  scanf("%f", &v7);
  v9 = v8 / (float)(v7 * v7);
  printf("Step tracking has started!\n");
  while ( v10 )
  {
    printf("Enter the number of steps you took (or -1 to end): ");
    scanf("%d", &v5);
    if ( v5 == -1 )
    {
      v10 = 0;
      break;
    }
    v3 = v8 / ((0.0007 * (double)(int)v5 + v7) * (v7 + 0.0007 * (double)(int)v5));
    v9 = v3;
    printf("Your current steps: %d\n", v5);
    printf("Your current BMI: %.1f\n", v9);
    if ( v9 >= 18.5 )
    {
      if ( v9 > 24.9 )
      {
        if ( v9 < 25.0 || v9 > 29.9 )
          printf("You are obese. Consider speaking with a healthcare professional for assistance.\n");
        else
          printf("You are overweight. Consider decreasing your calorie intake and increasing your exercise.\n");
      }
      else
      {
        printf("You are in the healthy weight range. Keep up the good work!\n");
      }
    }
    else
    {
      printf("You are underweight. Consider increasing your calorie intake.\n");
    }
  }
  printf("Thank you for using the C Fitness Tracker!");
  return 0;
}
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_14[4];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int levenshtein_distance(char* s1, char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);
    int matrix[len1 + 1][len2 + 1];

    for (int i = 0; i <= len1; i++) {
        matrix[i][0] = i;
    }

    for (int j = 0; j <= len2; j++) {
        matrix[0][j] = j;
    }

    int substitutionCost;
    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                substitutionCost = 0;
            } else {
                substitutionCost = 1;
            }
            matrix[i][j] = fmin(matrix[i - 1][j] + 1,
                                 fmin(matrix[i][j - 1] + 1,
                                      matrix[i - 1][j - 1] + substitutionCost));
        }
    }

    return matrix[len1][len2];
}

int main() {
    char string1[100];
    char string2[100];

    printf("Enter the first string: ");
    scanf("%s", string1);

    printf("Enter the second string: ");
    scanf("%s", string2);

    int distance = levenshtein_distance(string1, string2);

    printf("The Levenshtein Distance between %s and %s is: %d\n", string1, string2, distance);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall levenshtein_distance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018F3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[112]; // [rsp+20h] [rbp-60h] BYREF
  char v5[108]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v6; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter the first string: ");
  scanf("%s", v5);
  printf("Enter the second string: ");
  scanf("%s", v4);
  v6 = levenshtein_distance(v5, v4);
  printf("The Levenshtein Distance between %s and %s is: %d\n", v5, v4, v6);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall levenshtein_distance(_QWORD, _QWORD);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: excited
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

#define GRAV_CONST 0.000000000066742

typedef struct {
  double x;
  double y;
  double z;
} Vector;

typedef struct {
  Vector position;
  Vector velocity;
  double mass;
} Body;

int main() {
  Body sun = {
    .mass = 1989000e24,
    .position = {0, 0, 0},
    .velocity = {0, 0, 0},
  };
  
  Body earth = {
    .mass = 5.972e24,
    .position = {1.496e11, 0, 0},
    .velocity = {0, 29780, 0},
  };
  
  Body moon = {
    .mass = 73.47e21,
    .position = {1.496e11 + 384400000, 0, 0},
    .velocity = {0, 3078, 0},
  };
  
  Body mars = {
    .mass = 641.71e21,
    .position = {0, -2.279e11, 0},
    .velocity = {-24130, 0, 0},
  };
  
  Body venus = {
    .mass = 48.685e23,
    .position = {0, -108.94e9, 0},
    .velocity = {35020, 0, 0},
  };
  
  Body mercury = {
    .mass = 3.301e23,
    .position = {0, -57.91e9, 0},
    .velocity = {47360, 0, 0},
  };
  
  Body jupiter = {
    .mass = 1898.19e24,
    .position = {0, 0, -7.785e11},
    .velocity = {13070, 0, 0},
  };
  
  Body saturn = {
    .mass = 568.34e24,
    .position = {0, 0, 1.433e12},
    .velocity = {-9650, 0, 0},
  };
  
  Body uranus = {
    .mass = 86.813e24,
    .position = {0, 0, -2.871e12},
    .velocity = {6810, 0, 0},
  };
  
  Body neptune = {
    .mass = 102.413e24,
    .position = {0, 0, 4.495e12},
    .velocity = {-5440, 0, 0},
  };
  
  Body pluto = {
    .mass = 1.27e22,
    .position = {0, 0, -5.906e12},
    .velocity = {4740, 0, 0},
  };
  
  Body bodies[] = {sun, earth, moon, mars, venus, mercury, jupiter, saturn, uranus, neptune, pluto};
  
  double t = 0;
  double dt = 3600; // 1 hour
  
  while (1) {
    t += dt;
    
    for (int i = 0; i < sizeof(bodies) / sizeof(Body); i++) {
      for (int j = i + 1; j < sizeof(bodies) / sizeof(Body); j++) {
        Vector r = {bodies[j].position.x - bodies[i].position.x, bodies[j].position.y - bodies[i].position.y, bodies[j].position.z - bodies[i].position.z};
        double dist = sqrt(r.x * r.x + r.y * r.y + r.z * r.z);
        Vector force = {.x = GRAV_CONST * bodies[i].mass * bodies[j].mass / (dist * dist * dist) * r.x,
                        .y = GRAV_CONST * bodies[i].mass * bodies[j].mass / (dist * dist * dist) * r.y,
                        .z = GRAV_CONST * bodies[i].mass * bodies[j].mass / (dist * dist * dist) * r.z};
        bodies[i].velocity.x += force.x / bodies[i].mass * dt;
        bodies[i].velocity.y += force.y / bodies[i].mass * dt;
        bodies[i].velocity.z += force.z / bodies[i].mass * dt;
        bodies[j].velocity.x -= force.x / bodies[j].mass * dt;
        bodies[j].velocity.y -= force.y / bodies[j].mass * dt;
        bodies[j].velocity.z -= force.z / bodies[j].mass * dt;
      }
    }
    
    for (int i = 0; i < sizeof(bodies) / sizeof(Body); i++) {
      bodies[i].position.x += bodies[i].velocity.x * dt;
      bodies[i].position.y += bodies[i].velocity.y * dt;
      bodies[i].position.z += bodies[i].velocity.z * dt;
    }
    
    // Output earth's position every 100 days
    if ((int)(t / 3600 / 24) % 100 == 0) {
      printf("Day %d: The Earth is at (%f, %f, %f)\n", (int)(t / 3600 / 24), earth.position.x, earth.position.y, earth.position.z);
    }
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+30h] [rbp-50h]
  double v5; // [rsp+38h] [rbp-48h]
  double v6; // [rsp+40h] [rbp-40h]
  double v7; // [rsp+50h] [rbp-30h]
  double v8; // [rsp+58h] [rbp-28h]
  double v9; // [rsp+60h] [rbp-20h]
  __int64 v10; // [rsp+70h] [rbp-10h]
  __int64 v11; // [rsp+78h] [rbp-8h]
  __int64 v12[148]; // [rsp+80h] [rbp+0h] BYREF
  double v13; // [rsp+520h] [rbp+4A0h]
  double v14; // [rsp+528h] [rbp+4A8h]
  double v15; // [rsp+530h] [rbp+4B0h]
  __int64 v16; // [rsp+538h] [rbp+4B8h]
  __int64 v17; // [rsp+540h] [rbp+4C0h]
  __int64 v18; // [rsp+548h] [rbp+4C8h]
  __int64 v19; // [rsp+550h] [rbp+4D0h]
  __int64 v20; // [rsp+560h] [rbp+4E0h]
  __int64 v21; // [rsp+568h] [rbp+4E8h]
  __int64 v22; // [rsp+570h] [rbp+4F0h]
  __int64 v23; // [rsp+578h] [rbp+4F8h]
  __int64 v24; // [rsp+580h] [rbp+500h]
  __int64 v25; // [rsp+588h] [rbp+508h]
  __int64 v26; // [rsp+590h] [rbp+510h]
  double v27; // [rsp+598h] [rbp+518h]
  double v28; // [rsp+5A0h] [rbp+520h]
  unsigned int k; // [rsp+5ACh] [rbp+52Ch]
  unsigned int j; // [rsp+5B0h] [rbp+530h]
  unsigned int i; // [rsp+5B4h] [rbp+534h]
  double v32; // [rsp+5B8h] [rbp+538h]

  _main(argc, argv, envp);
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v26 = 0x46391ACE3D05AEF4i64;
  v13 = 1.496e11;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0i64;
  v17 = 0x40DD150000000000i64;
  v18 = 0i64;
  v19 = 0x4513C27B13272FB6i64;
  v12[140] = 0x424175E229400000i64;
  memset(&v12[141], 0, 24);
  v12[144] = 0x40A80C0000000000i64;
  v12[145] = 0i64;
  v12[146] = 0x44AF1DA223F6839Ai64;
  v12[132] = 0i64;
  v12[133] = 0xC24A87F303800000ui64;
  v12[134] = 0i64;
  v12[135] = 0xC0D7908000000000ui64;
  v12[136] = 0i64;
  v12[137] = 0i64;
  v12[138] = 0x44E0FC6566DA5696i64;
  v12[124] = 0i64;
  v12[125] = 0xC2395D547B000000ui64;
  v12[126] = 0i64;
  v12[127] = 0x40E1198000000000i64;
  v12[128] = 0i64;
  v12[129] = 0i64;
  v12[130] = 0x45101BC7A7C4F601i64;
  v12[116] = 0i64;
  v12[117] = 0xC22AF768F3000000ui64;
  v12[118] = 0i64;
  v12[119] = 0x40E7200000000000i64;
  v12[120] = 0i64;
  v12[121] = 0i64;
  v12[122] = 0x44D179B07057CF97i64;
  v12[108] = 0i64;
  v12[109] = 0i64;
  v12[110] = 0xC266A846E9200000ui64;
  v12[111] = 0x40C9870000000000i64;
  v12[112] = 0i64;
  v12[113] = 0i64;
  v12[114] = 0x45988895785BA94Bi64;
  v12[100] = 0i64;
  v12[101] = 0i64;
  v12[102] = 0x4274DA574BA00000i64;
  v12[103] = 0xC0C2D90000000000ui64;
  v12[104] = 0i64;
  v12[105] = 0i64;
  v12[106] = 0x457D61EAD22B17A1i64;
  v12[92] = 0i64;
  v12[93] = 0i64;
  v12[94] = 0xC284E3A77B300000ui64;
  v12[95] = 0x40BA9A0000000000i64;
  v12[96] = 0i64;
  v12[97] = 0i64;
  v12[98] = 0x4551F3D78A3D6D4Ei64;
  v12[84] = 0i64;
  v12[85] = 0i64;
  v12[86] = 0x42905A4B83580000i64;
  v12[87] = 0xC0B5400000000000ui64;
  v12[88] = 0i64;
  v12[89] = 0i64;
  v12[90] = 0x45552DB2F6B0BFBAi64;
  v12[76] = 0i64;
  v12[77] = 0i64;
  v12[78] = 0xC2957C6420D00000ui64;
  v12[79] = 0x40B2840000000000i64;
  v12[80] = 0i64;
  v12[81] = 0i64;
  v12[82] = 0x448583BF3DC42128i64;
  v10 = 0i64;
  v11 = 0i64;
  memset(v12, 0, 32);
  v12[4] = 0x46391ACE3D05AEF4i64;
  v12[5] = 0x42416A6D6C000000i64;
  memset(&v12[6], 0, 24);
  v12[9] = 0x40DD150000000000i64;
  v12[10] = 0i64;
  v12[11] = 0x4513C27B13272FB6i64;
  v12[12] = 0x424175E229400000i64;
  memset(&v12[13], 0, 24);
  v12[16] = 0x40A80C0000000000i64;
  v12[17] = 0i64;
  v12[18] = 0x44AF1DA223F6839Ai64;
  v12[19] = 0i64;
  v12[20] = 0xC24A87F303800000ui64;
  v12[21] = 0i64;
  v12[22] = 0xC0D7908000000000ui64;
  v12[23] = 0i64;
  v12[24] = 0i64;
  v12[25] = 0x44E0FC6566DA5696i64;
  v12[26] = 0i64;
  v12[27] = 0xC2395D547B000000ui64;
  v12[28] = 0i64;
  v12[29] = 0x40E1198000000000i64;
  v12[30] = 0i64;
  v12[31] = 0i64;
  v12[32] = 0x45101BC7A7C4F601i64;
  v12[33] = 0i64;
  v12[34] = 0xC22AF768F3000000ui64;
  v12[35] = 0i64;
  v12[36] = 0x40E7200000000000i64;
  v12[37] = 0i64;
  v12[38] = 0i64;
  v12[39] = 0x44D179B07057CF97i64;
  v12[40] = 0i64;
  v12[41] = 0i64;
  v12[42] = 0xC266A846E9200000ui64;
  v12[43] = 0x40C9870000000000i64;
  v12[44] = 0i64;
  v12[45] = 0i64;
  v12[46] = 0x45988895785BA94Bi64;
  v12[47] = 0i64;
  v12[48] = 0i64;
  v12[49] = 0x4274DA574BA00000i64;
  v12[50] = 0xC0C2D90000000000ui64;
  v12[51] = 0i64;
  v12[52] = 0i64;
  v12[53] = 0x457D61EAD22B17A1i64;
  v12[54] = 0i64;
  v12[55] = 0i64;
  v12[56] = 0xC284E3A77B300000ui64;
  v12[57] = 0x40BA9A0000000000i64;
  v12[58] = 0i64;
  v12[59] = 0i64;
  v12[60] = 0x4551F3D78A3D6D4Ei64;
  v12[61] = 0i64;
  v12[62] = 0i64;
  v12[63] = 0x42905A4B83580000i64;
  v12[64] = 0xC0B5400000000000ui64;
  v12[65] = 0i64;
  v12[66] = 0i64;
  v12[67] = 0x45552DB2F6B0BFBAi64;
  v12[68] = 0i64;
  v12[69] = 0i64;
  v12[70] = 0xC2957C6420D00000ui64;
  v12[71] = 0x40B2840000000000i64;
  v12[72] = 0i64;
  v12[73] = 0i64;
  v12[74] = 0x448583BF3DC42128i64;
  v32 = 0.0;
  v28 = 3600.0;
  while ( 1 )
  {
    v32 = v32 + v28;
    for ( i = 0; i <= 0xA; ++i )
    {
      for ( j = i + 1; j <= 0xA; ++j )
      {
        v7 = *(double *)&v12[7 * (int)j - 2] - *(double *)&v12[7 * (int)i - 2];
        v8 = *(double *)&v12[7 * (int)j - 1] - *(double *)&v12[7 * (int)i - 1];
        v9 = *(double *)&v12[7 * (int)j] - *(double *)&v12[7 * (int)i];
        v27 = sqrt(v7 * v7 + v8 * v8 + v9 * v9);
        v4 = v7 * (*(double *)&v12[7 * (int)i + 4] * 6.6742e-11 * *(double *)&v12[7 * (int)j + 4] / (v27 * v27 * v27));
        v5 = v8 * (*(double *)&v12[7 * (int)i + 4] * 6.6742e-11 * *(double *)&v12[7 * (int)j + 4] / (v27 * v27 * v27));
        v6 = v9 * (*(double *)&v12[7 * (int)i + 4] * 6.6742e-11 * *(double *)&v12[7 * (int)j + 4] / (v27 * v27 * v27));
        *(double *)&v12[7 * (int)i + 1] = v4 / *(double *)&v12[7 * (int)i + 4] * v28 + *(double *)&v12[7 * (int)i + 1];
        *(double *)&v12[7 * (int)i + 2] = v5 / *(double *)&v12[7 * (int)i + 4] * v28 + *(double *)&v12[7 * (int)i + 2];
        *(double *)&v12[7 * (int)i + 3] = v6 / *(double *)&v12[7 * (int)i + 4] * v28 + *(double *)&v12[7 * (int)i + 3];
        *(double *)&v12[7 * (int)j + 1] = *(double *)&v12[7 * (int)j + 1] - v4 / *(double *)&v12[7 * (int)j + 4] * v28;
        *(double *)&v12[7 * (int)j + 2] = *(double *)&v12[7 * (int)j + 2] - v5 / *(double *)&v12[7 * (int)j + 4] * v28;
        *(double *)&v12[7 * (int)j + 3] = *(double *)&v12[7 * (int)j + 3] - v6 / *(double *)&v12[7 * (int)j + 4] * v28;
      }
    }
    for ( k = 0; k <= 0xA; ++k )
    {
      *(double *)&v12[7 * (int)k - 2] = *(double *)&v12[7 * (int)k + 1] * v28 + *(double *)&v12[7 * (int)k - 2];
      *(double *)&v12[7 * (int)k - 1] = *(double *)&v12[7 * (int)k + 2] * v28 + *(double *)&v12[7 * (int)k - 1];
      *(double *)&v12[7 * (int)k] = *(double *)&v12[7 * (int)k + 3] * v28 + *(double *)&v12[7 * (int)k];
    }
    if ( !((int)(v32 / 3600.0 / 24.0) % 100) )
      printf("Day %d: The Earth is at (%f, %f, %f)\n", (unsigned int)(int)(v32 / 3600.0 / 24.0), v13, v14, v15);
  }
}
// 140002820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: innovative
#include <stdio.h>
#include <string.h>

int main() {
    int passwordStrength = 0;
    char password[50];
    printf("Enter a password:\n");
    scanf("%[^\n]%*c", password);

    //check password length
    if(strlen(password) >= 8) {
        passwordStrength++;
    }

    //check for uppercase letters
    for(int i = 0; i < strlen(password); i++) {
        if(password[i] >= 'A' && password[i] <= 'Z') {
            passwordStrength++;
            break;
        }
    }

    //check for lowercase letters
    for(int i = 0; i < strlen(password); i++) {
        if(password[i] >= 'a' && password[i] <= 'z') {
            passwordStrength++;
            break;
        }
    }

    //check for digits
    for(int i = 0; i < strlen(password); i++) {
        if(password[i] >= '0' && password[i] <= '9') {
            passwordStrength++;
            break;
        }
    }

    //check for special characters
    char specialCharacters[] = "!@#$%^&*()_+{}|:<>?-=[]\\;,./";
    for(int i = 0; i < strlen(password); i++) {
        for(int j = 0; j < strlen(specialCharacters); j++) {
            if(password[i] == specialCharacters[j]) {
                passwordStrength++;
                break;
            }
        }
        if(passwordStrength > 4) {
            break;
        }
    }

    //output password strength
    switch(passwordStrength) {
        case 0:
        case 1:
        case 2:
            printf("Password too weak\n");
            break;
        case 3:
            printf("Password is moderate\n");
            break;
        case 4:
            printf("Password is strong\n");
            break;
        case 5:
            printf("Password is very strong\n");
            break;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[32]; // [rsp+20h] [rbp-70h] BYREF
  char Str[56]; // [rsp+40h] [rbp-50h] BYREF
  int n; // [rsp+78h] [rbp-18h]
  int m; // [rsp+7Ch] [rbp-14h]
  int k; // [rsp+80h] [rbp-10h]
  int j; // [rsp+84h] [rbp-Ch]
  int i; // [rsp+88h] [rbp-8h]
  int v11; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  v11 = 0;
  printf("Enter a password:\n");
  scanf("%[^\n]%*c", Str);
  if ( strlen(Str) > 7 )
    ++v11;
  for ( i = 0; i < strlen(Str); ++i )
  {
    if ( Str[i] > 64 && Str[i] <= 90 )
    {
      ++v11;
      break;
    }
  }
  for ( j = 0; j < strlen(Str); ++j )
  {
    if ( Str[j] > 96 && Str[j] <= 122 )
    {
      ++v11;
      break;
    }
  }
  for ( k = 0; k < strlen(Str); ++k )
  {
    if ( Str[k] > 47 && Str[k] <= 57 )
    {
      ++v11;
      break;
    }
  }
  strcpy(v4, "!@#$%^&*()_+{}|:<>?-=[]\\;,./");
  for ( m = 0; m < strlen(Str); ++m )
  {
    for ( n = 0; n < strlen(v4); ++n )
    {
      if ( Str[m] == v4[n] )
      {
        ++v11;
        break;
      }
    }
    if ( v11 > 4 )
      break;
  }
  if ( v11 == 5 )
  {
    printf("Password is very strong\n");
  }
  else if ( v11 <= 5 )
  {
    if ( v11 == 4 )
    {
      printf("Password is strong\n");
    }
    else if ( v11 > 2 )
    {
      printf("Password is moderate\n");
    }
    else if ( v11 >= 0 )
    {
      printf("Password too weak\n");
    }
  }
  return 0;
}
// 1400017C6: conditional instruction was optimized away because %var_14.4<4
// 1400017DA: conditional instruction was optimized away because %var_14.4==3
// 1400018E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[56];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Count Tool ; Style: calm
#include <stdio.h>
#include <ctype.h>

int main() {
    char text[1000];
    int words = 0;
    int i, charCount;

    printf("Enter text: ");
    fgets(text, 1000, stdin);

    charCount = strlen(text);

    for (i = 0; i < charCount; i++) {
        if (isspace(text[i]) || text[i] == '\n') {
            words++;
        }
    }

    printf("\nWord count: %d", words);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isspace)(int C);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1012]; // [rsp+20h] [rbp-60h] BYREF
  int v6; // [rsp+414h] [rbp+394h]
  int i; // [rsp+418h] [rbp+398h]
  unsigned int v8; // [rsp+41Ch] [rbp+39Ch]

  _main(argc, argv, envp);
  v8 = 0;
  printf("Enter text: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v6 = strlen(Buffer);
  for ( i = 0; i < v6; ++i )
  {
    if ( isspace(Buffer[i]) || Buffer[i] == 10 )
      ++v8;
  }
  printf("\nWord count: %d", v8);
  return 0;
}
// 140001730: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[1012];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System administration ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
  char command[50];
  printf("Welcome to the Mind-Bending System Administration Program!\n");
  printf("Please enter a command:\n");

  while(1) {
    printf(">> ");
    scanf("%s", command);

    if(strcmp(command, "enigma") == 0) {
      printf("You've discovered the Enigma command! Prepare for a mind-bending experience!\n");
      int num_chars;
      printf("Enter the number of characters you want to generate: ");
      scanf("%d", &num_chars);
      
      char* enigma_chars = (char*) malloc(num_chars * sizeof(char));

      for(int i = 0; i < num_chars; i++) {
        int rand_num = rand() % 94 + 32; // generate a random ASCII char between 32 and 126
        enigma_chars[i] = (char) rand_num;
      }

      printf("Enigma output: ");
      for(int i = 0; i < num_chars; i++) {
        printf("%c", enigma_chars[i]);
      }
      printf("\n");

      free(enigma_chars);
    }
    else if(strcmp(command, "recursive") == 0) {
      printf("You've discovered the Recursive command! Prepare for mind-bending recursion!\n");
      int num_loops;
      printf("Enter the number of times you want to loop recursively: ");
      scanf("%d", &num_loops);

      recursive(num_loops);

      printf("Recursive command complete!\n");
    }
    else if(strcmp(command, "hyperspace") == 0) {
      printf("You've discovered the Hyperspace command! Prepare for a mind-bending warp!\n");
      printf("Are you ready to enter Hyperspace? (y/n): ");
      
      char confirmation;
      scanf(" %c", &confirmation); // make sure to have a space before %c to ignore any whitespace in input
      
      if(confirmation == 'y' || confirmation == 'Y') {
        printf("Warping to Hyperspace...");
        // start warp animation
        printf("\n\n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|____________________*_____*_____*_____*_______| \n");
        printf("|                                                 | \n");
        printf("|                   *     -^-     *               | \n");
        printf("|    *           .*    /_\\_\\_/_\\   *.             | \n");
        printf("|               .*.     * (_) *     *.     *      | \n");
        printf("|               .*.\'             \'.*.            | \n");
        printf("|__   *        .*.   \'  \'\')\'(\'\'  \'   *.   *    __| \n");
        printf("|                             *        .*.      __| \n");
        printf("|             *        *         .*.      .*.__.| \n");
        printf("|                                                 | \n");
        printf("|         *               *              .*.      | \n");
        printf("|    *           *       *           .*.        __| \n");
        printf("|               .*.                    .*.__.   __| \n");
        printf("|               .*.__.           *                 | \n");
        printf("|* ___.  .*.__.        *          .*.    *         | \n");
        printf("|.-\' &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'-.        *    .*.                 __| \n");
        printf("|\'-=._.-\'-._.-\'-._.-\'-._.-\'-._.-\'-._.-\'-._.-\'-.__| \n");
        printf("\n\n");
        // end warp animation
        printf("You have successfully warped to Hyperspace. Enjoy your mind-bending journey!\n");
      }
      else {
        printf("Warp cancelled. Returning to main menu...\n");
      }
    }
    else {
      printf("Invalid command. Try again.\n");
    }
  }

  return 0;
}

void recursive(int count) {
  if(count <= 0) {
    printf("Recursive loop complete.\n");
    return;
  }

  printf("Recursive loop #%d\n", count);
  recursive(count - 1);
  printf("Exiting recursive loop #%d\n", count);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall recursive(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// int __cdecl rand();
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+27h] [rbp-59h] BYREF
  unsigned int v5; // [rsp+28h] [rbp-58h] BYREF
  int v6; // [rsp+2Ch] [rbp-54h] BYREF
  char Str1[60]; // [rsp+30h] [rbp-50h] BYREF
  int v8; // [rsp+6Ch] [rbp-14h]
  void *Block; // [rsp+70h] [rbp-10h]
  int j; // [rsp+78h] [rbp-8h]
  int i; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Mind-Bending System Administration Program!\n");
  printf("Please enter a command:\n");
  while ( 1 )
  {
    while ( 1 )
    {
      printf(">> ");
      scanf("%s", Str1);
      if ( strcmp(Str1, "enigma") )
        break;
      printf("You've discovered the Enigma command! Prepare for a mind-bending experience!\n");
      printf("Enter the number of characters you want to generate: ");
      scanf("%d", &v6);
      Block = malloc(v6);
      for ( i = 0; i < v6; ++i )
      {
        v8 = rand() % 94 + 32;
        *((_BYTE *)Block + i) = v8;
      }
      printf("Enigma output: ");
      for ( j = 0; j < v6; ++j )
        printf("%c", (unsigned int)*((char *)Block + j));
      printf("\n");
      free(Block);
    }
    if ( !strcmp(Str1, "recursive") )
    {
      printf("You've discovered the Recursive command! Prepare for mind-bending recursion!\n");
      printf("Enter the number of times you want to loop recursively: ");
      scanf("%d", &v5);
      recursive(v5);
      printf("Recursive command complete!\n");
    }
    else if ( !strcmp(Str1, "hyperspace") )
    {
      printf("You've discovered the Hyperspace command! Prepare for a mind-bending warp!\n");
      printf("Are you ready to enter Hyperspace? (y/n): ");
      scanf(" %c", &v4);
      if ( v4 == 121 || v4 == 89 )
      {
        printf("Warping to Hyperspace...");
        printf("\n\n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/| \n");
        printf("|____________________*_____*_____*_____*_______| \n");
        printf("|                                                 | \n");
        printf("|                   *     -^-     *               | \n");
        printf("|    *           .*    /_\\_\\_/_\\   *.             | \n");
        printf("|               .*.     * (_) *     *.     *      | \n");
        printf("|               .*.'             '.*.            | \n");
        printf("|__   *        .*.   '  '')'(''  '   *.   *    __| \n");
        printf("|                             *        .*.      __| \n");
        printf("|             *        *         .*.      .*.__.| \n");
        printf("|                                                 | \n");
        printf("|         *               *              .*.      | \n");
        printf("|    *           *       *           .*.        __| \n");
        printf("|               .*.                    .*.__.   __| \n");
        printf("|               .*.__.           *                 | \n");
        printf("|* ___.  .*.__.        *          .*.    *         | \n");
        printf("|.-' &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'-.        *    .*.                 __| \n");
        printf("|'-=._.-'-._.-'-._.-'-._.-'-._.-'-._.-'-._.-'-.__| \n");
        printf("\n\n");
        printf("You have successfully warped to Hyperspace. Enjoy your mind-bending journey!\n");
      }
      else
      {
        printf("Warp cancelled. Returning to main menu...\n");
      }
    }
    else
    {
      printf("Invalid command. Try again.\n");
    }
  }
}
// 140001A14: using guessed type __int64 __fastcall recursive(_QWORD);
// 140001B20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Spam Detection System ; Style: interoperable
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_INPUT_LEN 1000
#define SPAM_THRESHOLD 0.5

int count_occurrences(char *string, char *substring) {
    int count = 0;
    char *tmp = string;

    while ((tmp = strstr(tmp, substring))) {
        count++;
        tmp += strlen(substring);
    }

    return count;
}

double check_spam(char *input) {
    // list of keywords that are commonly found in spam messages
    char *keywords[] = {"earn", "money", "investment", "opportunity", "limited time offer", "act now"};

    double spam_score = 0;
    int num_keywords = sizeof(keywords) / sizeof(keywords[0]);

    for (int i = 0; i < num_keywords; i++) {
        int occurrences = count_occurrences(input, keywords[i]);
        spam_score += (double) occurrences / (double) strlen(input);
    }

    return spam_score;
}

int main() {
    char input[MAX_INPUT_LEN];
    printf("Enter your message: ");
    fgets(input, MAX_INPUT_LEN, stdin);

    double spam_score = check_spam(input);

    if (spam_score > SPAM_THRESHOLD) {
        printf("This message appears to be spam.\n");
    } else {
        printf("This message seems legit.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
double __fastcall check_spam(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016E6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1000]; // [rsp+20h] [rbp-60h] BYREF
  double v6; // [rsp+408h] [rbp+388h]

  _main(argc, argv, envp);
  printf("Enter your message: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v6 = check_spam(Buffer);
  if ( v6 <= 0.5 )
    printf("This message seems legit.\n");
  else
    printf("This message appears to be spam.\n");
  return 0;
}
// 1400015EA: using guessed type double __fastcall check_spam(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to ASCII art generator ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
    char input_string[100], message[500];
    int i,j, ascii, height=5, width=6;

    printf("Enter a message: ");
    fgets(input_string, 100, stdin);
    input_string[strcspn(input_string, "\n")] = '\0';

    int len = strlen(input_string);

    for(i=0; i<height; i++){
        for(j=0; j<len*(width-1); j++){
            message[i*(len*(width-1))+j] = ' ';
        }
        message[i*(len*(width-1))+(len*(width-1))] = '\n';
    }
    message[height*(len*(width-1))] = '\0';

    for(i=0; i<len; i++){
        ascii = (int) input_string[i];
        for(j=0; j<5; j++){
            switch(ascii){
                case 32:
                    message[(j*len*(width-1))+(i*(width-1))+1] = ' ';
                    message[(j*len*(width-1))+(i*(width-1))+2] = ' ';
                    message[(j*len*(width-1))+(i*(width-1))+3] = ' ';
                    break;
                case 33:
                    message[(j*len*(width-1))+(i*(width-1))+1] = ' ';
                    message[(j*len*(width-1))+(i*(width-1))+2] = '|';
                    message[(j*len*(width-1))+(i*(width-1))+3] = '|';
                    break;

                //more cases for more characters...

                default:
                    printf("Invalid character!\n");
                    return 1;
            }
            message[(j*len*(width-1))+(i*(width-1))] = '/';
            message[(j*len*(width-1))+(i*(width-1))+4] = '\\';
        }
    }

    printf("\n%s\n", message);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char v5[512]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[104]; // [rsp+220h] [rbp+1A0h] BYREF
  int v7; // [rsp+288h] [rbp+208h]
  int v8; // [rsp+28Ch] [rbp+20Ch]
  int v9; // [rsp+290h] [rbp+210h]
  int v10; // [rsp+294h] [rbp+214h]
  int j; // [rsp+298h] [rbp+218h]
  int i; // [rsp+29Ch] [rbp+21Ch]

  _main(argc, argv, envp);
  v10 = 5;
  v9 = 6;
  printf("Enter a message: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  v8 = strlen(Buffer);
  for ( i = 0; i < v10; ++i )
  {
    for ( j = 0; j < v8 * (v9 - 1); ++j )
      v5[i * v8 * (v9 - 1) + j] = 32;
    v5[i * v8 * (v9 - 1) + v8 * (v9 - 1)] = 10;
  }
  v5[v10 * v8 * (v9 - 1)] = 0;
  for ( i = 0; i < v8; ++i )
  {
    v7 = Buffer[i];
    for ( j = 0; j <= 4; ++j )
    {
      if ( v7 == 32 )
      {
        v5[v8 * j * (v9 - 1) + 1 + i * (v9 - 1)] = 32;
        v5[v8 * j * (v9 - 1) + 2 + i * (v9 - 1)] = 32;
        v5[v8 * j * (v9 - 1) + 3 + i * (v9 - 1)] = 32;
      }
      else
      {
        if ( v7 != 33 )
        {
          printf("Invalid character!\n");
          return 1;
        }
        v5[v8 * j * (v9 - 1) + 1 + i * (v9 - 1)] = 32;
        v5[v8 * j * (v9 - 1) + 2 + i * (v9 - 1)] = 124;
        v5[v8 * j * (v9 - 1) + 3 + i * (v9 - 1)] = 124;
      }
      v5[v8 * j * (v9 - 1) + i * (v9 - 1)] = 47;
      v5[v8 * j * (v9 - 1) + 4 + i * (v9 - 1)] = 92;
    }
  }
  printf("\n%s\n", v5);
  return 0;
}
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[104];
// 140001591: using guessed type char var_280[512];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: modular
#include <stdio.h>
#include <stdlib.h>

FILE *fp;

void createFile() {
    char fileName[20];
    printf("Enter the name of file to create: ");
    scanf("%s", fileName);
    fp = fopen(fileName, "w");

    if (fp == NULL) {
        printf("Error creating file.\n");
        exit(1);
    }
    printf("File created successfully!\n");
}

void writeFile() {
    char text[100];
    printf("Enter text to write into the file: ");
    scanf(" %[^\n]", text);

    fputs(text, fp);

    printf("Text written successfully to the file!\n");
}

void readFile() {
    char ch;
    printf("Reading contents of file:\n");
    while ((ch = fgetc(fp)) != EOF) {
        printf("%c", ch);
    }
    printf("\n");
}

void closeFile() {
    fclose(fp);
    printf("File closed successfully!\n");
}

int main() {
    int choice;
    do {
        printf("\n1. Create File\n2. Write to File\n3. Read from File\n4. Close File\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                createFile();
                break;

            case 2:
                if (fp == NULL) {
                    printf("File not created yet!\n");
                    break;
                }
                writeFile();
                break;

            case 3:
                if (fp == NULL) {
                    printf("File not created yet!\n");
                    break;
                }
                readFile();
                break;

            case 4:
                if (fp == NULL) {
                    printf("File not created yet!\n");
                    break;
                }
                closeFile();
                break;

            case 5:
                exit(0);
                break;

            default:
                printf("Invalid choice!\n");
                break;
        }
    } while (choice != 5);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 createFile(void); // weak
__int64 writeFile(void); // weak
__int64 readFile(void); // weak
__int64 closeFile(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

FILE *fp; // idb


//----- (0000000140001749) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("\n1. Create File\n2. Write to File\n3. Read from File\n4. Close File\n5. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        createFile();
        break;
      case 2:
        if ( !fp )
          goto LABEL_10;
        writeFile();
        break;
      case 3:
        if ( !fp )
          goto LABEL_10;
        readFile();
        break;
      case 4:
        if ( fp )
          closeFile();
        else
LABEL_10:
          printf("File not created yet!\n");
        break;
      case 5:
        exit(0);
      default:
        printf("Invalid choice!\n");
        break;
    }
  }
  while ( v4 != 5 );
  return 0;
}
// 1400015E2: using guessed type __int64 createFile(void);
// 140001664: using guessed type __int64 writeFile(void);
// 1400016C0: using guessed type __int64 readFile(void);
// 14000171C: using guessed type __int64 closeFile(void);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Hexadecimal Converter ; Style: protected
#include <stdio.h>
#include <ctype.h>

// Function to check if an input string is a valid hexadecimal string
int is_valid_hex_string(const char *hex_string) {
    while(*hex_string) {
        if(!isxdigit(*hex_string)) {
            return 0;
        }
        hex_string++;
    }
    return 1;
}

// Function to convert a single hexadecimal character to its decimal equivalent
int hex_char_to_decimal(char hex_char) {
    hex_char = toupper(hex_char); // Convert hex character to uppercase for simplicity
    if(hex_char >= '0' && hex_char <= '9') {
        return hex_char - '0'; 
    } else {
        return hex_char - 'A' + 10;
    }
}

// Function to convert a hexadecimal string to its decimal equivalent
int hex_string_to_decimal(const char *hex_string) {
    int decimal_value = 0;
    while(*hex_string) {
        decimal_value = decimal_value * 16 + hex_char_to_decimal(*hex_string);
        hex_string++;
    }
    return decimal_value; 
}

int main() {
    char hex_string[100];
    printf("Enter a hexadecimal number: ");
    scanf("%s", hex_string);

    if(!is_valid_hex_string(hex_string)) {
        printf("Invalid hexadecimal string\n");
        return 1;
    }

    int decimal_value = hex_string_to_decimal(hex_string);
    printf("Decimal equivalent: %d\n", decimal_value);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall is_valid_hex_string(_QWORD); // weak
__int64 __fastcall hex_string_to_decimal(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016BC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[108]; // [rsp+20h] [rbp-70h] BYREF
  unsigned int v5; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter a hexadecimal number: ");
  scanf("%s", v4);
  if ( (unsigned int)is_valid_hex_string(v4) )
  {
    v5 = hex_string_to_decimal(v4);
    printf("Decimal equivalent: %d\n", v5);
    return 0;
  }
  else
  {
    printf("Invalid hexadecimal string\n");
    return 1;
  }
}
// 1400015E2: using guessed type __int64 __fastcall is_valid_hex_string(_QWORD);
// 14000166C: using guessed type __int64 __fastcall hex_string_to_decimal(_QWORD);
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Subnet Calculator ; Style: enthusiastic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

//This is a subnet calculator program that calculates subnet masks, network addresses and broadcast addresses for a given IP address and subnet mask

int main() {

    char ip_address[20], subnet_mask[20], temp[8], network_address[20], broadcast_address[20];
    int subnet_bits, i, j, k, l, octet, subnet_octets[4], subnet_mask_bin[32], ip_address_bin[32], network_address_bin[32], broadcast_address_bin[32];

    //Get user inputs for IP address and subnet mask
    printf("\n\n*** Subnet Calculator ***\n\n");
    printf("Enter IP address (in dotted decimal notation):");
    scanf("%s", ip_address);
    printf("Enter subnet mask (in dotted decimal notation):");
    scanf("%s", subnet_mask);

    //Convert IP address from dotted decimal notation to binary
    for(i=0,j=0,k=0,l=0;i<=strlen(ip_address);i++) {
        if(ip_address[i]=='.' || ip_address[i]=='\0') {
            temp[k]='\0';
            octet=atoi(temp);
            ip_address_bin[j]=octet/128;
            octet=octet%128;
            ip_address_bin[j+1]=octet/64;
            octet=octet%64;
            ip_address_bin[j+2]=octet/32;
            octet=octet%32;
            ip_address_bin[j+3]=octet/16;
            octet=octet%16;
            ip_address_bin[j+4]=octet/8;
            octet=octet%8;
            ip_address_bin[j+5]=octet/4;
            octet=octet%4;
            ip_address_bin[j+6]=octet/2;
            octet=octet%2;
            ip_address_bin[j+7]=octet;
            j=j+8;
            k=0;
        }
        else {
            temp[k]=ip_address[i];
            k++;
        }
    }

    //Convert subnet mask from dotted decimal notation to binary
    for(i=0,j=0,k=0,l=0;i<=strlen(subnet_mask);i++) {
        if(subnet_mask[i]=='.' || subnet_mask[i]=='\0') {
            temp[k]='\0';
            octet=atoi(temp);
            subnet_mask_bin[j]=octet/128;
            octet=octet%128;
            subnet_mask_bin[j+1]=octet/64;
            octet=octet%64;
            subnet_mask_bin[j+2]=octet/32;
            octet=octet%32;
            subnet_mask_bin[j+3]=octet/16;
            octet=octet%16;
            subnet_mask_bin[j+4]=octet/8;
            octet=octet%8;
            subnet_mask_bin[j+5]=octet/4;
            octet=octet%4;
            subnet_mask_bin[j+6]=octet/2;
            octet=octet%2;
            subnet_mask_bin[j+7]=octet;
            j=j+8;
            k=0;
        }
        else {
            temp[k]=subnet_mask[i];
            k++;
        }
    }

    //Calculate number of subnet bits
    for(i=0;i<=31;i++) {
        if(subnet_mask_bin[i]==1)
            subnet_bits++;
    }

    //Calculate subnet octets
    for(i=0,j=0;i<=31;i=i+8,j++) {
        subnet_octets[j]=subnet_mask_bin[i]*128+subnet_mask_bin[i+1]*64+subnet_mask_bin[i+2]*32+subnet_mask_bin[i+3]*16+subnet_mask_bin[i+4]*8+subnet_mask_bin[i+5]*4+subnet_mask_bin[i+6]*2+subnet_mask_bin[i+7];
    }

    //Calculate network address
    for(i=0;i<=31;i++) {
        network_address_bin[i]=ip_address_bin[i] & subnet_mask_bin[i];
    }

    //Calculate broadcast address
    for(i=0;i<=31;i++) {
        if(subnet_mask_bin[i]==1)
            broadcast_address_bin[i]=network_address_bin[i];
        else
            broadcast_address_bin[i]=1;
    }

    //Convert network address and broadcast address from binary to dotted decimal notation
    for(i=0,j=0,k=0,l=0;i<=31;i++) {
        if((i+1)%8==0) {
            temp[k]='\0';
            octet=atoi(temp);
            if(j<3) {
                sprintf(&network_address[l], "%d.", octet);
                sprintf(&broadcast_address[l], "%d.", octet);
            }
            else {
                sprintf(&network_address[l], "%d", octet);
                sprintf(&broadcast_address[l], "%d", octet);
            }
            k=0;
            j++;
            l=l+strlen(temp)+1;
        }
        else {
            sprintf(&temp[k], "%d", network_address_bin[i]);
            sprintf(&temp[k+1], "%c", '\0');
            k++;
        }
    }

    //Print output
    printf("\n\nIP Address: %s",ip_address);
    printf("\nSubnet mask: %s",subnet_mask);
    printf("\n\nNumber of subnet bits: %d",subnet_bits);
    printf("\n\nSubnet octet values: %d.%d.%d.%d",subnet_octets[0],subnet_octets[1],subnet_octets[2],subnet_octets[3]);
    printf("\n\nNetwork Address: %s",network_address);
    printf("\nBroadcast Address: %s\n\n",broadcast_address);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl atoi(const char *String);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[128]; // [rsp+30h] [rbp-50h]
  int v5[4]; // [rsp+230h] [rbp+1B0h]
  char v6[32]; // [rsp+240h] [rbp+1C0h] BYREF
  char v7[24]; // [rsp+260h] [rbp+1E0h] BYREF
  char String[8]; // [rsp+278h] [rbp+1F8h] BYREF
  char v9[32]; // [rsp+280h] [rbp+200h] BYREF
  char Str[24]; // [rsp+2A0h] [rbp+220h] BYREF
  int v11; // [rsp+2B8h] [rbp+238h]
  int v12; // [rsp+2BCh] [rbp+23Ch]
  int v13; // [rsp+2C0h] [rbp+240h]
  int v14; // [rsp+2C4h] [rbp+244h]
  int i; // [rsp+2C8h] [rbp+248h]
  unsigned int v16; // [rsp+2CCh] [rbp+24Ch]

  _main(argc, argv, envp);
  printf("\n\n*** Subnet Calculator ***\n\n");
  printf("Enter IP address (in dotted decimal notation):");
  scanf("%s", Str);
  printf("Enter subnet mask (in dotted decimal notation):");
  scanf("%s", v9);
  i = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  while ( i <= strlen(Str) )
  {
    if ( Str[i] != 46 && Str[i] )
    {
      String[v13++] = Str[i];
    }
    else
    {
      String[v13] = 0;
      v11 = atoi(String);
      v4[v14 + 64] = v11 / 128;
      v11 %= 128;
      v4[v14 + 65] = v11 / 64;
      v11 %= 64;
      v4[v14 + 66] = v11 / 32;
      v11 %= 32;
      v4[v14 + 67] = v11 / 16;
      v11 %= 16;
      v4[v14 + 68] = v11 / 8;
      v11 %= 8;
      v4[v14 + 69] = v11 / 4;
      v11 %= 4;
      v4[v14 + 70] = v11 / 2;
      v11 %= 2;
      v4[v14 + 71] = v11;
      v14 += 8;
      v13 = 0;
    }
    ++i;
  }
  i = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  while ( i <= strlen(v9) )
  {
    if ( v9[i] != 46 && v9[i] )
    {
      String[v13++] = v9[i];
    }
    else
    {
      String[v13] = 0;
      v11 = atoi(String);
      v4[v14 + 96] = v11 / 128;
      v11 %= 128;
      v4[v14 + 97] = v11 / 64;
      v11 %= 64;
      v4[v14 + 98] = v11 / 32;
      v11 %= 32;
      v4[v14 + 99] = v11 / 16;
      v11 %= 16;
      v4[v14 + 100] = v11 / 8;
      v11 %= 8;
      v4[v14 + 101] = v11 / 4;
      v11 %= 4;
      v4[v14 + 102] = v11 / 2;
      v11 %= 2;
      v4[v14 + 103] = v11;
      v14 += 8;
      v13 = 0;
    }
    ++i;
  }
  for ( i = 0; i <= 31; ++i )
  {
    if ( v4[i + 96] == 1 )
      ++v16;
  }
  i = 0;
  v14 = 0;
  while ( i <= 31 )
  {
    v5[v14] = v4[i + 103]
            + 2
            * (2
             * (2 * (2 * (2 * (2 * (2 * v4[i + 96] + v4[i + 97]) + v4[i + 98]) + v4[i + 99]) + v4[i + 100]) + v4[i + 101])
             + v4[i + 102]);
    i += 8;
    ++v14;
  }
  for ( i = 0; i <= 31; ++i )
    v4[i + 32] = v4[i + 96] & v4[i + 64];
  for ( i = 0; i <= 31; ++i )
  {
    if ( v4[i + 96] == 1 )
      v4[i] = v4[i + 32];
    else
      v4[i] = 1;
  }
  i = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  while ( i <= 31 )
  {
    if ( (((_BYTE)i + 1) & 7) != 0 )
    {
      sprintf(&String[v13], "%d", (unsigned int)v4[i + 32]);
      sprintf(&String[++v13], "%c", 0i64);
    }
    else
    {
      String[v13] = 0;
      v11 = atoi(String);
      if ( v14 > 2 )
      {
        sprintf(&v7[v12], "%d", (unsigned int)v11);
        sprintf(&v6[v12], "%d", (unsigned int)v11);
      }
      else
      {
        sprintf(&v7[v12], "%d.", (unsigned int)v11);
        sprintf(&v6[v12], "%d.", (unsigned int)v11);
      }
      v13 = 0;
      ++v14;
      v12 += strlen(String) + 1;
    }
    ++i;
  }
  printf("\n\nIP Address: %s", Str);
  printf("\nSubnet mask: %s", v9);
  printf("\n\nNumber of subnet bits: %d", v16);
  printf("\n\nSubnet octet values: %d.%d.%d.%d", (unsigned int)v5[0], (unsigned int)v5[1], (unsigned int)v5[2], v5[3]);
  printf("\n\nNetwork Address: %s", v7);
  printf("\nBroadcast Address: %s\n\n", v6);
  return 0;
}
// 1400020D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001625: using guessed type char Str[24];
// 140001625: using guessed type char var_60[32];
// 140001625: using guessed type char String[8];
// 140001625: using guessed type char var_80[24];
// 140001625: using guessed type char var_A0[32];

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Disk space analyzer ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <dirent.h>

long long calculate_directory_size(char *path);

int main() {
    long long size = calculate_directory_size(".");
    printf("Size of current directory: %lld bytes\n", size);
    return 0;
}

long long calculate_directory_size(char *path) {
    struct dirent *dir;
    DIR *d = opendir(path);
    if (d == NULL) {
        fprintf(stderr, "Cannot open directory\n");
        exit(EXIT_FAILURE);
    }

    long long total_size = 0;
    char new_path[1024];
    while ((dir = readdir(d)) != NULL) {
        // Ignore the "." and ".." folders
        if (strcmp(dir->d_name, ".") == 0 || strcmp(dir->d_name, "..") == 0) {
            continue;
        }

        // Create the new path by concatenating the directory and the file/folder name
        snprintf(new_path, sizeof(new_path), "%s/%s", path, dir->d_name);

        // Get the file/folder information
        struct stat st;
        if (stat(new_path, &st) == -1) {
            continue;
        }

        // If it's a file, add its size to the total
        if (S_ISREG(st.st_mode)) {
            total_size += st.st_size;
        }
        // If it's a directory, recursively calculate its size and add it to the total
        else if (S_ISDIR(st.st_mode)) {
            total_size += calculate_directory_size(new_path);
        }
    }

    closedir(d);
    return total_size;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall calculate_directory_size(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000161E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v4 = calculate_directory_size(".");
  printf("Size of current directory: %lld bytes\n", v4);
  return 0;
}
// 14000165F: using guessed type __int64 __fastcall calculate_directory_size(_QWORD);
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=157 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature Converter ; Style: Dennis Ritchie
#include <stdio.h>

float convertCtoF(float celsius) {
    return (celsius * 1.8) + 32;
}

float convertCtoK(float celsius) {
    return celsius + 273.15;
}

int main() {
    float celsius, fahrenheit, kelvin;
    
    printf("Enter temperature in Celsius: ");
    scanf("%f", &celsius);
    
    fahrenheit = convertCtoF(celsius);
    kelvin = convertCtoK(celsius);
    
    printf("\nTemperature in Fahrenheit: %.2f", fahrenheit);
    printf("\nTemperature in Kelvin: %.2f", kelvin);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
double convertCtoF(void); // weak
double convertCtoK(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001636) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  unsigned int v6; // [rsp+24h] [rbp-Ch] BYREF
  float v7; // [rsp+28h] [rbp-8h]
  float v8; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter temperature in Celsius: ");
  scanf("%f", &v6);
  v3 = _mm_cvtsi32_si128(v6);
  *(double *)v3.m128i_i64 = convertCtoF();
  v8 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
  v4 = _mm_cvtsi32_si128(v6);
  *(double *)v4.m128i_i64 = convertCtoK();
  v7 = COERCE_FLOAT(_mm_cvtsi128_si32(v4));
  printf("\nTemperature in Fahrenheit: %.2f", v8);
  printf("\nTemperature in Kelvin: %.2f", v7);
  return 0;
}
// 1400015E2: using guessed type double convertCtoF(void);
// 140001612: using guessed type double convertCtoK(void);
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: String manipulation ; Style: excited
#include <stdio.h>
#include <string.h>

int main() {
  char message[100];
  char reverse[100];
  printf("Welcome to the exciting String Manipulation Program!\n");
  printf("Enter a message: ");
  scanf("%[^\n]", message);

  // Remove any spaces from the message
  char no_spaces[100];
  int i, j = 0;
  for (i = 0; message[i] != '\0'; i++) {
    if (message[i] != ' ') {
      no_spaces[j++] = message[i];
    }
  }
  no_spaces[j] = '\0';
  printf("Your message without spaces is: %s\n", no_spaces);

  // Convert all letters to uppercase
  char uppercase[100];
  for (i = 0; no_spaces[i] != '\0'; i++) {
    uppercase[i] = toupper(no_spaces[i]);
  }
  uppercase[i] = '\0';
  printf("Your message in all uppercase is: %s\n", uppercase);

  // Reverse the message
  int length = strlen(no_spaces);
  for (i = length - 1, j = 0; i >= 0; i--, j++) {
    reverse[j] = no_spaces[i];
  }
  reverse[j] = '\0';
  printf("Your message reversed is: %s\n", reverse);

  // Check if message is a palindrome
  if (strcmp(no_spaces, reverse) == 0) {
    printf("Your message is a palindrome! Wow!\n");
  } else {
    printf("Your message is not a palindrome. Keep trying!\n");
  }

  // Add exclamation marks to the end of the message
  int num_exclamations;
  printf("How many exclamation marks do you want to add to the end of your message? ");
  scanf("%d", &num_exclamations);
  if (num_exclamations > 0) {
    char exclamations[100];
    for (i = 0; i < num_exclamations; i++) {
      exclamations[i] = '!';
    }
    exclamations[i] = '\0';
  
    char final_message[200];
    sprintf(final_message, "%s%s", uppercase, exclamations);
    printf("Your final message is: %s\n", final_message);
  }

  printf("Thank you for using the String Manipulation Program! Have a great day!\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl toupper(int C);
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  char v5[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[204]; // [rsp+90h] [rbp+10h] BYREF
  int v7; // [rsp+15Ch] [rbp+DCh] BYREF
  char v8[112]; // [rsp+160h] [rbp+E0h] BYREF
  char Str[112]; // [rsp+1D0h] [rbp+150h] BYREF
  char Str2[112]; // [rsp+240h] [rbp+1C0h] BYREF
  char v11[100]; // [rsp+2B0h] [rbp+230h] BYREF
  int v12; // [rsp+314h] [rbp+294h]
  int v13; // [rsp+318h] [rbp+298h]
  int i; // [rsp+31Ch] [rbp+29Ch]

  _main(argc, argv, envp);
  printf("Welcome to the exciting String Manipulation Program!\n");
  printf("Enter a message: ");
  scanf("%[^\n]", v11);
  v13 = 0;
  for ( i = 0; v11[i]; ++i )
  {
    if ( v11[i] != 32 )
    {
      v3 = v13++;
      Str[v3] = v11[i];
    }
  }
  Str[v13] = 0;
  printf("Your message without spaces is: %s\n", Str);
  for ( i = 0; Str[i]; ++i )
    v8[i] = toupper(Str[i]);
  v8[i] = 0;
  printf("Your message in all uppercase is: %s\n", v8);
  v12 = strlen(Str);
  i = v12 - 1;
  v13 = 0;
  while ( i >= 0 )
    Str2[v13++] = Str[i--];
  Str2[v13] = 0;
  printf("Your message reversed is: %s\n", Str2);
  if ( !strcmp(Str, Str2) )
    printf("Your message is a palindrome! Wow!\n");
  else
    printf("Your message is not a palindrome. Keep trying!\n");
  printf("How many exclamation marks do you want to add to the end of your message? ");
  scanf("%d", &v7);
  if ( v7 > 0 )
  {
    for ( i = 0; i < v7; ++i )
      v5[i] = 33;
    v5[i] = 0;
    sprintf(Buffer, "%s%s", v8, v5);
    printf("Your final message is: %s\n", Buffer);
  }
  printf("Thank you for using the String Manipulation Program! Have a great day!\n");
  return 0;
}
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001625: using guessed type char var_70[100];
// 140001625: using guessed type char Str[112];
// 140001625: using guessed type char var_1C0[112];
// 140001625: using guessed type char Str2[112];
// 140001625: using guessed type char var_300[112];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text Summarizer ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_INPUT_SIZE 100000
#define MAX_SENTENCES 10000
#define MAX_SUMMARY_SIZE 1000

int main() {
    char input[MAX_INPUT_SIZE];
    char sentences[MAX_SENTENCES][MAX_INPUT_SIZE];
    char summary[MAX_SUMMARY_SIZE];
    int sentence_scores[MAX_SENTENCES] = {0};
    int sentence_count = 0;
    int summary_count = 0;

    // Read input from user
    printf("Enter the text to summarize:\n");
    fgets(input, MAX_INPUT_SIZE, stdin);

    // Convert input to lowercase
    for(int i = 0; i < strlen(input); i++){
        input[i] = tolower(input[i]);
    }

    // Tokenize input into sentences
    char* token = strtok(input, ".?!:");
    while(token != NULL && sentence_count < MAX_SENTENCES){
        strcpy(sentences[sentence_count], token);
        sentence_count++;
        token = strtok(NULL, ".?!:");
    }

    // Calculate score for each sentence
    for(int i = 0; i < sentence_count; i++){
        char* word = strtok(sentences[i], " ");
        while(word != NULL){
            if(strcmp(word, "important") == 0 || strcmp(word, "essential") == 0){
                sentence_scores[i]++;
            }
            word = strtok(NULL, " ");
        }
    }

    // Create summary of top 3 sentences
    while(summary_count < 3){
        int highest_score = -1;
        int highest_score_index = -1;
        for(int i = 0; i < sentence_count; i++){
            if(sentence_scores[i] > highest_score){
                highest_score = sentence_scores[i];
                highest_score_index = i;
            }
        }
        if(highest_score_index != -1){
            strcat(summary, sentences[highest_score_index]);
            strcat(summary, ". ");
            sentence_scores[highest_score_index] = -1;
            summary_count++;
        }
    }

    // Print summary
    printf("Summary: %s\n", summary);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (0000000140001591) ----------------------------------------------------
#error "140001591: stack frame is too big (funcsize=0)"

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Movie Rating System ; Style: irregular
#include <stdio.h>

int main() {
  int rating;
  
  printf("Welcome to the Unique C Movie Rating System!\n");
  printf("Please enter your rating (1-10): ");
  scanf("%d", &rating);

  if (rating < 1 || rating > 10) {
    printf("Invalid rating, please enter a number between 1 and 10.\n");
  } else {
    printf("Thank you for rating the movie %d out of 10!\n", rating);
    
    if (rating == 1) {
      printf("Yikes, that's a terrible rating. We're sorry you didn't enjoy the movie.\n");
    } else if (rating > 1 && rating < 5) {
      printf("It sounds like this movie wasn't for you. Thanks for giving it a chance.\n");
    } else if (rating >= 5 && rating < 8) {
      printf("Glad to hear it was enjoyable! Any suggestions on how we can improve?\n");
    } else if (rating >= 8 && rating < 10) {
      printf("Wow, thanks for the high rating! We're thrilled to hear you enjoyed the movie.\n");
    } else if (rating == 10) {
      printf("Congratulations, you've given the movie a perfect rating! This is a huge accomplishment.\n");
    }
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Unique C Movie Rating System!\n");
  printf("Please enter your rating (1-10): ");
  scanf("%d", &v4);
  if ( v4 > 0 && v4 <= 10 )
  {
    printf("Thank you for rating the movie %d out of 10!\n", (unsigned int)v4);
    if ( v4 == 1 )
    {
      printf("Yikes, that's a terrible rating. We're sorry you didn't enjoy the movie.\n");
    }
    else if ( v4 <= 1 || v4 > 4 )
    {
      if ( v4 <= 4 || v4 > 7 )
      {
        if ( v4 <= 7 || v4 > 9 )
        {
          if ( v4 == 10 )
            printf("Congratulations, you've given the movie a perfect rating! This is a huge accomplishment.\n");
        }
        else
        {
          printf("Wow, thanks for the high rating! We're thrilled to hear you enjoyed the movie.\n");
        }
      }
      else
      {
        printf("Glad to hear it was enjoyable! Any suggestions on how we can improve?\n");
      }
    }
    else
    {
      printf("It sounds like this movie wasn't for you. Thanks for giving it a chance.\n");
    }
  }
  else
  {
    printf("Invalid rating, please enter a number between 1 and 10.\n");
  }
  return 0;
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Clustering Algorithm Implementation ; Style: ultraprecise
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<math.h>

#define ROWS 10
#define COLS 2

float distance(float *a, float *b, int cols){   // function to calculate distance between points a and b
    float sum = 0.0;
    int i;
    for(i=0; i<cols; i++){
        sum += pow((b[i]-a[i]), 2.0);
    }
    return sqrt(sum);
}

int find_nearest(float *point, float **centroids, int k, int cols){   // function to find centroid nearest to the point
    int i, nearest;
    float d, min_d = 10000;   // initializing minimum distance to a large value
    for(i=0; i<k; i++){
        d = distance(point, centroids[i], cols);
        if(d < min_d){
            min_d = d;
            nearest = i;
        }
    }
    return nearest;
}

float** create_centroids(int k, int cols){   // function to create k random centroids in the range of 0 to 1
    int i, j;
    float **centroids = (float**)malloc(k*sizeof(float*));
    for(i=0; i<k; i++){
        centroids[i] = (float*)malloc(cols*sizeof(float));
        for(j=0; j<cols; j++){
            centroids[i][j] = (float)rand()/(float)RAND_MAX;
        }
    }
    return centroids;
}

int main(){
    srand(time(NULL));
    float data_points[ROWS][COLS] = {{0.1, 0.6}, {0.15, 0.71}, {0.08, 0.9}, {0.16, 0.85}, {0.2, 0.3}, {0.25, 0.5}, {0.24, 0.1}, {0.3, 0.2}, {0.35, 0.3}, {0.45, 0.2}};  // sample data points with 10 rows and 2 columns
    int k = 3, i, j, iter = 0;
    float **centroids = create_centroids(k, COLS);  // creating initial k random centroids
    int *cluster = (int*)malloc(ROWS*sizeof(int));   // array to store cluster assignments of each point
    int *old_cluster = (int*)malloc(ROWS*sizeof(int));  // array to store old cluster assignments for comparison
    while(1){                               // loop till the clusters no more change
        iter++;
        for(i=0; i<ROWS; i++){
            cluster[i] = find_nearest(data_points[i], centroids, k, COLS); // finding the nearest centroid for each point
        }
        if(iter != 1){
            int diff_count = 0;
            for(i=0; i<ROWS; i++){
                if(cluster[i] != old_cluster[i]){
                    diff_count++;
                }
            }
            if(diff_count == 0){         // if no point has changed cluster, break out of loop
                break;
            }
        }
        for(i=0; i<ROWS; i++){
            old_cluster[i] = cluster[i];
        }
        float **sum = (float**)malloc(k*sizeof(float*));
        int *count = (int*)malloc(k*sizeof(int));
        for(i=0; i<k; i++){
            sum[i] = (float*)calloc(COLS, sizeof(float));
            count[i] = 0;
        }
        for(i=0; i<ROWS; i++){          // calculating sum of points in each cluster
            int c = cluster[i];
            for(j=0; j<COLS; j++){
                sum[c][j] += data_points[i][j];
            }
            count[c]++;
        }
        for(i=0; i<k; i++){            // updating centroids
            for(j=0; j<COLS; j++){
                centroids[i][j] = sum[i][j]/count[i];
            }
        }
        for(i=0; i<k; i++){
            free(sum[i]);              // freeing memory
        }
        free(sum);
        free(count);
    }
    printf("Final clustering:\n");
    for(i=0; i<k; i++){
        printf("Cluster %d: ", i+1);
        for(j=0; j<ROWS; j++){
            if(cluster[j] == i){
                printf("(%f, %f) ", data_points[j][0], data_points[j][1]);
            }
        }
        printf("\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall find_nearest(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall create_centroids(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void *__cdecl calloc(size_t Count, size_t Size);


//----- (00000001400017CB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  _DWORD *v4; // rbx
  void **v5; // rbx
  int v7; // [rsp+20h] [rbp-A0h] BYREF
  int v8[22]; // [rsp+24h] [rbp-9Ch]
  int v9; // [rsp+7Ch] [rbp-44h]
  void *v10; // [rsp+80h] [rbp-40h]
  void *Block; // [rsp+88h] [rbp-38h]
  _DWORD *v12; // [rsp+90h] [rbp-30h]
  _DWORD *v13; // [rsp+98h] [rbp-28h]
  __int64 centroids; // [rsp+A0h] [rbp-20h]
  int v15; // [rsp+ACh] [rbp-14h]
  int v16; // [rsp+B0h] [rbp-10h]
  int v17; // [rsp+B4h] [rbp-Ch]
  int j; // [rsp+B8h] [rbp-8h]
  int i; // [rsp+BCh] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v7 = 1036831949;
  v8[0] = 1058642330;
  v8[1] = 1041865114;
  v8[2] = 1060487823;
  v8[3] = 1034147594;
  v8[4] = 1063675494;
  v8[5] = 1042536202;
  v8[6] = 1062836634;
  v8[7] = 1045220557;
  v8[8] = 1050253722;
  v8[9] = 1048576000;
  v8[10] = 1056964608;
  v8[11] = 1047904911;
  v8[12] = 1036831949;
  v8[13] = 1050253722;
  v8[14] = 1045220557;
  v8[15] = 1051931443;
  v8[16] = 1050253722;
  v8[17] = 1055286886;
  v8[18] = 1045220557;
  v15 = 3;
  v17 = 0;
  centroids = create_centroids(3i64, 2i64);
  v13 = malloc(0x28ui64);
  v12 = malloc(0x28ui64);
  while ( 1 )
  {
    ++v17;
    for ( i = 0; i <= 9; *v4 = find_nearest(&v8[2 * i++ - 1], centroids, (unsigned int)v15, 2i64) )
      v4 = &v13[i];
    if ( v17 != 1 )
    {
      v16 = 0;
      for ( i = 0; i <= 9; ++i )
      {
        if ( v13[i] != v12[i] )
          ++v16;
      }
      if ( !v16 )
        break;
    }
    for ( i = 0; i <= 9; ++i )
      v12[i] = v13[i];
    Block = malloc(8i64 * v15);
    v10 = malloc(4i64 * v15);
    for ( i = 0; i < v15; ++i )
    {
      v5 = (void **)((char *)Block + 8 * i);
      *v5 = calloc(2ui64, 4ui64);
      *((_DWORD *)v10 + i) = 0;
    }
    for ( i = 0; i <= 9; ++i )
    {
      v9 = v13[i];
      for ( j = 0; j <= 1; ++j )
        *(float *)(*((_QWORD *)Block + v9) + 4i64 * j) = *(float *)&v8[2 * i - 1 + j]
                                                       + *(float *)(*((_QWORD *)Block + v9) + 4i64 * j);
      ++*((_DWORD *)v10 + v9);
    }
    for ( i = 0; i < v15; ++i )
    {
      for ( j = 0; j <= 1; ++j )
        *(float *)(*(_QWORD *)(8i64 * i + centroids) + 4i64 * j) = *(float *)(*((_QWORD *)Block + i) + 4i64 * j)
                                                                 / (float)*((int *)v10 + i);
    }
    for ( i = 0; i < v15; ++i )
      free(*((void **)Block + i));
    free(Block);
    free(v10);
  }
  printf("Final clustering:\n");
  for ( i = 0; i < v15; ++i )
  {
    printf("Cluster %d: ", (unsigned int)(i + 1));
    for ( j = 0; j <= 9; ++j )
    {
      if ( i == v13[j] )
        printf("(%f, %f) ", *(float *)&v8[2 * j - 1], *(float *)&v8[2 * j]);
    }
    printf("\n");
  }
  return 0;
}
// 140001671: using guessed type __int64 __fastcall find_nearest(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400016FF: using guessed type __int64 __fastcall create_centroids(_QWORD, _QWORD);
// 140001E30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=150 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text Summarizer ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SENTENCES 100
#define MAX_WORD_LENGTH 50

void readText(char *text, int len);
int getWordCount(char *text);
int getSentencesCount(char *text);
int tokenize(char *text, char tokens[][MAX_WORD_LENGTH], char delimeter);
void createSummary(char *text, char summary[][MAX_WORD_LENGTH], int summarySize, int wordCount, int sentenceCount, char *tokens[MAX_SENTENCES][MAX_WORD_LENGTH]);

int main() {
    char text[1000];
    printf("Enter Text:\n");
    readText(text, 1000);

    int wordCount = getWordCount(text);
    printf("Words in Text: %d\n", wordCount);

    int sentenceCount = getSentencesCount(text);
    printf("Sentences in Text: %d\n", sentenceCount);

    char tokens[MAX_SENTENCES][MAX_WORD_LENGTH];
    int sentenceStartIndexes[MAX_SENTENCES];
    int sentenceCountIndex = tokenize(text, tokens, '.');
    for (int i=0; i<sentenceCountIndex; i++) {
        sentenceStartIndexes[i] = i;
    }

    // sort sentences based on their length
    for (int i=0;i<sentenceCountIndex;i++) {
        int sentenceLength = strlen(tokens[i]);
        for (int j=i+1;j<sentenceCountIndex;j++) {
            int currentSentenceLength = strlen(tokens[j]);
            if (currentSentenceLength > sentenceLength) {
                char temp[MAX_WORD_LENGTH];
                int tempIndex = sentenceStartIndexes[i];

                sentenceStartIndexes[i] = sentenceStartIndexes[j];
                sentenceStartIndexes[j] = tempIndex;

                strcpy(temp, tokens[i]);
                strcpy(tokens[i], tokens[j]);
                strcpy(tokens[j], temp);

                sentenceLength = strlen(tokens[i]);
            }
        }
    }

    // create summary
    char summary[MAX_SENTENCES][MAX_WORD_LENGTH];
    createSummary(text, summary, 3, wordCount, sentenceCount, (char (*)[])tokens);
    printf("Summary:\n");
    for (int i=0; i<3; i++) {
        printf("%s. ", summary[i]);
    }
    printf("\n");

    return 0;
}

void readText(char *text, int len) {
    int i=0;
    char c;
    while ((c=getchar()) != '\n' && i<len) {
        text[i++] = c;
    }
    text[i] = '\0';
}

int getWordCount(char *text) {
    int wordCount = 0;
    while (*text != '\0') {
        if (*text == ' ') {
            wordCount++;
        }
        text++;
    }
    return wordCount + 1;
}

int getSentencesCount(char *text) {
    int sentenceCount = 0;
    while (*text != '\0') {
        if (*text == '.' || *text == '?' || *text == '!') {
            sentenceCount++;
        }
        text++;
    }
    return sentenceCount;
}

int tokenize(char *text, char tokens[][MAX_WORD_LENGTH], char delimeter) {
    int currentTokenIndex = 0;
    int currentTokenLength = 0;
    while (*text != '\0') {
        if (*text == delimeter) {
            currentTokenLength = 0;
            currentTokenIndex++;
        } else if (*text == '\n') {
            break;
        } else {
            tokens[currentTokenIndex][currentTokenLength++] = *text;
        }
        text++;
    }
    return currentTokenIndex + 1;
}

void createSummary(char *text, char summary[][MAX_WORD_LENGTH], int summarySize, int wordCount, int sentenceCount, char *tokens[MAX_SENTENCES][MAX_WORD_LENGTH]) {
    int sentenceIndexesToInclude[3];
    for (int i=0; i<summarySize; i++) {
        int maxWordCount = 0;
        for (int j=0; j<sentenceCount; j++) {
            int length = strlen(tokens[j]);
            if (length > maxWordCount && !strstr(text, summary[j])) {
                maxWordCount = length;
                sentenceIndexesToInclude[i] = j;
            }
        }
        strcpy(summary[i], tokens[sentenceIndexesToInclude[i]]);
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall readText(_QWORD, _QWORD); // weak
__int64 __fastcall getWordCount(_QWORD); // weak
__int64 __fastcall getSentencesCount(_QWORD); // weak
__int64 __fastcall tokenize(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall createSummary(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Destination[64]; // [rsp+30h] [rbp-50h] BYREF
  _WORD v5[2704]; // [rsp+70h] [rbp-10h] BYREF
  char v6[5008]; // [rsp+1590h] [rbp+1510h] BYREF
  char v7[1000]; // [rsp+2920h] [rbp+28A0h] BYREF
  int v8; // [rsp+2D08h] [rbp+2C88h]
  int v9; // [rsp+2D0Ch] [rbp+2C8Ch]
  int v10; // [rsp+2D10h] [rbp+2C90h]
  unsigned int SentencesCount; // [rsp+2D14h] [rbp+2C94h]
  unsigned int WordCount; // [rsp+2D18h] [rbp+2C98h]
  int m; // [rsp+2D1Ch] [rbp+2C9Ch]
  int k; // [rsp+2D20h] [rbp+2CA0h]
  int v15; // [rsp+2D24h] [rbp+2CA4h]
  int j; // [rsp+2D28h] [rbp+2CA8h]
  int i; // [rsp+2D2Ch] [rbp+2CACh]

  _main(argc, argv, envp);
  printf("Enter Text:\n");
  readText(v7, 1000i64);
  WordCount = getWordCount(v7);
  printf("Words in Text: %d\n", WordCount);
  SentencesCount = getSentencesCount(v7);
  printf("Sentences in Text: %d\n", SentencesCount);
  v10 = tokenize(v7, v6, 46i64);
  for ( i = 0; i < v10; ++i )
    *(_DWORD *)&v5[2 * i + 2504] = i;
  for ( j = 0; j < v10; ++j )
  {
    v15 = strlen(&v6[50 * j]);
    for ( k = j + 1; k < v10; ++k )
    {
      v9 = strlen(&v6[50 * k]);
      if ( v9 > v15 )
      {
        v8 = *(_DWORD *)&v5[2 * j + 2504];
        *(_DWORD *)&v5[2 * j + 2504] = *(_DWORD *)&v5[2 * k + 2504];
        *(_DWORD *)&v5[2 * k + 2504] = v8;
        strcpy(Destination, &v6[50 * j]);
        strcpy(&v6[50 * j], &v6[50 * k]);
        strcpy(&v6[50 * k], Destination);
        v15 = strlen(&v6[50 * j]);
      }
    }
  }
  createSummary((unsigned int)v7, (unsigned int)v5, 3, WordCount, SentencesCount, (__int64)v6);
  printf("Summary:\n");
  for ( m = 0; m <= 2; ++m )
    printf("%s. ", (const char *)&v5[25 * m]);
  printf("\n");
  return 0;
}
// 140001962: using guessed type __int64 __fastcall readText(_QWORD, _QWORD);
// 1400019C0: using guessed type __int64 __fastcall getWordCount(_QWORD);
// 140001A00: using guessed type __int64 __fastcall getSentencesCount(_QWORD);
// 140001A53: using guessed type __int64 __fastcall tokenize(_QWORD, _QWORD, _QWORD);
// 140001AFA: using guessed type __int64 __fastcall createSummary(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 140001CF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char var_17A0[5008];

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data recovery tool ; Style: protected
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define BUFFER_SIZE 512

int main()
{
    FILE *fp;
    size_t fileLen;
    char *buffer, fileName[20], newFileName[30];
    int i, j, extensionIndex;

    // Get the name of the file to be recovered from user
    printf("Enter filename: ");
    scanf("%s", fileName);

    // Open the file in read mode
    fp = fopen(fileName, "r");
    if(fp == NULL)
    {
        printf("Error: Failed to open file %s\n", fileName);
        exit(1);
    }

    // Calculate the size of the file
    fseek(fp, 0, SEEK_END);
    fileLen = ftell(fp);
    rewind(fp);

    // Allocate memory for the buffer to store the file content
    buffer = (char *) malloc(fileLen * sizeof(char));
    if(buffer == NULL)
    {
        printf("Error: Failed to allocate memory for buffer\n");
        fclose(fp);
        exit(1);
    }

    // Read the contents of the file into the buffer
    fread(buffer, fileLen, 1, fp);

    // Close the file
    fclose(fp);

    // Search for the file extension
    extensionIndex = -1;
    for(i = strlen(fileName) - 1; i >= 0; i--)
    {
        if(fileName[i] == '.')
        {
            extensionIndex = i;
            break;
        }
    }

    if(extensionIndex == -1)
    {
        printf("Error: File extension not found\n");
        free(buffer);
        exit(1);
    }

    // Generate the new filename by appending "_recovered" to the original filename
    strncpy(newFileName, fileName, extensionIndex);
    strcat(newFileName, "_recovered");
    strcat(newFileName, fileName + extensionIndex);

    // Open the newly generated file in write mode
    fp = fopen(newFileName, "wb");
    if(fp == NULL)
    {
        printf("Error: Failed to create recovered file %s\n", newFileName);
        free(buffer);
        exit(1);
    }

    // Write the contents of the buffer back to the file
    fwrite(buffer, fileLen, 1, fp);

    // Close the file
    fclose(fp);

    // Free up the memory allocated for the buffer
    free(buffer);

    printf("Recovery process completed successfully. Recovered file saved as %s\n", newFileName);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcat(char *Destination, const char *Source);
// void __cdecl rewind(FILE *Stream);
// void *__cdecl malloc(size_t Size);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// void __cdecl free(void *Block);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Destination[32]; // [rsp+20h] [rbp-60h] BYREF
  char FileName[32]; // [rsp+40h] [rbp-40h] BYREF
  void *Buffer; // [rsp+60h] [rbp-20h]
  size_t Size; // [rsp+68h] [rbp-18h]
  FILE *Stream; // [rsp+70h] [rbp-10h]
  int v9; // [rsp+78h] [rbp-8h]
  int i; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter filename: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "r");
  if ( !Stream )
  {
    printf("Error: Failed to open file %s\n", FileName);
    exit(1);
  }
  fseek(Stream, 0, 2);
  Size = ftell(Stream);
  rewind(Stream);
  Buffer = malloc(Size);
  if ( !Buffer )
  {
    printf("Error: Failed to allocate memory for buffer\n");
    fclose(Stream);
    exit(1);
  }
  fread(Buffer, Size, 1ui64, Stream);
  fclose(Stream);
  v9 = -1;
  for ( i = strlen(FileName) - 1; i >= 0; --i )
  {
    if ( FileName[i] == 46 )
    {
      v9 = i;
      break;
    }
  }
  if ( v9 == -1 )
  {
    printf("Error: File extension not found\n");
    free(Buffer);
    exit(1);
  }
  strncpy(Destination, FileName, v9);
  strcat(Destination, "_recovered");
  strcat(Destination, &FileName[v9]);
  Stream = fopen(Destination, "wb");
  if ( !Stream )
  {
    printf("Error: Failed to create recovered file %s\n", Destination);
    free(Buffer);
    exit(1);
  }
  fwrite(Buffer, Size, 1ui64, Stream);
  fclose(Stream);
  free(Buffer);
  printf("Recovery process completed successfully. Recovered file saved as %s\n", Destination);
  return 0;
}
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char FileName[32];

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: Sherlock Holmes
#include <stdio.h>

int main() {
    // create an array of integers
    int arr[10] = { 4, 3, 6, 8, 1, 9, 2, 5, 7, 0 };
    int n = 10;
    
    // print the unsorted array
    printf("Unsorted array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    // implement bubble sort algorithm
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-1-i; j++) {
            if (arr[j] > arr[j+1]) {
                // swap elements
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    
    // print the sorted array
    printf("Sorted array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[10]; // [rsp+20h] [rbp-40h]
  int v5; // [rsp+48h] [rbp-18h]
  int v6; // [rsp+4Ch] [rbp-14h]
  int m; // [rsp+50h] [rbp-10h]
  int k; // [rsp+54h] [rbp-Ch]
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 4;
  v4[1] = 3;
  v4[2] = 6;
  v4[3] = 8;
  v4[4] = 1;
  v4[5] = 9;
  v4[6] = 2;
  v4[7] = 5;
  v4[8] = 7;
  v4[9] = 0;
  v6 = 10;
  printf("Unsorted array: ");
  for ( i = 0; i < v6; ++i )
    printf("%d ", (unsigned int)v4[i]);
  printf("\n");
  for ( j = 0; j < v6 - 1; ++j )
  {
    for ( k = 0; k < v6 - 1 - j; ++k )
    {
      if ( v4[k] > v4[k + 1] )
      {
        v5 = v4[k];
        v4[k] = v4[k + 1];
        v4[k + 1] = v5;
      }
    }
  }
  printf("Sorted array: ");
  for ( m = 0; m < v6; ++m )
    printf("%d ", (unsigned int)v4[m]);
  printf("\n");
  return 0;
}
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data validation ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_STRING_SIZE 256

typedef struct {
    char firstName[MAX_STRING_SIZE];
    char lastName[MAX_STRING_SIZE];
    char email[MAX_STRING_SIZE];
    char phoneNumber[MAX_STRING_SIZE];
} User;

bool isValidEmail(char* email) {
    // Check for "@" symbol and at least one "."
    int countAtSymbol = 0;
    int countDotSymbol = 0;
    for (int i = 0; i < strlen(email); i++) {
        if (email[i] == '@') {
            countAtSymbol++;
        }
        else if (email[i] == '.') {
            countDotSymbol++;
        }
    }
    if (countAtSymbol == 1 && countDotSymbol > 0) {
        return true;
    }
    else {
        return false;
    }
}

bool isValidPhoneNumber(char* phoneNumber) {
    // Check for 10 digits and optional "-"'s, "(", and ")"
    int countDigits = 0;
    for (int i = 0; i < strlen(phoneNumber); i++) {
        if (isdigit(phoneNumber[i])) {
            countDigits++;
        }
        else if (phoneNumber[i] != '-' && phoneNumber[i] != '(' && phoneNumber[i] != ')') {
            return false;
        }
    }
    if (countDigits == 10) {
        return true;
    }
    else {
        return false;
    }
}

int main() {
    User user;
    printf("Enter first name: ");
    fgets(user.firstName, MAX_STRING_SIZE, stdin);
    user.firstName[strcspn(user.firstName, "\n")] = '\0';
    printf("Enter last name: ");
    fgets(user.lastName, MAX_STRING_SIZE, stdin);
    user.lastName[strcspn(user.lastName, "\n")] = '\0';

    // Validate email
    bool isValid = false;
    while (!isValid) {
        printf("Enter email: ");
        fgets(user.email, MAX_STRING_SIZE, stdin);
        user.email[strcspn(user.email, "\n")] = '\0';
        if (isValidEmail(user.email)) {
            isValid = true;
        }
        else {
            printf("Invalid email! Must contain '@' and at least one '.'\n");
        }
    }

    // Validate phone number
    isValid = false;
    while (!isValid) {
        printf("Enter phone number (format: xxx-xxx-xxxx): ");
        fgets(user.phoneNumber, MAX_STRING_SIZE, stdin);
        user.phoneNumber[strcspn(user.phoneNumber, "\n")] = '\0';
        if (isValidPhoneNumber(user.phoneNumber)) {
            isValid = true;
        }
        else {
            printf("Invalid phone number! Must contain 10 digits and optional '-''s, '(', and ')'\n");
        }
    }

    printf("\nUser information:\n");
    printf("First name: %s\n", user.firstName);
    printf("Last name: %s\n", user.lastName);
    printf("Email: %s\n", user.email);
    printf("Phone number: %s\n", user.phoneNumber);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall isValidEmail(_QWORD); // weak
__int64 __fastcall isValidPhoneNumber(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  FILE *v6; // rax
  char Buffer[256]; // [rsp+20h] [rbp-60h] BYREF
  char v9[256]; // [rsp+120h] [rbp+A0h] BYREF
  char v10[256]; // [rsp+220h] [rbp+1A0h] BYREF
  char v11[271]; // [rsp+320h] [rbp+2A0h] BYREF
  char v12; // [rsp+42Fh] [rbp+3AFh]

  _main(argc, argv, envp);
  printf("Enter first name: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 256, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  printf("Enter last name: ");
  v4 = __acrt_iob_func(0);
  fgets(v9, 256, v4);
  v9[strcspn(v9, "\n")] = 0;
  v12 = 0;
  while ( v12 != 1 )
  {
    printf("Enter email: ");
    v5 = __acrt_iob_func(0);
    fgets(v10, 256, v5);
    v10[strcspn(v10, "\n")] = 0;
    if ( (unsigned __int8)isValidEmail(v10) )
      v12 = 1;
    else
      printf("Invalid email! Must contain '@' and at least one '.'\n");
  }
  v12 = 0;
  while ( v12 != 1 )
  {
    printf("Enter phone number (format: xxx-xxx-xxxx): ");
    v6 = __acrt_iob_func(0);
    fgets(v11, 256, v6);
    v11[strcspn(v11, "\n")] = 0;
    if ( (unsigned __int8)isValidPhoneNumber(v11) )
      v12 = 1;
    else
      printf("Invalid phone number! Must contain 10 digits and optional '-''s, '(', and ')'\n");
  }
  printf("\nUser information:\n");
  printf("First name: %s\n", Buffer);
  printf("Last name: %s\n", v9);
  printf("Email: %s\n", v10);
  printf("Phone number: %s\n", v11);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall isValidEmail(_QWORD);
// 140001620: using guessed type __int64 __fastcall isValidPhoneNumber(_QWORD);
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016D4: using guessed type char Buffer[256];
// 1400016D4: using guessed type char var_310[256];
// 1400016D4: using guessed type char var_210[256];
// 1400016D4: using guessed type char var_110[271];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Airport Baggage Handling Simulation ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {

    // Initialize variables for the simulation
    int num_bags = 100;
    int conveyor_speed = 10;
    int conveyor_length = 50;
    int processing_time = 2;
    int min_wait_time = 1;
    int max_wait_time = 5;

    int bags_on_conveyor = 0;
    int bags_processed = 0;
    int bags_lost = 0;

    srand(time(NULL)); // Seed random number generator

    // Begin simulation loop
    for (int i = 0; i < num_bags; i++) {

        // Determine if bag makes it onto conveyor
        int r = rand() % 100;

        if (r < 50) {
            printf("Bag lost in surreal fashion.\n");
            bags_lost++;
            continue;
        }

        // Calculate time for bag to reach end of conveyor
        int conveyor_time = conveyor_length / conveyor_speed;

        // Wait for bag to arrive at end of conveyor
        for (int j = 1; j <= conveyor_time; j++) {
            printf("Waiting for bag to arrive on conveyor: %ds\n", j);
            sleep(1);
        }

        // Random processing time for each bag
        int p_time = rand() % processing_time + 1 + min_wait_time;

        // Process the bag
        for (int k = 1; k <= p_time; k++) {
            printf("Processing the bag: %ds\n", k);
            sleep(1);
        }

        printf("Bag processed and removed from system.\n");

        bags_processed++;

    }

    // Print simulation results
    printf("\nSimulation completed.\n");
    printf("Bags processed: %d\n", bags_processed);
    printf("Bags lost: %d\n", bags_lost);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-3Ch]
  int k; // [rsp+4Ch] [rbp-14h]
  int j; // [rsp+50h] [rbp-10h]
  int i; // [rsp+54h] [rbp-Ch]
  unsigned int v9; // [rsp+58h] [rbp-8h]
  unsigned int v10; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 0;
  v9 = 0;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i < 100; ++i )
  {
    if ( rand() % 100 > 49 )
    {
      for ( j = 1; j <= 5; ++j )
      {
        printf("Waiting for bag to arrive on conveyor: %ds\n", (unsigned int)j);
        sleep(1i64);
      }
      v5 = rand() % 2 + 2;
      for ( k = 1; k <= v5; ++k )
      {
        printf("Processing the bag: %ds\n", (unsigned int)k);
        sleep(1i64);
      }
      printf("Bag processed and removed from system.\n");
      ++v10;
    }
    else
    {
      printf("Bag lost in surreal fashion.\n");
      ++v9;
    }
  }
  printf("\nSimulation completed.\n");
  printf("Bags processed: %d\n", v10);
  printf("Bags lost: %d\n", v9);
  return 0;
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002860: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: CPU Scheduling Algorithms ; Style: high level of detail
#include<stdio.h>
#include<stdlib.h>

struct process{
    int pid;  //process id
    int bt;   //burst time
    int at;   //arrival time
    int wt;   //wait time
    int tat;  //turn around time
    int ct;   //completion time
};

void swap(struct process *p1, struct process *p2){
    struct process temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

void sort_by_arrival_time(struct process *p, int n){
    int i, j;
    for(i=0;i<n-1;i++){
        for(j=0;j<n-i-1;j++){
            if(p[j].at > p[j+1].at){
                swap(&p[j], &p[j+1]);
            }
        }
    }
}

void round_robin(struct process *p, int n, int tq){
    int i, j, rem_bt[n];
    for(i=0;i<n;i++){
        rem_bt[i] = p[i].bt;
    }
    int t = 0, wt_total = 0, tat_total = 0;
    while(1){
        int done = 1;
        for(i=0;i<n;i++){
            if(rem_bt[i]>0){
                done = 0;
                if(rem_bt[i] > tq){
                    t += tq;
                    rem_bt[i] -= tq;
                }else{
                    t += rem_bt[i];
                    p[i].ct = t;
                    rem_bt[i] = 0;
                    p[i].tat = p[i].ct - p[i].at;
                    p[i].wt = p[i].tat - p[i].bt;
                    wt_total += p[i].wt;
                    tat_total += p[i].tat;
                }
            }
        }
        if(done == 1){
            break;
        }
    }

    float avg_wt = (float)wt_total/n;
    float avg_tat = (float)tat_total/n;

    printf("\nPID\tAT\tBT\tCT\tTAT\tWT\n");
    for(i=0;i<n;i++){
        printf("%d\t%d\t%d\t%d\t%d\t%d\n", p[i].pid, p[i].at, p[i].bt, p[i].ct, p[i].tat, p[i].wt);
    }
    printf("Average waiting time: %.2f\n", avg_wt);
    printf("Average turn around time: %.2f", avg_tat);

}

int main(){
    int n, i, tq;
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct process p[n];
    for(i=0;i<n;i++){
        printf("Process %d\n", i+1);
        printf("Enter arrival time: ");
        scanf("%d", &p[i].at);
        printf("Enter burst time: ");
        scanf("%d", &p[i].bt);
        p[i].pid = i+1;
        p[i].wt = 0;
        p[i].tat = 0;
        p[i].ct = 0;
    }

    //Sorting the processes by their arrival time
    sort_by_arrival_time(p, n);

    printf("Enter time quantum: ");
    scanf("%d", &tq);

    //Applying round robin algorithm
    round_robin(p, n, tq);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall sort_by_arrival_time(_QWORD, _QWORD); // weak
__int64 __fastcall round_robin(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001B83) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  unsigned int v5; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v6; // [rsp+24h] [rbp-1Ch] BYREF
  unsigned int *v7; // [rsp+28h] [rbp-18h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of processes: ");
  scanf("%d", &v6);
  v8 = (int)v6 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(24i64 * (int)v6 + 15) >> 4));
  v7 = &v5;
  for ( i = 0; i < (int)v6; ++i )
  {
    printf("Process %d\n", (unsigned int)(i + 1));
    printf("Enter arrival time: ");
    scanf("%d", &v7[6 * i + 2]);
    printf("Enter burst time: ");
    scanf("%d", &v7[6 * i + 1]);
    v7[6 * i] = i + 1;
    v7[6 * i + 3] = 0;
    v7[6 * i + 4] = 0;
    v7[6 * i + 5] = 0;
  }
  sort_by_arrival_time(v7, v6);
  printf("Enter time quantum: ");
  scanf("%d", &v5);
  round_robin(v7, v6, v5);
  return 0;
}
// 14000164D: using guessed type __int64 __fastcall sort_by_arrival_time(_QWORD, _QWORD);
// 140001731: using guessed type __int64 __fastcall round_robin(_QWORD, _QWORD, _QWORD);
// 140001EC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Ebook reader ; Style: imaginative
#include<stdio.h>
#include<stdlib.h>

typedef struct Book {
   char title[50];
   char author[50];
   int pages;
   float price;
} Book;

int main() {
   Book book1;
   printf("Enter the book title: ");
   fgets(book1.title, sizeof(book1.title), stdin);
   printf("Enter the author name: ");
   fgets(book1.author, sizeof(book1.author), stdin);
   printf("Enter the number of pages: ");
   scanf("%d", &book1.pages);
   printf("Enter the price: ");
   scanf("%f", &book1.price);

   printf("\n\n*** Book Details ***\n\n");
   printf("Title: %s", book1.title);
   printf("Author: %s", book1.author);
   printf("Pages: %d", book1.pages);
   printf("Price: $%.2f", book1.price);

   FILE *file_pointer;
   file_pointer = fopen("book1.txt", "w");
   if (file_pointer == NULL) {
      printf("Error opening file.");
      exit(1);
   }

   fprintf(file_pointer, "*** Book Details ***\n\n");
   fprintf(file_pointer, "Title: %s", book1.title);
   fprintf(file_pointer, "Author: %s", book1.author);
   fprintf(file_pointer, "Pages: %d", book1.pages);
   fprintf(file_pointer, "Price: $%.2f", book1.price);

   fclose(file_pointer);
   printf("\n\nBook details saved to file.");
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Buffer[50]; // [rsp+20h] [rbp-80h] BYREF
  char v7[50]; // [rsp+52h] [rbp-4Eh] BYREF
  unsigned int v8; // [rsp+84h] [rbp-1Ch] BYREF
  float v9[4]; // [rsp+88h] [rbp-18h] BYREF
  FILE *Stream; // [rsp+98h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter the book title: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 50, v3);
  printf("Enter the author name: ");
  v4 = __acrt_iob_func(0);
  fgets(v7, 50, v4);
  printf("Enter the number of pages: ");
  scanf("%d", &v8);
  printf("Enter the price: ");
  scanf("%f", v9);
  printf("\n\n*** Book Details ***\n\n");
  printf("Title: %s", Buffer);
  printf("Author: %s", v7);
  printf("Pages: %d", v8);
  printf("Price: $%.2f", v9[0]);
  Stream = fopen("book1.txt", "w");
  if ( !Stream )
  {
    printf("Error opening file.");
    exit(1);
  }
  fprintf_0(Stream, "*** Book Details ***\n\n");
  fprintf_0(Stream, "Title: %s", Buffer);
  fprintf_0(Stream, "Author: %s", v7);
  fprintf_0(Stream, "Pages: %d", v8);
  fprintf_0(Stream, "Price: $%.2f", v9[0]);
  fclose(Stream);
  printf("\n\nBook details saved to file.");
  return 0;
}
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001625: using guessed type float var_18[4];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Watermarking ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char message[1000];          // Maximum 1000 characters allowed in message
    char key[100];              // Key for encryption/decryption
    int watermark_size;          // Watermark size to be inserted
    int secret_key;              // Secret key for authentication
} watermark;

// Function to encrypt message using key
void encrypt_message(watermark *wm) {
    int i, j = 0;
    for (i = 0; i < strlen(wm->message); i++) {
        wm->message[i] = wm->message[i] + wm->key[j];
        j++;
        if (j == strlen(wm->key)) j = 0;   // Reset index of key if it exceeds key length
    }
}

// Function to decrypt message using key
void decrypt_message(watermark *wm) {
    int i, j = 0;
    for (i = 0; i < strlen(wm->message); i++) {
        wm->message[i] = wm->message[i] - wm->key[j];
        j++;
        if (j == strlen(wm->key)) j = 0;   // Reset index of key if it exceeds key length
    }
}

// Function to insert watermark in message
void insert_watermark(watermark *wm) {
    int i, j = 0;
    char watermark[100] = "THIS IS A WATERMARK";   // Hardcoded watermark
    for (i = 0; i < wm->watermark_size; i++) {
        wm->message[j] = watermark[i];   // Insert watermark in message
        j++;
    }
}

// Function to authenticate using secret key
int authenticate(watermark *wm, int input_key) {
    if (input_key == wm->secret_key) return 1;
    else return 0;
}

int main() {
    watermark wm;
    
    // Taking message, key, watermark size and secret key as input from user
    printf("Enter the message:\n");
    fgets(wm.message, sizeof(wm.message), stdin);
    printf("Enter the key:\n");
    fgets(wm.key, sizeof(wm.key), stdin);
    printf("Enter the watermark size:\n");
    scanf("%d", &wm.watermark_size);
    printf("Enter the secret key:\n");
    scanf("%d", &wm.secret_key);
    
    encrypt_message(&wm);   // Encrypting message
    
    insert_watermark(&wm);  // Inserting watermark in message
    
    if (authenticate(&wm, wm.secret_key)) {   // Authenticating using secret key
        printf("The watermarked message is:\n");
        printf("%s\n", wm.message);    // Displaying watermarked message
        
        decrypt_message(&wm);   // Decrypting message
        printf("The original message is:\n");
        printf("%s\n", wm.message);    // Displaying original message
    }
    else {
        printf("Authentication failed!\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt_message(_QWORD); // weak
__int64 __fastcall decrypt_message(_QWORD); // weak
__int64 __fastcall insert_watermark(_QWORD); // weak
__int64 __fastcall authenticate(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001808) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Buffer[1000]; // [rsp+20h] [rbp-60h] BYREF
  char v7[100]; // [rsp+408h] [rbp+388h] BYREF
  int v8; // [rsp+46Ch] [rbp+3ECh] BYREF
  unsigned int v9[4]; // [rsp+470h] [rbp+3F0h] BYREF

  _main(argc, argv, envp);
  printf("Enter the message:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  printf("Enter the key:\n");
  v4 = __acrt_iob_func(0);
  fgets(v7, 100, v4);
  printf("Enter the watermark size:\n");
  scanf("%d", &v8);
  printf("Enter the secret key:\n");
  scanf("%d", v9);
  encrypt_message(Buffer);
  insert_watermark(Buffer);
  if ( (unsigned int)authenticate(Buffer, v9[0]) )
  {
    printf("The watermarked message is:\n");
    printf("%s\n", Buffer);
    decrypt_message(Buffer);
    printf("The original message is:\n");
    printf("%s\n", Buffer);
  }
  else
  {
    printf("Authentication failed!\n");
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt_message(_QWORD);
// 14000167D: using guessed type __int64 __fastcall decrypt_message(_QWORD);
// 14000171C: using guessed type __int64 __fastcall insert_watermark(_QWORD);
// 1400017E0: using guessed type __int64 __fastcall authenticate(_QWORD, _QWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001808: using guessed type unsigned int var_10[4];
// 140001808: using guessed type char anonymous_0[100];

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Intrusion detection system ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 100
#define MAX_ATTEMPTS 3

int main() {
    char password[MAX_SIZE];
    int attempts = 0;

    printf("Welcome to the Intrusion Detection System\n");

    while (attempts < MAX_ATTEMPTS) {
        printf("Enter the password: ");
        fgets(password, MAX_SIZE, stdin);
        password[strlen(password) - 1] = '\0'; // Remove newline character

        if (strcmp(password, "admin") == 0) {
            printf("Access granted.\n");
            break;
        } else {
            printf("Access denied. Try again.\n");
            attempts++;
        }
    }

    if (attempts == MAX_ATTEMPTS) {
        printf("Intrusion detected!\n");
        // Place code here to alert system administrators or security personnel
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[108]; // [rsp+20h] [rbp-70h] BYREF
  int v6; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  printf("Welcome to the Intrusion Detection System\n");
  while ( v6 <= 2 )
  {
    printf("Enter the password: ");
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 100, v3);
    Buffer[strlen(Buffer) - 1] = 0;
    if ( !strcmp(Buffer, "admin") )
    {
      printf("Access granted.\n");
      break;
    }
    printf("Access denied. Try again.\n");
    ++v6;
  }
  if ( v6 == 3 )
    printf("Intrusion detected!\n");
  return 0;
}
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[108];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game of Life ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define WIDTH 50 // Width of the grid
#define HEIGHT 20 // Height of the grid
#define GENERATIONS 1000 // Number of generations to simulate

// Function to update the grid based on the rules of Game of Life
void updateGrid(int grid[][WIDTH]) {
    int nextGrid[HEIGHT][WIDTH]; // Array to hold the updated grid

    // Loop through every cell in the grid
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            
            // Count the number of live neighbors for this cell
            int liveNeighbors = 0;
            for (int j = -1; j <= 1; j++) {
                for (int i = -1; i <= 1; i++) {
                    if (!(i == 0 && j == 0)) { // Ignore the current cell
                        int dx = x + i;
                        int dy = y + j;
                        if (dx >= 0 && dx < WIDTH && dy >= 0 && dy < HEIGHT && grid[dy][dx] == 1) {
                            liveNeighbors++;
                        }
                    }
                }
            }
            
            // Update the cell based on the rules of Game of Life
            if (grid[y][x] == 1) {
                if (liveNeighbors < 2 || liveNeighbors > 3) {
                    nextGrid[y][x] = 0; // Cell dies
                } else {
                    nextGrid[y][x] = 1; // Cell lives
                }
            } else {
                if (liveNeighbors == 3) {
                    nextGrid[y][x] = 1; // New cell is born
                } else {
                    nextGrid[y][x] = 0; // Cell stays dead
                }
            }
        }
    }
    
    // Copy the updated grid back to the original grid
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            grid[y][x] = nextGrid[y][x];
        }
    }
}

// Function to randomly initialize the grid
void initGrid(int grid[][WIDTH]) {
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            if (rand() % 2 == 0) {
                grid[y][x] = 1; // Cell is alive
            } else {
                grid[y][x] = 0; // Cell is dead
            }
        }
    }
}

// Function to print the grid
void printGrid(int grid[][WIDTH], int generation) {
    printf("Generation %d:\n", generation);
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            if (grid[y][x] == 1) {
                printf("*"); // Cell is alive
            } else {
                printf("."); // Cell is dead
            }
        }
        printf("\n");
    }
}

int main() {
    srand(time(NULL)); // Seed the random number generator
    
    int grid[HEIGHT][WIDTH]; // 2D array to hold the grid
    
    initGrid(grid); // Initialize the grid
    
    printGrid(grid, 0); // Print the initial grid
    
    for (int i = 1; i <= GENERATIONS; i++) {
        updateGrid(grid); // Update the grid
        printGrid(grid, i); // Print the updated grid
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 __fastcall updateGrid(_QWORD); // weak
__int64 __fastcall initGrid(_QWORD); // weak
__int64 __fastcall printGrid(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001A73) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[4012]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int i; // [rsp+FCCh] [rbp+F4Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  initGrid(v5);
  printGrid(v5, 0i64);
  for ( i = 1; (int)i <= 1000; ++i )
  {
    updateGrid(v5);
    printGrid(v5, i);
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall updateGrid(_QWORD);
// 1400018FC: using guessed type __int64 __fastcall initGrid(_QWORD);
// 1400019B9: using guessed type __int64 __fastcall printGrid(_QWORD, _QWORD);
// 140001BC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game of Life ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 30
#define COLS 70
#define GENS 1000

void seed_board(int board[ROWS][COLS], float threshold);
void print_board(int board[ROWS][COLS]);
int count_neighbors(int row, int col, int board[ROWS][COLS]);
void update_board(int board[ROWS][COLS]);

int main() {
    int board[ROWS][COLS] = {0};
    float threshold = 0.3;

    srand(time(NULL));
    seed_board(board, threshold);
    print_board(board);

    for (int i = 0; i < GENS; i++) {
        update_board(board);
        print_board(board);
    }

    printf("\nSimulation finished!");
    return 0;
}

void seed_board(int board[ROWS][COLS], float threshold) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if ((float)rand()/(float)RAND_MAX < threshold) {
                board[i][j] = 1;
            }
        }
    }
}

void print_board(int board[ROWS][COLS]) {
    system("clear");
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (board[i][j] == 1) {
                printf("O");
            } else {
                printf(" ");
            }
        }
        printf("\n");
    }
    printf("Press enter to continue...\n");
    getchar();
}

int count_neighbors(int row, int col, int board[ROWS][COLS]) {
    int count = 0;
    int r, c;

    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            r = (row + i + ROWS) % ROWS;
            c = (col + j + COLS) % COLS;
            count += board[r][c];
        }
    }

    count -= board[row][col];
    return count;
}

void update_board(int board[ROWS][COLS]) {
    int temp_board[ROWS][COLS] = {0};

    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            int count = count_neighbors(i, j, board);

            if (board[i][j] == 1 && (count == 2 || count == 3)) {
                temp_board[i][j] = 1;
            } else if (board[i][j] == 0 && count == 3) {
                temp_board[i][j] = 1;
            } else {
                temp_board[i][j] = 0;
            }
        }
    }

    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            board[i][j] = temp_board[i][j];
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall seed_board(_QWORD); // weak
__int64 __fastcall print_board(_QWORD); // weak
__int64 __fastcall update_board(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// void *__cdecl memset(void *, int Val, size_t Size);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[8408]; // [rsp+20h] [rbp-60h] BYREF
  int v6; // [rsp+20F8h] [rbp+2078h]
  int i; // [rsp+20FCh] [rbp+207Ch]

  _main(argc, argv, envp);
  memset(v5, 0, 0x20D0ui64);
  v6 = 1050253722;
  v3 = time(0i64);
  srand(v3);
  seed_board(v5);
  print_board(v5);
  for ( i = 0; i <= 999; ++i )
  {
    update_board(v5);
    print_board(v5);
  }
  printf("\nSimulation finished!");
  return 0;
}
// 14000167C: using guessed type __int64 __fastcall seed_board(_QWORD);
// 140001700: using guessed type __int64 __fastcall print_board(_QWORD);
// 1400018A3: using guessed type __int64 __fastcall update_board(_QWORD);
// 140001B50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: A* Pathfinding Algorithm ; Style: high level of detail
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Define the map size, start location, and end location
#define ROW 10
#define COL 10
#define START_ROW 1
#define START_COL 1
#define END_ROW 8
#define END_COL 8

// Define a structure to hold the cell information
struct Cell {
    int row, col, f, g, h;
    bool is_obstacle;
    struct Cell* parent;
};

// Define a function to calculate the Manhattan distance between two cells
int calc_h(struct Cell current, struct Cell end) {
    return abs(current.row - end.row) + abs(current.col - end.col);
}

// Define a function to check if a cell is a valid location on the map
bool is_valid_location(int row, int col) {
    return (row >= 0 && col >= 0 && row < ROW && col < COL);
}

// Define a function to check if a cell is an obstacle
bool is_obstacle(int map[ROW][COL], int row, int col) {
    return map[row][col];
}

// Define the A* pathfinding function
void a_star(int map[ROW][COL]) {
    // Initialize the starting and ending cells
    struct Cell start = {START_ROW, START_COL, 0, 0, 0, false, NULL};
    struct Cell end = {END_ROW, END_COL, 0, 0, 0, false, NULL};
    
    // Create the open and closed lists
    int open_list_count = 0;
    struct Cell* open_list[ROW*COL];
    bool closed_list[ROW][COL];
    
    // Add the starting cell to the open list
    open_list[open_list_count++] = &start;
    
    // Loop until the end cell is found or there are no more cells in the open list
    while (open_list_count > 0) {
        // Find the cell with the lowest f value in the open list
        int min_f = open_list[0]->f;
        int min_index = 0;
        for (int i = 1; i < open_list_count; i++) {
            if (open_list[i]->f < min_f) {
                min_f = open_list[i]->f;
                min_index = i;
            }
        }
        
        // Remove the cell with the lowest f value from the open list
        struct Cell* current = open_list[min_index];
        open_list[min_index] = open_list[--open_list_count];
        
        // Check if the current cell is the end cell
        if (current->row == end.row && current->col == end.col) {
            // Path found, trace it back to the start cell
            while (current) {
                map[current->row][current->col] = '*';
                current = current->parent;
            }
            return;
        }
        
        // Add the current cell to the closed list
        closed_list[current->row][current->col] = true;
        
        // Check the neighbors of the current cell
        for(int i = -1; i <= 1; i++) {
            for(int j = -1; j <= 1; j++) {
                // Skip the current cell and diagonal neighbors
                if (i == 0 && j == 0) {
                    continue;
                }
                if (abs(i) + abs(j) == 2) {
                    continue;
                }
                
                // Calculate the neighbor's location
                int neighbor_row = current->row + i;
                int neighbor_col = current->col + j;
                
                // Check if the neighbor is a valid location and not an obstacle
                if (is_valid_location(neighbor_row, neighbor_col) && !is_obstacle(map, neighbor_row, neighbor_col)) {
                    // Check if the neighbor is already in the closed list
                    if (closed_list[neighbor_row][neighbor_col]) {
                        continue;
                    }
                    
                    // Calculate the g, h, and f values for the neighbor
                    int neighbor_g = current->g + 1;
                    int neighbor_h = calc_h((struct Cell){neighbor_row, neighbor_col}, end);
                    int neighbor_f = neighbor_g + neighbor_h;
                    
                    // Check if the neighbor is already in the open list
                    bool is_in_open_list = false;
                    for (int k = 0; k < open_list_count; k++) {
                        if (open_list[k]->row == neighbor_row && open_list[k]->col == neighbor_col) {
                            is_in_open_list = true;
                            break;
                        }
                    }
                    
                    // If the neighbor is not in the open list, add it and set the parent and f values
                    if (!is_in_open_list) {
                        struct Cell* neighbor_cell = (struct Cell*) malloc(sizeof(struct Cell));
                        neighbor_cell->row = neighbor_row;
                        neighbor_cell->col = neighbor_col;
                        neighbor_cell->f = neighbor_f;
                        neighbor_cell->g = neighbor_g;
                        neighbor_cell->h = neighbor_h;
                        neighbor_cell->is_obstacle = false;
                        neighbor_cell->parent = current;
                        open_list[open_list_count++] = neighbor_cell;
                    }
                    // If the neighbor is already in the open list, check if this path to it is better
                    else {
                        for (int k = 0; k < open_list_count; k++) {
                            if (open_list[k]->row == neighbor_row && open_list[k]->col == neighbor_col) {
                                if (neighbor_g < open_list[k]->g) {
                                    open_list[k]->g = neighbor_g;
                                    open_list[k]->f = neighbor_f;
                                    open_list[k]->parent = current;
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
}

int main() {
    // Define the map with obstacles
    int map[ROW][COL] = {
        {0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
        {0, 1, 0, 1, 0, 1, 1, 1, 1, 0},
        {0, 1, 0, 1, 0, 0, 0, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 1, 0, 1, 0},
        {0, 1, 0, 0, 0, 0, 1, 0, 1, 0},
        {0, 1, 1, 1, 1, 0, 1, 0, 1, 0},
        {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},
        {0, 1, 1, 1, 1, 1, 1, 0, 1, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    };
    
    // Run the A* pathfinding algorithm
    a_star(map);
    
    // Print the final map
    printf("MAP:\n");
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < COL; j++) {
            if (map[i][j] == 0) {
                printf(".");
            }
            else {
                printf("%c", map[i][j]);
            }
        }
        printf("\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall a_star(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (0000000140001C38) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[102]; // [rsp+20h] [rbp-60h] BYREF
  int j; // [rsp+1B8h] [rbp+138h]
  int i; // [rsp+1BCh] [rbp+13Ch]

  _main(argc, argv, envp);
  qmemcpy(v4, &unk_14000A020, 0x190ui64);
  a_star(v4, &unk_14000A020);
  printf("MAP:\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
    {
      if ( v4[10 * i + j] )
        printf("%c", (unsigned int)v4[10 * i + j]);
      else
        printf(".");
    }
    printf("\n");
  }
  return 0;
}
// 140001631: using guessed type __int64 __fastcall a_star(_QWORD, _QWORD);
// 140001E10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001C38: using guessed type int var_1B0[102];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Unit converter ; Style: excited
#include <stdio.h>

int main()
{
    int choice;
    float temp, result;

    printf("Welcome to the unit converter!\n\n");

    printf("Which conversion would you like to perform?\n");
    printf("1. Celsius to Fahrenheit\n");
    printf("2. Fahrenheit to Celsius\n");
    scanf("%d", &choice);

    if (choice == 1)
    {
        // Celsius to Fahrenheit conversion
        printf("Enter the temperature in Celsius: ");
        scanf("%f", &temp);
        result = (temp * 9 / 5) + 32;
        printf("%f degrees Celsius is equal to %f degrees Fahrenheit.\n", temp, result);
    }
    else if (choice == 2)
    {
        // Fahrenheit to Celsius conversion
        printf("Enter the temperature in Fahrenheit: ");
        scanf("%f", &temp);
        result = (temp - 32) * 5 / 9;
        printf("%f degrees Fahrenheit is equal to %f degrees Celsius.\n", temp, result);
    }
    else
    {
        printf("Invalid choice. Please select 1 or 2.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+24h] [rbp-Ch] BYREF
  int v5; // [rsp+28h] [rbp-8h] BYREF
  float v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the unit converter!\n\n");
  printf("Which conversion would you like to perform?\n");
  printf("1. Celsius to Fahrenheit\n");
  printf("2. Fahrenheit to Celsius\n");
  scanf("%d", &v5);
  if ( v5 == 1 )
  {
    printf("Enter the temperature in Celsius: ");
    scanf("%f", &v4);
    v6 = (float)((float)(9.0 * v4) / 5.0) + 32.0;
    printf("%f degrees Celsius is equal to %f degrees Fahrenheit.\n", v4, v6);
  }
  else if ( v5 == 2 )
  {
    printf("Enter the temperature in Fahrenheit: ");
    scanf("%f", &v4);
    v6 = (float)(5.0 * (float)(v4 - 32.0)) / 9.0;
    printf("%f degrees Fahrenheit is equal to %f degrees Celsius.\n", v4, v6);
  }
  else
  {
    printf("Invalid choice. Please select 1 or 2.\n");
  }
  return 0;
}
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text processing ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char sentence[1000];
    char word[100];
    int length, i, j, k, count = 0, flag = 0;

    printf("Enter the sentence:\n");
    fgets(sentence, sizeof(sentence), stdin);

    length = strlen(sentence);

    // Removing newline character from the end of sentence
    if (sentence[length - 1] == '\n')
    {
        sentence[length - 1] = '\0';
        length--;
    }

    printf("Enter the word whose frequency is to be found:\n");
    scanf("%s", &word);

    for (i = 0; i < length;)
    {
        if (sentence[i] != ' ' && sentence[i] != '\t')
        {
            k = 0;
            for (j = i; sentence[j] != ' ' && sentence[j] != '\t' && j < length; j++)
            {
                word[k++] = sentence[j];
            }
            word[k] = '\0';

            if (strcmp(word, "") != 0 && strcmp(word, word) == 0)
            {
                count++;
            }

            i = j;
        }
        else
        {
            i++;
        }
    }

    printf("The frequency of the word %s in the sentence is %d\n", word, count);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v4; // eax
  char v6[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[1000]; // [rsp+90h] [rbp+10h] BYREF
  int v8; // [rsp+478h] [rbp+3F8h]
  unsigned int v9; // [rsp+47Ch] [rbp+3FCh]
  int v10; // [rsp+480h] [rbp+400h]
  int i; // [rsp+484h] [rbp+404h]
  int v12; // [rsp+488h] [rbp+408h]
  int v13; // [rsp+48Ch] [rbp+40Ch]

  _main(argc, argv, envp);
  v9 = 0;
  v8 = 0;
  printf("Enter the sentence:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v13 = strlen(Buffer);
  if ( Buffer[v13 - 1] == 10 )
    Buffer[--v13] = 0;
  printf("Enter the word whose frequency is to be found:\n");
  scanf("%s", v6);
  v12 = 0;
  while ( v12 < v13 )
  {
    if ( Buffer[v12] == 32 || Buffer[v12] == 9 )
    {
      ++v12;
    }
    else
    {
      v10 = 0;
      for ( i = v12; Buffer[i] != 32 && Buffer[i] != 9 && i < v13; ++i )
      {
        v4 = v10++;
        v6[v4] = Buffer[i];
      }
      v6[v10] = 0;
      if ( v6[0] )
        ++v9;
      v12 = i;
    }
  }
  printf("The frequency of the word %s in the sentence is %d\n", v6, v9);
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Buffer[1000];
// 1400015E2: using guessed type char var_470[112];

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Drone Remote Control ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>

#define MAX_DRONES 10
#define MAX_COMMAND_LENGTH 100

typedef struct {
    char type[20];
    int range;
    int price;
} Drone;

Drone drones[MAX_DRONES];

void initializeDrones() {
    strcpy(drones[0].type, "Quadcopter");
    drones[0].range = 1000;
    drones[0].price = 500;

    strcpy(drones[1].type, "Hexacopter");
    drones[1].range = 1200;
    drones[1].price = 800;

    // add more drones here
}

int main() {
    initializeDrones();

    char command[MAX_COMMAND_LENGTH];
    char* token;
    int selectedDroneIndex = 0;

    while (1) {
        printf("Enter a command:\n");
        fgets(command, MAX_COMMAND_LENGTH, stdin);

        token = strtok(command, " ");
        if (strcmp(token, "list") == 0) {
            printf("Available drones:\n");
            for (int i = 0; i < MAX_DRONES; i++) {
                if (strlen(drones[i].type) > 0) {
                    printf("%d: %s (%d meters, $%d)\n", i+1, drones[i].type, drones[i].range, drones[i].price);
                }
            }
        } else if (strcmp(token, "select") == 0) {
            token = strtok(NULL, " ");
            int index = atoi(token) - 1;
            if (index >= 0 && index < MAX_DRONES && strlen(drones[index].type) > 0) {
                selectedDroneIndex = index;
                printf("Selected drone: %s\n", drones[selectedDroneIndex].type);
            } else {
                printf("Invalid drone index\n");
            }
        } else if (strcmp(token, "fly") == 0) {
            token = strtok(NULL, " ");
            int distance = atoi(token);
            if (distance <= drones[selectedDroneIndex].range) {
                printf("%s is flying %d meters\n", drones[selectedDroneIndex].type, distance);
            } else {
                printf("%s cannot fly that far\n", drones[selectedDroneIndex].type);
            }
        } else if (strcmp(token, "buy") == 0) {
            token = strtok(NULL, " ");
            int price = atoi(token);
            if (price >= drones[selectedDroneIndex].price) {
                printf("%s purchased for $%d\n", drones[selectedDroneIndex].type, drones[selectedDroneIndex].price);
            } else {
                printf("Not enough money to buy %s\n", drones[selectedDroneIndex].type);
            }
        } else if (strcmp(token, "exit") == 0) {
            printf("Exiting program...\n");
            exit(0);
        } else {
            printf("Invalid command\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 initializeDrones(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
// int __cdecl atoi(const char *String);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

__int64 drones; // weak
int dword_14000F054[]; // weak
int dword_14000F058[]; // weak


//----- (0000000140001602) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  __int64 v4; // [rsp+20h] [rbp-90h]
  char Buffer[100]; // [rsp+30h] [rbp-80h] BYREF
  unsigned int v6; // [rsp+94h] [rbp-1Ch]
  int v7; // [rsp+98h] [rbp-18h]
  int v8; // [rsp+9Ch] [rbp-14h]
  char *Str1; // [rsp+A0h] [rbp-10h]
  int i; // [rsp+A8h] [rbp-8h]
  unsigned int v11; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  initializeDrones();
  v11 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      printf("Enter a command:\n");
      v3 = __acrt_iob_func(0);
      fgets(Buffer, 100, v3);
      Str1 = (char *)(int)strtok(Buffer, " ");
      if ( strcmp(Str1, "list") )
        break;
      printf("Available drones:\n");
      for ( i = 0; i <= 9; ++i )
      {
        if ( *((_BYTE *)&drones + 28 * i) )
        {
          LODWORD(v4) = dword_14000F058[7 * i];
          printf(
            "%d: %s (%d meters, $%d)\n",
            (unsigned int)(i + 1),
            (const char *)&drones + 28 * i,
            (unsigned int)dword_14000F054[7 * i],
            v4);
        }
      }
    }
    if ( !strcmp(Str1, "select") )
    {
      Str1 = (char *)(int)strtok(0i64, " ");
      v6 = atoi(Str1) - 1;
      if ( v6 <= 9 && *((_BYTE *)&drones + 28 * (int)v6) )
      {
        v11 = v6;
        printf("Selected drone: %s\n", (const char *)&drones + 28 * (int)v6);
      }
      else
      {
        printf("Invalid drone index\n");
      }
    }
    else if ( !strcmp(Str1, "fly") )
    {
      Str1 = (char *)(int)strtok(0i64, " ");
      v7 = atoi(Str1);
      if ( v7 > dword_14000F054[7 * v11] )
        printf("%s cannot fly that far\n", (const char *)&drones + 28 * (int)v11);
      else
        printf("%s is flying %d meters\n", (const char *)&drones + 28 * (int)v11, (unsigned int)v7);
    }
    else if ( !strcmp(Str1, "buy") )
    {
      Str1 = (char *)(int)strtok(0i64, " ");
      v8 = atoi(Str1);
      if ( v8 < dword_14000F058[7 * v11] )
        printf("Not enough money to buy %s\n", (const char *)&drones + 28 * (int)v11);
      else
        printf("%s purchased for $%d\n", (const char *)&drones + 28 * (int)v11, (unsigned int)dword_14000F058[7 * v11]);
    }
    else
    {
      if ( !strcmp(Str1, "exit") )
      {
        printf("Exiting program...\n");
        exit(0);
      }
      printf("Invalid command\n");
    }
  }
}
// 140001747: variable 'v4' is possibly undefined
// 140001591: using guessed type __int64 initializeDrones(void);
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type __int64 drones;
// 14000F054: using guessed type int dword_14000F054[];
// 14000F058: using guessed type int dword_14000F058[];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Ebook reader ; Style: Claude Shannon
#include <stdio.h>
#include <stdlib.h>

struct book {
    char title[50];
    char author[50];
    int pages;
    float price;
};

int main() {
    struct book my_book;
    
    printf("Enter book details:\n");
    printf("Title: ");
    fgets(my_book.title, 50, stdin);
    printf("Author: ");
    fgets(my_book.author, 50, stdin);
    printf("Number of pages: ");
    scanf("%d", &my_book.pages);
    printf("Price: ");
    scanf("%f", &my_book.price);

    printf("\nBook Details:\n");
    printf("Title: %s", my_book.title);
    printf("Author: %s", my_book.author);
    printf("Number of pages: %d\n", my_book.pages);
    printf("Price: $%.2f\n", my_book.price);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Buffer[50]; // [rsp+20h] [rbp-70h] BYREF
  char v7[50]; // [rsp+52h] [rbp-3Eh] BYREF
  unsigned int v8; // [rsp+84h] [rbp-Ch] BYREF
  float v9; // [rsp+88h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  printf("Enter book details:\n");
  printf("Title: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 50, v3);
  printf("Author: ");
  v4 = __acrt_iob_func(0);
  fgets(v7, 50, v4);
  printf("Number of pages: ");
  scanf("%d", &v8);
  printf("Price: ");
  scanf("%f", &v9);
  printf("\nBook Details:\n");
  printf("Title: %s", Buffer);
  printf("Author: %s", v7);
  printf("Number of pages: %d\n", v8);
  printf("Price: $%.2f\n", v9);
  return 0;
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Random ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL)); // Setting seed for random number generation based on time
    int array[10]; // Initializing an array of size 10
    int i;

    printf("Generating 10 random numbers:\n");

    for(i = 0; i < 10; i++) {
        array[i] = rand(); // Generating a random integer and adding it to the array
        printf("%d\n", array[i]); // Printing the generated number
    }

    printf("\nSorting the array in ascending order:\n");
    int j;
    int temp;
    for(i = 0; i < 10; i++) {
        for(j = i + 1; j < 10; j++) {
            if(array[i] > array[j]) { // Check if the current element is greater than the next element
                temp = array[i]; // Swap the elements if the condition is true
                array[i] = array[j];
                array[j] = temp;
            }
        }
    }

    for(i = 0; i < 10; i++) {
        printf("%d\n", array[i]); // Printing the sorted array
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[13]; // [rsp+20h] [rbp-40h]
  int v6; // [rsp+54h] [rbp-Ch]
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Generating 10 random numbers:\n");
  for ( i = 0; i <= 9; ++i )
  {
    v5[i] = rand();
    printf("%d\n", (unsigned int)v5[i]);
  }
  printf("\nSorting the array in ascending order:\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = i + 1; j <= 9; ++j )
    {
      if ( v5[i] > v5[j] )
      {
        v6 = v5[i];
        v5[i] = v5[j];
        v5[j] = v6;
      }
    }
  }
  for ( i = 0; i <= 9; ++i )
    printf("%d\n", (unsigned int)v5[i]);
  return 0;
}
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type int var_40[13];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Weather simulation ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int temperature, humidity, wind_speed, rainfall;
    srand(time(0)); // to generate random values

    temperature = rand() % 50; // temperature range from 0 to 50 degree Celsius
    humidity = rand() % 100; // humidity range from 0 to 100 percent
    wind_speed = rand() % 50; // wind speed range from 0 to 50 kmph
    rainfall = rand() % 100; // rainfall range from 0 to 100 mm/month

    printf("Today's weather simulation:\n");
    printf("Temperature: %d degree Celsius\n", temperature);
    printf("Humidity: %d%%\n", humidity);
    printf("Wind Speed: %d kmph\n", wind_speed);
    printf("Rainfall: %d mm/month\n", rainfall);

    // weather conditions based on temperature, humidity, wind speed and rainfall
    if (temperature >= 30 && humidity >= 60 && rainfall < 50) {
        printf("It's a hot and humid day. Drink plenty of water and stay indoors.\n");
    }
    else if (temperature <= 10 && wind_speed >= 25 && rainfall >= 50) {
        printf("It's a cold and windy day with heavy rainfall. Stay warm and dry.\n");
    }
    else if (wind_speed >= 50) {
        printf("It's a stormy day. Stay indoors and be cautious.\n");
    }
    else {
        printf("Weather conditions are normal today. Enjoy your day!\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+20h] [rbp-10h]
  int v6; // [rsp+24h] [rbp-Ch]
  int v7; // [rsp+28h] [rbp-8h]
  int v8; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v8 = rand() % 50;
  v7 = rand() % 100;
  v6 = rand() % 50;
  v5 = rand() % 100;
  printf("Today's weather simulation:\n");
  printf("Temperature: %d degree Celsius\n", (unsigned int)v8);
  printf("Humidity: %d%%\n", (unsigned int)v7);
  printf("Wind Speed: %d kmph\n", (unsigned int)v6);
  printf("Rainfall: %d mm/month\n", (unsigned int)v5);
  if ( v8 <= 29 || v7 <= 59 || v5 > 49 )
  {
    if ( v8 > 10 || v6 <= 24 || v5 <= 49 )
    {
      if ( v6 <= 49 )
        printf("Weather conditions are normal today. Enjoy your day!\n");
      else
        printf("It's a stormy day. Stay indoors and be cautious.\n");
    }
    else
    {
      printf("It's a cold and windy day with heavy rainfall. Stay warm and dry.\n");
    }
  }
  else
  {
    printf("It's a hot and humid day. Drink plenty of water and stay indoors.\n");
  }
  return 0;
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data structures visualization ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>

// defining a struct for a student record
struct student {
    char name[30];
    int roll_no;
    float average_marks;
};

// a function to display all details of a student
void display_student(struct student);

int main() {
    // initializing an array of struct students
    struct student students[5] = {
        {"John", 1, 75.5},
        {"Mary", 2, 89.0},
        {"Tim", 3, 92.3},
        {"Anne", 4, 68.7},
        {"Bob", 5, 80.1}
    };

    // printing the details of all the students in the array
    for(int i = 0; i < 5; i++) {
        printf("Student %d\n", i+1);
        display_student(students[i]);
        printf("\n");
    }

    return 0;
}

void display_student(struct student s) {
    printf("Name: %s\n", s.name);
    printf("Roll No: %d\n", s.roll_no);
    printf("Average Marks: %.2f\n", s.average_marks);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall display_student(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 *v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rbx
  __int64 v7[9]; // [rsp+20h] [rbp-60h] BYREF
  int v8; // [rsp+68h] [rbp-18h]
  __int16 v9; // [rsp+6Ch] [rbp-14h]
  int v10; // [rsp+70h] [rbp-10h]
  int v11; // [rsp+74h] [rbp-Ch]
  __int64 v12; // [rsp+78h] [rbp-8h]
  __int64 v13[2]; // [rsp+80h] [rbp+0h] BYREF
  int v14; // [rsp+90h] [rbp+10h]
  __int16 v15; // [rsp+94h] [rbp+14h]
  int v16; // [rsp+98h] [rbp+18h]
  int v17; // [rsp+9Ch] [rbp+1Ch]
  __int64 v18; // [rsp+A0h] [rbp+20h]
  __int64 v19; // [rsp+A8h] [rbp+28h]
  __int64 v20; // [rsp+B0h] [rbp+30h]
  int v21; // [rsp+B8h] [rbp+38h]
  __int16 v22; // [rsp+BCh] [rbp+3Ch]
  int v23; // [rsp+C0h] [rbp+40h]
  int v24; // [rsp+C4h] [rbp+44h]
  __int64 v25; // [rsp+C8h] [rbp+48h]
  __int64 v26; // [rsp+D0h] [rbp+50h]
  __int64 v27; // [rsp+D8h] [rbp+58h]
  int v28; // [rsp+E0h] [rbp+60h]
  __int16 v29; // [rsp+E4h] [rbp+64h]
  int v30; // [rsp+E8h] [rbp+68h]
  int v31; // [rsp+ECh] [rbp+6Ch]
  __int64 v32; // [rsp+F0h] [rbp+70h]
  __int64 v33; // [rsp+F8h] [rbp+78h]
  __int64 v34; // [rsp+100h] [rbp+80h]
  int v35; // [rsp+108h] [rbp+88h]
  __int16 v36; // [rsp+10Ch] [rbp+8Ch]
  int v37; // [rsp+110h] [rbp+90h]
  int v38; // [rsp+114h] [rbp+94h]
  int i; // [rsp+11Ch] [rbp+9Ch]

  _main(argc, argv, envp);
  v7[6] = 1852337994i64;
  v7[7] = 0i64;
  v7[8] = 0i64;
  v8 = 0;
  v9 = 0;
  v10 = 1;
  v11 = 1117192192;
  v12 = 2037539149i64;
  v13[0] = 0i64;
  v13[1] = 0i64;
  v14 = 0;
  v15 = 0;
  v16 = 2;
  v17 = 1118961664;
  v18 = 7170388i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v23 = 3;
  v24 = 1119394202;
  v25 = 1701736001i64;
  v26 = 0i64;
  v27 = 0i64;
  v28 = 0;
  v29 = 0;
  v30 = 4;
  v31 = 1116300902;
  v32 = 6451010i64;
  v33 = 0i64;
  v34 = 0i64;
  v35 = 0;
  v36 = 0;
  v37 = 5;
  v38 = 1117795123;
  for ( i = 0; i <= 4; ++i )
  {
    printf("Student %d\n", (unsigned int)(i + 1));
    v3 = &v13[5 * i - 6];
    v4 = v3[1];
    v7[0] = *v3;
    v7[1] = v4;
    v5 = v3[3];
    v7[2] = v3[2];
    v7[3] = v5;
    v7[4] = v3[4];
    display_student(v7);
    printf("\n");
  }
  return 0;
}
// 140001788: using guessed type __int64 __fastcall display_student(_QWORD);
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: CPU usage monitor ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main() {
  int cpu_prev_total = 0;
  int cpu_prev_idle = 0;

  while (1) {
    // Open the proc/stat file
    FILE* stat_file = fopen("/proc/stat", "r");

    // Read the first line of the file, which contains CPU usage stats
    char cpu_line[256];
    fgets(cpu_line, 256, stat_file);

    // Close the file
    fclose(stat_file);

    // Split the first line into individual fields
    char* cpu_fields[10];
    int cpu_total = 0;
    int cpu_idle = 0;
    char* tok = strtok(cpu_line, " ");
    int i = 0;
    while (tok != NULL) {
      cpu_fields[i] = tok;
      i++;

      if (i == 1) continue; // skip the first field, which is "cpu"

      // Calculate total CPU time
      cpu_total += atoi(tok);

      if (i == 5) { // idle time is the 5th field
        cpu_idle = atoi(tok);
        break;
      }

      tok = strtok(NULL, " ");
    }

    // Calculate CPU usage percentage since last measurement
    int cpu_diff_total = cpu_total - cpu_prev_total;
    int cpu_diff_idle = cpu_idle - cpu_prev_idle;
    double cpu_usage = ((double) cpu_diff_total - (double) cpu_diff_idle) / (double) cpu_diff_total * 100.0;

    // Print CPU usage to the console
    printf("CPU usage: %.2f%%\n", cpu_usage);

    // Save current CPU stats for the next measurement
    cpu_prev_total = cpu_total;
    cpu_prev_idle = cpu_idle;

    // Wait 1 second before next measurement
    sleep(1);
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// int __cdecl atoi(const char *String);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  __int64 v5[10]; // [rsp+20h] [rbp-60h]
  char Buffer[264]; // [rsp+70h] [rbp-10h] BYREF
  double v7; // [rsp+178h] [rbp+F8h]
  int v8; // [rsp+180h] [rbp+100h]
  int v9; // [rsp+184h] [rbp+104h]
  FILE *Stream; // [rsp+188h] [rbp+108h]
  int v11; // [rsp+194h] [rbp+114h]
  char *String; // [rsp+198h] [rbp+118h]
  __int64 v13; // [rsp+1A0h] [rbp+120h]
  __int64 v14; // [rsp+1A8h] [rbp+128h]

  _main(argc, argv, envp);
  v14 = 0i64;
  while ( 1 )
  {
    Stream = fopen("/proc/stat", "r");
    fgets(Buffer, 256, Stream);
    fclose(Stream);
    v13 = 0i64;
    String = strtok(Buffer, " ");
    v11 = 0;
    while ( 1 )
    {
      do
      {
        if ( !String )
          goto LABEL_8;
        v5[v11++] = (__int64)String;
      }
      while ( v11 == 1 );
      v3 = atoi(String);
      HIDWORD(v13) += v3;
      if ( v11 == 5 )
        break;
      String = strtok(0i64, " ");
    }
    LODWORD(v13) = atoi(String);
LABEL_8:
    v9 = HIDWORD(v13) - HIDWORD(v14);
    v8 = v13 - v14;
    v7 = 100.0
       * (((double)(HIDWORD(v13) - HIDWORD(v14)) - (double)((int)v13 - (int)v14))
        / (double)(HIDWORD(v13) - HIDWORD(v14)));
    printf("CPU usage: %.2f%%\n", v7);
    v14 = v13;
    sleep(1i64);
  }
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002890: using guessed type __int64 __fastcall sleep(_QWORD);
// 140001591: using guessed type __int64 var_190[10];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Metadata Extractor ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char* name;
    char* value;
} Metadata;

int main() {
    char data[] = "name: Alice\nage: 25\naddress: 1234 Main St.";
    char* pairs[3];
    Metadata metadata[3];

    // Split the data into pairs (name: value)
    pairs[0] = strtok(data, "\n");
    for (int i = 1; i < 3; i++) {
        pairs[i] = strtok(NULL, "\n");
    }

    // Split the pairs into name and value and store in Metadata structs
    for (int i = 0; i < 3; i++) {
        char* name = strtok(pairs[i], ":");
        char* value = strtok(NULL, "");
        metadata[i].name = malloc(strlen(name) + 1);
        metadata[i].value = malloc(strlen(value) + 1);
        strcpy(metadata[i].name, name);
        strcpy(metadata[i].value, value);
    }

    // Print out the extracted metadata
    for (int i = 0; i < 3; i++) {
        printf("%s: %s\n", metadata[i].name, metadata[i].value);
    }

    // Free the dynamically allocated memory
    for (int i = 0; i < 3; i++) {
        free(metadata[i].name);
        free(metadata[i].value);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);

//-------------------------------------------------------------------------
// Data declarations

const char byte_14000B004 = '\0'; // idb


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v3; // rax
  size_t v4; // rax
  void *v5; // rax
  size_t v6; // rax
  void *v7; // rax
  _BYTE v9[48]; // [rsp+20h] [rbp-A0h]
  char *v10[4]; // [rsp+50h] [rbp-70h]
  char String[48]; // [rsp+70h] [rbp-50h] BYREF
  char *Source; // [rsp+A0h] [rbp-20h]
  char *Str; // [rsp+A8h] [rbp-18h]
  int m; // [rsp+B0h] [rbp-10h]
  int k; // [rsp+B4h] [rbp-Ch]
  int j; // [rsp+B8h] [rbp-8h]
  int i; // [rsp+BCh] [rbp-4h]

  _main(argc, argv, envp);
  strcpy(String, "name: Alice\nage: 25\naddress: 1234 Main St.");
  v10[0] = strtok(String, "\n");
  for ( i = 1; i <= 2; ++i )
  {
    v3 = strtok(0i64, "\n");
    v10[i] = v3;
  }
  for ( j = 0; j <= 2; ++j )
  {
    Str = strtok(v10[j], ":");
    Source = strtok(0i64, &byte_14000B004);
    v4 = strlen(Str);
    v5 = malloc(v4 + 1);
    *(_QWORD *)&v9[16 * j] = v5;
    v6 = strlen(Source);
    v7 = malloc(v6 + 1);
    *(_QWORD *)&v9[16 * j + 8] = v7;
    strcpy(*(char **)&v9[16 * j], Str);
    strcpy(*(char **)&v9[16 * j + 8], Source);
  }
  for ( k = 0; k <= 2; ++k )
    printf("%s: %s\n", *(const char **)&v9[16 * k], *(const char **)&v9[16 * k + 8]);
  for ( m = 0; m <= 2; ++m )
  {
    free(*(void **)&v9[16 * m]);
    free(*(void **)&v9[16 * m + 8]);
  }
  return 0;
}
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Periodic Table Quiz ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// define constants for the number of elements in the table and the max length of element name
#define NUM_ELEMENTS 118
#define MAX_NAME_LENGTH 50

// define a struct to hold information about each element
typedef struct{
    int atomic_number;
    char symbol[3];
    char name[MAX_NAME_LENGTH];
    float atomic_mass;
} Element;

// create an array of element structs to hold all the elements of the periodic table
Element periodic_table[NUM_ELEMENTS] = {
    {1, "H", "Hydrogen", 1.008},
    {2, "He", "Helium", 4.003},
    {3, "Li", "Lithium", 6.941},
    {4, "Be", "Beryllium", 9.012},
    {5, "B", "Boron", 10.81},
    // and so on for all the elements in the table
};

// define a function to retrieve a random element from the table
Element get_random_element(){
    int index = rand() % NUM_ELEMENTS;
    return periodic_table[index];
}

// define a struct to hold information about each player
typedef struct {
    char name[MAX_NAME_LENGTH];
    int score;
} Player;

// define a function to prompt the user to enter the name of a player
void get_player_name(Player *player){
    printf("Enter your name: ");
    fgets(player->name, MAX_NAME_LENGTH, stdin);
    // remove newline character from input
    player->name[strcspn(player->name, "\n")] = 0;
}

// define a function to display the current leaderboard
void display_leaderboard(Player *players, int num_players){
    printf("\n-----LEADERBOARD-----\n");
    for(int i=0; i<num_players; i++){
        printf("%s: %d\n", players[i].name, players[i].score);
    }
    printf("---------------------\n\n");
}

int main(){
    // seed the random number generator
    srand(time(NULL));

    // prompt the user to enter the number of players
    int num_players;
    printf("Enter the number of players: ");
    scanf("%d", &num_players);
    getchar(); // consume extra newline character

    // initialize an array of player structs
    Player players[num_players];

    // prompt each player to enter their name
    for(int i=0; i<num_players; i++){
        printf("Player %d:\n", i+1);
        get_player_name(&players[i]);
    }

    // display the leaderboard before the quiz starts
    display_leaderboard(players, num_players);

    // play the quiz
    int num_questions = 5; // play 5 questions for each player
    for(int i=0; i<num_players; i++){
        // initialize the player's score to zero
        players[i].score = 0;

        // play the quiz for this player
        printf("%s, it's your turn to play.\n", players[i].name);
        for(int q=0; q<num_questions; q++){
            // get a random element from the periodic table
            Element element = get_random_element();

            // prompt the player with the atomic number of the element
            int guess;
            printf("What is the atomic number of %s? ", element.name);
            scanf("%d", &guess);
            getchar(); // consume extra newline character

            // check if the player's guess is correct
            if(guess == element.atomic_number){
                printf("Correct!\n");
                players[i].score++;
            }
            else{
                printf("Incorrect. The atomic number of %s is %d.\n", element.name, element.atomic_number);
            }
        }

        // display the player's score after the quiz
        printf("%s, you scored %d out of %d.\n", players[i].name, players[i].score, num_questions);

        // update the leaderboard
        display_leaderboard(players, num_players);
    }

    printf("Thanks for playing!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall get_random_element(_QWORD); // weak
__int64 __fastcall get_player_name(_QWORD); // weak
__int64 __fastcall display_leaderboard(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl getchar();


//----- (00000001400017A3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  void *v4; // rsp
  unsigned int v6; // [rsp+20h] [rbp-70h] BYREF
  char v7[61]; // [rsp+27h] [rbp-69h] BYREF
  int v8; // [rsp+64h] [rbp-2Ch] BYREF
  unsigned int v9; // [rsp+68h] [rbp-28h] BYREF
  unsigned int v10; // [rsp+6Ch] [rbp-24h]
  unsigned int *v11; // [rsp+70h] [rbp-20h]
  __int64 v12; // [rsp+78h] [rbp-18h]
  int k; // [rsp+84h] [rbp-Ch]
  int j; // [rsp+88h] [rbp-8h]
  int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Enter the number of players: ");
  scanf("%d", &v9);
  getchar();
  v12 = (int)v9 - 1i64;
  v4 = alloca(16 * ((unsigned __int64)(56i64 * (int)v9 + 15) >> 4));
  v11 = &v6;
  for ( i = 0; i < (int)v9; ++i )
  {
    printf("Player %d:\n", (unsigned int)(i + 1));
    get_player_name(&v11[14 * i]);
  }
  display_leaderboard(v11, v9);
  v10 = 5;
  for ( j = 0; j < (int)v9; ++j )
  {
    v11[14 * j + 13] = 0;
    printf("%s, it's your turn to play.\n", (const char *)&v11[14 * j]);
    for ( k = 0; k < (int)v10; ++k )
    {
      get_random_element(&v6);
      printf("What is the atomic number of %s? ", v7);
      scanf("%d", &v8);
      getchar();
      if ( v6 == v8 )
      {
        printf("Correct!\n");
        ++v11[14 * j + 13];
      }
      else
      {
        printf("Incorrect. The atomic number of %s is %d.\n", v7, v6);
      }
    }
    printf("%s, you scored %d out of %d.\n", (const char *)&v11[14 * j], v11[14 * j + 13], v10);
    display_leaderboard(v11, v9);
  }
  printf("Thanks for playing!\n");
  return 0;
}
// 140001601: using guessed type __int64 __fastcall get_random_element(_QWORD);
// 1400016A4: using guessed type __int64 __fastcall get_player_name(_QWORD);
// 140001706: using guessed type __int64 __fastcall display_leaderboard(_QWORD, _QWORD);
// 140001BA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400017A3: using guessed type unsigned int var_A0;

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home automation ; Style: portable
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Constants
#define LIGHT_OFF 0
#define LIGHT_ON 1

// Function prototypes
void turnLightOn(bool *lightStatus);
void turnLightOff(bool *lightStatus);
void printCurrentLightStatus(bool lightStatus);
void displayMainMenu();

int main()
{
    bool lightStatus = LIGHT_OFF;

    printf("\nWelcome to the Smart Home Automation program!\n");

    while (true) {
        displayMainMenu();

        int userInput;
        printf("\nEnter the operation you want to perform: ");
        scanf("%d", &userInput);

        switch (userInput) {
            case 1:
                turnLightOn(&lightStatus);
                break;
            case 2:
                turnLightOff(&lightStatus);
                break;
            case 3:
                printCurrentLightStatus(lightStatus);
                break;
            case 4:
                printf("\nGoodbye!\n");
                exit(0);
            default:
                printf("\nInvalid input. Try again.\n");
                break;
        }

        // Pause the system for 1 second to simulate processing time
        printf("\nProcessing...\n\n");
        sleep(1);
    }

    return 0;
}

void turnLightOn(bool *lightStatus)
{
    if (*lightStatus == LIGHT_ON) {
        printf("\nThe light is already on.\n");
    } else {
        *lightStatus = LIGHT_ON;
        printf("\nThe light is now on.\n");
    }
}

void turnLightOff(bool *lightStatus)
{
    if (*lightStatus == LIGHT_OFF) {
        printf("\nThe light is already off.\n");
    } else {
        *lightStatus = LIGHT_OFF;
        printf("\nThe light is now off.\n");
    }
}

void printCurrentLightStatus(bool lightStatus)
{
    if (lightStatus == LIGHT_ON) {
        printf("\nThe light is currently on.\n");
    } else {
        printf("\nThe light is currently off.\n");
    }
}

void displayMainMenu()
{
    printf("\n*******************\n");
    printf("MAIN MENU\n");
    printf("*******************\n");
    printf("1. Turn the light on\n");
    printf("2. Turn the light off\n");
    printf("3. Check the current status of the light\n");
    printf("4. Exit the program\n");
    printf("\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall turnLightOn(_QWORD); // weak
__int64 __fastcall turnLightOff(_QWORD); // weak
__int64 __fastcall printCurrentLightStatus(_QWORD); // weak
__int64 displayMainMenu(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+28h] [rbp-8h] BYREF
  unsigned __int8 v4; // [rsp+2Fh] [rbp-1h] BYREF

  _main(argc, argv, envp);
  v4 = 0;
  printf("\nWelcome to the Smart Home Automation program!\n");
  while ( 1 )
  {
    displayMainMenu();
    printf("\nEnter the operation you want to perform: ");
    scanf("%d", &v3);
    if ( v3 == 4 )
    {
      printf("\nGoodbye!\n");
      exit(0);
    }
    if ( v3 <= 4 )
    {
      switch ( v3 )
      {
        case 3:
          printCurrentLightStatus(v4);
          goto LABEL_13;
        case 1:
          turnLightOn(&v4);
          goto LABEL_13;
        case 2:
          turnLightOff(&v4);
          goto LABEL_13;
      }
    }
    printf("\nInvalid input. Try again.\n");
LABEL_13:
    printf("\nProcessing...\n\n");
    sleep(1i64);
  }
}
// 140001641: conditional instruction was optimized away because %var_8.4<3
// 1400016C2: using guessed type __int64 __fastcall turnLightOn(_QWORD);
// 140001707: using guessed type __int64 __fastcall turnLightOff(_QWORD);
// 14000174F: using guessed type __int64 __fastcall printCurrentLightStatus(_QWORD);
// 140001789: using guessed type __int64 displayMainMenu(void);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002920: using guessed type __int64 __fastcall sleep(_QWORD);
// 1400015E2: using guessed type int var_8;

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text Summarizer ; Style: Ada Lovelace
// Ada Lovelace Style Unique C Text Summarizer Example Program

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_STRING_LEN 1000
#define MAX_SUMMARY_LEN 100

int main() {
    char input_string[MAX_STRING_LEN];
    char summary[MAX_SUMMARY_LEN];
    int i, j;

    printf("Enter the input string: ");
    fgets(input_string, MAX_STRING_LEN, stdin);

    // Count number of sentences
    int sentence_count = 0;
    for (i = 0; input_string[i] != '\0'; i++) {
        if (input_string[i] == '.') {
            sentence_count++;
        }
    }

    // Allocate memory for the sentences
    char *sentences[sentence_count];
    for (i = 0; i < sentence_count; i++) {
        sentences[i] = (char *)malloc(MAX_STRING_LEN);
        memset(sentences[i], 0, MAX_STRING_LEN);
    }

    // Store the sentences
    int sentence_index = 0;
    int start_index = 0;
    for (i = 0; input_string[i] != '\0'; i++) {
        if (input_string[i] == '.') {
            strncpy(sentences[sentence_index++], input_string + start_index, i - start_index + 1);
            start_index = i + 1;
        }
    }

    // Calculate the score for each sentence
    float sentence_score[sentence_count];
    memset(sentence_score, 0, sentence_count * sizeof(float));
    for (i = 0; i < sentence_count; i++) {
        for (j = 0; j < sentence_count; j++) {
            if (i != j) {
                char *temp_sentence = (char *)malloc(MAX_STRING_LEN);
                strcpy(temp_sentence, sentences[i]);
                char *token = strtok(temp_sentence, " ");
                int common_word_count = 0;
                int total_word_count = 0;
                while (token != NULL) {
                    if (strstr(sentences[j], token) != NULL) {
                        common_word_count++;
                    }
                    total_word_count++;
                    token = strtok(NULL, " ");
                }
                free(temp_sentence);
                sentence_score[i] += (float)common_word_count / (float)total_word_count;
            }
        }
    }

    // Calculate the threshold score
    float threshold_score = 0;
    for (i = 0; i < sentence_count; i++) {
        threshold_score += sentence_score[i];
    }
    threshold_score /= sentence_count;

    // Generate the summary
    int summary_index = 0;
    for (i = 0; i < sentence_count; i++) {
        if (sentence_score[i] >= threshold_score && summary_index + strlen(sentences[i]) <= MAX_SUMMARY_LEN) {
            strncpy(summary + summary_index, sentences[i], strlen(sentences[i]));
            summary_index += strlen(sentences[i]);
        }
    }

    printf("Summary: %s\n", summary);

    // Free the memory
    for (i = 0; i < sentence_count; i++) {
        free(sentences[i]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  void *v4; // rsp
  int v5; // eax
  void *v6; // rsp
  size_t v7; // rax
  __int64 v9[4]; // [rsp+20h] [rbp-60h] BYREF
  char v10[112]; // [rsp+40h] [rbp-40h] BYREF
  char Buffer[1000]; // [rsp+B0h] [rbp+30h] BYREF
  char *Destination; // [rsp+498h] [rbp+418h]
  void *v13; // [rsp+4A0h] [rbp+420h]
  __int64 v14; // [rsp+4A8h] [rbp+428h]
  __int64 *v15; // [rsp+4B0h] [rbp+430h]
  __int64 v16; // [rsp+4B8h] [rbp+438h]
  int v17; // [rsp+4C0h] [rbp+440h]
  float v18; // [rsp+4C4h] [rbp+444h]
  int v19; // [rsp+4C8h] [rbp+448h]
  int v20; // [rsp+4CCh] [rbp+44Ch]
  char *SubStr; // [rsp+4D0h] [rbp+450h]
  int v22; // [rsp+4DCh] [rbp+45Ch]
  int v23; // [rsp+4E0h] [rbp+460h]
  int v24; // [rsp+4E4h] [rbp+464h]
  int j; // [rsp+4E8h] [rbp+468h]
  int i; // [rsp+4ECh] [rbp+46Ch]

  _main(argc, argv, envp);
  printf("Enter the input string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v24 = 0;
  for ( i = 0; Buffer[i]; ++i )
  {
    if ( Buffer[i] == 46 )
      ++v24;
  }
  v16 = v24 - 1i64;
  v9[2] = v24;
  v9[3] = 0i64;
  v9[0] = v24;
  v9[1] = 0i64;
  v4 = alloca(16 * ((unsigned __int64)(8i64 * v24 + 15) >> 4));
  v15 = v9;
  for ( i = 0; i < v24; ++i )
  {
    v15[i] = (__int64)malloc(0x3E8ui64);
    memset((void *)v15[i], 0, 0x3E8ui64);
  }
  v23 = 0;
  v22 = 0;
  for ( i = 0; Buffer[i]; ++i )
  {
    if ( Buffer[i] == 46 )
    {
      v5 = v23++;
      strncpy((char *)v15[v5], &Buffer[v22], i - v22 + 1);
      v22 = i + 1;
    }
  }
  v14 = v24 - 1i64;
  v6 = alloca(16 * ((unsigned __int64)(4i64 * v24 + 15) >> 4));
  v13 = v9;
  memset(v9, 0, 4i64 * v24);
  for ( i = 0; i < v24; ++i )
  {
    for ( j = 0; j < v24; ++j )
    {
      if ( i != j )
      {
        Destination = (char *)malloc(0x3E8ui64);
        strcpy(Destination, (const char *)v15[i]);
        SubStr = strtok(Destination, " ");
        v20 = 0;
        v19 = 0;
        while ( SubStr )
        {
          if ( strstr((const char *)v15[j], SubStr) )
            ++v20;
          ++v19;
          SubStr = strtok(0i64, " ");
        }
        free(Destination);
        *((float *)v13 + i) = (float)((float)v20 / (float)v19) + *((float *)v13 + i);
      }
    }
  }
  v18 = 0.0;
  for ( i = 0; i < v24; ++i )
    v18 = *((float *)v13 + i) + v18;
  v18 = v18 / (float)v24;
  v17 = 0;
  for ( i = 0; i < v24; ++i )
  {
    if ( *((float *)v13 + i) >= v18 && v17 + strlen((const char *)v15[i]) <= 0x64 )
    {
      v7 = strlen((const char *)v15[i]);
      strncpy(&v10[v17], (const char *)v15[i], v7);
      v17 += strlen((const char *)v15[i]);
    }
  }
  printf("Summary: %s\n", v10);
  for ( i = 0; i < v24; ++i )
    free((void *)v15[i]);
  return 0;
}
// 140001C30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[1000];
// 140001591: using guessed type char var_4E0[112];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Disk space analyzer ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>

// function to calculate directory size
long long int calcDirSize(char *dirPath)
{
    DIR *directory = opendir(dirPath);
    struct dirent *entry;
    struct stat statbuf;
    long long int dirSize = 0;

    if (directory == NULL) {
        printf("Error opening directory at path '%s'\n", dirPath);
        return -1;
    }

    // iterate over files and directories in the given directory path
    while ((entry = readdir(directory)) != NULL) {
        char childPath[1000];
        sprintf(childPath, "%s/%s", dirPath, entry->d_name);
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }
        if (stat(childPath, &statbuf) == -1) {
            printf("Error getting file stats for file '%s'\n", childPath);
            continue;
        }
        if (S_ISDIR(statbuf.st_mode)) {
            // if directory, recursively calculate directory size
            dirSize += calcDirSize(childPath);
        } else {
            // if file, add file size to directory size
            dirSize += statbuf.st_size;
        }
    }

    closedir(directory);
    return dirSize;
}

int main(int argc, char* argv[])
{
    if (argc != 2) {
        printf("Usage: %s <directory path>\n", argv[0]);
        return -1;
    }

    char *dirPath = argv[1];
    printf("Calculating size of directory at path '%s'\n", dirPath);

    // calculate directory size
    long long int dirSize = calcDirSize(dirPath);

    if (dirSize == -1) {
        return -1;
    }

    // print results
    printf("Total size of directory at path '%s' is %lld bytes.\n", dirPath, dirSize);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall calcDirSize(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001751) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-10h]
  const char *v5; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc == 2 )
  {
    v5 = argv[1];
    printf("Calculating size of directory at path '%s'\n", v5);
    v4 = calcDirSize(v5);
    if ( v4 == -1 )
    {
      return -1;
    }
    else
    {
      printf("Total size of directory at path '%s' is %lld bytes.\n", v5, v4);
      return 0;
    }
  }
  else
  {
    printf("Usage: %s <directory path>\n", *argv);
    return -1;
  }
}
// 1400015D4: using guessed type __int64 __fastcall calcDirSize(_QWORD);
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=156 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Palindrome Checker ; Style: post-apocalyptic
#include <stdio.h>
#include <string.h>

void reverse(char *str) {
    int i, j;
    char temp;

    for(i=0, j=strlen(str)-1; i<j; i++, j--) {
        temp = str[i];
        str[i] = str[j];
        str[j] = temp;
    }
}

int isPalindrome(char *str) {
    char reverseStr[strlen(str)];
    strcpy(reverseStr, str);
    reverse(reverseStr);

    return strcmp(str, reverseStr) == 0;
}

int main() {
    char str[100];

    printf("Welcome to the Palindrome Checker program!\n");
    printf("Please enter a string to check if it is a palindrome: ");

    fgets(str, 100, stdin); 
    str[strcspn(str, "\n")] = 0; 

    if(isPalindrome(str)) {
        printf("The string '%s' is a palindrome.\n", str);
    } else {
        printf("The string '%s' is NOT a palindrome.\n", str);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall isPalindrome(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016B7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[112]; // [rsp+20h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Palindrome Checker program!\n");
  printf("Please enter a string to check if it is a palindrome: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  if ( (unsigned int)isPalindrome(Buffer) )
    printf("The string '%s' is a palindrome.\n", Buffer);
  else
    printf("The string '%s' is NOT a palindrome.\n", Buffer);
  return 0;
}
// 140001612: using guessed type __int64 __fastcall isPalindrome(_QWORD);
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016B7: using guessed type char Buffer[112];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific Calculator Implementation ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main()
{
    float num1, num2, result;
    int choice;

    printf("Welcome to Scientific Calculator!\n");

    do {
        printf("\n");
        printf("Please select an operation to perform: \n");
        printf("1. Addition\n");
        printf("2. Subtraction\n");
        printf("3. Multiplication\n");
        printf("4. Division\n");
        printf("5. Exponentiation\n");
        printf("6. Square root\n");
        printf("7. Logarithm\n");
        printf("8. Exit\n\n");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the first number: ");
                scanf("%f", &num1);
                printf("Enter the second number: ");
                scanf("%f", &num2);
                result = num1 + num2;
                printf("Result: %f \n", result);
                break;

            case 2:
                printf("Enter the first number: ");
                scanf("%f", &num1);
                printf("Enter the second number: ");
                scanf("%f", &num2);
                result = num1 - num2;
                printf("Result: %f \n", result);
                break;

            case 3:
                printf("Enter the first number: ");
                scanf("%f", &num1);
                printf("Enter the second number: ");
                scanf("%f", &num2);
                result = num1 * num2;
                printf("Result: %f \n", result);
                break;

            case 4:
                printf("Enter the first number: ");
                scanf("%f", &num1);
                printf("Enter the second number: ");
                scanf("%f", &num2);
                result = num1 / num2;
                printf("Result: %f \n", result);
                break;

            case 5:
                printf("Enter the base number: ");
                scanf("%f", &num1);
                printf("Enter the exponent number: ");
                scanf("%f", &num2);
                result = pow(num1, num2);
                printf("Result: %f \n", result);
                break;

            case 6:
                printf("Enter the number: ");
                scanf("%f", &num1);
                result = sqrt(num1);
                printf("Result: %f \n", result);
                break;

            case 7:
                printf("Enter the number: ");
                scanf("%f", &num1);
                result = log10(num1);
                printf("Result: %f \n", result);
                break;

            case 8:
                printf("Thank you for using Scientific Calculator!\n");
                exit(0);
                break;

            default:
                printf("Invalid input! Please select a valid operation.\n");
                break;
        }
    } while (choice != 8);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl pow(double X, double Y);
// double __cdecl log10(double X);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  float v5; // xmm0_4
  int v7; // [rsp+20h] [rbp-10h] BYREF
  float v8; // [rsp+24h] [rbp-Ch] BYREF
  float v9; // [rsp+28h] [rbp-8h] BYREF
  float v10; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to Scientific Calculator!\n");
  do
  {
    printf("\n");
    printf("Please select an operation to perform: \n");
    printf("1. Addition\n");
    printf("2. Subtraction\n");
    printf("3. Multiplication\n");
    printf("4. Division\n");
    printf("5. Exponentiation\n");
    printf("6. Square root\n");
    printf("7. Logarithm\n");
    printf("8. Exit\n\n");
    scanf("%d", &v7);
    switch ( v7 )
    {
      case 1:
        printf("Enter the first number: ");
        scanf("%f", &v9);
        printf("Enter the second number: ");
        scanf("%f", &v8);
        v10 = v8 + v9;
        printf("Result: %f \n", (float)(v8 + v9));
        break;
      case 2:
        printf("Enter the first number: ");
        scanf("%f", &v9);
        printf("Enter the second number: ");
        scanf("%f", &v8);
        v10 = v9 - v8;
        printf("Result: %f \n", (float)(v9 - v8));
        break;
      case 3:
        printf("Enter the first number: ");
        scanf("%f", &v9);
        printf("Enter the second number: ");
        scanf("%f", &v8);
        v10 = v8 * v9;
        printf("Result: %f \n", (float)(v8 * v9));
        break;
      case 4:
        printf("Enter the first number: ");
        scanf("%f", &v9);
        printf("Enter the second number: ");
        scanf("%f", &v8);
        v10 = v9 / v8;
        printf("Result: %f \n", (float)(v9 / v8));
        break;
      case 5:
        printf("Enter the base number: ");
        scanf("%f", &v9);
        printf("Enter the exponent number: ");
        scanf("%f", &v8);
        v3 = pow(v9, v8);
        v10 = v3;
        printf("Result: %f \n", v3);
        break;
      case 6:
        printf("Enter the number: ");
        scanf("%f", &v9);
        v4 = sqrt(v9);
        v10 = v4;
        printf("Result: %f \n", v4);
        break;
      case 7:
        printf("Enter the number: ");
        scanf("%f", &v9);
        v5 = log10(v9);
        v10 = v5;
        printf("Result: %f \n", v5);
        break;
      case 8:
        printf("Thank you for using Scientific Calculator!\n");
        exit(0);
      default:
        printf("Invalid input! Please select a valid operation.\n");
        break;
    }
  }
  while ( v7 != 8 );
  return 0;
}
// 140001BA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Movie Rating System ; Style: post-apocalyptic
#include <stdio.h>

int main() {
    int rating;
    printf("Please enter your movie rating (1-10): ");
    scanf("%d", &rating);

    if (rating == 10) {
        printf("Wow, you have great taste in movies!\n");
    } else if (rating >= 8) {
        printf("That's a really good rating! You must have enjoyed the movie.\n");
    } else if (rating >= 5) {
        printf("Your rating is average. The movie may have been decent.\n");
    } else if (rating >= 3) {
        printf("Rating this movie that low is a crime! Did you really dislike it that much?\n");
    } else {
        printf("This movie must have been terrible if you rated it that low...\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Please enter your movie rating (1-10): ");
  scanf("%d", &v4);
  if ( v4 == 10 )
  {
    printf("Wow, you have great taste in movies!\n");
  }
  else if ( v4 <= 7 )
  {
    if ( v4 <= 4 )
    {
      if ( v4 <= 2 )
        printf("This movie must have been terrible if you rated it that low...\n");
      else
        printf("Rating this movie that low is a crime! Did you really dislike it that much?\n");
    }
    else
    {
      printf("Your rating is average. The movie may have been decent.\n");
    }
  }
  else
  {
    printf("That's a really good rating! You must have enjoyed the movie.\n");
  }
  return 0;
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Watermarking ; Style: intelligent
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define MAX_MSG_LENGTH 1000
#define MAX_WATERMARK_LENGTH 100

char* generateWatermark(char* message, char* watermark) {
    // Append watermark at the end of message
    strcat(message, watermark);
    // Reverse the message
    int len = strlen(message);
    char* reversedMsg = (char*)malloc(sizeof(char) * len);
    for(int i = 0; i < len; i++) {
        reversedMsg[i] = message[len - i - 1];
    }
    return reversedMsg;
}

void extractWatermark(char* reversedMsg, char* watermark) {
    // Reverse the reversed message to get the original message
    int len = strlen(reversedMsg);
    char* originalMsg = (char*)malloc(sizeof(char) * len);
    for(int i = 0; i < len; i++) {
        originalMsg[i] = reversedMsg[len - i - 1];
    }
    // Extract watermark from the original message
    int watermarkLen = strlen(watermark);
    strncpy(watermark, &originalMsg[strlen(originalMsg) - watermarkLen], watermarkLen);
}

int main() {
    char message[MAX_MSG_LENGTH], watermark[MAX_WATERMARK_LENGTH];
    printf("Enter the message: ");
    scanf("%[^\n]", message);
    printf("Enter the watermark: ");
    scanf("%s", watermark);
    char* stegoMessage = generateWatermark(message, watermark);
    printf("Stego message with watermark: %s\n", stegoMessage);
    char extractedWatermark[MAX_WATERMARK_LENGTH];
    extractWatermark(stegoMessage, extractedWatermark);
    printf("Extracted watermark: %s\n", extractedWatermark);
    free(stegoMessage);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generateWatermark(_QWORD, _QWORD); // weak
__int64 __fastcall extractWatermark(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (0000000140001719) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[112]; // [rsp+20h] [rbp-60h] BYREF
  char v5[112]; // [rsp+90h] [rbp+10h] BYREF
  char v6[1000]; // [rsp+100h] [rbp+80h] BYREF
  void *Block; // [rsp+4E8h] [rbp+468h]

  _main(argc, argv, envp);
  printf("Enter the message: ");
  scanf("%[^\n]", v6);
  printf("Enter the watermark: ");
  scanf("%s", v5);
  Block = (void *)generateWatermark(v6, v5);
  printf("Stego message with watermark: %s\n", (const char *)Block);
  extractWatermark(Block, v4);
  printf("Extracted watermark: %s\n", v4);
  free(Block);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall generateWatermark(_QWORD, _QWORD);
// 140001663: using guessed type __int64 __fastcall extractWatermark(_QWORD, _QWORD);
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password management ; Style: beginner-friendly
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define MAX 30 // Maximum number of passwords

// Password structure
typedef struct{
    char website[50];
    char username[30];
    char password[30];
}Password;

int count = 0; // Count variable to keep track of number of passwords stored

Password passwords[MAX]; // Array to store passwords

// Function prototypes
void add_password();
void view_passwords();
void search_website();


int main(){
    int choice;

    printf("Welcome to the Password Manager!\n\n");

    while(1){
        printf("Please choose an option:\n");
        printf("1. Add new password\n");
        printf("2. View saved passwords\n");
        printf("3. Search passwords by website\n");
        printf("4. Exit\n");

        scanf("%d", &choice);

        switch(choice){
            case 1:
                add_password();
                break;
            case 2:
                view_passwords();
                break;
            case 3:
                search_website();
                break;
            case 4:
                printf("\nThank you for using the Password Manager!");
                exit(0); // Exit the program
            default:
                printf("\nInvalid choice, please try again.\n");
        }
    }

    return 0;
}


// Function to add a new password
void add_password(){
    if(count == MAX){
        printf("\nYou have reached the maximum number of passwords that can be stored.\n");
        return;
    }

    Password new_password;

    printf("\nPlease enter the website name: ");
    scanf("%s", new_password.website);

    printf("Please enter the username: ");
    scanf("%s", new_password.username);

    printf("Please enter the password: ");
    scanf("%s", new_password.password);

    passwords[count++] = new_password;

    printf("\nThe password has been added successfully!\n\n");
}


// Function to view all saved passwords
void view_passwords(){
    if(count == 0){
        printf("\nNo passwords have been saved yet.\n\n");
        return;
    }

    printf("\nWebsite\t\tUsername\t\tPassword\n");

    for(int i=0; i<count; i++){
        printf("%s\t\t%s\t\t%s\n", passwords[i].website, passwords[i].username, passwords[i].password);
    }

    printf("\n");
}


// Function to search for a stored password b website
void search_website(){
    if(count == 0){
        printf("\nNo passwords have been saved yet.\n\n");
        return;
    }

    char website[50];
    int found = 0;

    printf("\nPlease enter the website name to search for: ");
    scanf("%s", website);

    for(int i=0; i<count; i++){
        if(strcmp(passwords[i].website, website) == 0){
            found = 1;
            printf("\nWebsite: %s\n", passwords[i].website);
            printf("Username: %s\n", passwords[i].username);
            printf("Password: %s\n", passwords[i].password);
            break;
        }
    }

    if(!found){
        printf("\nThe website you searched for could not be found.\n\n");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 add_password(void); // weak
__int64 view_passwords(void); // weak
__int64 search_website(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Password Manager!\n\n");
  while ( 1 )
  {
    printf("Please choose an option:\n");
    printf("1. Add new password\n");
    printf("2. View saved passwords\n");
    printf("3. Search passwords by website\n");
    printf("4. Exit\n");
    scanf("%d", &v3);
    if ( v3 == 4 )
    {
      printf("\nThank you for using the Password Manager!");
      exit(0);
    }
    if ( v3 > 4 )
    {
LABEL_12:
      printf("\nInvalid choice, please try again.\n");
    }
    else
    {
      switch ( v3 )
      {
        case 3:
          search_website();
          break;
        case 1:
          add_password();
          break;
        case 2:
          view_passwords();
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 140001674: conditional instruction was optimized away because %var_4.4<3
// 1400016C4: using guessed type __int64 add_password(void);
// 140001825: using guessed type __int64 view_passwords(void);
// 1400018E6: using guessed type __int64 search_website(void);
// 140001AD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Educational ; Style: relaxed
/* This is a program that calculates the sum of the first n natural numbers using a for loop */

#include<stdio.h>

int main(){

    int n, sum=0;

    printf("Please enter the value of n: ");
    scanf("%d",&n);

    // loop through every number from 1 to n and add them to the sum
    for(int i=1;i<=n;i++){
        sum += i;
    }

    printf("The sum of the first %d natural numbers is: %d", n, sum);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch] BYREF
  int i; // [rsp+28h] [rbp-8h]
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  printf("Please enter the value of n: ");
  scanf("%d", &v4);
  for ( i = 1; i <= (int)v4; ++i )
    v6 += i;
  printf("The sum of the first %d natural numbers is: %d", v4, v6);
  return 0;
}
// 140001710: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sudoku solver ; Style: ephemeral
#include <stdio.h>
#include <stdbool.h>

#define SIZE 9

void printBoard(int board[][SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf("%d ", board[i][j]);
        }
        printf("\n");
    }
}

bool rowContains(int board[][SIZE], int row, int num) {
    for (int i = 0; i < SIZE; i++) {
        if (board[row][i] == num) {
            return true;
        }
    }
    return false;
}

bool colContains(int board[][SIZE], int col, int num) {
    for (int i = 0; i < SIZE; i++) {
        if (board[i][col] == num) {
            return true;
        }
    }
    return false;
}

bool boxContains(int board[][SIZE], int boxStartRow, int boxStartCol, int num) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (board[i + boxStartRow][j + boxStartCol] == num) {
                return true;
            }
        }
    }
    return false;
}

bool isSafe(int board[][SIZE], int row, int col, int num) {
    return !rowContains(board, row, num) &&
           !colContains(board, col, num) &&
           !boxContains(board, row - row % 3, col - col % 3, num);
}

bool findEmptySpot(int board[][SIZE], int *row, int *col) {
    for (*row = 0; *row < SIZE; (*row)++) {
        for (*col = 0; *col < SIZE; (*col)++) {
            if (board[*row][*col] == 0) {
                return true;
            }
        }
    }
    return false;
}

bool solveSudoku(int board[][SIZE]) {
    int row, col;
    if (!findEmptySpot(board, &row, &col)) {
        return true;
    }
    for (int num = 1; num <= 9; num++) {
        if (isSafe(board, row, col, num)) {
            board[row][col] = num;
            if (solveSudoku(board)) {
                return true;
            }
            board[row][col] = 0;
        }
    }
    return false;
}

int main() {
    // Board to solve
    int board[SIZE][SIZE] = {
        {3, 0, 6, 5, 0, 8, 4, 0, 0},
        {5, 2, 0, 0, 0, 0, 0, 0, 0},
        {0, 8, 7, 0, 0, 0, 0, 3, 1},
        {0, 0, 3, 0, 0, 0, 0, 2, 0},
        {9, 0, 0, 8, 0, 0, 0, 0, 5},
        {0, 5, 0, 0, 0, 0, 6, 0, 0},
        {1, 3, 0, 0, 0, 0, 2, 5, 0},
        {0, 0, 0, 0, 0, 0, 0, 7, 4},
        {0, 0, 5, 2, 0, 6, 3, 0, 0}
    };

    // Print the unsolved board
    printf("Unsolved Sudoku Board:\n");
    printBoard(board);

    // Solve the Sudoku and print the solved board
    if (solveSudoku(board)) {
        printf("Solved Sudoku Board:\n");
        printBoard(board);
    } else {
        printf("No solution exists for this Sudoku Board\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printBoard(_QWORD); // weak
__int64 __fastcall solveSudoku(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (00000001400019AD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[352]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v4, &unk_14000A020, 0x144ui64);
  printf("Unsolved Sudoku Board:\n");
  printBoard(v4);
  if ( (unsigned __int8)solveSudoku(v4) )
  {
    printf("Solved Sudoku Board:\n");
    printBoard(v4);
  }
  else
  {
    printf("No solution exists for this Sudoku Board\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printBoard(_QWORD);
// 1400018CE: using guessed type __int64 __fastcall solveSudoku(_QWORD);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Electronic Voting System ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// define constants for number of candidates and voters
#define MAX_CANDIDATES 10
#define MAX_VOTERS 100

// define structures for candidate and voter
typedef struct {
    int id;
    char name[20];
    int votes;
} Candidate;

typedef struct {
    int id;
    char name[20];
    int voted_for;
} Voter;

int main() {
    // initialize candidates and voters array
    Candidate candidates[MAX_CANDIDATES];
    Voter voters[MAX_VOTERS];

    // initialize candidates
    candidates[0].id = 1;
    strcpy(candidates[0].name, "Alice");
    candidates[0].votes = 0;

    candidates[1].id = 2;
    strcpy(candidates[1].name, "Bob");
    candidates[1].votes = 0;

    // get number of voters
    int num_voters;
    printf("Enter number of voters: ");
    scanf("%d", &num_voters);

    // check if number of voters is not greater than maximum allowed
    if (num_voters > MAX_VOTERS) {
        printf("Error: Number of voters exceeds maximum allowed!\n");
        return 1;
    }

    // collect voter information
    for (int i = 0; i < num_voters; i++) {
        printf("Enter voter %d id and name: ", i + 1);
        int id;
        char name[20];
        scanf("%d %s", &id, name);

        // check if voter already exists in the list
        for (int j = 0; j < i; j++) {
            if (voters[j].id == id) {
                printf("Error: Voter with same id already exists!\n");
                return 1;
            }
        }

        // add voter to the list
        voters[i].id = id;
        strcpy(voters[i].name, name);
        voters[i].voted_for = 0;
    }

    // start voting process
    printf("Voting has started!\n");
    int num_votes = 0;
    while (num_votes < num_voters) {
        printf("Enter voter id and candidate id to cast your vote: ");
        int voter_id, candidate_id;
        scanf("%d %d", &voter_id, &candidate_id);

        // check if provided voter id is valid
        int voter_index = -1;
        for (int i = 0; i < num_voters; i++) {
            if (voters[i].id == voter_id) {
                voter_index = i;
                break;
            }
        }
        if (voter_index == -1) {
            printf("Error: Invalid voter id!\n");
            continue;
        }

        // check if provided candidate id is valid
        int candidate_index = -1;
        for (int i = 0; i < MAX_CANDIDATES; i++) {
            if (candidates[i].id == candidate_id) {
                candidate_index = i;
                break;
            }
        }
        if (candidate_index == -1) {
            printf("Error: Invalid candidate id!\n");
            continue;
        }

        // check if voter has already voted
        if (voters[voter_index].voted_for != 0) {
            printf("Error: This voter has already voted!\n");
            continue;
        }

        // cast vote and update vote count
        candidates[candidate_index].votes++;
        voters[voter_index].voted_for = candidate_id;
        num_votes++;

        printf("Vote casted successfully!\n");
    }

    // print final result
    printf("\nVoting result:\n\n");
    for (int i = 0; i < MAX_CANDIDATES; i++) {
        printf("%s: %d votes.\n", candidates[i].name, candidates[i].votes);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strcpy(char *Destination, const char *Source);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char Source[24]; // [rsp+30h] [rbp-50h] BYREF
  int v7; // [rsp+48h] [rbp-38h] BYREF
  int v8[13]; // [rsp+4Ch] [rbp-34h] BYREF
  _BYTE v9[2752]; // [rsp+80h] [rbp+0h] BYREF
  int v10; // [rsp+B40h] [rbp+AC0h] BYREF
  char v11[8]; // [rsp+B44h] [rbp+AC4h] BYREF
  int v12; // [rsp+B58h] [rbp+AD8h]
  int v13; // [rsp+B5Ch] [rbp+ADCh]
  int v14; // [rsp+B60h] [rbp+AE0h]
  int v15; // [rsp+B74h] [rbp+AF4h]
  int n; // [rsp+C60h] [rbp+BE0h]
  int m; // [rsp+C64h] [rbp+BE4h]
  int v18; // [rsp+C68h] [rbp+BE8h]
  int k; // [rsp+C6Ch] [rbp+BECh]
  int v20; // [rsp+C70h] [rbp+BF0h]
  int v21; // [rsp+C74h] [rbp+BF4h]
  int j; // [rsp+C78h] [rbp+BF8h]
  int i; // [rsp+C7Ch] [rbp+BFCh]

  _main(argc, argv, envp);
  v10 = 1;
  strcpy(v11, "Alice");
  v12 = 0;
  v13 = 2;
  v14 = 6451010;
  v15 = 0;
  printf("Enter number of voters: ");
  scanf("%d", v8);
  if ( v8[0] <= 100 )
  {
    for ( i = 0; i < v8[0]; ++i )
    {
      printf("Enter voter %d id and name: ", (unsigned int)(i + 1));
      scanf("%d %s", &v7, Source);
      for ( j = 0; j < i; ++j )
      {
        if ( *(_DWORD *)&v9[28 * j - 48] == v7 )
        {
          printf("Error: Voter with same id already exists!\n");
          return 1;
        }
      }
      *(_DWORD *)&v9[28 * i - 48] = v7;
      strcpy((char *)&v8[7 * i + 2], Source);
      *(_DWORD *)&v9[28 * i - 24] = 0;
    }
    printf("Voting has started!\n");
    v21 = 0;
    while ( v21 < v8[0] )
    {
      printf("Enter voter id and candidate id to cast your vote: ");
      scanf("%d %d", &v5, &v4);
      v20 = -1;
      for ( k = 0; k < v8[0]; ++k )
      {
        if ( *(_DWORD *)&v9[28 * k - 48] == v5 )
        {
          v20 = k;
          break;
        }
      }
      if ( v20 == -1 )
      {
        printf("Error: Invalid voter id!\n");
      }
      else
      {
        v18 = -1;
        for ( m = 0; m <= 9; ++m )
        {
          if ( *(_DWORD *)&v9[28 * m + 2752] == v4 )
          {
            v18 = m;
            break;
          }
        }
        if ( v18 == -1 )
        {
          printf("Error: Invalid candidate id!\n");
        }
        else if ( *(_DWORD *)&v9[28 * v20 - 24] )
        {
          printf("Error: This voter has already voted!\n");
        }
        else
        {
          ++*(_DWORD *)&v9[28 * v18 + 2776];
          *(_DWORD *)&v9[28 * v20 - 24] = v4;
          ++v21;
          printf("Vote casted successfully!\n");
        }
      }
    }
    printf("\nVoting result:\n\n");
    for ( n = 0; n <= 9; ++n )
      printf("%s: %d votes.\n", &v11[28 * n], *(unsigned int *)&v9[28 * n + 2776]);
    return 0;
  }
  else
  {
    printf("Error: Number of voters exceeds maximum allowed!\n");
    return 1;
  }
}
// 140001B60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Source[24];

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Arithmetic ; Style: synchronous
#include <stdio.h>

/* Function to calculate the sum of array using synchronous programming */
int synchronous_sum(int arr[], int size) {
  int sum = 0;
  for (int i = 0; i < size; i++) {
    sum += arr[i];
  }
  return sum;
}

/* Function to calculate the product of array using synchronous programming */
int synchronous_product(int arr[], int size) {
  int product = 1;
  for (int i = 0; i < size; i++) {
    product *= arr[i];
  }
  return product;
}

/* Function to calculate the average of array using synchronous programming */
float synchronous_average(int arr[], int size) {
  float sum = synchronous_sum(arr, size);
  return sum / size;
}

int main() {
  int arr[] = { 1, 2, 3, 4, 5 };
  int size = sizeof(arr)/sizeof(arr[0]); // calculating the length of the array

  printf("The sum of the array is %d.\n", synchronous_sum(arr, size));

  printf("The product of the array is %d.\n", synchronous_product(arr, size));

  printf("The average of the array is %.2f.\n", synchronous_average(arr, size));

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall synchronous_sum(_QWORD, _QWORD); // weak
__int64 __fastcall synchronous_product(_QWORD, _QWORD); // weak
float __fastcall synchronous_average(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001673) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  float v5; // xmm0_4
  int v7[7]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7[0] = 1;
  v7[1] = 2;
  v7[2] = 3;
  v7[3] = 4;
  v7[4] = 5;
  v8 = 5;
  v3 = synchronous_sum(v7, 5i64);
  printf("The sum of the array is %d.\n", v3);
  v4 = synchronous_product(v7, v8);
  printf("The product of the array is %d.\n", v4);
  v5 = synchronous_average(v7, v8);
  printf("The average of the array is %.2f.\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall synchronous_sum(_QWORD, _QWORD);
// 1400015DE: using guessed type __int64 __fastcall synchronous_product(_QWORD, _QWORD);
// 140001631: using guessed type float __fastcall synchronous_average(_QWORD, _QWORD);
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: configurable
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

#define MAX 20  //maximum number of cars on the road 
#define LANES 4 //number of lanes on the road 

int main() {
    srand(time(NULL));  //initialize random seed

    //configure the parameters for the simulation
    int speed[LANES] = {80, 70, 60, 50}; //speed limit for each lane
    int distance[MAX] = {0}; //distance of each car from the start of the road
    int position[LANES] = {0}; //position of the front car in each lane
    int lane[MAX] = {0}; //lane on which each car is
    int acceleration[MAX]; //acceleration of each car
    int braking[MAX]; //braking of each car
    int v[MAX]; //velocity of each car
    int time[MAX] = {0}; //time at which each car entered the road
    int count[MAX] = {0}; //number of cars between each car and the traffic jam
    int jam_distance[MAX] = {0}; //distance of each car from the traffic jam
    int jam_time[MAX] = {0}; //time at which each car encountered the traffic jam
    int jam_location = -1; //distance from the start of the road where the traffic jam occurs
    int jam_duration = -1; //duration of the traffic jam

    //initialize the distance and position of each car randomly
    for(int i=0; i<MAX; i++) {
        distance[i] = rand()%1000;  //random value from 0 to 999
        lane[i] = rand()%LANES;  //random lane from 0 to 3
        if(distance[i] > position[lane[i]]) {  //if the car is ahead of the front car in the current lane 
            position[lane[i]] = distance[i];
        }
        v[i] = speed[lane[i]];  //initialize the velocity of each car to the speed limit of its lane
        time[i] = rand()%3600;  //random value from 0 to 3599 seconds
    }

    //simulate the traffic flow
    while(1) {
        //determine the location of the traffic jam randomly at the start of the simulation or after the previous jam has been cleared
        if(jam_duration == 0) {
            jam_location = rand()%4000+5000;  //random distance from 5000 to 8999 meters
            jam_duration = rand()%600+600; //random duration from 600 to 1199 seconds
        }

        //calculate the acceleration and braking of each car based on the car-following model and update the velocity and distance
        for(int i=0; i<MAX; i++) {
            int d = position[lane[i]] - distance[i];
            int j = count[i] > 0 ? count[i] : MAX;  //if there is no car ahead of it, consider the traffic jam as the front car
            int dj = jam_distance[i] - distance[i];
            int t_star = 1.2;  //minimum safe time gap
            int a = 1;  //constant acceleration
            int b = 1;  //constant deceleration
            int delta = 4;  //delta exponent coefficient
            int s_star = 2*t_star*v[i];  //minimum safe distance
            acceleration[i] = a*(1-pow(v[i]/speed[lane[i]], delta)-pow(s_star/(d-t_star*v[i]), 2));
            if(i < j-1 && lane[i] == lane[i+1]) {  //if there is a car ahead of it in the same lane
                int d1 = position[lane[i]] - distance[i+1];
                int v1 = v[i+1];
                int s_star1 = 2*t_star*v1;
                acceleration[i] = a*(1-pow(v[i]/speed[lane[i]], delta)-pow(s_star/(d-t_star*v[i]-v[i]*(v[i]-v1)/(2*sqrt(a*b))), 2));
                braking[i+1] = b*pow(s_star1/(d1-t_star*v1), 2);
            }
            else if(d <= s_star) {  //if it is too close to the front car
                braking[i] = b*pow(s_star/d, 2);
            }
            if(distance[i] >= jam_location && distance[i] < jam_location+jam_duration && dj <= s_star) {  //if it is inside the traffic jam and too close to the front car 
                braking[i] = b*pow(s_star/dj, 2);
            }
            if(v[i]+acceleration[i] > speed[lane[i]]) {  //if it exceeds the speed limit of its lane
                acceleration[i] = (speed[lane[i]]-v[i])/1.2;
            }
            v[i] = v[i]+acceleration[i]-braking[i];
            if(v[i] < 0) {
                v[i] = 0;
            }
            distance[i] = distance[i]+v[i];
            if(distance[i] > position[lane[i]]) {  //if it passes the front car in the current lane
                position[lane[i]] = distance[i];
            }
            if(distance[i] >= jam_location && distance[i] < jam_location+jam_duration) {  //if it encounters the traffic jam
                count[i] = 0;
                jam_distance[i] = distance[i];
                jam_time[i] = time[i];
                for(int j=0; j<MAX; j++) {
                    if(j == i) {
                        continue;
                    }
                    if(lane[j] == lane[i] && distance[j] >= jam_location && distance[j] < jam_location+jam_duration && distance[j] < distance[i]) {  //if there is a car ahead of it inside the traffic jam
                        count[i]++;
                    }
                }
            }
            else if(distance[i] < jam_location) {  //if it is behind the traffic jam
                count[i] = 0;
            }
        }

        //output the current state of the simulation
        for(int i=0; i<LANES; i++) {
            printf("Lane %d:\t", i+1);
            for(int j=0; j<=position[i]/100; j++) {
                if(j == jam_location/100) {  //output the traffic jam with an underline
                    printf("\033[4m*\033[0m");
                }
                else {
                    printf("-");
                }
            }
            printf("\n");
        }
        printf("Time elapsed: %d s\n", time[0]);

        //update the time and check if the simulation has ended
        time[0]++;
        if(distance[0] >= 10000) {  //if the first car reaches the end of the road
            break;
        }
        if(jam_duration > 0) {  //if there is a traffic jam
            jam_duration--;
            if(jam_duration == 0) {  //if the traffic jam has been cleared
                for(int i=0; i<MAX; i++) {
                    if(jam_distance[i] >= jam_location && jam_distance[i] < jam_location+jam_duration) {  //if the car is inside the traffic jam
                        count[i] = 0;
                    }
                }
            }
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl pow(double X, double Y);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax
  double v5; // xmm6_8
  double v6; // xmm7_8
  double v7; // xmm10_8
  double v8; // xmm6_8
  double v9; // xmm7_8
  double v10; // xmm8_8
  double v11; // xmm9_8
  double v12; // xmm0_8
  double v13; // xmm0_8
  double v14; // xmm6_8
  double v15; // xmm0_8
  double v16; // xmm6_8
  double v17; // xmm0_8
  double v18; // xmm6_8
  double v19; // xmm0_8
  __int64 v21[10]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v22[10]; // [rsp+70h] [rbp-10h] BYREF
  __int64 v23[10]; // [rsp+C0h] [rbp+40h] BYREF
  __int64 v24[40]; // [rsp+110h] [rbp+90h] BYREF
  __int64 v25[10]; // [rsp+250h] [rbp+1D0h] BYREF
  __int64 v26[2]; // [rsp+2A0h] [rbp+220h]
  __int64 v27[10]; // [rsp+2B0h] [rbp+230h] BYREF
  int v28[5]; // [rsp+300h] [rbp+280h]
  int v29; // [rsp+314h] [rbp+294h]
  int v30; // [rsp+318h] [rbp+298h]
  int v31; // [rsp+31Ch] [rbp+29Ch]
  int v32; // [rsp+320h] [rbp+2A0h]
  int v33; // [rsp+324h] [rbp+2A4h]
  int v34; // [rsp+328h] [rbp+2A8h]
  int v35; // [rsp+32Ch] [rbp+2ACh]
  int v36; // [rsp+330h] [rbp+2B0h]
  int v37; // [rsp+334h] [rbp+2B4h]
  int v38; // [rsp+338h] [rbp+2B8h]
  int v39; // [rsp+33Ch] [rbp+2BCh]
  int ii; // [rsp+340h] [rbp+2C0h]
  int n; // [rsp+344h] [rbp+2C4h]
  int m; // [rsp+348h] [rbp+2C8h]
  int k; // [rsp+34Ch] [rbp+2CCh]
  int j; // [rsp+350h] [rbp+2D0h]
  int i; // [rsp+354h] [rbp+2D4h]
  int v46; // [rsp+358h] [rbp+2D8h]
  int v47; // [rsp+35Ch] [rbp+2DCh]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v28[0] = 80;
  v28[1] = 70;
  v28[2] = 60;
  v28[3] = 50;
  memset(v27, 0, sizeof(v27));
  v26[0] = 0i64;
  v26[1] = 0i64;
  memset(v25, 0, sizeof(v25));
  memset(v24, 0, 80);
  memset(v23, 0, sizeof(v23));
  memset(v22, 0, sizeof(v22));
  memset(v21, 0, sizeof(v21));
  v47 = -1;
  v46 = -1;
  for ( i = 0; i <= 19; ++i )
  {
    *((_DWORD *)v27 + i) = rand() % 1000;
    *((_DWORD *)v25 + i) = rand() % 4;
    if ( *((_DWORD *)v27 + i) > *((_DWORD *)v26 + *((int *)v25 + i)) )
      *((_DWORD *)v26 + *((int *)v25 + i)) = *((_DWORD *)v27 + i);
    *((_DWORD *)&v24[10] + i) = v28[*((int *)v25 + i)];
    *((_DWORD *)v24 + i) = rand() % 3600;
  }
  while ( 1 )
  {
    if ( !v46 )
    {
      v47 = rand() % 4000 + 5000;
      v46 = rand() % 600 + 600;
    }
    for ( j = 0; j <= 19; ++j )
    {
      v39 = *((_DWORD *)v26 + *((int *)v25 + j)) - *((_DWORD *)v27 + j);
      if ( *((int *)v23 + j) <= 0 )
        v4 = 20;
      else
        v4 = *((_DWORD *)v23 + j);
      v38 = v4;
      v37 = *((_DWORD *)v22 + j) - *((_DWORD *)v27 + j);
      v36 = 1;
      v35 = 1;
      v34 = 1;
      v33 = 4;
      v32 = 2 * *((_DWORD *)&v24[10] + j);
      v5 = 1.0 - pow((double)(*((_DWORD *)&v24[10] + j) / v28[*((int *)v25 + j)]), (double)4);
      v6 = (double)1 * (v5 - pow((double)(v32 / (v39 - v36 * *((_DWORD *)&v24[10] + j))), 2.0));
      *((_DWORD *)&v24[30] + j) = (int)v6;
      if ( j < v38 - 1 && *((_DWORD *)v25 + j) == *((_DWORD *)v25 + j + 1) )
      {
        v31 = *((_DWORD *)v26 + *((int *)v25 + j)) - *((_DWORD *)v27 + j + 1);
        v30 = *((_DWORD *)&v24[10] + j + 1);
        v29 = 2 * v30 * v36;
        v7 = (double)v35;
        v8 = 1.0 - pow((double)(*((_DWORD *)&v24[10] + j) / v28[*((int *)v25 + j)]), (double)v33);
        v9 = (double)v32;
        v10 = (double)(v39 - v36 * *((_DWORD *)&v24[10] + j));
        v11 = (double)(*((_DWORD *)&v24[10] + j) * (*((_DWORD *)&v24[10] + j) - v30));
        v12 = sqrt((double)(v34 * v35));
        v13 = pow(v9 / (v10 - v11 / (v12 + v12)), 2.0);
        *((_DWORD *)&v24[30] + j) = (int)(v7 * (v8 - v13));
        v14 = (double)v34;
        v15 = pow((double)(v29 / (v31 - v30 * v36)), 2.0);
        *((_DWORD *)&v24[20] + j + 1) = (int)(v15 * v14);
      }
      else if ( v39 <= v32 )
      {
        v16 = (double)v34;
        v17 = pow((double)(v32 / v39), 2.0);
        *((_DWORD *)&v24[20] + j) = (int)(v17 * v16);
      }
      if ( v47 <= *((_DWORD *)v27 + j) && *((_DWORD *)v27 + j) < v47 + v46 && v37 <= v32 )
      {
        v18 = (double)v34;
        v19 = pow((double)(v32 / v37), 2.0);
        *((_DWORD *)&v24[20] + j) = (int)(v19 * v18);
      }
      if ( *((_DWORD *)&v24[30] + j) + *((_DWORD *)&v24[10] + j) > v28[*((int *)v25 + j)] )
        *((_DWORD *)&v24[30] + j) = (int)((double)(v28[*((int *)v25 + j)] - *((_DWORD *)&v24[10] + j)) / 1.2);
      *((_DWORD *)&v24[10] + j) = *((_DWORD *)&v24[30] + j) + *((_DWORD *)&v24[10] + j) - *((_DWORD *)&v24[20] + j);
      if ( *((int *)&v24[10] + j) < 0 )
        *((_DWORD *)&v24[10] + j) = 0;
      *((_DWORD *)v27 + j) += *((_DWORD *)&v24[10] + j);
      if ( *((_DWORD *)v27 + j) > *((_DWORD *)v26 + *((int *)v25 + j)) )
        *((_DWORD *)v26 + *((int *)v25 + j)) = *((_DWORD *)v27 + j);
      if ( v47 > *((_DWORD *)v27 + j) || *((_DWORD *)v27 + j) >= v47 + v46 )
      {
        if ( v47 > *((_DWORD *)v27 + j) )
          *((_DWORD *)v23 + j) = 0;
      }
      else
      {
        *((_DWORD *)v23 + j) = 0;
        *((_DWORD *)v22 + j) = *((_DWORD *)v27 + j);
        *((_DWORD *)v21 + j) = *((_DWORD *)v24 + j);
        for ( k = 0; k <= 19; ++k )
        {
          if ( k != j
            && *((_DWORD *)v25 + k) == *((_DWORD *)v25 + j)
            && v47 <= *((_DWORD *)v27 + k)
            && *((_DWORD *)v27 + k) < v47 + v46
            && *((_DWORD *)v27 + k) < *((_DWORD *)v27 + j) )
          {
            ++*((_DWORD *)v23 + j);
          }
        }
      }
    }
    for ( m = 0; m <= 3; ++m )
    {
      printf("Lane %d:\t", (unsigned int)(m + 1));
      for ( n = 0; n <= *((_DWORD *)v26 + m) / 100; ++n )
      {
        if ( n == v47 / 100 )
          printf("\x1B[4m*\x1B[0m");
        else
          printf("-");
      }
      printf("\n");
    }
    printf("Time elapsed: %d s\n", LODWORD(v24[0]));
    ++LODWORD(v24[0]);
    if ( SLODWORD(v27[0]) > 9999 )
      break;
    if ( v46 > 0 && !--v46 )
    {
      for ( ii = 0; ii <= 19; ++ii )
      {
        if ( v47 <= *((_DWORD *)v22 + ii) && *((_DWORD *)v22 + ii) < v47 + v46 )
          *((_DWORD *)v23 + ii) = 0;
      }
    }
  }
  return 0;
}
// 1400024C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Huffman Coding Implementation ; Style: portable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TREE_HT 100

struct MinHeapNode {
    char data;
    unsigned frequency;
    struct MinHeapNode *left, *right;
};

struct MinHeap {
    unsigned size;
    unsigned capacity;
    struct MinHeapNode **array;
};

struct MinHeapNode *newMinHeapNode(char data, unsigned frequency) {
    struct MinHeapNode *temp = (struct MinHeapNode*)malloc(sizeof(struct MinHeapNode));
    temp->left = temp->right = NULL;
    temp->data = data;
    temp->frequency = frequency;
    return temp;
}

struct MinHeap *createMinHeap(unsigned capacity) {
    struct MinHeap *minHeap = (struct MinHeap*)malloc(sizeof(struct MinHeap));
    minHeap->size = 0;
    minHeap->capacity = capacity;
    minHeap->array = (struct MinHeapNode**)malloc(minHeap->capacity * sizeof(struct MinHeapNode*));
    return minHeap;
}

void swapMinHeapNode(struct MinHeapNode** a, struct MinHeapNode** b) {
    struct MinHeapNode* t = *a;
    *a = *b;
    *b = t;
}

void minHeapify(struct MinHeap* minHeap, int idx) {
    int smallest = idx;
    int left = 2 * idx + 1;
    int right = 2 * idx + 2;

    if (left < minHeap->size && minHeap->array[left]->frequency < minHeap->array[smallest]->frequency)
        smallest = left;

    if (right < minHeap->size && minHeap->array[right]->frequency < minHeap->array[smallest]->frequency)
        smallest = right;

    if (smallest != idx) {
        swapMinHeapNode(&minHeap->array[smallest], &minHeap->array[idx]);
        minHeapify(minHeap, smallest);
    }
}

int isSizeOne(struct MinHeap* minHeap) {
    return (minHeap->size == 1);
}

struct MinHeapNode* extractMin(struct MinHeap* minHeap) {
    struct MinHeapNode* temp = minHeap->array[0];
    minHeap->array[0] = minHeap->array[minHeap->size - 1];

    --minHeap->size;
    minHeapify(minHeap, 0);

    return temp;
}

void insertMinHeap(struct MinHeap* minHeap, struct MinHeapNode* minHeapNode) {
    ++minHeap->size;
    int i = minHeap->size - 1;

    while (i && minHeapNode->frequency < minHeap->array[(i - 1) / 2]->frequency) {
        minHeap->array[i] = minHeap->array[(i - 1) / 2];
        i = (i - 1) / 2;
    }

    minHeap->array[i] = minHeapNode;
}

void buildMinHeap(struct MinHeap* minHeap) {
    int n = minHeap->size - 1;
    int i;
    for (i = (n - 1) / 2; i >= 0; --i) {
        minHeapify(minHeap, i);
    }
}

void printArr(int arr[], int n) {
    int i;
    for (i = 0; i < n; ++i) {
        printf("%d", arr[i]);
    }
    printf("\n");
}

int isLeaf(struct MinHeapNode* root) {
    return !(root->left) && !(root->right);
}

struct MinHeap* createAndBuildMinHeap(char data[], int freq[], int size) {
    struct MinHeap* minHeap = createMinHeap(size);

    for (int i = 0; i < size; ++i) {
        minHeap->array[i] = newMinHeapNode(data[i], freq[i]);
    }

    minHeap->size = size;
    buildMinHeap(minHeap);

    return minHeap;
}

struct MinHeapNode* buildHuffmanTree(char data[], int freq[], int size) {
    struct MinHeapNode *left, *right, *top;

    struct MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);

    while (!isSizeOne(minHeap)) {
        left = extractMin(minHeap);
        right = extractMin(minHeap);

        top = newMinHeapNode('$', left->frequency + right->frequency);
        top->left = left;
        top->right = right;

        insertMinHeap(minHeap, top);
    }

    return extractMin(minHeap);
}

void printCodes(struct MinHeapNode* root, int arr[], int top) {
    if (root->left) {
        arr[top] = 0;
        printCodes(root->left, arr, top + 1);
    }

    if (root->right) {
        arr[top] = 1;
        printCodes(root->right, arr, top + 1);
    }

    if (isLeaf(root)) {
        printf("%c: ", root->data);
        printArr(arr, top);
    }
}

void HuffmanCodes(char data[], int freq[], int size) {
    struct MinHeapNode* root = buildHuffmanTree(data, freq, size);

    int arr[MAX_TREE_HT], top = 0;

    printCodes(root, arr, top);
}

int main() {
    char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'};
    int freq[] = {5, 9, 12, 13, 16, 45};
    int size = sizeof(arr) / sizeof(arr[0]);
    HuffmanCodes(arr, freq, size);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall HuffmanCodes(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001C79) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[9]; // [rsp+20h] [rbp-30h] BYREF
  int v5; // [rsp+46h] [rbp-Ah] BYREF
  __int16 v6; // [rsp+4Ah] [rbp-6h]
  int v7; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5 = 1684234849;
  v6 = 26213;
  v4[0] = 5;
  v4[1] = 9;
  v4[2] = 12;
  v4[3] = 13;
  v4[4] = 16;
  v4[5] = 45;
  v7 = 6;
  HuffmanCodes(&v5, v4, 6i64);
  return 0;
}
// 140001BFE: using guessed type __int64 __fastcall HuffmanCodes(_QWORD, _QWORD, _QWORD);
// 140001DA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=151 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAX_PLANETS 10

typedef struct Vector {
    double x;
    double y;
} Vector;

typedef struct Planet {
    Vector position;
    Vector velocity;
    Vector acceleration;
    double mass;
} Planet;

typedef struct SolarSystem {
    Planet planets[MAX_PLANETS];
    int count;
} SolarSystem;

const double GRAV_CONST = 6.67e-11;

void calculate_gravity(Planet *p1, Planet *p2) {
    Vector diff = { p2->position.x - p1->position.x, p2->position.y - p1->position.y };
    double distance = sqrt(diff.x * diff.x + diff.y * diff.y);
    double force = GRAV_CONST * (p1->mass * p2->mass) / (distance * distance);
    Vector direction = { diff.x / distance, diff.y / distance };
    Vector gravity1 = { direction.x * force / p1->mass, direction.y * force / p1->mass };
    Vector gravity2 = { direction.x * force / p2->mass, direction.y * force / p2->mass };
    p1->acceleration.x += gravity2.x;
    p1->acceleration.y += gravity2.y;
    p2->acceleration.x -= gravity1.x;
    p2->acceleration.y -= gravity1.y;
}

void calculate_accelerations(SolarSystem *system) {
    for (int i = 0; i < system->count; i++) {
        system->planets[i].acceleration.x = 0;
        system->planets[i].acceleration.y = 0;
        for (int j = 0; j < system->count; j++) {
            if (i != j) {
                calculate_gravity(&system->planets[i], &system->planets[j]);
            }
        }
    }
}

void update_positions(SolarSystem *system, double time_step) {
    for (int i = 0; i < system->count; i++) {
        Planet *p = &system->planets[i];
        p->position.x += p->velocity.x * time_step + 0.5 * p->acceleration.x * time_step * time_step;
        p->position.y += p->velocity.y * time_step + 0.5 * p->acceleration.y * time_step * time_step;
    }
}

void update_velocities(SolarSystem *system, double time_step) {
    for (int i = 0; i < system->count; i++) {
        Planet *p = &system->planets[i];
        p->velocity.x += p->acceleration.x * time_step;
        p->velocity.y += p->acceleration.y * time_step;
    }
}

void simulate(SolarSystem *system, double time_step, int num_steps) {
    for (int i = 0; i < num_steps; i++) {
        calculate_accelerations(system);
        update_positions(system, time_step);
        calculate_accelerations(system);
        update_velocities(system, time_step);
    }
}

int main() {
    SolarSystem solar_system = { .count = 2 };
    solar_system.planets[0] = (Planet) { .position = { 0, 0 }, .velocity = { 0, 0 }, .acceleration = { 0, 0 }, .mass = 1.989e30 };
    solar_system.planets[1] = (Planet) { .position = { 0, 149.6e9 }, .velocity = { 29.29e3, 0 }, .acceleration = { 0, 0 }, .mass = 5.97e24 };
    double time_step = 3600;
    int num_steps = 24 * 365;
    simulate(&solar_system, time_step, num_steps);
    printf("Position of the Earth: (%lf, %lf)\n", solar_system.planets[1].position.x, solar_system.planets[1].position.y);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall simulate(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A24) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[72]; // [rsp+A0h] [rbp+20h] BYREF
  int v5; // [rsp+2E4h] [rbp+264h]
  __int64 v6; // [rsp+2E8h] [rbp+268h]

  _main(argc, argv, envp);
  memset(v4, 0, 0x238ui64);
  LODWORD(v4[70]) = 2;
  memset(v4, 0, 48);
  v4[6] = 0x46391ACE3D05AEF4i64;
  v4[7] = 0i64;
  v4[8] = 0x42416A6D6C000000i64;
  v4[9] = 0x40DC9A8000000000i64;
  memset(&v4[10], 0, 24);
  v4[13] = 0x4513C0C964D9C187i64;
  v6 = 0x40AC200000000000i64;
  v5 = 8760;
  simulate(v4, 8760i64, 8760i64);
  printf("Position of the Earth: (%lf, %lf)\n", v4[7], v4[8]);
  return 0;
}
// 1400019BC: using guessed type __int64 __fastcall simulate(_QWORD, _QWORD, _QWORD);
// 140001C30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define BOARD_SIZE 4

void print_board(int game_board[][BOARD_SIZE], int revealed[][BOARD_SIZE]);
void update_stats(int game_board[][BOARD_SIZE], int revealed[][BOARD_SIZE], int x1, int y1, int x2, int y2, int *score, int *remaining_count);
int check_win(int remaining_count);

int main() {
    int game_board[BOARD_SIZE][BOARD_SIZE] = {0};
    int revealed[BOARD_SIZE][BOARD_SIZE] = {0};
    int score = 0;
    int remaining_count = BOARD_SIZE * BOARD_SIZE / 2;

    srand(time(NULL));

    // Initialize the board with random values from 1 to BOARD_SIZE^2/2
    for (int i = 1; i <= BOARD_SIZE * BOARD_SIZE / 2; i++) {
        int count = 0;
        while (count < 2) {
            int x = rand() % BOARD_SIZE;
            int y = rand() % BOARD_SIZE;

            if (game_board[x][y] == 0) {
                game_board[x][y] = i;
                count++;
            }
        }
    }

    // Game loop
    while (1) {
        print_board(game_board, revealed);

        printf("Enter the coordinates of the first card (x y): ");
        int x1, y1;
        scanf("%d %d", &x1, &y1);

        // Ensure that the coordinates are valid
        if (x1 < 0 || x1 >= BOARD_SIZE || y1 < 0 || y1 >= BOARD_SIZE || revealed[x1][y1]) {
            printf("Invalid coordinates.\n");
            continue;
        }

        revealed[x1][y1] = 1;
        print_board(game_board, revealed);

        printf("Enter the coordinates of the second card (x y): ");
        int x2, y2;
        scanf("%d %d", &x2, &y2);

        // Ensure that the coordinates are valid
        if (x2 < 0 || x2 >= BOARD_SIZE || y2 < 0 || y2 >= BOARD_SIZE || revealed[x2][y2]) {
            printf("Invalid coordinates.\n");
            revealed[x1][y1] = 0;
            continue;
        }

        revealed[x2][y2] = 1;

        // Update the score and remaining count
        update_stats(game_board, revealed, x1, y1, x2, y2, &score, &remaining_count);

        // Check if the game has been won
        if (check_win(remaining_count)) {
            printf("Congratulations, you won! Your final score is %d.\n", score);
            break;
        }
    }

    return 0;
}

void print_board(int game_board[][BOARD_SIZE], int revealed[][BOARD_SIZE]) {
    printf("    0 1 2 3\n");
    printf("   ---------\n");
    for (int i = 0; i < BOARD_SIZE; i++) {
        printf("%d | ", i);
        for (int j = 0; j < BOARD_SIZE; j++) {
            if (revealed[i][j]) {
                printf("%d ", game_board[i][j]);
            } else {
                printf("  ");
            }
        }
        printf("\n");
    }
    printf("\n");
}

void update_stats(int game_board[][BOARD_SIZE], int revealed[][BOARD_SIZE], int x1, int y1, int x2, int y2, int *score, int *remaining_count) {
    if (game_board[x1][y1] == game_board[x2][y2]) {
        printf("Match found! You earned 10 points.\n");
        *score += 10;
        *remaining_count -= 1;
    } else {
        printf("No match found. You lost 2 points.\n");
        *score -= 2;
        revealed[x1][y1] = 0;
        revealed[x2][y2] = 0;
    }
}

int check_win(int remaining_count) {
    return remaining_count == 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall print_board(_QWORD, _QWORD); // weak
__int64 __fastcall update_stats(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64); // weak
__int64 __fastcall check_win(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+48h] [rbp-A8h] BYREF
  unsigned int v6; // [rsp+4Ch] [rbp-A4h] BYREF
  unsigned int v7; // [rsp+50h] [rbp-A0h] BYREF
  unsigned int v8; // [rsp+54h] [rbp-9Ch] BYREF
  unsigned int v9; // [rsp+58h] [rbp-98h] BYREF
  unsigned int v10; // [rsp+5Ch] [rbp-94h] BYREF
  __int64 v11[8]; // [rsp+60h] [rbp-90h] BYREF
  __int64 v12[8]; // [rsp+A0h] [rbp-50h] BYREF
  int v13; // [rsp+E0h] [rbp-10h]
  int v14; // [rsp+E4h] [rbp-Ch]
  int v15; // [rsp+E8h] [rbp-8h]
  int i; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  memset(v12, 0, sizeof(v12));
  memset(v11, 0, sizeof(v11));
  v10 = 0;
  v9 = 8;
  v3 = time(0i64);
  srand(v3);
  for ( i = 1; i <= 8; ++i )
  {
    v15 = 0;
    while ( v15 <= 1 )
    {
      v14 = rand() % 4;
      v13 = rand() % 4;
      if ( !*((_DWORD *)&v12[2 * v14] + v13) )
      {
        *((_DWORD *)&v12[2 * v14] + v13) = i;
        ++v15;
      }
    }
  }
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        print_board(v12, v11);
        printf("Enter the coordinates of the first card (x y): ");
        scanf("%d %d", &v8, &v7);
        if ( v8 <= 3 && v7 <= 3 && !*((_DWORD *)&v11[2 * (int)v8] + (int)v7) )
          break;
        printf("Invalid coordinates.\n");
      }
      *((_DWORD *)&v11[2 * (int)v8] + (int)v7) = 1;
      print_board(v12, v11);
      printf("Enter the coordinates of the second card (x y): ");
      scanf("%d %d", &v6, &v5);
      if ( v6 <= 3 && v5 <= 3 && !*((_DWORD *)&v11[2 * (int)v6] + (int)v5) )
        break;
      printf("Invalid coordinates.\n");
      *((_DWORD *)&v11[2 * (int)v8] + (int)v7) = 0;
    }
    *((_DWORD *)&v11[2 * (int)v6] + (int)v5) = 1;
    update_stats((unsigned int)v12, (unsigned int)v11, v8, v7, v6, v5, (__int64)&v10, (__int64)&v9);
  }
  while ( !(unsigned int)check_win(v9) );
  printf("Congratulations, you won! Your final score is %d.\n", v10);
  return 0;
}
// 140001986: using guessed type __int64 __fastcall print_board(_QWORD, _QWORD);
// 140001A76: using guessed type __int64 __fastcall update_stats(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);
// 140001B5A: using guessed type __int64 __fastcall check_win(_QWORD);
// 140001C20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Color Code Converter ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Color code structure
typedef struct {
    int red;
    int green;
    int blue;
} Color;

// Function declarations
void display_menu();
void convert_to_hex();
void convert_to_rgb();

// Main function
int main() {
    int choice;
    printf("Welcome to the Color Code Converter!\n");

    do {
        display_menu();
        scanf("%d", &choice);

        switch(choice) {
            case 1:
                convert_to_hex();
                break;
            case 2:
                convert_to_rgb();
                break;
            case 3:
                printf("Exiting program...\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
                break;
        }
    } while(choice != 3);

    return 0;
}

// Display menu function
void display_menu() {
    printf("Please choose an option:\n");
    printf("1. Convert RGB values to Hexadecimal code\n");
    printf("2. Convert Hexadecimal code to RGB values\n");
    printf("3. Exit program\n");
}

// Convert RGB to Hex function
void convert_to_hex() {
    Color color;

    printf("Enter the RGB values (each separated by a space): ");
    scanf("%d %d %d", &color.red, &color.green, &color.blue);

    printf("The Hex code is: #%02x%02x%02x\n", color.red, color.green, color.blue);
}

// Convert Hex to RGB function
void convert_to_rgb() {
    char hex_code[7];
    Color color;

    printf("Enter the Hexadecimal code (without the #): ");
    scanf("%s", hex_code);

    if(strlen(hex_code) != 6) {
        printf("Invalid Hex code, please try again.\n");
        return;
    }

    // Convert Hex code to RGB values
    sscanf(hex_code, "%02x%02x%02x", &color.red, &color.green, &color.blue);

    printf("The RGB values are: %d %d %d\n", color.red, color.green, color.blue);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 display_menu(void); // weak
__int64 convert_to_hex(void); // weak
__int64 convert_to_rgb(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Color Code Converter!\n");
  do
  {
    display_menu();
    scanf("%d", &v4);
    if ( v4 == 3 )
    {
      printf("Exiting program...\n");
    }
    else
    {
      if ( v4 > 3 )
        goto LABEL_10;
      if ( v4 == 1 )
      {
        convert_to_hex();
        continue;
      }
      if ( v4 == 2 )
        convert_to_rgb();
      else
LABEL_10:
        printf("Invalid choice, please try again.\n");
    }
  }
  while ( v4 != 3 );
  return 0;
}
// 1400016B7: using guessed type __int64 display_menu(void);
// 140001702: using guessed type __int64 convert_to_hex(void);
// 14000176C: using guessed type __int64 convert_to_rgb(void);
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>

int main()
{
    FILE *fp;
    char filename[20], ch;
    int count = 0;
    
    printf("Enter the name of file: ");
    scanf("%s", filename);
    
    // open the file
    fp = fopen(filename, "r");
    if(fp == NULL) // if file not found, exit the program
    {
        printf("File not found!\n");
        exit(0);
    }
    
    // read the file character by character and count the number of lines
    while ((ch = fgetc(fp)) != EOF)
    {
        if (ch == '\n')
            count++;
    }
    
    // close the file
    fclose(fp);
    
    printf("The file %s has %d lines.\n", filename, count);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char FileName[31]; // [rsp+20h] [rbp-30h] BYREF
  char v5; // [rsp+3Fh] [rbp-11h]
  FILE *Stream; // [rsp+40h] [rbp-10h]
  unsigned int v7; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 0;
  printf("Enter the name of file: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "r");
  if ( !Stream )
  {
    printf("File not found!\n");
    exit(0);
  }
  while ( 1 )
  {
    v5 = fgetc(Stream);
    if ( v5 == -1 )
      break;
    if ( v5 == 10 )
      ++v7;
  }
  fclose(Stream);
  printf("The file %s has %d lines.\n", FileName, v7);
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to ASCII art generator ; Style: ultraprecise
#include <stdio.h>
#include <string.h>

int main()
{
    char user_input[100];
    printf("Enter a string to convert to ASCII art:\n");
    fgets(user_input, 100, stdin);

    int length = strlen(user_input);
    if (user_input[length - 1] == '\n')
    {
        user_input[length - 1] = '\0';
        length--;
    }

    printf("\nASCII art:\n");

    for (int i = 0; i < length; i++)
    {
        switch (user_input[i])
        {
            case 'A':
                printf("  /\\  \n /  \\ \n/    \\\n/------\\\n");
                break;
            case 'B':
                printf("|------\n|___  \n|   \\ \n|___/ \n");
                break;
            case 'C':
                printf("  /----\n /     \n/___   \n\\    \\ \n \\____\\\n");
                break;
            case 'D':
                printf("|------\\\n|     __)\n|      \\ \n|_____/ \n");
                break;
            case 'E':
                printf(" _____\n|  ___|\n| |__  \n|  __| \n| |___ \n|_____|\n");
                break;
            case 'F':
                printf(" _____\n|  ___|\n| |__  \n|  __| \n| |    \n|_|    \n");
                break;
            case 'G':
                printf("  /----\n /     \n/___   \n\\   __/\n \\_____\\\n");
                break;
            case 'H':
                printf("|\\    /\n| \\  / \n|  \\/  \n|      \n|      \n|      \n");
                break;
            case 'I':
                printf(" _____\n|_   _|\n  | |  \n  | |  \n _| |_ \n|_____|\n");
                break;
            case 'J':
                printf("       /_\n      |_|\n      |_|\n   ___/ \n|_|     \n");
                break;
            case 'K':
                printf("|\\    / \n| \\  /  \n| \\/   \n|      \n|      \n|      \n");
                break;
            case 'L':
                printf("|     \n|     \n|     \n|     \n|___  \n|____|\n");
                break;
            case 'M':
                printf("/\\    /\\\n/  \\  /  \\\n\\/    \\/\n|      |\n|      |\n|      |\n");
                break;
            case 'N':
                printf("|\\    |\n| \\   |\n|  \\  |\n|   \\ |\n|    \\|\n");
                break;
            case 'O':
                printf("  /\\  \n /  \\ \n/    \\\n\\    /\n \\__/ \n");
                break;
            case 'P':
                printf(" _____\n|  __ \\\n| |__) |\n|  ___/\n| |\n|_|\n");
                break;
            case 'Q':
                printf("  /\\  \n /  \\ \n/    \\\n\\  /\\\n \\/_/\\_\n");
                break;
            case 'R':
                printf(" _____\n|  __ \\\n| |__) |\n|  _  /\n| | \\ \\ \n|_|  \\_\\\n");
                break;
            case 'S':
                printf("  ____\n / ___|\n/ /___ \n| ___ \\\n| \\_/ |\n\\____/\n");
                break;
            case 'T':
                printf(" _____\n|_   _|\n  | |  \n  | |  \n  |_|  \n       \n");
                break;
            case 'U':
                printf("|      |\n|      |\n|      |\n|      |\n \\____/ \n");
                break;
            case 'V':
                printf("\\      /\n \\    / \n  \\  /  \n   \\/   \n        \n");
                break;
            case 'W':
                printf("|      |\n|      |\n|  /\\  |\n| /  \\ |\n| \\  / |\n|  \\/  |\n");
                break;
            case 'X':
                printf("\\    /\n \\  / \n  \\/  \n  /\\  \n /  \\ \n/    \\\n");
                break;
            case 'Y':
                printf("\\    /\n \\  / \n  \\/  \n  /    \n /     \n/      \n");
                break;
            case 'Z':
                printf(" _____\n|___ / \n  |_ \\ \n ___) |\n|____/ \n");
                break;
            default:
                printf("   \n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[104]; // [rsp+20h] [rbp-70h] BYREF
  int i; // [rsp+88h] [rbp-8h]
  int v7; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter a string to convert to ASCII art:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  v7 = strlen(Buffer);
  if ( Buffer[v7 - 1] == 10 )
    Buffer[--v7] = 0;
  printf("\nASCII art:\n");
  for ( i = 0; i < v7; ++i )
  {
    switch ( Buffer[i] )
    {
      case 'A':
        printf("  /\\  \n /  \\ \n/    \\\n/------\\\n");
        break;
      case 'B':
        printf("|------\n|___  \n|   \\ \n|___/ \n");
        break;
      case 'C':
        printf("  /----\n /     \n/___   \n\\    \\ \n \\____\\\n");
        break;
      case 'D':
        printf("|------\\\n|     __)\n|      \\ \n|_____/ \n");
        break;
      case 'E':
        printf(" _____\n|  ___|\n| |__  \n|  __| \n| |___ \n|_____|\n");
        break;
      case 'F':
        printf(" _____\n|  ___|\n| |__  \n|  __| \n| |    \n|_|    \n");
        break;
      case 'G':
        printf("  /----\n /     \n/___   \n\\   __/\n \\_____\\\n");
        break;
      case 'H':
        printf("|\\    /\n| \\  / \n|  \\/  \n|      \n|      \n|      \n");
        break;
      case 'I':
        printf(" _____\n|_   _|\n  | |  \n  | |  \n _| |_ \n|_____|\n");
        break;
      case 'J':
        printf("       /_\n      |_|\n      |_|\n   ___/ \n|_|     \n");
        break;
      case 'K':
        printf("|\\    / \n| \\  /  \n| \\/   \n|      \n|      \n|      \n");
        break;
      case 'L':
        printf("|     \n|     \n|     \n|     \n|___  \n|____|\n");
        break;
      case 'M':
        printf("/\\    /\\\n/  \\  /  \\\n\\/    \\/\n|      |\n|      |\n|      |\n");
        break;
      case 'N':
        printf("|\\    |\n| \\   |\n|  \\  |\n|   \\ |\n|    \\|\n");
        break;
      case 'O':
        printf("  /\\  \n /  \\ \n/    \\\n\\    /\n \\__/ \n");
        break;
      case 'P':
        printf(" _____\n|  __ \\\n| |__) |\n|  ___/\n| |\n|_|\n");
        break;
      case 'Q':
        printf("  /\\  \n /  \\ \n/    \\\n\\  /\\\n \\/_/\\_\n");
        break;
      case 'R':
        printf(" _____\n|  __ \\\n| |__) |\n|  _  /\n| | \\ \\ \n|_|  \\_\\\n");
        break;
      case 'S':
        printf("  ____\n / ___|\n/ /___ \n| ___ \\\n| \\_/ |\n\\____/\n");
        break;
      case 'T':
        printf(" _____\n|_   _|\n  | |  \n  | |  \n  |_|  \n       \n");
        break;
      case 'U':
        printf("|      |\n|      |\n|      |\n|      |\n \\____/ \n");
        break;
      case 'V':
        printf("\\      /\n \\    / \n  \\  /  \n   \\/   \n        \n");
        break;
      case 'W':
        printf("|      |\n|      |\n|  /\\  |\n| /  \\ |\n| \\  / |\n|  \\/  |\n");
        break;
      case 'X':
        printf("\\    /\n \\  / \n  \\/  \n  /\\  \n /  \\ \n/    \\\n");
        break;
      case 'Y':
        printf("\\    /\n \\  / \n  \\/  \n  /    \n /     \n/      \n");
        break;
      case 'Z':
        printf(" _____\n|___ / \n  |_ \\ \n ___) |\n|____/ \n");
        break;
      default:
        printf("   \n");
        break;
    }
  }
  return 0;
}
// 140001930: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[104];

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: excited
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main()
{
    int i=0, j=0, k=0, l=0;
    int car_count = 0;
    int cars[10];
    int current_pos = -1;
    int next_pos = 0;
    char sim_grid[4][10];

    srand(time(NULL)); // to get different random values each time

    // Initializing simulation grid for the traffic flow simulation
    for(i=0; i<4; i++)
    {
        for(j=0; j<10; j++)
        {
            sim_grid[i][j] = '-';
        }
    }

    // Creating the initial traffic flow by randomly placing cars on the grid
    for(i=0; i<5; i++)
    {
        current_pos = rand() % 4;
        next_pos = rand() % 10;
        if(sim_grid[current_pos][next_pos] != 'C')
        {
            sim_grid[current_pos][next_pos] = 'C';
            cars[car_count] = current_pos*10 + next_pos; // storing car position as single integer
            car_count++;
        }
        else
        {
            i--; // if position already occupied by a car, try again with new random values
        }
    }

    // Printing the initial traffic flow configuration
    printf("Initial Traffic Flow Configuration\n");
    for(i=0; i<4; i++)
    {
        for(j=0; j<10; j++)
        {
            printf("%c ", sim_grid[i][j]);
        }
        printf("\n");
    }
    printf("\n");

    // Moving the cars on the simulation grid based on traffic rules
    for(k=0; k<30; k++)
    {
        for(l=0; l<car_count; l++)
        {
            current_pos = cars[l] / 10;
            next_pos = cars[l] % 10;
            sim_grid[current_pos][next_pos] = '-'; // emptying the current position

            // Checking traffic rules for moving the car to next position
            if(current_pos == 0 && next_pos == 9)
            {
                sim_grid[3][0] = 'C';
                cars[l] = 30;
            }
            else if(current_pos == 3 && next_pos == 0)
            {
                sim_grid[0][9] = 'C';
                cars[l] = 9;
            }
            else if(next_pos == 9)
            {
                if(sim_grid[current_pos+1][0] != 'C')
                {
                    sim_grid[current_pos+1][0] = 'C';
                    cars[l] = (current_pos+1)*10;
                }
                else
                {
                    sim_grid[current_pos][next_pos] = 'C';
                    cars[l] = current_pos*10 + next_pos;
                }
            }
            else
            {
                if(sim_grid[current_pos][next_pos+1] != 'C')
                {
                    sim_grid[current_pos][next_pos+1] = 'C';
                    cars[l] = current_pos*10 + next_pos+1;
                }
                else
                {
                    sim_grid[current_pos][next_pos] = 'C';
                    cars[l] = current_pos*10 + next_pos;
                }
            }
        }

        // Printing the updated traffic flow configuration
        printf("Traffic Flow Configuration after Step %d\n", k+1);
        for(i=0; i<4; i++)
        {
            for(j=0; j<10; j++)
            {
                printf("%c ", sim_grid[i][j]);
            }
            printf("\n");
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  _WORD v5[4]; // [rsp+20h] [rbp-80h]
  char v6; // [rsp+29h] [rbp-77h]
  char v7; // [rsp+3Eh] [rbp-62h]
  int v8[13]; // [rsp+50h] [rbp-50h]
  int v9; // [rsp+84h] [rbp-1Ch]
  int v10; // [rsp+88h] [rbp-18h]
  int v11; // [rsp+8Ch] [rbp-14h]
  int m; // [rsp+90h] [rbp-10h]
  int k; // [rsp+94h] [rbp-Ch]
  int j; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]
  __int64 savedregs; // [rsp+A0h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  j = 0;
  k = 0;
  m = 0;
  v11 = 0;
  v10 = -1;
  v9 = 0;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 3; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      *((_BYTE *)&savedregs + 10 * i + j - 128) = 45;
  }
  for ( i = 0; i <= 4; ++i )
  {
    v10 = rand() % 4;
    v9 = rand() % 10;
    if ( *((_BYTE *)&savedregs + 10 * v10 + v9 - 128) == 67 )
    {
      --i;
    }
    else
    {
      *((_BYTE *)&savedregs + 10 * v10 + v9 - 128) = 67;
      v8[v11++] = v9 + 10 * v10;
    }
  }
  printf("Initial Traffic Flow Configuration\n");
  for ( i = 0; i <= 3; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      printf("%c ", (unsigned int)*((char *)&savedregs + 10 * i + j - 128));
    printf("\n");
  }
  printf("\n");
  for ( k = 0; k <= 29; ++k )
  {
    for ( m = 0; m < v11; ++m )
    {
      v10 = v8[m] / 10;
      v9 = v8[m] % 10;
      *((_BYTE *)&savedregs + 10 * v10 + v9 - 128) = 45;
      if ( v10 || v9 != 9 )
      {
        if ( v10 != 3 || v9 )
        {
          if ( v9 == 9 )
          {
            if ( LOBYTE(v5[5 * v10 + 5]) == 67 )
            {
              *((_BYTE *)&savedregs + 10 * v10 + v9 - 128) = 67;
              v8[m] = v9 + 10 * v10;
            }
            else
            {
              LOBYTE(v5[5 * v10 + 5]) = 67;
              v8[m] = 10 * (v10 + 1);
            }
          }
          else if ( *((_BYTE *)&savedregs + 10 * v10 + v9 - 127) == 67 )
          {
            *((_BYTE *)&savedregs + 10 * v10 + v9 - 128) = 67;
            v8[m] = v9 + 10 * v10;
          }
          else
          {
            *((_BYTE *)&savedregs + 10 * v10 + v9 - 127) = 67;
            v8[m] = 10 * v10 + v9 + 1;
          }
        }
        else
        {
          v6 = 67;
          v8[m] = 9;
        }
      }
      else
      {
        v7 = 67;
        v8[m] = 30;
      }
    }
    printf("Traffic Flow Configuration after Step %d\n", (unsigned int)(k + 1));
    for ( i = 0; i <= 3; ++i )
    {
      for ( j = 0; j <= 9; ++j )
        printf("%c ", (unsigned int)*((char *)&savedregs + 10 * i + j - 128));
      printf("\n");
    }
    printf("\n");
  }
  return 0;
}
// 140001B70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type int var_50[13];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to ASCII art generator ; Style: Alan Touring
// C Text to ASCII Art Generator
// By [Your Name Here]

#include <stdio.h>
#include <string.h>

#define MAX_INPUT_LENGTH 1000
#define MAX_LINE_LENGTH 100

// Function to print a given character for a specific number of times
void printChar(char c, int n) {
    int i;
    for (i = 0; i < n; i++) {
        printf("%c", c);
    }
}

int main() {
    char input[MAX_INPUT_LENGTH];
    char output[MAX_INPUT_LENGTH * 6];   // Assuming each character can be represented in up to 6 lines of ASCII art
    char line[MAX_LINE_LENGTH];
    int i, j, n;

    // Get input text
    printf("Enter some text: ");
    fgets(input, MAX_INPUT_LENGTH, stdin);

    // Convert to ASCII art
    n = strlen(input);
    for (i = 0, j = 0; i < n; i++, j += 6) {
        switch (input[i]) {
            case 'A':
                sprintf(line, "  /\\  \n /  \\ \n/____\\\n|    |\n|____|\n");
                break;
            case 'B':
                sprintf(line, " ____ \n|    |\n|___ \\\n|    |\n|____|\n");
                break;
            // Add more cases for other letters and characters
            default:
                sprintf(line, "      \n      \n      \n      \n      \n");   // Use blank lines for unrecognized characters
        }
        sprintf(output + j, "%s", line);
    }

    // Print ASCII art
    for (i = 0; i < 6; i++) {
        for (j = 0; j < n * 6; j += 6) {
            printf("%s", output + j + i);
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001616) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v4; // eax
  char v6[6112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[1012]; // [rsp+1800h] [rbp+1780h] BYREF
  int v8; // [rsp+1BF4h] [rbp+1B74h]
  int j; // [rsp+1BF8h] [rbp+1B78h]
  int i; // [rsp+1BFCh] [rbp+1B7Ch]

  _main(argc, argv, envp);
  printf("Enter some text: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v8 = strlen(Buffer);
  i = 0;
  j = 0;
  while ( i < v8 )
  {
    v4 = Buffer[i];
    if ( v4 == 65 )
    {
      sprintf(v6, "  /\\  \n /  \\ \n/____\\\n|    |\n|____|\n");
    }
    else if ( v4 == 66 )
    {
      sprintf(v6, " ____ \n|    |\n|___ \\\n|    |\n|____|\n");
    }
    else
    {
      sprintf(v6, "      \n      \n      \n      \n      \n");
    }
    sprintf(&v6[j + 112], "%s", v6);
    ++i;
    j += 6;
  }
  for ( i = 0; i <= 5; ++i )
  {
    for ( j = 0; j < 6 * v8; j += 6 )
      printf("%s", &v6[i + 112 + (__int64)j]);
    printf("\n");
  }
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001616: using guessed type char Buffer[1012];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Light Controller ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int red = 1, yellow = 0, green = 0;
  int time = 0, duration = 0;
  
  printf("Welcome to the Traffic Light Controller.\n");
  printf("The light is currently RED.\n\n");

  while(1) {
    printf("How long should RED be on for? ");
    scanf("%d", &duration);
    time += duration;
    printf("RED is on for %d seconds.\n", duration);
    printf("Yellow will be on for 3 seconds.\n");
    printf("Green will be on for 10 seconds.\n");

    red = 0;
    yellow = 1;
    green = 0;

    printf("\nYELLOW\n");
    printf("Remaining time: %d seconds.\n", 3 - time);
    while(time < 3) {
      time++;
      sleep(1);
      printf("Remaining time: %d seconds.\n", 3 - time);
    }

    red = 0;
    yellow = 0;
    green = 1;
    time = 0;

    printf("\nGREEN\n");
    printf("Remaining time: %d seconds.\n", 10 - time);
    while(time < 10) {
      time++;
      sleep(1);
      printf("Remaining time: %d seconds.\n", 10 - time);
    }

    red = 1;
    yellow = 0;
    green = 0;
    time = 0;

    printf("\nRED\n");
    printf("Remaining time: %d seconds.\n", duration - time);
    while(time < duration) {
      time++;
      sleep(1);
      printf("Remaining time: %d seconds.\n", duration - time);
    }
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-14h] BYREF
  int v5; // [rsp+30h] [rbp-10h]
  int v6; // [rsp+34h] [rbp-Ch]
  int v7; // [rsp+38h] [rbp-8h]
  int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 1;
  v6 = 0;
  v5 = 0;
  v8 = 0;
  v4 = 0;
  printf("Welcome to the Traffic Light Controller.\n");
  printf("The light is currently RED.\n\n");
  while ( 1 )
  {
    printf("How long should RED be on for? ");
    scanf("%d", &v4);
    v8 += v4;
    printf("RED is on for %d seconds.\n", v4);
    printf("Yellow will be on for 3 seconds.\n");
    printf("Green will be on for 10 seconds.\n");
    v7 = 0;
    v6 = 1;
    v5 = 0;
    printf("\nYELLOW\n");
    printf("Remaining time: %d seconds.\n", (unsigned int)(3 - v8));
    while ( v8 <= 2 )
    {
      ++v8;
      sleep(1i64);
      printf("Remaining time: %d seconds.\n", (unsigned int)(3 - v8));
    }
    v7 = 0;
    v6 = 0;
    v5 = 1;
    v8 = 0;
    printf("\nGREEN\n");
    printf("Remaining time: %d seconds.\n", (unsigned int)(10 - v8));
    while ( v8 <= 9 )
    {
      ++v8;
      sleep(1i64);
      printf("Remaining time: %d seconds.\n", (unsigned int)(10 - v8));
    }
    v7 = 1;
    v6 = 0;
    v5 = 0;
    v8 = 0;
    printf("\nRED\n");
    printf("Remaining time: %d seconds.\n", v4 - v8);
    while ( v8 < (int)v4 )
    {
      ++v8;
      sleep(1i64);
      printf("Remaining time: %d seconds.\n", v4 - v8);
    }
  }
}
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002900: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Frequency Counter ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50 // Maximum word length
#define MAX_WORDS 1000 // Maximum number of words

char *words[MAX_WORDS]; // Array of strings to store words
int frequencies[MAX_WORDS]; // Array to store frequency of each word
int curr_index = 0; // Index into the words array

// Function to add word to arrays or increment frequency if already present
void add_word(char *word) {
    int i, is_new_word = 1;
    for (i = 0; i < curr_index; i++) {
        if (strcmp(word, words[i]) == 0) {
            frequencies[i]++;
            is_new_word = 0;
            break;
        }
    }
    if (is_new_word) {
        words[curr_index] = malloc(MAX_WORD_LENGTH * sizeof(char));
        strcpy(words[curr_index], word);
        frequencies[curr_index++] = 1;
    }
}

// Function to read input file and retrieve words
void read_file(char *filename) {
    FILE *fp = fopen(filename, "r");
    if (fp == NULL) {
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }
    char curr_word[MAX_WORD_LENGTH];
    int i, j, len;
    while (fscanf(fp, "%s", curr_word) != EOF) {
        // Convert word to lowercase
        len = strlen(curr_word);
        for (i = 0; i < len; i++) {
            curr_word[i] = tolower(curr_word[i]);
        }
        // Remove punctuation
        for (i = 0, j = 0; curr_word[i] != '\0'; i++) {
            if (isalpha(curr_word[i])) {
                curr_word[j++] = curr_word[i];
            }
        }
        curr_word[j] = '\0';
        // Add word to arrays
        if (strlen(curr_word) > 0) {
            add_word(curr_word);
        }
    }
    fclose(fp);
}

// Function to print word frequency table
void print_table() {
    printf("Word\tFrequency\n");
    int i;
    for (i = 0; i < curr_index; i++) {
        printf("%s\t%d\n", words[i], frequencies[i]);
    }
}

int main() {
    char filename[MAX_WORD_LENGTH];
    printf("Enter filename: ");
    scanf("%s", filename);
    read_file(filename);
    print_table();
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall read_file(_QWORD); // weak
__int64 print_table(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000194A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[64]; // [rsp+20h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  printf("Enter filename: ");
  scanf("%s", v4);
  read_file(v4);
  print_table();
  return 0;
}
// 14000177D: using guessed type __int64 __fastcall read_file(_QWORD);
// 1400018CF: using guessed type __int64 print_table(void);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_SIZE 100

void initializeBoard(int board[MAX_SIZE][MAX_SIZE], int size);
void shuffle(int arr[MAX_SIZE], int size);
void printBoard(int board[MAX_SIZE][MAX_SIZE], int size);
int getPair(int board[MAX_SIZE][MAX_SIZE], int size, int r, int c);
int getRow();
int getColumn();

int main()
{
    int size, row, col, firstRow, firstCol, secondRow, secondCol, pairs = 0;
    int board[MAX_SIZE][MAX_SIZE];
    
    printf("Enter board size (even number between 4 and 100): ");
    scanf("%d", &size);
    
    // Validate input
    while (size < 4 || size > MAX_SIZE || size % 2 != 0) {
        printf("Invalid size! Please enter an even number between 4 and 100: ");
        scanf("%d", &size);
    }
    
    initializeBoard(board, size);
    shuffle(board[0], size * size);
    
    printf("Let's play the Memory game!\n\n");
    printBoard(board, size);
    
    while (pairs < (size * size) / 2) {
        printf("Enter first card location (row, column): ");
        firstRow = getRow();
        firstCol = getColumn();
        
        while (board[firstRow][firstCol] == -1) {
            printf("This card is already matched! Enter a different location.\n");
            printf("Enter first card location (row, column): ");
            firstRow = getRow();
            firstCol = getColumn();
        }
        
        board[firstRow][firstCol] = -1;
        printBoard(board, size);
        
        printf("Enter second card location (row, column): ");
        secondRow = getRow();
        secondCol = getColumn();
        
        while (board[secondRow][secondCol] == -1 || (firstRow == secondRow && firstCol == secondCol)) {
            if (board[secondRow][secondCol] == -1) {
                printf("This card is already matched! Enter a different location.\n");
            } else {
                printf("Can't choose the same location! Enter a different location.\n");
            }
            
            printf("Enter second card location (row, column): ");
            secondRow = getRow();
            secondCol = getColumn();
        }
        
        if (getPair(board, size, firstRow, firstCol) == getPair(board, size, secondRow, secondCol)) {
            printf("Congratulations! You found a pair.\n");
            board[secondRow][secondCol] = -1;
            pairs++;
        } else {
            printf("Sorry! Cards do not match.\n");
            board[firstRow][firstCol] = getPair(board, size, firstRow, firstCol);
        }
        
        printBoard(board, size);
    }
    
    printf("Great job! You won the game in %d moves.", pairs * 2);
    
    return 0;
}

void initializeBoard(int board[MAX_SIZE][MAX_SIZE], int size)
{
    int i, j, k = 0;
    
    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            board[i][j] = k / 2;
            k++;
        }
    }
}

void shuffle(int arr[MAX_SIZE], int size)
{
    int i, j, temp;
    srand(time(NULL));
    
    for (i = size - 1; i > 0; i--) {
        j = rand() % (i + 1);
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

void printBoard(int board[MAX_SIZE][MAX_SIZE], int size)
{
    int i, j;
    
    printf("\n    ");
    for (i = 0; i < size; i++) {
        printf("%-3d", i);
    }
    printf("\n   ");
    for (i = 0; i < size; i++) {
        printf("---");
    }
    printf("\n");
    
    for (i = 0; i < size; i++) {
        printf("%-2d |", i);
        for (j = 0; j < size; j++) {
            if (board[i][j] == -1) {
                printf(" X ");
            } else {
                printf(" - ");
            }
        }
        printf("| %d\n", i);
    }
    
    printf("   ");
    for (i = 0; i < size; i++) {
        printf("---");
    }
    printf("\n    ");
    for (i = 0; i < size; i++) {
        printf("%-3d", i);
    }
    printf("\n");
}

int getPair(int board[MAX_SIZE][MAX_SIZE], int size, int r, int c)
{
    int i, j;
    
    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            if (i != r || j != c) {
                if (board[i][j] == board[r][c]) {
                    return board[i][j];
                }
            }
        }
    }
    
    return -1;
}

int getRow()
{
    int row;
    
    printf("Enter row (0-99): ");
    scanf("%d", &row);
    
    // Validate input
    while (row < 0 || row > 99) {
        printf("Invalid row! Please enter a number between 0 and 99: ");
        scanf("%d", &row);
    }
    
    return row;
}

int getColumn()
{
    int col;
    
    printf("Enter column (0-99): ");
    scanf("%d", &col);
    
    // Validate input
    while (col < 0 || col > 99) {
        printf("Invalid column! Please enter a number between 0 and 99: ");
        scanf("%d", &col);
    }
    
    return col;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall initializeBoard(_QWORD, _QWORD); // weak
__int64 __fastcall shuffle(_QWORD, _QWORD); // weak
__int64 __fastcall printBoard(_QWORD, _QWORD); // weak
__int64 __fastcall getPair(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 getRow(void); // weak
__int64 getColumn(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int Pair; // ebx
  int v4; // eax
  int v6[10002]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v7; // [rsp+9C68h] [rbp+9BE8h] BYREF
  int v8; // [rsp+9C6Ch] [rbp+9BECh]
  unsigned int j; // [rsp+9C70h] [rbp+9BF0h]
  unsigned int v10; // [rsp+9C74h] [rbp+9BF4h]
  unsigned int i; // [rsp+9C78h] [rbp+9BF8h]
  unsigned int Row; // [rsp+9C7Ch] [rbp+9BFCh]

  _main(argc, argv, envp);
  v8 = 0;
  printf("Enter board size (even number between 4 and 100): ");
  scanf("%d", &v7);
  while ( (int)v7 <= 3 || (int)v7 > 100 || (v7 & 1) != 0 )
  {
    printf("Invalid size! Please enter an even number between 4 and 100: ");
    scanf("%d", &v7);
  }
  initializeBoard(v6, v7);
  shuffle(v6, v7 * v7);
  printf("Let's play the Memory game!\n\n");
  printBoard(v6, v7);
  while ( v8 < (int)(v7 * v7) / 2 )
  {
    printf("Enter first card location (row, column): ");
    Row = getRow();
    for ( i = getColumn(); v6[100 * Row + i] == -1; i = getColumn() )
    {
      printf("This card is already matched! Enter a different location.\n");
      printf("Enter first card location (row, column): ");
      Row = getRow();
    }
    v6[100 * Row + i] = -1;
    printBoard(v6, v7);
    printf("Enter second card location (row, column): ");
    v10 = getRow();
    for ( j = getColumn(); v6[100 * v10 + j] == -1 || Row == v10 && i == j; j = getColumn() )
    {
      if ( v6[100 * v10 + j] == -1 )
        printf("This card is already matched! Enter a different location.\n");
      else
        printf("Can't choose the same location! Enter a different location.\n");
      printf("Enter second card location (row, column): ");
      v10 = getRow();
    }
    Pair = getPair(v6, v7, Row, i);
    if ( Pair == (unsigned int)getPair(v6, v7, v10, j) )
    {
      printf("Congratulations! You found a pair.\n");
      v6[100 * v10 + j] = -1;
      ++v8;
    }
    else
    {
      printf("Sorry! Cards do not match.\n");
      v4 = getPair(v6, v7, Row, i);
      v6[100 * Row + i] = v4;
    }
    printBoard(v6, v7);
  }
  printf("Great job! You won the game in %d moves.", (unsigned int)(2 * v8));
  return 0;
}
// 140001A2B: using guessed type __int64 __fastcall initializeBoard(_QWORD, _QWORD);
// 140001AB6: using guessed type __int64 __fastcall shuffle(_QWORD, _QWORD);
// 140001B63: using guessed type __int64 __fastcall printBoard(_QWORD, _QWORD);
// 140001D1C: using guessed type __int64 __fastcall getPair(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001E23: using guessed type __int64 getRow(void);
// 140001E8F: using guessed type __int64 getColumn(void);
// 140001FB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001601: using guessed type int var_9C70[10002];

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Hotel Management System ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_ROOMS 100
#define MAX_OCCUPANTS 2

// Struct for Room Information
struct Room{
    int room_num;
    bool is_occupied;
    char occupants[MAX_OCCUPANTS][30];
    char room_type[20];
    int room_rate;
    char check_in_date[30];
    char check_out_date[30];
};

// Function Declaration
void display_menu();
void view_rooms(struct Room *rooms);
void book_room(struct Room *rooms);
void view_occupants(struct Room *rooms);
void checkout(struct Room *rooms);

int main(){
    // Initializing Rooms
    struct Room rooms[MAX_ROOMS];
    for(int i=0; i<MAX_ROOMS; i++){
        rooms[i].room_num = i+1;
        rooms[i].is_occupied = false;
        strcpy(rooms[i].room_type, "Basic");
        rooms[i].room_rate = 50;
        strcpy(rooms[i].check_in_date, "");
        strcpy(rooms[i].check_out_date, "");
    }

    // Welcome Message
    printf("Welcome to the C Hotel Management System! \n");
    display_menu(); // Display Menu

    int choice = 0;
    while(choice != 5){ // Exit Condition
        // Prompt User for Choice
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch(choice){
            case 1: view_rooms(rooms); break;
            case 2: book_room(rooms); break;
            case 3: view_occupants(rooms); break;
            case 4: checkout(rooms); break;
            case 5: printf("Exiting Program! "); break;
            default: printf("Invalid Choice! "); break;
        }

        if(choice != 5){
            // Reload Menu
            printf("\n\n");
            display_menu();
        }
    }

    return 0;
}

void display_menu(){
    printf("===== MENU =====\n");
    printf("1. View Rooms\n");
    printf("2. Book Room\n");
    printf("3. View Occupants\n");
    printf("4. Check-Out\n");
    printf("5. Exit\n");
}

void view_rooms(struct Room *rooms){
    printf("===== ROOMS =====\n");
    printf("Room No.\tType\tRate\tStatus\n");

    for(int i=0; i<MAX_ROOMS; i++){
        printf("%d\t\t%s\t$%d\t", rooms[i].room_num, rooms[i].room_type, rooms[i].room_rate);
        if(rooms[i].is_occupied == true){
            printf("Occupied");
            printf("\tOccupants: %s", rooms[i].occupants[0]);
            if(strcmp(rooms[i].occupants[1], "") != 0){
                printf(", %s", rooms[i].occupants[1]);
            }
            printf(", Check-In: %s", rooms[i].check_in_date);
            printf(", Check-Out: %s", rooms[i].check_out_date);
        }else{
            printf("Available");
        }
        printf("\n");
    }
}

void book_room(struct Room *rooms){
    printf("===== BOOK ROOM =====\n\n");
    printf("Enter Room No.: ");
    int room_no;
    scanf("%d", &room_no);

    // Check if Room Exists
    if(room_no < 1 || room_no > MAX_ROOMS){
        printf("Invalid Room No.! ");
        return;
    }

    // Check if Room is Available
    if(rooms[room_no-1].is_occupied == true){
        printf("Room already occupied! ");
        return;
    }

    // Get User Input
    char occupants[MAX_OCCUPANTS][30];
    printf("\nEnter Name of Occupant 1: ");
    scanf(" %[^\n]s", occupants[0]);
    printf("Enter Name of Occupant 2 (Optional, press enter to skip): ");
    scanf(" %[^\n]s", occupants[1]);
    char check_in_date[30];
    char check_out_date[30];
    printf("Enter Check-In Date (DD/MM/YYYY): ");
    scanf(" %[^\n]s", check_in_date);
    printf("Enter Check-Out Date (DD/MM/YYYY): ");
    scanf(" %[^\n]s", check_out_date);

    // Update Room Information
    rooms[room_no-1].is_occupied = true;
    strcpy(rooms[room_no-1].occupants[0], occupants[0]);
    if(strcmp(occupants[1], "") != 0){
        strcpy(rooms[room_no-1].occupants[1], occupants[1]);
    }
    strcpy(rooms[room_no-1].check_in_date, check_in_date);
    strcpy(rooms[room_no-1].check_out_date, check_out_date);

    printf("\n\nRoom %d has been booked! \n", room_no);
}

void view_occupants(struct Room *rooms){
    printf("===== OCCUPANTS =====\n\n");

    // Check if any Rooms are Occupied
    bool is_occupied = false;
    for(int i=0; i<MAX_ROOMS; i++){
        if(rooms[i].is_occupied == true){
            is_occupied = true;
            break;
        }
    }

    if(is_occupied == false){
        printf("No Rooms are Occupied! ");
        return;
    }

    // Get User Input
    printf("Enter Room No.: ");
    int room_no;
    scanf("%d", &room_no);

    // Check if Room Exists and is Occupied
    if(room_no < 1 || room_no > MAX_ROOMS){
        printf("Invalid Room No.! ");
        return;
    }else{
        if(rooms[room_no-1].is_occupied == false){
            printf("Room is not Occupied! ");
            return;
        }
    }

    printf("\nOccupants of Room %d: %s", room_no, rooms[room_no-1].occupants[0]);
    if(strcmp(rooms[room_no-1].occupants[1], "") != 0){
        printf(", %s", rooms[room_no-1].occupants[1]);
    }
    printf("\n");
}

void checkout(struct Room *rooms){
    printf("===== CHECK-OUT =====\n\n");

    // Check if any Rooms are Occupied
    bool is_occupied = false;
    for(int i=0; i<MAX_ROOMS; i++){
        if(rooms[i].is_occupied == true){
            is_occupied = true;
            break;
        }
    }

    if(is_occupied == false){
        printf("No Rooms are Occupied! ");
        return;
    }

    // Get User Input
    printf("Enter Room No.: ");
    int room_no;
    scanf("%d", &room_no);

    // Check if Room Exists and is Occupied
    if(room_no < 1 || room_no > MAX_ROOMS){
        printf("Invalid Room No.! ");
        return;
    }else{
        if(rooms[room_no-1].is_occupied == false){
            printf("Room is not Occupied! ");
            return;
        }
    }

    // Calculate Bill
    int rate = rooms[room_no-1].room_rate;
    char check_in_date[30];
    strcpy(check_in_date, rooms[room_no-1].check_in_date);
    char check_out_date[30];
    strcpy(check_out_date, rooms[room_no-1].check_out_date);
    int check_in_day, check_in_month, check_in_year;
    sscanf(check_in_date, "%d/%d/%d", &check_in_day, &check_in_month, &check_in_year);
    int check_out_day, check_out_month, check_out_year;
    sscanf(check_out_date, "%d/%d/%d", &check_out_day, &check_out_month, &check_out_year);
    int days_stayed = (check_out_year - check_in_year)*365 + (check_out_month - check_in_month)*30 + (check_out_day - check_in_day);
    int total_bill = rate*days_stayed;

    printf("\nTotal Bill: $%d", total_bill);

    // Update Room Information
    rooms[room_no-1].is_occupied = false;
    strcpy(rooms[room_no-1].occupants[0], "");
    strcpy(rooms[room_no-1].occupants[1], "");
    strcpy(rooms[room_no-1].check_in_date, "");
    strcpy(rooms[room_no-1].check_out_date, "");

    printf("\n\nCheck-Out of Room %d completed! \n", room_no);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 display_menu(void); // weak
__int64 __fastcall view_rooms(_QWORD); // weak
__int64 __fastcall book_room(_QWORD); // weak
__int64 __fastcall view_occupants(_QWORD); // weak
__int64 __fastcall checkout(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-54h] BYREF
  char v5[80]; // [rsp+30h] [rbp-50h] BYREF
  _BYTE v6[15132]; // [rsp+80h] [rbp+0h] BYREF
  int i; // [rsp+3B9Ch] [rbp+3B1Ch]

  _main(argc, argv, envp);
  for ( i = 0; i <= 99; ++i )
  {
    *(_DWORD *)&v6[152 * i - 80] = i + 1;
    v6[152 * i - 76] = 0;
    strcpy(&v5[152 * i + 65], "Basic");
    *(_DWORD *)&v6[152 * i + 8] = 50;
    v6[152 * i + 12] = 0;
    v5[152 * i + 122] = 0;
  }
  printf("Welcome to the C Hotel Management System! \n");
  display_menu();
  v4 = 0;
  while ( v4 != 5 )
  {
    printf("\nEnter your choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        view_rooms(v5);
        break;
      case 2:
        book_room(v5);
        break;
      case 3:
        view_occupants(v5);
        break;
      case 4:
        checkout(v5);
        break;
      case 5:
        printf("Exiting Program! ");
        break;
      default:
        printf("Invalid Choice! ");
        break;
    }
    if ( v4 != 5 )
    {
      printf("\n\n");
      display_menu();
    }
  }
  return 0;
}
// 140001892: using guessed type __int64 display_menu(void);
// 1400018FB: using guessed type __int64 __fastcall view_rooms(_QWORD);
// 140001B49: using guessed type __int64 __fastcall book_room(_QWORD);
// 140001DC4: using guessed type __int64 __fastcall view_occupants(_QWORD);
// 140001FA3: using guessed type __int64 __fastcall checkout(_QWORD);
// 1400023B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Intrusion detection system ; Style: Romeo and Juliet
/* A Romeo and Juliet-themed Intrusion Detection System */

#include <stdio.h>
#include <string.h>

int main()
{
    char message[100];
    int i, flag = 0;

    printf("Oh Romeo, Romeo, wherefore art thou Romeo?\n");

    scanf("%s", message);

    printf("It is the east, and Juliet is the sun.\n");

    for(i = 0; i < strlen(message); i++)
    {
        if(message[i] == 'e')
        {
            flag = 1;
        }
    }

    if(flag == 1)
    {
        printf("Aha! An intrusion attempt has been detected.\n");
    }
    else
    {
        printf("No intrusion attempt detected.\n");
    }

    printf("Goodnight, goodnight! Parting is such sweet sorrow, That I shall say good night till it be morrow.\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[104]; // [rsp+20h] [rbp-70h] BYREF
  int v5; // [rsp+88h] [rbp-8h]
  int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5 = 0;
  printf("Oh Romeo, Romeo, wherefore art thou Romeo?\n");
  scanf("%s", Str);
  printf("It is the east, and Juliet is the sun.\n");
  for ( i = 0; i < strlen(Str); ++i )
  {
    if ( Str[i] == 101 )
      v5 = 1;
  }
  if ( v5 == 1 )
    printf("Aha! An intrusion attempt has been detected.\n");
  else
    printf("No intrusion attempt detected.\n");
  printf("Goodnight, goodnight! Parting is such sweet sorrow, That I shall say good night till it be morrow.\n");
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[104];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: grateful
#include <stdio.h>

// Function to implement binary search
int binarySearch(int arr[], int l, int r, int x) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
 
        // If the element is present at the middle itself
        if (arr[mid] == x)
            return mid;
 
        // If element is smaller than mid, then it can only
        // be present in left subarray
        if (arr[mid] > x)
            return binarySearch(arr, l, mid - 1, x);
 
        // Else the element can only be present in right subarray
        return binarySearch(arr, mid + 1, r, x);
    }
 
    // We reach here when element is not present in array
    return -1;
}

// Main function
int main() {
    int arr[] = { 2, 3, 4, 10, 40 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    
    // Perform binary search
    int result = binarySearch(arr, 0, n - 1, x);
    
    // Print result
    if (result == -1) {
        printf("The element was not found in the array.\n");
    } else {
        printf("The element was found at index %d in the array.\n", result);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001651) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[5]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v5; // [rsp+34h] [rbp-Ch]
  int v6; // [rsp+38h] [rbp-8h]
  int v7; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 2;
  v4[1] = 3;
  v4[2] = 4;
  v4[3] = 10;
  v4[4] = 40;
  v7 = 5;
  v6 = 10;
  v5 = ((__int64 (__fastcall *)(int *, _QWORD, __int64, __int64))binarySearch)(v4, 0i64, 4i64, 10i64);
  if ( v5 == -1 )
    printf("The element was not found in the array.\n");
  else
    printf("The element was found at index %d in the array.\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: energetic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define constants for maximum size of XML tags and attributes
#define MAX_TAG_SIZE 50
#define MAX_ATTR_SIZE 50

// Define a struct to hold information about a single XML tag
typedef struct {
  char name[MAX_TAG_SIZE];
  char attributes[MAX_ATTR_SIZE][2][MAX_ATTR_SIZE];
  int num_attributes;
  char value[MAX_TAG_SIZE];
} xml_tag;

// Function to parse an XML tag and extract its information
xml_tag parse_tag(char* tag) {
  xml_tag parsed;
  parsed.num_attributes = 0;
  char* token = strtok(tag, " ");
  strcpy(parsed.name, token);
  token = strtok(NULL, "\"");
  while (token != NULL) {
    strcpy(parsed.attributes[parsed.num_attributes][0], token);
    token = strtok(NULL, "\"");
    strcpy(parsed.attributes[parsed.num_attributes][1], token);
    parsed.num_attributes++;
    token = strtok(NULL, "\"");
  }
  return parsed;
}

int main() {
  // Example XML document to parse
  char* document = "<note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>";

  // Parse the document and extract the tags and their information
  xml_tag tags[10];
  int num_tags = 0;
  char* token = strtok(document, "<>");
  while (token != NULL) {
    if (token[0] != '/') {
      tags[num_tags] = parse_tag(token);
      num_tags++;
    }
    token = strtok(NULL, "<>");
  }

  // Print out the extracted information for each tag
  for (int i = 0; i < num_tags; i++) {
    printf("Tag name: %s\n", tags[i].name);
    printf("Tag value: %s\n", tags[i].value);
    printf("Tag attributes:\n");
    for (int j = 0; j < tags[i].num_attributes; j++) {
      printf("%s: %s\n", tags[i].attributes[j][0], tags[i].attributes[j][1]);
    }
    printf("\n");
  }

  // Exit the program
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall parse_tag(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);


//----- (0000000140001751) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _QWORD *v3; // rbx
  _QWORD v5[12]; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v6[56112]; // [rsp+80h] [rbp+0h] BYREF
  char *String; // [rsp+DBB0h] [rbp+DB30h]
  int k; // [rsp+DBB8h] [rbp+DB38h]
  int j; // [rsp+DBBCh] [rbp+DB3Ch]
  char *i; // [rsp+DBC0h] [rbp+DB40h]
  int v11; // [rsp+DBCCh] [rbp+DB4Ch]

  _main(argc, argv, envp);
  String = "<note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>";
  v11 = 0;
  for ( i = strtok(
              "<note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>",
              "<>"); i; i = strtok(0i64, "<>") )
  {
    if ( *i != 47 )
    {
      v3 = &v6[5108 * v11 + 5024];
      parse_tag(v5, i);
      *v3 = v5[0];
      *(_QWORD *)((char *)v3 + 5100) = *(_QWORD *)&v6[5004];
      qmemcpy(
        (void *)((unsigned __int64)(v3 + 1) & 0xFFFFFFFFFFFFFFF8ui64),
        (const void *)((char *)v5 - ((char *)v3 - ((unsigned __int64)(v3 + 1) & 0xFFFFFFFFFFFFFFF8ui64))),
        8i64 * ((((_DWORD)v3 - (((_DWORD)v3 + 8) & 0xFFFFFFF8) + 5108) & 0xFFFFFFF8) >> 3));
      ++v11;
    }
  }
  for ( j = 0; j < v11; ++j )
  {
    printf("Tag name: %s\n", &v6[5108 * j + 5024]);
    printf("Tag value: %s\n", &v6[5108 * j + 10080]);
    printf("Tag attributes:\n");
    for ( k = 0; k < *(_DWORD *)&v6[5108 * j + 10076]; ++k )
      printf("%s: %s\n", &v6[5108 * j + 5074 + 100 * k], &v6[5108 * j + 5124 + 100 * k]);
    printf("\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall parse_tag(_QWORD, _QWORD);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001751: using guessed type _QWORD var_DBD0[12];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Log analysis ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 1000
#define MAX_NUM_LINES 100000
#define MAX_NUM_LOG_TYPES 100

typedef struct{
    char* name;
    int count;
}LogType;

int main(){
    char* filename = "sample_log_file.txt";
    FILE* file_pointer = fopen(filename, "r");
    if(!file_pointer){
        printf("Error opening file: %s\n", filename);
        exit(1);
    }

    char* line_buffer = malloc(MAX_LINE_LENGTH * sizeof(char));
    if(!line_buffer){
        printf("Error: failed to allocate memory for line buffer.\n");
        exit(1);
    }

    char** log_lines = malloc(MAX_NUM_LINES * sizeof(char*));
    if(!log_lines){
        printf("Error: failed to allocate memory for log lines.\n");
        exit(1);
    }

    int num_lines = 0;
    while(fgets(line_buffer, MAX_LINE_LENGTH, file_pointer)){
        log_lines[num_lines] = malloc(MAX_LINE_LENGTH * sizeof(char));
        if(!log_lines[num_lines]){
            printf("Error: failed to allocate memory for log line %d.\n", num_lines);
            exit(1);
        }
        strncpy(log_lines[num_lines], line_buffer, MAX_LINE_LENGTH);
        num_lines++;
    }

    fclose(file_pointer);
    free(line_buffer);

    LogType* log_types = malloc(MAX_NUM_LOG_TYPES * sizeof(LogType));
    if(!log_types){
        printf("Error: failed to allocate memory for log types.\n");
        exit(1);
    }

    int num_log_types = 0;
    for(int i = 0; i < num_lines; i++){
        char* type_start = strchr(log_lines[i], '[');
        if(!type_start){
            continue;
        }
        type_start++;

        char* type_end = strchr(type_start, ']');
        if(!type_end){
            continue;
        }

        int type_length = type_end - type_start;
        char* type_copy = malloc(type_length * sizeof(char));
        if(!type_copy){
            printf("Error: failed to allocate memory for log type copy.\n");
            exit(1);
        }
        strncpy(type_copy, type_start, type_length);

        int type_found = 0;
        for(int j = 0; j < num_log_types; j++){
            if(strcmp(log_types[j].name, type_copy) == 0){
                log_types[j].count++;
                type_found = 1;
                break;
            }
        }
        if(!type_found){
            log_types[num_log_types].name = type_copy;
            log_types[num_log_types].count = 1;
            num_log_types++;
        }
    }

    for(int i = 0; i < num_log_types; i++){
        printf("%s: %d\n", log_types[i].name, log_types[i].count);
        free(log_types[i].name);
    }
    free(log_types);
    for(int i = 0; i < num_lines; i++){
        free(log_lines[i]);
    }
    free(log_lines);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl strchr(const char *Str, int Val);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *Destination; // [rsp+28h] [rbp-68h]
  char *v5; // [rsp+38h] [rbp-58h]
  char *Str; // [rsp+40h] [rbp-50h]
  char *Stra; // [rsp+40h] [rbp-50h]
  _DWORD *Block; // [rsp+48h] [rbp-48h]
  _QWORD *v9; // [rsp+50h] [rbp-40h]
  char *Source; // [rsp+58h] [rbp-38h]
  FILE *Stream; // [rsp+60h] [rbp-30h]
  int m; // [rsp+74h] [rbp-1Ch]
  int k; // [rsp+78h] [rbp-18h]
  int j; // [rsp+7Ch] [rbp-14h]
  int v15; // [rsp+80h] [rbp-10h]
  int i; // [rsp+84h] [rbp-Ch]
  int v17; // [rsp+88h] [rbp-8h]
  signed int v18; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  Stream = fopen("sample_log_file.txt", "r");
  if ( !Stream )
  {
    printf("Error opening file: %s\n", "sample_log_file.txt");
    exit(1);
  }
  Source = (char *)malloc(0x3E8ui64);
  if ( !Source )
  {
    printf("Error: failed to allocate memory for line buffer.\n");
    exit(1);
  }
  v9 = malloc(0xC3500ui64);
  if ( !v9 )
  {
    printf("Error: failed to allocate memory for log lines.\n");
    exit(1);
  }
  v18 = 0;
  while ( fgets(Source, 1000, Stream) )
  {
    v9[v18] = malloc(0x3E8ui64);
    if ( !v9[v18] )
    {
      printf("Error: failed to allocate memory for log line %d.\n", (unsigned int)v18);
      exit(1);
    }
    strncpy((char *)v9[v18++], Source, 0x3E8ui64);
  }
  fclose(Stream);
  free(Source);
  Block = malloc(0x640ui64);
  if ( !Block )
  {
    printf("Error: failed to allocate memory for log types.\n");
    exit(1);
  }
  v17 = 0;
  for ( i = 0; i < v18; ++i )
  {
    Str = strchr((const char *)v9[i], 91);
    if ( Str )
    {
      Stra = Str + 1;
      v5 = strchr(Stra, 93);
      if ( v5 )
      {
        Destination = (char *)malloc((int)v5 - (int)Stra);
        if ( !Destination )
        {
          printf("Error: failed to allocate memory for log type copy.\n");
          exit(1);
        }
        strncpy(Destination, Stra, (int)v5 - (int)Stra);
        v15 = 0;
        for ( j = 0; j < v17; ++j )
        {
          if ( !strcmp(*(const char **)&Block[4 * j], Destination) )
          {
            ++Block[4 * j + 2];
            v15 = 1;
            break;
          }
        }
        if ( !v15 )
        {
          *(_QWORD *)&Block[4 * v17] = Destination;
          Block[4 * v17++ + 2] = 1;
        }
      }
    }
  }
  for ( k = 0; k < v17; ++k )
  {
    printf("%s: %d\n", *(const char **)&Block[4 * k], (unsigned int)Block[4 * k + 2]);
    free(*(void **)&Block[4 * k]);
  }
  free(Block);
  for ( m = 0; m < v18; ++m )
    free((void *)v9[m]);
  free(v9);
  return 0;
}
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Classification system ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

// Size variables
#define NUM_FEATURES 784
#define NUM_LABELS 10
#define TRAIN_SIZE 60000
#define TEST_SIZE 10000
#define BATCH_SIZE 128
#define EPOCHS 10

// Function to read in data from files
void readData(FILE* fp, float data[NUM_FEATURES][TRAIN_SIZE], int labels[TRAIN_SIZE]) {
    // Read each line of data
    for (int i = 0; i < TRAIN_SIZE; i++) {
        // Read in label and pixel values
        fscanf(fp, "%d", &labels[i]);
        for (int j = 0; j < NUM_FEATURES; j++) {
            fscanf(fp, ",%f", &data[j][i]);
        }
    }
}

// Function to softmax a given array
void softmax(float arr[NUM_LABELS]) {
    float max = arr[0];
    for (int i = 1; i < NUM_LABELS; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    float sum = 0;
    for (int i = 0; i < NUM_LABELS; i++) {
        arr[i] = expf(arr[i] - max);
        sum += arr[i];
    }

    for (int i = 0; i < NUM_LABELS; i++) {
        arr[i] /= sum;
    }
}

int main() {
    // Open files for reading
    FILE* fp_train_data = fopen("train_data.csv", "r");
    FILE* fp_train_labels = fopen("train_labels.csv", "r");
    FILE* fp_test_data = fopen("test_data.csv", "r");
    FILE* fp_test_labels = fopen("test_labels.csv", "r");

    // Read in data from files
    float train_data[NUM_FEATURES][TRAIN_SIZE];
    int train_labels[TRAIN_SIZE];
    float test_data[NUM_FEATURES][TEST_SIZE];
    int test_labels[TEST_SIZE];
    readData(fp_train_data, train_data, train_labels);
    readData(fp_test_data, test_data, test_labels);

    // Initialize weights and bias
    float weights[NUM_LABELS][NUM_FEATURES] = {};
    float bias[NUM_LABELS] = {};

    // Train the model
    for (int epoch = 0; epoch < EPOCHS; epoch++) {
        // Shuffle the training data
        for (int i = 0; i < TRAIN_SIZE; i++) {
            int j = rand() % TRAIN_SIZE;
            float tmp[NUM_FEATURES];
            memcpy(tmp, train_data[j], sizeof(tmp));
            memcpy(train_data[j], train_data[i], sizeof(tmp));
            memcpy(train_data[i], tmp, sizeof(tmp));
            int tmp_label = train_labels[j];
            train_labels[j] = train_labels[i];
            train_labels[i] = tmp_label;
        }

        // Train in batches
        for (int batch = 0; batch < TRAIN_SIZE / BATCH_SIZE; batch++) {
            // Initialize gradients
            float gradients[NUM_LABELS][NUM_FEATURES] = {};
            float bias_gradient[NUM_LABELS] = {};

            // Calculate gradients for each sample in the batch
            for (int i = 0; i < BATCH_SIZE; i++) {
                // Calculate logits
                float logits[NUM_LABELS] = {};
                for (int j = 0; j < NUM_LABELS; j++) {
                    for (int k = 0; k < NUM_FEATURES; k++) {
                        logits[j] += weights[j][k] * train_data[k][batch * BATCH_SIZE + i];
                    }
                    logits[j] += bias[j];
                }

                // Softmax the logits
                softmax(logits);

                // Calculate loss and gradient
                int label = train_labels[batch * BATCH_SIZE + i];
                float loss_grad[NUM_LABELS] = {};
                for (int j = 0; j < NUM_LABELS; j++) {
                    loss_grad[j] = logits[j] - (j == label);
                }

                // Calculate gradients and update
                for (int j = 0; j < NUM_LABELS; j++) {
                    bias_gradient[j] += loss_grad[j];
                    for (int k = 0; k < NUM_FEATURES; k++) {
                        gradients[j][k] += loss_grad[j] * train_data[k][batch * BATCH_SIZE + i];
                    }
                }
            }

            // Update weights and bias
            for (int i = 0; i < NUM_LABELS; i++) {
                for (int j = 0; j < NUM_FEATURES; j++) {
                    weights[i][j] -= gradients[i][j] / BATCH_SIZE;
                }
                bias[i] -= bias_gradient[i] / BATCH_SIZE;
            }
        }
    }

    // Evaluate the model on test data
    int correct = 0;
    for (int i = 0; i < TEST_SIZE; i++) {
        // Calculate logits
        float logits[NUM_LABELS] = {};
        for (int j = 0; j < NUM_LABELS; j++) {
            for (int k = 0; k < NUM_FEATURES; k++) {
                logits[j] += weights[j][k] * test_data[k][i];
            }
            logits[j] += bias[j];
        }

        // Softmax the logits
        softmax(logits);

        // Get predicted label
        int predicted_label = 0;
        for (int j = 1; j < NUM_LABELS; j++) {
            if (logits[j] > logits[predicted_label]) {
                predicted_label = j;
            }
        }

        // Check if prediction is correct
        if (predicted_label == test_labels[i]) {
            correct++;
        }
    }

    // Print accuracy
    printf("Accuracy: %.2f%%\n", (float) correct / TEST_SIZE * 100);

    // Close files
    fclose(fp_train_data);
    fclose(fp_train_labels);
    fclose(fp_test_data);
    fclose(fp_test_labels);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (00000001400017C2) ----------------------------------------------------
#error "1400017C2: stack frame is too big (funcsize=0)"

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Physics simulation ; Style: inquisitive
#include <stdio.h>
#include <math.h>

int main() {
    // In this physics simulation program, we will simulate the motion of a ball thrown in the air with air resistance.

    // First, we will define some constants.
    const double g = 9.81; // gravitational acceleration
    const double rho = 1.23; // density of air
    const double C = 0.47; // drag coefficient
    const double A = 0.003; // cross-sectional area of the ball
    const double m = 0.2; // mass of the ball

    // Next, we will prompt the user to enter the initial velocity of the ball.
    printf("Enter the initial velocity of the ball in m/s: ");
    double v_0;
    scanf("%lf", &v_0);

    // We will also prompt the user to enter the angle at which the ball is thrown.
    printf("Enter the angle at which the ball is thrown in degrees: ");
    double theta;
    scanf("%lf", &theta);

    // We will convert the angle from degrees to radians.
    theta = theta * M_PI / 180;

    // Now, we will initialize some variables for our simulation.
    double t = 0; // time
    double x = 0; // horizontal distance
    double y = 0; // height
    double vy = v_0 * sin(theta); // vertical velocity
    double vx = v_0 * cos(theta); // horizontal velocity
    double F_d, a, v, v_prev, delta_t = 0.01; // drag force, acceleration, velocity, previous velocity, time step

    // We will loop until the ball hits the ground.
    while (y >= 0) {
        // Calculate the drag force.
        F_d = 0.5 * rho * pow(vx, 2) * C * A;

        // Calculate the net force.
        double F_net = -F_d - m * g;

        // Calculate the acceleration.
        a = F_net / m;

        // Calculate the new velocity.
        v = vy + a * delta_t;

        // Calculate the average velocity.
        double v_avg = (v + vy) / 2;

        // Calculate the new position.
        y = y + v_avg * delta_t;
        x = x + vx * delta_t;

        // Print the position of the ball.
        printf("t=%.2fs\tx=%.2fm\ty=%.2fm\n", t, x, y);

        // Update the velocity.
        vy = v;
        vx = vx;

        // Update the time.
        t = t + delta_t;
    }

    // Print the total time of the simulation.
    printf("The ball hit the ground after %.2f seconds.\n", t);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl cos(double X);
double __cdecl pow(double X, double Y);
double __cdecl sin(double X);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm0_8
  double v4; // xmm0_8
  double v5; // xmm6_8
  double v6; // xmm0_8
  double X; // [rsp+20h] [rbp-90h] BYREF
  double v9; // [rsp+28h] [rbp-88h] BYREF
  double v10; // [rsp+30h] [rbp-80h]
  double v11; // [rsp+38h] [rbp-78h]
  double v12; // [rsp+40h] [rbp-70h]
  double v13; // [rsp+48h] [rbp-68h]
  double v14; // [rsp+50h] [rbp-60h]
  double v15; // [rsp+58h] [rbp-58h]
  double v16; // [rsp+60h] [rbp-50h]
  double v17; // [rsp+68h] [rbp-48h]
  double v18; // [rsp+70h] [rbp-40h]
  double v19; // [rsp+78h] [rbp-38h]
  double v20; // [rsp+80h] [rbp-30h]
  double v21; // [rsp+88h] [rbp-28h]
  double v22; // [rsp+90h] [rbp-20h]
  double v23; // [rsp+98h] [rbp-18h]
  double v24; // [rsp+A0h] [rbp-10h]
  double v25; // [rsp+A8h] [rbp-8h]

  _main(argc, argv, envp);
  v20 = 9.81;
  v19 = 1.23;
  v18 = 0.47;
  v17 = 0.003;
  v16 = 0.2;
  printf("Enter the initial velocity of the ball in m/s: ");
  scanf("%lf", &v9);
  printf("Enter the angle at which the ball is thrown in degrees: ");
  scanf("%lf", &X);
  X = 3.141592653589793 * X / 180.0;
  v25 = 0.0;
  v24 = 0.0;
  v23 = 0.0;
  v3 = sin(X);
  v22 = v3 * v9;
  v4 = cos(X);
  v21 = v4 * v9;
  v15 = 0.01;
  while ( v23 >= 0.0 )
  {
    v5 = v19 * 0.5;
    v6 = pow(v21, 2.0);
    v14 = v6 * v5 * v18 * v17;
    v13 = -v14 - v16 * v20;
    v12 = v13 / v16;
    v11 = v13 / v16 * v15 + v22;
    v10 = (v11 + v22) / 2.0;
    v23 = v10 * v15 + v23;
    v24 = v21 * v15 + v24;
    printf("t=%.2fs\tx=%.2fm\ty=%.2fm\n", v25, v24, v23);
    v22 = v11;
    v25 = v25 + v15;
  }
  printf("The ball hit the ground after %.2f seconds.\n", v25);
  return 0;
}
// 140001950: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mortgage Calculator ; Style: dynamic
#include <stdio.h>

int main() {
    float loanAmount, interestRate, monthlyPayment, principal, interest, balance, payments;
    
    // get loan amount
    printf("Enter loan amount: ");
    scanf("%f", &loanAmount);
    
    // get interest rate
    printf("Enter interest rate (in percentage): ");
    scanf("%f", &interestRate);
    
    // convert interest rate to monthly percentage rate
    interestRate /= 1200;
    
    // get number of payments
    printf("Enter number of payments: ");
    scanf("%f", &payments);
    
    // calculate monthly payment
    monthlyPayment = loanAmount * (interestRate * pow(1 + interestRate, payments)) / (pow(1 + interestRate, payments) - 1);
    
    // print monthly payment
    printf("\nMonthly Payment: $%.2f\n", monthlyPayment);
    
    // calculate and print amortization table
    printf("\nAmortization Table\n");
    printf("-------------------\n");
    printf("Month\t\tBalance\t\tPayment\t\tPrincipal\tInterest\n");
    
    balance = loanAmount;
    
    for (int month=1; month<=payments; month++) {
        
        interest = balance * interestRate;
        principal = monthlyPayment - interest;
        balance -= principal;
        
        printf("%d\t\t%.2f\t\t%.2f\t\t%.2f\t\t%.2f\n", month, balance, monthlyPayment, principal, interest);
    } 
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm6_8
  double v4; // xmm7_8
  double v5; // xmm6_8
  float v6; // xmm0_4
  float v8; // [rsp+30h] [rbp-20h] BYREF
  float v9; // [rsp+34h] [rbp-1Ch] BYREF
  float v10; // [rsp+38h] [rbp-18h] BYREF
  float v11; // [rsp+3Ch] [rbp-14h]
  float v12; // [rsp+40h] [rbp-10h]
  float v13; // [rsp+44h] [rbp-Ch]
  unsigned int i; // [rsp+48h] [rbp-8h]
  float v15; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter loan amount: ");
  scanf("%f", &v10);
  printf("Enter interest rate (in percentage): ");
  scanf("%f", &v9);
  v9 = v9 / 1200.0;
  printf("Enter number of payments: ");
  scanf("%f", &v8);
  v3 = v10;
  v4 = v9;
  v5 = v3 * (pow((float)(v9 + 1.0), v8) * v4);
  v6 = v5 / (pow((float)(v9 + 1.0), v8) - 1.0);
  v13 = v6;
  printf("\nMonthly Payment: $%.2f\n", v6);
  printf("\nAmortization Table\n");
  printf("-------------------\n");
  printf("Month\t\tBalance\t\tPayment\t\tPrincipal\tInterest\n");
  v15 = v10;
  for ( i = 1; v8 >= (float)(int)i; ++i )
  {
    v12 = v9 * v15;
    v11 = v13 - (float)(v9 * v15);
    v15 = v15 - v11;
    printf("%d\t\t%.2f\t\t%.2f\t\t%.2f\t\t%.2f\n", i, v15, v13, v11, v12);
  }
  return 0;
}
// 140001930: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Building a JSON Parser ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef enum {
  JSMN_OBJECT,
  JSMN_ARRAY,
  JSMN_STRING,
  JSMN_PRIMITIVE
} jsmntype_t;

typedef struct {
  jsmntype_t type;
  int start;
  int end;
  int size;
} jsmntok_t;

typedef struct {
  jsmntok_t* tokens;
  int num_tokens;
} jsmn_parser_t;

#define JSON_STRING_TEST "{\"name\": \"John Smith\", \"age\": 40, \"isMarried\": true, \"salary\": 120000.50, \"pets\": [\"dog\", \"cat\"]}"
#define JSMN_NUM_TOKENS 128

int jsmn_parse(jsmn_parser_t* parser, const char* json, size_t len) {
  jsmntok_t* tokens = parser->tokens;
  int num_tokens = 0;
  int i, j;

  /* Count number of tokens required */
  for (i = 0; i < len; i++) {
    switch (json[i]) {
      case '{':
      case '[':
        num_tokens++;
        break;
      case '}':
      case ']':
        num_tokens++;
        break;
      case '"':
        num_tokens++;
        for (i++; json[i] != '"' && i < len; i++);
        break;
      default:
        if (json[i] == '-' || (json[i] >= '0' && json[i] <= '9')) {
          num_tokens++;
          for (i++; json[i] >= '0' && json[i] <= '9'; i++);
          if (json[i] == '.') {
            num_tokens++;
            for (i++; json[i] >= '0' && json[i] <= '9'; i++);
          }
          i--;
        } else if (json[i] == 't' || json[i] == 'f' || json[i] == 'n') {
          num_tokens++;
          for (j = i+1; json[j] >= 'a' && json[j] <= 'z'; j++);
          if (strncmp(json+i, "true", 4) == 0 || strncmp(json+i, "null", 4) == 0) {
            i += 3;
          } else {
            i += 4;
          }
        }
        break;
    }
  }

  /* Allocate tokens */
  tokens = (jsmntok_t*) calloc(num_tokens, sizeof(jsmntok_t));
  if (tokens == NULL) {
    return -1;
  }
  parser->tokens = tokens;
  parser->num_tokens = num_tokens;

  /* Populate tokens */
  num_tokens = 0;
  for (i = 0; i < len; i++) {
    switch (json[i]) {
      case '{':
        tokens[num_tokens].type = JSMN_OBJECT;
        tokens[num_tokens].start = i;
        num_tokens++;
        break;
      case '}':
        tokens[num_tokens].type = JSMN_OBJECT;
        tokens[num_tokens].end = i+1;
        num_tokens++;
        break;
      case '[':
        tokens[num_tokens].type = JSMN_ARRAY;
        tokens[num_tokens].start = i;
        num_tokens++;
        break;
      case ']':
        tokens[num_tokens].type = JSMN_ARRAY;
        tokens[num_tokens].end = i+1;
        num_tokens++;
        break;
      case '"':
        tokens[num_tokens].type = JSMN_STRING;
        tokens[num_tokens].start = i+1;
        for (i++; json[i] != '"' && i < len; i++);
        tokens[num_tokens].end = i;
        num_tokens++;
        break;
      default:
        if (json[i] == '-' || (json[i] >= '0' && json[i] <= '9')) {
          tokens[num_tokens].type = JSMN_PRIMITIVE;
          tokens[num_tokens].start = i;
          for (i++; json[i] >= '0' && json[i] <= '9'; i++);
          if (json[i] == '.') {
            i++;
            for (; json[i] >= '0' && json[i] <= '9'; i++);
          }
          tokens[num_tokens].end = i;
          num_tokens++;
          i--;
        } else if (json[i] == 't' || json[i] == 'f' || json[i] == 'n') {
          tokens[num_tokens].type = JSMN_PRIMITIVE;
          tokens[num_tokens].start = i;
          for (j = i+1; json[j] >= 'a' && json[j] <= 'z'; j++);
          if (strncmp(json+i, "true", 4) == 0 || strncmp(json+i, "null", 4) == 0) {
            tokens[num_tokens].end = i+4;
            i += 3;
          } else {
            tokens[num_tokens].end = i+5;
            i += 4;
          }
          num_tokens++;
        }
        break;
    }
  }

  return 0;
}

int main() {
  const char* json = JSON_STRING_TEST;
  jsmn_parser_t parser;
  int i;
  
  jsmn_parse(&parser, json, strlen(json));
  
  printf("Number of tokens: %d\n", parser.num_tokens);
  for (i = 0; i < parser.num_tokens; i++) {
    switch (parser.tokens[i].type) {
      case JSMN_OBJECT:
        printf("%d: Object {start: %d, end: %d, size: %d}\n", i, parser.tokens[i].start, parser.tokens[i].end, parser.tokens[i].size);
        break;
      case JSMN_ARRAY:
        printf("%d: Array {start: %d, end: %d, size: %d}\n", i, parser.tokens[i].start, parser.tokens[i].end, parser.tokens[i].size);
        break;
      case JSMN_STRING:
        printf("%d: String {start: %d, end: %d}\n", i, parser.tokens[i].start, parser.tokens[i].end);
        break;
      case JSMN_PRIMITIVE:
        printf("%d: Primitive {start: %d, end: %d}\n", i, parser.tokens[i].start, parser.tokens[i].end);
        break;
    }
  }
  
  free(parser.tokens);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall jsmn_parse(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void __cdecl free(void *Block);


//----- (0000000140001C82) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  size_t v3; // rax
  unsigned int v4; // eax
  __int64 v6; // [rsp+20h] [rbp-30h]
  void *Block; // [rsp+30h] [rbp-20h] BYREF
  unsigned int v8; // [rsp+38h] [rbp-18h]
  char *Str; // [rsp+40h] [rbp-10h]
  unsigned int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  Str = "{\"name\": \"John Smith\", \"age\": 40, \"isMarried\": true, \"salary\": 120000.50, \"pets\": [\"dog\", \"cat\"]}";
  v3 = strlen(
         "{\"name\": \"John Smith\", \"age\": 40, \"isMarried\": true, \"salary\": 120000.50, \"pets\": [\"dog\", \"cat\"]}");
  jsmn_parse(
    &Block,
    "{\"name\": \"John Smith\", \"age\": 40, \"isMarried\": true, \"salary\": 120000.50, \"pets\": [\"dog\", \"cat\"]}",
    v3);
  printf("Number of tokens: %d\n", v8);
  for ( i = 0; (int)i < (int)v8; ++i )
  {
    v4 = *((_DWORD *)Block + 4 * (int)i);
    if ( v4 == 3 )
    {
      printf(
        "%d: Primitive {start: %d, end: %d}\n",
        i,
        *((unsigned int *)Block + 4 * (int)i + 1),
        *((unsigned int *)Block + 4 * (int)i + 2));
    }
    else if ( v4 <= 3 )
    {
      if ( v4 == 2 )
      {
        printf(
          "%d: String {start: %d, end: %d}\n",
          i,
          *((unsigned int *)Block + 4 * (int)i + 1),
          *((unsigned int *)Block + 4 * (int)i + 2));
      }
      else
      {
        LODWORD(v6) = *((_DWORD *)Block + 4 * (int)i + 3);
        if ( v4 )
          printf(
            "%d: Array {start: %d, end: %d, size: %d}\n",
            i,
            *((unsigned int *)Block + 4 * (int)i + 1),
            *((unsigned int *)Block + 4 * (int)i + 2),
            v6);
        else
          printf(
            "%d: Object {start: %d, end: %d, size: %d}\n",
            i,
            *((unsigned int *)Block + 4 * (int)i + 1),
            *((unsigned int *)Block + 4 * (int)i + 2),
            v6);
      }
    }
  }
  free(Block);
  return 0;
}
// 140001D0C: conditional instruction was optimized away because eax.4<2u
// 140001D19: conditional instruction was optimized away because eax.4==1
// 140001DD0: variable 'v6' is possibly undefined
// 140001591: using guessed type __int64 __fastcall jsmn_parse(_QWORD, _QWORD, _QWORD);
// 140001F40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: visionary
#include <stdio.h>

int main()
{
 int array[100], n, c, d,s;
  printf("Enter the number of elements you want in the array: \n");
  scanf("%d", &n);

  printf("Enter the elements of the array: \n");
  for (c = 0; c < n; c++)
    scanf("%d", &array[c]);

  // Sorting the array using Bubble sort
   for (c = 0 ; c < n - 1; c++)
  {
    for (d = 0 ; d < n - c - 1; d++)
    {
      if (array[d] > array[d+1]) /* For descending order use < */
      {
        s       = array[d];
        array[d]   = array[d+1];
        array[d+1] = s;
      }
    }
  }

  printf("Sorted array in ascending order: \n");
  for (c = 0; c < n; c++)
     printf("%d  ", array[c]);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[102]; // [rsp+2Ch] [rbp-54h] BYREF
  int v5; // [rsp+1C4h] [rbp+144h]
  int j; // [rsp+1C8h] [rbp+148h]
  int i; // [rsp+1CCh] [rbp+14Ch]

  _main(argc, argv, envp);
  printf("Enter the number of elements you want in the array: \n");
  scanf("%d", v4);
  printf("Enter the elements of the array: \n");
  for ( i = 0; i < v4[0]; ++i )
    scanf("%d", &v4[i + 1]);
  for ( i = 0; i < v4[0] - 1; ++i )
  {
    for ( j = 0; j < v4[0] - i - 1; ++j )
    {
      if ( v4[j + 1] > v4[j + 2] )
      {
        v5 = v4[j + 1];
        v4[j + 1] = v4[j + 2];
        v4[j + 2] = v5;
      }
    }
  }
  printf("Sorted array in ascending order: \n");
  for ( i = 0; i < v4[0]; ++i )
    printf("%d  ", (unsigned int)v4[i + 1]);
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Watermarking ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to set the lowest bit of every pixel to zero, except for the watermark bit
void embed_watermark(char *image_path, char *output_path, char *watermark) {
    FILE *image_file = fopen(image_path, "rb");
    FILE *output_file = fopen(output_path, "wb");

    if (image_file == NULL || output_file == NULL) {
        printf("File error!\n");
        exit(1);
    }

    unsigned char header[54];
    fread(header, sizeof(unsigned char), 54, image_file);

    fwrite(header, sizeof(unsigned char), 54, output_file);

    int width = *(int *)&header[18];
    int height = *(int *)&header[22];
    int padding = (4 - (width * 3) % 4) % 4;

    // Embed the watermark text bit by bit
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            unsigned char pixel[3];
            fread(pixel, sizeof(unsigned char), 3, image_file);

            // Set the lowest bit of the red component to zero
            pixel[0] = pixel[0] & 0xFE;

            if (*watermark != '\0') {
                // If there are more bits in the watermark message, embed the next one
                if ((*watermark & 0x80) == 0x80) {
                    // Set the lowest bit of the red component to one
                    pixel[0] = pixel[0] | 0x01;
                }
                watermark++;
            }

            fwrite(pixel, sizeof(unsigned char), 3, output_file);
        }
        // Add padding to the end of each row
        fseek(image_file, padding, SEEK_CUR);
        for (int k = 0; k < padding; k++) {
            fputc(0x00, output_file);
        }
    }

    fclose(image_file);
    fclose(output_file);
}

// Function to extract the watermark from an image
void extract_watermark(char *image_path, int watermark_len) {
    FILE *image_file = fopen(image_path, "rb");

    if (image_file == NULL) {
        printf("File error!\n");
        exit(1);
    }

    unsigned char header[54];
    fread(header, sizeof(unsigned char), 54, image_file);

    int width = *(int *)&header[18];
    int height = *(int *)&header[22];
    int padding = (4 - (width * 3) % 4) % 4;

    char watermark[watermark_len + 1];
    memset(watermark, 0, watermark_len + 1);

    // Extract the watermark from the LSB of the red component of each pixel
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            unsigned char pixel[3];
            fread(pixel, sizeof(unsigned char), 3, image_file);

            // Extract the lowest bit of the red component
            if ((pixel[0] & 0x01) == 0x01) {
                watermark[i * width + j] = '1';
            } else {
                watermark[i * width + j] = '0';
            }

            if (i * width + j == watermark_len) {
                break;
            }
        }
        // Skip the padding at the end of each row
        fseek(image_file, padding, SEEK_CUR);
    }

    printf("Extracted watermark: %s\n", watermark);

    fclose(image_file);
}

int main() {
    char *image_path = "input.bmp";
    char *output_path = "output.bmp";
    char *watermark = "Hello, World!";
    int watermark_len = strlen(watermark) * 8;

    embed_watermark(image_path, output_path, watermark);

    extract_watermark(output_path, watermark_len);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall embed_watermark(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall extract_watermark(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (000000014000198A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-1Ch]

  _main(argc, argv, envp);
  v4 = 8 * strlen("Hello, World!");
  embed_watermark("input.bmp", "output.bmp", "Hello, World!");
  extract_watermark("output.bmp", v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall embed_watermark(_QWORD, _QWORD, _QWORD);
// 140001777: using guessed type __int64 __fastcall extract_watermark(_QWORD, _QWORD);
// 140001AB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define N 10 // Size of matrix

void generateMatrix(int (*matrix)[N]) {
    srand(time(NULL)); // Set random seed based on current time

    // Initialize matrix with random 0's and 1's
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            matrix[i][j] = rand() % 2;
        }
    }
}

void printMatrix(int (*matrix)[N]) {
    // Print matrix
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

void percolate(int (*matrix)[N]) {
    int flag = 1; // Flag to mark if any changes made in last iteration
    // Keep checking and changing the matrix until no further changes can be made
    while (flag) {
        flag = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (matrix[i][j] == 1) {
                    // Check if any neighboring cell is also 1, if yes, change the current cell to 1
                    if ((j < N - 1 && matrix[i][j+1] == 2) ||
                        (i < N - 1 && matrix[i+1][j] == 2) ||
                        (j > 0 && matrix[i][j-1] == 2) ||
                        (i > 0 && matrix[i-1][j] == 2)) {
                        matrix[i][j] = 2;
                        flag = 1;
                    }
                }
            }
        }
    }
}

int main() {
    int matrix[N][N];

    generateMatrix(matrix);
    printf("Initial matrix:\n");
    printMatrix(matrix);

    percolate(matrix);
    printf("Final matrix:\n");
    printMatrix(matrix);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall generateMatrix(_QWORD); // weak
__int64 __fastcall printMatrix(_QWORD); // weak
__int64 __fastcall percolate(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001856) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[400]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  generateMatrix(v4);
  printf("Initial matrix:\n");
  printMatrix(v4);
  percolate(v4);
  printf("Final matrix:\n");
  printMatrix(v4);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall generateMatrix(_QWORD);
// 14000163F: using guessed type __int64 __fastcall printMatrix(_QWORD);
// 1400016BF: using guessed type __int64 __fastcall percolate(_QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database Indexing System ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_RECORDS 1000
#define MAX_NAME_LEN 50
#define MAX_AGE 120

typedef struct {
    int id;
    char name[MAX_NAME_LEN];
    int age;
} record_t;

typedef struct {
    char name[MAX_NAME_LEN];
    int records_count;
    int* records_indexes;
} index_t;

record_t records[MAX_RECORDS];
int records_count = 0;
index_t indexes[MAX_NAME_LEN];
int indexes_count = 0;

/* Helper functions */
int is_name_match(const char* name1, const char* name2) {
    return strcmp(name1, name2) == 0;
}

/* Database functions */
int add_record(int id, const char* name, int age) {
    if (records_count >= MAX_RECORDS) {
        return 0;
    }
    record_t* record = &records[records_count];
    record->id = id;
    strncpy(record->name, name, MAX_NAME_LEN);
    record->age = age;
    records_count++;
    return 1;
}

void add_index(const char* name, int record_index) {
    index_t* index = NULL;
    for (int i = 0; i < indexes_count; i++) {
        if (is_name_match(indexes[i].name, name)) {
            index = &indexes[i];
            break;
        }
    }
    if (index == NULL) {
        index = &indexes[indexes_count];
        strncpy(index->name, name, MAX_NAME_LEN);
        index->records_count = 0;
        index->records_indexes = calloc(MAX_RECORDS, sizeof(int));
        indexes_count++;
    }
    index->records_indexes[index->records_count] = record_index;
    index->records_count++;
}

void print_records(const index_t* index) {
    printf("Records indexed by %s:\n", index->name);
    for (int i = 0; i < index->records_count; i++) {
        const record_t* record = &records[index->records_indexes[i]];
        printf("[%d] %s (age %d)\n", record->id, record->name, record->age);
    }
}

int main() {
    /* Add some records */
    add_record(1, "John", 25);
    add_index("name", 0);
    add_record(2, "Bob", 30);
    add_index("name", 1);
    add_record(3, "John", 45);
    add_index("name", 2);
    add_record(4, "Alice", 20);
    add_index("age", 0);
    add_record(5, "Jane", 35);
    add_index("age", 1);

    /* Test indexing */
    for (int i = 0; i < indexes_count; i++) {
        print_records(&indexes[i]);
    }

    /* Cleanup */
    for (int i = 0; i < indexes_count; i++) {
        free(indexes[i].records_indexes);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall add_record(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall add_index(_QWORD, _QWORD); // weak
__int64 __fastcall print_records(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN indexes; // weak
_UNKNOWN unk_14001DAF8; // weak
int indexes_count; // weak


//----- (000000014000180A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  add_record(1i64, "John", 25i64);
  add_index("name", 0i64);
  add_record(2i64, "Bob", 30i64);
  add_index("name", 1i64);
  add_record(3i64, "John", 45i64);
  add_index("name", 2i64);
  add_record(4i64, "Alice", 20i64);
  add_index("age", 0i64);
  add_record(5i64, "Jane", 35i64);
  add_index("age", 1i64);
  for ( i = 0; i < indexes_count; ++i )
    print_records((char *)&indexes + 64 * (__int64)i);
  for ( j = 0; j < indexes_count; ++j )
    free(*((void **)&unk_14001DAF8 + 8 * (__int64)j));
  return 0;
}
// 1400015BF: using guessed type __int64 __fastcall add_record(_QWORD, _QWORD, _QWORD);
// 140001652: using guessed type __int64 __fastcall add_index(_QWORD, _QWORD);
// 140001766: using guessed type __int64 __fastcall print_records(_QWORD);
// 140001A30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14001E740: using guessed type int indexes_count;

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Antivirus scanner ; Style: light-weight
#include <stdio.h>
#include <stdbool.h>

#define MAX_FILE_NAME 50

bool isVirus(char* fileName) {
    // logic to check if file contains virus
    return false;
}

int main() {
    char fileName[MAX_FILE_NAME];
    
    printf("Enter file name to scan: ");
    scanf("%s", fileName);
    
    if(isVirus(fileName)) {
        printf("Virus detected in %s\n", fileName);
    } else {
        printf("No virus detected in %s\n", fileName);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall isVirus(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015F1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[64]; // [rsp+20h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  printf("Enter file name to scan: ");
  scanf("%s", v4);
  if ( (unsigned __int8)isVirus(v4) )
    printf("Virus detected in %s\n", v4);
  else
    printf("No virus detected in %s\n", v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall isVirus(_QWORD);
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Backup System ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILENAME_SIZE 20
#define MAX_NUM_FILES 10

typedef struct {
    char filename[MAX_FILENAME_SIZE];
    char contents[1024];
} File;

typedef struct {
    File files[MAX_NUM_FILES];
    int num_files;
} Backup;

void add_file(Backup* backup, char* filename, char* contents) {
    if (backup->num_files == MAX_NUM_FILES) {
        printf("Backup is full, cannot add file %s\n", filename);
        return;
    }
    strcpy(backup->files[backup->num_files].filename, filename);
    strcpy(backup->files[backup->num_files].contents, contents);
    backup->num_files++;
    printf("File %s added to backup\n", filename);
}

void remove_file(Backup* backup, char* filename) {
    int i, index = -1;
    for (i = 0; i < backup->num_files; i++) {
        if (strcmp(backup->files[i].filename, filename) == 0) {
            index = i;
            break;
        }
    }
    if (index == -1) {
        printf("File %s not found in backup\n", filename);
        return;
    }
    for (i = index; i < backup->num_files-1; i++) {
        backup->files[i] = backup->files[i+1];
    }
    backup->num_files--;
    printf("File %s removed from backup\n", filename);
}

void list_files(Backup* backup) {
    int i;
    printf("Backup contents:\n");
    for (i = 0; i < backup->num_files; i++) {
        printf("%s\n", backup->files[i].filename);
    }
}

int main() {
    Backup backup = {0};
    char filename[MAX_FILENAME_SIZE];
    char contents[1024];
    int choice;
    while (1) {
        printf("Backup menu:\n");
        printf("1) Add file\n");
        printf("2) Remove file\n");
        printf("3) List files\n");
        printf("4) Quit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                printf("Enter filename: ");
                scanf("%s", filename);
                printf("Enter contents: ");
                scanf("%s", contents);
                add_file(&backup, filename, contents);
                break;
            case 2:
                printf("Enter filename: ");
                scanf("%s", filename);
                remove_file(&backup, filename);
                break;
            case 3:
                list_files(&backup);
                break;
            case 4:
                printf("Terminating backup system...\n");
                exit(0);
            default:
                printf("Invalid choice, please try again\n");
                break;
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_file(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall remove_file(_QWORD, _QWORD); // weak
__int64 __fastcall list_files(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memset(void *, int Val, size_t Size);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001860) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+2Ch] [rbp-54h] BYREF
  char v4[1024]; // [rsp+30h] [rbp-50h] BYREF
  char v5[32]; // [rsp+430h] [rbp+3B0h] BYREF
  char v6[10448]; // [rsp+450h] [rbp+3D0h] BYREF

  _main(argc, argv, envp);
  memset(v6, 0, 0x28CCui64);
  while ( 1 )
  {
    printf("Backup menu:\n");
    printf("1) Add file\n");
    printf("2) Remove file\n");
    printf("3) List files\n");
    printf("4) Quit\n");
    printf("Enter choice: ");
    scanf("%d", &v3);
    if ( v3 == 4 )
    {
      printf("Terminating backup system...\n");
      exit(0);
    }
    if ( v3 > 4 )
    {
LABEL_12:
      printf("Invalid choice, please try again\n");
    }
    else
    {
      switch ( v3 )
      {
        case 3:
          list_files(v6);
          break;
        case 1:
          printf("Enter filename: ");
          scanf("%s", v5);
          printf("Enter contents: ");
          scanf("%s", v4);
          add_file(v6, v5, v4);
          break;
        case 2:
          printf("Enter filename: ");
          scanf("%s", v5);
          remove_file(v6, v5);
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 140001928: conditional instruction was optimized away because %var_2CF4.4<3
// 1400015E2: using guessed type __int64 __fastcall add_file(_QWORD, _QWORD, _QWORD);
// 1400016A9: using guessed type __int64 __fastcall remove_file(_QWORD, _QWORD);
// 1400017FC: using guessed type __int64 __fastcall list_files(_QWORD);
// 140001AE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Checksum Calculator ; Style: real-life
#include <stdio.h>
#include <stdlib.h>

int main() {
   unsigned char message[50];
   int len, i, sum = 0;

   printf("Enter the message to calculate Checksum:\n");
   fgets(message, sizeof(message), stdin);

   for(i=0;message[i]!='\0';i++) {
      sum += message[i];
   }

   printf("The calculated Checksum is: %x\n", sum);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[56]; // [rsp+20h] [rbp-40h] BYREF
  unsigned int v6; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  printf("Enter the message to calculate Checksum:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 50, v3);
  for ( i = 0; Buffer[i]; ++i )
    v6 += (unsigned __int8)Buffer[i];
  printf("The calculated Checksum is: %x\n", v6);
  return 0;
}
// 1400016E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[56];

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Tic Tac Toe AI ; Style: inquisitive
#include <stdio.h>
#include <stdlib.h>

// function to initialize the board with empty cells
void init_board(char board[3][3]) {
    int i, j;
    for(i=0;i<3;i++) {
        for(j=0;j<3;j++) {
            board[i][j] = '-';
        }
    }
}

// function to print the current state of the board
void print_board(char board[3][3]) {
    int i, j;
    for(i=0;i<3;i++) {
        for(j=0;j<3;j++) {
            printf("%c ", board[i][j]);
        }
        printf("\n");
    }
}

int main() {
    char board[3][3];
    int i, j;

    init_board(board);
    print_board(board);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall init_board(_QWORD); // weak
__int64 __fastcall print_board(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001666) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[9]; // [rsp+27h] [rbp-9h] BYREF

  _main(argc, argv, envp);
  init_board(v4);
  print_board(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall init_board(_QWORD);
// 1400015EA: using guessed type __int64 __fastcall print_board(_QWORD);
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    char answers[10][50] = {"Yes", "No", "Maybe", "It is uncertain", "Try again later", "Outlook not so good", "Ask again", "The future looks bright", "Cannot predict now", "Signs point to yes"};
    char question[100];

    printf("Welcome to the Automated Fortune Teller.\n");
    printf("Enter your question:\n");

    fgets(question, 100, stdin);
    printf("Thinking...\n");

    srand(time(NULL));
    int index = rand() % 10;

    printf("The answer to your question \"%s\" is: %s\n", question, answers[index]);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v4; // eax
  char Buffer[112]; // [rsp+20h] [rbp-60h] BYREF
  char v7[508]; // [rsp+90h] [rbp+10h] BYREF
  int v8; // [rsp+28Ch] [rbp+20Ch]

  _main(argc, argv, envp);
  qmemcpy(v7, &unk_14000A020, 0x1F4ui64);
  printf("Welcome to the Automated Fortune Teller.\n");
  printf("Enter your question:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  printf("Thinking...\n");
  v4 = time(0i64);
  srand(v4);
  v8 = rand() % 10;
  printf("The answer to your question \"%s\" is: %s\n", Buffer, &v7[50 * v8]);
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type char var_210[508];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Secure Password Generator ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ctype.h>

#define PASSWORD_LENGTH 12

int main() {

    char password[PASSWORD_LENGTH+1];
    int i, randomDigit, randomLetter, randomSymbol;

    srand(time(NULL));

    // generate random digits
    for(i=0; i < 2; ++i) {
        randomDigit = rand() % 10;
        password[i] = randomDigit + '0';
    }

    // generate random uppercase letters
    for(i=2; i < 5; ++i) {
        randomLetter = rand() % 26;
        password[i] = randomLetter + 'A';
    }

    // generate random lowercase letters
    for(i=5; i < 8; ++i) {
        randomLetter = rand() % 26;
        password[i] = randomLetter + 'a';
    }

    // generate random symbols
    for(i=8; i < 10; ++i) {

        switch(rand() % 4) {
            case 0:
                randomSymbol = rand() % 16;
                password[i] = randomSymbol < 10 ? randomSymbol + '0' : randomSymbol + 'A' - 10;
                break;
            case 1:
                password[i] = '!';
                break;
            case 2:
                password[i] = '@';
                break;
            case 3:
                password[i] = '#';
                break;
        }
    }

    // add a random symbol from all ASCII symbols
    password[10] = rand() % (127 - 33) + 33;

    // terminate the string with null character
    password[PASSWORD_LENGTH] = '\0';

    // shuffle the characters randomly
    for(i=0; i < PASSWORD_LENGTH; ++i) {
        int j = rand() % PASSWORD_LENGTH;
        char temp = password[i];
        password[i] = password[j];
        password[j] = temp;
    }

    // validate the password
    int hasDigit = 0, hasLower = 0, hasUpper = 0, hasSymbol = 0;
    for(i=0; i < PASSWORD_LENGTH; ++i) {
        if(isdigit(password[i])) hasDigit = 1;
        else if(islower(password[i])) hasLower = 1;
        else if(isupper(password[i])) hasUpper = 1;
        else hasSymbol = 1;
    }

    // regenerate the password if it doesn't meet the requirements
    while(!hasDigit || !hasLower || !hasUpper || !hasSymbol) {

        // generate random digits
        for(i=0; i < 2; ++i) {
            randomDigit = rand() % 10;
            password[i] = randomDigit + '0';
        }

        // generate random uppercase letters
        for(i=2; i < 5; ++i) {
            randomLetter = rand() % 26;
            password[i] = randomLetter + 'A';
        }

        // generate random lowercase letters
        for(i=5; i < 8; ++i) {
            randomLetter = rand() % 26;
            password[i] = randomLetter + 'a';
        }

        // generate random symbols
        for(i=8; i < 10; ++i) {

            switch(rand() % 4) {
                case 0:
                    randomSymbol = rand() % 16;
                    password[i] = randomSymbol < 10 ? randomSymbol + '0' : randomSymbol + 'A' - 10;
                    break;
                case 1:
                    password[i] = '!';
                    break;
                case 2:
                    password[i] = '@';
                    break;
                case 3:
                    password[i] = '#';
                    break;
            }
        }

        // add a random symbol from all ASCII symbols
        password[10] = rand() % (127 - 33) + 33;

        // terminate the string with null character
        password[PASSWORD_LENGTH] = '\0';

        // shuffle the characters randomly
        for(i=0; i < PASSWORD_LENGTH; ++i) {
            int j = rand() % PASSWORD_LENGTH;
            char temp = password[i];
            password[i] = password[j];
            password[j] = temp;
        }

        // validate the new password
        hasDigit = 0, hasLower = 0, hasUpper = 0, hasSymbol = 0;
        for(i=0; i < PASSWORD_LENGTH; ++i) {
            if(isdigit(password[i])) hasDigit = 1;
            else if(islower(password[i])) hasLower = 1;
            else if(isupper(password[i])) hasUpper = 1;
            else hasSymbol = 1;
        }
    }

    // print the password
    printf("Your secure password is: %s", password);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *islower)(int C);
// extern int (__cdecl *isupper)(int C);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax
  char v5; // dl
  int v6; // eax
  char v7; // dl
  char v9[10]; // [rsp+26h] [rbp-3Ah] BYREF
  char v10; // [rsp+30h] [rbp-30h]
  char v11; // [rsp+32h] [rbp-2Eh]
  char v12; // [rsp+33h] [rbp-2Dh]
  int v13; // [rsp+34h] [rbp-2Ch]
  int v14; // [rsp+38h] [rbp-28h]
  int v15; // [rsp+3Ch] [rbp-24h]
  int v16; // [rsp+40h] [rbp-20h]
  char v17; // [rsp+47h] [rbp-19h]
  int v18; // [rsp+48h] [rbp-18h]
  int v19; // [rsp+4Ch] [rbp-14h]
  int v20; // [rsp+50h] [rbp-10h]
  int v21; // [rsp+54h] [rbp-Ch]
  int v22; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 1; ++i )
  {
    v14 = rand() % 10;
    v9[i] = v14 + 48;
  }
  for ( i = 2; i <= 4; ++i )
  {
    v15 = rand() % 26;
    v9[i] = v15 + 65;
  }
  for ( i = 5; i <= 7; ++i )
  {
    v15 = rand() % 26;
    v9[i] = v15 + 97;
  }
  for ( i = 8; i <= 9; ++i )
  {
    v4 = rand() % 4;
    if ( v4 == 3 )
    {
      v9[i] = 35;
    }
    else if ( v4 <= 3 )
    {
      if ( v4 == 2 )
      {
        v9[i] = 64;
      }
      else if ( v4 )
      {
        if ( v4 == 1 )
          v9[i] = 33;
      }
      else
      {
        v16 = rand() % 16;
        if ( v16 > 9 )
          v5 = v16 + 55;
        else
          v5 = v16 + 48;
        v9[i] = v5;
      }
    }
  }
  v10 = rand() % 94 + 33;
  v11 = 0;
  for ( i = 0; i <= 11; ++i )
  {
    v13 = rand() % 12;
    v12 = v9[i];
    v9[i] = v9[v13];
    v9[v13] = v12;
  }
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  for ( i = 0; i <= 11; ++i )
  {
    if ( (unsigned int)(v9[i] - 48) > 9 )
    {
      if ( islower(v9[i]) )
      {
        v21 = 1;
      }
      else if ( isupper(v9[i]) )
      {
        v20 = 1;
      }
      else
      {
        v19 = 1;
      }
    }
    else
    {
      v22 = 1;
    }
  }
  while ( !v22 || !v21 || !v20 || !v19 )
  {
    for ( i = 0; i <= 1; ++i )
    {
      v14 = rand() % 10;
      v9[i] = v14 + 48;
    }
    for ( i = 2; i <= 4; ++i )
    {
      v15 = rand() % 26;
      v9[i] = v15 + 65;
    }
    for ( i = 5; i <= 7; ++i )
    {
      v15 = rand() % 26;
      v9[i] = v15 + 97;
    }
    for ( i = 8; i <= 9; ++i )
    {
      v6 = rand() % 4;
      if ( v6 == 3 )
      {
        v9[i] = 35;
      }
      else if ( v6 <= 3 )
      {
        if ( v6 == 2 )
        {
          v9[i] = 64;
        }
        else if ( v6 )
        {
          if ( v6 == 1 )
            v9[i] = 33;
        }
        else
        {
          v16 = rand() % 16;
          if ( v16 > 9 )
            v7 = v16 + 55;
          else
            v7 = v16 + 48;
          v9[i] = v7;
        }
      }
    }
    v10 = rand() % 94 + 33;
    v11 = 0;
    for ( i = 0; i <= 11; ++i )
    {
      v18 = rand() % 12;
      v17 = v9[i];
      v9[i] = v9[v18];
      v9[v18] = v17;
    }
    v22 = 0;
    v21 = 0;
    v20 = 0;
    v19 = 0;
    for ( i = 0; i <= 11; ++i )
    {
      if ( (unsigned int)(v9[i] - 48) > 9 )
      {
        if ( islower(v9[i]) )
        {
          v21 = 1;
        }
        else if ( isupper(v9[i]) )
        {
          v20 = 1;
        }
        else
        {
          v19 = 1;
        }
      }
      else
      {
        v22 = 1;
      }
    }
  }
  printf("Your secure password is: %s", v9);
  return 0;
}
// 1400016F1: conditional instruction was optimized away because eax.4<2
// 1400019CF: conditional instruction was optimized away because eax.4<2
// 140001C80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type char var_3A[10];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bucket Sort Implementation ; Style: secure
#include <stdio.h>
#include <stdlib.h>

#define ARRAY_SIZE 10
#define BUCKET_SIZE 5

void bucketSort(int *arr, int n) {
    int i, j;
    int min_val = arr[0], max_val = arr[0];

    for (i = 1; i < n; i++) {
        if (arr[i] < min_val) {
            min_val = arr[i];
        } else if (arr[i] > max_val) {
            max_val = arr[i];
        }
    }

    int num_buckets = ((max_val - min_val) / BUCKET_SIZE) + 1;

    int **buckets = (int **) malloc(num_buckets * sizeof(int *));
    for (i = 0; i < num_buckets; i++) {
        buckets[i] = (int *) malloc(BUCKET_SIZE * sizeof(int));
    }

    for (i = 0; i < num_buckets; i++) {
        for (j = 0; j < BUCKET_SIZE; j++) {
            buckets[i][j] = -1;
        }
    }

    int bucket_index;
    for (i = 0; i < n; i++) {
        bucket_index = (arr[i] - min_val) / BUCKET_SIZE;
        j = 0;
        while (buckets[bucket_index][j] != -1) {
            j++;
        }
        buckets[bucket_index][j] = arr[i];
    }

    for (i = 0; i < num_buckets; i++) {
        insertionSort(buckets[i], BUCKET_SIZE);
    }

    int index = 0;
    for (i = 0; i < num_buckets; i++) {
        for (j = 0; j < BUCKET_SIZE; j++) {
            if (buckets[i][j] != -1) {
                arr[index++] = buckets[i][j];
            }
        }
    }

    for (i = 0; i < num_buckets; i++) {
        free(buckets[i]);
    }
    free(buckets);
}

void insertionSort(int arr[], int n) {
    int i, j, key;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

int main() {
    int i;
    int arr[ARRAY_SIZE] = {6, 3, 8, 4, 2, 9, 1, 7, 5, 0};

    printf("Original Array: ");
    for (i = 0; i < ARRAY_SIZE; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    bucketSort(arr, ARRAY_SIZE);

    printf("Sorted Array: ");
    for (i = 0; i < ARRAY_SIZE; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall bucketSort(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400019A8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[11]; // [rsp+20h] [rbp-30h] BYREF
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 6;
  v4[1] = 3;
  v4[2] = 8;
  v4[3] = 4;
  v4[4] = 2;
  v4[5] = 9;
  v4[6] = 1;
  v4[7] = 7;
  v4[8] = 5;
  v4[9] = 0;
  printf("Original Array: ");
  for ( i = 0; i <= 9; ++i )
    printf("%d ", (unsigned int)v4[i]);
  printf("\n");
  bucketSort(v4, 10i64);
  printf("Sorted Array: ");
  for ( i = 0; i <= 9; ++i )
    printf("%d ", (unsigned int)v4[i]);
  printf("\n");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall bucketSort(_QWORD, _QWORD);
// 140001B60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bingo Simulator ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 5
#define COLS 5
#define MAX_NUM 75

void generate_card(int card[][COLS]);
void print_card(int card[][COLS]);
void generate_numbers(int numbers[]);
int check_card(int card[][COLS], int num);
int check_bingo(int card[][COLS]);

int main()
{
    int card[ROWS][COLS];
    int numbers[MAX_NUM];
    int num_drawn, row, col, num_bingo;
    char play_again = 'y';

    // Set random seed
    srand(time(NULL));

    printf("Welcome to the Bingo Simulator!\n");

    while (play_again == 'y')
    {
        // Generate a new card
        generate_card(card);
        
        // Reset all numbers drawn
        for (int i = 0; i < MAX_NUM; i++)
        {
            numbers[i] = 0;
        }

        num_bingo = 0;

        // Main game loop
        while (num_bingo == 0)
        {
            // Generate a new random number
            generate_numbers(numbers);
            num_drawn = numbers[rand() % MAX_NUM];

            // Check if number is in card
            if (check_card(card, num_drawn))
            {
                printf("Number drawn: %d\n", num_drawn);

                // Mark the number in the card
                for (row = 0; row < ROWS; row++)
                {
                    for (col = 0; col < COLS; col++)
                    {
                        if (card[row][col] == num_drawn)
                        {
                            card[row][col] = -1;
                        }
                    }
                }

                // Print updated card
                print_card(card);

                // Check for bingo
                num_bingo = check_bingo(card);

                if (num_bingo > 0)
                {
                    printf("Bingo! You won with %d numbers drawn!\n", MAX_NUM - num_bingo);
                }
            }
        }

        // Ask if user wants to play again
        printf("Would you like to play again? (y/n): ");
        fflush(stdin);
        scanf("%c", &play_again);
    }

    printf("Thank you for playing the Bingo Simulator!\n");

    return 0;
}

void generate_card(int card[][COLS])
{
    int i, j;
    int row_nums[ROWS][COLS] = {0};
    int col_nums[ROWS][COLS] = {0};

    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            card[i][j] = 0;
        }
    }

    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            if (j == 2 && i == 2)
            {
                card[i][j] = -1;
            }
            else
            {
                int num = rand() % 15 + (j * 15) + 1;
    
                while (row_nums[i][num / 15] == 1 || col_nums[j][num / 15] == 1)
                {
                    num = rand() % 15 + (j * 15) + 1;
                }
        
                card[i][j] = num;
                row_nums[i][num / 15] = 1;
                col_nums[j][num / 15] = 1;
            }
        }
    }
}

void print_card(int card[][COLS])
{
    int i, j;

    printf("\n");

    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            if (card[i][j] == -1)
            {
                printf("[X]");
            }
            else
            {
                printf("[%02d]", card[i][j]);
            }
        }
        
        printf("\n");
    }

    printf("\n");
}

void generate_numbers(int numbers[])
{
    int i, num;

    do
    {
        num = rand() % MAX_NUM + 1;
    } while (numbers[num - 1] == 1);

    numbers[num - 1] = 1;
}

int check_card(int card[][COLS], int num)
{
    int i, j;

    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            if(card[i][j] == num)
            {
                return 1;
            }
        }
    }

    return 0;
}

int check_bingo(int card[][COLS])
{
    int i, j, count;

    // Check rows
    for (i = 0; i < ROWS; i++)
    {
        count = 0;

        for (j = 0; j < COLS; j++)
        {
            if (card[i][j] == -1)
            {
                count++;
            }
        }

        if (count == COLS)
        {
            return (ROWS - i) * COLS; // Return number of numbers drawn
        }
    }

    // Check columns
    for (j = 0; j < COLS; j++)
    {
        count = 0;

        for (i = 0; i < ROWS; i++)
        {
            if (card[i][j] == -1)
            {
                count++;
            }
        }

        if (count == ROWS)
        {
            return (ROWS * COLS) - ((COLS - j) * ROWS); // Return number of numbers drawn
        }
    }

    // Check diagonals
    count = 0;

    for (i = 0; i < ROWS; i++)
    {
        if (card[i][i] == -1)
        {
            count++;
        }
    }

    if (count == ROWS)
    {
        return (ROWS * COLS) - (2 * ROWS); // Return number of numbers drawn
    }

    count = 0;

    for (i = 0; i < ROWS; i++)
    {
        if (card[i][COLS - 1 - i] == -1)
        {
            count++;
        }
    }

    if (count == ROWS)
    {
        return (ROWS * COLS) - (2 * ROWS); // Return number of numbers drawn
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall generate_card(_QWORD); // weak
__int64 __fastcall print_card(_QWORD); // weak
__int64 __fastcall generate_numbers(_QWORD); // weak
__int64 __fastcall check_card(_QWORD, _QWORD); // weak
__int64 __fastcall check_bingo(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl fflush(FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  FILE *v4; // rax
  char v6; // [rsp+2Fh] [rbp-51h] BYREF
  int v7[76]; // [rsp+30h] [rbp-50h] BYREF
  int v8[27]; // [rsp+160h] [rbp+E0h] BYREF
  unsigned int v9; // [rsp+1CCh] [rbp+14Ch]
  int i; // [rsp+1D0h] [rbp+150h]
  int v11; // [rsp+1D4h] [rbp+154h]
  int k; // [rsp+1D8h] [rbp+158h]
  int j; // [rsp+1DCh] [rbp+15Ch]

  _main(argc, argv, envp);
  v6 = 121;
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Bingo Simulator!\n");
  while ( v6 == 121 )
  {
    generate_card(v8);
    for ( i = 0; i <= 74; ++i )
      v7[i] = 0;
    v11 = 0;
    while ( !v11 )
    {
      generate_numbers(v7);
      v9 = v7[rand() % 75];
      if ( (unsigned int)check_card(v8, v9) )
      {
        printf("Number drawn: %d\n", v9);
        for ( j = 0; j <= 4; ++j )
        {
          for ( k = 0; k <= 4; ++k )
          {
            if ( v9 == v8[5 * j + k] )
              v8[5 * j + k] = -1;
          }
        }
        print_card(v8);
        v11 = check_bingo(v8);
        if ( v11 > 0 )
          printf("Bingo! You won with %d numbers drawn!\n", (unsigned int)(75 - v11));
      }
    }
    printf("Would you like to play again? (y/n): ");
    v4 = __acrt_iob_func(0);
    fflush(v4);
    scanf("%c", &v6);
  }
  printf("Thank you for playing the Bingo Simulator!\n");
  return 0;
}
// 140001848: using guessed type __int64 __fastcall generate_card(_QWORD);
// 140001B16: using guessed type __int64 __fastcall print_card(_QWORD);
// 140001BF6: using guessed type __int64 __fastcall generate_numbers(_QWORD);
// 140001C68: using guessed type __int64 __fastcall check_card(_QWORD, _QWORD);
// 140001CDA: using guessed type __int64 __fastcall check_bingo(_QWORD);
// 140001F50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001601: using guessed type int var_80[27];
// 140001601: using guessed type int var_1B0[76];

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Math exercise ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int num1, num2, answer, user_answer;
    int correct_count = 0, incorrect_count = 0;
    char response[10];

    // Using the time function to seed the rand function for random number generation
    srand(time(NULL));

    printf("Welcome to the Math Exercise Program!\n");
    printf("Answer the following multiplication questions.\n");

    // Loop to generate 10 random multiplication questions
    for (int i = 0; i < 10; i++)
    {
        num1 = rand() % 11; // Generating a random number between 0 and 10
        num2 = rand() % 11;

        answer = num1 * num2;

        printf("\nQuestion #%d:\n", i + 1);
        printf("%d x %d = ", num1, num2);
        scanf("%d", &user_answer);

        // Checking if the user's answer matches the correct answer
        if (user_answer == answer)
        {
            printf("Congratulations! Your answer is correct!\n");
            correct_count++;
        }
        else
        {
            printf("Oops! Your answer is incorrect! The correct answer is %d.\n", answer);
            incorrect_count++;
        }

        // Delay of 1 second between questions
        sleep(1);
    }

    // Displaying the results of the exercise
    printf("\nExercise complete! Here are your results:\n");
    printf("Number of questions answered correctly: %d\n", correct_count);
    printf("Number of questions answered incorrectly: %d\n", incorrect_count);

    // Asking the user if they'd like to try again
    printf("\nWould you like to try again? (yes/no)\n");
    scanf("%s", response);

    // If user enters "yes," program will restart. Otherwise, program will exit.
    if (strcmp(response, "yes") == 0)
    {
        main();
    }
    else
    {
        printf("\nThank you for using the Math Exercise Program! Goodbye!\n");
        exit(0);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  const char **v4; // rdx
  int v5; // ecx
  const char **v6; // r8
  char Str1[10]; // [rsp+2Ah] [rbp-26h] BYREF
  int v9; // [rsp+34h] [rbp-1Ch] BYREF
  unsigned int v10; // [rsp+38h] [rbp-18h]
  unsigned int v11; // [rsp+3Ch] [rbp-14h]
  unsigned int v12; // [rsp+40h] [rbp-10h]
  int i; // [rsp+44h] [rbp-Ch]
  unsigned int v14; // [rsp+48h] [rbp-8h]
  unsigned int v15; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v15 = 0;
  v14 = 0;
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Math Exercise Program!\n");
  printf("Answer the following multiplication questions.\n");
  for ( i = 0; i <= 9; ++i )
  {
    v12 = rand() % 11;
    v11 = rand() % 11;
    v10 = v11 * v12;
    printf("\nQuestion #%d:\n", (unsigned int)(i + 1));
    printf("%d x %d = ", v12, v11);
    scanf("%d", &v9);
    if ( v10 == v9 )
    {
      printf("Congratulations! Your answer is correct!\n");
      ++v15;
    }
    else
    {
      printf("Oops! Your answer is incorrect! The correct answer is %d.\n", v10);
      ++v14;
    }
    sleep(1i64);
  }
  printf("\nExercise complete! Here are your results:\n");
  printf("Number of questions answered correctly: %d\n", v15);
  printf("Number of questions answered incorrectly: %d\n", v14);
  printf("\nWould you like to try again? (yes/no)\n");
  scanf("%s", Str1);
  if ( strcmp(Str1, "yes") )
  {
    printf("\nThank you for using the Math Exercise Program! Goodbye!\n");
    exit(0);
  }
  main(v5, v4, v6);
  return 0;
}
// 1400017D0: variable 'v5' is possibly undefined
// 1400017D0: variable 'v4' is possibly undefined
// 1400017D0: variable 'v6' is possibly undefined
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002910: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Remote control Vehicle Simulation ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  //Initialize random seed
  srand(time(0));
  
  //Initialize variables
  int speed = 0, direction = 0;
  
  //Display welcome message and instructions
  printf("Welcome to the Remote Control Vehicle Simulation!\n");
  printf("Use the arrow keys to control the vehicle.\n");
  printf("Press 'q' to quit.\n");
  
  //Loop until user quits
  while(1) {
    //Get user input
    char input;
    printf("Enter a command: ");
    scanf("%c", &input);
    
    //Handle user input
    switch(input) {
      case 'q':
        printf("Goodbye!\n");
        return 0;
      case 'w':
        speed++;
        break;
      case 's':
        speed--;
        break;
      case 'a':
        direction--;
        break;
      case 'd':
        direction++;
        break;
      default:
        printf("Invalid command. Try again.\n");
    }
    
    //Limit speed to 10
    if(speed > 10) {
      speed = 10;
      printf("Maximum speed reached.\n");
    }
    else if(speed < 0) {
      speed = 0;
      printf("Vehicle stopped.\n");
    }
    
    //Limit direction to 360 degrees
    if(direction > 360) {
      direction -= 360;
    }
    else if(direction < 0) {
      direction += 360;
    }
    
    //Simulate vehicle movement
    int distance = speed * 10;
    int time = distance / (rand() % 10 + 1);
    printf("Vehicle moving %d meters at %d kph in direction %d degrees...\n", distance, speed, direction);
    printf("Estimated time of arrival: %d seconds\n", time);
  }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5; // [rsp+2Fh] [rbp-11h] BYREF
  unsigned int v6; // [rsp+30h] [rbp-10h]
  int v7; // [rsp+34h] [rbp-Ch]
  int v8; // [rsp+38h] [rbp-8h]
  int v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v9 = 0;
  v8 = 0;
  printf("Welcome to the Remote Control Vehicle Simulation!\n");
  printf("Use the arrow keys to control the vehicle.\n");
  printf("Press 'q' to quit.\n");
  while ( 1 )
  {
    printf("Enter a command: ");
    scanf("%c", &v5);
    switch ( v5 )
    {
      case 'a':
        --v8;
        break;
      case 'd':
        ++v8;
        break;
      case 'q':
        printf("Goodbye!\n");
        return 0;
      case 's':
        --v9;
        break;
      case 'w':
        ++v9;
        break;
      default:
        printf("Invalid command. Try again.\n");
        break;
    }
    if ( v9 <= 10 )
    {
      if ( v9 < 0 )
      {
        v9 = 0;
        printf("Vehicle stopped.\n");
      }
    }
    else
    {
      v9 = 10;
      printf("Maximum speed reached.\n");
    }
    if ( v8 <= 360 )
      v8 += v8 < 0 ? 0x168 : 0;
    else
      v8 -= 360;
    v7 = 10 * v9;
    v6 = v7 / (rand() % 10 + 1);
    printf(
      "Vehicle moving %d meters at %d kph in direction %d degrees...\n",
      (unsigned int)v7,
      (unsigned int)v9,
      (unsigned int)v8);
    printf("Estimated time of arrival: %d seconds\n", v6);
  }
}
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Email Client ; Style: recursive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct email {
    char *from;
    char *to;
    char *subject;
    char *message;
    struct email *next;
};

struct email *createEmail(char *from, char *to, char *subject, char *message) {
    struct email *newemail = malloc(sizeof(struct email));
    newemail->from = strdup(from);
    newemail->to = strdup(to);
    newemail->subject = strdup(subject);
    newemail->message = strdup(message);
    newemail->next = NULL;

    return newemail;
}

struct email *addEmail(struct email *head, char *from, char *to, char *subject, char *message) {
    if (head == NULL) {
        return createEmail(from, to, subject, message);
    }

    head->next = addEmail(head->next, from, to, subject, message);

    return head;
}

void printEmail(struct email *email) {
    printf("From: %s\nTo: %s\nSubject: %s\nMessage: %s\n", email->from, email->to, email->subject, email->message);
}

void printAllEmails(struct email *head) {
    if (head == NULL) {
        printf("No emails found.\n");
        return;
    }

    printEmail(head);
    printf("\n");

    printAllEmails(head->next);
}

void deleteEmail(struct email *head, char *search) {
    if (head == NULL) {
        printf("Email not found.\n");
        return;
    }

    if (strcmp(head->subject, search) == 0) {
        struct email *temp = head;
        head = head->next;
        free(temp);
        printf("Email deleted.\n");
        return;
    }

    deleteEmail(head->next, search);
}

int main() {
    struct email *head = NULL;

    head = addEmail(head, "user1@example.com", "user2@example.com", "Meeting Recap", "Hello, here is the summary of our meeting:\n- Discussed project timeline\n- Assigned tasks for next week\n\nBest,\nUser1");
    head = addEmail(head, "user2@example.com", "user1@example.com", "Project Update", "Hey User1,\nJust wanted to update you on the project status. We are making good progress and should have everything done on time.\n\nThanks,\nUser2");
    head = addEmail(head, "user3@example.com", "user1@example.com", "Question about project", "Hi User1,\nI had a question about the project. Are we planning on using the new API for this?\n\nThanks,\nUser3");

    printf("All Emails:\n");
    printAllEmails(head);

    deleteEmail(head, "Project Update");

    printf("\nUpdated Emails:\n");
    printAllEmails(head);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall addEmail(_DWORD, _DWORD, _DWORD, _DWORD, __int64); // weak
__int64 __fastcall printAllEmails(_QWORD); // weak
__int64 __fastcall deleteEmail(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017C9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int v4; // eax
  __int64 v6; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  v3 = addEmail(
         0,
         (unsigned int)"user1@example.com",
         (unsigned int)"user2@example.com",
         (unsigned int)"Meeting Recap",
         (__int64)"Hello, here is the summary of our meeting:\n"
                  "- Discussed project timeline\n"
                  "- Assigned tasks for next week\n"
                  "\n"
                  "Best,\n"
                  "User1");
  v4 = addEmail(
         v3,
         (unsigned int)"user2@example.com",
         (unsigned int)"user1@example.com",
         (unsigned int)"Project Update",
         (__int64)"Hey User1,\n"
                  "Just wanted to update you on the project status. We are making good progress and should have everythin"
                  "g done on time.\n"
                  "\n"
                  "Thanks,\n"
                  "User2");
  v6 = addEmail(
         v4,
         (unsigned int)"user3@example.com",
         (unsigned int)"user1@example.com",
         (unsigned int)"Question about project",
         (__int64)"Hi User1,\n"
                  "I had a question about the project. Are we planning on using the new API for this?\n"
                  "\n"
                  "Thanks,\n"
                  "User3");
  printf("All Emails:\n");
  printAllEmails(v6);
  deleteEmail(v6, "Project Update");
  printf("\nUpdated Emails:\n");
  printAllEmails(v6);
  return 0;
}
// 140001625: using guessed type __int64 __fastcall addEmail(_DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 1400016EA: using guessed type __int64 __fastcall printAllEmails(_QWORD);
// 14000173D: using guessed type __int64 __fastcall deleteEmail(_QWORD, _QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: surrealist
# include <stdio.h>
# include <stdlib.h>
# include <string.h>

struct xml_element {
  char *name;
  char *value;
  struct xml_element *child;
  struct xml_element *next;
};

void display_xml_tree(struct xml_element *root, int depth) {
  if (root == NULL) {
    return;
  }

  for (int i = 0; i < depth; i++) {
    printf("  ");
  }

  printf("<%s>", root->name);

  if (root->child == NULL) {
    printf("%s", root->value);
  }

  printf("\n");

  display_xml_tree(root->child, depth + 1);

  for (struct xml_element *e = root->next; e != NULL; e = e->next) {
    display_xml_tree(e, depth);
  }

  for (int i = 0; i < depth; i++) {
    printf("  ");
  }

  printf("</%s>\n", root->name);
}

void free_xml_tree(struct xml_element *root) {
  if (root == NULL) {
    return;
  }

  free_xml_tree(root->child);
  free_xml_tree(root->next);
  free(root->name);
  free(root->value);
  free(root);
}

void parse_xml_element(char *xml, struct xml_element *el) {
  int tag_start = 1;

  // Find the element name
  for (int i = 1;; i++) {
    if (xml[i] == ' ' || xml[i] == '>') {
      el->name = malloc(i - 1);
      strncpy(el->name, xml + 1, i - 1);
      break;
    }
  }

  // Walk through the attributes
  for (int i = 1;; i++) {
    if (xml[i] == '>') {
      tag_start = i;
      break;
    }
  }

  for (int i = tag_start + 1;; i++) {
    if (xml[i] == '=') {
      int value_start = i + 2;

      while (xml[value_start] == ' ' || xml[value_start] == '"') {
        value_start++;
      }

      for (int j = value_start; j < strlen(xml); j++) {
        if (xml[j] == '"') {
          el->value = malloc(j - value_start);
          strncpy(el->value, xml + value_start, j - value_start);
          break;
        }
      }
    }

    if (xml[i] == '/' && xml[i + 1] == '>') {
      return;
    }

    if (xml[i] == '>') {
      if (xml[i - 1] == '/') {
        return;
      }

      int child_start = i + 1;
      while (xml[child_start] == ' ') {
        child_start++;
      }

      el->child = malloc(sizeof(struct xml_element));
      parse_xml_element(xml + child_start, el->child);
      struct xml_element *current = el->child;

      while (current != NULL) {
        if (current->next == NULL) {
          current->next = malloc(sizeof(struct xml_element));
          parse_xml_element(xml + i + 1, current->next);
          break;
        }

        current = current->next;
      }

      return;
    }
  }
}

int main() {
  char *xml = "<html><head><title>Welcome to Surrealist Programming</title></head><body><h1>Coding in Dreamland</h1><p>This is a surrealistic example of an XML Parser program.</p></body></html>";

  struct xml_element root;
  memset(&root, 0, sizeof(struct xml_element));

  parse_xml_element(xml, &root);
  display_xml_tree(&root, 0);
  free_xml_tree(&root);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall display_xml_tree(_QWORD, _QWORD); // weak
__int64 __fastcall free_xml_tree(_QWORD); // weak
__int64 __fastcall parse_xml_element(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memset(void *, int Val, size_t Size);


//----- (00000001400019CD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[40]; // [rsp+20h] [rbp-30h] BYREF
  const char *v5; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  v5 = "<html><head><title>Welcome to Surrealist Programming</title></head><body><h1>Coding in Dreamland</h1><p>This is a"
       " surrealistic example of an XML Parser program.</p></body></html>";
  memset(v4, 0, 0x20ui64);
  parse_xml_element(
    "<html><head><title>Welcome to Surrealist Programming</title></head><body><h1>Coding in Dreamland</h1><p>This is a su"
    "rrealistic example of an XML Parser program.</p></body></html>",
    v4);
  display_xml_tree(v4, 0i64);
  free_xml_tree(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall display_xml_tree(_QWORD, _QWORD);
// 1400016AA: using guessed type __int64 __fastcall free_xml_tree(_QWORD);
// 14000170E: using guessed type __int64 __fastcall parse_xml_element(_QWORD, _QWORD);
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Expense Tracker ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_EXPENSES 100

struct Expense {
    int id;
    char name[50];
    float cost;
    int year;
    int month;
    int day;
};

// Function to add new expense
void addExpense(struct Expense expenses[], int *totalExpenses) {
    if (*totalExpenses >= MAX_EXPENSES) {
        printf("Maximum number of expenses reached!\n");
        return;
    }

    struct Expense newExpense;

    // Get expense details from user
    printf("Enter name of expense: ");
    scanf("%49s", newExpense.name);
    printf("Enter cost of expense: $");
    scanf("%f", &newExpense.cost);
    printf("Enter date of expense (YYYY/MM/DD): ");
    scanf("%d/%d/%d", &newExpense.year, &newExpense.month, &newExpense.day);

    newExpense.id = *totalExpenses + 1;

    expenses[*totalExpenses] = newExpense;
    (*totalExpenses)++;

    printf("Expense added successfully!\n");
}

// Function to display all expenses
void displayExpenses(struct Expense expenses[], int totalExpenses) {
    if (totalExpenses == 0) {
        printf("No expenses recorded yet.\n");
        return;
    }

    printf("%-5s%-20s%-15s%-15s\n", "ID", "Name", "Cost", "Date");

    for (int i = 0; i < totalExpenses; i++) {
        printf("%-5d%-20s$%-14.2f%4d/%02d/%02d\n",
                expenses[i].id, expenses[i].name,
                expenses[i].cost, expenses[i].year, expenses[i].month, expenses[i].day);
    }
}

// Function to find and display expenses by date
void displayExpensesByDate(struct Expense expenses[], int totalExpenses, int year, int month, int day) {
    printf("Expenses for %d/%02d/%02d:\n", year, month, day);

    for (int i = 0; i < totalExpenses; i++) {
        if (expenses[i].year == year && expenses[i].month == month && expenses[i].day == day) {
            printf("%-5d%-20s$%-14.2f\n", expenses[i].id, expenses[i].name, expenses[i].cost);
        }
    }
}

int main() {
    struct Expense expenses[MAX_EXPENSES] = {0};
    int totalExpenses = 0;

    char menuChoice;
    int year, month, day;

    printf("====================\n");
    printf("Futuristic Expense Tracker\n");
    printf("====================\n");

    // Display menu and take user input
    do {
        printf("\nChoose an option:\n");
        printf("1) Add a new expense\n");
        printf("2) Display all expenses\n");
        printf("3) Show expenses by date\n");
        printf("4) Quit program\n");
        printf("> ");
        scanf(" %c", &menuChoice);

        // Handle menu choice
        switch (menuChoice) {
            case '1':
                addExpense(expenses, &totalExpenses);
                break;
            case '2':
                displayExpenses(expenses, totalExpenses);
                break;
            case '3':
                printf("Enter date to show expenses (YYYY/MM/DD): ");
                scanf("%d/%d/%d", &year, &month, &day);
                displayExpensesByDate(expenses, totalExpenses, year, month, day);
                break;
            case '4':
                printf("Thank you for using Futuristic Expense Tracker!\n");
                break;
            default:
                printf("Invalid input. Please choose again.\n");
                break;
        }
    } while (menuChoice != '4');

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addExpense(_QWORD, _QWORD); // weak
__int64 __fastcall displayExpenses(_QWORD, _QWORD); // weak
__int64 __fastcall displayExpensesByDate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A26) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+3Ch] [rbp-44h] BYREF
  int v5; // [rsp+40h] [rbp-40h] BYREF
  int v6; // [rsp+44h] [rbp-3Ch] BYREF
  char v7; // [rsp+4Bh] [rbp-35h] BYREF
  unsigned int v8; // [rsp+4Ch] [rbp-34h] BYREF
  char v9[7216]; // [rsp+50h] [rbp-30h] BYREF

  _main(argc, argv, envp);
  memset(v9, 0, 0x1C20ui64);
  v8 = 0;
  printf("====================\n");
  printf("Futuristic Expense Tracker\n");
  printf("====================\n");
  do
  {
    printf("\nChoose an option:\n");
    printf("1) Add a new expense\n");
    printf("2) Display all expenses\n");
    printf("3) Show expenses by date\n");
    printf("4) Quit program\n");
    printf("> ");
    scanf(" %c", &v7);
    if ( v7 == 52 )
    {
      printf("Thank you for using Futuristic Expense Tracker!\n");
    }
    else
    {
      if ( v7 <= 52 )
      {
        if ( v7 == 51 )
        {
          printf("Enter date to show expenses (YYYY/MM/DD): ");
          scanf("%d/%d/%d", &v6, &v5, &v4);
          displayExpensesByDate((unsigned int)v9, v8, v6, v5, v4);
          continue;
        }
        if ( v7 <= 51 )
        {
          if ( v7 == 49 )
          {
            addExpense(v9, &v8);
            continue;
          }
          if ( v7 == 50 )
          {
            displayExpenses(v9, v8);
            continue;
          }
        }
      }
      printf("Invalid input. Please choose again.\n");
    }
  }
  while ( v7 != 52 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall addExpense(_QWORD, _QWORD);
// 14000173F: using guessed type __int64 __fastcall displayExpenses(_QWORD, _QWORD);
// 1400018BC: using guessed type __int64 __fastcall displayExpensesByDate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001CA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001A26: using guessed type int var_1C3C;

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Recursive ; Style: secure
#include <stdio.h>
#include <stdlib.h>

int fibonacci(int n) {
  if (n < 2) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}

int main() {
  int n, i;
  printf("Enter the number of terms: ");
  scanf("%d", &n);
  printf("Fibonacci Series: ");
  for (i = 0; i < n; i++) {
    printf("%d ", fibonacci(i));
  }
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall fibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001620) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+28h] [rbp-8h] BYREF
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of terms: ");
  scanf("%d", &v5);
  printf("Fibonacci Series: ");
  for ( i = 0; (int)i < v5; ++i )
  {
    v3 = fibonacci(i);
    printf("%d ", v3);
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Recursive ; Style: immersive
#include <stdio.h>

void recursiveCountdown(int n) {
    // base case
    if (n == 0) {
        printf("Blastoff!\n");
        return;
    } else {
        printf("%d\n", n);
        recursiveCountdown(n-1);
    }
}

int main() {
    int countdownFrom;

    printf("Please enter a number to countdown from: ");
    scanf("%d", &countdownFrom);

    printf("Counting down...\n");

    recursiveCountdown(countdownFrom);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall recursiveCountdown(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000162A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Please enter a number to countdown from: ");
  scanf("%d", &v4);
  printf("Counting down...\n");
  recursiveCountdown(v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall recursiveCountdown(_QWORD);
// 140001730: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: A* Pathfinding Algorithm ; Style: surprised
#include <stdio.h>
#define ROW 10
#define COL 10
int visit[ROW][COL];
int grid[ROW][COL];
int shortestPath = 0;

// structure for holding coordinates
struct point {
    int x; 
    int y; 
};

void AStarPathFinding(struct point start, struct point dest) {

    // initialization
    struct point q[ROW * COL];
    int f = 0, r = 0;
    q[r++] = start;
    visit[start.x][start.y] = 1;

    // directions: right, up, left, down
    int dx[4] = {0, -1, 0, 1};
    int dy[4] = {1, 0, -1, 0};
    while (f < r) {

        int k = 0;
        int minDist = ROW * COL + 1;

        // get the closest neighbors to the goal
        for (int i = 0; i < 4; i++) {

            struct point cur = q[f];
            struct point next = {cur.x + dx[i], cur.y + dy[i]};

            if (next.x < 0 || next.x >= ROW || next.y < 0 || next.y >= COL) {
                continue;
            }

            // find Manhattan distance
            int dist = abs(next.x - dest.x) + abs(next.y - dest.y);

            // update shortest path
            if (dist < minDist && !visit[next.x][next.y] && grid[next.x][next.y]) {
                k = i;
                minDist = dist;
            }
        }

        // record the visit and add the next point to the queue
        struct point cur = q[f];
        f++;
        visit[cur.x][cur.y] = 1;

        // update shortest path
        shortestPath += minDist;

        if (cur.x == dest.x && cur.y == dest.y) {
            return;
        }

        q[r++] = (struct point){cur.x + dx[k], cur.y + dy[k]};

    }
}

int main() {

    // create grid map example
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < COL; j++) {
            grid[i][j] = 1;
        }
    }

    // mark obstacles
    grid[3][3] = 0;
    grid[4][3] = 0;
    grid[5][3] = 0;

    // mark start and end points
    struct point start = {0, 0};
    struct point dest = {9, 9};

    // run A* pathfinding algorithm
    AStarPathFinding(start, dest);

    // print shortest path
    printf("Shortest path: %d\n", shortestPath);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall AStarPathFinding(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_DWORD grid[33]; // weak
int dword_14000F264; // weak
int dword_14000F28C; // weak
int dword_14000F2B4; // weak
int shortestPath; // weak


//----- (0000000140001884) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      grid[10 * i + j] = 1;
  }
  dword_14000F264 = 0;
  dword_14000F28C = 0;
  dword_14000F2B4 = 0;
  AStarPathFinding(0i64, 0x900000009i64);
  printf("Shortest path: %d\n", (unsigned int)shortestPath);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall AStarPathFinding(_QWORD, _QWORD);
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F1E0: using guessed type _DWORD grid[33];
// 14000F264: using guessed type int dword_14000F264;
// 14000F28C: using guessed type int dword_14000F28C;
// 14000F2B4: using guessed type int dword_14000F2B4;
// 14000F370: using guessed type int shortestPath;

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home light control ; Style: cheerful
#include <stdio.h>
#include <string.h>
#include <unistd.h>

/* Define macros for light control */
#define LIGHT_ON 1
#define LIGHT_OFF 0
#define BRIGHTNESS_HIGH 100
#define BRIGHTNESS_MEDIUM 50
#define BRIGHTNESS_LOW 10

int main() {
    int lightStatus = LIGHT_OFF;
    int brightnessLevel = BRIGHTNESS_MEDIUM;
    char input[10];

    printf("Welcome to your Smart Home Light Control\n");

    while (1) {
        printf("Enter 'on' to turn on the lights, 'off' to turn off the lights, or 'brightness' to change the brightness level\n");
        scanf("%s", input);

        if (strcmp(input, "on") == 0) {
            if (lightStatus == LIGHT_ON) {
                printf("Lights are already on!\n");
            } else {
                lightStatus = LIGHT_ON;
                printf("Turning on the lights...\n");
            }
        } else if (strcmp(input, "off") == 0) {
            if (lightStatus == LIGHT_OFF) {
                printf("Lights are already off!\n");
            } else {
                lightStatus = LIGHT_OFF;
                printf("Turning off the lights...\n");
            }
        } else if (strcmp(input, "brightness") == 0) {
            printf("Enter 'high' to set brightness to high, 'medium' to set brightness to medium, or 'low' to set brightness to low\n");
            scanf("%s", input);

            if (strcmp(input, "high") == 0) {
                brightnessLevel = BRIGHTNESS_HIGH;
                printf("Brightness level set to high\n");
            } else if (strcmp(input, "medium") == 0) {
                brightnessLevel = BRIGHTNESS_MEDIUM;
                printf("Brightness level set to medium\n");
            } else if (strcmp(input, "low") == 0) {
                brightnessLevel = BRIGHTNESS_LOW;
                printf("Brightness level set to low\n");
            } else {
                printf("Invalid input. Try again.\n");
            }
        } else {
            printf("Invalid input. Try again.\n");
        }

        // Simulate light transition
        if (lightStatus == LIGHT_ON) {
            printf("Lights are now on with a brightness level of %d%%\n", brightnessLevel);
        } else {
            printf("Lights are now off.\n");
        }

        // Sleep for 3 seconds
        sleep(3);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[10]; // [rsp+2Eh] [rbp-12h] BYREF
  unsigned int v5; // [rsp+38h] [rbp-8h]
  int v6; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  v5 = 50;
  printf("Welcome to your Smart Home Light Control\n");
  while ( 1 )
  {
    printf("Enter 'on' to turn on the lights, 'off' to turn off the lights, or 'brightness' to change the brightness level\n");
    scanf("%s", Str1);
    if ( !strcmp(Str1, "on") )
    {
      if ( v6 == 1 )
      {
        printf("Lights are already on!\n");
      }
      else
      {
        v6 = 1;
        printf("Turning on the lights...\n");
      }
      goto LABEL_18;
    }
    if ( !strcmp(Str1, "off") )
    {
      if ( v6 )
      {
        v6 = 0;
        printf("Turning off the lights...\n");
      }
      else
      {
        printf("Lights are already off!\n");
      }
      goto LABEL_18;
    }
    if ( strcmp(Str1, "brightness") )
      goto LABEL_17;
    printf(
      "Enter 'high' to set brightness to high, 'medium' to set brightness to medium, or 'low' to set brightness to low\n");
    scanf("%s", Str1);
    if ( !strcmp(Str1, "high") )
    {
      v5 = 100;
      printf("Brightness level set to high\n");
      goto LABEL_18;
    }
    if ( !strcmp(Str1, "medium") )
    {
      v5 = 50;
      printf("Brightness level set to medium\n");
      goto LABEL_18;
    }
    if ( !strcmp(Str1, "low") )
    {
      v5 = 10;
      printf("Brightness level set to low\n");
    }
    else
    {
LABEL_17:
      printf("Invalid input. Try again.\n");
    }
LABEL_18:
    if ( v6 == 1 )
      printf("Lights are now on with a brightness level of %d%%\n", v5);
    else
      printf("Lights are now off.\n");
    sleep(3i64);
  }
}
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002900: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedural Space Adventure ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int choice;
    int fuel = 100;
    int distance = 0;
    int oxygen = 100;
    int alien = 0;
    int found = 0;
    int randnum;
    srand(time(NULL));
    
    printf("Welcome to your Procedural Space Adventure!\n");
    printf("--------------------------------------------\n");
    printf("You are the captain of the spaceship U.S.S. Explorer.\n");
    printf("You are on a mission to explore uncharted parts of the galaxy.\n");
    printf("You have only 100 units of fuel and oxygen.\n");
    printf("Your mission is to find a habitable planet and return to Earth.\n");
    printf("--------------------------------------------\n");

    while (distance < 20) {
        printf("\nWhat do you want to do?\n");
        printf("1. Fly forward (costs 10 fuel, 5 oxygen)\n");
        printf("2. Scan for a planet (costs 20 fuel)\n");
        printf("3. Check your resources\n");
        printf("4. Quit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        printf("\n");

        switch (choice) {
            case 1:
                if (fuel < 10 || oxygen < 5) {
                    printf("You don't have enough resources to fly forward!\n");
                } else {
                    fuel -= 10;
                    oxygen -= 5;
                    distance++;
                    if (alien == 1) {
                        randnum = rand() % 10;
                        if (randnum > 5) {
                            printf("You encountered an alien and it attacked your ship!\n");
                            fuel -= 30;
                            oxygen -= 20;
                            alien = 0;
                        } else {
                            printf("You encountered an alien but it seems to be friendly.\n");
                        }
                    } else {
                        randnum = rand() % 10;
                        if (randnum > 7) {
                            printf("You encountered an alien!\n");
                            alien = 1;
                        }
                    }
                    printf("You have flown forward one unit.\n");
                }
                break;
            case 2:
                if (fuel < 20) {
                    printf("You don't have enough fuel to scan for a planet!\n");
                } else {
                    fuel -= 20;
                    randnum = rand() % 10;
                    if (randnum > 5) {
                        printf("You found a habitable planet!\n");
                        found = 1;
                    } else {
                        printf("You didn't find any habitable planets.\n");
                    }
                }
                break;
            case 3:
                printf("Fuel: %d\n", fuel);
                printf("Oxygen: %d\n", oxygen);
                printf("Distance from Earth: %d units\n", distance);
                if (alien == 1) {
                    printf("There is an alien aboard your ship.\n");
                }
                break;
            case 4:
                printf("Quitting...\n");
                return 0;
            default:
                printf("Invalid choice! Try again.\n");
                break;
        }

        if (found == 1) {
            break;
        }

        if (fuel <= 0 || oxygen <= 0) {
            printf("You ran out of fuel or oxygen and can't continue your mission anymore!\n");
            return 0;
        }
    }

    printf("\nCongratulations! You have successfully found a habitable planet and returned to Earth!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-1Ch] BYREF
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+2Ch] [rbp-14h]
  int v8; // [rsp+30h] [rbp-10h]
  int v9; // [rsp+34h] [rbp-Ch]
  unsigned int v10; // [rsp+38h] [rbp-8h]
  int v11; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v11 = 100;
  v10 = 0;
  v9 = 100;
  v8 = 0;
  v7 = 0;
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to your Procedural Space Adventure!\n");
  printf("--------------------------------------------\n");
  printf("You are the captain of the spaceship U.S.S. Explorer.\n");
  printf("You are on a mission to explore uncharted parts of the galaxy.\n");
  printf("You have only 100 units of fuel and oxygen.\n");
  printf("Your mission is to find a habitable planet and return to Earth.\n");
  printf("--------------------------------------------\n");
  while ( (int)v10 <= 19 )
  {
    printf("\nWhat do you want to do?\n");
    printf("1. Fly forward (costs 10 fuel, 5 oxygen)\n");
    printf("2. Scan for a planet (costs 20 fuel)\n");
    printf("3. Check your resources\n");
    printf("4. Quit\n");
    printf("Enter your choice: ");
    scanf("%d", &v5);
    printf("\n");
    if ( v5 == 4 )
    {
      printf("Quitting...\n");
      return 0;
    }
    if ( v5 > 4 )
    {
LABEL_26:
      printf("Invalid choice! Try again.\n");
      goto LABEL_27;
    }
    switch ( v5 )
    {
      case 3:
        printf("Fuel: %d\n", (unsigned int)v11);
        printf("Oxygen: %d\n", (unsigned int)v9);
        printf("Distance from Earth: %d units\n", v10);
        if ( v8 == 1 )
          printf("There is an alien aboard your ship.\n");
        break;
      case 1:
        if ( v11 > 9 && v9 > 4 )
        {
          v11 -= 10;
          v9 -= 5;
          ++v10;
          if ( v8 == 1 )
          {
            v6 = rand() % 10;
            if ( v6 <= 5 )
            {
              printf("You encountered an alien but it seems to be friendly.\n");
            }
            else
            {
              printf("You encountered an alien and it attacked your ship!\n");
              v11 -= 30;
              v9 -= 20;
              v8 = 0;
            }
          }
          else
          {
            v6 = rand() % 10;
            if ( v6 > 7 )
            {
              printf("You encountered an alien!\n");
              v8 = 1;
            }
          }
          printf("You have flown forward one unit.\n");
        }
        else
        {
          printf("You don't have enough resources to fly forward!\n");
        }
        break;
      case 2:
        if ( v11 > 19 )
        {
          v11 -= 20;
          v6 = rand() % 10;
          if ( v6 <= 5 )
          {
            printf("You didn't find any habitable planets.\n");
          }
          else
          {
            printf("You found a habitable planet!\n");
            v7 = 1;
          }
        }
        else
        {
          printf("You don't have enough fuel to scan for a planet!\n");
        }
        break;
      default:
        goto LABEL_26;
    }
LABEL_27:
    if ( v7 == 1 )
      break;
    if ( v11 <= 0 || v9 <= 0 )
    {
      printf("You ran out of fuel or oxygen and can't continue your mission anymore!\n");
      return 0;
    }
  }
  printf("\nCongratulations! You have successfully found a habitable planet and returned to Earth!\n");
  return 0;
}
// 140001750: conditional instruction was optimized away because %var_1C.4<3
// 140001A70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedural Space Adventure ; Style: shocked
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

// Function prototypes
void title_screen();
void prologue();
void random_planet();
void space_battle();

int main()
{
    // Seed the random number generator
    srand(time(NULL));
    
    // Title screen
    title_screen();
    
    // Prologue
    prologue();
    
    // Random planet
    random_planet();
    
    // Space battle
    space_battle();
    
    printf("Congratulations! You have completed the space adventure!\n");
    
    return 0;
}

// Prints the title screen
void title_screen()
{
    printf("******************\n");
    printf("** SPACE ADVENTURE **\n");
    printf("******************\n\n");
}

// Prints the prologue
void prologue()
{
    printf("You are a space adventurer, traveling through the galaxy in search of riches and adventure.\n");
    printf("Your ship is the fastest in the galaxy, equipped with powerful weapons and shields.\n");
    printf("As you travel through space, you receive a distress signal from a nearby planet...\n\n");
}

// Generates a random planet for the player to explore
void random_planet()
{
    // Generate a random number between 1 and 4
    int planet_choice = rand()%4 + 1;
    
    printf("You have arrived at planet %d!\n", planet_choice);
    
    switch(planet_choice)
    {
        case 1:
            printf("This planet is covered in ice and snow. There may be hidden treasures buried beneath the ice...\n");
            break;
        case 2:
            printf("This planet is a desert wasteland. The scorching heat will be a challenge to overcome...\n");
            break;
        case 3:
            printf("This planet is a lush forest world, full of dangerous predators and hidden caves...\n");
            break;
        case 4:
            printf("This planet is a volcanic hellscape. The extreme heat and deadly lava flows will test your skills...\n");
            break;
    }
    
    printf("\n");
}

// Simulates a space battle with an alien ship
void space_battle()
{
    printf("As you leave the planet, you are attacked by an alien ship!\n");
    printf("You must use your ship's weapons and shields to defeat the alien.\n");
    
    // Player's ship health
    int player_health = 100;
    
    // Alien ship health
    int alien_health = 50;
    
    // Loop until one ship's health reaches 0
    while(player_health > 0 && alien_health > 0)
    {
        printf("Your ship health: %d\n", player_health);
        printf("Alien ship health: %d\n\n", alien_health);
        
        // Player attacks first
        int player_attack = rand()%20 + 10;
        printf("You fire your ship's weapons and deal %d damage to the alien!\n", player_attack);
        alien_health -= player_attack;
        
        // Check if alien ship has been destroyed
        if(alien_health <= 0)
        {
            printf("The alien ship has been destroyed! You have emerged victorious!\n");
            return;
        }
        
        // Alien attacks next
        int alien_attack = rand()%15 + 5;
        printf("The alien ship fires its weapons and deals %d damage to your ship!\n", alien_attack);
        player_health -= alien_attack;
        
        // Check if player's ship has been destroyed
        if(player_health <= 0)
        {
            printf("Your ship has been destroyed! Game over.\n");
            exit(0);
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 title_screen(void); // weak
__int64 prologue(void); // weak
__int64 random_planet(void); // weak
__int64 space_battle(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  title_screen();
  prologue();
  random_planet();
  space_battle();
  printf("Congratulations! You have completed the space adventure!\n");
  return 0;
}
// 1400015FC: using guessed type __int64 title_screen(void);
// 140001638: using guessed type __int64 prologue(void);
// 140001674: using guessed type __int64 random_planet(void);
// 140001725: using guessed type __int64 space_battle(void);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Light Controller ; Style: rigorous
#include <stdio.h>

//function to switch lights and print the current state
void switchLights(int redTime, int greenTime, int yellowTime, int initialLight){
    int counter = 0; 
    int lightIndex = initialLight;
    while(counter < 10){
        switch(lightIndex){
            case 0:
                printf("Light is Green\n");
                counter += greenTime;
                break;
            case 1:
                printf("Light is Yellow\n");
                counter += yellowTime;
                break;
            case 2:
                printf("Light is Red\n");
                counter += redTime;
        }
        lightIndex = (lightIndex + 1) % 3;
    }
}

//main function
int main(){
    //initialize variables
    int redTime = 5;
    int greenTime = 10;
    int yellowTime = 2;
    int initialLight = 0;

    //call switchLights function 
    switchLights(redTime, greenTime, yellowTime, initialLight);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall switchLights(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001654) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  switchLights(5i64, 10i64, 2i64, 0i64, 0x200000000i64, 0x50000000Ai64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall switchLights(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database simulation ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_RECORDS 100

// Define struct for a single record
typedef struct {
    char name[50];
    int age;
    char occupation[50];
} Record;

// Declare global variables
Record db[MAX_RECORDS];
int num_records = 0;

// Function to add a new record to the database
void add_record() {
    if (num_records >= MAX_RECORDS) {
        printf("Database is full!\n");
        return;
    }

    // Prompt user for record data
    Record new_record;
    printf("Enter name: ");
    fgets(new_record.name, 50, stdin);
    strtok(new_record.name, "\n"); // Remove newline character
    printf("Enter age: ");
    scanf("%d", &new_record.age);
    getchar(); // Clear input buffer before reading occupation
    printf("Enter occupation: ");
    fgets(new_record.occupation, 50, stdin);
    strtok(new_record.occupation, "\n"); // Remove newline character

    // Add new record to database
    db[num_records] = new_record;
    num_records++;
    printf("Record added to database.\n");
}

// Function to delete a record from the database
void delete_record() {
    // Prompt user for name of record to delete
    char name[50];
    printf("Enter name of record to delete: ");
    fgets(name, 50, stdin);
    strtok(name, "\n"); // Remove newline character
    
    // Find record in database and delete it
    int i;
    for (i = 0; i < num_records; i++) {
        if (strcmp(db[i].name, name) == 0) {
            int j;
            for (j = i; j < num_records - 1; j++) {
                db[j] = db[j+1];
            }
            num_records--;
            printf("Record deleted from database.\n");
            return;
        }
    }
    printf("Record not found in database.\n");
}

// Function to modify a record in the database
void modify_record() {
    // Prompt user for name of record to modify
    char name[50];
    printf("Enter name of record to modify: ");
    fgets(name, 50, stdin);
    strtok(name, "\n"); // Remove newline character
    
    // Find record in database and prompt user for new data
    int i;
    for (i = 0; i < num_records; i++) {
        if (strcmp(db[i].name, name) == 0) {
            printf("Enter new age: ");
            scanf("%d", &db[i].age);
            getchar(); // Clear input buffer before reading occupation
            printf("Enter new occupation: ");
            fgets(db[i].occupation, 50, stdin);
            strtok(db[i].occupation, "\n"); // Remove newline character
            printf("Record updated.\n");
            return;
        }
    }
    printf("Record not found in database.\n");
}

// Function to search for a record in the database
void search_record() {
    // Prompt user for name to search for
    char name[50];
    printf("Enter name to search for: ");
    fgets(name, 50, stdin);
    strtok(name, "\n"); // Remove newline character
    
    // Search for record in database and print data if found
    int i;
    for (i = 0; i < num_records; i++) {
        if (strcmp(db[i].name, name) == 0) {
            printf("Name: %s\nAge: %d\nOccupation: %s\n", db[i].name, db[i].age, db[i].occupation);
            return;
        }
    }
    printf("Record not found in database.\n");
}

// Main function
int main() {
    int choice;
    printf("Welcome to the database simulation program!\n");

    while (1) {
        // Display menu and prompt user for choice
        printf("\nPlease select an option:\n");
        printf("1. Add record\n");
        printf("2. Delete record\n");
        printf("3. Modify record\n");
        printf("4. Search record\n");
        printf("5. Quit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        getchar(); // Clear input buffer

        // Execute user's chosen option
        switch (choice) {
            case 1:
                add_record();
                break;
            case 2:
                delete_record();
                break;
            case 3:
                modify_record();
                break;
            case 4:
                search_record();
                break;
            case 5:
                printf("Goodbye!\n");
                exit(0);
            default:
                printf("Invalid choice!\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_record(void); // weak
__int64 delete_record(void); // weak
__int64 modify_record(void); // weak
__int64 search_record(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001CA9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the database simulation program!\n");
  while ( 1 )
  {
    printf("\nPlease select an option:\n");
    printf("1. Add record\n");
    printf("2. Delete record\n");
    printf("3. Modify record\n");
    printf("4. Search record\n");
    printf("5. Quit\n");
    printf("Enter choice: ");
    scanf("%d", &v4);
    getchar();
    switch ( v4 )
    {
      case 1:
        add_record();
        break;
      case 2:
        delete_record();
        break;
      case 3:
        modify_record();
        break;
      case 4:
        search_record();
        break;
      case 5:
        printf("Goodbye!\n");
        exit(0);
      default:
        printf("Invalid choice!\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 add_record(void);
// 1400017A5: using guessed type __int64 delete_record(void);
// 140001984: using guessed type __int64 modify_record(void);
// 140001B4B: using guessed type __int64 search_record(void);
// 140001E70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Personal Finance Planner ; Style: calm
#include <stdio.h>

int main() {
   float monthly_income, monthly_expenses, savings_goal, total_savings;
   int months_to_goal;

   printf("Welcome to the Personal Finance Planner!\n");
   printf("Let's get started by entering your monthly income: ");
   scanf("%f", &monthly_income);
   printf("Great! Now enter your monthly expenses: ");
   scanf("%f", &monthly_expenses);
   printf("What is your savings goal? ");
   scanf("%f", &savings_goal);

   // Calculate the number of months needed to reach the savings goal
   total_savings=0;
   months_to_goal=0;

   while(total_savings < savings_goal) {
       total_savings += (monthly_income - monthly_expenses);
       months_to_goal++;
   }

   printf("\n*********************************************************\n");
   printf("Based on your monthly income and expenses, it will take %d months to reach your savings goal of $%.2f.\n", months_to_goal, savings_goal);
   printf("Here's a breakdown of how much you'll save each month:\n");

   // Calculate and display the monthly savings required to reach the goal
   float monthly_savings = savings_goal/months_to_goal;
   printf("\t\t$%.2f per month\n", monthly_savings);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+28h] [rbp-18h] BYREF
  float v5; // [rsp+2Ch] [rbp-14h] BYREF
  float v6; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v7; // [rsp+38h] [rbp-8h]
  float v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Personal Finance Planner!\n");
  printf("Let's get started by entering your monthly income: ");
  scanf("%f", &v6);
  printf("Great! Now enter your monthly expenses: ");
  scanf("%f", &v5);
  printf("What is your savings goal? ");
  scanf("%f", &v4);
  v8 = 0.0;
  v7 = 0;
  while ( v4 > v8 )
  {
    v8 = (float)(v6 - v5) + v8;
    ++v7;
  }
  printf("\n*********************************************************\n");
  printf(
    "Based on your monthly income and expenses, it will take %d months to reach your savings goal of $%.2f.\n",
    v7,
    v4);
  printf("Here's a breakdown of how much you'll save each month:\n");
  printf("\t\t$%.2f per month\n", (float)(v4 / (float)(int)v7));
  return 0;
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: random
#include <stdio.h>
#include <time.h>
#include <string.h>

struct diary {
    char date[20];
    char content[200];
};

int main() {
    struct diary entries[365];
    time_t currentTime;
    struct tm *localTime;
    char date[20];
    int i = 0;

    // Get current date
    time(&currentTime);
    localTime = localtime(&currentTime);
    strftime(date, sizeof(date), "%Y/%m/%d", localTime);

    // Initialize empty diary
    for (i = 0; i < 365; i++) {
        strcpy(entries[i].date, "");
        strcpy(entries[i].content, "");
    }

    // Main loop to interact with user
    while (1) {
        char option;
        printf("\nWelcome to your digital diary! Today is %s\n", date);
        printf("Enter an option:\n");
        printf("1 - Add a new entry\n");
        printf("2 - View all entries\n");
        printf("3 - Search for entries by date\n");
        printf("4 - Exit\n");
        scanf(" %c", &option);

        if (option == '1') {
            // Add a new entry
            char content[200];
            printf("Enter your thoughts for today: ");
            scanf(" %[^\n]s", content);
            strcpy(entries[i].date, date);
            strcpy(entries[i].content, content);
            i++;
            printf("Entry added.\n");
        } else if (option == '2') {
            // View all entries
            if (i == 0) {
                printf("No entries yet.\n");
            } else {
                printf("All entries:\n");
                for (int j = 0; j < i; j++) {
                    printf("Date: %s\n", entries[j].date);
                    printf("Content: %s\n", entries[j].content);
                }
            }
        } else if (option == '3') {
            // Search for entries by date
            char searchDate[20];
            printf("Enter the date you want to search for (YYYY/MM/DD): ");
            scanf(" %s", searchDate);
            int foundEntries = 0;
            for (int j = 0; j < i; j++) {
                if (strcmp(entries[j].date, searchDate) == 0) {
                    foundEntries++;
                    printf("Date: %s\n", entries[j].date);
                    printf("Content: %s\n", entries[j].content);
                }
            }
            if (foundEntries == 0) {
                printf("No entries found for that date.\n");
            }
        } else if (option == '4') {
            // Exit program
            printf("Goodbye!\n");
            break;
        } else {
            printf("Invalid option. Please try again.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static struct tm *__cdecl localtime(const time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strftime(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (0000000140001620) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Source[208]; // [rsp+20h] [rbp-60h] BYREF
  char Str2[31]; // [rsp+F0h] [rbp+70h] BYREF
  char v6; // [rsp+10Fh] [rbp+8Fh] BYREF
  char Buffer[24]; // [rsp+110h] [rbp+90h] BYREF
  time_t Time; // [rsp+128h] [rbp+A8h] BYREF
  char v9[80312]; // [rsp+130h] [rbp+B0h] BYREF
  struct tm *Tm; // [rsp+13AE8h] [rbp+13A68h]
  int k; // [rsp+13AF0h] [rbp+13A70h]
  int v12; // [rsp+13AF4h] [rbp+13A74h]
  int j; // [rsp+13AF8h] [rbp+13A78h]
  int i; // [rsp+13AFCh] [rbp+13A7Ch]

  _main(argc, argv, envp);
  i = 0;
  time(&Time);
  Tm = localtime(&Time);
  strftime(Buffer, 0x14ui64, "%Y/%m/%d", Tm);
  for ( i = 0; i <= 364; ++i )
  {
    v9[220 * i] = 0;
    v9[220 * i + 20] = 0;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          printf("\nWelcome to your digital diary! Today is %s\n", Buffer);
          printf("Enter an option:\n");
          printf("1 - Add a new entry\n");
          printf("2 - View all entries\n");
          printf("3 - Search for entries by date\n");
          printf("4 - Exit\n");
          scanf(" %c", &v6);
          if ( v6 != 49 )
            break;
          printf("Enter your thoughts for today: ");
          scanf(" %[^\n]s", Source);
          strcpy(&v9[220 * i], Buffer);
          strcpy(&v9[220 * i++ + 20], Source);
          printf("Entry added.\n");
        }
        if ( v6 != 50 )
          break;
        if ( i )
        {
          printf("All entries:\n");
          for ( j = 0; j < i; ++j )
          {
            printf("Date: %s\n", &v9[220 * j]);
            printf("Content: %s\n", &v9[220 * j + 20]);
          }
        }
        else
        {
          printf("No entries yet.\n");
        }
      }
      if ( v6 != 51 )
        break;
      printf("Enter the date you want to search for (YYYY/MM/DD): ");
      scanf(" %s", Str2);
      v12 = 0;
      for ( k = 0; k < i; ++k )
      {
        if ( !strcmp(&v9[220 * k], Str2) )
        {
          ++v12;
          printf("Date: %s\n", &v9[220 * k]);
          printf("Content: %s\n", &v9[220 * k + 20]);
        }
      }
      if ( !v12 )
        printf("No entries found for that date.\n");
    }
    if ( v6 == 52 )
      break;
    printf("Invalid option. Please try again.\n");
  }
  printf("Goodbye!\n");
  return 0;
}
// 140001AE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001620: using guessed type char var_139D0[80312];

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Ebook reader ; Style: excited
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50

typedef struct {
    char word[MAX_WORD_LENGTH];
    int count;
} Word;

int compare_words(const void* a, const void* b) {
    const Word* word1 = (const Word*)a;
    const Word* word2 = (const Word*)b;
    return word2->count - word1->count;
}

void display_exciting_message() {
    printf("\n\n\tWelcome to the C Ebook Reader!");
    printf("\n\tPrepare to embark on a thrilling journey through the world of C programming!");
    printf("\n\tFasten your seatbelt and get ready to learn some amazing concepts!");
}

void display_word_cloud(Word* words, int num_words) {
    printf("\n\n\tHere's a word cloud of the most frequently occurring words in the ebook:\n");
    for (int i = 0; i < num_words; i++) {
        for (int j = 0; j < words[i].count; j++) {
            printf("* ");
        }
        printf("%s\n", words[i].word);
    }
}

int main(int argc, char** argv) {
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    FILE* fp = fopen(argv[1], "r");
    if (!fp) {
        printf("Error: could not open file %s\n", argv[1]);
        return 1;
    }
    Word* words = malloc(sizeof(Word));
    int num_words = 0;
    char word[MAX_WORD_LENGTH] = { 0 };
    int c;
    while ((c = fgetc(fp)) != EOF) {
        if (isspace(c)) {
            if (strlen(word) > 0) {
                int found = 0;
                for (int i = 0; i < num_words; i++) {
                    if (strcmp(word, words[i].word) == 0) {
                        words[i].count++;
                        found = 1;
                        break;
                    }
                }
                if (!found || num_words == 0) {
                    num_words++;
                    words = realloc(words, num_words * sizeof(Word));
                    strcpy(words[num_words - 1].word, word);
                    words[num_words - 1].count = 1;
                }
            }
            memset(word, 0, sizeof(word));
        } else {
            strncat(word, &c, 1);
        }
    }
    qsort(words, num_words, sizeof(Word), compare_words);
    display_exciting_message();
    display_word_cloud(words, num_words);
    fclose(fp);
    free(words);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __cdecl compare_words(const void *, const void *); // idb
__int64 display_exciting_message(void); // weak
__int64 __fastcall display_word_cloud(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strncat(char *Destination, const char *Source, size_t Count);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl realloc(void *Block, size_t Size);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isspace)(int C);


//----- (00000001400016B2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int C; // [rsp+2Ch] [rbp-64h] BYREF
  char Str1[64]; // [rsp+30h] [rbp-60h] BYREF
  FILE *Stream; // [rsp+70h] [rbp-20h]
  int i; // [rsp+7Ch] [rbp-14h]
  int v8; // [rsp+80h] [rbp-10h]
  unsigned int v9; // [rsp+84h] [rbp-Ch]
  void *Block; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc == 2 )
  {
    Stream = fopen(argv[1], "r");
    if ( Stream )
    {
      Block = malloc(0x38ui64);
      v9 = 0;
      memset(Str1, 0, 50);
      while ( 1 )
      {
        C = fgetc(Stream);
        if ( C == -1 )
          break;
        if ( isspace(C) )
        {
          if ( Str1[0] )
          {
            v8 = 0;
            for ( i = 0; i < (int)v9; ++i )
            {
              if ( !strcmp(Str1, (const char *)Block + 56 * i) )
              {
                ++*((_DWORD *)Block + 14 * i + 13);
                v8 = 1;
                break;
              }
            }
            if ( !v8 || !v9 )
            {
              Block = realloc(Block, 56i64 * (int)++v9);
              strcpy((char *)Block + 56 * (int)v9 - 56, Str1);
              *((_DWORD *)Block + 14 * (int)v9 - 1) = 1;
            }
          }
          memset(Str1, 0, 0x32ui64);
        }
        else
        {
          strncat(Str1, (const char *)&C, 1ui64);
        }
      }
      qsort(Block, (int)v9, 0x38ui64, compare_words);
      display_exciting_message();
      display_word_cloud(Block, v9);
      fclose(Stream);
      free(Block);
      return 0;
    }
    else
    {
      printf("Error: could not open file %s\n", argv[1]);
      return 1;
    }
  }
  else
  {
    printf("Usage: %s <filename>\n", *argv);
    return 1;
  }
}
// 1400015C9: using guessed type __int64 display_exciting_message(void);
// 140001605: using guessed type __int64 __fastcall display_word_cloud(_QWORD, _QWORD);
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=149 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Periodic Table Quiz ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Define struct for element
typedef struct element {
    int atomic_number;
    char symbol[3];
    char name[20];
    float atomic_weight;
} Element;

// Define constants
#define NUM_ELEMENTS 118
#define NUM_QUESTIONS 10
#define MAX_SELECTIONS 4

// Declare global variables
Element elements[NUM_ELEMENTS];
int num_correct = 0;
int num_incorrect = 0;

// Define function prototypes
void load_elements();
void shuffle_elements();
void generate_question(int question_number);
void print_selections(Element correct_element, Element selections[MAX_SELECTIONS]);
void print_results(float time_taken);

int main() {
    // Load elements and shuffle them
    load_elements();
    shuffle_elements();
    
    // Generate and ask questions
    printf("\n--- Welcome to the Periodic Table Quiz! ---\n");
    printf("\nYou will be asked %d multiple-choice questions about the periodic table.\n", NUM_QUESTIONS);
    printf("You will have 10 seconds to answer each question.\n\n");
    for (int i = 1; i <= NUM_QUESTIONS; i++) {
        generate_question(i);
    }
    
    // Print results
    float time_taken = (float)(clock()) / CLOCKS_PER_SEC;
    printf("\n--- RESULTS ---\n");
    printf("You answered %d out of %d questions correctly.\n", num_correct, NUM_QUESTIONS);
    printf("You answered %d out of %d questions incorrectly.\n", num_incorrect, NUM_QUESTIONS);
    printf("You took %.2f seconds to complete the quiz.\n", time_taken);
    
    return 0;
}

// Load elements from file into elements array
void load_elements() {
    FILE *file;
    file = fopen("elements.txt", "r");
    if (file == NULL) {
        printf("Error opening file.");
        exit(1);
    }
    
    char line[50];
    for (int i = 0; i < NUM_ELEMENTS; i++) {
        // Read data into temporary variable
        int atomic_number_temp;
        char symbol_temp[3];
        char name_temp[20];
        float atomic_weight_temp;
        fgets(line, sizeof(line), file);
        sscanf(line, "%d %s %s %f", &atomic_number_temp, symbol_temp, name_temp, &atomic_weight_temp);
        
        // Copy data into Element struct
        Element element_temp;
        element_temp.atomic_number = atomic_number_temp;
        strcpy(element_temp.symbol, symbol_temp);
        strcpy(element_temp.name, name_temp);
        element_temp.atomic_weight = atomic_weight_temp;
        
        // Add Element struct to elements array
        elements[i] = element_temp;
    }
    
    fclose(file);
}

// Shuffle elements array
void shuffle_elements() {
    srand(time(NULL));
    for (int i = 0; i < NUM_ELEMENTS; i++) {
        int random_index = rand() % NUM_ELEMENTS;
        Element temp = elements[i];
        elements[i] = elements[random_index];
        elements[random_index] = temp;
    }
}

// Generate one multiple-choice question
void generate_question(int question_number) {
    // Choose the correct answer
    Element correct_element = elements[question_number - 1];
    
    // Generate three incorrect answers
    Element selections[MAX_SELECTIONS];
    for (int i = 0; i < MAX_SELECTIONS; i++) {
        int random_index = rand() % NUM_ELEMENTS;
        Element selection_temp = elements[random_index];
        while (strcmp(selection_temp.symbol, correct_element.symbol) == 0) {
            random_index = rand() % NUM_ELEMENTS;
            selection_temp = elements[random_index];
        }
        selections[i] = selection_temp;
    }
    
    // Add correct answer to selections array and shuffle
    selections[MAX_SELECTIONS - 1] = correct_element;
    srand(time(NULL));
    for (int i = 0; i < MAX_SELECTIONS; i++) {
        int random_index = rand() % MAX_SELECTIONS;
        Element temp = selections[i];
        selections[i] = selections[random_index];
        selections[random_index] = temp;
    }
    
    // Print question and selections
    printf("Question %d: What is the atomic symbol for %s?\n", question_number, correct_element.name);
    print_selections(correct_element, selections);
    
    // Get answer from user
    char answer[3];
    clock_t start_time = clock();
    scanf("%2s", answer);
    
    // Check answer and update scores
    if (strcmp(answer, correct_element.symbol) == 0) {
        printf("Correct!\n");
        num_correct++;
    } else {
        printf("Incorrect. The correct answer is %s.\n", correct_element.symbol);
        num_incorrect++;
    }
    
    // Print elapsed time and sleep for 2 seconds
    float time_taken = (float)(clock() - start_time) / CLOCKS_PER_SEC;
    printf("Time taken: %.2f seconds\n", time_taken);
    printf("Press Enter to continue...");
    fflush(stdout);
    getchar();
    sleep(2);
}

// Print selections with correct answer at the end
void print_selections(Element correct_element, Element selections[MAX_SELECTIONS]) {
    for (int i = 0; i < MAX_SELECTIONS; i++) {
        printf("%d) %s", i + 1, selections[i].symbol);
        if (strcmp(selections[i].symbol, correct_element.symbol) == 0) {
            printf(" (correct)");
        }
        printf("\n");
    }
}

// Print final results after completing all questions
void print_results(float time_taken) {
    printf("\n--- RESULTS ---\n");
    printf("You answered %d out of %d questions correctly.\n", num_correct, NUM_QUESTIONS);
    printf("You answered %d out of %d questions incorrectly.\n", num_incorrect, NUM_QUESTIONS);
    printf("You took %.2f seconds to complete the quiz.\n", time_taken);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 load_elements(void); // weak
__int64 shuffle_elements(void); // weak
__int64 __fastcall generate_question(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// clock_t __cdecl clock();

//-------------------------------------------------------------------------
// Data declarations

int num_correct; // weak
int num_incorrect; // weak


//----- (0000000140001644) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  load_elements();
  shuffle_elements();
  printf("\n--- Welcome to the Periodic Table Quiz! ---\n");
  printf("\nYou will be asked %d multiple-choice questions about the periodic table.\n", 10i64);
  printf("You will have 10 seconds to answer each question.\n\n");
  for ( i = 1; i <= 10; ++i )
    generate_question((unsigned int)i);
  v4 = (float)clock() / 1000.0;
  printf("\n--- RESULTS ---\n");
  printf("You answered %d out of %d questions correctly.\n", (unsigned int)num_correct, 10i64);
  printf("You answered %d out of %d questions incorrectly.\n", (unsigned int)num_incorrect, 10i64);
  printf("You took %.2f seconds to complete the quiz.\n", v4);
  return 0;
}
// 140001748: using guessed type __int64 load_elements(void);
// 140001891: using guessed type __int64 shuffle_elements(void);
// 1400019AF: using guessed type __int64 __fastcall generate_question(_QWORD);
// 140001FF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019F00: using guessed type int num_correct;
// 140019F04: using guessed type int num_incorrect;

// nfuncs=195 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: GPS Navigation Simulation ; Style: optimized
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define PI 3.14159265359

// Function to calculate the distance between two GPS coordinates
// latitude1 and longitude1 are the coordinates of Point 1
// latitude2 and longitude2 are the coordinates of Point 2
double calculate_distance(double latitude1, double longitude1, double latitude2, double longitude2) {
    double earth_radius = 6371.0; // Earth's radius in km
    double diff_latitude = (latitude2 - latitude1) * (PI / 180.0); // Difference in latitude
    double diff_longitude = (longitude2 - longitude1) * (PI / 180.0); // Difference in longitude
    double a = pow(sin(diff_latitude / 2), 2) + cos(latitude1 * (PI / 180.0)) * cos(latitude2 * (PI / 180.0)) * pow(sin(diff_longitude / 2), 2);
    double c = 2 * atan2(sqrt(a), sqrt(1 - a)); // Central angle
    double distance = earth_radius * c; // Distance between the two points
    return distance;
}

// Structure to hold GPS coordinates of a location
struct location {
    double latitude;
    double longitude;
    char name[50];
};

int main() {
    struct location start; // Starting location
    struct location destination; // Destination location
    double distance; // Distance between start and destination

    // Get starting location's details from user
    printf("Enter starting location details:\n");
    printf("Latitude: ");
    scanf("%lf", &start.latitude);
    printf("Longitude: ");
    scanf("%lf", &start.longitude);
    printf("Name: ");
    scanf("%s", start.name);

    // Get destination location's details from user
    printf("\nEnter destination location details:\n");
    printf("Latitude: ");
    scanf("%lf", &destination.latitude);
    printf("Longitude: ");
    scanf("%lf", &destination.longitude);
    printf("Name: ");
    scanf("%s", destination.name);

    // Calculate the distance between the two locations
    distance = calculate_distance(start.latitude, start.longitude, destination.latitude, destination.longitude);

    // Print the details of the two locations and the distance between them
    printf("\nStarting location: %s (%.6f, %.6f)\n", start.name, start.latitude, start.longitude);
    printf("Destination location: %s (%.6f, %.6f)\n", destination.name, destination.latitude, destination.longitude);
    printf("Distance between the locations: %.2f km\n", distance);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
double calculate_distance(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000179C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+20h] [rbp-A0h] BYREF
  double v5; // [rsp+28h] [rbp-98h] BYREF
  char v6[64]; // [rsp+30h] [rbp-90h] BYREF
  double v7; // [rsp+70h] [rbp-50h] BYREF
  double v8; // [rsp+78h] [rbp-48h] BYREF
  char v9[56]; // [rsp+80h] [rbp-40h] BYREF
  double v10; // [rsp+B8h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter starting location details:\n");
  printf("Latitude: ");
  scanf("%lf", &v7);
  printf("Longitude: ");
  scanf("%lf", &v8);
  printf("Name: ");
  scanf("%s", v9);
  printf("\nEnter destination location details:\n");
  printf("Latitude: ");
  scanf("%lf", &v4);
  printf("Longitude: ");
  scanf("%lf", &v5);
  printf("Name: ");
  scanf("%s", v6);
  v10 = calculate_distance();
  printf("\nStarting location: %s (%.6f, %.6f)\n", v9, v7, v8);
  printf("Destination location: %s (%.6f, %.6f)\n", v6, v4, v5);
  printf("Distance between the locations: %.2f km\n", v10);
  return 0;
}
// 1400015E2: using guessed type double calculate_distance(void);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Auction System ; Style: energetic
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

struct product{

char name[50];
int id;
int price;

};

void print_product(struct product p){

printf("Product ID: %d\n",p.id);
printf("Product Name: %s\n",p.name);
printf("Product Price: %d\n\n",p.price);

}

int main(){

srand(time(NULL));

struct product products[5];

strcpy(products[0].name,"Laptop");
strcpy(products[1].name,"Mobile Phone");
strcpy(products[2].name,"Television");
strcpy(products[3].name,"Digital Camera");
strcpy(products[4].name,"Headphones");

for(int i=0;i<5;i++){

products[i].id=i+1;
products[i].price=rand()%1000;

print_product(products[i]);

}


int max_bid=0;
int max_bid_index=-1;
int total_bids=0;

while(max_bid_index==-1){

int bid=-1;

while(bid==-1){

printf("Enter your bid: ");
scanf("%d",&bid);

if(bid<=max_bid){
    printf("You must bid a higher amount than the current highest bid of %d\n",max_bid);
    bid=-1;
}
else{
    max_bid=bid;
    max_bid_index=rand()%5;
    printf("You are currently the highest bidder on: "); 
    print_product(products[max_bid_index]);
    printf("Your bid: %d\n\n",max_bid);
    total_bids++;
}

}

}

printf("Auction over!\nTotal bids: %d\n",total_bids);
printf("Highest bidder on product no. %d: \n",products[max_bid_index].id);
print_product(products[max_bid_index]);

return 0;

}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall print_product(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001651) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  _BYTE *v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rbx
  _BYTE *v8; // rax
  __int64 v9; // rbx
  __int64 v10; // rbx
  __int64 v11; // rbx
  _BYTE *v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rbx
  __int64 v15; // rbx
  __int64 v17; // [rsp+20h] [rbp-60h] BYREF
  __int64 v18; // [rsp+28h] [rbp-58h]
  __int64 v19; // [rsp+30h] [rbp-50h]
  __int64 v20; // [rsp+38h] [rbp-48h]
  __int64 v21; // [rsp+40h] [rbp-40h]
  __int64 v22; // [rsp+48h] [rbp-38h]
  __int64 v23; // [rsp+50h] [rbp-30h]
  int v24; // [rsp+58h] [rbp-28h]
  int v25; // [rsp+6Ch] [rbp-14h] BYREF
  char v26[8]; // [rsp+70h] [rbp-10h] BYREF
  _BYTE v27[44]; // [rsp+80h] [rbp+0h] BYREF
  char v28[16]; // [rsp+ACh] [rbp+2Ch] BYREF
  char v29[16]; // [rsp+E8h] [rbp+68h] BYREF
  char v30[16]; // [rsp+124h] [rbp+A4h] BYREF
  char v31[16]; // [rsp+160h] [rbp+E0h] BYREF
  unsigned int v32; // [rsp+1A0h] [rbp+120h]
  int v33; // [rsp+1A4h] [rbp+124h]
  unsigned int v34; // [rsp+1A8h] [rbp+128h]
  int i; // [rsp+1ACh] [rbp+12Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  strcpy(v26, "Laptop");
  strcpy(v28, "Mobile Phone");
  strcpy(v29, "Television");
  strcpy(v30, "Digital Camera");
  strcpy(v31, "Headphones");
  for ( i = 0; i <= 4; ++i )
  {
    *(_DWORD *)&v27[60 * i + 36] = i + 1;
    *(_DWORD *)&v27[60 * i + 40] = rand() % 1000;
    v4 = &v27[60 * i - 16];
    v5 = *((_QWORD *)v4 + 1);
    v17 = *(_QWORD *)v4;
    v18 = v5;
    v6 = *((_QWORD *)v4 + 3);
    v19 = *((_QWORD *)v4 + 2);
    v20 = v6;
    v7 = *((_QWORD *)v4 + 5);
    v21 = *((_QWORD *)v4 + 4);
    v22 = v7;
    v23 = *((_QWORD *)v4 + 6);
    v24 = *((_DWORD *)v4 + 14);
    print_product(&v17);
  }
  v34 = 0;
  v33 = -1;
  v32 = 0;
  while ( v33 == -1 )
  {
    v25 = -1;
    while ( v25 == -1 )
    {
      printf("Enter your bid: ");
      scanf("%d", &v25);
      if ( (int)v34 < v25 )
      {
        v34 = v25;
        v33 = rand() % 5;
        printf("You are currently the highest bidder on: ");
        v8 = &v27[60 * v33 - 16];
        v9 = *((_QWORD *)v8 + 1);
        v17 = *(_QWORD *)v8;
        v18 = v9;
        v10 = *((_QWORD *)v8 + 3);
        v19 = *((_QWORD *)v8 + 2);
        v20 = v10;
        v11 = *((_QWORD *)v8 + 5);
        v21 = *((_QWORD *)v8 + 4);
        v22 = v11;
        v23 = *((_QWORD *)v8 + 6);
        v24 = *((_DWORD *)v8 + 14);
        print_product(&v17);
        printf("Your bid: %d\n\n", v34);
        ++v32;
      }
      else
      {
        printf("You must bid a higher amount than the current highest bid of %d\n", v34);
        v25 = -1;
      }
    }
  }
  printf("Auction over!\nTotal bids: %d\n", v32);
  printf("Highest bidder on product no. %d: \n", *(unsigned int *)&v27[60 * v33 + 36]);
  v12 = &v27[60 * v33 - 16];
  v13 = *((_QWORD *)v12 + 1);
  v17 = *(_QWORD *)v12;
  v18 = v13;
  v14 = *((_QWORD *)v12 + 3);
  v19 = *((_QWORD *)v12 + 2);
  v20 = v14;
  v15 = *((_QWORD *)v12 + 5);
  v21 = *((_QWORD *)v12 + 4);
  v22 = v15;
  v23 = *((_QWORD *)v12 + 6);
  v24 = *((_DWORD *)v12 + 14);
  print_product(&v17);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall print_product(_QWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Classification system ; Style: lively
#include <stdio.h>

int main() {
  printf("Welcome to the Image Classification System!\n");

  int image_num;
  printf("Enter the number of images you want to classify: ");
  scanf("%d", &image_num);

  int image_size;
  printf("Enter the size of each image: ");
  scanf("%d", &image_size);

  float image_data[image_num][image_size];
  printf("Enter the image data:\n");

  for (int i = 0; i < image_num; i++) {
    printf("Image %d:\n", i+1);
    for (int j = 0; j < image_size; j++) {
      scanf("%f", &image_data[i][j]);
    }
  }

  float weights[image_size];
  printf("Enter the weights:\n");
  for (int i = 0; i < image_size; i++) {
    scanf("%f", &weights[i]);
  }

  printf("Classifying the images...\n");
  for (int i = 0; i < image_num; i++) {
    float result = 0;
    for (int j = 0; j < image_size; j++) {
      result += image_data[i][j] * weights[j];
    }
    if (result > 0) {
      printf("Image %d is classified as Image A\n", i+1);
    } else {
      printf("Image %d is classified as Image B\n", i+1);
    }
  }

  printf("Thank you for using the Image Classification System!\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned __int64 v3; // rbx
  void *v4; // rsp
  void *v5; // rsp
  __int64 v7; // [rsp+0h] [rbp-C0h] BYREF
  char v8; // [rsp+20h] [rbp-A0h] BYREF
  __int64 *v9; // [rsp+28h] [rbp-98h]
  __int64 v10; // [rsp+30h] [rbp-90h]
  __int64 v11; // [rsp+38h] [rbp-88h]
  __int64 v12; // [rsp+40h] [rbp-80h]
  __int64 v13; // [rsp+48h] [rbp-78h]
  __int64 v14; // [rsp+50h] [rbp-70h]
  __int64 v15; // [rsp+58h] [rbp-68h]
  __int64 v16; // [rsp+60h] [rbp-60h]
  __int64 v17; // [rsp+68h] [rbp-58h]
  int v18; // [rsp+78h] [rbp-48h] BYREF
  int v19; // [rsp+7Ch] [rbp-44h] BYREF
  char *v20; // [rsp+80h] [rbp-40h]
  __int64 v21; // [rsp+88h] [rbp-38h]
  char *v22; // [rsp+90h] [rbp-30h]
  __int64 v23; // [rsp+98h] [rbp-28h]
  __int64 v24; // [rsp+A0h] [rbp-20h]
  int n; // [rsp+A8h] [rbp-18h]
  float v26; // [rsp+ACh] [rbp-14h]
  int m; // [rsp+B0h] [rbp-10h]
  int k; // [rsp+B4h] [rbp-Ch]
  int j; // [rsp+B8h] [rbp-8h]
  int i; // [rsp+BCh] [rbp-4h]

  _main(argc, argv, envp);
  v9 = &v7;
  printf("Welcome to the Image Classification System!\n");
  printf("Enter the number of images you want to classify: ");
  scanf("%d", &v19);
  printf("Enter the size of each image: ");
  scanf("%d", &v18);
  v24 = v18 - 1i64;
  v14 = v18;
  v15 = 0i64;
  v3 = 4i64 * v18;
  v23 = v19 - 1i64;
  v16 = v18;
  v17 = 0i64;
  v4 = alloca(16 * ((unsigned __int64)(4 * v18 * (__int64)v19 + 15) >> 4));
  v22 = &v8;
  printf("Enter the image data:\n");
  for ( i = 0; i < v19; ++i )
  {
    printf("Image %d:\n", (unsigned int)(i + 1));
    for ( j = 0; j < v18; ++j )
      scanf("%f", &v22[4 * j + 4 * (v3 >> 2) * i]);
  }
  v21 = v18 - 1i64;
  v12 = v18;
  v13 = 0i64;
  v10 = v18;
  v11 = 0i64;
  v5 = alloca(16 * ((unsigned __int64)(4i64 * v18 + 15) >> 4));
  v20 = &v8;
  printf("Enter the weights:\n");
  for ( k = 0; k < v18; ++k )
    scanf("%f", &v20[4 * k]);
  printf("Classifying the images...\n");
  for ( m = 0; m < v19; ++m )
  {
    v26 = 0.0;
    for ( n = 0; n < v18; ++n )
      v26 = (float)(*(float *)&v20[4 * n] * *(float *)&v22[4 * n + 4 * (v3 >> 2) * m]) + v26;
    if ( v26 <= 0.0 )
      printf("Image %d is classified as Image B\n", (unsigned int)(m + 1));
    else
      printf("Image %d is classified as Image A\n", (unsigned int)(m + 1));
  }
  printf("Thank you for using the Image Classification System!\n");
  return 0;
}
// 140001A30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: A* Pathfinding Algorithm ; Style: curious
#include<stdio.h>

int main(){
   int n,start,end;
   printf("Enter the number of nodes: ");
   scanf("%d",&n);

   int graph[n][n],visited[n],distance[n],prev[n];
   for(int i=0;i<n;i++){
       visited[i]=0;
       distance[i]=999999;
   }

   printf("Enter the weights of the edges: ");
   for(int i=0;i<n;i++){
       for(int j=0;j<n;j++){
           scanf("%d",&graph[i][j]);
       }
   }

   printf("Enter the starting and ending nodes: ");
   scanf("%d %d",&start,&end);
   start--;
   end--;

   distance[start]=0;
   int current=start;

   while(current!=end){
       visited[current]=1;

       int minDistance=999999;
       int nextNode=0;

       for(int i=0;i<n;i++){
           if(graph[current][i]>0 && !visited[i]){
               int totalDistance=distance[current]+graph[current][i];
               if(totalDistance<distance[i]){
                   distance[i]=totalDistance;
                   prev[i]=current;
               }
               if(distance[i]<minDistance){
                   minDistance=distance[i];
                   nextNode=i;
               }
           }
       }
       current=nextNode;
   }

   printf("\nShortest Path: ");
   int path[n];
   int count=1;
   int temp=end;

   while(temp!=start){
       path[count]=temp;
       count++;
       temp=prev[temp];
   }

   path[count]=start;

   for(int i=count;i>=1;i--){
       printf("%d ",path[i]+1);
   }
   printf("\nShortest Distance: %d",distance[end]);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned __int64 v3; // rbx
  void *v4; // rsp
  void *v5; // rsp
  void *v6; // rsp
  void *v7; // rsp
  void *v8; // rsp
  __int64 v10; // [rsp+0h] [rbp-80h] BYREF
  char v11; // [rsp+20h] [rbp-60h] BYREF
  __int64 *v12; // [rsp+28h] [rbp-58h]
  __int64 v13; // [rsp+30h] [rbp-50h]
  __int64 v14; // [rsp+38h] [rbp-48h]
  __int64 v15; // [rsp+40h] [rbp-40h]
  __int64 v16; // [rsp+48h] [rbp-38h]
  __int64 v17; // [rsp+50h] [rbp-30h]
  __int64 v18; // [rsp+58h] [rbp-28h]
  __int64 v19; // [rsp+60h] [rbp-20h]
  __int64 v20; // [rsp+68h] [rbp-18h]
  __int64 v21; // [rsp+70h] [rbp-10h]
  __int64 v22; // [rsp+78h] [rbp-8h]
  __int64 v23; // [rsp+80h] [rbp+0h]
  __int64 v24; // [rsp+88h] [rbp+8h]
  __int64 v25; // [rsp+90h] [rbp+10h]
  __int64 v26; // [rsp+98h] [rbp+18h]
  __int64 v27; // [rsp+A0h] [rbp+20h]
  __int64 v28; // [rsp+A8h] [rbp+28h]
  __int64 v29; // [rsp+B0h] [rbp+30h]
  __int64 v30; // [rsp+B8h] [rbp+38h]
  __int64 v31; // [rsp+C0h] [rbp+40h]
  __int64 v32; // [rsp+C8h] [rbp+48h]
  int v33; // [rsp+D0h] [rbp+50h] BYREF
  int v34; // [rsp+D4h] [rbp+54h] BYREF
  int v35; // [rsp+D8h] [rbp+58h] BYREF
  int v36; // [rsp+DCh] [rbp+5Ch]
  char *v37; // [rsp+E0h] [rbp+60h]
  __int64 v38; // [rsp+E8h] [rbp+68h]
  char *v39; // [rsp+F0h] [rbp+70h]
  __int64 v40; // [rsp+F8h] [rbp+78h]
  char *v41; // [rsp+100h] [rbp+80h]
  __int64 v42; // [rsp+108h] [rbp+88h]
  char *v43; // [rsp+110h] [rbp+90h]
  __int64 v44; // [rsp+118h] [rbp+98h]
  char *v45; // [rsp+120h] [rbp+A0h]
  __int64 v46; // [rsp+128h] [rbp+A8h]
  __int64 v47; // [rsp+130h] [rbp+B0h]
  int jj; // [rsp+138h] [rbp+B8h]
  int ii; // [rsp+13Ch] [rbp+BCh]
  int v50; // [rsp+140h] [rbp+C0h]
  int n; // [rsp+144h] [rbp+C4h]
  int v52; // [rsp+148h] [rbp+C8h]
  int v53; // [rsp+14Ch] [rbp+CCh]
  int m; // [rsp+150h] [rbp+D0h]
  int k; // [rsp+154h] [rbp+D4h]
  int j; // [rsp+158h] [rbp+D8h]
  int i; // [rsp+15Ch] [rbp+DCh]

  _main(argc, argv, envp);
  v12 = &v10;
  printf("Enter the number of nodes: ");
  scanf("%d", &v35);
  v47 = v35 - 1i64;
  v29 = v35;
  v30 = 0i64;
  v3 = 4i64 * v35;
  v46 = v47;
  v31 = v35;
  v32 = 0i64;
  v4 = alloca(16 * ((unsigned __int64)(4 * v35 * (__int64)v35 + 15) >> 4));
  v45 = &v11;
  v44 = v47;
  v27 = v35;
  v28 = 0i64;
  v25 = v35;
  v26 = 0i64;
  v5 = alloca(16 * ((v3 + 15) >> 4));
  v43 = &v11;
  v42 = v47;
  v23 = v35;
  v24 = 0i64;
  v21 = v35;
  v22 = 0i64;
  v6 = alloca(16 * ((v3 + 15) >> 4));
  v41 = &v11;
  v40 = v47;
  v19 = v35;
  v20 = 0i64;
  v17 = v35;
  v18 = 0i64;
  v7 = alloca(16 * ((v3 + 15) >> 4));
  v39 = &v11;
  for ( i = 0; i < v35; ++i )
  {
    *(_DWORD *)&v43[4 * i] = 0;
    *(_DWORD *)&v41[4 * i] = 999999;
  }
  printf("Enter the weights of the edges: ");
  for ( j = 0; j < v35; ++j )
  {
    for ( k = 0; k < v35; ++k )
      scanf("%d", &v45[4 * k + 4 * (v3 >> 2) * j]);
  }
  printf("Enter the starting and ending nodes: ");
  scanf("%d %d", &v34, &v33);
  --v34;
  --v33;
  *(_DWORD *)&v41[4 * v34] = 0;
  for ( m = v34; m != v33; m = v52 )
  {
    *(_DWORD *)&v43[4 * m] = 1;
    v53 = 999999;
    v52 = 0;
    for ( n = 0; n < v35; ++n )
    {
      if ( *(int *)&v45[4 * n + 4 * (v3 >> 2) * m] > 0 && !*(_DWORD *)&v43[4 * n] )
      {
        v36 = *(_DWORD *)&v41[4 * m] + *(_DWORD *)&v45[4 * n + 4 * (v3 >> 2) * m];
        if ( v36 < *(_DWORD *)&v41[4 * n] )
        {
          *(_DWORD *)&v41[4 * n] = v36;
          *(_DWORD *)&v39[4 * n] = m;
        }
        if ( v53 > *(_DWORD *)&v41[4 * n] )
        {
          v53 = *(_DWORD *)&v41[4 * n];
          v52 = n;
        }
      }
    }
  }
  printf("\nShortest Path: ");
  v38 = v35 - 1i64;
  v15 = v35;
  v16 = 0i64;
  v13 = v35;
  v14 = 0i64;
  v8 = alloca(16 * ((unsigned __int64)(4i64 * v35 + 15) >> 4));
  v37 = &v11;
  v50 = 1;
  for ( ii = v33; ii != v34; ii = *(_DWORD *)&v39[4 * ii] )
    *(_DWORD *)&v37[4 * v50++] = ii;
  *(_DWORD *)&v37[4 * v50] = v34;
  for ( jj = v50; jj > 0; --jj )
    printf("%d ", (unsigned int)(*(_DWORD *)&v37[4 * jj] + 1));
  printf("\nShortest Distance: %d", *(unsigned int *)&v41[4 * v33]);
  return 0;
}
// 140001D00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Binary Converter ; Style: relaxed
#include <stdio.h>

void printBinary(int decimal) {
    int binaryArr[32];
    int i = 0;

    while (decimal > 0) {
        binaryArr[i] = decimal % 2;
        decimal /= 2;
        i++;
    }

    for (int j = i - 1; j >= 0; j--) {
        printf("%d", binaryArr[j]);
    }
}

int main() {
    int decimal;

    printf("Enter a decimal number to convert to binary: ");
    scanf("%d", &decimal);

    printf("The binary representation of %d is: ", decimal);
    printBinary(decimal);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall printBinary(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000166B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter a decimal number to convert to binary: ");
  scanf("%d", &v4);
  printf("The binary representation of %d is: ", v4);
  printBinary(v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall printBinary(_QWORD);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

const int BOARD_SIZE = 4;

void generateBoard(int board[][BOARD_SIZE]) {
    int numPairs = (BOARD_SIZE * BOARD_SIZE) / 2;
    int pairs[numPairs];
    for (int i = 0; i < numPairs; i++) {
        pairs[i] = i;
    }

    srand(time(NULL));
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            int index = rand() % numPairs;
            board[i][j] = pairs[index];
            pairs[index] = pairs[numPairs - 1];
            numPairs--;
        }
    }
}

void printBoard(int board[][BOARD_SIZE], int revealed[][BOARD_SIZE]) {
    printf("   0 1 2 3\n");
    for (int i = 0; i < BOARD_SIZE; i++) {
        printf("%d ", i);
        for (int j = 0; j < BOARD_SIZE; j++) {
            if (revealed[i][j]) {
                printf("%d ", board[i][j]);
            } else {
                printf("X ");
            }
        }
        printf("\n");
    }
}

int main(void) {
    int board[BOARD_SIZE][BOARD_SIZE];
    int revealed[BOARD_SIZE][BOARD_SIZE];
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            revealed[i][j] = 0;
        }
    }
    generateBoard(board);

    int numPairsFound = 0;
    while (numPairsFound < (BOARD_SIZE * BOARD_SIZE) / 2) {
        printBoard(board, revealed);

        int x1, y1, x2, y2;
        printf("Enter first card coordinates: ");
        scanf("%d %d", &x1, &y1);

        while (revealed[x1][y1] == 1) {
            printf("That card has already been revealed. Enter new coordinates: ");
            scanf("%d %d", &x1, &y1);
        }

        revealed[x1][y1] = 1;
        printBoard(board, revealed);

        printf("Enter second card coordinates: ");
        scanf("%d %d", &x2, &y2);

        while (revealed[x2][y2] == 1) {
            printf("That card has already been revealed. Enter new coordinates: ");
            scanf("%d %d", &x2, &y2);
        }

        revealed[x2][y2] = 1;
        printBoard(board, revealed);

        if (board[x1][y1] == board[x2][y2]) {
            printf("Pair found!\n");
            numPairsFound++;
        } else {
            printf("No pair found.\n");
            revealed[x1][y1] = 0;
            revealed[x2][y2] = 0;
        }
    }

    printf("Congratulations! You have found all pairs.\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generateBoard(_QWORD); // weak
__int64 __fastcall printBoard(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018B3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  void *v4; // rsp
  __int64 v6; // [rsp+0h] [rbp-F0h] BYREF
  char v7; // [rsp+20h] [rbp-D0h] BYREF
  __int64 *v8; // [rsp+28h] [rbp-C8h]
  __int64 v9; // [rsp+30h] [rbp-C0h]
  __int64 v10; // [rsp+38h] [rbp-B8h]
  unsigned __int64 v11; // [rsp+40h] [rbp-B0h]
  __int64 v12; // [rsp+48h] [rbp-A8h]
  __int64 v13; // [rsp+50h] [rbp-A0h]
  __int64 v14; // [rsp+58h] [rbp-98h]
  __int64 v15; // [rsp+60h] [rbp-90h]
  __int64 v16; // [rsp+68h] [rbp-88h]
  __int64 v17; // [rsp+70h] [rbp-80h]
  __int64 v18; // [rsp+78h] [rbp-78h]
  __int64 v19; // [rsp+80h] [rbp-70h]
  __int64 v20; // [rsp+88h] [rbp-68h]
  __int64 v21; // [rsp+90h] [rbp-60h]
  __int64 v22; // [rsp+98h] [rbp-58h]
  int v23; // [rsp+A0h] [rbp-50h] BYREF
  int v24; // [rsp+A4h] [rbp-4Ch] BYREF
  int v25; // [rsp+A8h] [rbp-48h] BYREF
  int v26; // [rsp+ACh] [rbp-44h] BYREF
  char *v27; // [rsp+B0h] [rbp-40h]
  __int64 v28; // [rsp+B8h] [rbp-38h]
  __int64 v29; // [rsp+C0h] [rbp-30h]
  char *v30; // [rsp+C8h] [rbp-28h]
  __int64 v31; // [rsp+D0h] [rbp-20h]
  __int64 v32; // [rsp+D8h] [rbp-18h]
  int v33; // [rsp+E4h] [rbp-Ch]
  int j; // [rsp+E8h] [rbp-8h]
  int i; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  v8 = &v6;
  v32 = 3i64;
  v12 = 0i64;
  v11 = 16i64;
  v31 = 3i64;
  v21 = 4i64;
  v22 = 0i64;
  v19 = 4i64;
  v20 = 0i64;
  v3 = alloca(64i64);
  v30 = &v7;
  v29 = 3i64;
  v9 = 4i64;
  v10 = 0i64;
  v28 = 3i64;
  v17 = 4i64;
  v18 = 0i64;
  v15 = 4i64;
  v16 = 0i64;
  v13 = 4i64;
  v14 = 0i64;
  v4 = alloca(64i64);
  v27 = &v7;
  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4; ++j )
      *(_DWORD *)&v27[16 * i + 4 * j] = 0;
  }
  generateBoard(v30);
  v33 = 0;
  while ( v33 < 8 )
  {
    printBoard(v30, v27);
    printf("Enter first card coordinates: ");
    scanf("%d %d", &v26, &v25);
    while ( *(_DWORD *)&v27[16 * v26 + 4 * v25] == 1 )
    {
      printf("That card has already been revealed. Enter new coordinates: ");
      scanf("%d %d", &v26, &v25);
    }
    *(_DWORD *)&v27[16 * v26 + 4 * v25] = 1;
    printBoard(v30, v27);
    printf("Enter second card coordinates: ");
    scanf("%d %d", &v24, &v23);
    while ( *(_DWORD *)&v27[16 * v24 + 4 * v23] == 1 )
    {
      printf("That card has already been revealed. Enter new coordinates: ");
      scanf("%d %d", &v24, &v23);
    }
    *(_DWORD *)&v27[16 * v24 + 4 * v23] = 1;
    printBoard(v30, v27);
    if ( *(_DWORD *)&v30[4 * v25 + 4 * (v11 >> 2) * v26] == *(_DWORD *)&v30[4 * v23 + 4 * (v11 >> 2) * v24] )
    {
      printf("Pair found!\n");
      ++v33;
    }
    else
    {
      printf("No pair found.\n");
      *(_DWORD *)&v27[16 * v26 + 4 * v25] = 0;
      *(_DWORD *)&v27[16 * v24 + 4 * v23] = 0;
    }
  }
  printf("Congratulations! You have found all pairs.\n");
  return 0;
}
// 140001601: using guessed type __int64 __fastcall generateBoard(_QWORD);
// 14000177C: using guessed type __int64 __fastcall printBoard(_QWORD, _QWORD);
// 140001ED0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Table Game ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 6
#define COLS 6

void print_board(int board[ROWS][COLS], int guess_board[ROWS][COLS]);
int make_guess(int board[ROWS][COLS], int guess_board[ROWS][COLS], int row, int col);
int get_random_num(int min, int max);
void initialize_board(int board[ROWS][COLS], int guess_board[ROWS][COLS]);

int main() {
    int board[ROWS][COLS];
    int guess_board[ROWS][COLS];
    int count = 0;
    int row = 0;
    int col = 0;
    int num_mines = 0;
    
    srand(time(0)); 
    
    // initialize board
    initialize_board(board, guess_board);
    
    // get user input      
    printf("How many mines do you want in the game? (maximum %d): ", ROWS * COLS);
    scanf("%d", &num_mines);
    while(num_mines > ROWS * COLS) {
        printf("You cannot have more than %d mines. Please try again. ", ROWS * COLS);
        scanf("%d", &num_mines);
    }

    // randomly place mines on board
    while(count < num_mines) {
        row = get_random_num(0, ROWS);
        col = get_random_num(0, COLS);
        
        if(board[row][col] != -1) {
            board[row][col] = -1;
            count++;
        }
    }
    
    // print blank guess board
    printf("\n");
    print_board(board, guess_board);
    
    // let user make guesses until they win or lose
    while(1) {
        printf("Please enter row and column to guess: ");
        scanf("%d %d", &row, &col);
        
        if(make_guess(board, guess_board, row, col) == -1) {
            printf("Game Over! You hit a mine.\n");
            print_board(board, guess_board);
            break;
        } else if( guess_board[row][col] != 0) {
            printf("You already guessed that spot. Try again.\n");
        } else if(guess_board[row][col] == 0) { 
            print_board(board, guess_board);
        }
        
        // check to see if user has won
        int win = 1;
        for(int i = 0; i < ROWS; i++) {
            for(int j = 0; j < COLS; j++) {
                if(guess_board[i][j] == 0 && board[i][j] != -1) {
                    win = 0;
                    break;
                }
            }
        }
        if(win) {
            printf("Congratulations! You won the game!\n");
            print_board(board, guess_board);
            break;
        }
    }       
                 
    return 0;
}

// prints the guess board with X's for unknown spots
void print_board(int board[ROWS][COLS], int guess_board[ROWS][COLS]) {
    printf("\n");
    for(int i = 0; i < ROWS; i++) {
        for(int j = 0; j < COLS; j++) {
            if(guess_board[i][j] == 1) {
                printf("%d ", board[i][j]);
            } else if(guess_board[i][j] == -1) {
                printf("X ");
            } else {
                printf("- ");
            }
        }
        printf("\n");
    }
}

// user makes a guess
int make_guess(int board[ROWS][COLS], int guess_board[ROWS][COLS], int row, int col) {
    if(board[row][col] == -1) {
        guess_board[row][col] = -1;
        return -1;
    } else {
        guess_board[row][col] = 1;
        // check for adjacent mines
        int count = 0;
        if(row > 0 && board[row-1][col] == -1) { // top
            count++;
        } 
        if(row < ROWS - 1 && board[row+1][col] == -1) { // bottom
            count++;
        }
        if(col > 0 && board[row][col-1] == -1) { // left
            count++;
        }
        if(col < COLS - 1 && board[row][col+1] == -1) { // right
            count++;
        }
        guess_board[row][col] = count;
        
        return 0;
    }
}

// generates random number within min and max range
int get_random_num(int min, int max) {
    return (rand() % (max - min)) + min;
}

// initializes the board with all zeros
void initialize_board(int board[ROWS][COLS], int guess_board[ROWS][COLS]) {
    for(int i = 0; i < ROWS; i++) {
        for(int j = 0; j < COLS; j++) {
            board[i][j] = 0;
            guess_board[i][j] = 0;
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall print_board(_QWORD, _QWORD); // weak
__int64 __fastcall make_guess(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall get_random_num(_QWORD, _QWORD); // weak
__int64 __fastcall initialize_board(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-5Ch] BYREF
  unsigned int v6; // [rsp+28h] [rbp-58h] BYREF
  unsigned int random_num; // [rsp+2Ch] [rbp-54h] BYREF
  int v8[36]; // [rsp+30h] [rbp-50h] BYREF
  int v9[36]; // [rsp+C0h] [rbp+40h] BYREF
  int j; // [rsp+150h] [rbp+D0h]
  int i; // [rsp+154h] [rbp+D4h]
  int v12; // [rsp+158h] [rbp+D8h]
  int v13; // [rsp+15Ch] [rbp+DCh]

  _main(argc, argv, envp);
  v13 = 0;
  random_num = 0;
  v6 = 0;
  v5 = 0;
  v3 = time(0i64);
  srand(v3);
  initialize_board(v9, v8);
  printf("How many mines do you want in the game? (maximum %d): ", 36i64);
  scanf("%d", &v5);
  while ( v5 > 36 )
  {
    printf("You cannot have more than %d mines. Please try again. ", 36i64);
    scanf("%d", &v5);
  }
  while ( v13 < v5 )
  {
    random_num = get_random_num(0i64, 6i64);
    v6 = get_random_num(0i64, 6i64);
    if ( v9[6 * random_num + v6] != -1 )
    {
      v9[6 * random_num + v6] = -1;
      ++v13;
    }
  }
  printf("\n");
  print_board(v9, v8);
  do
  {
    printf("Please enter row and column to guess: ");
    scanf("%d %d", &random_num, &v6);
    if ( (unsigned int)make_guess(v9, v8, random_num, v6) == -1 )
    {
      printf("Game Over! You hit a mine.\n");
      print_board(v9, v8);
      return 0;
    }
    if ( v8[6 * random_num + v6] )
      printf("You already guessed that spot. Try again.\n");
    else
      print_board(v9, v8);
    v12 = 1;
    for ( i = 0; i <= 5; ++i )
    {
      for ( j = 0; j <= 5; ++j )
      {
        if ( !v8[6 * i + j] && v9[6 * i + j] != -1 )
        {
          v12 = 0;
          break;
        }
      }
    }
  }
  while ( !v12 );
  printf("Congratulations! You won the game!\n");
  print_board(v9, v8);
  return 0;
}
// 14000190D: using guessed type __int64 __fastcall print_board(_QWORD, _QWORD);
// 140001A23: using guessed type __int64 __fastcall make_guess(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001BD6: using guessed type __int64 __fastcall get_random_num(_QWORD, _QWORD);
// 140001BFF: using guessed type __int64 __fastcall initialize_board(_QWORD, _QWORD);
// 140001D40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001601: using guessed type int var_130[36];
// 140001601: using guessed type int var_A0[36];

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: light-weight
#include <stdio.h>

int main() {
   float item1, item2, item3, item4, item5, subtotal, tax, total;
   int quantity1, quantity2, quantity3, quantity4, quantity5;
   const float TAX_RATE = 0.05; // 5% tax rate
   
   // Prompt for and get item prices and quantities
   printf("Enter item 1 price: ");
   scanf("%f", &item1);
   printf("Enter item 1 quantity: ");
   scanf("%d", &quantity1);

   printf("Enter item 2 price: ");
   scanf("%f", &item2);
   printf("Enter item 2 quantity: ");
   scanf("%d", &quantity2);

   printf("Enter item 3 price: ");
   scanf("%f", &item3);
   printf("Enter item 3 quantity: ");
   scanf("%d", &quantity3);

   printf("Enter item 4 price: ");
   scanf("%f", &item4);
   printf("Enter item 4 quantity: ");
   scanf("%d", &quantity4);

   printf("Enter item 5 price: ");
   scanf("%f", &item5);
   printf("Enter item 5 quantity: ");
   scanf("%d", &quantity5);

   // Calculate subtotal
   subtotal = item1 * quantity1 + item2 * quantity2 + item3 * quantity3
      + item4 * quantity4 + item5 * quantity5;

   // Calculate tax
   tax = subtotal * TAX_RATE;

   // Calculate total
   total = subtotal + tax;

   // Print the bill
   printf("\n+-------------------------+\n");
   printf("|       CAFE BILLING       |\n");
   printf("+-------------------------+\n");
   printf("| Item      |  Qty | Price |\n");
   printf("+-------------------------+\n");
   printf("| Item 1    |  %3d | $%4.2f |\n", quantity1, item1);
   printf("| Item 2    |  %3d | $%4.2f |\n", quantity2, item2);
   printf("| Item 3    |  %3d | $%4.2f |\n", quantity3, item3);
   printf("| Item 4    |  %3d | $%4.2f |\n", quantity4, item4);
   printf("| Item 5    |  %3d | $%4.2f |\n", quantity5, item5);
   printf("+-------------------------+\n");
   printf("| Subtotal  |       | $%4.2f |\n", subtotal);
   printf("| Tax (5%%)  |       | $%4.2f |\n", tax);
   printf("| Total     |       | $%4.2f |\n", total);
   printf("+-------------------------+\n");

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-38h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-34h] BYREF
  unsigned int v6; // [rsp+30h] [rbp-30h] BYREF
  unsigned int v7; // [rsp+34h] [rbp-2Ch] BYREF
  unsigned int v8; // [rsp+38h] [rbp-28h] BYREF
  float v9; // [rsp+3Ch] [rbp-24h] BYREF
  float v10; // [rsp+40h] [rbp-20h] BYREF
  float v11; // [rsp+44h] [rbp-1Ch] BYREF
  float v12; // [rsp+48h] [rbp-18h] BYREF
  float v13; // [rsp+4Ch] [rbp-14h] BYREF
  float v14; // [rsp+50h] [rbp-10h]
  float v15; // [rsp+54h] [rbp-Ch]
  float v16; // [rsp+58h] [rbp-8h]
  float v17; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v17 = 0.050000001;
  printf("Enter item 1 price: ");
  scanf("%f", &v13);
  printf("Enter item 1 quantity: ");
  scanf("%d", &v8);
  printf("Enter item 2 price: ");
  scanf("%f", &v12);
  printf("Enter item 2 quantity: ");
  scanf("%d", &v7);
  printf("Enter item 3 price: ");
  scanf("%f", &v11);
  printf("Enter item 3 quantity: ");
  scanf("%d", &v6);
  printf("Enter item 4 price: ");
  scanf("%f", &v10);
  printf("Enter item 4 quantity: ");
  scanf("%d", &v5);
  printf("Enter item 5 price: ");
  scanf("%f", &v9);
  printf("Enter item 5 quantity: ");
  scanf("%d", &v4);
  v16 = (float)(v9 * (float)(int)v4)
      + (float)((float)((float)((float)((float)(int)v8 * v13) + (float)(v12 * (float)(int)v7))
                      + (float)(v11 * (float)(int)v6))
              + (float)(v10 * (float)(int)v5));
  v15 = v16 * v17;
  v14 = v16 + (float)(v16 * v17);
  printf("\n+-------------------------+\n");
  printf("|       CAFE BILLING       |\n");
  printf("+-------------------------+\n");
  printf("| Item      |  Qty | Price |\n");
  printf("+-------------------------+\n");
  printf("| Item 1    |  %3d | $%4.2f |\n", v8, v13);
  printf("| Item 2    |  %3d | $%4.2f |\n", v7, v12);
  printf("| Item 3    |  %3d | $%4.2f |\n", v6, v11);
  printf("| Item 4    |  %3d | $%4.2f |\n", v5, v10);
  printf("| Item 5    |  %3d | $%4.2f |\n", v4, v9);
  printf("+-------------------------+\n");
  printf("| Subtotal  |       | $%4.2f |\n", v16);
  printf("| Tax (5%%)  |       | $%4.2f |\n", v15);
  printf("| Total     |       | $%4.2f |\n", v14);
  printf("+-------------------------+\n");
  return 0;
}
// 140001AB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: surprised
#include <stdio.h>
#include <math.h>
#include <time.h>

#define PI 3.14159265359
#define G 6.67430e-11

struct position {
    double x, y;
};

struct velocity {
    double vx, vy;
};

struct body {
    double mass, radius;
    struct position pos;
    struct velocity vel;
    struct position force;
};

void init_body(struct body *b, double mass, double radius, double x, double y, double vx, double vy) {
	  b->mass = mass;
	  b->radius = radius;
	  b->pos.x = x;
	  b->pos.y = y;
	  b->vel.vx = vx;
	  b->vel.vy = vy;
	  b->force.x = 0;
	  b->force.y = 0;
}

void calc_force(struct body *b1, struct body *b2) {
    double dx, dy, dist, f;

    dx = b2->pos.x - b1->pos.x;
    dy = b2->pos.y - b1->pos.y;
    dist = sqrt(dx * dx + dy * dy);

    if (dist == 0) {
        f = 0;
    } else {
        f = G * b1->mass * b2->mass / (dist * dist);
    }

    b1->force.x += f * dx / dist;
    b1->force.y += f * dy / dist;
}

void simulate(struct body *bodies, int num_bodies, double dt) {
    int i, j;

    for (i = 0; i < num_bodies; i++) {
        for (j = 0; j < num_bodies; j++) {
            if (i != j) {
            	calc_force(&bodies[i], &bodies[j]);
            }
        }
    }

    for (i = 0; i < num_bodies; i++) {
        double ax = bodies[i].force.x / bodies[i].mass;
        double ay = bodies[i].force.y / bodies[i].mass;

        bodies[i].vel.vx += ax * dt;
        bodies[i].vel.vy += ay * dt;
        bodies[i].pos.x += bodies[i].vel.vx * dt;
        bodies[i].pos.y += bodies[i].vel.vy * dt;

        bodies[i].force.x = 0;
        bodies[i].force.y = 0;
    }
}

void print_body(struct body *b) {
    printf("Body position: (%.2f, %.2f)\n", b->pos.x, b->pos.y);
}

int main() {
    srand(time(NULL));

    int num_bodies = 5;
    double dt = 0.1;
    struct body bodies[num_bodies];

    init_body(&bodies[0], 1.989e30, 696340000, 0, 0, 0, 0);
    printf("Initializing Sun...\n");

    init_body(&bodies[1], 5.97e24, 6371000, 147095000000, 0, 0, 30290);
    printf("Initializing Earth...\n");

    init_body(&bodies[2], 6.39e23, 3389500, 206644545142, 0, 0, 26500);
    printf("Initializing Mars...\n");

    init_body(&bodies[3], 3.30e23, 2523200, 149598262, 0, 0, 47850);
    printf("Initializing Mercury...\n");

    init_body(&bodies[4], 4.87e24, 6051800, 108939000000, 0, 0, 34790);
    printf("Initializing Venus...\n");

    int i, j, k;
    for (k = 0; k < 10; k++) {
        for (i = 0; i < num_bodies; i++) {
            printf("Body %d position: ", i);
            print_body(&bodies[i]);
        }

        simulate(bodies, num_bodies, dt);

        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall init_body(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64, __int64); // weak
__int64 __fastcall simulate(_QWORD, _QWORD); // weak
__int64 __fastcall print_body(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001A18) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  void *v4; // rsp
  int v5; // r8d
  int v6; // r9d
  int v7; // edx
  int v8; // r8d
  int v9; // r9d
  int v10; // edx
  int v11; // r8d
  int v12; // r9d
  int v13; // edx
  int v14; // r8d
  int v15; // r9d
  int v16; // edx
  int v17; // r8d
  int v18; // r9d
  char v20; // [rsp+40h] [rbp-30h] BYREF
  char *v21; // [rsp+48h] [rbp-28h]
  __int64 v22; // [rsp+50h] [rbp-20h]
  __int64 v23; // [rsp+58h] [rbp-18h]
  unsigned int v24; // [rsp+64h] [rbp-Ch]
  int i; // [rsp+68h] [rbp-8h]
  unsigned int j; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v24 = 5;
  v23 = 0x3FB999999999999Ai64;
  v22 = 4i64;
  v4 = alloca(320i64);
  v21 = &v20;
  init_body((unsigned int)&v20, 5, v5, v6, 0i64, 0i64, 0i64);
  printf("Initializing Sun...\n");
  init_body((_DWORD)v21 + 64, v7, v8, v9, 0i64, 0i64, 0x40DD948000000000i64);
  printf("Initializing Earth...\n");
  init_body((_DWORD)v21 + 128, v10, v11, v12, 0i64, 0i64, 0x40D9E10000000000i64);
  printf("Initializing Mars...\n");
  init_body((_DWORD)v21 + 192, v13, v14, v15, 0i64, 0i64, 0x40E75D4000000000i64);
  printf("Initializing Mercury...\n");
  init_body((_DWORD)v21 + 256, v16, v17, v18, 0i64, 0i64, 0x40E0FCC000000000i64);
  printf("Initializing Venus...\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; (int)j < (int)v24; ++j )
    {
      printf("Body %d position: ", j);
      print_body(&v21[64 * (__int64)(int)j]);
    }
    simulate(v21, v24);
    printf("\n");
  }
  return 0;
}
// 140001AE7: variable 'v5' is possibly undefined
// 140001AE7: variable 'v6' is possibly undefined
// 140001B40: variable 'v7' is possibly undefined
// 140001B40: variable 'v8' is possibly undefined
// 140001B40: variable 'v9' is possibly undefined
// 140001B99: variable 'v10' is possibly undefined
// 140001B99: variable 'v11' is possibly undefined
// 140001B99: variable 'v12' is possibly undefined
// 140001BF4: variable 'v13' is possibly undefined
// 140001BF4: variable 'v14' is possibly undefined
// 140001BF4: variable 'v15' is possibly undefined
// 140001C4F: variable 'v16' is possibly undefined
// 140001C4F: variable 'v17' is possibly undefined
// 140001C4F: variable 'v18' is possibly undefined
// 1400015B0: using guessed type __int64 __fastcall init_body(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64, __int64);
// 14000175B: using guessed type __int64 __fastcall simulate(_QWORD, _QWORD);
// 1400019B9: using guessed type __int64 __fastcall print_body(_QWORD);
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Typing Speed Test ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_WORDS 50 // Maximum number of words in the test
#define MAX_WORD_LENGTH 15 // Maximum length of a word in characters

int main() {
    char words[MAX_WORDS][MAX_WORD_LENGTH]; // Array to store words
    int i, j;
    int mistakes = 0; // Counter for number of mistakes made by user
    clock_t start, end; // Variables to measure time taken to complete test
    float time_taken;

    // Populate array with random words
    char* word_list[] = {"abstract", "algorithm", "array", "binary", "buffer", "class",
                         "compile", "debug", "function", "integer", "library", "loop",
                         "memory", "null", "object", "operator", "pointer", "program",
                         "queue", "recursion", "stack", "string", "syntax", "variable"};
    srand(time(NULL)); // Seed the random number generator
    for (i = 0; i < MAX_WORDS; i++) {
        strcpy(words[i], word_list[rand() % 24]);
    }

    // Display instructions
    printf("Welcome to the Typing Speed Test!\n");
    printf("You will be given %d words to type as quickly and accurately as possible.\n", MAX_WORDS);
    printf("Press enter to begin.\n");
    getchar(); // Wait for user to press enter

    // Begin test
    start = clock();
    for (i = 0; i < MAX_WORDS; i++) {
        printf("Word %d: ", i+1); // Print the word to be typed
        char input[MAX_WORD_LENGTH]; // Variable to store user input
        scanf("%s", input);
        for (j = 0; j < strlen(input); j++) {
            if (input[j] != words[i][j]) {
                mistakes++; // Increment mistake counter if character is incorrect
            }
        }
    }
    end = clock();
    time_taken = (float)(end - start) / CLOCKS_PER_SEC;

    // Display results
    printf("Congratulations, you have completed the typing speed test!\n");
    printf("You made %d mistakes and took %.2f seconds to complete the test.\n", mistakes, time_taken);
    printf("Your typing speed was approximately %.2f words per minute.\n", (MAX_WORDS / time_taken) * 60);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();
// clock_t __cdecl clock();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax
  char Str[15]; // [rsp+21h] [rbp-5Fh] BYREF
  char *Source[10]; // [rsp+30h] [rbp-50h]
  __int64 v8[109]; // [rsp+80h] [rbp+0h] BYREF
  float v9; // [rsp+3E8h] [rbp+368h]
  clock_t v10; // [rsp+3ECh] [rbp+36Ch]
  clock_t v11; // [rsp+3F0h] [rbp+370h]
  unsigned int v12; // [rsp+3F4h] [rbp+374h]
  int j; // [rsp+3F8h] [rbp+378h]
  int i; // [rsp+3FCh] [rbp+37Ch]

  _main(argc, argv, envp);
  v12 = 0;
  Source[0] = "abstract";
  Source[1] = "algorithm";
  Source[2] = "array";
  Source[3] = "binary";
  Source[4] = "buffer";
  Source[5] = "class";
  Source[6] = "compile";
  Source[7] = "debug";
  Source[8] = "function";
  Source[9] = "integer";
  v8[0] = (__int64)"library";
  v8[1] = (__int64)"loop";
  v8[2] = (__int64)"memory";
  v8[3] = (__int64)"null";
  v8[4] = (__int64)"object";
  v8[5] = (__int64)"operator";
  v8[6] = (__int64)"pointer";
  v8[7] = (__int64)"program";
  v8[8] = (__int64)"queue";
  v8[9] = (__int64)"recursion";
  v8[10] = (__int64)"stack";
  v8[11] = (__int64)"string";
  v8[12] = (__int64)"syntax";
  v8[13] = (__int64)"variable";
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 49; ++i )
  {
    v4 = rand();
    strcpy((char *)&v8[14] + 15 * i, Source[v4 % 24]);
  }
  printf("Welcome to the Typing Speed Test!\n");
  printf("You will be given %d words to type as quickly and accurately as possible.\n", 50i64);
  printf("Press enter to begin.\n");
  getchar();
  v11 = clock();
  for ( i = 0; i <= 49; ++i )
  {
    printf("Word %d: ", (unsigned int)(i + 1));
    scanf("%s", Str);
    for ( j = 0; j < strlen(Str); ++j )
    {
      if ( Str[j] != *((_BYTE *)&v8[14] + 15 * i + j) )
        ++v12;
    }
  }
  v10 = clock();
  v9 = (float)(v10 - v11) / 1000.0;
  printf("Congratulations, you have completed the typing speed test!\n");
  printf("You made %d mistakes and took %.2f seconds to complete the test.\n", v12, v9);
  printf("Your typing speed was approximately %.2f words per minute.\n", (float)(60.0 * (float)(50.0 / v9)));
  return 0;
}
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001601: using guessed type char Str[15];

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: satisfied
#include<stdio.h>

int search(int arr[], int n, int key){
    int i;
    for(i=0; i<n; i++){
        if(arr[i]==key)
            return i;
    }
    return -1;
}

int main(){
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    int key = 3;
    int result = search(arr, n, key);
    if(result==-1)
        printf("Key not found\n");
    else
        printf("Key found at index %d\n", result);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall search(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[5]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v5; // [rsp+34h] [rbp-Ch]
  int v6; // [rsp+38h] [rbp-8h]
  int v7; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 1;
  v4[1] = 2;
  v4[2] = 3;
  v4[3] = 4;
  v4[4] = 5;
  v7 = 5;
  v6 = 3;
  v5 = search(v4, 5i64, 3i64);
  if ( v5 == -1 )
    printf("Key not found\n");
  else
    printf("Key found at index %d\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall search(_QWORD, _QWORD, _QWORD);
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database Indexing System ; Style: shocked
#include <stdio.h>
#include <stdlib.h>

/* Define a struct to represent a person */
typedef struct Person {
    char* name;
    int age;
    int id;
} Person;

/* Define a struct to represent a node in the binary tree */
typedef struct Node {
    Person person;
    struct Node* left;
    struct Node* right;
} Node;

/* Define a function to create a new node in the binary tree */
Node* new_node(Person person) {
    Node* node = (Node*) malloc(sizeof(Node));
    node->person = person;
    node->left = NULL;
    node->right = NULL;
    return node;
}

/* Define a function to insert a person into the binary tree */
Node* insert(Node* root, Person person) {
    if (root == NULL) {
        return new_node(person);
    } else if (person.id < root->person.id) {
        root->left = insert(root->left, person);
    } else {
        root->right = insert(root->right, person);
    }
    return root;
}

/* Define a function to search for a person in the binary tree */
Person* search(Node* root, int id) {
    if (root == NULL) {
        return NULL;
    } else if (id == root->person.id) {
        return &(root->person);
    } else if (id < root->person.id) {
        return search(root->left, id);
    } else {
        return search(root->right, id);
    }
}

/* Define a function to print all the people in the binary tree */
void print(Node* root) {
    if (root == NULL) {
        return;
    }
    print(root->left);
    printf("Name: %s, Age: %d, ID: %d\n", root->person.name, root->person.age, root->person.id);
    print(root->right);
}

/* Define the main function */
int main() {
    Node* root = NULL;

    /* Insert some people into the binary tree */
    root = insert(root, (Person) { "Alice", 25, 1 });
    root = insert(root, (Person) { "Bob", 30, 2 });
    root = insert(root, (Person) { "Charlie", 35, 3 });

    /* Search for a person in the binary tree */
    Person* person = search(root, 2);
    if (person == NULL) {
        printf("Person not found!\n");
    } else {
        printf("Name: %s, Age: %d, ID: %d\n", person->name, person->age, person->id);
    }

    /* Print all the people in the binary tree */
    print(root);

    return 0; 
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall insert(_QWORD, _QWORD); // weak
__int64 __fastcall search(_QWORD, _QWORD); // weak
__int64 __fastcall print(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000177D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v4; // [rsp+20h] [rbp-20h] BYREF
  __int64 v5; // [rsp+28h] [rbp-18h]
  __int64 v6; // [rsp+30h] [rbp-10h]
  __int64 v7; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  v7 = 0i64;
  v4 = "Alice";
  v5 = 0x100000019i64;
  v7 = insert(0i64, &v4);
  v4 = "Bob";
  v5 = 0x20000001Ei64;
  v7 = insert(v7, &v4);
  v4 = "Charlie";
  v5 = 0x300000023i64;
  v7 = insert(v7, &v4);
  v6 = search(v7, 2i64);
  if ( v6 )
    printf("Name: %s, Age: %d, ID: %d\n", *(const char **)v6, *(unsigned int *)(v6 + 8), *(unsigned int *)(v6 + 12));
  else
    printf("Person not found!\n");
  print(v7);
  return 0;
}
// 1400015F2: using guessed type __int64 __fastcall insert(_QWORD, _QWORD);
// 1400016AB: using guessed type __int64 __fastcall search(_QWORD, _QWORD);
// 140001714: using guessed type __int64 __fastcall print(_QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text-Based Adventure Game ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// function to generate random number between min and max
int getRandomNumber(int min, int max) {
    return (rand() % (max - min + 1)) + min;
}

int main() {
    // seed the random number generator with system time
    srand(time(0));
    
    printf("Welcome to the Text-Based Adventure Game!\n");
    printf("You find yourself in a dark forest. How did you get here?\n");
    printf("Look around and find a way out.\n");
    
    int playerChoice;
    int randomNumber;
    int hasKey = 0;
    
    while (1) {
        printf("\nWhat would you like to do?\n");
        printf("1. Walk north\n");
        printf("2. Walk south\n");
        printf("3. Walk east\n");
        printf("4. Walk west\n");
        printf("5. Search area\n");
        printf("6. Quit\n");
        
        scanf("%d", &playerChoice);
        
        switch(playerChoice) {
            case 1:
                printf("You walk north but there's no way out.\n");
                break;
            case 2:
                printf("You walk south but there's no way out.\n");
                break;
            case 3:
                printf("You walk east but there's no way out.\n");
                break;
            case 4:
                printf("You walk west and find an old cabin.\n");
                printf("Do you want to go inside? (1 = yes, 2 = no): ");
                
                scanf("%d", &playerChoice);
                
                if (playerChoice == 1) {
                    printf("You go inside the cabin and find a key.\n");
                    hasKey = 1;
                } else {
                    printf("You decide not to enter the cabin.\n");
                }
                break;
            case 5:
                printf("You search the area and find a locked door.\n");
                printf("Do you want to try the key? (1 = yes, 2 = no): ");
                
                if (hasKey) {
                    scanf("%d", &playerChoice);
                    
                    if (playerChoice == 1) {
                        printf("You try the key and it unlocks the door!\n");
                        printf("Congratulations, you've found your way out of the forest!\n");
                        return 0;
                    } else {
                        printf("You decide not to use the key.\n");
                    }
                } else {
                    printf("You need a key to try the door.\n");
                }
                break;
            case 6:
                printf("Thanks for playing the Text-Based Adventure Game!\n");
                return 0;
            default:
                printf("Invalid choice, please try again.\n");
                break;
        }
        
        // generate a random obstacle
        randomNumber = getRandomNumber(1, 4);
        
        if (randomNumber == 1) {
            printf("You hear a loud noise nearby.\n");
        } else if (randomNumber == 2) {
            printf("You see a strange figure in the distance.\n");
        } else if (randomNumber == 3) {
            printf("You feel like you're being watched.\n");
        } else {
            printf("You trip over a fallen tree.\n");
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall getRandomNumber(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (000000014000162B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  int RandomNumber; // [rsp+28h] [rbp-8h]
  int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Text-Based Adventure Game!\n");
  printf("You find yourself in a dark forest. How did you get here?\n");
  printf("Look around and find a way out.\n");
  v7 = 0;
  while ( 2 )
  {
    printf("\nWhat would you like to do?\n");
    printf("1. Walk north\n");
    printf("2. Walk south\n");
    printf("3. Walk east\n");
    printf("4. Walk west\n");
    printf("5. Search area\n");
    printf("6. Quit\n");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        printf("You walk north but there's no way out.\n");
        goto LABEL_16;
      case 2:
        printf("You walk south but there's no way out.\n");
        goto LABEL_16;
      case 3:
        printf("You walk east but there's no way out.\n");
        goto LABEL_16;
      case 4:
        printf("You walk west and find an old cabin.\n");
        printf("Do you want to go inside? (1 = yes, 2 = no): ");
        scanf("%d", &v5);
        if ( v5 == 1 )
        {
          printf("You go inside the cabin and find a key.\n");
          v7 = 1;
        }
        else
        {
          printf("You decide not to enter the cabin.\n");
        }
        goto LABEL_16;
      case 5:
        printf("You search the area and find a locked door.\n");
        printf("Do you want to try the key? (1 = yes, 2 = no): ");
        if ( !v7 )
        {
          printf("You need a key to try the door.\n");
          goto LABEL_16;
        }
        scanf("%d", &v5);
        if ( v5 != 1 )
        {
          printf("You decide not to use the key.\n");
LABEL_16:
          RandomNumber = getRandomNumber(1i64, 4i64);
          switch ( RandomNumber )
          {
            case 1:
              printf("You hear a loud noise nearby.\n");
              break;
            case 2:
              printf("You see a strange figure in the distance.\n");
              break;
            case 3:
              printf("You feel like you're being watched.\n");
              break;
            default:
              printf("You trip over a fallen tree.\n");
              break;
          }
          continue;
        }
        printf("You try the key and it unlocks the door!\n");
        printf("Congratulations, you've found your way out of the forest!\n");
        return 0;
      case 6:
        printf("Thanks for playing the Text-Based Adventure Game!\n");
        return 0;
      default:
        printf("Invalid choice, please try again.\n");
        goto LABEL_16;
    }
  }
}
// 140001601: using guessed type __int64 __fastcall getRandomNumber(_QWORD, _QWORD);
// 1400019B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Educational ; Style: creative
#include <stdio.h>
#include <stdlib.h>

int main() {
   int n;
   int sum = 0;
   printf("Enter a integer number n: ");
   scanf("%d", &n);
   
   if (n <= 0) {
      printf("Invalid input!\n");
      return 0;
   }

   printf("The sequence is: ");
   for (int i = 1; i <= n; i++) {
      printf("%d ", i);
      sum += i;
   }

   printf("\nThe sum of the sequence is: %d\n", sum);
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  printf("Enter a integer number n: ");
  scanf("%d", &v4);
  if ( v4 > 0 )
  {
    printf("The sequence is: ");
    for ( i = 1; (int)i <= v4; ++i )
    {
      printf("%d ", i);
      v6 += i;
    }
    printf("\nThe sum of the sequence is: %d\n", v6);
    return 0;
  }
  else
  {
    printf("Invalid input!\n");
    return 0;
  }
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text processing ; Style: surprised
#include <stdio.h>
#include <string.h>

int main()
{
   char string[100];
   int i, j, len;
   
   printf("Wow, I'm so surprised to see you here!\n\n");
   printf("What string would you like to process? ");
   scanf("%s", string);

   len = strlen(string);

   printf("\n\nProcessing your string...\n\n");

   for(i=0; i<len; i++)
   {
      for(j=0; j<=i; j++)
      {
          printf("%c", string[j]);
      }
      printf("\n");
   }

   printf("\n");
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[100]; // [rsp+20h] [rbp-70h] BYREF
  int v5; // [rsp+84h] [rbp-Ch]
  int j; // [rsp+88h] [rbp-8h]
  int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Wow, I'm so surprised to see you here!\n\n");
  printf("What string would you like to process? ");
  scanf("%s", Str);
  v5 = strlen(Str);
  printf("\n\nProcessing your string...\n\n");
  for ( i = 0; i < v5; ++i )
  {
    for ( j = 0; j <= i; ++j )
      printf("%c", (unsigned int)Str[j]);
    printf("\n");
  }
  printf("\n");
  return 0;
}
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[100];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cryptographic hash function ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

unsigned long hash(unsigned char *str){
    unsigned long hash = 5381;
    int c;

    while (c = *str++)
        hash = ((hash << 5) + hash) + c;

    return hash;
}

int main() {
  char msg[] = "This is a unique C Cryptographic hash function example program";
  printf("Calculating the hash of the message '%s'...\n", msg);
  
  unsigned long result = hash(msg);
  printf("The hash result is %lu\n", result);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall hash(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015DF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[76]; // [rsp+20h] [rbp-50h] BYREF
  unsigned int v5; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  strcpy(v4, "This is a unique C Cryptographic hash function example program");
  printf("Calculating the hash of the message '%s'...\n", v4);
  v5 = hash(v4);
  printf("The hash result is %lu\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall hash(_QWORD);
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mailing list manager ; Style: Cryptic
#include <stdio.h>

#define MAX_EMAILS 100

char emails[MAX_EMAILS][80]; // array of emails
int num_emails = 0; // number of emails currently in the list

void add_email(char email[]) {
    if (num_emails < MAX_EMAILS) {
        strcpy(emails[num_emails], email);
        num_emails++;
    } else {
        printf("Sorry, the maximum number of emails has been reached.\n");
    }
}

void remove_email(char email[]) {
    int i, j;
    for (i = 0; i < num_emails; i++) {
        if (strcmp(emails[i], email) == 0) {
            // found matching email, shift all subsequent emails left to delete it
            for (j = i+1; j < num_emails; j++) {
                strcpy(emails[j-1], emails[j]);
            }
            num_emails--;
            return;
        }
    }
    printf("Sorry, that email was not found in the mailing list.\n");
}

void display_emails() {
    int i;
    for (i = 0; i < num_emails; i++) {
        printf("%s\n", emails[i]);
    }
}

int main() {
    char command[80], email[80];

    while (1) {
        printf("Enter a command ('add', 'remove', 'display', or 'quit'): ");
        fgets(command, sizeof(command), stdin);

        if (strcmp(command, "add\n") == 0) {
            printf("Enter email to add: ");
            fgets(email, sizeof(email), stdin);
            add_email(email);
        } else if (strcmp(command, "remove\n") == 0) {
            printf("Enter email to remove: ");
            fgets(email, sizeof(email), stdin);
            remove_email(email);
        } else if (strcmp(command, "display\n") == 0) {
            display_emails();
        } else if (strcmp(command, "quit\n") == 0) {
            printf("Exiting program.\n");
            break;
        } else {
            printf("Sorry, that command is not recognized.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall add_email(_QWORD); // weak
__int64 __fastcall remove_email(_QWORD); // weak
__int64 display_emails(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001735) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  char v7[80]; // [rsp+20h] [rbp-A0h] BYREF
  char Buffer[80]; // [rsp+70h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          printf("Enter a command ('add', 'remove', 'display', or 'quit'): ");
          v3 = __acrt_iob_func(0);
          fgets(Buffer, 80, v3);
          if ( strcmp(Buffer, "add\n") )
            break;
          printf("Enter email to add: ");
          v4 = __acrt_iob_func(0);
          fgets(v7, 80, v4);
          add_email(v7);
        }
        if ( strcmp(Buffer, "remove\n") )
          break;
        printf("Enter email to remove: ");
        v5 = __acrt_iob_func(0);
        fgets(v7, 80, v5);
        remove_email(v7);
      }
      if ( strcmp(Buffer, "display\n") )
        break;
      display_emails();
    }
    if ( !strcmp(Buffer, "quit\n") )
      break;
    printf("Sorry, that command is not recognized.\n");
  }
  printf("Exiting program.\n");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall add_email(_QWORD);
// 1400015FC: using guessed type __int64 __fastcall remove_email(_QWORD);
// 1400016DD: using guessed type __int64 display_emails(void);
// 140001960: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Resume Parsing System ; Style: systematic
#include <stdio.h>
#include <string.h>
#include <ctype.h>

// function prototypes
void parseResume(char *resumeText);
int extractEducation(char *resumeText, char *educationLine[], int *numLines);
int extractExperience(char *resumeText, char *experienceLine[], int *numLines);

int main() {
    char resume[10000]; // assuming resume will not be longer than 10,000 characters
    printf("Enter your resume text:\n");
    fgets(resume, sizeof(resume), stdin); // read resume text from user

    parseResume(resume); // parse resume text and display extracted education and experience

    return 0;
}

// function to parse resume text and extract education and experience sections
void parseResume(char *resumeText) {
    char *educationLine[10]; // assuming maximum of 10 education lines
    int numEducationLines = extractEducation(resumeText, educationLine, &numEducationLines);
    printf("\nEDUCATION:\n");
    for (int i = 0; i < numEducationLines; i++) {
        printf("%s\n", educationLine[i]);
    }

    char *experienceLine[10]; // assuming maximum of 10 experience lines
    int numExperienceLines = extractExperience(resumeText, experienceLine, &numExperienceLines);
    printf("\nEXPERIENCE:\n");
    for (int i = 0; i < numExperienceLines; i++) {
        printf("%s\n", experienceLine[i]);
    }
}

// function to extract education section from resume text
int extractEducation(char *resumeText, char *educationLine[], int *numLines) {
    *numLines = 0;
    char *start = strstr(resumeText, "education");
    if (start == NULL) {
        return 0; // no education section found
    }

    start += strlen("education") + 1; // skip "education" and the following space
    char *end = strstr(start, "experience");
    if (end == NULL) {
        end = resumeText + strlen(resumeText); // if experience section not found, use end of resume text
    }

    // extract each line of education section
    int i = 0;
    while (start < end) {
        char *lineEnd = strstr(start, "\n");
        if (lineEnd == NULL || lineEnd > end) {
            lineEnd = end; // if end of line not found or crossed experience section, use end of education section
        }

        // trim leading and trailing spaces from line
        while (isspace(*start)) {
            start++;
        }
        while (isspace(*(lineEnd - 1))) {
            lineEnd--;
        }

        int len = lineEnd - start;
        educationLine[i] = malloc(len + 1); // allocate memory for line
        strncpy(educationLine[i], start, len);
        educationLine[i][len] = '\0'; // terminate string
        i++;

        *numLines = i;
        if (i >= 10) {
            break; // maximum of 10 lines extracted
        }

        start = lineEnd + 1;
    }

    return i;
}

// function to extract experience section from resume text
int extractExperience(char *resumeText, char *experienceLine[], int *numLines) {
    *numLines = 0;
    char *start = strstr(resumeText, "experience");
    if (start == NULL) {
        return 0; // no experience section found
    }

    start += strlen("experience") + 1; // skip "experience" and the following space

    // extract each line of experience section
    int i = 0;
    while (*start != '\0') {
        char *lineEnd = strstr(start, "\n");

        // trim leading and trailing spaces from line
        while (isspace(*start)) {
            start++;
        }
        while (isspace(*(lineEnd - 1))) {
            lineEnd--;
        }

        int len = lineEnd - start;
        experienceLine[i] = malloc(len + 1); // allocate memory for line
        strncpy(experienceLine[i], start, len);
        experienceLine[i][len] = '\0'; // terminate string
        i++;

        *numLines = i;
        if (i >= 10) {
            break; // maximum of 10 lines extracted
        }

        start = lineEnd + 1;
    }

    return i;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall parseResume(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[10000]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  printf("Enter your resume text:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 10000, v3);
  parseResume(Buffer);
  return 0;
}
// 1400015FA: using guessed type __int64 __fastcall parseResume(_QWORD);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    FILE *file_ptr;
    char text[1000];
    int length;

    // Ask user for file path
    printf("Enter the path of the text file: ");
    fgets(text, 1000, stdin);
    length = strlen(text);
    text[length-1] = '\0';

    // Attempt to open the file
    file_ptr = fopen(text, "a+");
    if (file_ptr == NULL) {
        printf("File could not be opened.\n");
        return 1;
    }

    // Print a puzzle to the console
    printf("Crack this code to get the next clue:\n");
    printf("86 104 97 116 39 115 32 103 111 105 110 103 32 111 110 63\n");

    // Get user input to solve puzzle
    fgets(text, 1000, stdin);
    length = strlen(text);
    text[length-1] = '\0';

    // Check if the answer is correct
    if (strcmp(text, "What's going on?") != 0) {
        printf("Incorrect answer.\n");
        return 1;
    }

    // Write the next clue to the file
    fprintf(file_ptr, "The next clue is: 'The quick brown fox jumps over the lazy dog.'\n");

    // Close the file
    fclose(file_ptr);

    // Print success message
    printf("Congratulations! You solved the puzzle and found the next clue.\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v5; // rax
  char Buffer[1008]; // [rsp+20h] [rbp-60h] BYREF
  FILE *Stream; // [rsp+410h] [rbp+390h]
  int v8; // [rsp+41Ch] [rbp+39Ch]

  _main(argc, argv, envp);
  printf("Enter the path of the text file: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v8 = strlen(Buffer);
  Buffer[v8 - 1] = 0;
  Stream = fopen(Buffer, "a+");
  if ( Stream )
  {
    printf("Crack this code to get the next clue:\n");
    printf("86 104 97 116 39 115 32 103 111 105 110 103 32 111 110 63\n");
    v5 = __acrt_iob_func(0);
    fgets(Buffer, 1000, v5);
    v8 = strlen(Buffer);
    Buffer[v8 - 1] = 0;
    if ( !strcmp(Buffer, "What's going on?") )
    {
      fprintf_0(Stream, "The next clue is: 'The quick brown fox jumps over the lazy dog.'\n");
      fclose(Stream);
      printf("Congratulations! You solved the puzzle and found the next clue.\n");
      return 0;
    }
    else
    {
      printf("Incorrect answer.\n");
      return 1;
    }
  }
  else
  {
    printf("File could not be opened.\n");
    return 1;
  }
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015D4: using guessed type char Buffer[1008];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Date and time ; Style: single-threaded
#include <stdio.h>
#include <time.h>

int main() {
  time_t rawtime;
  struct tm * timeinfo;
  int i;

  time(&rawtime);
  timeinfo = localtime(&rawtime);

  printf("Current date and time: %s", asctime(timeinfo));

  //custom date and time
  timeinfo->tm_year = 121;   // year starting from 1900 
  timeinfo->tm_mon = 6;      // 0-11
  timeinfo->tm_mday = 23;    //1-31
  timeinfo->tm_hour = 14;    //0-23
  timeinfo->tm_min = 45;     //0-59
  timeinfo->tm_sec = 30;     //0-60

  //convert custom date and time into time_t format
  time_t t = mktime(timeinfo);

  //adjust timezone
  timeinfo = localtime(&t);

  printf("Custom date and time: %s", asctime(timeinfo));

  //example for printing current date and time repeatedly for 10 times with 1 second delay
  for (i=0; i<10; i++) {
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    printf("Current date and time: %s", asctime(timeinfo));
    sleep(1);
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static struct tm *__cdecl localtime(const time_t *const Time);
static time_t __cdecl mktime(struct tm *const Tm);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// char *__cdecl asctime(const struct tm *Tm);


//----- (00000001400015EE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v3; // rax
  char *v4; // rax
  char *v5; // rax
  time_t v7; // [rsp+20h] [rbp-20h] BYREF
  time_t Time; // [rsp+28h] [rbp-18h] BYREF
  struct tm *Tm; // [rsp+30h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  time(&Time);
  Tm = localtime(&Time);
  v3 = asctime(Tm);
  printf("Current date and time: %s", v3);
  Tm->tm_year = 121;
  Tm->tm_mon = 6;
  Tm->tm_mday = 23;
  Tm->tm_hour = 14;
  Tm->tm_min = 45;
  Tm->tm_sec = 30;
  v7 = mktime(Tm);
  Tm = localtime(&v7);
  v4 = asctime(Tm);
  printf("Custom date and time: %s", v4);
  for ( i = 0; i <= 9; ++i )
  {
    time(&Time);
    Tm = localtime(&Time);
    v5 = asctime(Tm);
    printf("Current date and time: %s", v5);
    sleep(1i64);
  }
  return 0;
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002830: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Error handling ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

int main(int argc, char *argv[]) {
    FILE *file = fopen("file.txt", "r");
    if (file == NULL) {
        perror("Error while opening the file");
        return EXIT_FAILURE;
    }

    char buffer[256];
    if (fgets(buffer, sizeof(buffer), file) == NULL) {
        if (ferror(file)) {
            perror("Error while reading from the file");
        } else {
            fprintf(stderr, "Unexpected end of file\n");
        }
        fclose(file);
        return EXIT_FAILURE;
    }

    printf("The content of the file is: %s", buffer);
    fclose(file);
    return EXIT_SUCCESS;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl perror(const char *ErrMsg);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl ferror(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v4; // rax
  char Buffer[264]; // [rsp+20h] [rbp-60h] BYREF
  FILE *Stream; // [rsp+128h] [rbp+A8h]

  _main(argc, argv, envp);
  Stream = fopen("file.txt", "r");
  if ( Stream )
  {
    if ( fgets(Buffer, 256, Stream) )
    {
      printf("The content of the file is: %s", Buffer);
      fclose(Stream);
      return 0;
    }
    else
    {
      if ( ferror(Stream) )
      {
        perror("Error while reading from the file");
      }
      else
      {
        v4 = __acrt_iob_func(2u);
        fprintf_0(v4, "Unexpected end of file\n");
      }
      fclose(Stream);
      return 1;
    }
  }
  else
  {
    perror("Error while opening the file");
    return 1;
  }
}
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Metadata Extractor ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char *name;
    char *artist; 
    char *album; 
    int year;
} Song;

void extract_metadata(char *file_path, Song *song) {
    printf("Surprise, surprise! We're going to extract the metadata of %s.\n", file_path);
    
    // Let's pretend we're doing some really complex metadata extraction here
    song->name = "Cool Song";
    song->artist = "Awesome Artist";
    song->album = "Incredible Album";
    song->year = 2021;
    
    // Print out the extracted metadata
    printf("Song: %s\n", song->name);
    printf("Artist: %s\n", song->artist);
    printf("Album: %s\n", song->album);
    printf("Year: %d\n", song->year);
}

int main() {
    char *file_path = "path/to/file.mp3";
    Song *song = malloc(sizeof(Song));
    
    extract_metadata(file_path, song);
    
    free(song);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall extract_metadata(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (0000000140001657) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *Block; // [rsp+20h] [rbp-10h]

  _main(argc, argv, envp);
  Block = malloc(0x20ui64);
  extract_metadata("path/to/file.mp3", Block);
  free(Block);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall extract_metadata(_QWORD, _QWORD);
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Email Client ; Style: lively
#include <stdio.h>
#include <stdlib.h>

#define MAX_EMAILS 10
#define MAX_SUBJECT_LENGTH 50
#define MAX_MESSAGE_LENGTH 100

struct Email {
  char subject[MAX_SUBJECT_LENGTH];
  char message[MAX_MESSAGE_LENGTH];
  char to[50];
  char from[50];
  int id;
  int isSent;
};

struct Email *emails[MAX_EMAILS];
int email_count = 0;

void send_email() {
  struct Email email;
  printf("Enter recipient's email address: ");
  scanf("%s", email.to);
  printf("Enter subject: ");
  scanf("%s", email.subject);
  printf("Enter message: ");
  scanf("%s", email.message);
  printf("Enter sender's email address: ");
  scanf("%s", email.from);
  email.id = email_count;
  email.isSent = 1;

  emails[email_count] = (struct Email *) malloc(sizeof(struct Email));
  *emails[email_count] = email;
  email_count++;

  printf("\nEmail sent successfully!\n");
}

void view_email() {
  int id;
  printf("Enter email id: ");
  scanf("%d", &id);

  if (id >= email_count || id < 0) {
    printf("Invalid email id!\n");
    return;
  }

  struct Email *email = emails[id];
  printf("\nTo: %s\n", email->to);
  printf("Subject: %s\n", email->subject);
  printf("Message: %s\n", email->message);
  printf("From: %s\n\n", email->from);
}

void list_emails() {
  printf("%-5s%-15s%-30s\n", "ID", "To", "Subject");

  for (int i = 0; i < email_count; i++) {
    struct Email *email = emails[i];
    if (email->isSent) {
      printf("%-5d%-15s%-30s\n", email->id, email->to, email->subject);
    }
  }
}

void delete_email() {
  int id;
  printf("Enter email id: ");
  scanf("%d", &id);

  if (id >= email_count || id < 0) {
    printf("Invalid email id!\n");
    return;
  }

  struct Email *email = emails[id];
  email->isSent = 0;
  printf("Email deleted successfully!\n");
}

int main() {
  int choice;
  do {
    printf("\n");
    printf("1. Send Email\n");
    printf("2. View Email\n");
    printf("3. List Emails\n");
    printf("4. Delete Email\n");
    printf("5. Quit\n");
    printf("Enter your choice: ");

    scanf("%d", &choice);

    switch (choice) {
      case 1:
        send_email();
        break;
      case 2:
        view_email();
        break;
      case 3:
        list_emails();
        break;
      case 4:
        delete_email();
        break;
      case 5:
        printf("\nGoodbye!\n");
        break;
      default:
        printf("Invalid choice!\n");
        break;
    }

  } while (choice != 5);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 send_email(void); // weak
__int64 view_email(void); // weak
__int64 list_emails(void); // weak
__int64 delete_email(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000198D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("\n");
    printf("1. Send Email\n");
    printf("2. View Email\n");
    printf("3. List Emails\n");
    printf("4. Delete Email\n");
    printf("5. Quit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        send_email();
        break;
      case 2:
        view_email();
        break;
      case 3:
        list_emails();
        break;
      case 4:
        delete_email();
        break;
      case 5:
        printf("\nGoodbye!\n");
        break;
      default:
        printf("Invalid choice!\n");
        break;
    }
  }
  while ( v4 != 5 );
  return 0;
}
// 1400015E2: using guessed type __int64 send_email(void);
// 140001772: using guessed type __int64 view_email(void);
// 140001852: using guessed type __int64 list_emails(void);
// 1400018FB: using guessed type __int64 delete_email(void);
// 140001B50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Count Tool ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_CHARS 1000

int main(){
    char text[MAX_CHARS];
    int wordCount = 0;
    char* word;
    printf("Welcome to the Unique C Word Count Tool\n\n");
    printf("Enter your text: ");

    fgets(text, MAX_CHARS, stdin);

    // make a duplicate text buffer to modify
    char duplicate[MAX_CHARS];
    strcpy(duplicate, text);

    // tokenize the text to count unique words
    word = strtok(text, " ,.!?;\n");

    // put all unique words in a separate array
    char unique_words[MAX_CHARS][MAX_CHARS];
    char* temp;
    int unique_word_count = 0;

    while(word != NULL){
        int is_unique = 1;
        for(int i = 0; i < unique_word_count; i++){
            if(strcmp(unique_words[i], word) == 0){
                is_unique = 0;
                break;
            }
        }
        if(is_unique){
            strcpy(unique_words[unique_word_count], word);
            unique_word_count++;
        }

        word = strtok(NULL, " ,.!?;\n");
    }

    printf("\nUnique Words:\n");

    for(int i = 0; i < unique_word_count; i++){
        printf("%s\n", unique_words[i]);
    }

    // print each unique word's count
    printf("\nWord Count:\n");

    word = strtok(duplicate, " ,.!?;\n");

    while(word != NULL){
        int count = 0;
        for(int i = 0; i < unique_word_count; i++){
            if(strcmp(unique_words[i], word) == 0){
                count++;
            }
        }
        printf("%s: %d\n", word, count);
        word = strtok(NULL, " ,.!?;\n");
        wordCount++;
    }

    printf("\nTotal word count: %d\n", wordCount);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char v5[1000000]; // [rsp+20h] [rbp-60h] BYREF
  char Destination[1008]; // [rsp+F4260h] [rbp+F41E0h] BYREF
  char Buffer[1000]; // [rsp+F4650h] [rbp+F45D0h] BYREF
  int k; // [rsp+F4A38h] [rbp+F49B8h]
  unsigned int v9; // [rsp+F4A3Ch] [rbp+F49BCh]
  int j; // [rsp+F4A40h] [rbp+F49C0h]
  int i; // [rsp+F4A44h] [rbp+F49C4h]
  int v12; // [rsp+F4A48h] [rbp+F49C8h]
  int v13; // [rsp+F4A4Ch] [rbp+F49CCh]
  char *Str2; // [rsp+F4A50h] [rbp+F49D0h]
  unsigned int v15; // [rsp+F4A5Ch] [rbp+F49DCh]

  _main(argc, argv, envp);
  v15 = 0;
  printf("Welcome to the Unique C Word Count Tool\n\n");
  printf("Enter your text: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  strcpy(Destination, Buffer);
  Str2 = strtok(Buffer, " ,.!?;\n");
  v13 = 0;
  while ( Str2 )
  {
    v12 = 1;
    for ( i = 0; i < v13; ++i )
    {
      if ( !strcmp(&v5[1000 * i], Str2) )
      {
        v12 = 0;
        break;
      }
    }
    if ( v12 )
      strcpy(&v5[1000 * v13++], Str2);
    Str2 = strtok(0i64, " ,.!?;\n");
  }
  printf("\nUnique Words:\n");
  for ( j = 0; j < v13; ++j )
    printf("%s\n", &v5[1000 * j]);
  printf("\nWord Count:\n");
  Str2 = strtok(Destination, " ,.!?;\n");
  while ( Str2 )
  {
    v9 = 0;
    for ( k = 0; k < v13; ++k )
    {
      if ( !strcmp(&v5[1000 * k], Str2) )
        ++v9;
    }
    printf("%s: %d\n", Str2, v9);
    Str2 = strtok(0i64, " ,.!?;\n");
    ++v15;
  }
  printf("\nTotal word count: %d\n", v15);
  return 0;
}
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char var_F4A40[1000000];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Compression algorithms ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 100000

int main()
{
    char originalString[MAX_SIZE], compressedString[MAX_SIZE];
    int count[MAX_SIZE], freq[MAX_SIZE];
    int i, j, k, length, compressedLength = 0, compressionRatio;

    printf("Enter the string to be compressed: ");
    gets(originalString);

    length = strlen(originalString);

    //ASCII range is from 0 to 127. So, initializing count array with 0.
    for(i = 0; i < 128; i++)
        count[i] = 0;

    //counting the frequency of each character
    for(i = 0; i < length; i++)
        count[(int)originalString[i]]++;

    k = 0;
    //generate compressed string
    for(i = 0; i < 128; i++)
    {
        if(count[i] != 0)
        {
            compressedString[k++] = (char)i;
            compressedString[k++] = (char)count[i];
        }
    }

    compressedLength = strlen(compressedString);

    //calculate compression ratio
    compressionRatio = (length - compressedLength) * 100 / length;

    printf("\nOriginal String: %s\n", originalString);
    printf("Compressed String: %s\n", compressedString);
    printf("Compression Ratio: %d percent\n", compressionRatio);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// __int64 __fastcall gets(_QWORD); weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v7[100000]; // [rsp+61AA0h] [rbp+61A20h]
  char v8[100000]; // [rsp+C3520h] [rbp+C34A0h] BYREF
  char Str[100012]; // [rsp+DBBC0h] [rbp+DBB40h] BYREF
  unsigned int v10; // [rsp+F426Ch] [rbp+F41ECh]
  int v11; // [rsp+F4270h] [rbp+F41F0h]
  int v12; // [rsp+F4274h] [rbp+F41F4h]
  int v13; // [rsp+F4278h] [rbp+F41F8h]
  int i; // [rsp+F427Ch] [rbp+F41FCh]

  _main(argc, argv, envp);
  v12 = 0;
  printf("Enter the string to be compressed: ");
  gets(Str);
  v11 = strlen(Str);
  for ( i = 0; i <= 127; ++i )
    v7[i] = 0;
  for ( i = 0; i < v11; ++i )
    ++v7[Str[i]];
  v13 = 0;
  for ( i = 0; i <= 127; ++i )
  {
    if ( v7[i] )
    {
      v3 = v13++;
      v8[v3] = i;
      v4 = v7[i];
      v5 = v13++;
      v8[v5] = v4;
    }
  }
  v12 = strlen(v8);
  v10 = 100 * (v11 - v12) / v11;
  printf("\nOriginal String: %s\n", Str);
  printf("Compressed String: %s\n", v8);
  printf("Compression Ratio: %d percent\n", v10);
  return 0;
}
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140008A80: using guessed type __int64 __fastcall gets(_QWORD);
// 140001591: using guessed type char Str[100012];
// 140001591: using guessed type int var_927E0[100000];
// 140001591: using guessed type char var_30D60[100000];

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Log analysis ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    FILE *file;
    char line[100];
    int num_of_lines = 0;
    int num_of_errors = 0;
    int num_of_warnings = 0;
    
    // Check if the file exists
    if ((file = fopen("log.txt", "r")) == NULL) {
        printf("Error opening file.\n");
        return 1;   
    }
    
    // Read each line of the file
    while (fgets(line, sizeof(line), file)) {
        num_of_lines++;
        
        // Count the number of errors
        if (strstr(line, "ERROR") != NULL) {
            num_of_errors++;
        }
        
        // Count the number of warnings
        if (strstr(line, "WARNING") != NULL) {
            num_of_warnings++;
        }
    }
    
    // Close the file
    fclose(file);
    
    // Print the results
    printf("Number of lines: %d\n", num_of_lines);
    printf("Number of errors: %d\n", num_of_errors);
    printf("Number of warnings: %d\n", num_of_warnings);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[104]; // [rsp+20h] [rbp-80h] BYREF
  FILE *Stream; // [rsp+88h] [rbp-18h]
  unsigned int v6; // [rsp+94h] [rbp-Ch]
  unsigned int v7; // [rsp+98h] [rbp-8h]
  unsigned int v8; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 0;
  v7 = 0;
  v6 = 0;
  Stream = fopen("log.txt", "r");
  if ( Stream )
  {
    while ( fgets(Str, 100, Stream) )
    {
      ++v8;
      if ( strstr(Str, "ERROR") )
        ++v7;
      if ( strstr(Str, "WARNING") )
        ++v6;
    }
    fclose(Stream);
    printf("Number of lines: %d\n", v8);
    printf("Number of errors: %d\n", v7);
    printf("Number of warnings: %d\n", v6);
    return 0;
  }
  else
  {
    printf("Error opening file.\n");
    return 1;
  }
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Electronic Voting System ; Style: irregular
#include <stdio.h>
#include <stdlib.h>

int main() {
  int votes[5] = {0}; // An array to store the vote counts
  int choice;
  printf("Welcome to the Electronic Voting System!\n");

  while (1) { // An infinite loop will keep the program running until it is manually terminated
    printf("\nPlease select your candidate (1-5):\n");
    printf("1. John Snow\n2. Daenerys Targaryen\n3. Tyrion Lannister\n4. Sansa Stark\n5. Arya Stark\n");
    printf("Choice: ");
    scanf("%d", &choice); // Read the user's choice

    switch (choice) { // Use a switch statement to add a vote to the corresponding candidate's count
      case 1:
        votes[0] += 1;
        break;
      case 2:
        votes[1] += 1;
        break;
      case 3:
        votes[2] += 1;
        break;
      case 4:
        votes[3] += 1;
        break;
      case 5:
        votes[4] += 1;
        break;
      default:
        printf("Invalid choice! Please try again.\n");
    }

    printf("Current Vote Count:\n"); // Display the current vote count after each vote is added
    printf("John Snow: %d\n", votes[0]);
    printf("Daenerys Targaryen: %d\n", votes[1]);
    printf("Tyrion Lannister: %d\n", votes[2]);
    printf("Sansa Stark: %d\n", votes[3]);
    printf("Arya Stark: %d\n", votes[4]);
  }

  return 0; // End of program
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-24h] BYREF
  __int64 v5; // [rsp+30h] [rbp-20h]
  __int64 v6; // [rsp+38h] [rbp-18h]
  unsigned int v7; // [rsp+40h] [rbp-10h]

  _main(argc, argv, envp);
  v5 = 0i64;
  v6 = 0i64;
  v7 = 0;
  printf("Welcome to the Electronic Voting System!\n");
  while ( 1 )
  {
    printf("\nPlease select your candidate (1-5):\n");
    printf("1. John Snow\n2. Daenerys Targaryen\n3. Tyrion Lannister\n4. Sansa Stark\n5. Arya Stark\n");
    printf("Choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        LODWORD(v5) = v5 + 1;
        break;
      case 2:
        ++HIDWORD(v5);
        break;
      case 3:
        LODWORD(v6) = v6 + 1;
        break;
      case 4:
        ++HIDWORD(v6);
        break;
      case 5:
        ++v7;
        break;
      default:
        printf("Invalid choice! Please try again.\n");
        break;
    }
    printf("Current Vote Count:\n");
    printf("John Snow: %d\n", (unsigned int)v5);
    printf("Daenerys Targaryen: %d\n", HIDWORD(v5));
    printf("Tyrion Lannister: %d\n", (unsigned int)v6);
    printf("Sansa Stark: %d\n", HIDWORD(v6));
    printf("Arya Stark: %d\n", v7);
  }
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: curious
#include<stdio.h>
#include<stdlib.h>

int main()
{
    int i,j;
    int width = 20;
    int height = 20;
    int pixels[20][20];

    for(i=0; i<height; i++)
    {
        for(j=0; j<width; j++)
        {
            if((i==1 && j>=6 && j<=13) || (i==4 && j>=5 && j<=14) || (j==4 && i>=6 && i<=8) || (j==15 && i>=6 && i<=8) || (i==9 && j>=6 && j<=13) )
                pixels[i][j] = 1;
            else
                pixels[i][j] = 0;
        }
    }

    // Print the generated pixel art
    for(i=0; i<height; i++)
    {
        for(j=0; j<width; j++)
        {
            if(pixels[i][j] == 1)
                printf("* ");
            else
                printf("  ");
        }
        printf("\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[400]; // [rsp+20h] [rbp-60h]
  int v5; // [rsp+660h] [rbp+5E0h]
  int v6; // [rsp+664h] [rbp+5E4h]
  int j; // [rsp+668h] [rbp+5E8h]
  int i; // [rsp+66Ch] [rbp+5ECh]

  _main(argc, argv, envp);
  v6 = 20;
  v5 = 20;
  for ( i = 0; i < v5; ++i )
  {
    for ( j = 0; j < v6; ++j )
      v4[20 * i + j] = i == 1 && j > 5 && j <= 13
                    || i == 4 && j > 4 && j <= 14
                    || j == 4 && i > 5 && i <= 8
                    || j == 15 && i > 5 && i <= 8
                    || i == 9 && j > 5 && j <= 13;
  }
  for ( i = 0; i < v5; ++i )
  {
    for ( j = 0; j < v6; ++j )
    {
      if ( v4[20 * i + j] == 1 )
        printf("* ");
      else
        printf("  ");
    }
    printf("\n");
  }
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type int var_650[400];

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define SIZE 4

void shuffle(int arr[]);
void printBoard(int board[][SIZE], int revealed[]);

int main()
{
    int board[SIZE][SIZE] = {{0}};
    int revealed[SIZE * SIZE] = {0};
    int choices[2] = {0};
    int matches = 0;
    int moves = 0;

    // Set up board with pairs of numbers
    for (int i = 1; i <= SIZE * SIZE / 2; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            int row, col;
            do
            {
                row = rand() % SIZE;
                col = rand() % SIZE;
            } while (board[row][col] != 0);
            board[row][col] = i;
        }
    }

    shuffle(board[0]);

    printf("Welcome to the Memory Game!\n");
    printf("Find all matching pairs.\n\n");

    // Main game loop
    while (matches < SIZE * SIZE / 2)
    {
        printf("Moves: %d\n", moves);
        printBoard(board, revealed);

        printf("Enter two coordinates to reveal a box (e.g. 1 2): ");
        scanf("%d %d", &choices[0], &choices[1]);

        choices[0]--, choices[1]--;
        int idx = choices[0] * SIZE + choices[1];

        if (revealed[idx] == 1)
        {
            printf("That box is already revealed!\n\n");
            continue;
        }

        revealed[idx] = 1;
        printBoard(board, revealed);

        if (board[choices[0]][choices[1]] == 0)
        {
            printf("Oops, that's a bomb! Game over...\n");
            break;
        }

        if (matches % 2 == 1)
        {
            if (board[choices[0]][choices[1]] == board[choices[0]][choices[1] - 1])
            {
                printf("Match found!\n");
                matches++;
            }
            else
            {
                printf("Oops, try again.\n");
                revealed[idx] = 0;
                revealed[choices[0] * SIZE + choices[1] - 1] = 0;
            }
        }

        moves++;
    }

    printf("Congratulations, you found all the matches in %d moves!\n", moves);

    return 0;
}

void shuffle(int arr[])
{
    srand(time(NULL));
    for (int i = SIZE * SIZE - 1; i > 0; i--)
    {
        int j = rand() % (i + 1);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

void printBoard(int board[][SIZE], int revealed[])
{
    printf("\n  ");
    for (int i = 0; i < SIZE; i++)
        printf("%d ", i + 1);
    printf("\n");

    for (int i = 0; i < SIZE; i++)
    {
        printf("%d ", i + 1);
        for (int j = 0; j < SIZE; j++)
            printf("%c ", revealed[i * SIZE + j] ? (board[i][j] == 0 ? '*' : board[i][j] + '0') : '-');
        printf("\n");
    }
    printf("\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall shuffle(_QWORD); // weak
__int64 __fastcall printBoard(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-A8h] BYREF
  __int64 v5[8]; // [rsp+30h] [rbp-A0h] BYREF
  __int64 v6[8]; // [rsp+70h] [rbp-60h] BYREF
  int v7; // [rsp+B4h] [rbp-1Ch]
  int v8; // [rsp+B8h] [rbp-18h]
  int v9; // [rsp+BCh] [rbp-14h]
  int j; // [rsp+C0h] [rbp-10h]
  int i; // [rsp+C4h] [rbp-Ch]
  unsigned int v12; // [rsp+C8h] [rbp-8h]
  int v13; // [rsp+CCh] [rbp-4h]

  _main(argc, argv, envp);
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  v4 = 0i64;
  v13 = 0;
  v12 = 0;
  for ( i = 1; i <= 8; ++i )
  {
    for ( j = 0; j <= 1; ++j )
    {
      do
      {
        v8 = rand() % 4;
        v7 = rand() % 4;
      }
      while ( *((_DWORD *)&v6[2 * v8] + v7) );
      *((_DWORD *)&v6[2 * v8] + v7) = i;
    }
  }
  shuffle(v6);
  printf("Welcome to the Memory Game!\n");
  printf("Find all matching pairs.\n\n");
  while ( v13 <= 7 )
  {
    printf("Moves: %d\n", v12);
    printBoard(v6, v5);
    printf("Enter two coordinates to reveal a box (e.g. 1 2): ");
    scanf("%d %d", &v4, (char *)&v4 + 4);
    LODWORD(v4) = v4 - 1;
    --HIDWORD(v4);
    v9 = 4 * v4 + HIDWORD(v4);
    if ( *((_DWORD *)v5 + v9) == 1 )
    {
      printf("That box is already revealed!\n\n");
    }
    else
    {
      *((_DWORD *)v5 + v9) = 1;
      printBoard(v6, v5);
      if ( !*((_DWORD *)&v6[2 * (int)v4] + SHIDWORD(v4)) )
      {
        printf("Oops, that's a bomb! Game over...\n");
        break;
      }
      if ( v13 % 2 == 1 )
      {
        if ( *((_DWORD *)&v6[2 * (int)v4] + SHIDWORD(v4)) == *((_DWORD *)&v6[2 * (int)v4 - 1] + HIDWORD(v4) + 1) )
        {
          printf("Match found!\n");
          ++v13;
        }
        else
        {
          printf("Oops, try again.\n");
          *((_DWORD *)v5 + v9) = 0;
          *((_DWORD *)&v5[2 * (int)v4 - 1] + HIDWORD(v4) + 1) = 0;
        }
      }
      ++v12;
    }
  }
  printf("Congratulations, you found all the matches in %d moves!\n", v12);
  return 0;
}
// 140001952: using guessed type __int64 __fastcall shuffle(_QWORD);
// 1400019FA: using guessed type __int64 __fastcall printBoard(_QWORD, _QWORD);
// 140001C00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Poker Game ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DECK_SIZE 52
#define HAND_SIZE 5

// Structure for each card in the deck
typedef struct {
    char *face;
    char *suit;
} Card;

// Structure for a standard 52-card deck
typedef struct {
    Card cards[DECK_SIZE];
    int cards_left;
} Deck;

// Structure for a hand of cards
typedef struct {
    Card cards[HAND_SIZE];
} Hand;

// Function declarations
Deck new_deck();
void shuffle(Deck *deck);
Hand deal_hand(Deck *deck);
void print_hand(Hand *hand);
int evaluate_hand(Hand *hand);

// Main function
int main() {
    // Initialize random seed
    srand(time(NULL));

    // Create a new deck and shuffle it
    Deck deck = new_deck();
    shuffle(&deck);

    // Deal a hand and print it out
    Hand hand = deal_hand(&deck);
    printf("Your hand is:\n");
    print_hand(&hand);

    // Evaluate the hand and print the result
    int score = evaluate_hand(&hand);
    printf("Your score is %d\n", score);

    return 0;
}

// Returns a new deck of cards
Deck new_deck() {
    char *faces[] = {"Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King"};
    char *suits[] = {"Hearts", "Diamonds", "Clubs", "Spades"};

    Deck deck;
    deck.cards_left = DECK_SIZE;

    // Add each card to the deck
    int i, j;
    for (i = 0; i < 13; i++) {
        for (j = 0; j < 4; j++) {
            Card card;
            card.face = faces[i];
            card.suit = suits[j];
            deck.cards[i * 4 + j] = card;
        }
    }

    return deck;
}

// Shuffles the given deck of cards
void shuffle(Deck *deck) {
    int i;
    for (i = 0; i < DECK_SIZE; i++) {
        int j = rand() % DECK_SIZE;
        Card temp = deck->cards[i];
        deck->cards[i] = deck->cards[j];
        deck->cards[j] = temp;
    }
}

// Deals a hand of cards from the given deck
Hand deal_hand(Deck *deck) {
    Hand hand;

    // Take the first five cards from the deck
    int i;
    for (i = 0; i < HAND_SIZE; i++) {
        hand.cards[i] = deck->cards[deck->cards_left - 1];
        deck->cards_left--;
    }

    return hand;
}

// Prints out a hand of cards
void print_hand(Hand *hand) {
    int i;
    for (i = 0; i < HAND_SIZE; i++) {
        printf("%s of %s\n", hand->cards[i].face, hand->cards[i].suit);
    }
}

// Evaluates a hand of cards and returns a score
int evaluate_hand(Hand *hand) {
    // TODO: Implement hand evaluation logic
    // For now, just return a random score
    return rand() % 100;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall new_deck(_QWORD); // weak
__int64 __fastcall shuffle(_QWORD); // weak
__int64 __fastcall deal_hand(_QWORD, _QWORD); // weak
__int64 __fastcall print_hand(_QWORD); // weak
__int64 __fastcall evaluate_hand(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[80]; // [rsp+20h] [rbp-60h] BYREF
  char v6[844]; // [rsp+70h] [rbp-10h] BYREF
  unsigned int v7; // [rsp+3BCh] [rbp+33Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  new_deck(v6);
  shuffle(v6);
  deal_hand(v5, v6);
  printf("Your hand is:\n");
  print_hand(v5);
  v7 = evaluate_hand(v5);
  printf("Your score is %d\n", v7);
  return 0;
}
// 140001650: using guessed type __int64 __fastcall new_deck(_QWORD);
// 140001834: using guessed type __int64 __fastcall shuffle(_QWORD);
// 1400018FB: using guessed type __int64 __fastcall deal_hand(_QWORD, _QWORD);
// 1400019CF: using guessed type __int64 __fastcall print_hand(_QWORD);
// 140001A35: using guessed type __int64 __fastcall evaluate_hand(_QWORD);
// 140001B20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to print the array
void printArray(int arr[], int size) {
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

// Function to perform quicksort
void quicksort(int arr[], int low, int high) {
    int pivot, i, j, temp;
    if (low < high) {
        // select pivot
        pivot = low;
        i = low;
        j = high;
        while (i < j) {
            // find element greater than pivot
            while (arr[i] <= arr[pivot] && i <= high) {
                i++;
            }
            // find element less than or equal to pivot
            while (arr[j] > arr[pivot]) {
                j--;
            }
            // swap elements if i < j
            if (i < j) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        // swap pivot and j
        temp = arr[pivot];
        arr[pivot] = arr[j];
        arr[j] = temp;
        // recursively perform quicksort on left and right subarrays
        quicksort(arr, low, j-1);
        quicksort(arr, j+1, high);
    }
}

// Driver function
int main() {
    int arr[100];
    int i, n;
    // Get size of array from user
    printf("Enter number of elements in array: ");
    scanf("%d", &n);
    // Generate random array of given size
    srand(time(0));
    for (i = 0; i < n; i++) {
        arr[i] = rand() % 100;
    }
    // Display original array
    printf("Original array: ");
    printArray(arr, n);
    // Sort array using quicksort
    quicksort(arr, 0, n-1);
    // Display sorted array
    printf("Sorted array: ");
    printArray(arr, n);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall printArray(_QWORD, _QWORD); // weak
__int64 __fastcall quicksort(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001811) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  int v6[103]; // [rsp+30h] [rbp-50h] BYREF
  int i; // [rsp+1CCh] [rbp+14Ch]

  _main(argc, argv, envp);
  printf("Enter number of elements in array: ");
  scanf("%d", &v5);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i < (int)v5; ++i )
    v6[i] = rand() % 100;
  printf("Original array: ");
  printArray(v6, v5);
  quicksort(v6, 0i64, v5 - 1);
  printf("Sorted array: ");
  printArray(v6, v5);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall printArray(_QWORD, _QWORD);
// 140001662: using guessed type __int64 __fastcall quicksort(_QWORD, _QWORD, _QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001811: using guessed type int var_1A0[103];

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sentiment analysis tool ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define positive and negative keywords
char positiveWords[10][20] = {"amazing", "awesome", "great", "good", "fantastic", "excellent", "love", "like", "super", "happy"};
char negativeWords[10][20] = {"awful", "bad", "terrible", "poor", "sad", "hate", "dislike", "worst", "horrible", "disgusting"};

// Define function to count number of occurrences of a word in a string
int countWord(char *sentence, char *word) {
    int count = 0;
    char *ptr = sentence;
    while (ptr = strstr(ptr, word)) {
        count++;
        ptr++;
    }
    return count;
}

// Define function to calculate sentiment score of a string
int calculateSentimentScore(char *sentence) {
    int positiveScore = 0, negativeScore = 0;
    for (int i = 0; i < 10; i++) {
        positiveScore += countWord(sentence, positiveWords[i]);
        negativeScore += countWord(sentence, negativeWords[i]);
    }
    return positiveScore - negativeScore;
}

int main() {
    char sentence[100];
    printf("Enter a sentence: ");
    fgets(sentence, 100, stdin);
    sentence[strcspn(sentence, "\n")] = '\0'; // Remove newline character
    int score = calculateSentimentScore(sentence);
    if (score > 0) {
        printf("Sentiment score of \"%s\" is %d, which is positive.\n", sentence, score);
    } else if (score < 0) {
        printf("Sentiment score of \"%s\" is %d, which is negative.\n", sentence, score);
    } else {
        printf("Sentiment score of \"%s\" is %d, which is neutral.\n", sentence, score);
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall calculateSentimentScore(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001672) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[108]; // [rsp+20h] [rbp-70h] BYREF
  unsigned int v6; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter a sentence: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  v6 = calculateSentimentScore(Buffer);
  if ( (int)v6 <= 0 )
  {
    if ( (v6 & 0x80000000) == 0 )
      printf("Sentiment score of \"%s\" is %d, which is neutral.\n", Buffer, v6);
    else
      printf("Sentiment score of \"%s\" is %d, which is negative.\n", Buffer, v6);
  }
  else
  {
    printf("Sentiment score of \"%s\" is %d, which is positive.\n", Buffer, v6);
  }
  return 0;
}
// 1400015DF: using guessed type __int64 __fastcall calculateSentimentScore(_QWORD);
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001672: using guessed type char Buffer[108];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Graph Coloring Problem ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define NODES 10
// Define maximum number of colors
#define COLORS 4

void printSolution(int color[]);
int isSafe(int node, int graph[][NODES], int color[], int c);
int graphColoringUtil(int graph[][NODES], int m, int color[], int node);

int main()
{
    // Set random seed
    srand(time(0));
    // Define graph as a 2D array
    int graph[NODES][NODES];
    // Initialize graph with random values
    for (int i = 0; i < NODES; i++) {
        for (int j = 0; j < NODES; j++) {
            if (i == j) {
                graph[i][j] = 0;
            } else {
                graph[i][j] = graph[j][i] = rand() % 2;
            }
        }
    }
    // Print graph
    printf("Generated Graph:\n");
    for (int i = 0; i < NODES; i++) {
        for (int j = 0; j < NODES; j++) {
            printf("%d ", graph[i][j]);
        }
        printf("\n");
    }
    // Initialize color array
    int color[NODES];
    // Initialize colors to 0
    for (int i = 0; i < NODES; i++) {
        color[i] = 0;
    }
    // Graph coloring using backtrack
    if (graphColoringUtil(graph, COLORS, color, 0) == 0) {
        printf("Solution does not exist");
        return 0;
    }
    // Print solution
    printf("Solution Exists: ");
    printSolution(color);
    return 0;
}

/* A utility function to print solution */
void printSolution(int color[])
{
    printf("Assigned Colors:\n");
    for (int i = 0; i < NODES; i++) {
        printf("Node %d: Color %d\n", i, color[i]);
    }
}

/* A utility function to check if the current color assignment is safe for node v */
int isSafe(int node, int graph[][NODES], int color[], int c)
{
    for (int i = 0; i < NODES; i++) {
        if (graph[node][i] && c == color[i]) {
            return 0;
        }
    }
    return 1;
}

/* A recursive utility function to solve graph coloring problem */
int graphColoringUtil(int graph[][NODES], int m, int color[], int node)
{
    // If all nodes are assigned a color
    if (node == NODES) {
        return 1;
    }
    // Consider this node for all colors from 1 to m
    for (int i = 1; i <= m; i++) {
        // Check if assignment of color i to node v is valid
        if (isSafe(node, graph, color, i)) {
            color[node] = i;
            // Recur to assign colors to rest of the nodes
            if (graphColoringUtil(graph, m, color, node + 1) == 1) {
                return 1;
            }
            // If assigning color i doesn't lead to a solution then remove it
            color[node] = 0;
        }
    }
    // If no color can be assigned to this node then return 0
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall printSolution(_QWORD); // weak
__int64 __fastcall graphColoringUtil(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[12]; // [rsp+20h] [rbp-60h] BYREF
  int v6[103]; // [rsp+50h] [rbp-30h] BYREF
  int n; // [rsp+1ECh] [rbp+16Ch]
  int m; // [rsp+1F0h] [rbp+170h]
  int k; // [rsp+1F4h] [rbp+174h]
  int j; // [rsp+1F8h] [rbp+178h]
  int i; // [rsp+1FCh] [rbp+17Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
    {
      if ( i == j )
      {
        v6[10 * i + j] = 0;
      }
      else
      {
        v6[10 * j + i] = rand() % 2;
        v6[10 * i + j] = v6[10 * j + i];
      }
    }
  }
  printf("Generated Graph:\n");
  for ( k = 0; k <= 9; ++k )
  {
    for ( m = 0; m <= 9; ++m )
      printf("%d ", (unsigned int)v6[10 * k + m]);
    printf("\n");
  }
  for ( n = 0; n <= 9; ++n )
    v5[n] = 0;
  if ( (unsigned int)graphColoringUtil(v6, 4i64, v5, 0i64) )
  {
    printf("Solution Exists: ");
    printSolution(v5);
  }
  else
  {
    printf("Solution does not exist");
  }
  return 0;
}
// 1400017F7: using guessed type __int64 __fastcall printSolution(_QWORD);
// 1400018DB: using guessed type __int64 __fastcall graphColoringUtil(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type int var_1B0[103];
// 1400015B0: using guessed type int var_1E0[12];

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Rogue-like Game with Procedural Generation ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAP_SIZE 20

char map[MAP_SIZE][MAP_SIZE];
int playerX, playerY;

void generateMap();
void printMap();
void movePlayer(int x, int y);

int main()
{
    srand(time(NULL));
    generateMap();
    playerX = MAP_SIZE/2;
    playerY = MAP_SIZE/2;
    map[playerX][playerY] = '@';
    printMap();
    char input;
    while (1) {
        input = getchar();
        switch (input) {
            case 'w':
                movePlayer(-1, 0);
                break;
            case 's':
                movePlayer(1, 0);
                break;
            case 'a':
                movePlayer(0, -1);
                break;
            case 'd':
                movePlayer(0, 1);
                break;
            default:
                break;
        }
        system("clear");
        printMap();
    }
}

void generateMap()
{
    int i, j;
    for (i = 0; i < MAP_SIZE; i++) {
        for (j = 0; j < MAP_SIZE; j++) {
            if (rand()%10 == 0) {
                map[i][j] = '#';
            } else {
                map[i][j] = '.';
            }
        }
    }
}

void printMap()
{
    int i, j;
    for (i = 0; i < MAP_SIZE; i++) {
        printf("|");
        for (j = 0; j < MAP_SIZE; j++) {
            printf("%c|", map[i][j]);
        }
        printf("\n");
    }
}

void movePlayer(int x, int y)
{
    if (playerX + x >= 0 && playerX + x < MAP_SIZE) {
        if (map[playerX+x][playerY+y] != '#') {
            map[playerX][playerY] = '.';
            playerX += x;
            playerY += y;
            map[playerX][playerY] = '@';
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 generateMap(void); // weak
__int64 printMap(void); // weak
__int64 __fastcall movePlayer(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl system(const char *Command);
// void __cdecl srand(unsigned int Seed);
// int __cdecl getchar();

//-------------------------------------------------------------------------
// Data declarations

_BYTE map[400]; // weak
int playerX; // weak
int playerY; // weak


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  generateMap();
  playerX = 10;
  playerY = 10;
  map[210] = 64;
  printMap();
  while ( 1 )
  {
    v4 = (char)getchar();
    if ( v4 == 119 )
    {
      movePlayer(0xFFFFFFFFi64, 0i64);
    }
    else if ( v4 <= 119 )
    {
      if ( v4 == 115 )
      {
        movePlayer(1i64, 0i64);
      }
      else if ( v4 <= 115 )
      {
        if ( v4 == 97 )
        {
          movePlayer(0i64, 0xFFFFFFFFi64);
        }
        else if ( v4 == 100 )
        {
          movePlayer(0i64, 1i64);
        }
      }
    }
    system("clear");
    printMap();
  }
}
// 1400016A7: using guessed type __int64 generateMap(void);
// 140001778: using guessed type __int64 printMap(void);
// 14000180B: using guessed type __int64 __fastcall movePlayer(_QWORD, _QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type _BYTE map[400];
// 14000F1D0: using guessed type int playerX;
// 14000F1D4: using guessed type int playerY;

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: recursive
#include <stdio.h>
#include <string.h>

int min(int a, int b, int c) {
    if(a < b && a < c) {
        return a;
    }
    else if(b < a && b < c) {
        return b;
    }
    else {
        return c;
    }
}

int recursiveLevenshteinDistance(char* str1, char* str2, int m, int n) {
    if(m == 0) {
        return n;
    }
    else if(n == 0) {
        return m;
    }
    else if(str1[m-1] == str2[n-1]) {
        return recursiveLevenshteinDistance(str1, str2, m-1, n-1);
    }
    else {
        return 1 + min(recursiveLevenshteinDistance(str1, str2, m, n-1),      //Insert 
                        recursiveLevenshteinDistance(str1, str2, m-1, n),     //Remove
                        recursiveLevenshteinDistance(str1, str2, m-1, n-1));  //Replace
    }
}

int main() {
    char str1[100], str2[100];
    int m, n, result;
    
    printf("Enter the first string: ");
    scanf("%s", str1);
    printf("Enter the second string: ");
    scanf("%s", str2);
    
    m = strlen(str1);
    n = strlen(str2);
    
    result = recursiveLevenshteinDistance(str1, str2, m, n);
    printf("The Levenshtein Distance between %s and %s is %d\n", str1, str2, result);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall recursiveLevenshteinDistance(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (0000000140001720) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[112]; // [rsp+20h] [rbp-60h] BYREF
  char Str[100]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v6; // [rsp+F4h] [rbp+74h]
  unsigned int v7; // [rsp+F8h] [rbp+78h]
  unsigned int v8; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter the first string: ");
  scanf("%s", Str);
  printf("Enter the second string: ");
  scanf("%s", v4);
  v8 = strlen(Str);
  v7 = strlen(v4);
  v6 = recursiveLevenshteinDistance(Str, v4, v8, v7);
  printf("The Levenshtein Distance between %s and %s is %d\n", Str, v4, v6);
  return 0;
}
// 14000161F: using guessed type __int64 __fastcall recursiveLevenshteinDistance(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Educational ; Style: careful
#include <stdio.h>
#include <stdlib.h>

int main() {
    int num, reverse = 0, original;
    printf("Enter an integer: ");
    scanf("%d", &num);

    original = num;

    while (num != 0) {
        reverse = reverse * 10 + num % 10;
        num = num / 10;
    }

    printf("The reverse of %d is %d\n", original, reverse);

    if (original == reverse) {
        printf("%d is a palindrome number\n", original);
    } else {
        printf("%d is not a palindrome number\n", original);
    }

    // Find the sum of all even numbers between 1 and user input
    int sum = 0;
    printf("Enter a number: ");
    scanf("%d", &num);

    for (int i = 2; i <= num; i += 2) {
        sum += i;
    }

    printf("The sum of all even numbers between 1 and %d is %d\n", num, sum);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v5; // [rsp+30h] [rbp-10h]
  int i; // [rsp+34h] [rbp-Ch]
  unsigned int v7; // [rsp+38h] [rbp-8h]
  unsigned int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 0;
  printf("Enter an integer: ");
  scanf("%d", &v4);
  v5 = v4;
  while ( v4 )
  {
    v8 = 10 * v8 + v4 % 10;
    v4 /= 10;
  }
  printf("The reverse of %d is %d\n", v5, v8);
  if ( v5 == v8 )
    printf("%d is a palindrome number\n", v5);
  else
    printf("%d is not a palindrome number\n", v5);
  v7 = 0;
  printf("Enter a number: ");
  scanf("%d", &v4);
  for ( i = 2; i <= v4; i += 2 )
    v7 += i;
  printf("The sum of all even numbers between 1 and %d is %d\n", (unsigned int)v4, v7);
  return 0;
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Modern Encryption ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

// Function to generate random key
char* generate_key(int length) {
    char* key = malloc(length * sizeof(char));
    int i;
    for (i = 0; i < length; i++) {
        // Generate random ASCII characters between 32 and 126
        key[i] = (char)((rand() % (126 - 32 + 1)) + 32);
    }
    return key;
}

// Function to perform encryption
char* encrypt(char* message, char* key) {
    int message_length = strlen(message);
    char* encrypted_message = malloc(message_length * sizeof(char));
    int i;
    for (i = 0; i < message_length; i++) {
        // XOR operation between message character and corresponding key character
        encrypted_message[i] = message[i] ^ key[i % strlen(key)];
    }
    return encrypted_message;
}

int main() {
    printf("Welcome to Modern Encryption Program!\n\n");

    // Seed the random number generator
    srand((unsigned int)time(NULL));

    // Get message and key from user
    char message[100];
    printf("Enter message to be encrypted: ");
    scanf("%99[^\n]", message);
    getchar();

    int key_length;
    printf("Enter length of key: ");
    scanf("%d", &key_length);
    getchar();

    // Generate random key
    char* key = generate_key(key_length);
    printf("Generated key: %s\n", key);

    // Encrypt message using key
    char* encrypted_message = encrypt(message, key);
    printf("Encrypted Message: %s\n", encrypted_message);

    // Free memory
    free(key);
    free(encrypted_message);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall generate_key(_QWORD); // weak
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl getchar();
// void __cdecl free(void *Block);


//----- (000000014000171B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-84h] BYREF
  char v6[112]; // [rsp+30h] [rbp-80h] BYREF
  void *v7; // [rsp+A0h] [rbp-10h]
  void *Block; // [rsp+A8h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to Modern Encryption Program!\n\n");
  v3 = time(0i64);
  srand(v3);
  printf("Enter message to be encrypted: ");
  scanf("%99[^\n]", v6);
  getchar();
  printf("Enter length of key: ");
  scanf("%d", &v5);
  getchar();
  Block = (void *)generate_key(v5);
  printf("Generated key: %s\n", (const char *)Block);
  v7 = (void *)encrypt(v6, Block);
  printf("Encrypted Message: %s\n", (const char *)v7);
  free(Block);
  free(v7);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall generate_key(_QWORD);
// 140001678: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Graph representation ; Style: brave
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 20

typedef struct Graph {
    int num_vertices;
    int num_edges;
    int adjacency_matrix[MAX_VERTICES][MAX_VERTICES];
} Graph;

// creates a new graph and sets all edges to zero
Graph* create_graph(int num_vertices) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->num_vertices = num_vertices;
    graph->num_edges = 0;
    
    int i, j;
    for (i = 0; i < num_vertices; i++) {
        for (j = 0; j < num_vertices; j++) {
            graph->adjacency_matrix[i][j] = 0;
        }
    }
    
    return graph;
}

// adds an edge to the graph
void add_edge(Graph* graph, int vertex1, int vertex2) {
    if (vertex1 >= 0 && vertex1 < graph->num_vertices && vertex2 >= 0 && vertex2 < graph->num_vertices) {
        graph->adjacency_matrix[vertex1][vertex2] = 1;
        graph->adjacency_matrix[vertex2][vertex1] = 1;
        graph->num_edges++;
    }
}

// prints the graph
void print_graph(Graph* graph) {
    int i, j;
    printf("    ");
    for (i = 0; i < graph->num_vertices; i++) {
        printf("%d ", i);
    }
    printf("\n");
    for (i = 0; i < graph->num_vertices; i++) {
        printf("%d: ", i);
        for (j = 0; j < graph->num_vertices; j++) {
            printf("%d ", graph->adjacency_matrix[i][j]);
        }
        printf("\n");
    }
}

int main() {
    Graph* graph = create_graph(5);
    add_edge(graph, 0, 1);
    add_edge(graph, 0, 2);
    add_edge(graph, 1, 2);
    add_edge(graph, 1, 4);
    add_edge(graph, 2, 3);
    add_edge(graph, 3, 4);
    print_graph(graph);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall create_graph(_QWORD); // weak
__int64 __fastcall add_edge(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall print_graph(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001799) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 graph; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  graph = create_graph(5i64);
  add_edge(graph, 0i64, 1i64);
  add_edge(graph, 0i64, 2i64);
  add_edge(graph, 1i64, 2i64);
  add_edge(graph, 1i64, 4i64);
  add_edge(graph, 2i64, 3i64);
  add_edge(graph, 3i64, 4i64);
  print_graph(graph);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall create_graph(_QWORD);
// 14000161B: using guessed type __int64 __fastcall add_edge(_QWORD, _QWORD, _QWORD);
// 1400016B2: using guessed type __int64 __fastcall print_graph(_QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Expense Tracker ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_TRANSACTIONS 100

// structure to hold transaction information
typedef struct {
  char type;
  float amount;
  char description[100];
} Transaction;

// function to display main menu
void displayMainMenu() {
  printf("\n#####      C EXPENSE TRACKER      #####\n");
  printf("\n1. Record a new transaction");
  printf("\n2. View all transactions");
  printf("\n3. View summary of transactions");
  printf("\n4. Exit");
  printf("\n\nEnter your choice: ");
}

// function to record a new transaction
void recordTransaction(Transaction transactions[], int *numTransactions) {
  
  Transaction newTransaction;

  //get transaction info from user
  printf("\nEnter transaction type (E for expense or I for income): ");
  scanf(" %c",&newTransaction.type);
  printf("Enter transaction amount: ");
  scanf("%f", &newTransaction.amount);
  printf("Enter transaction description (max 100 characters): ");
  getchar();
  fgets(newTransaction.description, 100, stdin);

  //add transaction to array
  transactions[*numTransactions] = newTransaction;
  *numTransactions += 1;

  printf("\nTransaction recorded successfully!\n");
}

// function to view all transactions
void viewTransactions(Transaction transactions[], int numTransactions) {
  printf("\n#####      ALL TRANSACTIONS      #####\n\n");

  for (int i=0; i<numTransactions; i++) {
    printf("%d. ", i+1);
    printf("%c ", transactions[i].type);
    printf("%.2f ", transactions[i].amount);
    printf("%s ", transactions[i].description);
  }
  if (numTransactions == 0)
    printf("\nNo transactions to display.");
}

// function to view summary of transactions
void viewTransactionSummary(Transaction transactions[], int numTransactions) {
  float income = 0.0, expense = 0.0;
  for (int i=0; i<numTransactions; i++) {
    if (transactions[i].type == 'I')
      income += transactions[i].amount;
    else
      expense += transactions[i].amount;
  }
  printf("\n#####      TRANSACTION SUMMARY      #####\n\n");
  printf("Total income: Rs. %.2f \n", income);
  printf("Total expense: Rs. %.2f \n", expense);
  printf("Net balance: Rs. %.2f \n", income - expense);
}

int main() {

  Transaction transactions[MAX_TRANSACTIONS];
  int numTransactions = 0;
  int choice;

  do {
    displayMainMenu();
    scanf("%d", &choice);

    switch(choice) {
      case 1:
        recordTransaction(transactions, &numTransactions);
        break;
      case 2:
        viewTransactions(transactions, numTransactions);
        break;
      case 3:
        viewTransactionSummary(transactions, numTransactions);
        break;
      case 4:
        printf("\n#####      END OF PROGRAM      #####\n");
        break;
      default:
        printf("\nInvalid choice. Try again.\n");
        break;
    }
  } while (choice != 4);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 displayMainMenu(void); // weak
__int64 __fastcall recordTransaction(_QWORD, _QWORD); // weak
__int64 __fastcall viewTransactions(_QWORD, _QWORD); // weak
__int64 __fastcall viewTransactionSummary(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A71) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[10800]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  do
  {
    displayMainMenu();
    scanf("%d", &v4);
    if ( v4 == 4 )
    {
      printf("\n#####      END OF PROGRAM      #####\n");
    }
    else
    {
      if ( v4 <= 4 )
      {
        switch ( v4 )
        {
          case 3:
            viewTransactionSummary(v6, v5);
            continue;
          case 1:
            recordTransaction(v6, &v5);
            continue;
          case 2:
            viewTransactions(v6, v5);
            continue;
        }
      }
      printf("\nInvalid choice. Try again.\n");
    }
  }
  while ( v4 != 4 );
  return 0;
}
// 140001AC3: conditional instruction was optimized away because %var_2A38.4<3
// 1400015E2: using guessed type __int64 displayMainMenu(void);
// 14000164B: using guessed type __int64 __fastcall recordTransaction(_QWORD, _QWORD);
// 1400017B0: using guessed type __int64 __fastcall viewTransactions(_QWORD, _QWORD);
// 1400018EE: using guessed type __int64 __fastcall viewTransactionSummary(_QWORD, _QWORD);
// 140001BF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Intrusion detection system ; Style: realistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_LOG_LENGTH 1000
#define MAX_IP_LENGTH 16
#define THRESHOLD 5

typedef struct {
    char ip[MAX_IP_LENGTH];
    time_t timestamp;
    int count;
} LogEntry;

int main() {
    char input[MAX_LOG_LENGTH];
    LogEntry logs[100];
    int num_logs = 0;
    
    while (fgets(input, MAX_LOG_LENGTH, stdin) != NULL) {
        char* ip = strtok(input, " ");
        time_t current_time = time(NULL);
        int i;
        int found_matching_log_entry = 0;
        
        for (i = 0; i < num_logs; i++) {
            if (strcmp(logs[i].ip, ip) == 0) {
                if (current_time - logs[i].timestamp < 60) {
                    logs[i].count++;
                    found_matching_log_entry = 1;
                    break;
                }
                else {
                    logs[i].count = 1;
                    logs[i].timestamp = current_time;
                    found_matching_log_entry = 1;
                    break;
                }
            }
        }
        
        if (!found_matching_log_entry) {
            LogEntry new_log_entry;
            strcpy(new_log_entry.ip, ip);
            new_log_entry.timestamp = current_time;
            new_log_entry.count = 1;
            logs[num_logs] = new_log_entry;
            num_logs++;
        }
        
        for (i = 0; i < num_logs; i++) {
            if (logs[i].count >= THRESHOLD) {
                printf("Intrusion detected from %s\n", logs[i].ip);
                break;
            }
        }
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _QWORD *v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // rdx
  FILE *v6; // rax
  char Destination[8]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v9; // [rsp+28h] [rbp-58h]
  time_t v10; // [rsp+30h] [rbp-50h]
  __int64 v11; // [rsp+38h] [rbp-48h]
  char v12[64]; // [rsp+40h] [rbp-40h] BYREF
  _BYTE v13[3136]; // [rsp+80h] [rbp+0h] BYREF
  char String[1008]; // [rsp+CC0h] [rbp+C40h] BYREF
  time_t v15; // [rsp+10B0h] [rbp+1030h]
  char *Str2; // [rsp+10B8h] [rbp+1038h]
  int v17; // [rsp+10C4h] [rbp+1044h]
  int i; // [rsp+10C8h] [rbp+1048h]
  int v19; // [rsp+10CCh] [rbp+104Ch]

  _main(argc, argv, envp);
  v19 = 0;
LABEL_17:
  while ( 1 )
  {
    v6 = __acrt_iob_func(0);
    if ( !fgets(String, 1000, v6) )
      return 0;
    Str2 = strtok(String, " ");
    v15 = time(0i64);
    v17 = 0;
    for ( i = 0; i < v19; ++i )
    {
      if ( !strcmp(&v12[32 * i], Str2) )
      {
        if ( v15 - *(_QWORD *)&v13[32 * i - 48] > 59 )
        {
          *(_DWORD *)&v13[32 * i - 40] = 1;
          *(_QWORD *)&v13[32 * i - 48] = v15;
        }
        else
        {
          ++*(_DWORD *)&v13[32 * i - 40];
        }
        v17 = 1;
        break;
      }
    }
    if ( !v17 )
    {
      strcpy(Destination, Str2);
      v10 = v15;
      LODWORD(v11) = 1;
      v3 = &v13[32 * v19 - 64];
      v4 = v9;
      *v3 = *(_QWORD *)Destination;
      v3[1] = v4;
      v5 = v11;
      v3[2] = v10;
      v3[3] = v5;
      ++v19;
    }
    for ( i = 0; i < v19; ++i )
    {
      if ( *(int *)&v13[32 * i - 40] > 4 )
      {
        printf("Intrusion detected from %s\n", &v12[32 * i]);
        goto LABEL_17;
      }
    }
  }
}
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type char var_1090[64];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bingo Simulator ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 5
#define COLS 5

// Function prototypes
void createBoard(int board[][COLS]);
void displayBoard(int board[][COLS]);
int drawNumber(int drawnNumbers[], int size, int max);
void markNumber(int board[][COLS], int num);
int checkWin(int board[][COLS]);

// Main function
int main()
{
    int board[ROWS][COLS];
    int drawnNumbers[75];
    int numDrawn = 0;
    int num;

    // Set random seed
    srand(time(NULL));

    // Generate the board
    createBoard(board);

    // Display the board
    printf("\nWelcome to Bingo!\n");
    displayBoard(board);

    // Play Bingo
    while (1)
    {
        // Draw a number
        num = drawNumber(drawnNumbers, numDrawn, 75);
        drawnNumbers[numDrawn++] = num;

        // Display the drawn number
        printf("\nNumber drawn: %d\n", num);

        // Mark the number on the board
        markNumber(board, num);
        displayBoard(board);

        // Check for win
        if (checkWin(board))
        {
            printf("\nBingo! You win!\n");
            break;
        }

        // Sleep for a second before drawing the next number
        printf("Next number in 1 second...\n");
        sleep(1);
    }

    return 0;
}

// Function definitions
void createBoard(int board[][COLS])
{
    int i, j;
    int nums[75];

    // Initialize the board with zeros
    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            board[i][j] = 0;
        }
    }

    // Generate an array of the numbers to pick from
    for (i = 0; i < 75; i++)
    {
        nums[i] = i + 1;
    }

    // Shuffle the array
    for (i = 74; i > 0; i--)
    {
        int j = rand() % (i + 1);
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    // Fill in the board with the numbers
    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            if (i == ROWS / 2 && j == COLS / 2)
            {
                board[i][j] = -1;
            }
            else
            {
                board[i][j] = nums[i * COLS + j];
            }
        }
    }
}

void displayBoard(int board[][COLS])
{
    int i, j;

    printf("\n   B   I   N   G   O\n");

    for (i = 0; i < ROWS; i++)
    {
        printf(" +---+---+---+---+---+\n");
        for (j = 0; j < COLS; j++)
        {
            if (board[i][j] == -1)
            {
                printf(" | X ");
            }
            else if (board[i][j] < 10)
            {
                printf(" | %d ", board[i][j]);
            }
            else
            {
                printf(" | %d", board[i][j]);
            }
        }
        printf(" |\n");
    }

    printf(" +---+---+---+---+---+\n");
}

int drawNumber(int drawnNumbers[], int size, int max)
{
    int num;

    // Keep drawing numbers until we get a number that hasn't been drawn yet
    do
    {
        num = rand() % max + 1;
    } while (findNumber(drawnNumbers, size, num) != -1);

    return num;
}

int findNumber(int arr[], int size, int num)
{
    int i;
    for (i = 0; i < size; i++)
    {
        if (arr[i] == num)
        {
            return i;
        }
    }
    return -1;
}

void markNumber(int board[][COLS], int num)
{
    int i, j;
    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLS; j++)
        {
            if (board[i][j] == num)
            {
                board[i][j] = -1;
                return;
            }
        }
    }
}

int checkWin(int board[][COLS])
{
    int i, j;
    int row, col, diag, antidiag;

    // Check for a horizontal win
    for (i = 0; i < ROWS; i++)
    {
        row = 1;
        for (j = 0; j < COLS; j++)
        {
            if (board[i][j] != -1)
            {
                row = 0;
                break;
            }
        }
        if (row)
        {
            return 1;
        }
    }

    // Check for a vertical win
    for (j = 0; j < COLS; j++)
    {
        col = 1;
        for (i = 0; i < ROWS; i++)
        {
            if (board[i][j] != -1)
            {
                col = 0;
                break;
            }
        }
        if (col)
        {
            return 1;
        }
    }

    // Check for a diagonal win
    diag = 1;
    for (i = 0; i < ROWS; i++)
    {
        if (board[i][i] != -1)
        {
            diag = 0;
            break;
        }
    }
    if (diag)
    {
        return 1;
    }

    // Check for an antidiagonal win
    antidiag = 1;
    for (i = 0; i < ROWS; i++)
    {
        if (board[i][COLS - i - 1] != -1)
        {
            antidiag = 0;
            break;
        }
    }
    if (antidiag)
    {
        return 1;
    }

    // No win yet
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall createBoard(_QWORD); // weak
__int64 __fastcall displayBoard(_QWORD); // weak
__int64 __fastcall drawNumber(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall markNumber(_QWORD, _QWORD); // weak
__int64 __fastcall checkWin(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax
  int v6[76]; // [rsp+20h] [rbp-60h] BYREF
  char v7[104]; // [rsp+150h] [rbp+D0h] BYREF
  unsigned int v8; // [rsp+1B8h] [rbp+138h]
  unsigned int v9; // [rsp+1BCh] [rbp+13Ch]

  _main(argc, argv, envp);
  v9 = 0;
  v3 = time(0i64);
  srand(v3);
  createBoard(v7);
  printf("\nWelcome to Bingo!\n");
  displayBoard(v7);
  while ( 1 )
  {
    v8 = drawNumber(v6, v9, 75i64);
    v4 = v9++;
    v6[v4] = v8;
    printf("\nNumber drawn: %d\n", v8);
    markNumber(v7, v8);
    displayBoard(v7);
    if ( (unsigned int)checkWin(v7) )
      break;
    printf("Next number in 1 second...\n");
    sleep(1i64);
  }
  printf("\nBingo! You win!\n");
  return 0;
}
// 1400016D1: using guessed type __int64 __fastcall createBoard(_QWORD);
// 1400018D9: using guessed type __int64 __fastcall displayBoard(_QWORD);
// 140001A36: using guessed type __int64 __fastcall drawNumber(_QWORD, _QWORD, _QWORD);
// 140001ACF: using guessed type __int64 __fastcall markNumber(_QWORD, _QWORD);
// 140001B61: using guessed type __int64 __fastcall checkWin(_QWORD);
// 140001DD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002E30: using guessed type __int64 __fastcall sleep(_QWORD);
// 1400015B0: using guessed type int var_1A0[76];

// nfuncs=148 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Intrusion detection system ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Implementing circular queue for storing logs
#define MAX_SIZE 10
char queue[MAX_SIZE][100];
int front = -1, rear = -1;

void printQueue() {
    if(front == -1 && rear == -1) {
        printf("Queue is Empty\n");
        return;
    }
    printf("Logs: ");
    for(int i=front; i != rear; i = (i+1) % MAX_SIZE)
        printf("%s ",queue[i]);
    printf("%s\n", queue[rear]);
}

// Function to detect intrusion
bool detectIntrusion(char* log) {
    int count = 0;
    for(int i=0; i<strlen(log); ++i)
        if(log[i] == ':')
            count++;
    return count > 4;
}

int main() {
    printf("Welcome to Intrusion Detection System\n");
    char log[1000];
    while(true) {
        printf("Enter log: ");
        fgets(log, sizeof(log), stdin);
        log[strcspn(log, "\n")] = 0;    // Removing trailing newline
        if(!detectIntrusion(log)) {
            if(front == -1 && rear == -1)
                front = rear = 0;
            else {
                rear = (rear+1)%MAX_SIZE;
                if(front == rear) {
                    front = (front+1)%MAX_SIZE;
                }
            }
            strcpy(queue[rear], log);
            printQueue();
        }
        else {
            printf("Intrusion detected!\n");
            printf("Logs: ");
            for(int i=front; i != rear; i = (i+1) % MAX_SIZE)
                printf("%s ",queue[i]);
            printf("%s\n", queue[rear]);
            front = -1, rear = -1;
            exit(0);
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 printQueue(void); // weak
__int64 __fastcall detectIntrusion(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

int front = -1; // weak
int rear = -1; // weak
char queue[1024]; // weak


//----- (00000001400016F7) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v4; // edx
  char Buffer[1004]; // [rsp+20h] [rbp-60h] BYREF
  int i; // [rsp+40Ch] [rbp+38Ch]

  _main(argc, argv, envp);
  printf("Welcome to Intrusion Detection System\n");
  while ( 1 )
  {
    printf("Enter log: ");
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 1000, v3);
    Buffer[strcspn(Buffer, "\n")] = 0;
    if ( (unsigned __int8)detectIntrusion(Buffer) == 1 )
      break;
    if ( front == -1 && rear == -1 )
    {
      rear = 0;
      front = 0;
    }
    else
    {
      rear = (rear + 1) % 10;
      if ( front == rear )
        front = (front + 1) % 10;
    }
    strcpy(&queue[100 * rear], Buffer);
    printQueue();
  }
  printf("Intrusion detected!\n");
  printf("Logs: ");
  for ( i = front; i != rear; i = v4 - 10 * i )
  {
    printf("%s ", &queue[100 * i]);
    v4 = i + 1;
    i = (i + 1) / 10;
  }
  printf("%s\n", &queue[100 * rear]);
  front = -1;
  rear = -1;
  exit(0);
}
// 140001591: using guessed type __int64 printQueue(void);
// 14000169A: using guessed type __int64 __fastcall detectIntrusion(_QWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A010: using guessed type int front;
// 14000A014: using guessed type int rear;
// 1400016F7: using guessed type char Buffer[1004];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cryptographic hash fucntion ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define ROTR(n, x) ((x >> n) | (x << (32 - n)))

uint32_t ch(uint32_t x, uint32_t y, uint32_t z) {
    return (x & y) ^ (~x & z);
}

uint32_t maj(uint32_t x, uint32_t y, uint32_t z) {
    return (x & y) ^ (x & z) ^ (y & z);
}

uint32_t sigma0(uint32_t x) {
    return ROTR(2, x) ^ ROTR(13, x) ^ ROTR(22, x);
}

uint32_t sigma1(uint32_t x) {
    return ROTR(6, x) ^ ROTR(11, x) ^ ROTR(25, x);
}

uint32_t delta0(uint32_t x) {
    return ROTR(7, x) ^ ROTR(18, x) ^ (x >> 3);
}

uint32_t delta1(uint32_t x) {
    return ROTR(17, x) ^ ROTR(19, x) ^ (x >> 10);
}

void sha256(const uint8_t *message, uint32_t len, uint8_t *digest) {
    uint32_t K[] = {
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
    };

    uint32_t H[] = {
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19,
    };

    uint32_t W[64] = {0};
    uint32_t a, b, c, d, e, f, g, h, T1, T2;

    uint8_t *ptr;
    uint32_t i, j;

    uint32_t len_bits = len * 8;
    uint32_t num_blocks = (((len + 8) + 64) / 512) + 1;

    uint8_t *msg = (uint8_t *) calloc(num_blocks * 512 / 8, 1);
    memcpy(msg, message, len);
    msg[len] = 0x80;

    ptr = msg + (num_blocks * 512 / 8 - 8);
    ptr[0] = (len_bits >> 24) & 0xFF;
    ptr[1] = (len_bits >> 16) & 0xFF;
    ptr[2] = (len_bits >> 8) & 0xFF;
    ptr[3] = len_bits & 0xFF;

    for (i = 0; i < num_blocks; i++) {
        ptr = msg + (i * 512 / 8);
        for (j = 0; j < 16; j++) {
            W[j] = (ptr[j * 4] << 24) |
                   (ptr[j * 4 + 1] << 16) |
                   (ptr[j * 4 + 2] << 8) |
                   (ptr[j * 4 + 3]);
        }
        for (j = 16; j < 64; j++) {
            W[j] = delta1(W[j - 2]) + W[j - 7] +
                   delta0(W[j - 15]) + W[j - 16];
        }

        a = H[0];
        b = H[1];
        c = H[2];
        d = H[3];
        e = H[4];
        f = H[5];
        g = H[6];
        h = H[7];

        for (j = 0; j < 64; j++) {
            T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j];
            T2 = sigma0(a) + maj(a, b, c);
            h = g;
            g = f;
            f = e;
            e = d + T1;
            d = c;
            c = b;
            b = a;
            a = T1 + T2;
        }

        H[0] += a;
        H[1] += b;
        H[2] += c;
        H[3] += d;
        H[4] += e;
        H[5] += f;
        H[6] += g;
        H[7] += h;
    }

    ptr = digest;
    for (i = 0; i < 8; i++) {
        *ptr++ = (H[i] >> 24) & 0xFF;
        *ptr++ = (H[i] >> 16) & 0xFF;
        *ptr++ = (H[i] >> 8) & 0xFF;
        *ptr++ = H[i] & 0xFF;
    }

    free(msg);
}

int main() {
    char input[100];
    printf("Enter a string to hash: ");
    fgets(input, 100, stdin);

    uint8_t digest[32];
    sha256(input, strlen(input), digest);

    printf("Hash result: ");
    for (int i = 0; i < 32; i++) {
        printf("%02x", digest[i]);
    }
    printf("\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall sha256(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001ECE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v4; // eax
  char v6[32]; // [rsp+20h] [rbp-90h] BYREF
  char Buffer[108]; // [rsp+40h] [rbp-70h] BYREF
  int i; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter a string to hash: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  v4 = strlen(Buffer);
  sha256(Buffer, v4, v6);
  printf("Hash result: ");
  for ( i = 0; i <= 31; ++i )
    printf("%02x", (unsigned __int8)v6[i]);
  printf("\n");
  return 0;
}
// 14000165A: using guessed type __int64 __fastcall sha256(_QWORD, _QWORD, _QWORD);
// 140002050: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001ECE: using guessed type char var_90[32];

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: grateful
#include <stdio.h>

// function for binary search
int binarySearch(int arr[], int low, int high, int key) {
    if (high >= low) {
        int mid = low + (high - low) / 2;

        // if the key is present at the middle itself
        if (arr[mid] == key)
            return mid;

        // if key is smaller than mid, then it can only be present in left subarray
        if (arr[mid] > key)
            return binarySearch(arr, low, mid - 1, key);

        // else the key lies in right subarray
        return binarySearch(arr, mid + 1, high, key);
    }

    // key not found
    return -1;
}

int main() {
    int arr[] = {2, 3, 4, 10, 40};
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 10;
    int result = binarySearch(arr, 0, n - 1, key);
    if (result == -1)
        printf("Element is not present in array");
    else
        printf("Element is present at index %d", result);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001651) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[5]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v5; // [rsp+34h] [rbp-Ch]
  int v6; // [rsp+38h] [rbp-8h]
  int v7; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 2;
  v4[1] = 3;
  v4[2] = 4;
  v4[3] = 10;
  v4[4] = 40;
  v7 = 5;
  v6 = 10;
  v5 = ((__int64 (__fastcall *)(int *, _QWORD, __int64, __int64))binarySearch)(v4, 0i64, 4i64, 10i64);
  if ( v5 == -1 )
    printf("Element is not present in array");
  else
    printf("Element is present at index %d", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bitwise operations ; Style: unmistakable
#include <stdio.h>

// Function to print binary of a number
void printBinary(unsigned int num)
{
    if (num > 1)
        printBinary(num / 2);

    printf("%d", num % 2);
}

int main()
{
    unsigned int a = 60; // 60 in binary: 0011 1100
    unsigned int b = 13; // 13 in binary: 0000 1101
    unsigned int c, d;

    // Bitwise AND of a and b
    c = a & b; // 12 in binary: 0000 1100
    printf("a & b = %d (binary: ", c);
    printBinary(c);
    printf(")\n");

    // Bitwise OR of a and b
    c = a | b; // 61 in binary: 0011 1101
    printf("a | b = %d (binary: ", c);
    printBinary(c);
    printf(")\n");

    // Bitwise XOR of a and b
    c = a ^ b; // 49 in binary: 0011 0001
    printf("a ^ b = %d (binary: ", c);
    printBinary(c);
    printf(")\n");

    // Bitwise NOT of a
    c = ~a; // -61 in binary (assuming 2's complement): 1100 0011
    printf("~a = %d (binary: ", c);
    printBinary(c);
    printf(")\n");

    // Bitwise left shift of a
    d = a << 2; // 240 in binary: 1111 0000
    printf("a << 2 = %d (binary: ", d);
    printBinary(d);
    printf(")\n");

    // Bitwise right shift of a
    d = a >> 2; // 15 in binary: 0000 1111
    printf("a >> 2 = %d (binary: ", d);
    printBinary(d);
    printf(")\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printBinary(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015CC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("a & b = %d (binary: ", 12i64);
  printBinary(12i64);
  printf(")\n");
  printf("a | b = %d (binary: ", 61i64);
  printBinary(61i64);
  printf(")\n");
  printf("a ^ b = %d (binary: ", 49i64);
  printBinary(49i64);
  printf(")\n");
  printf("~a = %d (binary: ", 4294967235i64);
  printBinary(4294967235i64);
  printf(")\n");
  printf("a << 2 = %d (binary: ", 240i64);
  printBinary(240i64);
  printf(")\n");
  printf("a >> 2 = %d (binary: ", 15i64);
  printBinary(15i64);
  printf(")\n");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printBinary(_QWORD);
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System administration ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define ADMIN "root"

int main(){
    char username[20];
    char password[20];
    int tries = 0;

    printf("Please login to the system.\n");

    while(tries < 3){
        printf("Username: ");
        scanf("%s", username);

        printf("Password: ");
        scanf("%s", password);

        if(strcmp(username, ADMIN) == 0 && strcmp(password, "pUzzl3m3Plz!") == 0){
            printf("Welcome, %s!\n", username);
            printf("You have unlocked the secret program.\n");

            // code to run the secret program goes here.
            printf("The secret program is running...\n");

            for(int i = 0; i < 10; i++){
                char command[20];
                sprintf(command, "echo 'Puzzle piece #%d'", i+1);
                system(command);
                sleep(1);
            }

            printf("Program complete. Exiting...\n");

            return 0;
        }

        printf("Invalid username or password. Please try again.\n");
        tries++;
    }

    printf("Too many attempts. Exiting...\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// int __cdecl system(const char *Command);
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[32]; // [rsp+20h] [rbp-60h] BYREF
  char v5[32]; // [rsp+40h] [rbp-40h] BYREF
  char Str1[24]; // [rsp+60h] [rbp-20h] BYREF
  int i; // [rsp+78h] [rbp-8h]
  int v8; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 0;
  printf("Please login to the system.\n");
  while ( 1 )
  {
    if ( v8 > 2 )
    {
      printf("Too many attempts. Exiting...\n");
      return 0;
    }
    printf("Username: ");
    scanf("%s", Str1);
    printf("Password: ");
    scanf("%s", v5);
    if ( !strcmp(Str1, "root") && !strcmp(v5, "pUzzl3m3Plz!") )
      break;
    printf("Invalid username or password. Please try again.\n");
    ++v8;
  }
  printf("Welcome, %s!\n", Str1);
  printf("You have unlocked the secret program.\n");
  printf("The secret program is running...\n");
  for ( i = 0; i <= 9; ++i )
  {
    sprintf(Buffer, "echo 'Puzzle piece #%d'", (unsigned int)(i + 1));
    system(Buffer);
    sleep(1i64);
  }
  printf("Program complete. Exiting...\n");
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400028B0: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Syntax parsing ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>

// Function to check if the character is a valid identifier character
bool valid_identifier(char c)
{
    return isalnum(c) || c == '_';
}

// Struct to represent a single token
typedef struct Token
{
    enum { IDENTIFIER, NUMBER, LPAREN, RPAREN, PLUS, MINUS, TIMES, DIVIDE, ASSIGN, END } type;
    char* value;
} Token;

// Function to create a new token
Token* new_token(int type, char* value)
{
    Token* token = (Token*) malloc(sizeof(Token));
    token->type = type;
    token->value = value;
    return token;
}

// Function to parse the next token in the input string
Token* next_token(char** input)
{
    char* value = (char*) malloc(sizeof(char));
    *value = '\0';
    while (**input && isspace(**input))
    {
        (*input)++;
    }
    if (**input && valid_identifier(**input))
    {
        while (**input && valid_identifier(**input))
        {
            value = (char*) realloc(value, (strlen(value) + 1) * sizeof(char));
            strncat(value, (*input)++, 1);
        }
        return new_token(IDENTIFIER, value);
    }
    if (**input && isdigit(**input))
    {
        while (**input && isdigit(**input))
        {
            value = (char*) realloc(value, (strlen(value) + 1) * sizeof(char));
            strncat(value, (*input)++, 1);
        }
        return new_token(NUMBER, value);
    }
    if (**input)
    {
        switch (**input)
        {
            case '(':
                (*input)++;
                return new_token(LPAREN, "(");
            case ')':
                (*input)++;
                return new_token(RPAREN, ")");
            case '+':
                (*input)++;
                return new_token(PLUS, "+");
            case '-':
                (*input)++;
                return new_token(MINUS, "-");
            case '*':
                (*input)++;
                return new_token(TIMES, "*");
            case '/':
                (*input)++;
                return new_token(DIVIDE, "/");
            case '=':
                (*input)++;
                return new_token(ASSIGN, "=");
        }
    }
    return new_token(END, "");
}

// Function to print a token
void print_token(Token* token)
{
    printf("[%d, %s]", token->type, token->value);
}

// Function to free a token
void free_token(Token* token)
{
    free(token->value);
    free(token);
}

// Recursive descent parser functions
void statement(char** input);
void expression(char** input);
void term(char** input);
void factor(char** input);
void identifier(char** input);
void number(char** input);

// Function to handle a syntax error
void syntax_error(char** input, char* message)
{
    printf("Syntax error: %s\n", message);
    exit(1);
}

// Function to parse a statement
void statement(char** input)
{
    identifier(input);
    Token* token = next_token(input);
    if (token->type != ASSIGN)
    {
        syntax_error(input, "Expected '=' after identifier in statement");
    }
    expression(input);
}

// Function to parse an expression
void expression(char** input)
{
    term(input);
    Token* token = next_token(input);
    while (token->type == PLUS || token->type == MINUS)
    {
        term(input);
        token = next_token(input);
    }
}

// Function to parse a term
void term(char** input)
{
    factor(input);
    Token* token = next_token(input);
    while (token->type == TIMES || token->type == DIVIDE)
    {
        factor(input);
        token = next_token(input);
    }
}

// Function to parse a factor
void factor(char** input)
{
    Token* token = next_token(input);
    if (token->type == LPAREN)
    {
        expression(input);
        token = next_token(input);
        if (token->type != RPAREN)
        {
            syntax_error(input, "Expected ')' after expression in factor");
        }
    }
    else if (token->type == IDENTIFIER)
    {
        // Do nothing
    }
    else if (token->type == NUMBER)
    {
        // Do nothing
    }
    else
    {
        syntax_error(input, "Unexpected token in factor");
    }
}

// Function to parse an identifier
void identifier(char** input)
{
    Token* token = next_token(input);
    if (token->type != IDENTIFIER)
    {
        syntax_error(input, "Expected identifier");
    }
}

// Function to parse a number
void number(char** input)
{
    Token* token = next_token(input);
    if (token->type != NUMBER)
    {
        syntax_error(input, "Expected number");
    }
}

// Main function
int main()
{
    char* input = "a = b + c * 2";
    printf("Input: %s\n", input);
    while (*input)
    {
        Token* token = next_token(&input);
        print_token(token);
        free_token(token);
    }
    printf("\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall next_token(_QWORD); // weak
__int64 __fastcall print_token(_QWORD); // weak
__int64 __fastcall free_token(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001BDE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v4; // [rsp+20h] [rbp-10h] BYREF
  __int64 v5; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v4 = "a = b + c * 2";
  printf("Input: %s\n", "a = b + c * 2");
  while ( *v4 )
  {
    v5 = next_token(&v4);
    print_token(v5);
    free_token(v5);
  }
  printf("\n");
  return 0;
}
// 140001608: using guessed type __int64 __fastcall next_token(_QWORD);
// 140001948: using guessed type __int64 __fastcall print_token(_QWORD);
// 14000197D: using guessed type __int64 __fastcall free_token(_QWORD);
// 140001D10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=153 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Phone Book ; Style: optimized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define INIT_CAP 10
#define CAP_INCREMENT 5

typedef struct {
    char name[50];
    char email[50];
    char phone[15];
} contact_t;

typedef struct {
    contact_t *contacts;
    int size;
    int capacity;
} phone_book_t;

phone_book_t* create_phone_book() {
    phone_book_t *book = (phone_book_t*) malloc(sizeof(phone_book_t));
    book->size = 0;
    book->capacity = INIT_CAP;
    book->contacts = (contact_t*) malloc(INIT_CAP * sizeof(contact_t));
    return book;
}

void destroy_phone_book(phone_book_t *book) {
    free(book->contacts);
    free(book);
}

void add_contact(phone_book_t *book, const char *name, const char *email, const char *phone) {
    if(book->size == book->capacity) {
        book->capacity += CAP_INCREMENT;
        book->contacts = (contact_t*) realloc(book->contacts, book->capacity * sizeof(contact_t));
    }
    contact_t *new_contact = &(book->contacts[book->size]);
    strcpy(new_contact->name, name);
    strcpy(new_contact->email, email);
    strcpy(new_contact->phone, phone);
    book->size++;
}

int find_contact_index(const phone_book_t *book, const char *name) {
    for(int i = 0; i < book->size; i++) {
        if(strcmp(book->contacts[i].name, name) == 0) {
            return i;
        }
    }
    return -1;
}

void remove_contact(phone_book_t *book, const char *name) {
    int index = find_contact_index(book, name);
    if(index != -1) {
        memmove(&(book->contacts[index]), &(book->contacts[index+1]), (book->size - index - 1) * sizeof(contact_t));
        book->size--;
    }
}

void print_phone_book(const phone_book_t *book) {
    printf("NAME\t\t\tEMAIL\t\t\tPHONE\n");
    printf("----------------------------------------------------\n");
    for(int i = 0; i < book->size; i++) {
        printf("%-20s\t%-20s\t%-15s\n", book->contacts[i].name, book->contacts[i].email, book->contacts[i].phone);
    }
}

int main() {
    phone_book_t *book = create_phone_book();

    add_contact(book, "John Smith", "john.smith@gmail.com", "555-1234");
    add_contact(book, "Jane Doe", "jane.doe@hotmail.com", "555-5678");
    add_contact(book, "Bob Johnson", "bob.johnson@yahoo.com", "555-2468");
    add_contact(book, "Mary Brown", "mary.brown@gmail.com", "555-3698");

    printf("Initial phone book:\n");
    print_phone_book(book);

    remove_contact(book, "Bob Johnson");

    printf("\nPhone book after removing Bob Johnson:\n");
    print_phone_book(book);

    destroy_phone_book(book);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 create_phone_book(void); // weak
__int64 __fastcall destroy_phone_book(_QWORD); // weak
__int64 __fastcall add_contact(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall remove_contact(_QWORD, _QWORD); // weak
__int64 __fastcall print_phone_book(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000185B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 phone_book; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  phone_book = create_phone_book();
  add_contact(phone_book, "John Smith", "john.smith@gmail.com", "555-1234");
  add_contact(phone_book, "Jane Doe", "jane.doe@hotmail.com", "555-5678");
  add_contact(phone_book, "Bob Johnson", "bob.johnson@yahoo.com", "555-2468");
  add_contact(phone_book, "Mary Brown", "mary.brown@gmail.com", "555-3698");
  printf("Initial phone book:\n");
  print_phone_book(phone_book);
  remove_contact(phone_book, "Bob Johnson");
  printf("\nPhone book after removing Bob Johnson:\n");
  print_phone_book(phone_book);
  destroy_phone_book(phone_book);
  return 0;
}
// 140001591: using guessed type __int64 create_phone_book(void);
// 1400015DB: using guessed type __int64 __fastcall destroy_phone_book(_QWORD);
// 140001606: using guessed type __int64 __fastcall add_contact(_QWORD, _QWORD, _QWORD, _QWORD);
// 14000172E: using guessed type __int64 __fastcall remove_contact(_QWORD, _QWORD);
// 1400017B7: using guessed type __int64 __fastcall print_phone_book(_QWORD);
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Modern Encryption ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define SHIFT 3   // Shift value for the Caesar Cipher

// Encryption function
void encrypt(char *plaintext, int shift) {
    int i;

    for (i = 0; i < strlen(plaintext); i++) {
        // Shift uppercase letters
        if (isupper(plaintext[i])) {
            plaintext[i] = ((plaintext[i] - 'A') + shift) % 26 + 'A';
        }
        // Shift lowercase letters
        else if (islower(plaintext[i])) {
            plaintext[i] = ((plaintext[i] - 'a') + shift) % 26 + 'a';
        }
    }
}

int main(void) {
    char plaintext[100];
    int shift;

    // Get plaintext and shift value from user
    printf("Enter plaintext: ");
    scanf("%[^\n]", plaintext);
    printf("Enter shift value (1-25): ");
    scanf("%d", &shift);

    // Validate shift value
    while (shift < 1 || shift > 25) {
        printf("Invalid shift value. Please enter a value between 1 and 25: ");
        scanf("%d", &shift);
    }

    // Encrypt plaintext using Caesar Cipher
    encrypt(plaintext, shift);

    // Print encrypted text
    printf("Encrypted text: %s\n", plaintext);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000170B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-74h] BYREF
  char v5[112]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter plaintext: ");
  scanf("%[^\n]", v5);
  printf("Enter shift value (1-25): ");
  scanf("%d", &v4);
  while ( v4 <= 0 || v4 > 25 )
  {
    printf("Invalid shift value. Please enter a value between 1 and 25: ");
    scanf("%d", &v4);
  }
  encrypt(v5, (unsigned int)v4);
  printf("Encrypted text: %s\n", v5);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: calm
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b){
    int temp = *a;
    *a = *b;
    *b = temp;
}
void bubble_sort(int arr[], int n){
    int i, j;
    for(i=0; i<n-1; i++){
        for(j=0; j<n-i-1; j++){
            if(arr[j]>arr[j+1]){
                swap(&arr[j], &arr[j+1]);
            }
        }
    }
}

void selection_sort(int arr[], int n){
    int i, j, min_index;
    for(i=0; i<n-1; i++){
        min_index=i;
        for(j=i+1; j<n; j++){
            if(arr[j]<arr[min_index]){
                min_index=j;
            }
        }
        if(min_index!=i){
            swap(&arr[i], &arr[min_index]);
        }
    }
}

void insertion_sort(int arr[], int n){
    int i, j, key;
    for(i=1; i<n; i++){
        key=arr[i];
        j=i-1;

        while(j>=0 && arr[j]>key){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1] = key;
    }
}

int main(){
    int n, choice, i;

    printf("Enter the size of the array: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter %d elements in the array\n", n);
    for (i = 0; i < n; ++i){
        scanf("%d", &arr[i]);
    }

    printf("Which sorting method do you want to use:\n");
    printf("1. Bubble Sort\n");
    printf("2. Selection Sort\n");
    printf("3. Insertion Sort\n");

    scanf("%d", &choice);

    switch(choice){
        case 1:
            bubble_sort(arr, n);
            printf("The array sorted using Bubble Sort is:\n");
            break;
        case 2:
            selection_sort(arr, n);
            printf("The array sorted using Selection Sort is:\n");
            break;
        case 3:
            insertion_sort(arr, n);
            printf("The array sorted using Insertion Sort is:\n");
            break;
        default:
            printf("Invalid Input\n");
            exit(0);
    }

    for(i=0; i<n; i++){
        printf("%d ", arr[i]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall bubble_sort(_QWORD, _QWORD); // weak
__int64 __fastcall selection_sort(_QWORD, _QWORD); // weak
__int64 __fastcall insertion_sort(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (000000014000185B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  int v5; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v6; // [rsp+24h] [rbp-1Ch] BYREF
  int *v7; // [rsp+28h] [rbp-18h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the size of the array: ");
  scanf("%d", &v6);
  v8 = (int)v6 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(4i64 * (int)v6 + 15) >> 4));
  v7 = &v5;
  printf("Enter %d elements in the array\n", v6);
  for ( i = 0; i < (int)v6; ++i )
    scanf("%d", &v7[i]);
  printf("Which sorting method do you want to use:\n");
  printf("1. Bubble Sort\n");
  printf("2. Selection Sort\n");
  printf("3. Insertion Sort\n");
  scanf("%d", &v5);
  if ( v5 == 3 )
  {
    insertion_sort(v7, v6);
    printf("The array sorted using Insertion Sort is:\n");
  }
  else
  {
    if ( v5 > 3 )
      goto LABEL_12;
    if ( v5 == 1 )
    {
      bubble_sort(v7, v6);
      printf("The array sorted using Bubble Sort is:\n");
    }
    else
    {
      if ( v5 != 2 )
      {
LABEL_12:
        printf("Invalid Input\n");
        exit(0);
      }
      selection_sort(v7, v6);
      printf("The array sorted using Selection Sort is:\n");
    }
  }
  for ( i = 0; i < (int)v6; ++i )
    printf("%d ", (unsigned int)v7[i]);
  return 0;
}
// 140001617: using guessed type __int64 __fastcall bubble_sort(_QWORD, _QWORD);
// 1400016D0: using guessed type __int64 __fastcall selection_sort(_QWORD, _QWORD);
// 140001791: using guessed type __int64 __fastcall insertion_sort(_QWORD, _QWORD);
// 140001B20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature monitor ; Style: beginner-friendly
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float celsius, fahrenheit;
    
    printf("Enter the temperature in Celsius: ");
    scanf("%f", &celsius);
    
    fahrenheit = (celsius * 9 / 5) + 32;
    
    printf("The temperature in Fahrenheit is: %.2f\n", fahrenheit);
    
    if (fahrenheit <= 32)
    {
        printf("It's freezing cold!\n");
    }
    else if (fahrenheit > 32 && fahrenheit <= 60)
    {
        printf("It's chilly!\n");
    }
    else if (fahrenheit > 60 && fahrenheit <= 80)
    {
        printf("It's nice and warm!\n");
    }
    else
    {
        printf("It's hot outside!\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+28h] [rbp-8h] BYREF
  float v5; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the temperature in Celsius: ");
  scanf("%f", &v4);
  v5 = (float)((float)(9.0 * v4) / 5.0) + 32.0;
  printf("The temperature in Fahrenheit is: %.2f\n", v5);
  if ( v5 > 32.0 )
  {
    if ( v5 > 60.0 )
    {
      if ( v5 > 80.0 )
        printf("It's hot outside!\n");
      else
        printf("It's nice and warm!\n");
    }
    else
    {
      printf("It's chilly!\n");
    }
  }
  else
  {
    printf("It's freezing cold!\n");
  }
  return 0;
}
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Table Game ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
   int num, guess, attempts = 0;
   srand(time(0));
   num = rand() % 100 + 1; // Generate random number from 1 to 100
   
   printf("Welcome to the Number Guessing Game!\n");
   printf("I'm thinking of a number from 1 to 100. Can you guess it in 10 tries?\n");
   
   while(attempts < 10) {
      printf("Guess #%d: ", attempts+1);
      scanf("%d", &guess);
      
      if(guess < 1 || guess > 100) {
         printf("Invalid guess. Please enter a number from 1 to 100.\n");
         continue; // Restart the while-loop
      }
      
      if(guess < num) {
         printf("Too low!\n");
      } else if(guess > num) {
         printf("Too high!\n");
      } else {
         printf("Congratulations, you guessed the number in %d tries!\n", attempts+1);
         return 0; // Terminate the program
      }
      
      attempts++;
   }
   
   // If the user didn't guess the number in 10 tries, print the correct number
   printf("Sorry, you didn't guess the number in time. The correct number was %d.\n", num);
   
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  int v6; // [rsp+28h] [rbp-8h]
  int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 0;
  v3 = time(0i64);
  srand(v3);
  v6 = rand() % 100 + 1;
  printf("Welcome to the Number Guessing Game!\n");
  printf("I'm thinking of a number from 1 to 100. Can you guess it in 10 tries?\n");
  while ( v7 <= 9 )
  {
    printf("Guess #%d: ", (unsigned int)(v7 + 1));
    scanf("%d", &v5);
    if ( v5 > 0 && v5 <= 100 )
    {
      if ( v6 <= v5 )
      {
        if ( v6 >= v5 )
        {
          printf("Congratulations, you guessed the number in %d tries!\n", (unsigned int)(v7 + 1));
          return 0;
        }
        printf("Too high!\n");
      }
      else
      {
        printf("Too low!\n");
      }
      ++v7;
    }
    else
    {
      printf("Invalid guess. Please enter a number from 1 to 100.\n");
    }
  }
  printf("Sorry, you didn't guess the number in time. The correct number was %d.\n", (unsigned int)v6);
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Hotel Management System ; Style: shape shifting
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct guest {
  char name[30];
  int room_number;
  int stay_length;
  float bill_total;
};

void add_guest(struct guest list[], int *num_guests);
void display_guests(struct guest list[], int num_guests);
void checkout_guest(struct guest list[], int *num_guests);
void print_menu();

int main() {
  int choice, num_guests=0;
  struct guest guest_list[50];
  do {
    print_menu();
    printf("Enter your choice: ");
    scanf("%d", &choice);
    switch(choice) {
      case 1:
        add_guest(guest_list, &num_guests);
        break;
      case 2:
        display_guests(guest_list, num_guests);
        break;
      case 3:
        checkout_guest(guest_list, &num_guests);
        break;
      case 4:
        printf("Thank you for using the Hotel Management System.\n");
        exit(0);
      default:
        printf("Invalid choice. Please choose again.\n");
        break;
    }
  } while(choice != 4);

  return 0;
}

void add_guest(struct guest list[], int *num_guests) {
  if(*num_guests == 50) {
    printf("The hotel is currently at maximum capacity.\n");
    return;
  }
  
  printf("Enter guest name: ");
  scanf("%s", list[*num_guests].name);
  printf("Enter room number (1-50): ");
  scanf("%d", &list[*num_guests].room_number);
  printf("Enter length of stay: ");
  scanf("%d", &list[*num_guests].stay_length);
  list[*num_guests].bill_total = list[*num_guests].stay_length * 100.0; //Assuming each night costs $100
  printf("Guest added successfully.\n");
  (*num_guests)++;
}

void display_guests(struct guest list[], int num_guests) {
  if(num_guests == 0) {
    printf("There are currently no guests at the hotel.\n");
    return;
  }
  
  printf("Name\tRoom Number\tStay Length\tBill Total\n");
  for(int i=0; i<num_guests; i++) {
    printf("%s\t%d\t%d\t$%.2f\n", list[i].name, list[i].room_number, list[i].stay_length, list[i].bill_total);
  }
}

void checkout_guest(struct guest list[], int *num_guests) {
  if(*num_guests == 0) {
    printf("There are currently no guests to checkout.\n");
    return;
  }
  
  char name[30];
  printf("Enter guest name to checkout: ");
  scanf("%s", name);
  for(int i=0; i<*num_guests; i++) {
    if(strcmp(list[i].name, name) == 0) {
      printf("Checkout complete. Guest bill is $%.2f.\n", list[i].bill_total);
      for(int j=i; j<*num_guests-1; j++) {
        list[j] = list[j+1]; //Shift all elements after the checked out guest
      }
      (*num_guests)--;
      return;
    }
  }
  printf("Guest not found in current guests.\n");
}

void print_menu() {
  printf("Welcome to the Hotel Management System.\n");
  printf("1. Add guest\n");
  printf("2. Display current guests\n");
  printf("3. Checkout guest\n");
  printf("4. Exit\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall add_guest(_QWORD, _QWORD); // weak
__int64 __fastcall display_guests(_QWORD, _QWORD); // weak
__int64 __fastcall checkout_guest(_QWORD, _QWORD); // weak
__int64 print_menu(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[2200]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v5; // [rsp+8B8h] [rbp+838h] BYREF
  int v6; // [rsp+8BCh] [rbp+83Ch] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  do
  {
    print_menu();
    printf("Enter your choice: ");
    scanf("%d", &v6);
    if ( v6 == 4 )
    {
      printf("Thank you for using the Hotel Management System.\n");
      exit(0);
    }
    if ( v6 <= 4 )
    {
      switch ( v6 )
      {
        case 3:
          checkout_guest(v4, &v5);
          continue;
        case 1:
          add_guest(v4, &v5);
          continue;
        case 2:
          display_guests(v4, v5);
          continue;
      }
    }
    printf("Invalid choice. Please choose again.\n");
  }
  while ( v6 != 4 );
  return 0;
}
// 140001646: conditional instruction was optimized away because %var_4.4<3
// 1400016D8: using guessed type __int64 __fastcall add_guest(_QWORD, _QWORD);
// 140001879: using guessed type __int64 __fastcall display_guests(_QWORD, _QWORD);
// 140001991: using guessed type __int64 __fastcall checkout_guest(_QWORD, _QWORD);
// 140001B4E: using guessed type __int64 print_menu(void);
// 140001C60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Poker Game ; Style: paranoid
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_PLAYERS 6
#define MAX_NAME_LENGTH 20

typedef enum {
    CLUBS,
    DIAMONDS,
    HEARTS,
    SPADES
} Suit;

typedef enum {
    ACE = 1,
    TWO,
    THREE,
    FOUR,
    FIVE,
    SIX,
    SEVEN,
    EIGHT,
    NINE,
    TEN,
    JACK,
    QUEEN,
    KING
} Rank;

typedef struct {
    Rank rank;
    Suit suit;
} Card;

typedef struct {
    char name[MAX_NAME_LENGTH];
    int chips;
    Card hand[2];
} Player;

Card deck[52];
int deckIndex = 0;

void shuffleDeck()
{
    srand(time(NULL));
    int n = 52;
    while (n > 1) {
        int k = rand() % n;
        n--;
        Card temp = deck[n];
        deck[n] = deck[k];
        deck[k] = temp;
    }
}

Card dealCard()
{
    if (deckIndex == 52) {
        shuffleDeck();
        deckIndex = 0;
    }
    return deck[deckIndex++];
}

void dealCards(Player *players, int numPlayers)
{
    for (int i = 0; i < numPlayers; i++) {
        players[i].hand[0] = dealCard();
        players[i].hand[1] = dealCard();
    }
}

void printCard(Card card)
{
    switch (card.rank) {
        case ACE:
            printf("Ace");
            break;
        case TWO:
            printf("2");
            break;
        case THREE:
            printf("3");
            break;
        case FOUR:
            printf("4");
            break;
        case FIVE:
            printf("5");
            break;
        case SIX:
            printf("6");
            break;
        case SEVEN:
            printf("7");
            break;
        case EIGHT:
            printf("8");
            break;
        case NINE:
            printf("9");
            break;
        case TEN:
            printf("10");
            break;
        case JACK:
            printf("Jack");
            break;
        case QUEEN:
            printf("Queen");
            break;
        case KING:
            printf("King");
            break;
    }
    printf(" of ");
    switch (card.suit) {
        case CLUBS:
            printf("Clubs");
            break;
        case DIAMONDS:
            printf("Diamonds");
            break;
        case HEARTS:
            printf("Hearts");
            break;
        case SPADES:
            printf("Spades");
            break;
    }
    printf("\n");
}

void printHand(Card hand[], int size)
{
    for (int i = 0; i < size; i++) {
        printCard(hand[i]);
    }
}

int main()
{
    Player players[MAX_PLAYERS];
    int numPlayers = 0;
    int numChips = 0;
    int numCards = 2;
    
    printf("Welcome to paranoid poker! How many players will be playing? ");
    scanf("%d", &numPlayers);
    if (numPlayers < 2 || numPlayers > 6) {
        printf("Invalid number of players. Must be between 2 and 6.\n");
        return 1;
    }
    
    for (int i = 0; i < numPlayers; i++) {
        printf("Player %d, enter your name: ", i+1);
        scanf("%s", players[i].name);
        players[i].chips = 1000;
    }
    
    printf("\n%s has begun dealing cards...\n\n", players[rand() % numPlayers].name);
    shuffleDeck();
    dealCards(players, numPlayers);
    
    for (int i = 0; i < numPlayers; i++) {
        printf("%s's hand:\n", players[i].name);
        printHand(players[i].hand, numCards);
        printf("\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 shuffleDeck(void); // weak
__int64 __fastcall dealCards(_QWORD, _QWORD); // weak
__int64 __fastcall printHand(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();


//----- (000000014000196C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // eax
  int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[80]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v7; // [rsp+80h] [rbp+0h] BYREF
  unsigned int v8; // [rsp+120h] [rbp+A0h]
  int v9; // [rsp+124h] [rbp+A4h]
  int j; // [rsp+128h] [rbp+A8h]
  int i; // [rsp+12Ch] [rbp+ACh]

  _main(argc, argv, envp);
  v5 = 0;
  v9 = 0;
  v8 = 2;
  printf("Welcome to paranoid poker! How many players will be playing? ");
  scanf("%d", &v5);
  if ( v5 > 1 && v5 <= 6 )
  {
    for ( i = 0; i < v5; ++i )
    {
      printf("Player %d, enter your name: ", (unsigned int)(i + 1));
      scanf("%s", &v6[40 * i]);
      *((_DWORD *)&v7 + 10 * i - 15) = 1000;
    }
    v4 = rand();
    printf("\n%s has begun dealing cards...\n\n", &v6[40 * (v4 % v5)]);
    shuffleDeck();
    dealCards(v6, (unsigned int)v5);
    for ( j = 0; j < v5; ++j )
    {
      printf("%s's hand:\n", &v6[40 * j]);
      printHand(&v6[40 * j + 24], v8);
      printf("\n");
    }
    return 0;
  }
  else
  {
    printf("Invalid number of players. Must be between 2 and 6.\n");
    return 1;
  }
}
// 140001601: using guessed type __int64 shuffleDeck(void);
// 1400016F5: using guessed type __int64 __fastcall dealCards(_QWORD, _QWORD);
// 140001924: using guessed type __int64 __fastcall printHand(_QWORD, _QWORD);
// 140001C20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000196C: using guessed type char var_100[80];

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Steganography ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//This program demonstrates a unique implementation of LSB steganography on an image

//Function to get image data
unsigned char* getImage(char *filename) {
    FILE *in;
    unsigned char *data;

    in = fopen(filename,"rb");

    if (in == NULL) {
        printf("Error opening file.\n");
        exit(1);
    }

    data = (unsigned char*) malloc(sizeof(unsigned char));

    fread(data,1,sizeof(unsigned char),in);

    fclose(in);

    return data;
}

//Function to write image data
void writeImage(char *filename, unsigned char *data) {
    FILE *out;

    out = fopen(filename,"wb");

    if (out == NULL) {
        printf("Error opening file.\n");
        exit(1);
    }

    fwrite(data,1,sizeof(unsigned char),out);

    fclose(out);

}

//Function to hide message in the least significant bits of the image data
void hideMessage(char *message, unsigned char *imageData) {
    int messageLength = strlen(message);
    int bitCount = 0;

    for (int i = 0; i < messageLength; i++) {
        for (int j = 0; j < 8; j++) {
            unsigned char bit = (message[i] >> j) & 1;
            if (bit) {
                imageData[bitCount] |= 1;
            } else {
                imageData[bitCount] &= 0xFE;
            }
            bitCount++;
        }
    }
}

//Function to get hidden message from the least significant bits of the image data
char* getMessage(unsigned char *imageData) {
    char *message = (char*) malloc(sizeof(char));
    int messageLength = 0;
    int bitCount = 0;

    while (1) {
        char ch = 0;
        for (int i = 0; i < 8; i++) {
            char bit = imageData[bitCount] & 1;
            ch |= bit << i;
            bitCount++;
        }
        if (ch == '\0') break;
        message[messageLength] = ch;
        messageLength++;
        message = (char*) realloc(message,sizeof(char) * (messageLength + 1));
    }
    message[messageLength] = '\0';

    return message;
}

int main() {

    printf("LSB Steganography Implementation on Images\n\n");

    char *message = "Hidden message!";
    unsigned char *imageData;

    //Get the image data
    imageData = getImage("image.bmp");

    //Hide the message in the image data
    hideMessage(message,imageData);

    //Write the new image data to a file
    writeImage("hidden.bmp",imageData);

    //Get the hidden message from the image data
    char *hiddenMessage = getMessage(imageData);

    printf("Message hidden in image: %s\n",hiddenMessage);

    //Free memory
    free(imageData);
    free(hiddenMessage);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall getImage(_QWORD); // weak
__int64 __fastcall writeImage(_QWORD, _QWORD); // weak
__int64 __fastcall hideMessage(_QWORD, _QWORD); // weak
__int64 __fastcall getMessage(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (0000000140001816) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *Message; // [rsp+28h] [rbp-18h]
  void *Block; // [rsp+30h] [rbp-10h]

  _main(argc, argv, envp);
  printf("LSB Steganography Implementation on Images\n\n");
  Block = (void *)getImage("image.bmp");
  hideMessage("Hidden message!", Block);
  writeImage("hidden.bmp", Block);
  Message = (char *)getMessage(Block);
  printf("Message hidden in image: %s\n", Message);
  free(Block);
  free(Message);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall getImage(_QWORD);
// 140001616: using guessed type __int64 __fastcall writeImage(_QWORD, _QWORD);
// 14000168E: using guessed type __int64 __fastcall hideMessage(_QWORD, _QWORD);
// 14000175A: using guessed type __int64 __fastcall getMessage(_QWORD);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mortgage Calculator ; Style: real-life
#include <stdio.h>
#include <stdlib.h>

int main(){

    float loan_amount, interest_rate, monthly_payment, total_interest, total_payment;
    int years;

    // taking loan amount as input
    printf("Enter the loan amount: ");
    scanf("%f", &loan_amount);

    // taking interest rate as input
    printf("Enter the interest rate (per annum): ");
    scanf("%f", &interest_rate);

    // taking loan term in years as input
    printf("Enter the loan term (in years): ");
    scanf("%d", &years);

    // calculating monthly interest rate
    float monthly_rate = interest_rate/(12 * 100);

    // calculating number of months
    int months = years * 12;

    // calculating monthly payment
    monthly_payment = (loan_amount * monthly_rate * pow(1 + monthly_rate, months)) / (pow(1 + monthly_rate, months) - 1);

    // calculating total interest paid
    total_interest = monthly_payment * months - loan_amount;

    // calculating total payment
    total_payment = monthly_payment * months;

    // print the output
    printf("Loan Amount: %.2f\n",loan_amount);
    printf("Interest Rate: %.2f per annum\n",interest_rate);
    printf("Loan Term: %d years\n",years);
    printf("Monthly Payment: %.2f\n",monthly_payment);
    printf("Total Interest Paid: %.2f\n",total_interest);
    printf("Total Payment: %.2f\n",total_payment);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm6_8
  double v4; // xmm6_8
  float v5; // xmm0_4
  unsigned int v7; // [rsp+20h] [rbp-20h] BYREF
  float v8; // [rsp+24h] [rbp-1Ch] BYREF
  float v9; // [rsp+28h] [rbp-18h] BYREF
  float v10; // [rsp+2Ch] [rbp-14h]
  float v11; // [rsp+30h] [rbp-10h]
  float v12; // [rsp+34h] [rbp-Ch]
  unsigned int v13; // [rsp+38h] [rbp-8h]
  float v14; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the loan amount: ");
  scanf("%f", &v9);
  printf("Enter the interest rate (per annum): ");
  scanf("%f", &v8);
  printf("Enter the loan term (in years): ");
  scanf("%d", &v7);
  v14 = v8 / 1200.0;
  v13 = 12 * v7;
  v3 = (float)(v9 * (float)(v8 / 1200.0));
  v4 = v3 * pow((float)((float)(v8 / 1200.0) + 1.0), (double)(int)(12 * v7));
  v5 = v4 / (pow((float)(v14 + 1.0), (double)(int)v13) - 1.0);
  v12 = v5;
  v11 = (float)((float)(int)v13 * v5) - v9;
  v10 = (float)(int)v13 * v5;
  printf("Loan Amount: %.2f\n", v9);
  printf("Interest Rate: %.2f per annum\n", v8);
  printf("Loan Term: %d years\n", v7);
  printf("Monthly Payment: %.2f\n", v12);
  printf("Total Interest Paid: %.2f\n", v11);
  printf("Total Payment: %.2f\n", v10);
  return 0;
}
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Airport Baggage Handling Simulation ; Style: energetic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    printf("Welcome to the Airport Baggage Handling Simulation!\n");

    // Set up variables for the simulation
    int total_waiting_time = 0;
    int total_bags_processed = 0;
    int max_waiting_time = 0;
    srand(time(NULL));

    // Simulation loop runs five times
    for (int i = 0; i < 5; i++) {

        printf("\nRunning simulation %d...\n", i + 1);

        // Generate random number of bags between 1 and 10
        int num_bags = rand() % 10 + 1;
        printf("Processing %d bags...\n", num_bags);

        // Set up variables for this simulation run
        int waiting_time = 0;
        int bags_processed = 0;

        // Loop through bags
        for (int j = 0; j < num_bags; j++) {

            // Generate random processing time between 1 and 5 seconds
            int processing_time = rand() % 5 + 1;

            // Add processing time to waiting time
            waiting_time += processing_time;

            // Print message for this bag
            printf("Processing bag %d (time: %d seconds)...\n", j + 1, processing_time);

            // Increment counter for bags processed
            bags_processed++;
        }

        // Print results for this simulation run
        printf("\nBags processed: %d\n", bags_processed);
        printf("Total waiting time: %d seconds\n", waiting_time);

        // Add results for this simulation run to total results
        total_bags_processed += bags_processed;
        total_waiting_time += waiting_time;

        // Keep track of the maximum waiting time
        if (waiting_time > max_waiting_time) {
            max_waiting_time = waiting_time;
        }
    }

    // Print total results for all simulation runs
    printf("\nOverall results:\n");
    printf("Total bags processed: %d\n", total_bags_processed);
    printf("Average waiting time: %d seconds\n", total_waiting_time / 5);
    printf("Maximum waiting time: %d seconds\n", max_waiting_time);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-24h]
  int v6; // [rsp+30h] [rbp-20h]
  int j; // [rsp+34h] [rbp-1Ch]
  unsigned int v8; // [rsp+38h] [rbp-18h]
  unsigned int v9; // [rsp+3Ch] [rbp-14h]
  int i; // [rsp+40h] [rbp-10h]
  unsigned int v11; // [rsp+44h] [rbp-Ch]
  unsigned int v12; // [rsp+48h] [rbp-8h]
  int v13; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Airport Baggage Handling Simulation!\n");
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 4; ++i )
  {
    printf("\nRunning simulation %d...\n", (unsigned int)(i + 1));
    v6 = rand() % 10 + 1;
    printf("Processing %d bags...\n", (unsigned int)v6);
    v9 = 0;
    v8 = 0;
    for ( j = 0; j < v6; ++j )
    {
      v5 = rand() % 5 + 1;
      v9 += v5;
      printf("Processing bag %d (time: %d seconds)...\n", (unsigned int)(j + 1), v5);
      ++v8;
    }
    printf("\nBags processed: %d\n", v8);
    printf("Total waiting time: %d seconds\n", v9);
    v12 += v8;
    v13 += v9;
    if ( (int)v9 > (int)v11 )
      v11 = v9;
  }
  printf("\nOverall results:\n");
  printf("Total bags processed: %d\n", v12);
  printf("Average waiting time: %d seconds\n", (unsigned int)(v13 / 5));
  printf("Maximum waiting time: %d seconds\n", v11);
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cryptographic hash function ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Create a custom hash function
unsigned long myHashFunction(const char *str) {
    int n = strlen(str);
    unsigned long hash = 5381;
    for (int i = 0; i < n; i++) {
        hash = ((hash << 5) + hash) + str[i];
    }
    return hash;
}

int main(void) {
    char *input = malloc(100);
    printf("Enter a string to hash: ");
    scanf("%s", input);
    unsigned long hash = myHashFunction(input);
    printf("Hash value: %lu\n", hash);
    free(input);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall myHashFunction(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (0000000140001645) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch]
  void *Block; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  Block = malloc(0x64ui64);
  printf("Enter a string to hash: ");
  scanf("%s", Block);
  v4 = myHashFunction(Block);
  printf("Hash value: %lu\n", v4);
  free(Block);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall myHashFunction(_QWORD);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Task Scheduler ; Style: enthusiastic
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef void (*TaskFunction)(void);

typedef struct {
    int interval;
    int remaining_time;
    TaskFunction task;
} Task;

void task1() {
    printf("I'm task 1!\n");
}

void task2() {
    printf("I'm task 2!\n");
}

int main() {
    Task tasks[2] = {
        {3, 3, &task1},
        {5, 5, &task2}
    };
    int num_tasks = sizeof(tasks) / sizeof(tasks[0]);

    while (1) {
        for (int i = 0; i < num_tasks; i++) {
            if (tasks[i].remaining_time == 0) {
                tasks[i].task();
                tasks[i].remaining_time = tasks[i].interval;
            } else {
                tasks[i].remaining_time--;
            }
        }
        usleep(100000); // sleep for 100ms
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall task1(); // weak
__int64 __fastcall task2(); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall usleep(_QWORD); // weak


//----- (00000001400015CD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int *v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  int v8; // [rsp+20h] [rbp-30h]
  int v9; // [rsp+24h] [rbp-2Ch] BYREF
  __int64 (__fastcall *v10)(); // [rsp+28h] [rbp-28h]
  int v11; // [rsp+30h] [rbp-20h]
  int v12; // [rsp+34h] [rbp-1Ch]
  __int64 (__fastcall *v13)(); // [rsp+38h] [rbp-18h]
  int v14; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 3;
  v9 = 3;
  v10 = task1;
  v11 = 5;
  v12 = 5;
  v13 = task2;
  v14 = 2;
  while ( 1 )
  {
    for ( i = 0; i < v14; ++i )
    {
      if ( *(&v9 + 4 * i) )
      {
        v3 = (int *)(unsigned int)(*(&v9 + 4 * i) - 1);
        *(&v9 + 4 * i) = (int)v3;
      }
      else
      {
        ((void (__fastcall *)(__int64, int *, __int64, __int64))*(&v10 + 2 * i))(v4, v3, v5, v6);
        v3 = &v9 + 4 * i;
        *v3 = *(&v8 + 4 * i);
      }
    }
    usleep(100000i64);
  }
}
// 140001645: variable 'v4' is possibly undefined
// 140001645: variable 'v3' is possibly undefined
// 140001645: variable 'v5' is possibly undefined
// 140001645: variable 'v6' is possibly undefined
// 140001591: using guessed type __int64 __fastcall task1();
// 1400015AF: using guessed type __int64 __fastcall task2();
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400027D0: using guessed type __int64 __fastcall usleep(_QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: synchronous
#include <stdio.h>

int main() {
  int i, j, flag, n;
  
  printf("Enter the number of prime numbers you want to generate: ");
  scanf("%d", &n);
  
  // First prime number is 2
  printf("2 ");

  // Check for prime numbers starting from 3
  for (i = 3; i <= n; i++) {
    flag = 1;

    // Check if i is prime
    for (j = 2; j <= i / 2; j++)
      if (i % j == 0)
        flag = 0;

    // If i is prime, print it
    if (flag)
      printf("%d ", i);
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-10h] BYREF
  int v5; // [rsp+24h] [rbp-Ch]
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of prime numbers you want to generate: ");
  scanf("%d", &v4);
  printf("2 ");
  for ( i = 3; i <= v4; ++i )
  {
    v5 = 1;
    for ( j = 2; j <= i / 2; ++j )
    {
      if ( !(i % j) )
        v5 = 0;
    }
    if ( v5 )
      printf("%d ", (unsigned int)i);
  }
  return 0;
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define BOARD_SIZE 16

int main(int argc, char *argv[]) {
    int board[BOARD_SIZE] = {0};
    int revealed[BOARD_SIZE] = {0};
    int num_turns = 0;
    
    // Seed the random number generator using current time
    srand(time(NULL));
    
    // Initialize the board with random numbers
    for (int i = 0; i < BOARD_SIZE; i++) {
        board[i] = rand() % 8 + 1;
    }
    
    // Print the board
    printf("MEMORY GAME\n");
    printf("===========");
    for (int i = 0; i < BOARD_SIZE; i++) {
        printf("\n| ");
        if (revealed[i]) {
            printf("%d ", board[i]);
        } else {
            printf("? ");
        }
        printf("|  ");
        // Print a newline after every fourth square
        if ((i+1) % 4 == 0) {
            printf("\n=============");
        }
    }
    printf("\n\n");
    
    int choice1, choice2;
    while (1) {
        // Prompt for the first choice
        printf("Pick a square (1-16): ");
        scanf("%d", &choice1);
        printf("\n");
        
        // Make sure the choice is valid
        if (choice1 < 1 || choice1 > 16) {
            printf("Invalid choice. Try again.\n\n");
            continue;
        }
        if (revealed[choice1-1]) {
            printf("That square has already been chosen. Try again.\n\n");
            continue;
        }
        
        // Reveal the first choice
        revealed[choice1-1] = 1;
        num_turns++;
        
        // Print the board with the first choice revealed
        printf("MEMORY GAME\n");
        printf("===========");
        for (int i = 0; i < BOARD_SIZE; i++) {
            printf("\n| ");
            if (revealed[i]) {
                printf("%d ", board[i]);
            } else {
                printf("? ");
            }
            printf("|  ");
            if ((i+1) % 4 == 0) {
                printf("\n=============");
            }
        }
        printf("\n\n");
        
        // Prompt for the second choice
        printf("Pick another square (1-16): ");
        scanf("%d", &choice2);
        printf("\n");
        
        // Make sure the choice is valid
        if (choice2 < 1 || choice2 > 16) {
            printf("Invalid choice. Try again.\n\n");
            revealed[choice1-1] = 0;
            num_turns--;
            continue;
        }
        if (revealed[choice2-1]) {
            printf("That square has already been chosen. Try again.\n\n");
            revealed[choice1-1] = 0;
            num_turns--;
            continue;
        }
        
        // Reveal the second choice
        revealed[choice2-1] = 1;
        num_turns++;
        
        // Print the board with both choices revealed
        printf("MEMORY GAME\n");
        printf("===========");
        for (int i = 0; i < BOARD_SIZE; i++) {
            printf("\n| ");
            if (revealed[i]) {
                printf("%d ", board[i]);
            } else {
                printf("? ");
            }
            printf("|  ");
            if ((i+1) % 4 == 0) {
                printf("\n=============");
            }
        }
        printf("\n\n");
        
        // Check if the choices match
        if (board[choice1-1] == board[choice2-1]) {
            printf("Match!\n\n");
        } else {
            printf("No match.\n\n");
            revealed[choice1-1] = 0;
            revealed[choice2-1] = 0;
            num_turns -= 2;
        }
        
        // Check if the game is over
        int game_over = 1;
        for (int i = 0; i < BOARD_SIZE; i++) {
            if (!revealed[i]) {
                game_over = 0;
                break;
            }
        }
        if (game_over) {
            printf("Game over! You completed the game in %d turns.\n", num_turns);
            break;
        }
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+28h] [rbp-A8h] BYREF
  int v6; // [rsp+2Ch] [rbp-A4h] BYREF
  __int64 v7[8]; // [rsp+30h] [rbp-A0h] BYREF
  __int64 v8[8]; // [rsp+70h] [rbp-60h] BYREF
  int n; // [rsp+B4h] [rbp-1Ch]
  int v10; // [rsp+B8h] [rbp-18h]
  int m; // [rsp+BCh] [rbp-14h]
  int k; // [rsp+C0h] [rbp-10h]
  int j; // [rsp+C4h] [rbp-Ch]
  int i; // [rsp+C8h] [rbp-8h]
  unsigned int v15; // [rsp+CCh] [rbp-4h]

  _main(argc, argv, envp);
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  v15 = 0;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 15; ++i )
    *((_DWORD *)v8 + i) = rand() % 8 + 1;
  printf("MEMORY GAME\n");
  printf("===========");
  for ( j = 0; j <= 15; ++j )
  {
    printf("\n| ");
    if ( *((_DWORD *)v7 + j) )
      printf("%d ", *((unsigned int *)v8 + j));
    else
      printf("? ");
    printf("|  ");
    if ( (((_BYTE)j + 1) & 3) == 0 )
      printf("\n=============");
  }
  printf("\n\n");
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            printf("Pick a square (1-16): ");
            scanf("%d", &v6);
            printf("\n");
            if ( v6 > 0 && v6 <= 16 )
              break;
            printf("Invalid choice. Try again.\n\n");
          }
          if ( !*((_DWORD *)v7 + v6 - 1) )
            break;
          printf("That square has already been chosen. Try again.\n\n");
        }
        *((_DWORD *)v7 + v6 - 1) = 1;
        ++v15;
        printf("MEMORY GAME\n");
        printf("===========");
        for ( k = 0; k <= 15; ++k )
        {
          printf("\n| ");
          if ( *((_DWORD *)v7 + k) )
            printf("%d ", *((unsigned int *)v8 + k));
          else
            printf("? ");
          printf("|  ");
          if ( (((_BYTE)k + 1) & 3) == 0 )
            printf("\n=============");
        }
        printf("\n\n");
        printf("Pick another square (1-16): ");
        scanf("%d", &v5);
        printf("\n");
        if ( v5 > 0 && v5 <= 16 )
          break;
        printf("Invalid choice. Try again.\n\n");
        *((_DWORD *)v7 + v6 - 1) = 0;
        --v15;
      }
      if ( !*((_DWORD *)v7 + v5 - 1) )
        break;
      printf("That square has already been chosen. Try again.\n\n");
      *((_DWORD *)v7 + v6 - 1) = 0;
      --v15;
    }
    *((_DWORD *)v7 + v5 - 1) = 1;
    ++v15;
    printf("MEMORY GAME\n");
    printf("===========");
    for ( m = 0; m <= 15; ++m )
    {
      printf("\n| ");
      if ( *((_DWORD *)v7 + m) )
        printf("%d ", *((unsigned int *)v8 + m));
      else
        printf("? ");
      printf("|  ");
      if ( (((_BYTE)m + 1) & 3) == 0 )
        printf("\n=============");
    }
    printf("\n\n");
    if ( *((_DWORD *)v8 + v6 - 1) == *((_DWORD *)v8 + v5 - 1) )
    {
      printf("Match!\n\n");
    }
    else
    {
      printf("No match.\n\n");
      *((_DWORD *)v7 + v6 - 1) = 0;
      *((_DWORD *)v7 + v5 - 1) = 0;
      v15 -= 2;
    }
    v10 = 1;
    for ( n = 0; n <= 15; ++n )
    {
      if ( !*((_DWORD *)v7 + n) )
      {
        v10 = 0;
        break;
      }
    }
  }
  while ( !v10 );
  printf("Game over! You completed the game in %d turns.\n", v15);
  return 0;
}
// 140001C10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Alien Invasion Probability Calculator ; Style: brave
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  srand(time(NULL)); // Initialize random seed
  int invasionProbability = rand() % 101; // Generate a random number from 0 to 100
  
  printf("Welcome to the Alien Invasion Probability Calculator!\n");
  printf("Based on our calculations, there is a %d%% chance of an alien invasion.\n", invasionProbability);
  
  if (invasionProbability == 0) {
    printf("Well, it looks like we're safe for now.\n");
  } else if (invasionProbability > 0 && invasionProbability <= 25) {
    printf("It's unlikely, but we should still prepare just in case.\n");
  } else if (invasionProbability > 25 && invasionProbability <= 50) {
    printf("Things are looking ominous. We need to start preparing for an attack.\n");
  } else if (invasionProbability > 50 && invasionProbability <= 75) {
    printf("This is getting serious. We need to evacuate major cities and set up a defensive perimeter.\n");
  } else {
    printf("This is not a drill. An alien invasion is imminent. We need to mobilize all available resources and fight for our survival!\n");
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v5 = rand() % 101;
  printf("Welcome to the Alien Invasion Probability Calculator!\n");
  printf("Based on our calculations, there is a %d%% chance of an alien invasion.\n", (unsigned int)v5);
  if ( v5 )
  {
    if ( v5 <= 0 || v5 > 25 )
    {
      if ( v5 <= 25 || v5 > 50 )
      {
        if ( v5 <= 50 || v5 > 75 )
          printf(
            "This is not a drill. An alien invasion is imminent. We need to mobilize all available resources and fight fo"
            "r our survival!\n");
        else
          printf("This is getting serious. We need to evacuate major cities and set up a defensive perimeter.\n");
      }
      else
      {
        printf("Things are looking ominous. We need to start preparing for an attack.\n");
      }
    }
    else
    {
      printf("It's unlikely, but we should still prepare just in case.\n");
    }
  }
  else
  {
    printf("Well, it looks like we're safe for now.\n");
  }
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ITEMS 50

// Struct to store item details
typedef struct {
    char name[20];
    int quantity;
    float price;
} item;

// Initialize menu items
item menu[MAX_ITEMS] = {
    {"Coffee", 10, 2.50},
    {"Tea", 15, 1.25},
    {"Sandwich", 5, 5.00},
    {"Pastry", 20, 2.50},
    {"Donut", 30, 1.50}
};

int main() {
    int num_items = sizeof(menu) / sizeof(item);
    int order_qty[num_items];
    float order_total = 0;

    printf("*** Welcome to the Future Cafe! ***\n");
    printf("Here is our menu:\n");

    for (int i = 0; i < num_items; i++) {
        printf("%d. %s - $%.2f\n", i+1, menu[i].name, menu[i].price);
    }

    printf("\nPlease enter your order below:\n");

    // Take customer's order
    for (int i = 0; i < num_items; i++) {
        printf("%s - Enter qty: ", menu[i].name);
        scanf("%d", &order_qty[i]);
        order_total += order_qty[i] * menu[i].price;

        // Check if ordered qty is greater than available qty
        if (order_qty[i] > menu[i].quantity) {
            printf("We don't have enough %s in stock. Your order has been adjusted accordingly.\n", menu[i].name);
            order_qty[i] = menu[i].quantity;
            order_total -= (order_qty[i] * menu[i].price);
        }

        // Update available qty
        menu[i].quantity -= order_qty[i];
    }

    // Print invoice
    printf("\n\n*** INVOICE ***\n");

    for (int i = 0; i < num_items; i++) {
        if (order_qty[i] > 0) {
            printf("%s x %d - $%.2f\n", menu[i].name, order_qty[i], (order_qty[i] * menu[i].price));
        }
    }

    // Add tax and calculate total amount
    float tax = order_total * 0.07;
    float total_amount = order_total + tax;
    printf("\nTax (7%%) - $%.2f\n", tax);
    printf("Total Amount - $%.2f\n", total_amount);

    printf("\n\nThank you for ordering from Future Cafe!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char menu[7] = "Coffee"; // weak
char asc_140014034[2] = "\n"; // weak
float flt_140014038[346] =
{
  2.5,
  ?flt,
  0.0,
  0.0,
  0.0,
  0.0,
  ?flt,
  1.25,
  1.7589352e22,
  4.2956907e24,
  0.0,
  0.0,
  0.0,
  ?flt,
  5.0,
  7.7130241e31,
  ?flt,
  0.0,
  0.0,
  0.0,
  ?flt,
  2.5,
  3.022518e32,
  ?flt,
  0.0,
  0.0,
  0.0,
  ?flt,
  1.5,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0
}; // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  int v4; // xmm0_4
  int v6[2]; // [rsp+20h] [rbp-30h] BYREF
  int *v7; // [rsp+28h] [rbp-28h]
  __int64 v8; // [rsp+30h] [rbp-20h]
  int v9; // [rsp+3Ch] [rbp-14h]
  int k; // [rsp+40h] [rbp-10h]
  int j; // [rsp+44h] [rbp-Ch]
  int i; // [rsp+48h] [rbp-8h]
  float v13; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 50;
  v8 = 49i64;
  v3 = alloca(208i64);
  v7 = v6;
  v13 = 0.0;
  printf("*** Welcome to the Future Cafe! ***\n");
  printf("Here is our menu:\n");
  for ( i = 0; i < v9; ++i )
    printf("%d. %s - $%.2f\n", (unsigned int)(i + 1), &menu[28 * i], flt_140014038[7 * i]);
  printf("\nPlease enter your order below:\n");
  for ( j = 0; j < v9; ++j )
  {
    printf("%s - Enter qty: ", &menu[28 * j]);
    scanf("%d", &v7[j]);
    v13 = (float)(flt_140014038[7 * j] * (float)v7[j]) + v13;
    if ( v7[j] > *(_DWORD *)&asc_140014034[28 * j] )
    {
      printf("We don't have enough %s in stock. Your order has been adjusted accordingly.\n", &menu[28 * j]);
      v7[j] = *(_DWORD *)&asc_140014034[28 * j];
      v13 = v13 - (float)((float)v7[j] * flt_140014038[7 * j]);
    }
    *(_DWORD *)&asc_140014034[28 * j] -= v7[j];
  }
  printf("\n\n*** INVOICE ***\n");
  for ( k = 0; k < v9; ++k )
  {
    if ( v7[k] > 0 )
      printf("%s x %d - $%.2f\n", &menu[28 * k], (unsigned int)v7[k], (float)(flt_140014038[7 * k] * (float)v7[k]));
  }
  *(float *)&v4 = 0.07000000000000001 * v13;
  v6[1] = v4;
  *(float *)v6 = v13 + *(float *)&v4;
  printf("\nTax (7%%) - $%.2f\n", *(float *)&v4);
  printf("Total Amount - $%.2f\n", *(float *)v6);
  printf("\n\nThank you for ordering from Future Cafe!\n");
  return 0;
}
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140014038: using guessed type float flt_140014038[346];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Appointment Scheduler ; Style: lively
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

struct appointment {
    char name[50];
    int day;
    int month;
    int year;
    int hour;
    int minute;
};

int main() {
    struct appointment appts[100];
    int num_appts = 0;

    while (true) {
        int choice;
        printf("\nWelcome to the Appointment Scheduler!\n");
        printf("1. Add an appointment\n");
        printf("2. List all appointments\n");
        printf("3. Exit\n");
        printf("Please enter your choice: ");
        scanf("%d", &choice);

        if (choice == 1) {
            struct appointment new_appt;
            printf("\nEnter the details of the new appointment.\n");
            printf("Name: ");
            scanf("%s", new_appt.name);
            printf("Date (DD/MM/YYYY): ");
            scanf("%d/%d/%d", &new_appt.day, &new_appt.month, &new_appt.year);
            printf("Time (HH:MM): ");
            scanf("%d:%d", &new_appt.hour, &new_appt.minute);
            appts[num_appts++] = new_appt;
            printf("New appointment added!\n");
        } else if (choice == 2) {
            printf("\nList of all appointments:\n");
            for (int i = 0; i < num_appts; i++) {
                printf("%s - %02d/%02d/%04d %02d:%02d\n", 
                       appts[i].name, 
                       appts[i].day, 
                       appts[i].month, 
                       appts[i].year, 
                       appts[i].hour, 
                       appts[i].minute);
            }
        } else if (choice == 3) {
            printf("\nGoodbye!\n");
            exit(0);
        } else {
            printf("\nInvalid choice. Please try again.\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int *v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rbx
  __int64 v8; // rbx
  int v9; // ecx
  int v10; // edx
  unsigned int v11; // r11d
  unsigned int v12; // r10d
  __int64 v13; // [rsp+20h] [rbp-60h]
  __int64 v14; // [rsp+28h] [rbp-58h]
  __int64 v15; // [rsp+30h] [rbp-50h]
  __int64 v16[6]; // [rsp+40h] [rbp-40h] BYREF
  __int64 v17; // [rsp+70h] [rbp-10h] BYREF
  __int64 v18; // [rsp+78h] [rbp-8h] BYREF
  __int64 v19; // [rsp+80h] [rbp+0h] BYREF
  int v20[1803]; // [rsp+8Ch] [rbp+Ch] BYREF
  int i; // [rsp+1CB8h] [rbp+1C38h]
  int v22; // [rsp+1CBCh] [rbp+1C3Ch]

  _main(argc, argv, envp);
  v22 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      printf("\nWelcome to the Appointment Scheduler!\n");
      printf("1. Add an appointment\n");
      printf("2. List all appointments\n");
      printf("3. Exit\n");
      printf("Please enter your choice: ");
      scanf("%d", v20);
      if ( v20[0] != 1 )
        break;
      printf("\nEnter the details of the new appointment.\n");
      printf("Name: ");
      scanf("%s", v16);
      printf("Date (DD/MM/YYYY): ");
      scanf("%d/%d/%d", (char *)&v17 + 4, &v18, (char *)&v18 + 4);
      printf("Time (HH:MM): ");
      scanf("%d:%d", &v19, (char *)&v19 + 4);
      v3 = v22++;
      v4 = v20 + 144 * v3 + 12659;
      v5 = v16[1];
      *(_QWORD *)v4 = v16[0];
      *((_QWORD *)v4 + 1) = v5;
      v6 = v16[3];
      *((_QWORD *)v4 + 2) = v16[2];
      *((_QWORD *)v4 + 3) = v6;
      v7 = v16[5];
      *((_QWORD *)v4 + 4) = v16[4];
      *((_QWORD *)v4 + 5) = v7;
      v8 = v18;
      *((_QWORD *)v4 + 6) = v17;
      *((_QWORD *)v4 + 7) = v8;
      *((_QWORD *)v4 + 8) = v19;
      printf("New appointment added!\n");
    }
    if ( v20[0] == 2 )
    {
      printf("\nList of all appointments:\n");
      for ( i = 0; i < v22; ++i )
      {
        v9 = *((_DWORD *)v20 + 18 * i + 19);
        v10 = *((_DWORD *)v20 + 18 * i + 18);
        v11 = *((_DWORD *)v20 + 18 * i + 17);
        v12 = *((_DWORD *)v20 + 18 * i + 16);
        LODWORD(v15) = *((_DWORD *)v20 + 18 * i + 20);
        LODWORD(v14) = v9;
        LODWORD(v13) = v10;
        printf("%s - %02d/%02d/%04d %02d:%02d\n", (const char *)&v20[18 * i + 1], v12, v11, v13, v14, v15);
      }
    }
    else
    {
      if ( v20[0] == 3 )
      {
        printf("\nGoodbye!\n");
        exit(0);
      }
      printf("\nInvalid choice. Please try again.\n");
    }
  }
}
// 1400019F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: String manipulation ; Style: paranoid
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_STR_LEN 50

int main() {

  char input_str[MAX_STR_LEN + 1];
  char output_str[MAX_STR_LEN + 1];
  int length = 0;
  int num_upper = 0;
  int num_lower = 0;
  int num_digits = 0;
  int num_special = 0;
  int paranoid_score = 0;
  int i;

  printf("Enter a string (max length %d): ", MAX_STR_LEN);
  fgets(input_str, MAX_STR_LEN+1, stdin);
  length = strlen(input_str);

  // Copy input string to output string
  strcpy(output_str, input_str);

  // Calculate number of uppercase, lowercase characters, digits, and special characters
  for(i = 0; i < length; i++) {
    if(isupper(input_str[i])) {
      num_upper++;
    }
    else if(islower(input_str[i])) {
      num_lower++;
    }
    else if(isdigit(input_str[i])) {
      num_digits++;
    }
    else if(!isspace(input_str[i])) {
      num_special++;
    }
  }

  // Calculate paranoid score based on number of characters and type of characters
  paranoid_score = length * 2;
  paranoid_score += num_upper * 5;
  paranoid_score += num_lower * 3;
  paranoid_score += num_digits * 4;
  paranoid_score += num_special * 6;

  // Print out paranoid score and output string
  printf("Paranoid Score: %d\n", paranoid_score);
  printf("Output String: %s\n", output_str);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *islower)(int C);
// extern int (__cdecl *isspace)(int C);
// extern int (__cdecl *isupper)(int C);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Destination[64]; // [rsp+20h] [rbp-90h] BYREF
  char Buffer[52]; // [rsp+60h] [rbp-50h] BYREF
  unsigned int v7; // [rsp+94h] [rbp-1Ch]
  int v8; // [rsp+98h] [rbp-18h]
  int i; // [rsp+9Ch] [rbp-14h]
  int v10; // [rsp+A0h] [rbp-10h]
  int v11; // [rsp+A4h] [rbp-Ch]
  int v12; // [rsp+A8h] [rbp-8h]
  int v13; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v7 = 0;
  printf("Enter a string (max length %d): ", 50i64);
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 51, v3);
  v8 = strlen(Buffer);
  strcpy(Destination, Buffer);
  for ( i = 0; i < v8; ++i )
  {
    if ( isupper(Buffer[i]) )
    {
      ++v13;
    }
    else if ( islower(Buffer[i]) )
    {
      ++v12;
    }
    else if ( (unsigned int)(Buffer[i] - 48) > 9 )
    {
      if ( !isspace(Buffer[i]) )
        ++v10;
    }
    else
    {
      ++v11;
    }
  }
  v7 = 6 * v10 + 4 * v11 + 3 * v12 + 5 * v13 + 2 * v8;
  printf("Paranoid Score: %d\n", v7);
  printf("Output String: %s\n", Destination);
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[52];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/* Circuit components */

typedef struct Resistor {
    double value;
} Resistor;

typedef struct Capacitor {
    double value;
    double voltage;
} Capacitor;

typedef struct Inductor {
    double value;
    double current;
} Inductor;

typedef struct VoltageSource {
    double value;
} VoltageSource;

/* Circuit simulation function */

void simulate_circuit(Resistor* R, Capacitor* C, Inductor* L, VoltageSource* V, double t, double dt) {
    double time = 0.0;
    double v_out = 0.0;
    double i_cap = 0.0;
    double i_ind = 0.0;
    double i_res = 0.0;
    double v_cap = 0.0;
    double v_ind = 0.0;
    double v_res = 0.0;
    
    /* Start simulation loop */
    while (time <= t) {
        /* Calculate current through capacitor */
        i_cap = C->value * (v_out - C->voltage) / dt;
        /* Calculate current through inductor */
        i_ind = (V->value - v_out - L->current * L->value) / dt;
        /* Calculate current through resistor */
        i_res = (v_out - v_cap - v_ind) / R->value;
        /* Update capacitor voltage */
        v_cap += i_cap / C->value * dt;
        /* Update inductor current */
        L->current += i_ind * dt / L->value;
        /* Update resistor voltage */
        v_res = i_res * R->value;
        /* Calculate output voltage */
        v_out = v_cap + v_ind + v_res;
        /* Update time */
        time += dt;
        /* Print results */
        printf("Time: %.2f s, Voltage: %.2f V\n", time, v_out);
    }
}

/* Example circuit */

int main() {
    /* Create components */
    Resistor r = { 10.0 };
    Capacitor c = { 1e-6, 0.0 };
    Inductor l = { 1e-3, 0.0 };
    VoltageSource v = { 5.0 };
    /* Simulate circuit */
    simulate_circuit(&r, &c, &l, &v, 0.1, 0.001);
    /* Exit program */
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall simulate_circuit(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001742) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+38h] [rbp-38h] BYREF
  __int64 v5[2]; // [rsp+40h] [rbp-30h] BYREF
  __int64 v6[3]; // [rsp+50h] [rbp-20h] BYREF
  __int64 v7; // [rsp+68h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v7 = 0x4024000000000000i64;
  v6[0] = 0x3EB0C6F7A0B5ED8Di64;
  v6[1] = 0i64;
  v5[0] = 0x3F50624DD2F1A9FCi64;
  v5[1] = 0i64;
  v4 = 0x4014000000000000i64;
  simulate_circuit(
    (unsigned int)&v7,
    (unsigned int)v6,
    (unsigned int)v5,
    (unsigned int)&v4,
    0x3FB999999999999Ai64,
    0x3F50624DD2F1A9FCi64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall simulate_circuit(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Appointment Scheduler ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure to hold appointment details
struct Appointment {
    char name[50];
    char date[20];
    char time[20];
};

// Function to add new appointment
void addAppointment(struct Appointment *appointments, int *count) {
    struct Appointment appointment;
    printf("Enter name: ");
    scanf("%s", appointment.name);
    printf("Enter date: ");
    scanf("%s", appointment.date);
    printf("Enter time: ");
    scanf("%s", appointment.time);
    appointments[*count] = appointment;
    (*count)++;
    printf("\nAppointment added successfully!\n\n");
}

// Function to display all appointments
void displayAppointments(struct Appointment *appointments, int count) {
    if(count == 0) {
        printf("\nNo appointments found!\n\n");
        return;
    }
    printf("%-20s%-20s%s\n", "Name", "Date", "Time");
    for(int i=0; i<count; i++) {
        printf("%-20s%-20s%s\n", appointments[i].name, appointments[i].date, appointments[i].time);
    }
    printf("\n");
}

int main() {
    struct Appointment appointments[50];
    int count = 0;
    int choice = 0;
    while(choice != 3) {
        printf("1. Add Appointment\n");
        printf("2. Display Appointments\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch(choice) {
            case 1: addAppointment(appointments, &count); break;
            case 2: displayAppointments(appointments, count); break;
            case 3: printf("\nExiting...\n"); break;
            default: printf("\nInvalid choice, please try again!\n\n"); break;
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addAppointment(_QWORD, _QWORD); // weak
__int64 __fastcall displayAppointments(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017D8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[4512]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  v4 = 0;
  while ( v4 != 3 )
  {
    printf("1. Add Appointment\n");
    printf("2. Display Appointments\n");
    printf("3. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    if ( v4 == 3 )
    {
      printf("\nExiting...\n");
    }
    else
    {
      if ( v4 > 3 )
        goto LABEL_10;
      if ( v4 == 1 )
      {
        addAppointment(v6, &v5);
      }
      else if ( v4 == 2 )
      {
        displayAppointments(v6, v5);
      }
      else
      {
LABEL_10:
        printf("\nInvalid choice, please try again!\n\n");
      }
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall addAppointment(_QWORD, _QWORD);
// 14000170D: using guessed type __int64 __fastcall displayAppointments(_QWORD, _QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Task Scheduler ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct task_s {
    char name[20];
    int priority;
    time_t start_time;
    int duration;
} task_t;

typedef struct node_s {
    task_t *task;
    struct node_s *next;
} node_t;

typedef struct schedule_s {
    node_t *head;
    int count;
} schedule_t;

node_t *create_node(task_t *task) {
    node_t *node = malloc(sizeof(node_t));
    node->task = task;
    node->next = NULL;
    return node;
}

void add_task(schedule_t *schedule, task_t *task) {
    node_t *node = create_node(task);
    if (schedule->head == NULL) {
        schedule->head = node;
    } else {
        node_t *current = schedule->head;
        if (task->priority < current->task->priority) {
            node->next = current;
            schedule->head = node;
        } else {
            while (current->next != NULL
                   && task->priority >= current->next->task->priority) {
                current = current->next;
            }
            node->next = current->next;
            current->next = node;
        }
    }
    schedule->count++;
}

void print_schedule(schedule_t *schedule) {
    printf("\n------ Task Schedule ------\n");
    node_t *current = schedule->head;
    while (current != NULL) {
        printf("Name: %s\n", current->task->name);
        printf("Priority: %d\n", current->task->priority);
        printf("Start Time: %ld\n", current->task->start_time);
        printf("Duration: %d\n\n", current->task->duration);
        current = current->next;
    }
}

void delete_schedule(schedule_t *schedule) {
    node_t *current = schedule->head;
    while (current != NULL) {
        node_t *next = current->next;
        free(current->task);
        free(current);
        current = next;
    }
    free(schedule);
}

int main() {
    srand(time(NULL));
    schedule_t *schedule = malloc(sizeof(schedule_t));
    schedule->head = NULL;
    schedule->count = 0;

    for (int i = 0; i < 5; i++) {
        task_t *task = malloc(sizeof(task_t));
        sprintf(task->name, "Task %d", i+1);
        task->priority = rand()%10;
        task->start_time = time(NULL) + rand()%60*60;
        task->duration = rand()%60;
        add_task(schedule, task);
    }

    print_schedule(schedule);
    delete_schedule(schedule);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sprintf(char *const Buffer, const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall add_task(_QWORD, _QWORD); // weak
__int64 __fastcall print_schedule(_QWORD); // weak
__int64 __fastcall delete_schedule(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// void *__cdecl malloc(size_t Size);


//----- (0000000140001817) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  time_t v4; // rbx
  char *Buffer; // [rsp+28h] [rbp-18h]
  _DWORD *v7; // [rsp+30h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v7 = malloc(0x10ui64);
  *(_QWORD *)v7 = 0i64;
  v7[2] = 0;
  for ( i = 0; i <= 4; ++i )
  {
    Buffer = (char *)malloc(0x28ui64);
    sprintf(Buffer, "Task %d", (unsigned int)(i + 1));
    *((_DWORD *)Buffer + 5) = rand() % 10;
    v4 = time(0i64);
    *((_QWORD *)Buffer + 3) = v4 + 60 * (rand() % 60);
    *((_DWORD *)Buffer + 8) = rand() % 60;
    add_task(v7, Buffer);
  }
  print_schedule(v7);
  delete_schedule(v7);
  return 0;
}
// 14000162E: using guessed type __int64 __fastcall add_task(_QWORD, _QWORD);
// 140001709: using guessed type __int64 __fastcall print_schedule(_QWORD);
// 1400017B8: using guessed type __int64 __fastcall delete_schedule(_QWORD);
// 140001A30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Alien Invasion Probability Calculator ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int invasion_probability = 0;
    
    srand(time(NULL));
    
    // Determine the invasion probability
    for (int i = 0; i < 10; i++) {
        int alien_ships = (rand() % 100) + 1; // Generate random number between 1 to 100
        
        // If number is between 1 to 25, assign invasion_probability as high
        if (alien_ships >= 1 && alien_ships <= 25) {
            invasion_probability = invasion_probability + 30;
        }
        
        // If number is between 26 to 75, assign invasion_probability as medium
        else if (alien_ships >= 26 && alien_ships <= 75) {
            invasion_probability = invasion_probability + 20;
        }
        
        // If number is between 76 to 100, assign invasion_probability as low
        else if (alien_ships >= 76 && alien_ships <= 100) {
            invasion_probability = invasion_probability + 10;
        }
    }
    
    printf("Alien invasion probability: %d%%\n", invasion_probability);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-Ch]
  int i; // [rsp+28h] [rbp-8h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 0;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 9; ++i )
  {
    v5 = rand() % 100 + 1;
    if ( v5 <= 0 || v5 > 25 )
    {
      if ( v5 <= 25 || v5 > 75 )
      {
        if ( v5 > 75 && v5 <= 100 )
          v7 += 10;
      }
      else
      {
        v7 += 20;
      }
    }
    else
    {
      v7 += 30;
    }
  }
  printf("Alien invasion probability: %d%%\n", v7);
  return 0;
}
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *ptr1, *ptr2, *ptr3, *ptr4; //pointer declaration

    //Allocating memory using malloc
    ptr1 = (int *)malloc(5 * sizeof(int));
    ptr2 = (int *)malloc(10 * sizeof(int));
    ptr3 = (int *)malloc(15 * sizeof(int));

    //Checking for malloc error
    if (ptr1 == NULL || ptr2 == NULL || ptr3 == NULL) {
        printf("Memory Allocation Error!\n");
        return -1;
    }

    //Printing the allocated memory addresses
    printf("Memory Addresses Allocated:\n");
    printf("ptr1: %p\n", ptr1);
    printf("ptr2: %p\n", ptr2);
    printf("ptr3: %p\n", ptr3);

    //Freeing up allocated memory using free
    free(ptr1);

    //Allocating memory using calloc
    ptr4 = (int *)calloc(20, sizeof(int));

    //Checking for calloc error
    if (ptr4 == NULL) {
        printf("Memory Allocation Error!\n");
        return -1;
    }

    //Printing the allocated memory address
    printf("ptr4: %p\n", ptr4);

    //Reallocating memory using realloc
    ptr2 = (int *)realloc(ptr2, 20 * sizeof(int));

    //Checking for realloc error
    if (ptr2 == NULL) {
        printf("Memory Allocation Error!\n");
        return -1;
    }

    //Printing the reallocated memory address
    printf("ptr2: %p\n", ptr2);

    //Freeing up the rest of the allocated memory
    free(ptr2);
    free(ptr3);
    free(ptr4);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void *__cdecl calloc(size_t Count, size_t Size);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v4; // [rsp+20h] [rbp-20h]
  void *v5; // [rsp+28h] [rbp-18h]
  void *v6; // [rsp+30h] [rbp-10h]
  void *v7; // [rsp+30h] [rbp-10h]
  void *Block; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  Block = malloc(0x14ui64);
  v6 = malloc(0x28ui64);
  v5 = malloc(0x3Cui64);
  if ( !Block )
    goto LABEL_7;
  if ( !v6 )
    goto LABEL_7;
  if ( !v5 )
    goto LABEL_7;
  printf("Memory Addresses Allocated:\n");
  printf("ptr1: %p\n", Block);
  printf("ptr2: %p\n", v6);
  printf("ptr3: %p\n", v5);
  free(Block);
  v4 = calloc(0x14ui64, 4ui64);
  if ( !v4 )
    goto LABEL_7;
  printf("ptr4: %p\n", v4);
  v7 = realloc(v6, 0x50ui64);
  if ( v7 )
  {
    printf("ptr2: %p\n", v7);
    free(v7);
    free(v5);
    free(v4);
    return 0;
  }
  else
  {
LABEL_7:
    printf("Memory Allocation Error!\n");
    return -1;
  }
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Website Uptime Monitor ; Style: recursive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

void wait(int seconds) {
    clock_t endwait;
    endwait = clock() + seconds * CLOCKS_PER_SEC;
    while (clock() < endwait) {}
}

int checkWebsite(char* url) {
    int response = system(url);
    if (response) {
        printf("%s is down.\n", url);
        return 0;
    } else {
        printf("%s is up!\n", url);
        return 1;
    }
}

void monitorWebsite(char* url, int interval) {
    int status = checkWebsite(url);
    wait(interval);
    if (!status) {
        monitorWebsite(url, interval);
    }
}

int main() {
    char url[100];
    int interval;

    printf("Enter website URL: ");
    scanf("%s", url);

    printf("Enter interval (in seconds): ");
    scanf("%d", &interval);

    monitorWebsite(url, interval);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall monitorWebsite(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016AB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-74h] BYREF
  char v5[112]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter website URL: ");
  scanf("%s", v5);
  printf("Enter interval (in seconds): ");
  scanf("%d", &v4);
  monitorWebsite(v5, v4);
  return 0;
}
// 14000166B: using guessed type __int64 __fastcall monitorWebsite(_QWORD, _QWORD);
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital signal processing ; Style: grateful
#include <stdio.h>
#include <stdlib.h>

#define INPUT_FILE "input.txt"
#define OUTPUT_FILE "output.txt"

int main() {
    // Open the input file for reading
    FILE *input_file = fopen(INPUT_FILE, "r");
    if (!input_file) {
        printf("Error: Failed to open input file.\n");
        return 1;
    }

    // Open the output file for writing
    FILE *output_file = fopen(OUTPUT_FILE, "w");
    if (!output_file) {
        printf("Error: Failed to open output file.\n");
        return 1;
    }

    // Initialize filter coefficients
    float b[] = {0.25, 0.5, 0.25};

    // Initialize buffer for storing input samples
    float input[3] = {0};

    // Read input samples from file and filter them
    float sample;
    while (fscanf(input_file, "%f", &sample) == 1) {
        // Shift input samples in buffer
        input[2] = input[1];
        input[1] = input[0];
        input[0] = sample;

        // Calculate output sample using filter coefficients
        float output = b[0]*input[0] + b[1]*input[1] + b[2]*input[2];

        // Write output sample to file
        fprintf(output_file, "%.2f\n", output);
    }

    // Close the input and output files
    fclose(input_file);
    fclose(output_file);

    printf("LPF applied successfully to input samples from '%s' and output written to '%s'\n", INPUT_FILE, OUTPUT_FILE);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001617) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+20h] [rbp-30h] BYREF
  char v5[12]; // [rsp+24h] [rbp-2Ch] BYREF
  float v6; // [rsp+30h] [rbp-20h]
  float v7; // [rsp+34h] [rbp-1Ch]
  float v8; // [rsp+38h] [rbp-18h]
  float v9; // [rsp+3Ch] [rbp-14h]
  FILE *Stream; // [rsp+40h] [rbp-10h]
  FILE *v11; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  v11 = fopen("input.txt", "r");
  if ( v11 )
  {
    Stream = fopen("output.txt", "w");
    if ( Stream )
    {
      v6 = 0.25;
      v7 = 0.5;
      v8 = 0.25;
      memset(v5, 0, sizeof(v5));
      while ( fscanf(v11, "%f", &v4) == 1 )
      {
        *(_QWORD *)&v5[4] = *(_QWORD *)v5;
        *(float *)v5 = v4;
        v9 = (float)(*(float *)&v5[8] * v8) + (float)((float)(v6 * v4) + (float)(*(float *)&v5[4] * v7));
        fprintf_0(Stream, "%.2f\n", v9);
      }
      fclose(v11);
      fclose(Stream);
      printf(
        "LPF applied successfully to input samples from '%s' and output written to '%s'\n",
        "input.txt",
        "output.txt");
      return 0;
    }
    else
    {
      printf("Error: Failed to open output file.\n");
      return 1;
    }
  }
  else
  {
    printf("Error: Failed to open input file.\n");
    return 1;
  }
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: immersive
#include <stdio.h>

// Function to calculate Body Mass Index (BMI)
float calculateBMI(float height, float weight) {
    float bmi = weight / (height * height);
    return bmi;
}

// Function to calculate daily calories requirement based on activity level
float calculateDailyCalorieRequirement(float bmr, int activityLevel) {
    float dailyCalorieRequirement;
    switch(activityLevel) {
        case 1:
            dailyCalorieRequirement = bmr * 1.2;
            break;
        case 2:
            dailyCalorieRequirement = bmr * 1.375;
            break;
        case 3:
            dailyCalorieRequirement = bmr * 1.55;
            break;
        case 4:
            dailyCalorieRequirement = bmr * 1.725;
            break;
        case 5:
            dailyCalorieRequirement = bmr * 1.9;
            break;
        default:
            printf("Please enter a valid activity level\n");
            dailyCalorieRequirement = -1;
            break;
    }
    return dailyCalorieRequirement;
}

int main() {
    float height, weight, bmi, bmr, dailyCalorieRequirement;
    int age, gender, activityLevel;

    printf("Welcome to your Fitness Tracker!\n\n");
    printf("Please enter your height in meters: ");
    scanf("%f", &height);

    printf("\nPlease enter your weight in kilograms: ");
    scanf("%f", &weight);

    printf("\nPlease enter your age in years: ");
    scanf("%d", &age);

    printf("\nPlease enter your gender (1 for male, 2 for female): ");
    scanf("%d", &gender);

    printf("\nPlease enter your activity level (1 for sedentary, 2 for light exercise, 3 for moderate exercise, 4 for heavy exercise, 5 for very heavy exercise): ");
    scanf("%d", &activityLevel);

    // Calculate BMI
    bmi = calculateBMI(height, weight);
    printf("\nYour BMI is: %.2f\n", bmi);

    // Calculate Basal Metabolic Rate (BMR)
    if(gender == 1) {
        bmr = 88.362 + (13.397 * weight) + (4.799 * height * 100) - (5.677 * age);
    }
    else if(gender == 2) {
        bmr = 447.593 + (9.247 * weight) + (3.098 * height * 100) - (4.33 * age);
    }
    else {
        printf("Please enter a valid gender number\n");
        return 0;
    }

    printf("Your BMR is: %.2f\n", bmr);

    // Calculate Daily Calorie Requirement
    dailyCalorieRequirement = calculateDailyCalorieRequirement(bmr, activityLevel);

    if(dailyCalorieRequirement != -1) {
        printf("Your daily calorie requirement is: %.2f calories\n", dailyCalorieRequirement);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
double calculateBMI(void); // weak
double __fastcall calculateDailyCalorieRequirement(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001719) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  float v4; // xmm0_4
  float v5; // xmm0_4
  __m128i v7; // xmm0
  __int64 v8; // rcx
  unsigned int v9; // [rsp+20h] [rbp-20h] BYREF
  int v10; // [rsp+24h] [rbp-1Ch] BYREF
  int v11; // [rsp+28h] [rbp-18h] BYREF
  float v12; // [rsp+2Ch] [rbp-14h] BYREF
  float v13; // [rsp+30h] [rbp-10h] BYREF
  float v14; // [rsp+34h] [rbp-Ch]
  float v15; // [rsp+38h] [rbp-8h]
  float v16; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to your Fitness Tracker!\n\n");
  printf("Please enter your height in meters: ");
  scanf("%f", &v13);
  printf("\nPlease enter your weight in kilograms: ");
  scanf("%f", &v12);
  printf("\nPlease enter your age in years: ");
  scanf("%d", &v11);
  printf("\nPlease enter your gender (1 for male, 2 for female): ");
  scanf("%d", &v10);
  printf(
    "\n"
    "Please enter your activity level (1 for sedentary, 2 for light exercise, 3 for moderate exercise, 4 for heavy exerci"
    "se, 5 for very heavy exercise): ");
  scanf("%d", &v9);
  v3 = _mm_cvtsi32_si128(LODWORD(v13));
  *(double *)v3.m128i_i64 = calculateBMI();
  v15 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
  printf("\nYour BMI is: %.2f\n", v15);
  if ( v10 == 1 )
  {
    v4 = 100.0 * (v13 * 4.799) + v12 * 13.397 + 88.36199999999999 - 5.677 * (double)v11;
    v16 = v4;
  }
  else
  {
    if ( v10 != 2 )
    {
      printf("Please enter a valid gender number\n");
      return 0;
    }
    v5 = 100.0 * (v13 * 3.098) + v12 * 9.247 + 447.593 - 4.33 * (double)v11;
    v16 = v5;
  }
  printf("Your BMR is: %.2f\n", v16);
  v7 = _mm_cvtsi32_si128(LODWORD(v16));
  *(double *)v7.m128i_i64 = calculateDailyCalorieRequirement(v8, v9);
  v14 = COERCE_FLOAT(_mm_cvtsi128_si32(v7));
  if ( v14 != -1.0 )
    printf("Your daily calorie requirement is: %.2f calories\n", v14);
  return 0;
}
// 14000197F: variable 'v8' is possibly undefined
// 1400015E2: using guessed type double calculateBMI(void);
// 140001619: using guessed type double __fastcall calculateDailyCalorieRequirement(_QWORD, _QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: calm
#include<stdio.h>
#include<stdlib.h>

#define ARR_SIZE 100 // size of integer array

int main()
{
    // allocate memory for integer and character arrays
    int* intArr = (int*)malloc(sizeof(int) * ARR_SIZE);
    char* charArr = (char*)calloc(ARR_SIZE, sizeof(char));

    // check if memory allocation successful
    if (intArr == NULL || charArr == NULL) {
        printf("Memory allocation failed!\n");
        exit(1);
    }

    // assign values to integer array
    for (int i = 0; i < ARR_SIZE; i++) {
        intArr[i] = i + 1;
    }

    // print integer array
    printf("Printing integer array:\n");
    for (int i = 0; i < ARR_SIZE; i++) {
        printf("%d ", intArr[i]);
    }
    printf("\n\n");

    // assign values to character array
    for (int i = 0; i < ARR_SIZE; i++) {
        charArr[i] = 'a' + i;
    }

    // print character array
    printf("Printing character array:\n");
    for (int i = 0; i < ARR_SIZE; i++) {
        printf("%c ", charArr[i]);
    }
    printf("\n\n");

    // reallocate memory for integer array
    intArr = (int*)realloc(intArr, sizeof(int) * (ARR_SIZE + 50));

    // check if memory reallocation successful
    if (intArr == NULL) {
        printf("Memory reallocation failed!\n");
        exit(1);
    }

    // assign new values to integer array
    for (int i = ARR_SIZE; i < ARR_SIZE + 50; i++) {
        intArr[i] = i + 1;
    }

    // print updated integer array
    printf("Printing updated integer array:\n");
    for (int i = 0; i < ARR_SIZE + 50; i++) {
        printf("%d ", intArr[i]);
    }
    printf("\n\n");

    // free allocated memory
    free(intArr);
    free(charArr);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void __cdecl __noreturn exit(int Code);
// void *__cdecl calloc(size_t Count, size_t Size);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _BYTE *v4; // [rsp+28h] [rbp-28h]
  _DWORD *Block; // [rsp+30h] [rbp-20h]
  _DWORD *Blocka; // [rsp+30h] [rbp-20h]
  int ii; // [rsp+38h] [rbp-18h]
  int n; // [rsp+3Ch] [rbp-14h]
  int m; // [rsp+40h] [rbp-10h]
  int k; // [rsp+44h] [rbp-Ch]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  Block = malloc(0x190ui64);
  v4 = calloc(0x64ui64, 1ui64);
  if ( !Block || !v4 )
  {
    printf("Memory allocation failed!\n");
    exit(1);
  }
  for ( i = 0; i <= 99; ++i )
    Block[i] = i + 1;
  printf("Printing integer array:\n");
  for ( j = 0; j <= 99; ++j )
    printf("%d ", (unsigned int)Block[j]);
  printf("\n\n");
  for ( k = 0; k <= 99; ++k )
    v4[k] = k + 97;
  printf("Printing character array:\n");
  for ( m = 0; m <= 99; ++m )
    printf("%c ", (unsigned int)(char)v4[m]);
  printf("\n\n");
  Blocka = realloc(Block, 0x258ui64);
  if ( !Blocka )
  {
    printf("Memory reallocation failed!\n");
    exit(1);
  }
  for ( n = 100; n <= 149; ++n )
    Blocka[n] = n + 1;
  printf("Printing updated integer array:\n");
  for ( ii = 0; ii <= 149; ++ii )
    printf("%d ", (unsigned int)Blocka[ii]);
  printf("\n\n");
  free(Blocka);
  free(v4);
  return 0;
}
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Log analysis ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    printf("\n\n ********** Cyberpunk Style C Log Analysis ********** \n\n");

    FILE *log_file;
    char log_line[100];
    char *log_file_name = "cyber.log";
    int line_count = 0;
    int error_count = 0;
    char error_message[100];

    log_file = fopen(log_file_name, "r");

    if (log_file == NULL) {
        printf("Error opening log file\n");
        exit(0);
    }

    printf("Analyzing log file...\n\n");

    while (fgets(log_line, 100, log_file)) {
        line_count++;

        if (strstr(log_line, "ERROR") != NULL) {
            error_count++;
            strcpy(error_message, log_line);
            printf("ALERT: Error detected on line %d - %s", line_count, error_message);
        }
    }

    if (error_count == 0) {
        printf("No errors detected in log file\n");
    }

    printf("\n\n ********** End of Log Analysis **********\n\n");
    fclose(log_file);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// char *__cdecl strcpy(char *Destination, const char *Source);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Destination[112]; // [rsp+20h] [rbp-60h] BYREF
  char Str[104]; // [rsp+90h] [rbp+10h] BYREF
  FILE *Stream; // [rsp+F8h] [rbp+78h]
  char *FileName; // [rsp+100h] [rbp+80h]
  int v8; // [rsp+108h] [rbp+88h]
  unsigned int v9; // [rsp+10Ch] [rbp+8Ch]

  _main(argc, argv, envp);
  printf("\n\n ********** Cyberpunk Style C Log Analysis ********** \n\n");
  FileName = "cyber.log";
  v9 = 0;
  v8 = 0;
  Stream = fopen("cyber.log", "r");
  if ( !Stream )
  {
    printf("Error opening log file\n");
    exit(0);
  }
  printf("Analyzing log file...\n\n");
  while ( fgets(Str, 100, Stream) )
  {
    ++v9;
    if ( strstr(Str, "ERROR") )
    {
      ++v8;
      strcpy(Destination, Str);
      printf("ALERT: Error detected on line %d - %s", v9, Destination);
    }
  }
  if ( !v8 )
    printf("No errors detected in log file\n");
  printf("\n\n ********** End of Log Analysis **********\n\n");
  fclose(Stream);
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text-Based Adventure Game ; Style: synchronous
#include <stdio.h>
#include <string.h>

// function for getting user input and checking for valid input
void getUserInput(char input[], int inputSize, char validOptions[]) {
    int valid = 0;
    while (!valid) {
        printf(" > ");
        fgets(input, inputSize, stdin);
        input[strcspn(input, "\n")] = 0; // remove '\n' character from input
        for (int i = 0; i < strlen(validOptions); i++) {
            if (*input == validOptions[i]) {
                valid = 1;
            }
        }
        if (!valid) {
            printf("Invalid input. Please choose one of the following options: %s\n", validOptions);
        }
    }
}

// function for handling the player's next move
void movePlayer(char playerPosition[], char input[]) {
    if (strcmp(input, "n") == 0) {
        strcpy(playerPosition, "north");
    } else if (strcmp(input, "s") == 0) {
        strcpy(playerPosition, "south");
    } else if (strcmp(input, "e") == 0) {
        strcpy(playerPosition, "east");
    } else if (strcmp(input, "w") == 0) {
        strcpy(playerPosition, "west");
    }
}

int main() {

    // game variables
    char playerPosition[6] = "start";
    char input[11];
    int foundTreasure = 0;
    int monsterDefeated = 0;

    // game introduction
    printf("Welcome to Text-Based Adventure Game!\n");
    printf("Your goal is to explore the dungeon, defeat the monster, and find the treasure.\n");
    printf("You are currently at the start of the dungeon.\n");

    while (!foundTreasure && !monsterDefeated) {
        // display current room information and options for next move
        if (strcmp(playerPosition, "start") == 0) {
            printf("\nYou are at the entrance of the dungeon.\n");
            printf("You can go north (n) to enter the dungeon or south (s) to exit.\n");
            getUserInput(input, 11, "ns");
            movePlayer(playerPosition, input);
        } else if (strcmp(playerPosition, "north") == 0) {
            printf("\nYou have entered the dungeon.\n");
            printf("You can go north (n), east (e), or west (w).\n");
            getUserInput(input, 11, "new");
            movePlayer(playerPosition, input);
        } else if (strcmp(playerPosition, "south") == 0) {
            printf("\nYou have exited the dungeon.\n");
            printf("Game over.\n");
            return 0;
        } else if (strcmp(playerPosition, "east") == 0) {
            printf("\nYou have encountered a monster!\n");
            printf("You can fight the monster (f) or run away (r).\n");
            getUserInput(input, 11, "fr");
            if (strcmp(input, "f") == 0) {
                printf("You have defeated the monster and gained access to the treasure room!\n");
                monsterDefeated = 1;
            } else if (strcmp(input, "r") == 0) {
                printf("You have successfully run away from the monster.\n");
                strcpy(playerPosition, "north");
            }
        } else if (strcmp(playerPosition, "west") == 0) {
            printf("\nYou have found a treasure!\n");
            printf("Congratulations, you have won the game!\n");
            foundTreasure = 1;
        }
    }

    return 0;

}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall getUserInput(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall movePlayer(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (000000014000172B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[11]; // [rsp+27h] [rbp-19h] BYREF
  char Str1[6]; // [rsp+32h] [rbp-Eh] BYREF
  int v6; // [rsp+38h] [rbp-8h]
  int v7; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  strcpy(Str1, "start");
  v7 = 0;
  v6 = 0;
  printf("Welcome to Text-Based Adventure Game!\n");
  printf("Your goal is to explore the dungeon, defeat the monster, and find the treasure.\n");
  printf("You are currently at the start of the dungeon.\n");
  while ( !v7 && !v6 )
  {
    if ( !strcmp(Str1, "start") )
    {
      printf("\nYou are at the entrance of the dungeon.\n");
      printf("You can go north (n) to enter the dungeon or south (s) to exit.\n");
      getUserInput(v4, 11i64, "ns");
      movePlayer(Str1, v4);
    }
    else if ( !strcmp(Str1, "north") )
    {
      printf("\nYou have entered the dungeon.\n");
      printf("You can go north (n), east (e), or west (w).\n");
      getUserInput(v4, 11i64, "new");
      movePlayer(Str1, v4);
    }
    else
    {
      if ( !strcmp(Str1, "south") )
      {
        printf("\nYou have exited the dungeon.\n");
        printf("Game over.\n");
        return 0;
      }
      if ( !strcmp(Str1, "east") )
      {
        printf("\nYou have encountered a monster!\n");
        printf("You can fight the monster (f) or run away (r).\n");
        getUserInput(v4, 11i64, "fr");
        if ( !strcmp(v4, "f") )
        {
          printf("You have defeated the monster and gained access to the treasure room!\n");
          v6 = 1;
        }
        else if ( !strcmp(v4, "r") )
        {
          printf("You have successfully run away from the monster.\n");
          strcpy(Str1, "north");
        }
      }
      else if ( !strcmp(Str1, "west") )
      {
        printf("\nYou have found a treasure!\n");
        printf("Congratulations, you have won the game!\n");
        v7 = 1;
      }
    }
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall getUserInput(_QWORD, _QWORD, _QWORD);
// 140001676: using guessed type __int64 __fastcall movePlayer(_QWORD, _QWORD);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Music Library Management System ; Style: calm
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

struct nodes {
    char title[50];
    char artist[50];
};

void printMenu();
int searchSong(struct nodes *list, char *searchTitle, int total);
void deleteSong(struct nodes *list, char *searchTitle, int *total);
void displayList(struct nodes *list, int total);

int main()
{
    struct nodes myMusicList[100]; 
    int choice, totalSongs=0;
    char searchTitle[50], deleteTitle[50];

    printf("Welcome to the Music Library Management System :)\n\n");

    do {
        printMenu();
        scanf("%d", &choice);
        getchar(); 

        switch(choice) {
            case 1: ; //Adding a song
                printf("\nEnter the title of the song: ");
                fgets(myMusicList[totalSongs].title,sizeof(myMusicList[totalSongs].title),stdin);

                printf("Enter the name of the artist: ");
                fgets(myMusicList[totalSongs].artist,sizeof(myMusicList[totalSongs].artist),stdin);

                printf("\n'%s' by %s has been added to the music library!\n\n", myMusicList[totalSongs].title, myMusicList[totalSongs].artist);
                totalSongs++;
                break;

            case 2: ; //Searching for a song
                printf("\nEnter the title of the song: ");
                fgets(searchTitle,sizeof(searchTitle),stdin);
                int result=searchSong(myMusicList, searchTitle, totalSongs);

                if(result==-1) {
                    printf("\nSorry, '%s' was not found in the music library.\n\n", searchTitle);
                } else {
                    printf("\n'%s' by %s was found in the music library.\n\n", myMusicList[result].title, myMusicList[result].artist);
                }
                break;

            case 3: ; //Deleting a song
                printf("\nEnter the title of the song you want to delete: ");
                fgets(deleteTitle,sizeof(deleteTitle),stdin);
                deleteSong(myMusicList, deleteTitle, &totalSongs);
                break;

            case 4: ; //Displaying the song list
                displayList(myMusicList, totalSongs);
                break;

            case 5: ; //Exiting the program
                printf("\nThank you for using the Music Library Management System :)\n\n");
                exit(0);
                break;

            default:
                printf("\nInvalid choice, please try again.\n\n");
                break;
        }
    } while(1);

    return 0;
}

void printMenu() {
    printf("1. Add a song\n");
    printf("2. Search for a song\n");
    printf("3. Delete a song\n");
    printf("4. Display the music list\n");
    printf("5. Exit the program\n");
    printf("\nEnter your choice: ");
}

int searchSong(struct nodes *list, char *searchTitle, int total) {
    for(int i=0; i<total; i++) {
        if(strncmp(list[i].title,searchTitle,strlen(searchTitle)-1)==0) {
            return i;
        }
    }
    return -1;
}

void deleteSong(struct nodes *list, char *searchTitle, int *total) {
    int index=searchSong(list,searchTitle,*total);

    if(index==-1) {
        printf("\nSorry, '%s' was not found in the music library.\n\n", searchTitle);
    } else {
        printf("\n'%s' by %s has been deleted from the music library.\n\n", list[index].title, list[index].artist);
        for(int i=index; i<*total; i++) {
            list[i]=list[i+1];
        }
        (*total)--;
    }
}

void displayList(struct nodes *list, int total) {
    printf("\n---Music Library---\n\n");
    for(int i=0; i<total; i++) {
        printf("%d. '%s' by %s\n", i+1, list[i].title, list[i].artist);
    }
    printf("\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 printMenu(void); // weak
__int64 __fastcall searchSong(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall deleteSong(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall displayList(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  FILE *v6; // rax
  char v8[64]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[56]; // [rsp+60h] [rbp-20h] BYREF
  unsigned int v10; // [rsp+98h] [rbp+18h] BYREF
  int v11; // [rsp+9Ch] [rbp+1Ch] BYREF
  char v12[10012]; // [rsp+A0h] [rbp+20h] BYREF
  int v13; // [rsp+27BCh] [rbp+273Ch]

  _main(argc, argv, envp);
  v10 = 0;
  printf("Welcome to the Music Library Management System :)\n\n");
  while ( 1 )
  {
    printMenu();
    scanf("%d", &v11);
    getchar();
    switch ( v11 )
    {
      case 1:
        printf("\nEnter the title of the song: ");
        v3 = __acrt_iob_func(0);
        fgets(&v12[100 * v10], 50, v3);
        printf("Enter the name of the artist: ");
        v4 = __acrt_iob_func(0);
        fgets(&v12[100 * v10 + 50], 50, v4);
        printf("\n'%s' by %s has been added to the music library!\n\n", &v12[100 * v10], &v12[100 * v10 + 50]);
        ++v10;
        break;
      case 2:
        printf("\nEnter the title of the song: ");
        v5 = __acrt_iob_func(0);
        fgets(Buffer, 50, v5);
        v13 = searchSong(v12, Buffer, v10);
        if ( v13 == -1 )
          printf("\nSorry, '%s' was not found in the music library.\n\n", Buffer);
        else
          printf("\n'%s' by %s was found in the music library.\n\n", &v12[100 * v13], &v12[100 * v13 + 50]);
        break;
      case 3:
        printf("\nEnter the title of the song you want to delete: ");
        v6 = __acrt_iob_func(0);
        fgets(v8, 50, v6);
        deleteSong(v12, v8, &v10);
        break;
      case 4:
        displayList(v12, v10);
        break;
      case 5:
        printf("\nThank you for using the Music Library Management System :)\n\n");
        exit(0);
      default:
        printf("\nInvalid choice, please try again.\n\n");
        break;
    }
  }
}
// 140001900: using guessed type __int64 printMenu(void);
// 140001969: using guessed type __int64 __fastcall searchSong(_QWORD, _QWORD, _QWORD);
// 1400019F4: using guessed type __int64 __fastcall deleteSong(_QWORD, _QWORD, _QWORD);
// 140001BA1: using guessed type __int64 __fastcall displayList(_QWORD, _QWORD);
// 140001D20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_2720[10012];

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Dice Roller ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to roll dice
int rollDice(int numDice, int sides) {
    int total = 0;
    for (int i = 0; i < numDice; i++) {
        total += (rand() % sides) + 1;
    }
    return total;
}

int main() {
    int numDice, sides, rollCount;
    char input;

    // Seed the random number generator
    srand(time(NULL));

    // Welcome message
    printf("Welcome to the Dice Roller!\n\n");

    do {
        // Prompt the user for input
        printf("How many dice would you like to roll? (1-10): ");
        scanf("%d", &numDice);

        // Validate input
        while (numDice < 1 || numDice > 10) {
            printf("Invalid input, please choose a value between 1 and 10: ");
            scanf("%d", &numDice);
        }

        printf("How many sides should the dice have? (2-100): ");
        scanf("%d", &sides);

        // Validate input
        while (sides < 2 || sides > 100) {
            printf("Invalid input, please choose a value between 2 and 100: ");
            scanf("%d", &sides);
        }

        printf("How many times do you want to roll the dice? (1-100): ");
        scanf("%d", &rollCount);

        // Validate input
        while (rollCount < 1 || rollCount > 100) {
            printf("Invalid input, please choose a value between 1 and 100: ");
            scanf("%d", &rollCount);
        }

        // Roll the dice and print the results
        printf("\nRolling %d %d-sided dice %d times...\n\n", numDice, sides, rollCount);

        for (int i = 0; i < rollCount; i++) {
            printf("Roll %d: %d\n", i+1, rollDice(numDice, sides));
        }

        // Prompt the user to play again
        printf("\nWould you like to roll again? (y/n): ");
        scanf(" %c", &input);

    } while (input == 'y' || input == 'Y');

    // Thank you message
    printf("\nThank you for using the Dice Roller! Have a great day!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall rollDice(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001645) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  char v6; // [rsp+2Fh] [rbp-11h] BYREF
  int v7; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v8; // [rsp+34h] [rbp-Ch] BYREF
  unsigned int v9; // [rsp+38h] [rbp-8h] BYREF
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Dice Roller!\n\n");
  do
  {
    printf("How many dice would you like to roll? (1-10): ");
    scanf("%d", &v9);
    while ( (int)v9 <= 0 || (int)v9 > 10 )
    {
      printf("Invalid input, please choose a value between 1 and 10: ");
      scanf("%d", &v9);
    }
    printf("How many sides should the dice have? (2-100): ");
    scanf("%d", &v8);
    while ( (int)v8 <= 1 || (int)v8 > 100 )
    {
      printf("Invalid input, please choose a value between 2 and 100: ");
      scanf("%d", &v8);
    }
    printf("How many times do you want to roll the dice? (1-100): ");
    scanf("%d", &v7);
    while ( v7 <= 0 || v7 > 100 )
    {
      printf("Invalid input, please choose a value between 1 and 100: ");
      scanf("%d", &v7);
    }
    printf("\nRolling %d %d-sided dice %d times...\n\n", v9, v8, (unsigned int)v7);
    for ( i = 0; i < v7; ++i )
    {
      v4 = rollDice(v9, v8);
      printf("Roll %d: %d\n", (unsigned int)(i + 1), v4);
    }
    printf("\nWould you like to roll again? (y/n): ");
    scanf(" %c", &v6);
  }
  while ( v6 == 121 || v6 == 89 );
  printf("\nThank you for using the Dice Roller! Have a great day!\n");
  return 0;
}
// 140001601: using guessed type __int64 __fastcall rollDice(_QWORD, _QWORD);
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Phone Book ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[50];
    char number[20];
} Contact;

int main() {
    int option;
    int numContacts = 0;
    Contact *phonebook = malloc(sizeof(Contact));
    printf("Hello there! Welcome to the Curious Phone Book.\n");

    do {
        printf("\nWhat would you like to do? Choose an option below:\n");
        printf("1. Add a Contact\n");
        printf("2. Search for a Contact\n");
        printf("3. List all Contacts\n");
        printf("4. Exit\n");

        scanf("%d", &option);

        switch(option) {
            case 1: {
                Contact newContact;
                printf("\nEnter the contact name: ");
                scanf("%s", newContact.name);
                printf("Enter the contact number: ");
                scanf("%s", newContact.number);

                numContacts++;
                phonebook = realloc(phonebook, numContacts * sizeof(Contact));
                phonebook[numContacts - 1] = newContact;

                printf("\nContact added successfully!\n");
                break;
            }
            case 2: {
                char searchName[50];
                int found = 0;

                printf("\nEnter the name of the contact you want to search for: ");
                scanf("%s", searchName);

                for(int i = 0; i < numContacts; i++) {
                    if(strcmp(phonebook[i].name, searchName) == 0) {
                        printf("\n%s's phone number is: %s\n", phonebook[i].name, phonebook[i].number);
                        found = 1;
                        break;
                    }
                }

                if(!found)
                    printf("\nContact not found.\n");

                break;
            }
            case 3: {
                if(numContacts == 0) {
                    printf("\nYour phonebook is currently empty.\n");
                    break;
                }

                printf("\nHere are all your contacts:\n");

                for(int i = 0; i < numContacts; i++) {
                    printf("%s: %s\n", phonebook[i].name, phonebook[i].number);
                }

                break;
            }
            case 4: {
                printf("\nThank you for using Curious Phone Book! Goodbye.\n");
                break;
            }
            default: {
                printf("\nInvalid option. Please try again.\n");
                break;
            }
        }
    } while(option != 4);

    free(phonebook);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rbx
  char Str2[8]; // [rsp+20h] [rbp-70h] BYREF
  __int64 v10; // [rsp+28h] [rbp-68h]
  __int64 v11; // [rsp+30h] [rbp-60h]
  __int64 v12; // [rsp+38h] [rbp-58h]
  __int64 v13; // [rsp+40h] [rbp-50h]
  __int64 v14; // [rsp+48h] [rbp-48h]
  __int64 v15[2]; // [rsp+50h] [rbp-40h] BYREF
  int v16; // [rsp+60h] [rbp-30h]
  __int16 v17; // [rsp+64h] [rbp-2Ch]
  int v18; // [rsp+70h] [rbp-20h] BYREF
  int i; // [rsp+74h] [rbp-1Ch]
  int j; // [rsp+78h] [rbp-18h]
  int v21; // [rsp+7Ch] [rbp-14h]
  void *Block; // [rsp+80h] [rbp-10h]
  int v23; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  v23 = 0;
  Block = malloc(0x46ui64);
  printf("Hello there! Welcome to the Curious Phone Book.\n");
  do
  {
    printf("\nWhat would you like to do? Choose an option below:\n");
    printf("1. Add a Contact\n");
    printf("2. Search for a Contact\n");
    printf("3. List all Contacts\n");
    printf("4. Exit\n");
    scanf("%d", &v18);
    if ( v18 == 4 )
    {
      printf("\nThank you for using Curious Phone Book! Goodbye.\n");
      continue;
    }
    if ( v18 > 4 )
    {
LABEL_23:
      printf("\nInvalid option. Please try again.\n");
      continue;
    }
    switch ( v18 )
    {
      case 3:
        if ( v23 )
        {
          printf("\nHere are all your contacts:\n");
          for ( i = 0; i < v23; ++i )
            printf("%s: %s\n", (const char *)Block + 70 * i, (const char *)Block + 70 * i + 50);
        }
        else
        {
          printf("\nYour phonebook is currently empty.\n");
        }
        break;
      case 1:
        printf("\nEnter the contact name: ");
        scanf("%s", Str2);
        printf("Enter the contact number: ");
        scanf("%s", (char *)v15 + 2);
        Block = realloc(Block, 70i64 * ++v23);
        v3 = (char *)Block + 70 * v23 - 70;
        v4 = v10;
        *(_QWORD *)v3 = *(_QWORD *)Str2;
        *((_QWORD *)v3 + 1) = v4;
        v5 = v12;
        *((_QWORD *)v3 + 2) = v11;
        *((_QWORD *)v3 + 3) = v5;
        v6 = v14;
        *((_QWORD *)v3 + 4) = v13;
        *((_QWORD *)v3 + 5) = v6;
        v7 = v15[1];
        *((_QWORD *)v3 + 6) = v15[0];
        *((_QWORD *)v3 + 7) = v7;
        *((_DWORD *)v3 + 16) = v16;
        *((_WORD *)v3 + 34) = v17;
        printf("\nContact added successfully!\n");
        break;
      case 2:
        v21 = 0;
        printf("\nEnter the name of the contact you want to search for: ");
        scanf("%s", Str2);
        for ( j = 0; j < v23; ++j )
        {
          if ( !strcmp((const char *)Block + 70 * j, Str2) )
          {
            printf("\n%s's phone number is: %s\n", (const char *)Block + 70 * j, (const char *)Block + 70 * j + 50);
            v21 = 1;
            break;
          }
        }
        if ( !v21 )
          printf("\nContact not found.\n");
        break;
      default:
        goto LABEL_23;
    }
  }
  while ( v18 != 4 );
  free(Block);
  return 0;
}
// 14000169E: conditional instruction was optimized away because %var_30.4<3
// 1400019D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text-Based Adventure Game ; Style: invasive
#include <stdio.h>

int main() {
    printf("Welcome to Invasive Adventure!\n");
    printf("You wake up in a dark room with no memory of how you got there.\n");
    printf("As you look around, you see a door in front of you and a window to your right.\n");
    
    char choice1;
    printf("Enter 'd' to open the door or 'w' to look out the window: ");
    scanf("%c", &choice1);
    
    if (choice1 == 'd') {
        printf("You open the door and see a long hallway.\n");
        printf("As you start walking down the hallway, you feel like you are being watched.\n");
        
        char choice2;
        printf("Enter 'f' to keep walking or 'r' to turn back: ");
        scanf(" %c", &choice2);
        
        if (choice2 == 'f') {
            printf("You walk until you reach the end of the hallway.\n");
            printf("There is a locked door in front of you.\n");
            
            char choice3;
            printf("Enter 'u' to try to unlock the door or 'b' to go back: ");
            scanf(" %c", &choice3);
            
            if (choice3 == 'u') {
                printf("You try to unlock the door, but the keyhole is too small for your fingers.\n");
                printf("As you turn around, you see a figure approaching you from the other end of the hallway.\n");
                
                char choice4;
                printf("Enter 'r' to run towards the figure or 'h' to hide in a nearby room: ");
                scanf(" %c", &choice4);
                
                if (choice4 == 'r') {
                    printf("You run towards the figure, but it disappears into thin air.\n");
                    printf("Confused and scared, you turn around and see the hallway has changed.\n");
                    printf("Everything seems to be made of flesh and bone, and the walls are pulsating.\n");
                } else if (choice4 == 'h') {
                    printf("You quickly enter a nearby room and lock the door.\n");
                    printf("It's a small room with a single window, but you can't see anything odd outside.\n");
                    printf("You hear footsteps passing by the door, but they soon fade away.\n");
                } else {
                    printf("Invalid choice. Try again.\n");
                }
            } else if (choice3 == 'b') {
                printf("You turn back, but the hallway has changed.\n");
                printf("Everything seems to be made of flesh and bone, and the walls are pulsating.\n");
            } else {
                printf("Invalid choice. Try again.\n");
            }
        } else if (choice2 == 'r') {
            printf("You turn back and see the door you came through is gone.\n");
            printf("In a panic, you start running back towards where you woke up.\n");
            printf("But as you run, the walls start to close in on you.\n");
            printf("You struggle to escape, but it's no use.\n");
            printf("The walls engulf you and everything goes black.\n");
            return 0;
        } else {
            printf("Invalid choice. Try again.\n");
        }
    } else if (choice1 == 'w') {
        printf("You look out the window, but all you see is darkness.\n");
        printf("Suddenly, you feel a hand grab your shoulder from behind.\n");
        printf("You turn around to see a grotesque creature that resembles a human.\n");
        printf("It has razor-sharp claws, sharp teeth, and a massive hunchback.\n");
        
        char choice5;
        printf("Enter 'a' to fight the creature or 'r' to run: ");
        scanf(" %c", &choice5);
        
        if (choice5 == 'a') {
            printf("You try to fight the creature, but it's too strong and fast.\n");
            printf("It slashes you with its claws, causing massive damage.\n");
            printf("You struggle to stay conscious, but eventually, everything goes black.\n");
            return 0;
        } else if (choice5 == 'r') {
            printf("You run as fast as you can, but the creature is right behind you.\n");
            printf("You make a desperate move and jump out of the window.\n");
            printf("You fall for what feels like forever, but eventually, you land in a body of water.\n");
            printf("You struggle to swim to the surface, but eventually, you make it.\n");
            printf("As you take a few deep breaths, you realize you are in a swamp.\n");
            
            char choice6;
            printf("Enter 'w' to keep swimming or 's' to try to find a way out: ");
            scanf(" %c", &choice6);
            
            if (choice6 == 'w') {
                printf("You keep swimming, but the water is thick and slimy.\n");
                printf("Suddenly, you feel something wrap around your leg and pull you down.\n");
                printf("You struggle to escape, but it's too strong.\n");
                printf("You are dragged under the surface and everything goes black.\n");
                return 0;
            } else if (choice6 == 's') {
                printf("You swim to the closest edge of the swamp and climb out.\n");
                printf("As you look around, you see a dense forest in front of you.\n");
                
                char choice7;
                printf("Enter 'e' to explore the forest or 'c' to stay put: ");
                scanf(" %c", &choice7);
                
                if (choice7 == 'e') {
                    printf("You start walking into the forest, but you soon realize you are lost.\n");
                    printf("The forest seems to be alive, with roots and vines crawling around your feet.\n");
                    printf("You struggle to walk, but eventually, you come across a clearing.\n");
                    
                    char choice8;
                    printf("Enter 'p' to sit down and rest or 'f' to keep walking: ");
                    scanf(" %c", &choice8);
                    
                    if (choice8 == 'p') {
                        printf("You sit down and try to catch your breath.\n");
                        printf("As you relax, you hear a faint singing coming from the trees.\n");
                        printf("It's a beautiful melody, and it seems to be getting closer.\n");
                        printf("You stand up, but before you can do anything else, a massive bird swoops down and grabs you.\n");
                        printf("You struggle to escape, but it's too strong.");
                        printf("Eventually, you give up and everything goes black.\n");
                        return 0;
                    } else if (choice8 == 'f') {
                        printf("You keep walking, but it's getting dark.\n");
                        printf("You try to turn back, but all the trees look the same.\n");
                        printf("Suddenly, you hear a voice calling out to you.\n");
                        printf("'Hey, over here!'");
                        
                        char choice9;
                        printf("Enter 'h' to hide or 'a' to approach the voice: ");
                        scanf(" %c", &choice9);
                        
                        if (choice9 == 'h') {
                            printf("You hide behind a nearby tree, but the voice seems to be getting closer.\n");
                            printf("You peek around the tree and see a figure approaching you.\n");
                            printf("It's a beautiful woman, but she has sharp, fanged teeth and glowing eyes.\n");
                            printf("She smiles and says, 'I've been waiting for you.'\n");
                            printf("You try to run, but she grabs you and brings you in for a kiss.\n");
                            printf("You struggle to get free, but eventually, everything goes black.\n");
                            return 0;
                        } else if (choice9 == 'a') {
                            printf("You walk towards the voice, but as you get closer, you realize it's coming from a massive spider.\n");
                            printf("It's legs are covered in black fur, and its eyes seem to glow in the dark.\n");
                            printf("It creeps closer and closer, and before you can react, it pounces and bites you.\n");
                            printf("You feel a sharp pain and start to feel woozy.\n");
                            printf("The last thing you see is the spider dragging you off into the darkness.\n");
                            return 0;
                        } else {
                            printf("Invalid choice. Try again.\n");
                        }
                    } else {
                        printf("Invalid choice. Try again.\n");
                    }
                } else if (choice7 == 'c') {
                    printf("You stay near the edge of the swamp, hoping someone will find you.\n");
                    printf("You wait for what feels like hours, but no one comes.\n");
                    printf("As the night turns colder, you start to shiver.\n");
                    printf("Soon, you can't move and everything goes black.\n");
                    return 0;
                } else {
                    printf("Invalid choice. Try again.\n");
                }
            } else {
                printf("Invalid choice. Try again.\n");
            }
        } else {
            printf("Invalid choice. Try again.\n");
        }
    } else {
        printf("Invalid choice. Try again.\n");
    }
    
    printf("Congratulations, you survived Invasive Adventure!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+27h] [rbp-9h] BYREF
  char v5; // [rsp+28h] [rbp-8h] BYREF
  char v6; // [rsp+29h] [rbp-7h] BYREF
  char v7; // [rsp+2Ah] [rbp-6h] BYREF
  char v8; // [rsp+2Bh] [rbp-5h] BYREF
  char v9; // [rsp+2Ch] [rbp-4h] BYREF
  char v10; // [rsp+2Dh] [rbp-3h] BYREF
  char v11; // [rsp+2Eh] [rbp-2h] BYREF
  char v12; // [rsp+2Fh] [rbp-1h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to Invasive Adventure!\n");
  printf("You wake up in a dark room with no memory of how you got there.\n");
  printf("As you look around, you see a door in front of you and a window to your right.\n");
  printf("Enter 'd' to open the door or 'w' to look out the window: ");
  scanf("%c", &v12);
  if ( v12 == 100 )
  {
    printf("You open the door and see a long hallway.\n");
    printf("As you start walking down the hallway, you feel like you are being watched.\n");
    printf("Enter 'f' to keep walking or 'r' to turn back: ");
    scanf(" %c", &v11);
    if ( v11 == 102 )
    {
      printf("You walk until you reach the end of the hallway.\n");
      printf("There is a locked door in front of you.\n");
      printf("Enter 'u' to try to unlock the door or 'b' to go back: ");
      scanf(" %c", &v10);
      if ( v10 == 117 )
      {
        printf("You try to unlock the door, but the keyhole is too small for your fingers.\n");
        printf("As you turn around, you see a figure approaching you from the other end of the hallway.\n");
        printf("Enter 'r' to run towards the figure or 'h' to hide in a nearby room: ");
        scanf(" %c", &v9);
        if ( v9 == 114 )
        {
          printf("You run towards the figure, but it disappears into thin air.\n");
          printf("Confused and scared, you turn around and see the hallway has changed.\n");
          printf("Everything seems to be made of flesh and bone, and the walls are pulsating.\n");
        }
        else if ( v9 == 104 )
        {
          printf("You quickly enter a nearby room and lock the door.\n");
          printf("It's a small room with a single window, but you can't see anything odd outside.\n");
          printf("You hear footsteps passing by the door, but they soon fade away.\n");
        }
        else
        {
          printf("Invalid choice. Try again.\n");
        }
      }
      else if ( v10 == 98 )
      {
        printf("You turn back, but the hallway has changed.\n");
        printf("Everything seems to be made of flesh and bone, and the walls are pulsating.\n");
      }
      else
      {
        printf("Invalid choice. Try again.\n");
      }
    }
    else
    {
      if ( v11 == 114 )
      {
        printf("You turn back and see the door you came through is gone.\n");
        printf("In a panic, you start running back towards where you woke up.\n");
        printf("But as you run, the walls start to close in on you.\n");
        printf("You struggle to escape, but it's no use.\n");
        printf("The walls engulf you and everything goes black.\n");
        return 0;
      }
      printf("Invalid choice. Try again.\n");
    }
  }
  else if ( v12 == 119 )
  {
    printf("You look out the window, but all you see is darkness.\n");
    printf("Suddenly, you feel a hand grab your shoulder from behind.\n");
    printf("You turn around to see a grotesque creature that resembles a human.\n");
    printf("It has razor-sharp claws, sharp teeth, and a massive hunchback.\n");
    printf("Enter 'a' to fight the creature or 'r' to run: ");
    scanf(" %c", &v8);
    if ( v8 == 97 )
    {
      printf("You try to fight the creature, but it's too strong and fast.\n");
      printf("It slashes you with its claws, causing massive damage.\n");
      printf("You struggle to stay conscious, but eventually, everything goes black.\n");
      return 0;
    }
    if ( v8 == 114 )
    {
      printf("You run as fast as you can, but the creature is right behind you.\n");
      printf("You make a desperate move and jump out of the window.\n");
      printf("You fall for what feels like forever, but eventually, you land in a body of water.\n");
      printf("You struggle to swim to the surface, but eventually, you make it.\n");
      printf("As you take a few deep breaths, you realize you are in a swamp.\n");
      printf("Enter 'w' to keep swimming or 's' to try to find a way out: ");
      scanf(" %c", &v7);
      if ( v7 == 119 )
      {
        printf("You keep swimming, but the water is thick and slimy.\n");
        printf("Suddenly, you feel something wrap around your leg and pull you down.\n");
        printf("You struggle to escape, but it's too strong.\n");
        printf("You are dragged under the surface and everything goes black.\n");
        return 0;
      }
      if ( v7 == 115 )
      {
        printf("You swim to the closest edge of the swamp and climb out.\n");
        printf("As you look around, you see a dense forest in front of you.\n");
        printf("Enter 'e' to explore the forest or 'c' to stay put: ");
        scanf(" %c", &v6);
        if ( v6 == 101 )
        {
          printf("You start walking into the forest, but you soon realize you are lost.\n");
          printf("The forest seems to be alive, with roots and vines crawling around your feet.\n");
          printf("You struggle to walk, but eventually, you come across a clearing.\n");
          printf("Enter 'p' to sit down and rest or 'f' to keep walking: ");
          scanf(" %c", &v5);
          if ( v5 == 112 )
          {
            printf("You sit down and try to catch your breath.\n");
            printf("As you relax, you hear a faint singing coming from the trees.\n");
            printf("It's a beautiful melody, and it seems to be getting closer.\n");
            printf("You stand up, but before you can do anything else, a massive bird swoops down and grabs you.\n");
            printf("You struggle to escape, but it's too strong.");
            printf("Eventually, you give up and everything goes black.\n");
            return 0;
          }
          if ( v5 == 102 )
          {
            printf("You keep walking, but it's getting dark.\n");
            printf("You try to turn back, but all the trees look the same.\n");
            printf("Suddenly, you hear a voice calling out to you.\n");
            printf("'Hey, over here!'");
            printf("Enter 'h' to hide or 'a' to approach the voice: ");
            scanf(" %c", &v4);
            if ( v4 == 104 )
            {
              printf("You hide behind a nearby tree, but the voice seems to be getting closer.\n");
              printf("You peek around the tree and see a figure approaching you.\n");
              printf("It's a beautiful woman, but she has sharp, fanged teeth and glowing eyes.\n");
              printf("She smiles and says, 'I've been waiting for you.'\n");
              printf("You try to run, but she grabs you and brings you in for a kiss.\n");
              printf("You struggle to get free, but eventually, everything goes black.\n");
              return 0;
            }
            if ( v4 == 97 )
            {
              printf("You walk towards the voice, but as you get closer, you realize it's coming from a massive spider.\n");
              printf("It's legs are covered in black fur, and its eyes seem to glow in the dark.\n");
              printf("It creeps closer and closer, and before you can react, it pounces and bites you.\n");
              printf("You feel a sharp pain and start to feel woozy.\n");
              printf("The last thing you see is the spider dragging you off into the darkness.\n");
              return 0;
            }
            printf("Invalid choice. Try again.\n");
          }
          else
          {
            printf("Invalid choice. Try again.\n");
          }
        }
        else
        {
          if ( v6 == 99 )
          {
            printf("You stay near the edge of the swamp, hoping someone will find you.\n");
            printf("You wait for what feels like hours, but no one comes.\n");
            printf("As the night turns colder, you start to shiver.\n");
            printf("Soon, you can't move and everything goes black.\n");
            return 0;
          }
          printf("Invalid choice. Try again.\n");
        }
      }
      else
      {
        printf("Invalid choice. Try again.\n");
      }
    }
    else
    {
      printf("Invalid choice. Try again.\n");
    }
  }
  else
  {
    printf("Invalid choice. Try again.\n");
  }
  printf("Congratulations, you survived Invasive Adventure!\n");
  return 0;
}
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game of Life ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 25
#define COLS 50
#define GENERATIONS 50

int grid[ROWS][COLS];
int grid_temp[ROWS][COLS];

/* Initialize the grid randomly */
void initializeGrid() {
    srand(time(NULL));
    for (int i=0; i<ROWS; i++) {
        for (int j=0; j<COLS; j++) {
            grid[i][j] = rand() % 2;
        }
    }
}

/* Print the current state of the grid */
void printGrid() {
    printf("\n");
    for (int i=0; i<ROWS; i++) {
        for (int j=0; j<COLS; j++) {
            if (grid[i][j] == 1) {
                printf("* ");
            } else {
                printf("- ");
            }
        }
        printf("\n");
    }
}

/* Get the number of neighbors for a given cell */
int getNeighbors(int i, int j) {
    int neighbors = 0;
    int row, col;
    for (int x=-1; x<=1; x++) {
        for (int y=-1; y<=1; y++) {
            row = (i + x + ROWS) % ROWS;
            col = (j + y + COLS) % COLS;
            if (grid[row][col] == 1) {
                neighbors++;
            }
        }
    }
    neighbors -= grid[i][j];
    return neighbors;
}

/* Update the grid according to the rules of the Game of Life */
void updateGrid() {
    int neighbors;
    for (int i=0; i<ROWS; i++) {
        for (int j=0; j<COLS; j++) {
            neighbors = getNeighbors(i, j);
            if (grid[i][j] == 1) {
                if (neighbors < 2 || neighbors > 3) {
                    grid_temp[i][j] = 0;
                } else {
                    grid_temp[i][j] = 1;
                }
            } else {
                if (neighbors == 3) {
                    grid_temp[i][j] = 1;
                } else {
                    grid_temp[i][j] = 0;
                }
            }
        }
    }
    for (int i=0; i<ROWS; i++) {
        for (int j=0; j<COLS; j++) {
            grid[i][j] = grid_temp[i][j];
        }
    }
}

int main() {
    initializeGrid();
    for (int gen=1; gen<=GENERATIONS; gen++) {
        printf("Generation %d:", gen);
        printGrid();
        updateGrid();
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 initializeGrid(void); // weak
__int64 printGrid(void); // weak
__int64 updateGrid(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A81) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  initializeGrid();
  for ( i = 1; i <= 50; ++i )
  {
    printf("Generation %d:", (unsigned int)i);
    printGrid();
    updateGrid();
  }
  return 0;
}
// 1400015B0: using guessed type __int64 initializeGrid(void);
// 140001642: using guessed type __int64 printGrid(void);
// 14000183A: using guessed type __int64 updateGrid(void);
// 140001B80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: inquisitive
#include <stdio.h>

int main() {
  int x, y, n;
  printf("Let's print a C-shaped pattern. How many rows do you want? ");
  scanf("%d", &n);
  for (x = 0; x < n; x++) {
    for (y = 0; y <= n; y++) {
      if (y == 0 || (x == 0 && y < n) || (x == n/2 && y >= n/2) || (y == n/2 && x > n/2) || x == n-1) {
        printf("*");
      } else {
        printf(" ");
      }
    }
    printf("\n");
  }
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Let's print a C-shaped pattern. How many rows do you want? ");
  scanf("%d", &v4);
  for ( i = 0; i < v4; ++i )
  {
    for ( j = 0; j <= v4; ++j )
    {
      if ( !j || !i && j < v4 || i == v4 / 2 && j >= v4 / 2 || j == v4 / 2 && i > v4 / 2 || i == v4 - 1 )
        printf("*");
      else
        printf(" ");
    }
    printf("\n");
  }
  return 0;
}
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to Morse code conversion ; Style: beginner-friendly
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to convert character to morse code string
char* charToMorse(char c){

    // Array of morse code strings for each character
    char* morseCodes[] = {".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....",
                          "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.",
                          "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-",
                          "-.--", "--.."};

    // Converting character to its respective ASCII index and subtracting by 65 to get array index
    // If the character is a space, return an empty string
    if(c == ' '){
        return "";
    } else {
        int index = (int)c - 65;
        return morseCodes[index];
    }
}

// Function to convert text string to morse code string
char* textToMorse(char* text){

    // Allocating memory for morse code string with twice the length of the original text string
    int textLen = strlen(text);
    char* morseCode = (char*)malloc(textLen*2*sizeof(char));
    morseCode[0] = '\0';

    // Loop through each character in the text string and add its morse code to the morse code string
    for(int i=0; i<textLen; i++){
        char* charMorse = charToMorse(text[i]);
        strcat(morseCode, charMorse);
        strcat(morseCode, " ");
    }

    return morseCode;
}

int main(){

    printf("Enter a text string to convert to Morse code:\n");

    // Get input from user
    char text[200];
    fgets(text, sizeof(text), stdin);

    // Convert text to Morse code and print result
    char* morseCode = textToMorse(text);
    printf("Morse code: %s\n", morseCode);

    free(morseCode);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall textToMorse(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400017AC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[200]; // [rsp+20h] [rbp-D0h] BYREF
  void *Block; // [rsp+E8h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a text string to convert to Morse code:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 200, v3);
  Block = (void *)textToMorse(Buffer);
  printf("Morse code: %s\n", (const char *)Block);
  free(Block);
  return 0;
}
// 140001712: using guessed type __int64 __fastcall textToMorse(_QWORD);
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ROWS 10
#define COLS 10

/* function to print the maze */
void printMaze(char maze[][COLS], int startRow, int startCol, int endRow, int endCol) {
    for(int i=0;i<ROWS;i++) {
        for(int j=0;j<COLS;j++) {
            if(i == startRow && j == startCol) {
                printf("| S ");
            } else if(i == endRow && j == endCol) {
                printf("| E ");
            } else {
                printf("| %c ", maze[i][j]);
            }
        }
        printf("|\n");
    }
}

/* function to find the path from start to end */
void findPath(char maze[][COLS], int startRow, int startCol, int endRow, int endCol) {
    int path[ROWS*COLS][2], top=-1;
    int visited[ROWS][COLS], flag=0;
    memset(visited, 0, sizeof(visited));
    visited[startRow][startCol] = 1;
    path[++top][0] = startRow;
    path[top][1] = startCol;
    
    while(top >= 0) {
        int row = path[top][0];
        int col = path[top][1];
        if(row == endRow && col == endCol) {
            flag = 1;
            break;
        }
        top--;
        if(row>0 && maze[row-1][col]=='0' && visited[row-1][col]==0) {
            path[++top][0] = row-1;
            path[top][1] = col;
            visited[row-1][col] = 1;
        }
        if(col>0 && maze[row][col-1]=='0' && visited[row][col-1]==0) {
            path[++top][0] = row;
            path[top][1] = col-1;
            visited[row][col-1] = 1;
        }
        if(row<ROWS-1 && maze[row+1][col]=='0' && visited[row+1][col]==0) {
            path[++top][0] = row+1;
            path[top][1] = col;
            visited[row+1][col] = 1;
        }
        if(col<COLS-1 && maze[row][col+1]=='0' && visited[row][col+1]==0) {
            path[++top][0] = row;
            path[top][1] = col+1;
            visited[row][col+1] = 1;
        }
    }
    if(flag == 0) {
        printf("\nPath not found!\n\n");
    } else {
        // print the path
        printf("\nPath:\n");
        for(int i=top;i>=0;i--) {
            printf("(%d,%d)\n", path[i][0], path[i][1]);
        }
        printf("\n");
    }
}

int main() {
    char maze[ROWS][COLS] = {
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '1', '1', '1', '1', '1', '1', '1', '0', '1'},
        {'0', '1', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'0', '1', '1', '0', '1', '1', '1', '1', '0', '1'},
        {'0', '1', '0', '0', '1', '0', '0', '0', '0', '0'},
        {'0', '1', '1', '0', '1', '0', '1', '1', '1', '0'},
        {'0', '1', '0', '0', '1', '0', '1', '0', '0', '0'},
        {'0', '1', '0', '1', '1', '0', '1', '0', '1', '0'},
        {'0', '1', '1', '0', '0', '0', '0', '0', '0', '1'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'}
    };
    int startRow = 1, startCol = 1;
    int endRow = 8, endCol = 9;
    
    printf("\nMaze:\n");
    printMaze(maze, startRow, startCol, endRow, endCol);
    
    findPath(maze, startRow, startCol, endRow, endCol);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printMaze(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
__int64 __fastcall findPath(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001B72) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[14]; // [rsp+30h] [rbp-80h] BYREF
  int v5; // [rsp+A0h] [rbp-10h]
  int v6; // [rsp+A4h] [rbp-Ch]
  int v7; // [rsp+A8h] [rbp-8h]
  int v8; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  qmemcpy(
    v4,
    "0000000000011111110101000000010110111101010010000001101011100100101000010110101001100000010000000000",
    100);
  v8 = 1;
  v7 = 1;
  v6 = 8;
  v5 = 9;
  printf("\nMaze:\n");
  printMaze((unsigned int)v4, 1, 1, 8, 9);
  findPath((unsigned int)v4, v8, v7, v6, v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printMaze(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14000166F: using guessed type __int64 __fastcall findPath(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001D70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password management ; Style: Linus Torvalds
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define PASSWORD_LENGTH 20
#define MAX_PASSWORDS 100

struct password {
    char name[50];
    char value[PASSWORD_LENGTH];
};

int numPasswords = 0;
struct password passwords[MAX_PASSWORDS];

void generatePassword(char *password) {
    int i, r;
    char c;
    srand(time(NULL)); // Seed random generator
    for (i = 0; i < PASSWORD_LENGTH; i++) {
        r = rand() % 62; // Generate random number from 0 to 61
        if (r < 26) {
            c = 'a' + r;
        } else if (r < 52) {
            c = 'A' + r - 26;
        } else {
            c = '0' + r - 52;
        }
        password[i] = c;
    }
    password[PASSWORD_LENGTH] = '\0';
}

void addPassword() {
    char name[50];
    char value[PASSWORD_LENGTH];
    printf("Enter name for password: ");
    scanf("%s", name);
    generatePassword(value);
    strncpy(passwords[numPasswords].name, name, 50);
    strncpy(passwords[numPasswords].value, value, PASSWORD_LENGTH);
    printf("Generated password for %s: %s\n", name, value);
    numPasswords++;
}

void displayPasswords() {
    int i;
    if (numPasswords == 0) {
        printf("No passwords saved.\n");
        return;
    }
    printf("%d password%s saved:\n", numPasswords, (numPasswords == 1) ? "" : "s");
    for (i = 0; i < numPasswords; i++) {
        printf("%s: %s\n", passwords[i].name, passwords[i].value);
    }
}

void searchPasswords() {
    int i;
    char query[50];
    printf("Enter name query: ");
    scanf("%s", query);
    for (i = 0; i < numPasswords; i++) {
        if (strstr(passwords[i].name, query)) {
            printf("%s: %s\n", passwords[i].name, passwords[i].value);
        }
    }
}

int main() {
    char c;
    printf("Password Manager\n\n");
    while (1) {
        printf("Options:\n");
        printf("1. Add password\n");
        printf("2. Display all passwords\n");
        printf("3. Search passwords\n");
        printf("4. Quit\n");
        printf("Enter option number: ");
        scanf(" %c", &c);
        printf("\n");
        switch (c) {
            case '1':
                addPassword();
                break;
            case '2':
                displayPasswords();
                break;
            case '3':
                searchPasswords();
                break;
            case '4':
                printf("Goodbye!\n");
                exit(0);
            default:
                printf("Invalid option.\n");
        }
        printf("\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 addPassword(void); // weak
__int64 displayPasswords(void); // weak
__int64 searchPasswords(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400018E2) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  char v3; // [rsp+2Fh] [rbp-1h] BYREF

  _main(argc, argv, envp);
  printf("Password Manager\n\n");
  while ( 1 )
  {
    printf("Options:\n");
    printf("1. Add password\n");
    printf("2. Display all passwords\n");
    printf("3. Search passwords\n");
    printf("4. Quit\n");
    printf("Enter option number: ");
    scanf(" %c", &v3);
    printf("\n");
    if ( v3 == 52 )
    {
      printf("Goodbye!\n");
      exit(0);
    }
    if ( v3 <= 52 )
    {
      switch ( v3 )
      {
        case '3':
          searchPasswords();
          goto LABEL_13;
        case '1':
          addPassword();
          goto LABEL_13;
        case '2':
          displayPasswords();
          goto LABEL_13;
      }
    }
    printf("Invalid option.\n");
LABEL_13:
    printf("\n");
  }
}
// 140001996: conditional instruction was optimized away because eax.4<33
// 1400016AE: using guessed type __int64 addPassword(void);
// 140001773: using guessed type __int64 displayPasswords(void);
// 14000182D: using guessed type __int64 searchPasswords(void);
// 140001AB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Linked list operations ; Style: inquisitive
#include <stdio.h>
#include <stdlib.h>

// define the structure of a list node
struct Node {
    int data;
    struct Node* next;
};

// function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = NULL;
    newNode = (struct Node*) malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Error: memory allocation failed!");
        exit(1);
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// function to insert a node at the front of the list
void insertAtFront(struct Node** headRef, int data) {
    struct Node* newNode = createNode(data);
    newNode->next = *headRef;
    *headRef = newNode;
}

// function to insert a node after a given node in the list
void insertAfter(struct Node* prevNode, int data) {
    if (prevNode == NULL) {
        printf("Error: the previous node cannot be NULL!");
        exit(1);
    }
    struct Node* newNode = createNode(data);
    newNode->next = prevNode->next;
    prevNode->next = newNode;
}

// function to insert a node at the end of the list
void insertAtEnd(struct Node** headRef, int data) {
    struct Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    struct Node* lastNode = *headRef;
    while (lastNode->next != NULL) {
        lastNode = lastNode->next;
    }
    lastNode->next = newNode;
}

// function to delete a node from the list by key
void deleteByKey(struct Node** headRef, int key) {
    struct Node* temp = *headRef;
    struct Node* prevNode = NULL;

    if (temp != NULL && temp->data == key) {
        *headRef = temp->next;
        free(temp);
        return;
    }

    while (temp != NULL && temp->data != key) {
        prevNode = temp;
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Error: key not found in list!");
        return;
    }

    prevNode->next = temp->next;
    free(temp);
}

// function to print the elements of the list
void printList(struct Node* head) {
    printf("Linked List: ");
    while (head != NULL) {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

// main function
int main() {
    struct Node* head = NULL;

    insertAtEnd(&head, 10);
    insertAtFront(&head, 5);
    insertAtEnd(&head, 20);
    insertAfter(head->next, 15);
    printList(head);

    deleteByKey(&head, 5);
    deleteByKey(&head, 15);
    printList(head);

    insertAtFront(&head, 30);
    insertAtEnd(&head, 40);
    printList(head);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall insertAtFront(_QWORD, _QWORD); // weak
__int64 __fastcall insertAfter(_QWORD, _QWORD); // weak
__int64 __fastcall insertAtEnd(_QWORD, _QWORD); // weak
__int64 __fastcall deleteByKey(_QWORD, _QWORD); // weak
__int64 __fastcall printList(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000180C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v4 = 0i64;
  insertAtEnd(&v4, 10i64);
  insertAtFront(&v4, 5i64);
  insertAtEnd(&v4, 20i64);
  insertAfter(*(_QWORD *)(v4 + 8), 15i64);
  printList(v4);
  deleteByKey(&v4, 5i64);
  deleteByKey(&v4, 15i64);
  printList(v4);
  insertAtFront(&v4, 30i64);
  insertAtEnd(&v4, 40i64);
  printList(v4);
  return 0;
}
// 1400015F1: using guessed type __int64 __fastcall insertAtFront(_QWORD, _QWORD);
// 14000162F: using guessed type __int64 __fastcall insertAfter(_QWORD, _QWORD);
// 14000168F: using guessed type __int64 __fastcall insertAtEnd(_QWORD, _QWORD);
// 1400016FD: using guessed type __int64 __fastcall deleteByKey(_QWORD, _QWORD);
// 1400017AF: using guessed type __int64 __fastcall printList(_QWORD);
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Error handling ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

void func(int *p) {
    if (p == NULL) {
        fprintf(stderr, "Error: null pointer passed to function\n");
        exit(EXIT_FAILURE);
    }
    /* function logic here */
}

int main(void)
{
    int *p = NULL;
    int ret;

    p = malloc(sizeof(int));
    if (p == NULL) {
        perror("malloc error");
        exit(EXIT_FAILURE);
    }

    printf("Enter a positive integer: ");
    ret = scanf("%d", p);
    if (ret == 0 || *p <= 0) {
        fprintf(stderr, "Error: invalid input\n");
        free(p);
        exit(EXIT_FAILURE);
    }

    func(p);

    free(p);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall func(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl perror(const char *ErrMsg);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001669) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int *Block; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  Block = (int *)malloc(4ui64);
  if ( !Block )
  {
    perror("malloc error");
    exit(1);
  }
  printf("Enter a positive integer: ");
  if ( !scanf("%d", Block) || *Block <= 0 )
  {
    v3 = __acrt_iob_func(2u);
    fprintf_0(v3, "Error: invalid input\n");
    free(Block);
    exit(1);
  }
  func(Block);
  free(Block);
  return 0;
}
// 140001625: using guessed type __int64 __fastcall func(_QWORD);
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game of Life ; Style: cheerful
/* Welcome to the Happy Game of Life! */
/* This program is a cheerful version of the famous Game of Life */
/* Created by [Your Name] */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 20
#define COLUMNS 40

/* Function prototypes */
void initialize_board(int board[ROWS][COLUMNS]);
void print_board(int board[ROWS][COLUMNS], int generation);
void update_board(int board[ROWS][COLUMNS]);

int main(void)
{
    int board[ROWS][COLUMNS];
    int generation = 0;

    /* Initializing the board */
    initialize_board(board);

    /* Main game loop */
    while (1)
    {
        system("clear"); /* Clearing the console */

        print_board(board, generation); /* Printing the board */

        update_board(board); /* Updating the board */

        generation++; /* Increasing the generation counter */

        sleep(1); /* Waiting for one second */
    }

    return 0;
}

/* This function initializes the board with random values */
void initialize_board(int board[ROWS][COLUMNS])
{
    int i, j;
    srand(time(NULL)); /* Initializing the random number generator */

    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLUMNS; j++)
        {
            board[i][j] = rand() % 2; /* Filling the board with random values (0 or 1) */
        }
    }
}

/* This function prints the board to the console */
void print_board(int board[ROWS][COLUMNS], int generation)
{
    int i, j;
    printf("Welcome to the Happy Game of Life - Generation %d\n\n", generation);

    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLUMNS; j++)
        {
            if (board[i][j] == 0)
            {
                /* Cheerful smiley face for dead cells */
                printf(":)");

            }
            else
            {
                /* Also cheerful smiley face for living cells */
                printf(":D");
            }
        }
        printf("\n");
    }
}

/* This function updates the board according to the rules of the game of life */
void update_board(int board[ROWS][COLUMNS])
{
    int i, j;
    int new_board[ROWS][COLUMNS];

    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLUMNS; j++)
        {
            int neighbors = 0;
            int k, l;

            /* Counting the number of living neighbors */
            for (k = i - 1; k <= i + 1; k++)
            {
                for (l = j - 1; l <= j + 1; l++)
                {
                    if (k >= 0 && k < ROWS && l >= 0 && l < COLUMNS && !(k == i && l == j))
                    {
                        neighbors += board[k][l];
                    }
                }
            }

            /* Applying the rules of the game */
            if (board[i][j] == 1 && (neighbors < 2 || neighbors > 3))
            {
                new_board[i][j] = 0;
            }
            else if (board[i][j] == 0 && neighbors == 3)
            {
                new_board[i][j] = 1;
            }
            else
            {
                new_board[i][j] = board[i][j];
            }
        }
    }

    /* Copying the new board to the original board */
    for (i = 0; i < ROWS; i++)
    {
        for (j = 0; j < COLUMNS; j++)
        {
            board[i][j] = new_board[i][j];
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall initialize_board(_QWORD); // weak
__int64 __fastcall print_board(_QWORD, _QWORD); // weak
__int64 __fastcall update_board(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// int __cdecl system(const char *Command);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[3212]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v5; // [rsp+CACh] [rbp+C2Ch]

  _main(argc, argv, envp);
  v5 = 0;
  initialize_board(v4);
  while ( 1 )
  {
    system("clear");
    print_board(v4, v5);
    update_board(v4);
    ++v5;
    sleep(1i64);
  }
}
// 14000161B: using guessed type __int64 __fastcall initialize_board(_QWORD);
// 1400016AA: using guessed type __int64 __fastcall print_board(_QWORD, _QWORD);
// 140001754: using guessed type __int64 __fastcall update_board(_QWORD);
// 140001B10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002B70: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sudoku solver ; Style: beginner-friendly
#include <stdio.h>

int checkRow(int row, int num, int puzzle[][9]) {
    for (int col = 0; col < 9; col++) {
        if (puzzle[row][col] == num) {
            return 0;
        }
    }
    return 1;
}

int checkCol(int col, int num, int puzzle[][9]) {
    for (int row = 0; row < 9; row++) {
        if (puzzle[row][col] == num) {
            return 0;
        }
    }
    return 1;
}

int checkBox(int startRow, int startCol, int num, int puzzle[][9]) {
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
            if (puzzle[row+startRow][col+startCol] == num) {
                return 0;
            }
        }
    }
    return 1;
}

void printPuzzle(int puzzle[][9]) {
    for (int row = 0; row < 9; row++) {
        for (int col = 0; col < 9; col++) {
            printf("%2d",puzzle[row][col]);
            if (col == 2 || col == 5) {
                printf(" ");
            }
        }
        printf("\n");
        if (row == 2 || row == 5) {
            printf("\n");
        }
    }
}

int solve(int puzzle[][9]) {
    int row, col, num;
    for (row = 0; row < 9; row++) {
        for (col = 0; col < 9; col++) {
            if (puzzle[row][col] == 0) {
                for (num = 1; num <= 9; num++) {
                    if (checkRow(row, num, puzzle) && checkCol(col, num, puzzle) && checkBox(row-row%3, col-col%3, num, puzzle)) {
                        puzzle[row][col] = num;
                        if (solve(puzzle))
                            return 1;
                        puzzle[row][col] = 0;
                    }
                }
                return 0;
            }
        }
    }
    return 1;
}

int main() {
    int puzzle[9][9] = {{0, 0, 0, 9, 0, 0, 0, 5, 0},
                        {7, 0, 0, 0, 0, 0, 0, 0, 0},
                        {0, 9, 0, 0, 8, 0, 0, 0, 0},
                        {0, 0, 0, 7, 0, 5, 0, 0, 0},
                        {1, 0, 7, 0, 0, 0, 4, 0, 0},
                        {0, 0, 4, 0, 3, 0, 0, 0, 0},
                        {0, 0, 0, 0, 0, 7, 0, 0, 0},
                        {0, 5, 0, 0, 0, 0, 0, 0, 0},
                        {0, 0, 0, 0, 0, 0, 0, 0, 0}};

    printf("Puzzle before solving:\n");
    printPuzzle(puzzle);

    if (solve(puzzle)) {
        printf("Puzzle solved:\n");
        printPuzzle(puzzle);
    } else {
        printf("Unable to solve puzzle");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printPuzzle(_QWORD); // weak
__int64 __fastcall solve(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000193C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[88]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  memset(v4, 0, 324);
  v4[3] = 9;
  v4[7] = 5;
  v4[9] = 7;
  v4[19] = 9;
  v4[22] = 8;
  v4[30] = 7;
  v4[32] = 5;
  v4[36] = 1;
  v4[38] = 7;
  v4[42] = 4;
  v4[47] = 4;
  v4[49] = 3;
  v4[59] = 7;
  v4[64] = 5;
  printf("Puzzle before solving:\n");
  printPuzzle(v4);
  if ( (unsigned int)solve(v4) )
  {
    printf("Puzzle solved:\n");
    printPuzzle(v4);
  }
  else
  {
    printf("Unable to solve puzzle");
  }
  return 0;
}
// 1400016D8: using guessed type __int64 __fastcall printPuzzle(_QWORD);
// 140001795: using guessed type __int64 __fastcall solve(_QWORD);
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the User Struct
typedef struct User {
    char username[50];
    int age;
    float weight;
    float height;
    float goal_weight;
    float goal_calories;
} User;

// Define the Exercise Struct
typedef struct Exercise {
    char name[50];
    int calories;
} Exercise;

// Define the Tracker Struct
typedef struct Tracker {
    int date;
    int month;
    int year;
    float calories_consumed;
    float calories_burned;
} Tracker;

// Define the main function
int main() {
    // Initialize the user
    User user;
    printf("Please enter your username: \n");
    scanf("%s", &user.username);
    printf("Please enter your age: \n");
    scanf("%d", &user.age);
    printf("Please enter your weight in kg: \n");
    scanf("%f", &user.weight);
    printf("Please enter your height in m: \n");
    scanf("%f", &user.height);
    printf("Please enter your goal weight in kg: \n");
    scanf("%f", &user.goal_weight);
    printf("Please enter your goal calories per day: \n");
    scanf("%f", &user.goal_calories);

    // Initialize the exercises
    Exercise exercises[5];
    strcpy(exercises[0].name, "Running");
    exercises[0].calories = 700;
    strcpy(exercises[1].name, "Cycling");
    exercises[1].calories = 500;
    strcpy(exercises[2].name, "Swimming");
    exercises[2].calories = 600;
    strcpy(exercises[3].name, "Weightlifting");
    exercises[3].calories = 400;
    strcpy(exercises[4].name, "Yoga");
    exercises[4].calories = 200;

    // Initialize the tracker array for 1 week
    Tracker tracker[7];

    // Loop through each day and track the user's information
    for(int i=0; i<7; i++) {
        printf("Please enter the date for day %d (DD MM YYYY): \n", i+1);
        scanf("%d %d %d", &tracker[i].date, &tracker[i].month, &tracker[i].year);
        printf("Please enter the number of calories consumed for day %d: \n", i+1);
        scanf("%f", &tracker[i].calories_consumed);
        printf("Please enter the type of exercise done for day %d (0 for none, 1 for running, 2 for cycling, 3 for swimming, 4 for weightlifting, 5 for yoga): \n", i+1);

        int exerciseChoice;
        scanf("%d", &exerciseChoice);

        if(exerciseChoice != 0) {
            float minutes;
            printf("Please enter the number of minutes spent on %s: \n", exercises[exerciseChoice-1].name);
            scanf("%f", &minutes);
            tracker[i].calories_burned = exercises[exerciseChoice-1].calories * (minutes / 60);
        } else {
            tracker[i].calories_burned = 0;
        }
    }

    // Calculate the total calories consumed and burned for the week
    float total_calories_consumed = 0;
    float total_calories_burned = 0;

    for(int i=0; i<7; i++) {
        total_calories_consumed += tracker[i].calories_consumed;
        total_calories_burned += tracker[i].calories_burned;
    }

    // Calculate the user's weight loss progress
    float weight_loss = user.weight - user.goal_weight;
    float calories_per_kg_lost = weight_loss * 7700;
    float days_to_goal = calories_per_kg_lost / user.goal_calories;

    // Print the user's daily and weekly progress
    printf("Daily Progress:\n");
    for(int i=0; i<7; i++) {
        printf("%d/%d/%d - Consumed: %.2f calories, Burned: %.2f calories\n", tracker[i].date, tracker[i].month, tracker[i].year, tracker[i].calories_consumed, tracker[i].calories_burned);
    }

    printf("\nWeekly Progress:\n");
    printf("Calories Consumed: %.2f\n", total_calories_consumed);
    printf("Calories Burned: %.2f\n", total_calories_burned);
    printf("Net Calories: %.2f\n", total_calories_consumed - total_calories_burned);
    printf("Goal Calories: %.2f\n", user.goal_calories);
    printf("Days to Goal: %.2f\n", days_to_goal);

    printf("\nThank you for using the fitness tracker!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+38h] [rbp-48h] BYREF
  int v5[17]; // [rsp+3Ch] [rbp-44h] BYREF
  _BYTE v6[80]; // [rsp+80h] [rbp+0h] BYREF
  _QWORD v7[6]; // [rsp+D0h] [rbp+50h] BYREF
  int v8; // [rsp+104h] [rbp+84h]
  __int64 v9; // [rsp+108h] [rbp+88h]
  int v10; // [rsp+13Ch] [rbp+BCh]
  char v11[16]; // [rsp+140h] [rbp+C0h] BYREF
  int v12; // [rsp+174h] [rbp+F4h]
  char v13[16]; // [rsp+178h] [rbp+F8h] BYREF
  int v14; // [rsp+1ACh] [rbp+12Ch]
  char v15[8]; // [rsp+1B0h] [rbp+130h] BYREF
  int v16; // [rsp+1E4h] [rbp+164h]
  char v17[52]; // [rsp+1F0h] [rbp+170h] BYREF
  int v18; // [rsp+224h] [rbp+1A4h] BYREF
  float v19; // [rsp+228h] [rbp+1A8h] BYREF
  int v20; // [rsp+22Ch] [rbp+1ACh] BYREF
  float v21; // [rsp+230h] [rbp+1B0h] BYREF
  float v22[3]; // [rsp+234h] [rbp+1B4h] BYREF
  float v23; // [rsp+240h] [rbp+1C0h]
  float v24; // [rsp+244h] [rbp+1C4h]
  float v25; // [rsp+248h] [rbp+1C8h]
  int k; // [rsp+24Ch] [rbp+1CCh]
  int j; // [rsp+250h] [rbp+1D0h]
  float v28; // [rsp+254h] [rbp+1D4h]
  float v29; // [rsp+258h] [rbp+1D8h]
  int i; // [rsp+25Ch] [rbp+1DCh]

  _main(argc, argv, envp);
  printf("Please enter your username: \n");
  scanf("%s", v17);
  printf("Please enter your age: \n");
  scanf("%d", &v18);
  printf("Please enter your weight in kg: \n");
  scanf("%f", &v19);
  printf("Please enter your height in m: \n");
  scanf("%f", &v20);
  printf("Please enter your goal weight in kg: \n");
  scanf("%f", &v21);
  printf("Please enter your goal calories per day: \n");
  scanf("%f", v22);
  v7[0] = 0x676E696E6E7552i64;
  v8 = 700;
  v9 = 0x676E696C637943i64;
  v10 = 500;
  strcpy(v11, "Swimming");
  v12 = 600;
  strcpy(v13, "Weightlifting");
  v14 = 400;
  strcpy(v15, "Yoga");
  v16 = 200;
  for ( i = 0; i <= 6; ++i )
  {
    printf("Please enter the date for day %d (DD MM YYYY): \n", (unsigned int)(i + 1));
    scanf("%d %d %d", &v5[5 * i + 1], &v5[5 * i + 2], &v5[5 * i + 3]);
    printf("Please enter the number of calories consumed for day %d: \n", (unsigned int)(i + 1));
    scanf("%f", &v5[5 * i + 4]);
    printf(
      "Please enter the type of exercise done for day %d (0 for none, 1 for running, 2 for cycling, 3 for swimming, 4 for"
      " weightlifting, 5 for yoga): \n",
      (unsigned int)(i + 1));
    scanf("%d", v5);
    if ( v5[0] )
    {
      printf("Please enter the number of minutes spent on %s: \n", (const char *)&v7[7 * v5[0] - 7]);
      scanf("%f", &v4);
      *(float *)&v6[20 * i - 48] = (float)(v4 / 60.0) * (float)*(int *)&v6[56 * v5[0] + 76];
    }
    else
    {
      *(_DWORD *)&v6[20 * i - 48] = 0;
    }
  }
  v29 = 0.0;
  v28 = 0.0;
  for ( j = 0; j <= 6; ++j )
  {
    v29 = *(float *)&v6[20 * j - 52] + v29;
    v28 = *(float *)&v6[20 * j - 48] + v28;
  }
  v25 = v19 - v21;
  v24 = 7700.0 * (float)(v19 - v21);
  v23 = v24 / v22[0];
  printf("Daily Progress:\n");
  for ( k = 0; k <= 6; ++k )
    printf(
      "%d/%d/%d - Consumed: %.2f calories, Burned: %.2f calories\n",
      *(unsigned int *)&v6[20 * k - 64],
      *(unsigned int *)&v6[20 * k - 60],
      *(unsigned int *)&v6[20 * k - 56],
      *(float *)&v6[20 * k - 52],
      *(float *)&v6[20 * k - 48]);
  printf("\nWeekly Progress:\n");
  printf("Calories Consumed: %.2f\n", v29);
  printf("Calories Burned: %.2f\n", v28);
  printf("Net Calories: %.2f\n", (float)(v29 - v28));
  printf("Goal Calories: %.2f\n", v22[0]);
  printf("Days to Goal: %.2f\n", v23);
  printf("\nThank you for using the fitness tracker!\n");
  return 0;
}
// 140001DE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_70[52];
// 1400015E2: using guessed type float var_2C[3];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Email Client ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_EMAILS 10
#define MAX_LENGTH 1000
#define MAX_SENDERS 200

typedef struct{
    char sender[MAX_SENDERS];
    char subject[MAX_LENGTH];
    char message[MAX_LENGTH];
} Email;

void printMenu(){
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("               Purrfect Email Client\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("                     Main Menu\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("1 - Compose New Email\n");
    printf("2 - Check Inbox\n");
    printf("3 - Quit\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("Enter your choice : ");
}

void clearBuffer(){
    int c = 0;
    while ((c = getchar()) != '\n' && c != EOF) { }
}

void invalidChoice(){
    printf("Invalid choice. Please enter a valid choice.\n");
}

void addEmail(Email* emails, int* numEmails){
    int senderLength = 0;
    int subjectLength = 0;
    int messageLength = 0;
    
    printf("Enter sender : ");
    fgets(emails[*numEmails].sender, MAX_SENDERS, stdin);
    senderLength = strlen(emails[*numEmails].sender);
    if(senderLength > 0 && emails[*numEmails].sender[senderLength - 1] == '\n'){
        emails[*numEmails].sender[senderLength - 1] = '\0';
    }
    
    printf("Enter subject : ");
    fgets(emails[*numEmails].subject, MAX_LENGTH, stdin);
    subjectLength = strlen(emails[*numEmails].subject);
    if(subjectLength > 0 && emails[*numEmails].subject[subjectLength - 1] == '\n'){
        emails[*numEmails].subject[subjectLength - 1] = '\0';
    }
    
    printf("Enter message : ");
    fgets(emails[*numEmails].message, MAX_LENGTH, stdin);
    messageLength = strlen(emails[*numEmails].message);
    if(messageLength > 0 && emails[*numEmails].message[messageLength - 1] == '\n'){
        emails[*numEmails].message[messageLength - 1] = '\0';
    }
    
    printf("Email sent successfully!\n\n");
    *numEmails += 1;
}

void viewInbox(Email* emails, int numEmails){
    if(numEmails == 0){
        printf("You have no new emails.\n\n");
        return;
    }
    
    printf("Your inbox:\n");
    for(int i = 0; i < numEmails; i++){
        printf("Sender : %s\n", emails[i].sender);
        printf("Subject : %s\n", emails[i].subject);
        printf("Message : %s\n", emails[i].message);
        printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    }
}

int main(){
    Email emails[MAX_EMAILS];
    int numEmails = 0;
    int choice = 0;
    while(choice != 3){
        printMenu();
        if(scanf("%d", &choice) != 1){
            clearBuffer();
            invalidChoice();
            continue;
        }
        clearBuffer();
        switch(choice){
            case 1:
                addEmail(emails, &numEmails);
                break;
            case 2:
                viewInbox(emails, numEmails);
                break;
            case 3:
                printf("Thank you for using Purrfect Email Client. Goodbye!\n\n");
                break;
            default:
                invalidChoice();
                break;
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 printMenu(void); // weak
__int64 clearBuffer(void); // weak
__int64 invalidChoice(void); // weak
__int64 __fastcall addEmail(_QWORD, _QWORD); // weak
__int64 __fastcall viewInbox(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A45) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[22000]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  v4 = 0;
  while ( v4 != 3 )
  {
    printMenu();
    if ( scanf("%d", &v4) == 1 )
    {
      clearBuffer();
      if ( v4 == 3 )
      {
        printf("Thank you for using Purrfect Email Client. Goodbye!\n\n");
      }
      else
      {
        if ( v4 > 3 )
          goto LABEL_12;
        if ( v4 == 1 )
        {
          addEmail(v6, &v5);
        }
        else if ( v4 == 2 )
        {
          viewInbox(v6, v5);
        }
        else
        {
LABEL_12:
          invalidChoice();
        }
      }
    }
    else
    {
      clearBuffer();
      invalidChoice();
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 printMenu(void);
// 140001687: using guessed type __int64 clearBuffer(void);
// 1400016B2: using guessed type __int64 invalidChoice(void);
// 1400016D0: using guessed type __int64 __fastcall addEmail(_QWORD, _QWORD);
// 140001961: using guessed type __int64 __fastcall viewInbox(_QWORD, _QWORD);
// 140001BD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Basic Image Processing: Simple tasks like flipping an image, changing brightness/contrast ; Style: retro
#include<stdio.h>
#include<stdlib.h>
#include<math.h>

typedef enum{
    FLIP_HORIZONTAL,FLIP_VERTICAL
}FlipType;

struct Image{
    int rows;
    int cols;
    int **data;
};

void malloc_image(int rows,int cols,struct Image *img){
    img->rows=rows;
    img->cols=cols;
    img->data=(int**)malloc(rows*sizeof(int*));
    for(int i=0;i<rows;i++){
        img->data[i]=(int*)malloc(cols*sizeof(int));
    }
}

void free_image(struct Image *img){
    for(int i=0;i<img->rows;i++){
        free(img->data[i]);
    }
    free(img->data);   
}

void read_image(char *filename,struct Image *img){
    FILE *fp=fopen(filename,"r");
    if(fp==NULL){
        printf("Could not open file for reading\n");
        exit(1);
    }

    fscanf(fp,"%d %d",&img->rows,&img->cols);
    malloc_image(img->rows,img->cols,img);

    for(int i=0;i<img->rows;i++){
        for(int j=0;j<img->cols;j++){
            fscanf(fp,"%d",&img->data[i][j]);   
        }
    }

    fclose(fp);
}

void write_image(char *filename,struct Image *img){
    FILE *fp=fopen(filename,"w");
    if(fp==NULL){
        printf("Could not open file for writing\n");
        exit(1);
    }

    fprintf(fp,"%d %d\n",img->rows,img->cols);
    for(int i=0;i<img->rows;i++){
        for(int j=0;j<img->cols;j++){
            fprintf(fp,"%d ",img->data[i][j]);  
        }
        fprintf(fp,"\n");
    }

    fclose(fp);
}

void flip_image(struct Image *img,FlipType type){
    int **temp=(int**)malloc(img->rows*sizeof(int*));
    for(int i=0;i<img->rows;i++){
        temp[i]=(int*)malloc(img->cols*sizeof(int));
    }

    if(type==FLIP_HORIZONTAL){
        for(int i=0;i<img->rows;i++){
            for(int j=0;j<img->cols;j++){
                temp[i][j]=img->data[i][img->cols-1-j];
            }
        }
    }
    else if(type==FLIP_VERTICAL){
        for(int i=0;i<img->rows;i++){
            for(int j=0;j<img->cols;j++){
                temp[i][j]=img->data[img->rows-1-i][j];
            }
        }
    }

    for(int i=0;i<img->rows;i++){
        for(int j=0;j<img->cols;j++){
            img->data[i][j]=temp[i][j];
        }
    }

    for(int i=0;i<img->rows;i++){
        free(temp[i]);
    }
    free(temp); 
}

void change_brightness(struct Image *img,double factor){ 
    for(int i=0;i<img->rows;i++){
        for(int j=0;j<img->cols;j++){
            img->data[i][j]=(int)fmin(fmax(factor*img->data[i][j],0.0),255.0);
        }
    } 
}

void change_contrast(struct Image *img,double factor){ 
    double avg,sum=0;
    for(int i=0;i<img->rows;i++){
        for(int j=0;j<img->cols;j++){
            sum+=img->data[i][j];
        }
    }
    avg=sum/(img->rows*img->cols);

    for(int i=0;i<img->rows;i++){
        for(int j=0;j<img->cols;j++){
            img->data[i][j]=(int)fmin(fmax(factor*(img->data[i][j]-avg)+avg,0.0),255.0);
        }
    }
}

int main(){
    struct Image img;
    read_image("input_image.txt",&img);

    flip_image(&img,FLIP_HORIZONTAL);
    write_image("flipped_image.txt",&img);

    flip_image(&img,FLIP_VERTICAL);
    write_image("flipped_image.txt",&img);

    change_brightness(&img,1.5);
    write_image("brightness_image.txt",&img);

    change_contrast(&img,2);
    write_image("contrast_image.txt",&img);

    free_image(&img);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall free_image(_QWORD); // weak
__int64 __fastcall read_image(_QWORD, _QWORD); // weak
__int64 __fastcall write_image(_QWORD, _QWORD); // weak
__int64 __fastcall flip_image(_QWORD, _QWORD); // weak
__int64 __fastcall change_brightness(_QWORD); // weak
__int64 __fastcall change_contrast(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001DC4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[16]; // [rsp+20h] [rbp-10h] BYREF

  _main(argc, argv, envp);
  read_image("input_image.txt", v4);
  flip_image(v4, 0i64);
  write_image("flipped_image.txt", v4);
  flip_image(v4, 1i64);
  write_image("flipped_image.txt", v4);
  change_brightness(v4);
  write_image("brightness_image.txt", v4);
  change_contrast(v4);
  write_image("contrast_image.txt", v4);
  free_image(v4);
  return 0;
}
// 1400016A3: using guessed type __int64 __fastcall free_image(_QWORD);
// 1400016FD: using guessed type __int64 __fastcall read_image(_QWORD, _QWORD);
// 140001801: using guessed type __int64 __fastcall write_image(_QWORD, _QWORD);
// 140001900: using guessed type __int64 __fastcall flip_image(_QWORD, _QWORD);
// 140001B5D: using guessed type __int64 __fastcall change_brightness(_QWORD);
// 140001C3E: using guessed type __int64 __fastcall change_contrast(_QWORD);
// 140001F60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Educational ; Style: happy
#include <stdio.h>

int main() {
  printf("Welcome to the Happy Code Learning Program!\n\n");
  printf("Today, we are going to learn about arrays and loops!\n\n");

  int myArray[5] = {1, 2, 3, 4, 5};

  printf("My array is:");
  for(int i=0; i<5; i++) {
    printf(" %d", myArray[i]);
  }
  printf("\n\n");
  printf("Now, let's double each element in the array using a loop!\n\n");

  for(int i=0; i<5; i++) {
    myArray[i] = myArray[i] * 2;
    printf("Element %d is now %d\n", i+1, myArray[i]);
  }

  printf("\n\n");
  printf("The final array is:");
  for(int i=0; i<5; i++) {
    printf(" %d", myArray[i]);
  }
  printf("\n\n");
  printf("Great job! You've learned how to use arrays and loops in C!\n");
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[5]; // [rsp+20h] [rbp-20h]
  int k; // [rsp+34h] [rbp-Ch]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Happy Code Learning Program!\n\n");
  printf("Today, we are going to learn about arrays and loops!\n\n");
  v4[0] = 1;
  v4[1] = 2;
  v4[2] = 3;
  v4[3] = 4;
  v4[4] = 5;
  printf("My array is:");
  for ( i = 0; i <= 4; ++i )
    printf(" %d", (unsigned int)v4[i]);
  printf("\n\n");
  printf("Now, let's double each element in the array using a loop!\n\n");
  for ( j = 0; j <= 4; ++j )
  {
    v4[j] *= 2;
    printf("Element %d is now %d\n", (unsigned int)(j + 1), (unsigned int)v4[j]);
  }
  printf("\n\n");
  printf("The final array is:");
  for ( k = 0; k <= 4; ++k )
    printf(" %d", (unsigned int)v4[k]);
  printf("\n\n");
  printf("Great job! You've learned how to use arrays and loops in C!\n");
  return 0;
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Intrusion detection system ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024
#define MAX_ACCESS_COUNT 3

typedef struct {
    char username[20];
    char password[20];
} LoginCredential;

void systemError(int error_code);
void reportIntrusionAttempt();
void notifyAdministrator();

int main() {
    FILE* access_file;
    LoginCredential saved_credentials;
    LoginCredential entered_credentials;
    int access_count = 0;

    // Open the access file and read the saved login credentials
    if((access_file = fopen("access.dat", "rb")) == NULL) {
        systemError(1);
    }

    fread(&saved_credentials, sizeof(LoginCredential), 1, access_file);
    fclose(access_file);

    // Prompt the user to enter their login credentials
    printf("Enter your username and password:\n");
    scanf("%s %s", entered_credentials.username, entered_credentials.password);

    // Check if the entered credentials match the saved credentials
    if(strcmp(entered_credentials.username, saved_credentials.username) == 0 &&
       strcmp(entered_credentials.password, saved_credentials.password) == 0) {
        printf("Login successful.\n");
    } else {
        access_count++;
        reportIntrusionAttempt();

        if(access_count == MAX_ACCESS_COUNT) {
            notifyAdministrator();
        }

        printf("Invalid login attempt. You have %d login attempts left.\n", MAX_ACCESS_COUNT - access_count);
    }

    return 0;
}

void systemError(int error_code) {
    printf("An error occurred while accessing the system.\n");
    exit(error_code);
}

void reportIntrusionAttempt() {
    FILE* intrusion_file;
    char buffer[MAX_BUFFER_SIZE];

    if((intrusion_file = fopen("intrusions.dat", "a+")) == NULL) {
        systemError(2);
    }

    sprintf(buffer, "Intrusion attempt detected on %s", __DATE__);
    fwrite(buffer, strlen(buffer), 1, intrusion_file);
    fclose(intrusion_file);
}

void notifyAdministrator() {
    FILE* admin_file;
    char buffer[MAX_BUFFER_SIZE];

    if((admin_file = fopen("admin.dat", "rb")) == NULL) {
        systemError(3);
    }

    fread(buffer, MAX_BUFFER_SIZE, 1, admin_file);
    printf("Notifying System Administrator: %s\n", buffer);
    fclose(admin_file);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
void __fastcall __noreturn systemError(_QWORD); // weak
__int64 reportIntrusionAttempt(void); // weak
__int64 notifyAdministrator(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[20]; // [rsp+20h] [rbp-70h] BYREF
  char v5[28]; // [rsp+34h] [rbp-5Ch] BYREF
  char Buffer[20]; // [rsp+50h] [rbp-40h] BYREF
  char v7[28]; // [rsp+64h] [rbp-2Ch] BYREF
  FILE *Stream; // [rsp+80h] [rbp-10h]
  int v9; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 0;
  Stream = fopen("access.dat", "rb");
  if ( !Stream )
    systemError(1i64);
  fread(Buffer, 0x28ui64, 1ui64, Stream);
  fclose(Stream);
  printf("Enter your username and password:\n");
  scanf("%s %s", Str1, v5);
  if ( !strcmp(Str1, Buffer) && !strcmp(v5, v7) )
  {
    printf("Login successful.\n");
  }
  else
  {
    ++v9;
    reportIntrusionAttempt();
    if ( v9 == 3 )
      notifyAdministrator();
    printf("Invalid login attempt. You have %d login attempts left.\n", (unsigned int)(3 - v9));
  }
  return 0;
}
// 140001740: using guessed type void __fastcall __noreturn systemError(_QWORD);
// 140001763: using guessed type __int64 reportIntrusionAttempt(void);
// 140001805: using guessed type __int64 notifyAdministrator(void);
// 140001950: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001625: using guessed type char anonymous_0[28];
// 140001625: using guessed type char anonymous_1[28];

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Phone Book ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Define surreal phone book data structure */
typedef struct surrealist_phonebook {
    char* name;
    char* phone_number;
    char* favorite_food;
    char* dream_destination;
    char* favorite_color;
} Surrealist_Phonebook;

int main() {
    Surrealist_Phonebook* contacts = NULL;
    int num_contacts = 0;
    char input[256];

    printf("Welcome to the Surrealist Phone Book!\n");

    /* Loop through menu options until exit is chosen */
    while (1) {
        printf("Please choose an option:\n");
        printf("1. Add new contact\n");
        printf("2. View existing contacts\n");
        printf("3. Exit\n");
        fgets(input, 256, stdin);
        input[strlen(input) - 1] = '\0';

        /* Add new contact */
        if (strcmp(input, "1") == 0) {
            contacts = realloc(contacts, (num_contacts + 1) * sizeof(Surrealist_Phonebook));
            Surrealist_Phonebook new_contact;

            printf("What is the name of your new contact?\n");
            fgets(input, 256, stdin);
            input[strlen(input) - 1] = '\0';
            new_contact.name = strdup(input);

            printf("What is the phone number for %s?\n", new_contact.name);
            fgets(input, 256, stdin);
            input[strlen(input) - 1] = '\0';
            new_contact.phone_number = strdup(input);

            printf("What is %s's favorite food?\n", new_contact.name);
            fgets(input, 256, stdin);
            input[strlen(input) - 1] = '\0';
            new_contact.favorite_food = strdup(input);

            printf("What is %s's dream destination?\n", new_contact.name);
            fgets(input, 256, stdin);
            input[strlen(input) - 1] = '\0';
            new_contact.dream_destination = strdup(input);

            printf("What is %s's favorite color?\n", new_contact.name);
            fgets(input, 256, stdin);
            input[strlen(input) - 1] = '\0';
            new_contact.favorite_color = strdup(input);

            contacts[num_contacts++] = new_contact;
            printf("New contact %s added to the phone book!\n", new_contact.name);
        }

        /* View existing contacts */
        else if (strcmp(input, "2") == 0) {
            if (num_contacts == 0) {
                printf("There are no contacts in the phone book!\n");
            }
            else {
                printf("Here are the contacts stored in the phone book:\n");

                for (int i = 0; i < num_contacts; i++) {
                    Surrealist_Phonebook current_contact = contacts[i];

                    printf("Name: %s\n", current_contact.name);
                    printf("Phone number: %s\n", current_contact.phone_number);
                    printf("Favorite food: %s\n", current_contact.favorite_food);
                    printf("Dream destination: %s\n", current_contact.dream_destination);
                    printf("Favorite color: %s\n\n", current_contact.favorite_color);
                }
            }
        }

        /* Exit */
        else if (strcmp(input, "3") == 0) {
            printf("Thank you for using the Surrealist Phone Book!\n");
            for (int i = 0; i < num_contacts; i++) {
                free(contacts[i].name);
                free(contacts[i].phone_number);
                free(contacts[i].favorite_food);
                free(contacts[i].dream_destination);
                free(contacts[i].favorite_color);
            }
            free(contacts);
            break;
        }

        /* Invalid input */
        else {
            printf("Incorrect input, please try again.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strdup(const char *String);
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl realloc(void *Block, size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  FILE *v6; // rax
  FILE *v7; // rax
  FILE *v8; // rax
  int v9; // eax
  char **v10; // rax
  __int64 v11; // rdx
  char *v13; // [rsp+20h] [rbp-60h]
  char *v14; // [rsp+28h] [rbp-58h]
  const char *v15; // [rsp+28h] [rbp-58h]
  char *v16; // [rsp+30h] [rbp-50h]
  const char *v17; // [rsp+30h] [rbp-50h]
  char *v18; // [rsp+38h] [rbp-48h]
  const char *v19; // [rsp+38h] [rbp-48h]
  char *v20; // [rsp+40h] [rbp-40h]
  const char *v21; // [rsp+40h] [rbp-40h]
  char Buffer[268]; // [rsp+50h] [rbp-30h] BYREF
  int j; // [rsp+15Ch] [rbp+DCh]
  int i; // [rsp+160h] [rbp+E0h]
  int v25; // [rsp+164h] [rbp+E4h]
  void *Block; // [rsp+168h] [rbp+E8h]

  _main(argc, argv, envp);
  Block = 0i64;
  v25 = 0;
  printf("Welcome to the Surrealist Phone Book!\n");
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        printf("Please choose an option:\n");
        printf("1. Add new contact\n");
        printf("2. View existing contacts\n");
        printf("3. Exit\n");
        v3 = __acrt_iob_func(0);
        fgets(Buffer, 256, v3);
        Buffer[strlen(Buffer) - 1] = 0;
        if ( strcmp(Buffer, "1") )
          break;
        Block = realloc(Block, 40i64 * (v25 + 1));
        printf("What is the name of your new contact?\n");
        v4 = __acrt_iob_func(0);
        fgets(Buffer, 256, v4);
        Buffer[strlen(Buffer) - 1] = 0;
        v13 = strdup(Buffer);
        printf("What is the phone number for %s?\n", v13);
        v5 = __acrt_iob_func(0);
        fgets(Buffer, 256, v5);
        Buffer[strlen(Buffer) - 1] = 0;
        v14 = strdup(Buffer);
        printf("What is %s's favorite food?\n", v13);
        v6 = __acrt_iob_func(0);
        fgets(Buffer, 256, v6);
        Buffer[strlen(Buffer) - 1] = 0;
        v16 = strdup(Buffer);
        printf("What is %s's dream destination?\n", v13);
        v7 = __acrt_iob_func(0);
        fgets(Buffer, 256, v7);
        Buffer[strlen(Buffer) - 1] = 0;
        v18 = strdup(Buffer);
        printf("What is %s's favorite color?\n", v13);
        v8 = __acrt_iob_func(0);
        fgets(Buffer, 256, v8);
        Buffer[strlen(Buffer) - 1] = 0;
        v20 = strdup(Buffer);
        v9 = v25++;
        v10 = (char **)((char *)Block + 40 * v9);
        *v10 = v13;
        v10[1] = v14;
        v10[2] = v16;
        v10[3] = v18;
        v10[4] = v20;
        printf("New contact %s added to the phone book!\n", v13);
      }
      if ( strcmp(Buffer, "2") )
        break;
      if ( v25 )
      {
        printf("Here are the contacts stored in the phone book:\n");
        for ( i = 0; i < v25; ++i )
        {
          v11 = 40i64 * i;
          v15 = *(const char **)((char *)Block + v11 + 8);
          v17 = *(const char **)((char *)Block + v11 + 16);
          v19 = *(const char **)((char *)Block + v11 + 24);
          v21 = *(const char **)((char *)Block + v11 + 32);
          printf("Name: %s\n", *(const char **)((char *)Block + v11));
          printf("Phone number: %s\n", v15);
          printf("Favorite food: %s\n", v17);
          printf("Dream destination: %s\n", v19);
          printf("Favorite color: %s\n\n", v21);
        }
      }
      else
      {
        printf("There are no contacts in the phone book!\n");
      }
    }
    if ( !strcmp(Buffer, "3") )
      break;
    printf("Incorrect input, please try again.\n");
  }
  printf("Thank you for using the Surrealist Phone Book!\n");
  for ( j = 0; j < v25; ++j )
  {
    free(*((void **)Block + 5 * j));
    free(*((void **)Block + 5 * j + 1));
    free(*((void **)Block + 5 * j + 2));
    free(*((void **)Block + 5 * j + 3));
    free(*((void **)Block + 5 * j + 4));
  }
  free(Block);
  return 0;
}
// 140001C30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[268];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Personal Finance Planner ; Style: realistic
#include <stdio.h>
#include <stdlib.h>

float get_income() {
    float income;
    printf("Enter your monthly income: ");
    scanf("%f", &income);
    return income;
}

float get_expenses() {
    float expenses;
    printf("Enter your monthly expenses: ");
    scanf("%f", &expenses);
    return expenses;
}

void display_menu() {
    printf("\nPersonal Finance Planner Menu\n");
    printf("-----------------------------\n");
    printf("1. Calculate monthly budget\n");
    printf("2. Display savings goal\n");
    printf("3. Exit\n");
}

void calculate_budget(float income, float expenses) {
    float budget = income - expenses;
    if (budget >= 0) {
        printf("You have a monthly budget of $%.2f\n", budget);
    } else {
        printf("You are in a deficit of $%.2f\n", budget);
    }
}

void display_goal(float income, float expenses) {
    float goal = (income - expenses) * 12;
    printf("Your annual savings goal is $%.2f\n", goal);
}

int main() {

    float income = get_income();
    float expenses = get_expenses();

    int choice = 0;
    while (choice != 3) {

        display_menu();
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                calculate_budget(income, expenses);
                break;
            case 2:
                display_goal(income, expenses);
                break;
            case 3:
                printf("Goodbye!\n");
                break;
            default:
                printf("Invalid choice\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
double get_income(void); // weak
double get_expenses(void); // weak
__int64 display_menu(void); // weak
__int64 calculate_budget(void); // weak
__int64 display_goal(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000179F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  int v5[3]; // [rsp+24h] [rbp-Ch] BYREF

  _main(argc, argv, envp);
  *(double *)v3.m128i_i64 = get_income();
  v5[2] = _mm_cvtsi128_si32(v3);
  *(double *)v3.m128i_i64 = get_expenses();
  v5[1] = _mm_cvtsi128_si32(v3);
  v5[0] = 0;
  while ( v5[0] != 3 )
  {
    display_menu();
    printf("Enter your choice: ");
    scanf("%d", v5);
    if ( v5[0] == 3 )
    {
      printf("Goodbye!\n");
    }
    else
    {
      if ( v5[0] > 3 )
        goto LABEL_10;
      if ( v5[0] == 1 )
      {
        calculate_budget();
      }
      else if ( v5[0] == 2 )
      {
        display_goal();
      }
      else
      {
LABEL_10:
        printf("Invalid choice\n");
      }
    }
  }
  return 0;
}
// 1400017B1: variable 'v3' is possibly undefined
// 1400015E2: using guessed type double get_income(void);
// 14000161A: using guessed type double get_expenses(void);
// 140001652: using guessed type __int64 display_menu(void);
// 1400016AC: using guessed type __int64 calculate_budget(void);
// 14000173C: using guessed type __int64 display_goal(void);
// 140001930: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_FLOORS 10
#define MAX_PASSENGERS 5

int elevatorPosition = 0; // Current floor of the elevator
int passengerDestinations[MAX_PASSENGERS] = {0}; // Array of passenger destinations
int numPassengers = 0; // Number of passengers in the elevator

// Function to generate a random number between min and max (inclusive)
int getRandomNumber(int min, int max) {
    return (rand() % (max - min + 1)) + min; 
}

// Function to simulate the elevator movement
void moveElevator(int floor) {
    printf("The elevator is on floor %d\n", floor);
    elevatorPosition = floor;
}

// Function to add a passenger to the elevator
void addPassenger(int destination) {
    if (numPassengers < MAX_PASSENGERS) {
        printf("A passenger has entered the elevator and wants to go to floor %d\n", destination);
        passengerDestinations[numPassengers] = destination;
        numPassengers++;
    } else {
        printf("The elevator is at full capacity\n");
    }
}

// Function to remove a passenger from the elevator
void removePassenger(int index) {
    printf("A passenger has reached their destination and has left the elevator on floor %d\n", elevatorPosition);
    numPassengers--;
    for (int i = index; i < numPassengers; i++) {
        passengerDestinations[i] = passengerDestinations[i+1];
    }
}

int main() {
    srand(time(NULL)); // Seed the random number generato

    while (1) {
        // Generate a random floor to simulate a passenger call button press
        int pressedFloor = getRandomNumber(1, MAX_FLOORS);
        printf("Someone has pressed the elevator button on floor %d\n", pressedFloor);

        // Determine the direction the elevator needs to travel to reach the passenger
        int direction = pressedFloor - elevatorPosition;
        if (direction > 0) {
            printf("The elevator is moving up\n");
            for (int i = elevatorPosition + 1; i <= pressedFloor; i++) {
                moveElevator(i);
            }
        } else if (direction < 0) {
            printf("The elevator is moving down\n");
            for (int i = elevatorPosition - 1; i >= pressedFloor; i--) {
                moveElevator(i);
            }
        } else {
            printf("The elevator is already on the requested floor\n");
        }

        // Generate a random number of passengers to simulate entering the elevator
        int numNewPassengers = getRandomNumber(1, MAX_PASSENGERS - numPassengers);
        for (int i = 0; i < numNewPassengers; i++) {
            int destination = getRandomNumber(1, MAX_FLOORS);
            addPassenger(destination);
        }

        // Drop off passengers whose destination is the current floor
        for (int i = 0; i < numPassengers; i++) {
            if (passengerDestinations[i] == elevatorPosition) {
                removePassenger(i);
            }
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall getRandomNumber(_QWORD, _QWORD); // weak
__int64 __fastcall moveElevator(_QWORD); // weak
__int64 __fastcall addPassenger(_QWORD); // weak
__int64 __fastcall removePassenger(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

int elevatorPosition; // weak
_DWORD passengerDestinations[5]; // weak
int numPassengers; // weak


//----- (00000001400016F5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+20h] [rbp-20h]
  int v6; // [rsp+24h] [rbp-1Ch]
  int RandomNumber; // [rsp+2Ch] [rbp-14h]
  int m; // [rsp+30h] [rbp-10h]
  int k; // [rsp+34h] [rbp-Ch]
  int i; // [rsp+38h] [rbp-8h]
  int j; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  while ( 1 )
  {
    RandomNumber = getRandomNumber(1i64, 10i64);
    printf("Someone has pressed the elevator button on floor %d\n", (unsigned int)RandomNumber);
    if ( RandomNumber - elevatorPosition <= 0 )
    {
      if ( RandomNumber - elevatorPosition >= 0 )
      {
        printf("The elevator is already on the requested floor\n");
      }
      else
      {
        printf("The elevator is moving down\n");
        for ( i = elevatorPosition - 1; i >= RandomNumber; --i )
          moveElevator((unsigned int)i);
      }
    }
    else
    {
      printf("The elevator is moving up\n");
      for ( j = elevatorPosition + 1; j <= RandomNumber; ++j )
        moveElevator((unsigned int)j);
    }
    v6 = getRandomNumber(1i64, (unsigned int)(5 - numPassengers));
    for ( k = 0; k < v6; ++k )
    {
      v5 = getRandomNumber(1i64, 10i64);
      addPassenger(v5);
    }
    for ( m = 0; m < numPassengers; ++m )
    {
      if ( passengerDestinations[m] == elevatorPosition )
        removePassenger((unsigned int)m);
    }
  }
}
// 1400015B0: using guessed type __int64 __fastcall getRandomNumber(_QWORD, _QWORD);
// 1400015DA: using guessed type __int64 __fastcall moveElevator(_QWORD);
// 140001607: using guessed type __int64 __fastcall addPassenger(_QWORD);
// 140001673: using guessed type __int64 __fastcall removePassenger(_QWORD);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type int elevatorPosition;
// 14000F050: using guessed type _DWORD passengerDestinations[5];
// 14000F064: using guessed type int numPassengers;

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: peaceful
#include <stdio.h>
#include <string.h>

struct DiaryEntry {
    int day;
    int month;
    int year;
    char entry[1000];
};

int main() {
    struct DiaryEntry diary[365];
    int choice = 0;
    int entries = 0;
    int i;

    while (1) {
        printf("1. New Entry\n");
        printf("2. Display Entries\n");
        printf("3. Quit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                if (entries < 365) {
                    printf("Enter the date of entry (DD MM YYYY): ");
                    scanf("%d %d %d", &diary[entries].day, &diary[entries].month, &diary[entries].year);
                    printf("Enter your entry: ");
                    getchar();
                    fgets(diary[entries].entry, sizeof(diary[entries].entry), stdin);
                    entries++;
                } else {
                    printf("Sorry, diary is full.\n");
                }
                break;
            case 2:
                for (i = 0; i < entries; i++) {
                    printf("%d/%d/%d: %s", diary[i].day, diary[i].month, diary[i].year, diary[i].entry);
                }
                break;
            case 3:
                printf("Exiting...\n");
                return 0;
            default:
                printf("Invalid choice.\n");
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v5[17]; // [rsp+3Ch] [rbp-44h] BYREF
  _BYTE v6[369320]; // [rsp+80h] [rbp+0h] BYREF
  int i; // [rsp+5A328h] [rbp+5A2A8h]
  int v8; // [rsp+5A32Ch] [rbp+5A2ACh]

  _main(argc, argv, envp);
  v5[0] = 0;
  v8 = 0;
  while ( 1 )
  {
    printf("1. New Entry\n");
    printf("2. Display Entries\n");
    printf("3. Quit\n");
    printf("Enter your choice: ");
    scanf("%d", v5);
    if ( v5[0] == 3 )
      break;
    if ( v5[0] > 3 )
      goto LABEL_15;
    if ( v5[0] == 1 )
    {
      if ( v8 > 364 )
      {
        printf("Sorry, diary is full.\n");
      }
      else
      {
        printf("Enter the date of entry (DD MM YYYY): ");
        scanf("%d %d %d", &v5[253 * v8 + 1], &v5[253 * v8 + 2], &v5[253 * v8 + 3]);
        printf("Enter your entry: ");
        getchar();
        v3 = __acrt_iob_func(0);
        fgets((char *)&v5[253 * v8++ + 4], 1000, v3);
      }
    }
    else if ( v5[0] == 2 )
    {
      for ( i = 0; i < v8; ++i )
        printf(
          "%d/%d/%d: %s",
          *(unsigned int *)&v6[1012 * i - 64],
          *(unsigned int *)&v6[1012 * i - 60],
          *(unsigned int *)&v6[1012 * i - 56],
          (const char *)&v5[253 * i + 4]);
    }
    else
    {
LABEL_15:
      printf("Invalid choice.\n");
    }
  }
  printf("Exiting...\n");
  return 0;
}
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System event logger ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Define the structure for a log entry
typedef struct {
  time_t timestamp;      // The time the event occurred
  char *source;          // The source of the event
  char *message;         // The message associated with the event
} LogEntry;

// Define a function that creates and returns a new LogEntry
LogEntry *create_log_entry(char *source, char *message) {
  LogEntry *entry = malloc(sizeof(LogEntry));
  entry->timestamp = time(NULL);
  entry->source = strdup(source);
  entry->message = strdup(message);
  return entry;
}

// Define a function that prints a log entry to stdout
void print_log_entry(LogEntry *entry) {
  printf("[%ld] %s: %s\n", entry->timestamp, entry->source, entry->message);
}

// Define the structure for the node in the decentralized log
typedef struct node Node;
struct node {
  LogEntry *entry;
  Node *next;
};

// Define the structure for a decentralized log
typedef struct {
  Node *head;
  int size;
} DecentralizedLog;

// Define a function that initializes a DecentralizedLog
void init_decentralized_log(DecentralizedLog *log) {
  log->head = NULL;
  log->size = 0;
}

// Define a function that adds a LogEntry to a DecentralizedLog
void add_log_entry(DecentralizedLog *log, LogEntry *entry) {
  Node *new_node = malloc(sizeof(Node));
  new_node->entry = entry;
  new_node->next = log->head;
  log->head = new_node;
  log->size++;
}

// Define a function that prints a DecentralizedLog to stdout
void print_decentralized_log(DecentralizedLog *log) {
  Node *current = log->head;
  while (current != NULL) {
    print_log_entry(current->entry);
    current = current->next;
  }
}

int main() {
  // Initialize a DecentralizedLog
  DecentralizedLog log;
  init_decentralized_log(&log);

  // Create and add some LogEntries
  LogEntry *entry1 = create_log_entry("System", "Program started");
  LogEntry *entry2 = create_log_entry("Network", "Connection established");
  LogEntry *entry3 = create_log_entry("System", "Program exiting");
  add_log_entry(&log, entry1);
  add_log_entry(&log, entry2);
  add_log_entry(&log, entry3);

  // Print the DecentralizedLog
  print_decentralized_log(&log);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall create_log_entry(_QWORD, _QWORD); // weak
__int64 __fastcall init_decentralized_log(_QWORD); // weak
__int64 __fastcall add_log_entry(_QWORD, _QWORD); // weak
__int64 __fastcall print_decentralized_log(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001715) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[24]; // [rsp+20h] [rbp-30h] BYREF
  __int64 v5; // [rsp+38h] [rbp-18h]
  __int64 v6; // [rsp+40h] [rbp-10h]
  __int64 log_entry; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  init_decentralized_log(v4);
  log_entry = create_log_entry("System", "Program started");
  v6 = create_log_entry("Network", "Connection established");
  v5 = create_log_entry("System", "Program exiting");
  add_log_entry(v4, log_entry);
  add_log_entry(v4, v6);
  add_log_entry(v4, v5);
  print_decentralized_log(v4);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall create_log_entry(_QWORD, _QWORD);
// 140001656: using guessed type __int64 __fastcall init_decentralized_log(_QWORD);
// 140001677: using guessed type __int64 __fastcall add_log_entry(_QWORD, _QWORD);
// 1400016D2: using guessed type __int64 __fastcall print_decentralized_log(_QWORD);
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Math exercise ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * This program generates two random numbers between 1 to 100 and asks the user to
 * input the correct answer to their sum. If the user inputs the correct answer,
 * the program prints "Correct" and generates a new set of random numbers. If the user inputs
 * the incorrect answer, the program prints "Incorrect" and terminates.
 */

int get_random_number() {
    srand(time(NULL)); // seed the random number generator
    return rand() % 100 + 1; // generate a random number between 1 to 100
}

int get_sum(int num1, int num2) {
    return num1 + num2;
}

void main() {
    int num1 = get_random_number();
    int num2 = get_random_number();

    while(1) {
        printf("What is the sum of %d and %d: ", num1, num2);
        int answer;
        scanf("%d", &answer);

        if(answer == get_sum(num1, num2)) {
            printf("Correct!\n");
            num1 = get_random_number();
            num2 = get_random_number();
        } else {
            printf("Incorrect, the correct answer is %d\n", get_sum(num1, num2));
            break;
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 get_random_number(void); // weak
__int64 __fastcall get_sum(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000165B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int sum; // eax
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int random_number; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  random_number = get_random_number();
  for ( i = get_random_number(); ; i = get_random_number() )
  {
    printf("What is the sum of %d and %d: ", random_number, i);
    scanf("%d", &v5);
    if ( (unsigned int)get_sum(random_number, i) != v5 )
      break;
    printf("Correct!\n");
    random_number = get_random_number();
  }
  sum = get_sum(random_number, i);
  return printf("Incorrect, the correct answer is %d\n", sum);
}
// 140001601: using guessed type __int64 get_random_number(void);
// 140001647: using guessed type __int64 __fastcall get_sum(_QWORD, _QWORD);
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Clustering Algorithm Implementation ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAX_ITERATIONS 10000
#define MIN_DISTANCE 0.001

typedef struct {
    double x;
    double y;
} point;

typedef struct {
    point centroid;
    int count;
} cluster;

double distance(point p1, point p2) {
    double dx = p1.x - p2.x;
    double dy = p1.y - p2.y;
    return sqrt(dx*dx + dy*dy);
}

void kMeans(point dataset[], int num_points, int num_clusters) {
    cluster* clusters = (cluster*)malloc(num_clusters * sizeof(cluster));
    // Initialize the clusters with randomly selected points from the dataset
    for (int i = 0; i < num_clusters; i++) {
        int random_index = rand() % num_points;
        clusters[i].centroid = dataset[random_index];
        clusters[i].count = 0;
    }
    int iteration = 0;
    while (iteration < MAX_ITERATIONS) {
        // Assign each point to the nearest cluster
        for (int i = 0; i < num_points; i++) {
            point p = dataset[i];
            int closest_cluster_index = 0;
            double closest_distance = distance(p, clusters[0].centroid);
            for (int j = 1; j < num_clusters; j++) {
                double d = distance(p, clusters[j].centroid);
                if (d < closest_distance) {
                    closest_cluster_index = j;
                    closest_distance = d;
                }
            }
            clusters[closest_cluster_index].count++;
        }
        // Recompute the centroids of each cluster
        int changes = 0;
        for (int i = 0; i < num_clusters; i++) {
            point old_centroid = clusters[i].centroid;
            double avg_x = 0, avg_y = 0;
            if (clusters[i].count > 0) {
                for (int j = 0; j < num_points; j++) {
                    if (dataset[j].x == clusters[i].centroid.x && dataset[j].y == clusters[i].centroid.y) {
                        continue;
                    }
                    if (distance(dataset[j], clusters[i].centroid) < MIN_DISTANCE) {
                        avg_x += dataset[j].x;
                        avg_y += dataset[j].y;
                        clusters[i].count++;
                    }
                }
                if (clusters[i].count > 0) {
                    clusters[i].centroid.x = avg_x / clusters[i].count;
                    clusters[i].centroid.y = avg_y / clusters[i].count;
                }
            }
            if (distance(old_centroid, clusters[i].centroid) > 0) {
                changes++;
            }
        }
        if (changes == 0) {
            break;
        }
        iteration++;
    }
    // Print the results
    for (int i = 0; i < num_clusters; i++) {
        printf("Cluster %d:\n", i+1);
        printf("Centroid: (%f, %f)\n", clusters[i].centroid.x, clusters[i].centroid.y);
        printf("Count: %d\n", clusters[i].count);
        printf("Points: ");
        for (int j = 0; j < num_points; j++) {
            if (dataset[j].x == clusters[i].centroid.x && dataset[j].y == clusters[i].centroid.y) {
                continue;
            }
            if (distance(dataset[j], clusters[i].centroid) < MIN_DISTANCE) {
                printf("(%f, %f) ", dataset[j].x, dataset[j].y);
            }
        }
        printf("\n");
    }
    free(clusters);
}

int main() {
    // Generate a dataset of random points
    point dataset[100];
    for (int i = 0; i < 100; i++) {
        dataset[i].x = (double)rand()/RAND_MAX*10;
        dataset[i].y = (double)rand()/RAND_MAX*10;
    }
    // Cluster the dataset into 4 clusters
    kMeans(dataset, 100, 4);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall kMeans(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();


//----- (0000000140001E6D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[96]; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v5[1516]; // [rsp+80h] [rbp+0h] BYREF
  int i; // [rsp+66Ch] [rbp+5ECh]

  _main(argc, argv, envp);
  for ( i = 0; i <= 99; ++i )
  {
    *(double *)&v5[16 * i - 96] = 10.0 * ((double)rand() / 32767.0);
    *(double *)&v5[16 * i - 88] = 10.0 * ((double)rand() / 32767.0);
  }
  kMeans(v4, 100i64, 4i64);
  return 0;
}
// 140001620: using guessed type __int64 __fastcall kMeans(_QWORD, _QWORD, _QWORD);
// 140002010: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001E6D: using guessed type char var_650[96];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File system simulation ; Style: Cyberpunk
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_FILES 10
#define MAX_FILENAME_SIZE 20
#define MAX_FILE_SIZE 1024

typedef struct {
    char filename[MAX_FILENAME_SIZE];
    int size;
    char data[MAX_FILE_SIZE];
} File;

typedef struct {
    char name[MAX_FILENAME_SIZE];
    File files[MAX_FILES];
    int file_count;
    int used_space;
} Directory;

Directory root;

void create_file(char* filename, char* data, int size) {
    if (root.file_count >= MAX_FILES) {
        printf("File system full.\n");
        return;
    }
    File new_file;
    strcpy(new_file.filename, filename);
    new_file.size = size;
    strcpy(new_file.data, data);
    root.files[root.file_count++] = new_file;
    root.used_space += size;
    printf("File %s created.\n", filename);
}

void delete_file(char* filename) {
    int i;
    for (i = 0; i < root.file_count; i++) {
        if (strcmp(root.files[i].filename, filename) == 0) {
            root.used_space -= root.files[i].size;
            int j;
            for (j = i; j < root.file_count - 1; j++) {
                root.files[j] = root.files[j + 1];
            }
            root.file_count--;
            printf("File %s deleted.\n", filename);
            return;
        }
    }
    printf("File not found.\n");
}

void list_files() {
    int i;
    for (i = 0; i < root.file_count; i++) {
        printf("%s (%d bytes)\n", root.files[i].filename, root.files[i].size);
    }
    printf("%d/%d files (%d/%d bytes used)\n", root.file_count, MAX_FILES, root.used_space, MAX_FILES * MAX_FILE_SIZE);
}

int main() {
    strcpy(root.name, "root");
    root.file_count = 0;
    root.used_space = 0;
    
    printf("Welcome to Cyberfile.\n");
    printf("Enter a command (create [filename] [size] [data], delete [filename], list):\n");
    
    char input[100];
    char command[10], filename[MAX_FILENAME_SIZE], data[MAX_FILE_SIZE];
    int size;
    
    while (fgets(input, 100, stdin)) {
        sscanf(input, "%s %s %d %[^\n]", command, filename, &size, data);
        if (strcmp(command, "create") == 0) {
            create_file(filename, data, size);
        } else if (strcmp(command, "delete") == 0) {
            delete_file(filename);
        } else if (strcmp(command, "list") == 0) {
            list_files();
        } else {
            printf("Invalid command.\n");
        }
        printf("Enter a command (create [filename] [size] [data], delete [filename], list):\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sscanf(const char *const Buffer, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall create_file(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall delete_file(_QWORD); // weak
__int64 list_files(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

int root; // weak
int dword_14001B944; // weak
int dword_14001B948; // weak


//----- (0000000140001902) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v5; // [rsp+3Ch] [rbp-44h] BYREF
  char v6[1024]; // [rsp+40h] [rbp-40h] BYREF
  char v7[22]; // [rsp+440h] [rbp+3C0h] BYREF
  char Str1[10]; // [rsp+456h] [rbp+3D6h] BYREF
  char Buffer[112]; // [rsp+460h] [rbp+3E0h] BYREF

  _main(argc, argv, envp);
  strcpy((char *)&root, "root");
  dword_14001B944 = 0;
  dword_14001B948 = 0;
  printf("Welcome to Cyberfile.\n");
  printf("Enter a command (create [filename] [size] [data], delete [filename], list):\n");
  while ( 1 )
  {
    v3 = __acrt_iob_func(0);
    if ( !fgets(Buffer, 100, v3) )
      break;
    sscanf(Buffer, "%s %s %d %[^\n]", Str1, v7, &v5, v6);
    if ( !strcmp(Str1, "create") )
    {
      create_file(v7, v6, v5);
    }
    else if ( !strcmp(Str1, "delete") )
    {
      delete_file(v7);
    }
    else if ( !strcmp(Str1, "list") )
    {
      list_files();
    }
    else
    {
      printf("Invalid command.\n");
    }
    printf("Enter a command (create [filename] [size] [data], delete [filename], list):\n");
  }
  return 0;
}
// 1400015D4: using guessed type __int64 __fastcall create_file(_QWORD, _QWORD, _QWORD);
// 1400016FA: using guessed type __int64 __fastcall delete_file(_QWORD);
// 140001864: using guessed type __int64 list_files(void);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019040: using guessed type int root;
// 14001B944: using guessed type int dword_14001B944;
// 14001B948: using guessed type int dword_14001B948;
// 140001902: using guessed type char var_490[1024];

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>

#define NUM_FLOORS 10 // Number of floors in our building
#define NUM_ELEVATORS 2 // Number of elevators in our building

enum State { IDLE, MOVING_UP, MOVING_DOWN, OPENING_DOORS, CLOSING_DOORS };

struct Elevator {
    int id;
    int current_floor;
    enum State state;
    int destination;
};

struct Floor {
    int floor_number;
    int waiting_passengers;
    enum State elevator_state[NUM_ELEVATORS];
};

struct Building {
    struct Elevator elevators[NUM_ELEVATORS];
    struct Floor floors[NUM_FLOORS];
};

void init_building(struct Building* building);
void print_elevator_state(struct Elevator elevator);
void print_floor_state(struct Floor floor);
void print_building_state(struct Building* building);
void elevator_tick(struct Elevator* elevator);
void floor_tick(struct Floor* floor, struct Elevator* elevators, int num_elevators);
void building_tick(struct Building* building);
void passenger_arrives(struct Floor* floor);
void set_destination(struct Elevator* elevator, int floor);

int main() {
    struct Building building;
    init_building(&building);

    printf("Initial state of the building:\n");
    print_building_state(&building);

    printf("\nPress Enter to start the simulation...\n");
    getchar();

    while (1) {
        // Generate some passengers randomly
        for (int i = 0; i < NUM_FLOORS; ++i) {
            if (rand() % 10 < 4) {
                passenger_arrives(&building.floors[i]);
            }
        }

        building_tick(&building);

        print_building_state(&building);

        printf("\nPress Enter to continue...\n");
        getchar();
    }

    return 0;
}

void init_building(struct Building* building) {
    // Initialize elevators
    for (int i = 0; i < NUM_ELEVATORS; ++i) {
        building->elevators[i].id = i;
        building->elevators[i].current_floor = 0;
        building->elevators[i].state = IDLE;
        building->elevators[i].destination = -1;
    }

    // Initialize floors
    for (int i = 0; i < NUM_FLOORS; ++i) {
        building->floors[i].floor_number = i;
        building->floors[i].waiting_passengers = 0;
        for (int j = 0; j < NUM_ELEVATORS; ++j) {
            building->floors[i].elevator_state[j] = IDLE;
        }
    }
}

void print_elevator_state(struct Elevator elevator) {
    printf("Elevator %d: %d -> %d (%s)\n", elevator.id, elevator.current_floor,
            elevator.destination, elevator.state == IDLE ? "idle" :
            elevator.state == MOVING_UP ? "moving up" :
            elevator.state == MOVING_DOWN ? "moving down" :
            elevator.state == OPENING_DOORS ? "opening doors" :
            elevator.state == CLOSING_DOORS ? "closing doors" : "");
}

void print_floor_state(struct Floor floor) {
    printf("Floor %d: %d passengers waiting\n", floor.floor_number, floor.waiting_passengers);
}

void print_building_state(struct Building* building) {
    printf("\n");
    for (int i = NUM_FLOORS - 1; i >= 0; --i) {
        print_floor_state(building->floors[i]);
    }
    printf("\n");
    for (int i = 0; i < NUM_ELEVATORS; ++i) {
        print_elevator_state(building->elevators[i]);
    }
}

void elevator_tick(struct Elevator* elevator) {
    switch (elevator->state) {
        case IDLE:
            if (elevator->destination != -1 && elevator->destination > elevator->current_floor) {
                elevator->state = MOVING_UP;
            } else if (elevator->destination != -1 && elevator->destination < elevator->current_floor) {
                elevator->state = MOVING_DOWN;
            }
            break;
        case MOVING_UP:
            elevator->current_floor++;
            if (elevator->current_floor == elevator->destination) {
                elevator->state = OPENING_DOORS;
            }
            break;
        case MOVING_DOWN:
            elevator->current_floor--;
            if (elevator->current_floor == elevator->destination) {
                elevator->state = OPENING_DOORS;
            }
            break;
        case OPENING_DOORS:
            elevator->state = CLOSING_DOORS;
            break;
        case CLOSING_DOORS:
            elevator->state = IDLE;
            elevator->destination = -1;
            break;
    }
}

void floor_tick(struct Floor* floor, struct Elevator* elevators, int num_elevators) {
    for (int i = 0; i < num_elevators; ++i) {
        if (elevators[i].current_floor == floor->floor_number) {
            floor->elevator_state[i] = OPENING_DOORS;
            elevators[i].destination = -1;
        } else if (floor->elevator_state[i] != CLOSING_DOORS) {
            floor->elevator_state[i] = IDLE;
        }
    }

    if (floor->waiting_passengers > 0) {
        for (int i = 0; i < num_elevators; ++i) {
            if (elevators[i].state == IDLE) {
                set_destination(&elevators[i], floor->floor_number);
                elevators[i].state = floor->floor_number < elevators[i].current_floor ? MOVING_DOWN :
                        floor->floor_number > elevators[i].current_floor ? MOVING_UP : IDLE;
                floor->waiting_passengers--;
                break;
            }
        }
    }
}

void building_tick(struct Building* building) {
    for (int i = 0; i < NUM_ELEVATORS; ++i) {
        elevator_tick(&building->elevators[i]);
    }

    for (int i = 0; i < NUM_FLOORS; ++i) {
        floor_tick(&building->floors[i], building->elevators, NUM_ELEVATORS);
    }
}

void passenger_arrives(struct Floor* floor) {
    floor->waiting_passengers++;
}

void set_destination(struct Elevator* elevator, int floor) {
    elevator->destination = floor;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall init_building(_QWORD); // weak
__int64 __fastcall print_building_state(_QWORD); // weak
__int64 __fastcall building_tick(_QWORD); // weak
__int64 __fastcall passenger_arrives(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();
// int __cdecl getchar();


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _OWORD v4[12]; // [rsp+20h] [rbp-D0h] BYREF
  int i; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  init_building(v4);
  printf("Initial state of the building:\n");
  print_building_state(v4);
  printf("\nPress Enter to start the simulation...\n");
  getchar();
  while ( 1 )
  {
    for ( i = 0; i <= 9; ++i )
    {
      if ( rand() % 10 <= 3 )
        passenger_arrives(&v4[i + 2]);
    }
    building_tick(v4);
    print_building_state(v4);
    printf("\nPress Enter to continue...\n");
    getchar();
  }
}
// 140001681: using guessed type __int64 __fastcall init_building(_QWORD);
// 14000186E: using guessed type __int64 __fastcall print_building_state(_QWORD);
// 140001BD1: using guessed type __int64 __fastcall building_tick(_QWORD);
// 140001C50: using guessed type __int64 __fastcall passenger_arrives(_QWORD);
// 140001D40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=148 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *file_ptr;
    char filename[50], text[100];

    // Get the file name from the user
    printf("Enter the filename: ");
    scanf("%s", filename);

    // Open the file
    file_ptr = fopen(filename, "w");

    // Check if the file was opened successfully
    if (file_ptr == NULL) {
        printf("Error opening file\n");
        exit(1);
    }

    // Get text input from the user
    printf("Enter some text: ");
    scanf("%s", text);

    // Write the text to the file
    fprintf(file_ptr, "%s", text);

    // Close the file
    fclose(file_ptr);

    // Re-open the file to read the contents
    file_ptr = fopen(filename, "r");

    // Check if the file was opened successfully
    if (file_ptr == NULL) {
        printf("Error opening file\n");
        exit(1);
    }

    // Read the contents of the file and print it to the screen
    printf("Contents of file %s:\n", filename);
    while (fgets(text, sizeof(text), file_ptr)) {
        printf("%s", text);
    }

    // Close the file
    fclose(file_ptr);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[112]; // [rsp+20h] [rbp-B0h] BYREF
  char FileName[56]; // [rsp+90h] [rbp-40h] BYREF
  FILE *Stream; // [rsp+C8h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter the filename: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "w");
  if ( !Stream )
  {
    printf("Error opening file\n");
    exit(1);
  }
  printf("Enter some text: ");
  scanf("%s", Buffer);
  fprintf_0(Stream, "%s", Buffer);
  fclose(Stream);
  Stream = fopen(FileName, "r");
  if ( !Stream )
  {
    printf("Error opening file\n");
    exit(1);
  }
  printf("Contents of file %s:\n", FileName);
  while ( fgets(Buffer, 100, Stream) )
    printf("%s", Buffer);
  fclose(Stream);
  return 0;
}
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home automation ; Style: futuristic
#include <stdio.h>
#include <stdbool.h>

//function prototypes
void turnOnLights(void);
void turnOffLights(void);
void turnOnAC(void);
void turnOffAC(void);
void queryTemperature(void);

//global variables
bool areLightsOn = false;
bool isACOn = false;
int temperature = 25;

int main()
{
    printf("\n***Welcome to Futuristic Smart Home Automation System***\n\n");

    int choice = 0;

    do {
        printf("Please choose an option:\n");
        printf("1. Turn on lights\n");
        printf("2. Turn off lights\n");
        printf("3. Turn on AC\n");
        printf("4. Turn off AC\n");
        printf("5. Query temperature\n");
        printf("6. Exit\n");

        scanf("%d", &choice);

        switch(choice) {
            case 1:
                if(!areLightsOn) {
                    turnOnLights();
                    areLightsOn = true;
                }
                else {
                    printf("Lights are already on!\n");
                }
                break;

            case 2:
                if(areLightsOn) {
                    turnOffLights();
                    areLightsOn = false;
                }
                else {
                    printf("Lights are already off!\n");
                }
                break;

            case 3:
                if(!isACOn) {
                    turnOnAC();
                    isACOn = true;
                }
                else {
                    printf("AC is already on!\n");
                }
                break;

            case 4:
                if(isACOn) {
                    turnOffAC();
                    isACOn = false;
                }
                else {
                    printf("AC is already off!\n");
                }
                break;

            case 5:
                queryTemperature();
                break;

            case 6:
                printf("Thank you for using the system!\n");
                break;

            default:
                printf("Invalid option, please try again...\n");
                break;
        }
    } while (choice != 6);

    return 0;
}

void turnOnLights(void) {
    printf("Turning on lights...\n");
    //code to turn on the lights
}

void turnOffLights(void) {
    printf("Turning off lights...\n");
    //code to turn off the lights
}

void turnOnAC(void) {
    printf("Turning on AC...\n");
    //code to turn on the AC
}

void turnOffAC(void) {
    printf("Turning off AC...\n");
    //code to turn off the AC
}

void queryTemperature(void) {
    printf("Current temperature is %d degrees Celsius.\n", temperature);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 turnOnLights(void); // weak
__int64 turnOffLights(void); // weak
__int64 turnOnAC(void); // weak
__int64 turnOffAC(void); // weak
__int64 queryTemperature(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char areLightsOn; // weak
char isACOn; // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("\n***Welcome to Futuristic Smart Home Automation System***\n\n");
  v4 = 0;
  do
  {
    printf("Please choose an option:\n");
    printf("1. Turn on lights\n");
    printf("2. Turn off lights\n");
    printf("3. Turn on AC\n");
    printf("4. Turn off AC\n");
    printf("5. Query temperature\n");
    printf("6. Exit\n");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        if ( areLightsOn != 1 )
        {
          turnOnLights();
          areLightsOn = 1;
        }
        else
        {
          printf("Lights are already on!\n");
        }
        break;
      case 2:
        if ( areLightsOn )
        {
          turnOffLights();
          areLightsOn = 0;
        }
        else
        {
          printf("Lights are already off!\n");
        }
        break;
      case 3:
        if ( isACOn != 1 )
        {
          turnOnAC();
          isACOn = 1;
        }
        else
        {
          printf("AC is already on!\n");
        }
        break;
      case 4:
        if ( isACOn )
        {
          turnOffAC();
          isACOn = 0;
        }
        else
        {
          printf("AC is already off!\n");
        }
        break;
      case 5:
        queryTemperature();
        break;
      case 6:
        printf("Thank you for using the system!\n");
        break;
      default:
        printf("Invalid option, please try again...\n");
        break;
    }
  }
  while ( v4 != 6 );
  return 0;
}
// 1400017A8: using guessed type __int64 turnOnLights(void);
// 1400017C6: using guessed type __int64 turnOffLights(void);
// 1400017E4: using guessed type __int64 turnOnAC(void);
// 140001802: using guessed type __int64 turnOffAC(void);
// 140001820: using guessed type __int64 queryTemperature(void);
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140018040: using guessed type char areLightsOn;
// 140018041: using guessed type char isACOn;

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Time Travel Simulator ; Style: ultraprecise
#include <stdio.h>
#include <time.h>

int main() {
  struct tm start_time = {0};

  start_time.tm_year = 2021 - 1900; // January 1 2021
  start_time.tm_mon = 0;
  start_time.tm_mday = 1;

  time_t current_time = mktime(&start_time);

  struct tm dest_time = {0};
  dest_time.tm_year = 5500 - 1900; // The year 5500
  dest_time.tm_mon = 0;
  dest_time.tm_mday = 1;

  time_t dest_timestamp = mktime(&dest_time);

  printf("Starting from January 1, 2021, we will travel through time to the year 5500.\n");

  while (current_time < dest_timestamp) {
    printf("Time Traveling to the year: %d\n", 1900 + dest_time.tm_year);
    current_time += 86400; // Add one day
    struct tm* updated_time = localtime(&current_time);
    printf("Date is now: %d-%02d-%02d\n", 1900 + updated_time->tm_year, updated_time->tm_mon + 1, updated_time->tm_mday);
    printf("====================================\n");
  }

  printf("Time Traveling Complete.\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static struct tm *__cdecl localtime(const time_t *const Time);
static time_t __cdecl mktime(struct tm *const Tm);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015CF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  struct tm v4; // [rsp+20h] [rbp-70h] BYREF
  time_t Time; // [rsp+48h] [rbp-48h] BYREF
  struct tm Tm; // [rsp+50h] [rbp-40h] BYREF
  struct tm *v7; // [rsp+80h] [rbp-10h]
  time_t v8; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  *(_QWORD *)&Tm.tm_sec = 0i64;
  *(_QWORD *)&Tm.tm_hour = 0x100000000i64;
  *(_QWORD *)&Tm.tm_mon = 0x7900000000i64;
  *(_QWORD *)&Tm.tm_wday = 0i64;
  Tm.tm_isdst = 0;
  Time = mktime(&Tm);
  *(_QWORD *)&v4.tm_sec = 0i64;
  *(_QWORD *)&v4.tm_hour = 0x100000000i64;
  *(_QWORD *)&v4.tm_mon = 0xE1000000000i64;
  *(_QWORD *)&v4.tm_wday = 0i64;
  v4.tm_isdst = 0;
  v8 = mktime(&v4);
  printf("Starting from January 1, 2021, we will travel through time to the year 5500.\n");
  while ( v8 > Time )
  {
    printf("Time Traveling to the year: %d\n", (unsigned int)(v4.tm_year + 1900));
    Time += 86400i64;
    v7 = localtime(&Time);
    printf(
      "Date is now: %d-%02d-%02d\n",
      (unsigned int)(v7->tm_year + 1900),
      (unsigned int)(v7->tm_mon + 1),
      (unsigned int)v7->tm_mday);
    printf("====================================\n");
  }
  printf("Time Traveling Complete.\n");
  return 0;
}
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital signal processing ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/* Define global constants */
#define PI 3.14159265358979323846
#define N 10

/* Define function to compute the discrete Fourier transform */
void DFT(double x[], double Xr[], double Xi[]) {
    int k, n;
    double c, s, Wr, Wi;

    for (k = 0; k < N; k++) {
        Xr[k] = 0;
        Xi[k] = 0;

        for (n = 0; n < N; n++) {
            c = cos(2 * PI * k * n / N);
            s = -sin(2 * PI * k * n / N);

            Xr[k] += x[n] * c;
            Xi[k] += x[n] * s;
        }
    }
}

/* Define function to print complex numbers */
void printComplex(double Xr[], double Xi[]) {
    int k;

    printf("X(k) = ");

    for (k = 0; k < N; k++) {
        printf("%.2f + %.2fi, ", Xr[k], Xi[k]);
    }

    printf("\n");
}

/* Define main function */
int main() {
    double x[N] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    double Xr[N];
    double Xi[N];

    DFT(x, Xr, Xi);
    printComplex(Xr, Xi);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall DFT(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall printComplex(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000180F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[80]; // [rsp+20h] [rbp-60h] BYREF
  char v5[80]; // [rsp+70h] [rbp-10h] BYREF
  __int64 v6[10]; // [rsp+C0h] [rbp+40h] BYREF

  _main(argc, argv, envp);
  v6[0] = 0x3FF0000000000000i64;
  v6[1] = 0x4000000000000000i64;
  v6[2] = 0x4008000000000000i64;
  v6[3] = 0x4010000000000000i64;
  v6[4] = 0x4014000000000000i64;
  v6[5] = 0x4018000000000000i64;
  v6[6] = 0x401C000000000000i64;
  v6[7] = 0x4020000000000000i64;
  v6[8] = 0x4022000000000000i64;
  v6[9] = 0x4024000000000000i64;
  DFT(v6, v5, v4);
  printComplex(v5, v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall DFT(_QWORD, _QWORD, _QWORD);
// 14000175D: using guessed type __int64 __fastcall printComplex(_QWORD, _QWORD);
// 1400019A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Tic Tac Toe AI ; Style: beginner-friendly
#include <stdio.h>
#include <stdlib.h>

char board[3][3]; // Tic Tac Toe Board

// Function to display the Tic Tac Toe board
void display_board() {
    printf("\n\n");
    printf(" %c | %c | %c\n", board[0][0], board[0][1], board[0][2]);
    printf("___|___|___\n");
    printf(" %c | %c | %c\n", board[1][0], board[1][1], board[1][2]);
    printf("___|___|___\n");
    printf(" %c | %c | %c\n", board[2][0], board[2][1], board[2][2]);
    printf("   |   |   \n");
}

// Function to initialize the Tic Tac Toe board
void initialize_board() {
    for(int i=0; i<3; i++) {
        for(int j=0; j<3; j++) {
            board[i][j] = ' ';
        }
    }
}

// Function to check if the player has won the game
int check_if_won(char player) {
    // Checking Rows
    for(int i=0; i<3; i++) {
        if(board[i][0] == player && board[i][1] == player && board[i][2] == player) {
            return 1;
        }
    }
    // Checking Columns
    for(int i=0; i<3; i++) {
        if(board[0][i] == player && board[1][i] == player && board[2][i] == player) {
            return 1;
        }
    }
    // Checking Diagonals
    if(board[0][0] == player && board[1][1] == player && board[2][2] == player) {
        return 1;
    }
    if(board[0][2] == player && board[1][1] == player && board[2][0] == player) {
        return 1;
    }
    return 0;
}

// Function to get the next move from the player
void get_player_move(char player) {
    int row, col;
    printf("\n%s's turn (X or O): ", player == 'X' ? "Player 1" : "Player 2");
    scanf("%d %d", &row, &col);
    if(board[row-1][col-1] == ' ') {
        board[row-1][col-1] = player;
    }
    else {
        printf("\nInvalid Move! Please Try Again.\n");
        get_player_move(player);
    }
}

// Function to get the best move for the AI player
void get_AI_move() {
    int row, col;
    // If AI can win in the next move
    for(int i=0; i<3; i++) {
        for(int j=0; j<3; j++) {
            if(board[i][j] == ' ') {
                board[i][j] = 'O';
                if(check_if_won('O')) {
                    return;
                }
                else {
                    board[i][j] = ' ';
                }
            }
        }
    }
    // If player can win in the next move, block the move
    for(int i=0; i<3; i++) {
        for(int j=0; j<3; j++) {
            if(board[i][j] == ' ') {
                board[i][j] = 'X';
                if(check_if_won('X')) {
                    board[i][j] = 'O';
                    return;
                }
                else {
                    board[i][j] = ' ';
                }
            }
        }
    }
    // If AI can't win nor block player's move, choose random move
    do {
        row = rand() % 3;
        col = rand() % 3;
    } while(board[row][col] != ' ');
    board[row][col] = 'O';
}

// Function to check if the game is a tie
int check_if_tie() {
    for(int i=0; i<3; i++) {
        for(int j=0; j<3; j++) {
            if(board[i][j] == ' ') {
                return 0;
            }
        }
    }
    return 1;
}

// Function to start and play the game
void play_game() {
    char player = 'X';
    int game_status = 0; // 0 - Game is Incomplete, 1 - Player Wins, 2 - AI Wins, 3 - Tie Game
    initialize_board();
    display_board();
    while(game_status == 0) {
        if(player == 'X') {
            get_player_move(player);
        }
        else {
            get_AI_move();
        }
        display_board();
        if(check_if_won(player)) {
            game_status = player == 'X' ? 1 : 2;
        }
        else if(check_if_tie()) {
            game_status = 3;
        }
        player = player == 'X' ? 'O' : 'X';
    }
    if(game_status == 1) {
        printf("Congratulations! Player 1 Wins!");
    }
    else if(game_status == 2) {
        printf("Sorry, AI Wins. Better Luck Next Time.");
    }
    else {
        printf("It's a Tie Game!");
    }
}

int main() {
    printf("Welcome to Tic Tac Toe.\n");
    play_game();
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 play_game(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001CD2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("Welcome to Tic Tac Toe.\n");
  play_game();
  return 0;
}
// 140001C01: using guessed type __int64 play_game(void);
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Alien Invasion Probability Calculator ; Style: genious
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main() {
    int num, i;
    float probability;
    srand(time(0));
    printf("\nWelcome to the Alien Invasion Probability Calculator\n");
    printf("\nEnter the number of times you want to run the simulation: ");
    scanf("%d", &num);
    printf("\nCalculating Probability...\n");
    for(i=1; i<=num; i++) {
        int random = rand() % 10 + 1;
        if(random == 1) {
            probability += 0.2;
        }
        else if(random == 2) {
            probability += 0.1;
        }
        else if(random >=3 && random <= 5) {
            probability += 0.05;
        }
        else {
            probability += 0.01;
        }
    }
    probability = probability/num * 100;
    printf("\nThe probability of alien invasion is: %0.2f%%\n", probability);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax
  float v5; // xmm0_4
  float v6; // xmm0_4
  float v7; // xmm0_4
  float v8; // xmm0_4
  int v10; // [rsp+20h] [rbp-10h] BYREF
  int v11; // [rsp+24h] [rbp-Ch]
  float v12; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("\nWelcome to the Alien Invasion Probability Calculator\n");
  printf("\nEnter the number of times you want to run the simulation: ");
  scanf("%d", &v10);
  printf("\nCalculating Probability...\n");
  for ( i = 1; i <= v10; ++i )
  {
    v4 = rand();
    v11 = v4 % 10 + 1;
    if ( v4 % 10 )
    {
      if ( v11 == 2 )
      {
        v6 = v12 + 0.1;
        v12 = v6;
      }
      else if ( v11 <= 2 || v11 > 5 )
      {
        v8 = v12 + 0.01;
        v12 = v8;
      }
      else
      {
        v7 = v12 + 0.05;
        v12 = v7;
      }
    }
    else
    {
      v5 = v12 + 0.2;
      v12 = v5;
    }
  }
  printf("\nThe probability of alien invasion is: %0.2f%%\n", (float)(100.0 * (float)(v12 / (float)v10)));
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Basic Image Processing: Simple tasks like flipping an image, changing brightness/contrast ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILENAME_SIZE 100

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int DWORD;

typedef struct ImgInfo {
    int width;
    int height;
    BYTE* pixels;
} ImgInfo;

// Helper function to read bitmap header information
void readBmpHeader(FILE* fp, ImgInfo* info) {
    fseek(fp, 18, SEEK_SET);
    fread(&info->width, sizeof(int), 1, fp);
    fread(&info->height, sizeof(int), 1, fp);
    fseek(fp, 28, SEEK_SET);
}

// Helper function to read bitmap pixel array data
void readBmpPixels(FILE* fp, ImgInfo* info) {
    fseek(fp, 54, SEEK_SET);
    int imgSize = info->width * info->height * 3;
    info->pixels = (BYTE*)malloc(imgSize);
    fread(info->pixels, sizeof(BYTE), imgSize, fp);
}

// Helper function to write bitmap file header
void writeBmpFileHeader(FILE* fp, int fileSize) {
    fseek(fp, 2, SEEK_SET);
    WORD bfType = 0x4D42;
    fwrite(&bfType, sizeof(WORD), 1, fp);
    DWORD bfSize = fileSize;
    fwrite(&bfSize, sizeof(DWORD), 1, fp);
    WORD bfReserved1 = 0;
    fwrite(&bfReserved1, sizeof(WORD), 1, fp);
    WORD bfReserved2 = 0;
    fwrite(&bfReserved2, sizeof(WORD), 1, fp);
    DWORD bfOffBits = 54;
    fwrite(&bfOffBits, sizeof(DWORD), 1, fp);
}

// Helper function to write bitmap information header
void writeBmpInfoHeader(FILE* fp, ImgInfo* info) {
    DWORD biSize = 40;
    fwrite(&biSize, sizeof(DWORD), 1, fp);
    fwrite(&info->width, sizeof(int), 1, fp);
    fwrite(&info->height, sizeof(int), 1, fp);
    WORD biPlanes = 1;
    fwrite(&biPlanes, sizeof(WORD), 1, fp);
    WORD biBitCount = 24;
    fwrite(&biBitCount, sizeof(WORD), 1, fp);
    DWORD biCompression = 0;
    fwrite(&biCompression, sizeof(DWORD), 1, fp);
    DWORD biSizeImage = info->width * info->height * 3;
    fwrite(&biSizeImage, sizeof(DWORD), 1, fp);
    int biXPelsPerMeter = 2834;
    fwrite(&biXPelsPerMeter, sizeof(int), 1, fp);
    int biYPelsPerMeter = 2834;
    fwrite(&biYPelsPerMeter, sizeof(int), 1, fp);
    DWORD biClrUsed = 0;
    fwrite(&biClrUsed, sizeof(DWORD), 1, fp);
    DWORD biClrImportant = 0;
    fwrite(&biClrImportant, sizeof(DWORD), 1, fp);
}

// Helper function to flip image horizontally
void flipHorizontal(ImgInfo* info) {
    int rowSize = info->width * 3;
    BYTE* tempRow = (BYTE*)malloc(rowSize);
    int halfHeight = info->height / 2;
    for (int i = 0; i < halfHeight; i++) {
        int topIndex = i * rowSize;
        int bottomIndex = (info->height - i - 1) * rowSize;
        memcpy(tempRow, info->pixels + topIndex, rowSize);
        memcpy(info->pixels + topIndex, info->pixels + bottomIndex, rowSize);
        memcpy(info->pixels + bottomIndex, tempRow, rowSize);
    }
    free(tempRow);
}

// Helper function to adjust brightness of an image
void adjustBrightness(ImgInfo* info, int brightness) {
    int imgSize = info->width * info->height * 3;
    for (int i = 0; i < imgSize; i += 3) {
        int r = *(info->pixels + i);
        int g = *(info->pixels + i + 1);
        int b = *(info->pixels + i + 2);
        r += brightness;
        r = (r > 255 ? 255 : (r < 0 ? 0 : r));
        g += brightness;
        g = (g > 255 ? 255 : (g < 0 ? 0 : g));
        b += brightness;
        b = (b > 255 ? 255 : (b < 0 ? 0 : b));
        *(info->pixels + i) = r;
        *(info->pixels + i + 1) = g;
        *(info->pixels + i + 2) = b;
    }
}

// Helper function to adjust contrast of an image
void adjustContrast(ImgInfo* info, double contrast) {
    double factor = (259.0 * (contrast + 255.0)) / (255.0 * (259.0 - contrast));
    int imgSize = info->width * info->height * 3;
    for (int i = 0; i < imgSize; i += 3) {
        int r = *(info->pixels + i);
        int g = *(info->pixels + i + 1);
        int b = *(info->pixels + i + 2);
        r = (int)(factor * (r - 128) + 128);
        r = (r > 255 ? 255 : (r < 0 ? 0 : r));
        g = (int)(factor * (g - 128) + 128);
        g = (g > 255 ? 255 : (g < 0 ? 0 : g));
        b = (int)(factor * (b - 128) + 128);
        b = (b > 255 ? 255 : (b < 0 ? 0 : b));
        *(info->pixels + i) = r;
        *(info->pixels + i + 1) = g;
        *(info->pixels + i + 2) = b;
    }
}

// Main function to process the image file
int main() {
    char inputFilename[MAX_FILENAME_SIZE];
    printf("Enter input filename: ");
    scanf("%s", inputFilename);
    FILE* inputFile = fopen(inputFilename, "rb");
    if (!inputFile) {
        printf("Error: could not open file %s\n", inputFilename);
        return 1;
    }
    ImgInfo info;
    readBmpHeader(inputFile, &info);
    readBmpPixels(inputFile, &info);
    fclose(inputFile);
    printf("Enter desired brightness level (-255 to 255): ");
    int brightness;
    scanf("%d", &brightness);
    adjustBrightness(&info, brightness);
    printf("Enter desired contrast level (0.1 to 10.0): ");
    double contrast;
    scanf("%lf", &contrast);
    adjustContrast(&info, contrast);
    flipHorizontal(&info);
    char outputFilename[MAX_FILENAME_SIZE];
    printf("Enter output filename: ");
    scanf("%s", outputFilename);
    FILE* outputFile = fopen(outputFilename, "wb");
    if (!outputFile) {
        printf("Error: could not open file %s\n", outputFilename);
        free(info.pixels);
        return 1;
    }
    int fileSize = info.width * info.height * 3 + 54;
    writeBmpFileHeader(outputFile, fileSize);
    writeBmpInfoHeader(outputFile, &info);
    fwrite(info.pixels, sizeof(BYTE), fileSize - 54, outputFile);
    fclose(outputFile);
    free(info.pixels);
    printf("Image processing successful!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall readBmpHeader(_QWORD, _QWORD); // weak
__int64 __fastcall readBmpPixels(_QWORD, _QWORD); // weak
__int64 __fastcall writeBmpFileHeader(_QWORD, _QWORD); // weak
__int64 __fastcall writeBmpInfoHeader(_QWORD, _QWORD); // weak
__int64 __fastcall flipHorizontal(_QWORD); // weak
__int64 __fastcall adjustBrightness(_QWORD, _QWORD); // weak
__int64 __fastcall adjustContrast(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001DA6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[112]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v6; // [rsp+9Ch] [rbp+1Ch] BYREF
  int v7[2]; // [rsp+A0h] [rbp+20h] BYREF
  void *Block; // [rsp+A8h] [rbp+28h]
  char FileName[108]; // [rsp+B0h] [rbp+30h] BYREF
  unsigned int v10; // [rsp+11Ch] [rbp+9Ch]
  FILE *v11; // [rsp+120h] [rbp+A0h]
  FILE *Stream; // [rsp+128h] [rbp+A8h]

  _main(argc, argv, envp);
  printf("Enter input filename: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "rb");
  if ( Stream )
  {
    readBmpHeader(Stream, v7);
    readBmpPixels(Stream, v7);
    fclose(Stream);
    printf("Enter desired brightness level (-255 to 255): ");
    scanf("%d", &v6);
    adjustBrightness(v7, v6);
    printf("Enter desired contrast level (0.1 to 10.0): ");
    scanf("%lf", &v5);
    adjustContrast(v7);
    flipHorizontal(v7);
    printf("Enter output filename: ");
    scanf("%s", v4);
    v11 = fopen(v4, "wb");
    if ( v11 )
    {
      v10 = 3 * v7[1] * v7[0] + 54;
      writeBmpFileHeader(v11, v10);
      writeBmpInfoHeader(v11, v7);
      fwrite(Block, 1ui64, (int)(v10 - 54), v11);
      fclose(v11);
      free(Block);
      printf("Image processing successful!\n");
      return 0;
    }
    else
    {
      printf("Error: could not open file %s\n", v4);
      free(Block);
      return 1;
    }
  }
  else
  {
    printf("Error: could not open file %s\n", FileName);
    return 1;
  }
}
// 1400015E2: using guessed type __int64 __fastcall readBmpHeader(_QWORD, _QWORD);
// 14000165B: using guessed type __int64 __fastcall readBmpPixels(_QWORD, _QWORD);
// 1400016D9: using guessed type __int64 __fastcall writeBmpFileHeader(_QWORD, _QWORD);
// 1400017A9: using guessed type __int64 __fastcall writeBmpInfoHeader(_QWORD, _QWORD);
// 14000193C: using guessed type __int64 __fastcall flipHorizontal(_QWORD);
// 140001A45: using guessed type __int64 __fastcall adjustBrightness(_QWORD, _QWORD);
// 140001B9D: using guessed type __int64 __fastcall adjustContrast(_QWORD);
// 1400020A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001DA6: using guessed type __int64 var_A0;

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System boot optimizer ; Style: complete
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define BOOT_TIME 30 // Boot time in seconds

// Helper function to simulate loading of a module
void load_module(char* module_name) {
    printf("Loading module: %s\n", module_name);
    int wait_time = rand() % 5 + 1; // Random wait time between 1 and 5 seconds
    sleep(wait_time);
    printf("Module %s loaded in %d seconds\n", module_name, wait_time);
}

int main() {
    // Initialize random seed
    srand(time(NULL));

    // Simulate boot process
    printf("System booting...\n");
    for(int i=0; i<=BOOT_TIME; i++) {
        printf("Time remaining: %d seconds\n", BOOT_TIME-i);
        sleep(1); // Wait for 1 second
    }

    printf("Optimizing boot sequence...\n");
    load_module("filesystem");
    load_module("network");
    load_module("security");
    load_module("graphics");
    load_module("audio");
    load_module("input");
    load_module("power");

    printf("Boot sequence optimized successfully!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall load_module(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001626) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("System booting...\n");
  for ( i = 0; i <= 30; ++i )
  {
    printf("Time remaining: %d seconds\n", (unsigned int)(30 - i));
    sleep(1i64);
  }
  printf("Optimizing boot sequence...\n");
  load_module("filesystem");
  load_module("network");
  load_module("security");
  load_module("graphics");
  load_module("audio");
  load_module("input");
  load_module("power");
  printf("Boot sequence optimized successfully!\n");
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall load_module(_QWORD);
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002830: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: HTML beautifier ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define constants for HTML tags and characters
#define CLOSING_TAG '/'
#define OPENING_TAG '<'
#define CLOSING_ANGLE '>'
#define SPACE ' '
#define QUOTE '"'
#define SINGLE_QUOTE '\''

// Function to beautify HTML code
void beautify_html(char* html_code) {

    // Keep track of nested tags and indentation level
    int nested_tags = 0;
    int indent_level = 0;
    char* output = malloc(strlen(html_code) * 2); // Allocate memory for output string
    char* p = html_code; // Pointer to traverse the input string
    char* q = output; // Pointer to traverse the output string

    // Loop through every character in the input string
    while (*p != '\0') {

        // Check if character is an opening tag
        if (*p == OPENING_TAG) {

            // Indent for nested tags
            for (int i = 0; i < indent_level; i++) {
                *q++ = SPACE;
                *q++ = SPACE;
            }

            // Copy the opening tag
            *q++ = *p++;

            // Check if tag is a closing tag
            if (*p == CLOSING_TAG) {
                nested_tags--;
            } else {
                nested_tags++;
            }
        }

        // Check if character is a closing tag
        else if (*p == CLOSING_ANGLE && *(p - 1) == CLOSING_TAG) {

            // Unindent for nested tags
            nested_tags--;
            indent_level--;

            // Indent for nested tags
            for (int i = 0; i < indent_level; i++) {
                *q++ = SPACE;
                *q++ = SPACE;
            }

            // Copy the closing tag
            *q++ = CLOSING_TAG;
            *q++ = *p++;
            *q++ = CLOSING_ANGLE;
        }

        // Check if character is a space or quote
        else if (*p == SPACE || *p == QUOTE || *p == SINGLE_QUOTE) {

            // Copy the character
            *q++ = *p++;

            // Check if the previous character was also a space or quote
            if (*(q - 2) == SPACE || *(q - 2) == QUOTE || *(q - 2) == SINGLE_QUOTE) {
                continue; // Skip duplicate characters
            }

            // Indent for nested tags
            if (*(q - 2) == OPENING_TAG) {
                for (int i = 0; i < nested_tags; i++) {
                    *q++ = SPACE;
                    *q++ = SPACE;
                }
                indent_level += nested_tags;
            }
        }

        // Otherwise, copy the character
        else {
            *q++ = *p++;
        }
    }

    *q = '\0'; // Add null terminator to output string
    strcpy(html_code, output); // Copy output string back to input string
    free(output); // Release memory allocated for output string
}

int main() {

    // Sample HTML code to beautify
    char html_code[] = "<html><body><h1>Hello World!</h1><p>This is a sample paragraph.</p></body></html>";

    // Beautify the HTML code
    beautify_html(html_code);

    // Print the beautified HTML code
    printf("%s\n", html_code);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall beautify_html(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017FE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[96]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  strcpy(v4, "<html><body><h1>Hello World!</h1><p>This is a sample paragraph.</p></body></html>");
  beautify_html(v4);
  printf("%s\n", v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall beautify_html(_QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Color Code Converter ; Style: lively
#include <stdio.h>

int main() {

  // Introduction
  printf("\nWelcome to the C Color Code Converter!\n\n");

  // Ask user for input
  printf("Please enter a color code in Hexadecimal format (e.g. #FF5733): ");
  char hexCode[8];
  scanf("%s", hexCode);

  // Convert Hexadecimal to RGB
  int r, g, b;
  sscanf(hexCode, "#%02x%02x%02x", &r, &g, &b);

  // Display RGB values
  printf("\nRGB values for %s:\n", hexCode);
  printf("Red: %d\n", r);
  printf("Green: %d\n", g);
  printf("Blue: %d\n", b);

  // Convert RGB to HSL
  double h, s, l;
  double rDecimal = r / 255.0;
  double gDecimal = g / 255.0;
  double bDecimal = b / 255.0;
  double max = fmax(fmax(rDecimal, gDecimal), bDecimal);
  double min = fmin(fmin(rDecimal, gDecimal), bDecimal);
  double delta = max - min;

  if (delta == 0) {
    h = 0;
  } else if (max == rDecimal) {
    h = fmod((gDecimal - bDecimal) / delta, 6);
  } else if (max == gDecimal) {
    h = (bDecimal - rDecimal) / delta + 2;
  } else {
    h = (rDecimal - gDecimal) / delta + 4;
  }

  h = h * 60;
  if (h < 0) {
    h += 360;
  }

  l = (max + min) / 2;

  if (delta == 0) {
    s = 0;
  } else {
    s = delta / (1 - fabs(2 * l - 1));
  }

  // Display HSL values
  printf("\nHSL values for %s:\n", hexCode);
  printf("Hue: %g\n", h);
  printf("Saturation: %g\n", s);
  printf("Lightness: %g\n", l);

  // Exit message
  printf("\nThank you for using the C Color Code Converter!\n\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sscanf(const char *const Buffer, const char *const Format, ...);
int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl fmax(double X, double Y);
double __cdecl fmin(double X, double Y);
double __cdecl fmod(double X, double Y);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm0_8
  double v4; // xmm0_8
  unsigned int v6; // [rsp+34h] [rbp-5Ch] BYREF
  unsigned int v7; // [rsp+38h] [rbp-58h] BYREF
  unsigned int v8; // [rsp+3Ch] [rbp-54h] BYREF
  char Buffer[8]; // [rsp+40h] [rbp-50h] BYREF
  double v10; // [rsp+48h] [rbp-48h]
  double v11; // [rsp+50h] [rbp-40h]
  double v12; // [rsp+58h] [rbp-38h]
  double v13; // [rsp+60h] [rbp-30h]
  double v14; // [rsp+68h] [rbp-28h]
  double Y; // [rsp+70h] [rbp-20h]
  double X; // [rsp+78h] [rbp-18h]
  double v17; // [rsp+80h] [rbp-10h]
  double v18; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  printf("\nWelcome to the C Color Code Converter!\n\n");
  printf("Please enter a color code in Hexadecimal format (e.g. #FF5733): ");
  scanf("%s", Buffer);
  sscanf(Buffer, "#%02x%02x%02x", &v8, &v7, &v6);
  printf("\nRGB values for %s:\n", Buffer);
  printf("Red: %d\n", v8);
  printf("Green: %d\n", v7);
  printf("Blue: %d\n", v6);
  X = (double)(int)v8 / 255.0;
  Y = (double)(int)v7 / 255.0;
  v14 = (double)(int)v6 / 255.0;
  v3 = fmax(X, Y);
  v13 = fmax(v3, v14);
  v4 = fmin(X, Y);
  v12 = fmin(v4, v14);
  v11 = v13 - v12;
  if ( v13 - v12 == 0.0 )
  {
    v18 = 0.0;
  }
  else if ( v13 == X )
  {
    v18 = fmod((Y - v14) / v11, 6.0);
  }
  else if ( v13 == Y )
  {
    v18 = (v14 - X) / v11 + 2.0;
  }
  else
  {
    v18 = (X - Y) / v11 + 4.0;
  }
  v18 = 60.0 * v18;
  if ( v18 < 0.0 )
    v18 = v18 + 360.0;
  v10 = (v13 + v12) / 2.0;
  if ( v11 == 0.0 )
    v17 = 0.0;
  else
    v17 = v11 / (1.0 - fabs(v10 + v10 - 1.0));
  printf("\nHSL values for %s:\n", Buffer);
  printf("Hue: %g\n", v18);
  printf("Saturation: %g\n", v17);
  printf("Lightness: %g\n", v10);
  printf("\nThank you for using the C Color Code Converter!\n\n");
  return 0;
}
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001625: using guessed type char Buffer[8];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Time Travel Simulator ; Style: careful
#include <stdio.h>
#include <time.h>

void timeTravel(int year) {
    time_t t = time(NULL); // get current time
    struct tm* localTime = localtime(&t); // convert to local time
    localTime->tm_year = year - 1900; // set year for time travel
    t = mktime(localTime); // convert back to time_t
    printf("Welcome to the year %d!\n", year);
    printf("Today is %s", ctime(&t));
}

int main() {
    printf("Welcome to the Time Travel Simulator\n");
    printf("Enter a year in the future or past to travel to: ");

    int year;
    scanf("%d", &year);

    timeTravel(year);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall timeTravel(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016DE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Time Travel Simulator\n");
  printf("Enter a year in the future or past to travel to: ");
  scanf("%d", &v4);
  timeTravel(v4);
  return 0;
}
// 14000165E: using guessed type __int64 __fastcall timeTravel(_QWORD);
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database Indexing System ; Style: real-life
#include <stdio.h>
#include <stdlib.h>

// Define a structure for a record in the database
typedef struct record {
    int id;
    char name[50];
    double salary;
} Record;

// Define a structure for an index entry
typedef struct index_entry {
    int id;
    long offset;
} IndexEntry;

// Define a structure for the index
typedef struct index {
    IndexEntry* entries;
    int num_entries;
} Index;

// Function to create an index for the database
Index create_index(FILE* fp) {
    // Count number of records in the file
    fseek(fp, 0, SEEK_END);
    long filesize = ftell(fp);
    int num_records = filesize / sizeof(Record);
    fseek(fp, 0, SEEK_SET);
    
    // Allocate memory for the index entries
    IndexEntry* entries = (IndexEntry*) malloc(sizeof(IndexEntry) * num_records);
    
    // Read each record and store its offset in the index
    for (int i = 0; i < num_records; i++) {
        Record rec;
        fread(&rec, sizeof(Record), 1, fp);
        entries[i].id = rec.id;
        entries[i].offset = ftell(fp) - sizeof(Record);
    }
    
    // Create the index and return it
    Index idx = {.entries = entries, .num_entries = num_records};
    return idx;
}

// Function to get the record with a given ID using the index
Record get_record_with_id(Index idx, FILE* fp, int id) {
    // Binary search through the index for the ID
    int lo = 0;
    int hi = idx.num_entries - 1;
    while (lo <= hi) {
        int mid = (lo + hi) / 2;
        if (idx.entries[mid].id == id) {
            // Found the ID, seek to the offset and read the record
            fseek(fp, idx.entries[mid].offset, SEEK_SET);
            Record rec;
            fread(&rec, sizeof(Record), 1, fp);
            return rec;
        } else if (idx.entries[mid].id < id) {
            // ID is in the upper half of the range
            lo = mid + 1;
        } else {
            // ID is in the lower half of the range
            hi = mid - 1;
        }
    }
    
    // ID not found
    Record nullrec = {.id = -1, .name = "", .salary = 0.0};
    return nullrec;
}


int main() {
    // Open the database file
    FILE* fp = fopen("employees.dat", "rb");
    if (fp == NULL) {
        printf("Error opening file\n");
        return 1;
    }
    
    // Create the index
    Index idx = create_index(fp);
    
    // Get a record from the database using the index
    int id = 42;
    Record rec = get_record_with_id(idx, fp, id);
    if (rec.id == -1) {
        printf("Record with ID %d not found\n", id);
    } else {
        printf("Record with ID %d:\n", id);
        printf("Name: %s\n", rec.name);
        printf("Salary: $%.2f\n", rec.salary);
    }
    
    // Clean up
    fclose(fp);
    free(idx.entries);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall create_index(_QWORD, _QWORD); // weak
__int64 __fastcall get_record_with_id(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001889) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[2]; // [rsp+20h] [rbp-70h] BYREF
  int v5; // [rsp+30h] [rbp-60h] BYREF
  char v6[52]; // [rsp+34h] [rbp-5Ch] BYREF
  double v7; // [rsp+68h] [rbp-28h]
  void *Block[2]; // [rsp+70h] [rbp-20h] BYREF
  unsigned int v9; // [rsp+84h] [rbp-Ch]
  FILE *Stream; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  Stream = fopen("employees.dat", "rb");
  if ( Stream )
  {
    create_index(Block, Stream);
    v9 = 42;
    v4[0] = (__int64)Block[0];
    v4[1] = (__int64)Block[1];
    ((void (__fastcall *)(int *, __int64 *, FILE *, __int64))get_record_with_id)(&v5, v4, Stream, 42i64);
    if ( v5 == -1 )
    {
      printf("Record with ID %d not found\n", v9);
    }
    else
    {
      printf("Record with ID %d:\n", v9);
      printf("Name: %s\n", v6);
      printf("Salary: $%.2f\n", v7);
    }
    fclose(Stream);
    free(Block[0]);
    return 0;
  }
  else
  {
    printf("Error opening file\n");
    return 1;
  }
}
// 140001591: using guessed type __int64 __fastcall create_index(_QWORD, _QWORD);
// 1400016A2: using guessed type __int64 __fastcall get_record_with_id(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140001A70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001889: using guessed type char anonymous_0[52];

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pathfinding algorithms ; Style: intelligent
#include <stdio.h>
#define MAX 10

int graph[MAX][MAX], visited[MAX], n;

void DFS(int m) {
    int j;
    visited[m] = 1;
    printf("-> %d ", m + 1);
    for (j = 0; j < n; j++)
        if (!visited[j] && graph[m][j] == 1)
            DFS(j);
}

int main() {
    int i, j, start;
    printf("Enter the number of nodes: ");
    scanf("%d", &n);
    printf("\nEnter the adjacency matrix:\n");
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &graph[i][j]);
    printf("\nEnter the starting node: ");
    scanf("%d", &start);
    start--;
    for (i = 0; i < n; i++)
        visited[i] = 0;
    printf("\nDFS traversal: ");
    DFS(start);
    printf("\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall DFS(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN graph; // weak
_DWORD visited[10]; // weak
int n; // weak


//----- (0000000140001697) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch] BYREF
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of nodes: ");
  scanf("%d", &n);
  printf("\nEnter the adjacency matrix:\n");
  for ( i = 0; i < n; ++i )
  {
    for ( j = 0; j < n; ++j )
      scanf("%d", (char *)&graph + 40 * i + 4 * j);
  }
  printf("\nEnter the starting node: ");
  scanf("%d", &v4);
  --v4;
  for ( i = 0; i < n; ++i )
    visited[i] = 0;
  printf("\nDFS traversal: ");
  DFS(v4);
  printf("\n");
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall DFS(_QWORD);
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400181E0: using guessed type _DWORD visited[10];
// 140018208: using guessed type int n;

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: multiplayer
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int binarySearch(int arr[], int l, int r, int x){
    while(l <= r){
        int mid = l + (r-l)/2;
 
        if(arr[mid] == x)
            return mid;
 
        if(arr[mid] < x)
            l = mid + 1;

        else
            r = mid - 1;
    }

    return -1;
}

int* generateRandomNumbers(int n){
    int *arr = malloc(n * sizeof(int));
    srand(time(NULL));
    for(int i = 0; i < n; i++){
        arr[i] = rand() % 100;
    }
    return arr;
}

int main(){
    int n, *arr, x;
    printf("Enter length of array: ");
    scanf("%d", &n);

    arr = generateRandomNumbers(n);
    printf("Generated Random Array: ");
    for(int i = 0; i < n; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Input value to search
    printf("Enter a value to search: ");
    scanf("%d", &x);

    int index = binarySearch(arr, 0, n-1, x);

    if(index == -1)
        printf("%d not found in the array\n", x);
    else
        printf("%d found at index %d\n", x, index);

    free(arr);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall generateRandomNumbers(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (0000000140001725) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-1Ch] BYREF
  unsigned int v5; // [rsp+28h] [rbp-18h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-14h]
  void *Block; // [rsp+30h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter length of array: ");
  scanf("%d", &v5);
  Block = (void *)generateRandomNumbers(v5);
  printf("Generated Random Array: ");
  for ( i = 0; i < (int)v5; ++i )
    printf("%d ", *((unsigned int *)Block + i));
  printf("\n");
  printf("Enter a value to search: ");
  scanf("%d", &v4);
  v6 = binarySearch(Block, 0i64, v5 - 1, v4);
  if ( v6 == -1 )
    printf("%d not found in the array\n", v4);
  else
    printf("%d found at index %d\n", v4, v6);
  free(Block);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001695: using guessed type __int64 __fastcall generateRandomNumbers(_QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Periodic Table Quiz ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the maximum length of element names and symbols
#define MAX_NAME_LEN 20
#define MAX_SYMBOL_LEN 3

// Define the maximum number of elements in the periodic table
#define MAX_NUM_ELEMENTS 118

// Define a struct for an element
typedef struct {
    char name[MAX_NAME_LEN];
    char symbol[MAX_SYMBOL_LEN];
    int atomic_number;
} element;

// Define a function to create a new element
element* create_element(char* name, char* symbol, int atomic_number) {
    element* new_element = malloc(sizeof(element));
    strcpy(new_element->name, name);
    strcpy(new_element->symbol, symbol);
    new_element->atomic_number = atomic_number;
    return new_element;
}

// Define the periodic table as a global array of element pointers
element* periodic_table[MAX_NUM_ELEMENTS];

// Define a function to add an element to the periodic table
void add_element_to_periodic_table(element* new_element) {
    periodic_table[new_element->atomic_number - 1] = new_element;
}

// Define a function to print an element
void print_element(element* elem) {
    printf("%d. %s (%s)\n", elem->atomic_number, elem->symbol, elem->name);
}

// Define the main function
int main() {
    // Create some elements
    element* hydrogen = create_element("Hydrogen", "H", 1);
    element* helium = create_element("Helium", "He", 2);
    element* lithium = create_element("Lithium", "Li", 3);
    element* beryllium = create_element("Beryllium", "Be", 4);
    
    // Add the elements to the periodic table
    add_element_to_periodic_table(hydrogen);
    add_element_to_periodic_table(helium);
    add_element_to_periodic_table(lithium);
    add_element_to_periodic_table(beryllium);
    
    // Print all elements in the periodic table
    printf("Periodic Table:\n");
    for (int i = 0; i < MAX_NUM_ELEMENTS; i++) {
        if (periodic_table[i] != NULL) {
            print_element(periodic_table[i]);
        }
    }
    
    // Free memory used by the elements
    free(hydrogen);
    free(helium);
    free(lithium);
    free(beryllium);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall create_element(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall add_element_to_periodic_table(_QWORD); // weak
__int64 __fastcall print_element(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);

//-------------------------------------------------------------------------
// Data declarations

_QWORD periodic_table[120]; // weak


//----- (0000000140001656) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v4; // [rsp+28h] [rbp-28h]
  void *v5; // [rsp+30h] [rbp-20h]
  void *element; // [rsp+38h] [rbp-18h]
  void *Block; // [rsp+40h] [rbp-10h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  Block = (void *)create_element("Hydrogen", "H", 1i64);
  element = (void *)create_element("Helium", "He", 2i64);
  v5 = (void *)create_element("Lithium", "Li", 3i64);
  v4 = (void *)create_element("Beryllium", "Be", 4i64);
  add_element_to_periodic_table(Block);
  add_element_to_periodic_table(element);
  add_element_to_periodic_table(v5);
  add_element_to_periodic_table(v4);
  printf("Periodic Table:\n");
  for ( i = 0; i <= 117; ++i )
  {
    if ( periodic_table[i] )
      print_element(periodic_table[i]);
  }
  free(Block);
  free(element);
  free(v5);
  free(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall create_element(_QWORD, _QWORD, _QWORD);
// 1400015EB: using guessed type __int64 __fastcall add_element_to_periodic_table(_QWORD);
// 140001619: using guessed type __int64 __fastcall print_element(_QWORD);
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type _QWORD periodic_table[120];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  // Array of possible fortunes
  char *fortunes[] = {"A bright future awaits you.", 
                      "You will have a successful career.",
                      "A long-awaited opportunity will come your way.",
                      "Unexpected money will come to you.",
                      "A romantic relationship will flourish."};

  // Seed the random number generator with system time
  srand(time(NULL));

  // Generate a random index to select a fortune from the array
  int random_index = rand() % 5;

  // Print the fortune to the user
  printf("Your fortune for today is: %s\n", fortunes[random_index]);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5[5]; // [rsp+20h] [rbp-30h]
  int v6; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5[0] = (__int64)"A bright future awaits you.";
  v5[1] = (__int64)"You will have a successful career.";
  v5[2] = (__int64)"A long-awaited opportunity will come your way.";
  v5[3] = (__int64)"Unexpected money will come to you.";
  v5[4] = (__int64)"A romantic relationship will flourish.";
  v3 = time(0i64);
  srand(v3);
  v6 = rand() % 5;
  printf("Your fortune for today is: %s\n", (const char *)v5[v6]);
  return 0;
}
// 140001710: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Encyptor ; Style: complete
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {

    // Check if the file name is provided as argument
    if (argc < 2) {
        printf("Please provide a file name.\n");
        return 1;
    }
    
    // Open the file in read mode
    FILE *fp = fopen(argv[1], "r");
    
    // Check if the file is opened successfully
    if (fp == NULL) {
        printf("Error opening the file.\n");
        return 1;
    }
    
    // Get the file size
    fseek(fp, 0L, SEEK_END);
    int file_size = ftell(fp);
    fseek(fp, 0L, SEEK_SET);
    
    // Allocate memory for the file content buffer
    char *file_content = (char*) malloc(file_size);
    
    // Read the file contents into the buffer
    fread(file_content, sizeof(char), file_size, fp);
    
    // Close the file
    fclose(fp);
    
    // Define the encryption key
    char key[] = "mysecretkey";
    int key_len = strlen(key);
    
    // Encrypt the file contents
    for (int i = 0; i < file_size; i++) {
        file_content[i] ^= key[i % key_len];
    }
    
    // Create a new file and write the encrypted contents to it
    char output_file_name[50];
    strcpy(output_file_name, "encrypted_");
    strcat(output_file_name, argv[1]);
    
    FILE *output_fp = fopen(output_file_name, "w");
    
    if (output_fp == NULL) {
        printf("Error creating the output file.\n");
        return 1;
    }
    
    fwrite(file_content, sizeof(char), file_size, output_fp);
    
    fclose(output_fp);
    
    printf("Encryption successful.\nNew file: %s\n", output_file_name);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcat(char *Destination, const char *Source);
// void *__cdecl malloc(size_t Size);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Destination[52]; // [rsp+20h] [rbp-70h] BYREF
  char Str[12]; // [rsp+54h] [rbp-3Ch] BYREF
  FILE *v6; // [rsp+60h] [rbp-30h]
  int v7; // [rsp+6Ch] [rbp-24h]
  void *Buffer; // [rsp+70h] [rbp-20h]
  int v9; // [rsp+7Ch] [rbp-14h]
  FILE *Stream; // [rsp+80h] [rbp-10h]
  int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  if ( argc > 1 )
  {
    Stream = fopen(argv[1], "r");
    if ( Stream )
    {
      fseek(Stream, 0, 2);
      v9 = ftell(Stream);
      fseek(Stream, 0, 0);
      Buffer = malloc(v9);
      fread(Buffer, 1ui64, v9, Stream);
      fclose(Stream);
      strcpy(Str, "mysecretkey");
      v7 = strlen(Str);
      for ( i = 0; i < v9; ++i )
        *((_BYTE *)Buffer + i) ^= Str[i % v7];
      strcpy(Destination, "encrypted_");
      strcat(Destination, argv[1]);
      v6 = fopen(Destination, "w");
      if ( v6 )
      {
        fwrite(Buffer, 1ui64, v9, v6);
        fclose(v6);
        printf("Encryption successful.\nNew file: %s\n", Destination);
        return 0;
      }
      else
      {
        printf("Error creating the output file.\n");
        return 1;
      }
    }
    else
    {
      printf("Error opening the file.\n");
      return 1;
    }
  }
  else
  {
    printf("Please provide a file name.\n");
    return 1;
  }
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int download_speed, upload_speed, ping_time;
    srand(time(0)); //ensuring randomization
    printf("Welcome to the Chuck Norris Internet Speed Test!\n");
    printf("Please wait while we try to establish a connection with the internet...\n");
    sleep(3); //adding some suspense
    printf("Connection established successfully!\n\n");
    printf("Checking download speed...\n");
    download_speed = rand() % 101; //randomizing download speed from 0 to 100 Mbps
    printf("Download speed: %d Mbps\n", download_speed);
    if (download_speed >= 90)
    {
        printf("Chuck Norris approves!\n");
    }
    else if (download_speed >= 70 && download_speed < 90)
    {
        printf("Not bad, but Chuck Norris expects more!\n");
    }
    else
    {
        printf("Chuck Norris is not impressed!\n");
    }
    printf("\nChecking upload speed...\n");
    upload_speed = rand() % 101; //randomizing upload speed from 0 to 100 Mbps
    printf("Upload speed: %d Mbps\n", upload_speed);
    if (upload_speed >= 90)
    {
        printf("Chuck Norris approves!\n");
    }
    else if (upload_speed >= 70 && upload_speed < 90)
    {
        printf("Not bad, but Chuck Norris expects more!\n");
    }
    else
    {
        printf("Chuck Norris is not impressed!\n");
    }
    printf("\nChecking ping time...\n");
    ping_time = rand() % 51; //randomizing ping time from 0 to 50 ms
    printf("Ping time: %d ms\n", ping_time);
    if (ping_time <= 5)
    {
        printf("Chuck Norris approves!\n");
    }
    else if (ping_time > 5 && ping_time <= 20)
    {
        printf("Not bad, but Chuck Norris expects more!\n");
    }
    else
    {
        printf("Chuck Norris is not impressed!\n");
    }
    printf("\nThank you for taking the Chuck Norris Internet Speed Test!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-Ch]
  int v6; // [rsp+28h] [rbp-8h]
  int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Chuck Norris Internet Speed Test!\n");
  printf("Please wait while we try to establish a connection with the internet...\n");
  sleep(3i64);
  printf("Connection established successfully!\n\n");
  printf("Checking download speed...\n");
  v7 = rand() % 101;
  printf("Download speed: %d Mbps\n", (unsigned int)v7);
  if ( v7 <= 89 )
  {
    if ( v7 <= 69 )
      printf("Chuck Norris is not impressed!\n");
    else
      printf("Not bad, but Chuck Norris expects more!\n");
  }
  else
  {
    printf("Chuck Norris approves!\n");
  }
  printf("\nChecking upload speed...\n");
  v6 = rand() % 101;
  printf("Upload speed: %d Mbps\n", (unsigned int)v6);
  if ( v6 <= 89 )
  {
    if ( v6 <= 69 )
      printf("Chuck Norris is not impressed!\n");
    else
      printf("Not bad, but Chuck Norris expects more!\n");
  }
  else
  {
    printf("Chuck Norris approves!\n");
  }
  printf("\nChecking ping time...\n");
  v5 = rand() % 51;
  printf("Ping time: %d ms\n", (unsigned int)v5);
  if ( v5 > 5 )
  {
    if ( v5 > 20 )
      printf("Chuck Norris is not impressed!\n");
    else
      printf("Not bad, but Chuck Norris expects more!\n");
  }
  else
  {
    printf("Chuck Norris approves!\n");
  }
  printf("\nThank you for taking the Chuck Norris Internet Speed Test!\n");
  return 0;
}
// 140001674: conditional instruction was optimized away because %var_4.4 is in (46..59)
// 140001705: conditional instruction was optimized away because %var_8.4 is in (46..59)
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400028F0: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Natural Language Date Converter ; Style: irregular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_INPUT_LENGTH 100

// function to convert month from string to integer
int month_to_num(char *month) {
    char *months[12] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
    for (int i = 0; i < 12; i++) {
        if (strcmp(month, months[i]) == 0) {
            return i + 1;
        }
    }
    return -1;
}

// function to convert integer month to string
char *num_to_month(int month) {
    char *months[12] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
    return months[month - 1];
}

// function to check if leap year
int is_leap_year(int year) {
    if (year % 4 == 0) {
        if (year % 100 == 0) {
            if (year % 400 == 0) {
                return 1;
            } else {
                return 0;
            }
        } else {
            return 1;
        }
    } else {
        return 0;
    }
}

int main() {
    char input[MAX_INPUT_LENGTH];
    int year, month, day;

    printf("Welcome to Natural Language Date Converter\n\n");
    printf("Please enter the date in natural language format (e.g. January 1st, 2022): ");
    fgets(input, MAX_INPUT_LENGTH, stdin);

    // remove newline character at end of input
    input[strcspn(input, "\n")] = 0;

    // parse input using %s and %d format specifiers
    sscanf(input, "%s %d, %d", input, &day, &year);

    // get month as integer
    month = month_to_num(input);

    if (month != -1) {
        // valid month
        if (day > 0 && day <= 31) {
            // valid day
            if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {
                printf("Invalid date\n");
            } else if (month == 2) {
                if ((is_leap_year(year) && day > 29) || (!is_leap_year(year) && day > 28)) {
                    printf("Invalid date\n");
                } else {
                    printf("The date is %s %d, %d\n", num_to_month(month), day, year);
                }
            } else {
                printf("The date is %s %d, %d\n", num_to_month(month), day, year);
            }
        } else {
            printf("Invalid date\n");
        }
    } else {
        printf("Invalid date\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sscanf(const char *const Buffer, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall month_to_num(_QWORD); // weak
__int64 __fastcall num_to_month(_QWORD); // weak
__int64 __fastcall is_leap_year(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400017C8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v4; // esi
  unsigned int v5; // ebx
  const char *v6; // rax
  int v8; // [rsp+38h] [rbp-78h] BYREF
  unsigned int v9; // [rsp+3Ch] [rbp-74h] BYREF
  char Buffer[108]; // [rsp+40h] [rbp-70h] BYREF
  unsigned int v11; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to Natural Language Date Converter\n\n");
  printf("Please enter the date in natural language format (e.g. January 1st, 2022): ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  sscanf(Buffer, "%s %d, %d", Buffer, &v8, &v9);
  v11 = month_to_num(Buffer);
  if ( v11 == -1
    || v8 <= 0
    || v8 > 31
    || (v11 == 4 || v11 == 6 || v11 == 9 || v11 == 11) && v8 > 30
    || v11 == 2 && ((unsigned int)is_leap_year(v9) && v8 > 29 || !(unsigned int)is_leap_year(v9) && v8 > 28) )
  {
    printf("Invalid date\n");
  }
  else
  {
    v4 = v9;
    v5 = v8;
    v6 = (const char *)num_to_month(v11);
    printf("The date is %s %d, %d\n", v6, v5, v4);
  }
  return 0;
}
// 1400015D4: using guessed type __int64 __fastcall month_to_num(_QWORD);
// 1400016AA: using guessed type __int64 __fastcall num_to_month(_QWORD);
// 14000174C: using guessed type __int64 __fastcall is_leap_year(_QWORD);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400017C8: using guessed type char Buffer[108];

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Log analysis ; Style: shape shifting
#include <stdio.h>
#include <string.h>

int main() {

  char log_file[100];    // name of the log file

  printf("Enter the name of the log file: ");
  scanf("%s", log_file);

  FILE *log_ptr;     // log file pointer
  char log_line[1000];    // buffer to store each line of the log
  int error_count = 0;    // count of error lines in the log

  log_ptr = fopen(log_file, "r");    // open the log file in read mode

  if (log_ptr == NULL) {
    printf("Error: Unable to open log file!\n");
    return 0;
  }

  while (fgets(log_line, sizeof(log_line), log_ptr)) {
    char log_state[10];    // variable to track the state of each log line
      
    // check for errors in the log line
    if (strstr(log_line, "ERROR") != NULL) {
      error_count++;
      strcpy(log_state, "error");
    } else if (strstr(log_line, "WARNING") != NULL) {
      strcpy(log_state, "warning");
    } else {
      strcpy(log_state, "normal");
    }

    // print the log line with appropriate formatting based on its state
    if (strcmp(log_state, "error") == 0) {
      printf("\033[31m%s\033[0m", log_line);    // if error, print in red
    } else if (strcmp(log_state, "warning") == 0) {
      printf("\033[33m%s\033[0m", log_line);    // if warning, print in yellow
    } else {
      printf("%s", log_line);    // if normal, print as is
    }
  }

  printf("Total number of error lines: %d\n", error_count);

  fclose(log_ptr);    // close the log file

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[10]; // [rsp+26h] [rbp-5Ah] BYREF
  char Str[1008]; // [rsp+30h] [rbp-50h] BYREF
  char FileName[112]; // [rsp+420h] [rbp+3A0h] BYREF
  FILE *Stream; // [rsp+490h] [rbp+410h]
  unsigned int v8; // [rsp+49Ch] [rbp+41Ch]

  _main(argc, argv, envp);
  printf("Enter the name of the log file: ");
  scanf("%s", FileName);
  v8 = 0;
  Stream = fopen(FileName, "r");
  if ( Stream )
  {
    while ( fgets(Str, 1000, Stream) )
    {
      if ( strstr(Str, "ERROR") )
      {
        ++v8;
        strcpy(Str1, "error");
      }
      else if ( strstr(Str, "WARNING") )
      {
        strcpy(Str1, "warning");
      }
      else
      {
        strcpy(Str1, "normal");
      }
      if ( !strcmp(Str1, "error") )
      {
        printf("\x1B[31m%s\x1B[0m", Str);
      }
      else if ( !strcmp(Str1, "warning") )
      {
        printf("\x1B[33m%s\x1B[0m", Str);
      }
      else
      {
        printf("%s", Str);
      }
    }
    printf("Total number of error lines: %d\n", v8);
    fclose(Stream);
    return 0;
  }
  else
  {
    printf("Error: Unable to open log file!\n");
    return 0;
  }
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: String manipulation ; Style: complex
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

//Function to reverse a string
void reverse(char *str, int len) 
{ 
    int i, j; 
    char temp;
    
    for (i = 0, j = len - 1; i < j; i++, j--) {
        temp = *(str+i);
        *(str+i) = *(str+j);
        *(str+j) = temp;
    }
} 

//Function to remove whitespace from a string
void remove_whitespace(char *str) 
{
    char *new_str = str;
    do {
        while(*new_str == ' ') {
            ++new_str;
        }
    } while(*str++ = *new_str++);
}

//Function to convert a string to uppercase
void uppercase(char *str)
{
    while (*str) {
        *str = toupper(*str);
        str++;
    }
}

//Function to convert a string to lowercase
void lowercase(char *str)
{
    while (*str) {
        *str = tolower(*str);
        str++;
    }
}

int main() 
{ 
    char str[100]; 
    int choice, len;
    
    printf("Enter a string: "); 
    fgets(str, sizeof(str), stdin);
    len = strlen(str);
    
    printf("Enter your choice:\n1. Reverse the string\n2. Remove whitespace from the string\n3. Convert the string to uppercase\n4. Convert the string to lowercase\n"); 
    scanf("%d", &choice); 
    
    switch (choice) {
        case 1: 
            reverse(str, len); 
            printf("The reversed string is: %s\n", str); 
            break;
            
        case 2:
            remove_whitespace(str); 
            printf("The string without whitespace is: %s\n", str); 
            break;
            
        case 3: 
            uppercase(str); 
            printf("The uppercase string is: %s\n", str); 
            break;
            
        case 4:
            lowercase(str); 
            printf("The lowercase string is: %s\n", str); 
            break;
            
        default: 
            printf("Invalid choice.\n");
    }
    
    return 0; 
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall reverse(_QWORD, _QWORD); // weak
__int64 __fastcall remove_whitespace(_QWORD); // weak
__int64 __fastcall uppercase(_QWORD); // weak
__int64 __fastcall lowercase(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001730) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v5; // [rsp+2Ch] [rbp-74h] BYREF
  char Buffer[108]; // [rsp+30h] [rbp-70h] BYREF
  unsigned int v7; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter a string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  v7 = strlen(Buffer);
  printf(
    "Enter your choice:\n"
    "1. Reverse the string\n"
    "2. Remove whitespace from the string\n"
    "3. Convert the string to uppercase\n"
    "4. Convert the string to lowercase\n");
  scanf("%d", &v5);
  if ( v5 == 4 )
  {
    lowercase(Buffer);
    printf("The lowercase string is: %s\n", Buffer);
  }
  else
  {
    if ( v5 > 4 )
    {
LABEL_11:
      printf("Invalid choice.\n");
      return 0;
    }
    switch ( v5 )
    {
      case 3:
        uppercase(Buffer);
        printf("The uppercase string is: %s\n", Buffer);
        break;
      case 1:
        reverse(Buffer, v7);
        printf("The reversed string is: %s\n", Buffer);
        break;
      case 2:
        remove_whitespace(Buffer);
        printf("The string without whitespace is: %s\n", Buffer);
        break;
      default:
        goto LABEL_11;
    }
  }
  return 0;
}
// 1400017C5: conditional instruction was optimized away because %var_74.4<3
// 1400015E2: using guessed type __int64 __fastcall reverse(_QWORD, _QWORD);
// 140001660: using guessed type __int64 __fastcall remove_whitespace(_QWORD);
// 1400016B2: using guessed type __int64 __fastcall uppercase(_QWORD);
// 1400016F1: using guessed type __int64 __fastcall lowercase(_QWORD);
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System administration ; Style: random
/*
 * This program demonstrates the use of system administration commands in C.
 * It asks the user for a command to run and executes it using the system() function.
 * It can also display the contents of a file and write to a file using the relevant commands.
 * Written by Random Coder on a whim.
 */

#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int choice;
    char command[100], filename[20], content[1000];

    printf("Welcome to System Administration with C!\n");

    do {
        printf("\nChoose an action:\n"
               "1. Run a command\n"
               "2. Display the contents of a file\n"
               "3. Write to a file\n"
               "4. Exit\n"
               "Choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("\nEnter the command to run: ");
                scanf("%s", command);
                system(command);
                break;
            case 2:
                printf("\nEnter the name of the file: ");
                scanf("%s", filename);
                sprintf(command, "cat %s", filename);
                system(command);
                break;
            case 3:
                printf("\nEnter the name of the file: ");
                scanf("%s", filename);
                printf("Enter the content to write: ");
                getchar();
                fgets(content, sizeof content, stdin);
                sprintf(command, "echo '%s' > %s", content, filename);
                system(command);
                break;
            case 4:
                printf("\nGoodbye!\n");
                break;
            default:
                printf("\nInvalid choice\n");
        }
    } while (choice != 4);

    return EXIT_SUCCESS;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl system(const char *Command);
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1008]; // [rsp+20h] [rbp-60h] BYREF
  char v6[32]; // [rsp+410h] [rbp+390h] BYREF
  char Command[108]; // [rsp+430h] [rbp+3B0h] BYREF
  int v8; // [rsp+49Ch] [rbp+41Ch] BYREF

  _main(argc, argv, envp);
  printf("Welcome to System Administration with C!\n");
  do
  {
    printf("\nChoose an action:\n1. Run a command\n2. Display the contents of a file\n3. Write to a file\n4. Exit\nChoice: ");
    scanf("%d", &v8);
    if ( v8 == 4 )
    {
      printf("\nGoodbye!\n");
    }
    else
    {
      if ( v8 <= 4 )
      {
        switch ( v8 )
        {
          case 3:
            printf("\nEnter the name of the file: ");
            scanf("%s", v6);
            printf("Enter the content to write: ");
            getchar();
            v3 = __acrt_iob_func(0);
            fgets(Buffer, 1000, v3);
            sprintf(Command, "echo '%s' > %s", Buffer, v6);
            system(Command);
            continue;
          case 1:
            printf("\nEnter the command to run: ");
            scanf("%s", Command);
            system(Command);
            continue;
          case 2:
            printf("\nEnter the name of the file: ");
            scanf("%s", v6);
            sprintf(Command, "cat %s", v6);
            system(Command);
            continue;
        }
      }
      printf("\nInvalid choice\n");
    }
  }
  while ( v8 != 4 );
  return 0;
}
// 140001695: conditional instruction was optimized away because %var_4.4<3
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: authentic
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 10 // the maximum size of the array

/* function to swap two elements in an array */
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

/* function to perform bubble sort */
void bubble_sort(int arr[], int n) {
    for(int i=0;i<n-1;i++) {
        for(int j=0;j<n-i-1;j++) {
            if(arr[j] > arr[j+1]) {
                swap(&arr[j], &arr[j+1]);
            }
        }
    }
}

/* function to perform selection sort */
void selection_sort(int arr[], int n) {
    int min_idx;
    for(int i=0;i<n-1;i++) {
        min_idx = i;
        for(int j=i+1;j<n;j++) {
            if(arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        swap(&arr[i], &arr[min_idx]);
    }
}

/* function to perform insertion sort */
void insertion_sort(int arr[], int n) {
    int key, j;
    for(int i=1;i<n;i++) {
        key = arr[i];
        j = i - 1;
        while(j >= 0 && arr[j] > key) {
            arr[j+1] = arr[j];
            j = j - 1;
        }
        arr[j+1] = key;
    }
}

int main() {
    int arr[MAX_SIZE], n, choice;
    printf("Enter the size of the array (maximum 10): ");
    scanf("%d", &n);
    printf("Enter the elements of the array: ");
    for(int i=0;i<n;i++) {
        scanf("%d", &arr[i]);
    }
    printf("Enter your choice of sorting algorithm:\n");
    printf("1. Bubble Sort\n");
    printf("2. Selection Sort\n");
    printf("3. Insertion Sort\n");
    printf("Your choice: ");
    scanf("%d", &choice);
    switch(choice) {
        case 1:
            bubble_sort(arr, n);
            printf("Sorted array using Bubble Sort: ");
            break;
        case 2:
            selection_sort(arr, n);
            printf("Sorted array using Selection Sort: ");
            break;
        case 3:
            insertion_sort(arr, n);
            printf("Sorted array using Insertion Sort: ");
            break;
        default:
            printf("Invalid choice.\n");
            exit(0);
    }
    for(int i=0;i<n;i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall bubble_sort(_QWORD, _QWORD); // weak
__int64 __fastcall selection_sort(_QWORD, _QWORD); // weak
__int64 __fastcall insertion_sort(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001853) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-38h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-34h] BYREF
  int v6[10]; // [rsp+30h] [rbp-30h] BYREF
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the size of the array (maximum 10): ");
  scanf("%d", &v5);
  printf("Enter the elements of the array: ");
  for ( i = 0; i < (int)v5; ++i )
    scanf("%d", &v6[i]);
  printf("Enter your choice of sorting algorithm:\n");
  printf("1. Bubble Sort\n");
  printf("2. Selection Sort\n");
  printf("3. Insertion Sort\n");
  printf("Your choice: ");
  scanf("%d", &v4);
  if ( v4 == 3 )
  {
    insertion_sort(v6, v5);
    printf("Sorted array using Insertion Sort: ");
  }
  else
  {
    if ( v4 > 3 )
      goto LABEL_12;
    if ( v4 == 1 )
    {
      bubble_sort(v6, v5);
      printf("Sorted array using Bubble Sort: ");
    }
    else
    {
      if ( v4 != 2 )
      {
LABEL_12:
        printf("Invalid choice.\n");
        exit(0);
      }
      selection_sort(v6, v5);
      printf("Sorted array using Selection Sort: ");
    }
  }
  for ( j = 0; j < (int)v5; ++j )
    printf("%d ", (unsigned int)v6[j]);
  printf("\n");
  return 0;
}
// 140001617: using guessed type __int64 __fastcall bubble_sort(_QWORD, _QWORD);
// 1400016D0: using guessed type __int64 __fastcall selection_sort(_QWORD, _QWORD);
// 140001789: using guessed type __int64 __fastcall insertion_sort(_QWORD, _QWORD);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001853: using guessed type int var_30[10];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: careful
#include<stdio.h>

#define ROW 10
#define COL 10

//function to check if the given indices are within the maze bounds
int isSafe(int maze[][COL], int i, int j, int n, int m){
    if(i>=0 && i<n && j>=0 && j<m && maze[i][j]==1)
        return 1;
    return 0;
}

//function to print the path
void printSolution(int sol[][COL], int n, int m){
    printf("\nPath:\n");
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            printf("%d ", sol[i][j]);
        }
        printf("\n");
    }
}

//function to find the path from starting position to ending position in the given maze
int mazePath(int maze[][COL], int i, int j, int n, int m, int sol[][COL], int x, int y){

    if(i==x && j==y){
        sol[i][j]=1;
        return 1;
    }

    if(isSafe(maze, i, j, n, m)){
        sol[i][j]=1;

        if(mazePath(maze, i+1, j, n, m, sol, x, y)==1)
            return 1;

        if(mazePath(maze, i, j+1, n, m, sol, x, y)==1)
            return 1;

        sol[i][j]=0; 
   		//backtracking
    }

    return 0;
}

int main(){
    int maze[ROW][COL]={
        {1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
        {1, 0, 1, 0, 1, 1, 1, 0, 1, 1},
        {1, 1, 1, 0, 1, 1, 0, 1, 0, 1},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
        {1, 1, 1, 0, 1, 1, 1, 0, 1, 0},
        {1, 0, 1, 1, 1, 1, 0, 1, 0, 0},
        {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
        {1, 1, 0, 0, 0, 0, 1, 0, 0, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    };

    int sol[ROW][COL]={0}; //initialize all values of sol[][] as 0

    int startX=0, startY=0, endX=9, endY=9; //starting and ending positions in the maze

    printf("Maze:\n");
    for(int i=0;i<ROW;i++){
        for(int j=0;j<COL;j++){
            printf("%d ", maze[i][j]);
        }
        printf("\n");
    }

    if(mazePath(maze, startX, startY, ROW, COL, sol, endX, endY)==1)
        printSolution(sol, ROW, COL);
    else
        printf("No path found");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printSolution(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall mazePath(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, _DWORD, _DWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (0000000140001804) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[400]; // [rsp+40h] [rbp-40h] BYREF
  int v5[102]; // [rsp+1D0h] [rbp+150h] BYREF
  int v6; // [rsp+368h] [rbp+2E8h]
  int v7; // [rsp+36Ch] [rbp+2ECh]
  int v8; // [rsp+370h] [rbp+2F0h]
  int v9; // [rsp+374h] [rbp+2F4h]
  int j; // [rsp+378h] [rbp+2F8h]
  int i; // [rsp+37Ch] [rbp+2FCh]

  _main(argc, argv, envp);
  qmemcpy(v5, &unk_14000A020, 0x190ui64);
  memset(v4, 0, sizeof(v4));
  v9 = 0;
  v8 = 0;
  v7 = 9;
  v6 = 9;
  printf("Maze:\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      printf("%d ", (unsigned int)v5[10 * i + j]);
    printf("\n");
  }
  if ( (unsigned int)mazePath((unsigned int)v5, v9, v8, 10, 10, (__int64)v4, v7, v6) == 1 )
    printSolution(v4, 10i64, 10i64);
  else
    printf("No path found");
  return 0;
}
// 1400015F9: using guessed type __int64 __fastcall printSolution(_QWORD, _QWORD, _QWORD);
// 140001693: using guessed type __int64 __fastcall mazePath(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, _DWORD, _DWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001804: using guessed type int var_1C0[102];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Hexadecimal Converter ; Style: active
#include <stdio.h>

int main() {
  int inputNum;
  printf("Enter a decimal number: ");
  scanf("%d", &inputNum);

  char hexNum[10];
  int quotient, remainder;
  int i = 0;

  while (inputNum > 0) {
    quotient = inputNum / 16;
    remainder = inputNum % 16;

    if (remainder < 10) {
      hexNum[i++] = remainder + 48;
    } else {
      hexNum[i++] = remainder + 55;
    }

    inputNum = quotient;
  }

  printf("\nHexadecimal Equivalent: ");
  for (int j = i - 1; j >= 0; j--) {
    printf("%c", hexNum[j]);
  }

  printf("\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  char v5[10]; // [rsp+22h] [rbp-1Eh]
  int v6; // [rsp+2Ch] [rbp-14h] BYREF
  int v7; // [rsp+30h] [rbp-10h]
  int v8; // [rsp+34h] [rbp-Ch]
  int i; // [rsp+38h] [rbp-8h]
  int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter a decimal number: ");
  scanf("%d", &v6);
  v10 = 0;
  while ( v6 > 0 )
  {
    v8 = v6 >> 4;
    v7 = v6 % 16;
    v3 = v10++;
    if ( v6 % 16 > 9 )
      v5[v3] = v7 + 55;
    else
      v5[v3] = v7 + 48;
    v6 = v8;
  }
  printf("\nHexadecimal Equivalent: ");
  for ( i = v10 - 1; i >= 0; --i )
    printf("%c", (unsigned int)v5[i]);
  printf("\n");
  return 0;
}
// 140001625: conditional instruction was optimized away because %var_14.4>=1
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_1E[10];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Auction System ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//define constants
#define MAX_ITEMS 100
#define MAX_NAME_LENGTH 50

//declare struct item
struct item {
    char name[MAX_NAME_LENGTH];
    int current_bid;
};

//declare global variables
struct item items[MAX_ITEMS];
int num_items = 0;

//function prototypes
void display_menu();
void add_item();
void view_items();
void make_bid();

int main() {
    int choice;

    while(1) {
        display_menu(); //display main menu
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch(choice) {
            case 1:
                add_item(); //add a new item for auction
                break;
            case 2:
                view_items(); //display all items currently available for auction
                break;
            case 3:
                make_bid(); //allow a user to make a bid on an item
                break;
            case 4:
                printf("Exiting program...\n");
                exit(0); //exit the program
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}

//function to display menu options
void display_menu() {
    printf("\n****** Digital Auction System ******\n");
    printf("1. Add item\n");
    printf("2. View items\n");
    printf("3. Make bid\n");
    printf("4. Exit\n");
}

//function to add item to items array
void add_item() {
    if(num_items >= MAX_ITEMS) {
        printf("Maximum number of items reached.\n");
        return;
    }

    printf("Enter name of item: ");
    scanf("%s", items[num_items].name);
    printf("Enter starting bid: ");
    scanf("%d", &items[num_items].current_bid);

    printf("Item added successfully.\n");
    num_items++;
}

//function to view all items currently available for auction
void view_items() {
    if(num_items == 0) {
        printf("No items currently available for auction.\n");
        return;
    }

    printf("\nItems currently available for auction:\n");

    for(int i = 0; i < num_items; i++) {
        printf("%d. %s\t\tCurrent bid: $%d\n", i+1, items[i].name, items[i].current_bid);
    }
}

//function to allow a user to make a bid on an item
void make_bid() {
    if(num_items == 0) {
        printf("No items currently available for auction.\n");
        return;
    }

    char item_name[MAX_NAME_LENGTH];
    int bid_amount;

    printf("Enter name of item to bid on: ");
    scanf("%s", item_name);

    int index = -1;

    //find item in items array
    for(int i = 0; i < num_items; i++) {
        if(strcmp(items[i].name, item_name) == 0) {
            index = i;
            break;
        }
    }

    if(index == -1) {
        printf("Item not found.\n");
        return;
    }

    printf("Current bid for %s: $%d\n", item_name, items[index].current_bid);

    while(1) {
        printf("Enter your bid: ");
        scanf("%d", &bid_amount);

        if(bid_amount <= items[index].current_bid) {
            printf("Bid must be higher than current bid. Please try again.\n");
        }
        else {
            items[index].current_bid = bid_amount;
            printf("Bid accepted. New bid for %s is $%d.\n", item_name, items[index].current_bid);
            break;
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 display_menu(void); // weak
__int64 add_item(void); // weak
__int64 view_items(void); // weak
__int64 make_bid(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    display_menu();
    printf("Enter your choice: ");
    scanf("%d", &v3);
    if ( v3 == 4 )
    {
      printf("Exiting program...\n");
      exit(0);
    }
    if ( v3 > 4 )
    {
LABEL_12:
      printf("Invalid choice. Please try again.\n");
    }
    else
    {
      switch ( v3 )
      {
        case 3:
          make_bid();
          break;
        case 1:
          add_item();
          break;
        case 2:
          view_items();
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 14000162E: conditional instruction was optimized away because %var_4.4<3
// 14000167E: using guessed type __int64 display_menu(void);
// 1400016D8: using guessed type __int64 add_item(void);
// 1400017AF: using guessed type __int64 view_items(void);
// 14000185E: using guessed type __int64 make_bid(void);
// 140001AD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Matrix operations ; Style: surprised
#include <stdio.h>

int main() {
    printf("Hold on to your hats, folks! We're about to perform some matrix operations!\n");

    // Matrix A
    int A[3][3] = {{1, 2, 3},
                   {4, 5, 6},
                   {7, 8, 9}};

    // Matrix B
    int B[3][3] = {{9, 8, 7},
                   {6, 5, 4},
                   {3, 2, 1}};

    printf("Matrix A:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", A[i][j]);
        }
        printf("\n");
    }

    printf("Matrix B:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", B[i][j]);
        }
        printf("\n");
    }

    printf("Let's add them up! Here's the result of A + B:\n");
    int C[3][3];
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            C[i][j] = A[i][j] + B[i][j];
            printf("%d ", C[i][j]);
        }
        printf("\n");
    }

    printf("And now, let's subtract them. Here's the result of A - B:\n");
    int D[3][3];
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            D[i][j] = A[i][j] - B[i][j];
            printf("%d ", D[i][j]);
        }
        printf("\n");
    }

    printf("Whoa, it's not over yet! Let's multiply them now. Here's the result of A * B:\n");
    int E[3][3];
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            E[i][j] = 0;
            for (int k = 0; k < 3; k++) {
                E[i][j] += A[i][k] * B[k][j];
            }
            printf("%d ", E[i][j]);
        }
        printf("\n");
    }

    printf("Oh yeah, we just multiplied them like a boss.\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[36]; // [rsp+20h] [rbp-60h]
  int v5[12]; // [rsp+B0h] [rbp+30h]
  int v6[9]; // [rsp+E0h] [rbp+60h]
  int i1; // [rsp+104h] [rbp+84h]
  int nn; // [rsp+108h] [rbp+88h]
  int mm; // [rsp+10Ch] [rbp+8Ch]
  int kk; // [rsp+110h] [rbp+90h]
  int jj; // [rsp+114h] [rbp+94h]
  int ii; // [rsp+118h] [rbp+98h]
  int n; // [rsp+11Ch] [rbp+9Ch]
  int m; // [rsp+120h] [rbp+A0h]
  int k; // [rsp+124h] [rbp+A4h]
  int j; // [rsp+128h] [rbp+A8h]
  int i; // [rsp+12Ch] [rbp+ACh]

  _main(argc, argv, envp);
  printf("Hold on to your hats, folks! We're about to perform some matrix operations!\n");
  v6[0] = 1;
  v6[1] = 2;
  v6[2] = 3;
  v6[3] = 4;
  v6[4] = 5;
  v6[5] = 6;
  v6[6] = 7;
  v6[7] = 8;
  v6[8] = 9;
  v5[0] = 9;
  v5[1] = 8;
  v5[2] = 7;
  v5[3] = 6;
  v5[4] = 5;
  v5[5] = 4;
  v5[6] = 3;
  v5[7] = 2;
  v5[8] = 1;
  printf("Matrix A:\n");
  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      printf("%d ", (unsigned int)v6[3 * i + j]);
    printf("\n");
  }
  printf("Matrix B:\n");
  for ( k = 0; k <= 2; ++k )
  {
    for ( m = 0; m <= 2; ++m )
      printf("%d ", (unsigned int)v5[3 * k + m]);
    printf("\n");
  }
  printf("Let's add them up! Here's the result of A + B:\n");
  for ( n = 0; n <= 2; ++n )
  {
    for ( ii = 0; ii <= 2; ++ii )
    {
      v4[3 * n + 24 + ii] = v5[3 * n + ii] + v6[3 * n + ii];
      printf("%d ", (unsigned int)v4[3 * n + 24 + ii]);
    }
    printf("\n");
  }
  printf("And now, let's subtract them. Here's the result of A - B:\n");
  for ( jj = 0; jj <= 2; ++jj )
  {
    for ( kk = 0; kk <= 2; ++kk )
    {
      v4[3 * jj + 12 + kk] = v6[3 * jj + kk] - v5[3 * jj + kk];
      printf("%d ", (unsigned int)v4[3 * jj + 12 + kk]);
    }
    printf("\n");
  }
  printf("Whoa, it's not over yet! Let's multiply them now. Here's the result of A * B:\n");
  for ( mm = 0; mm <= 2; ++mm )
  {
    for ( nn = 0; nn <= 2; ++nn )
    {
      v4[3 * mm + nn] = 0;
      for ( i1 = 0; i1 <= 2; ++i1 )
        v4[3 * mm + nn] += v6[3 * mm + i1] * v5[3 * i1 + nn];
      printf("%d ", (unsigned int)v4[3 * mm + nn]);
    }
    printf("\n");
  }
  printf("Oh yeah, we just multiplied them like a boss.\n");
  return 0;
}
// 140001B90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: Romeo and Juliet
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define ROWS 4
#define COLS 4

char gameBoard[ROWS][COLS] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'};
char displayBoard[ROWS][COLS] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};
int flippedCards[2][2];
int score = 0;
int attempts = 0;

void displayBoardState() {
    printf("\n\n\n\n\t\t\t%c\t\t\t%c\t\t\t%c\t\t\t%c\n\n\n", displayBoard[0][0], displayBoard[0][1], displayBoard[0][2], displayBoard[0][3]);
    printf("\t\t\t%c\t\t\t%c\t\t\t%c\t\t\t%c\n\n\n", displayBoard[1][0], displayBoard[1][1], displayBoard[1][2], displayBoard[1][3]);
    printf("\t\t\t%c\t\t\t%c\t\t\t%c\t\t\t%c\n\n\n", displayBoard[2][0], displayBoard[2][1], displayBoard[2][2], displayBoard[2][3]);
    printf("\t\t\t%c\t\t\t%c\t\t\t%c\t\t\t%c\n\n\n", displayBoard[3][0], displayBoard[3][1], displayBoard[3][2], displayBoard[3][3]);
}

void shuffleCards(char arr[]) {
    int n = strlen(arr);
    for(int i = 0; i < n; i++) {
        int j = rand() % (i + 1);
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

void checkMatch() {
    int row1 = flippedCards[0][0];
    int col1 = flippedCards[0][1];
    int row2 = flippedCards[1][0];
    int col2 = flippedCards[1][1];
    if(gameBoard[row1][col1] == gameBoard[row2][col2]) {
        displayBoard[row1][col1] = gameBoard[row1][col1];
        displayBoard[row2][col2] = gameBoard[row2][col2];
        printf("\n\n\t\t\tMATCH FOUND! WELL DONE!\n\n");
        score++;
    } else {
        displayBoard[row1][col1] = ' ';
        displayBoard[row2][col2] = ' ';
        printf("\n\n\t\t\tNO MATCH FOUND. TRY AGAIN!\n\n");
    }
    attempts++;
    printf("\n\n\t\t\tATTEMPTS: %d", attempts);
    printf("\t\t\t\tSCORE: %d", score);
}

void playRound() {
    int row, col;
    printf("\n\n\t\t\tENTER ROW: ");
    scanf("%d", &row);
    printf("\n\n\t\t\tENTER COLUMN: ");
    scanf("%d", &col);
    row--;
    col--;
    if(row > 3 || col > 3 || row < 0 || col < 0) {
        printf("\n\n\t\t\tINVALID ENTRY. PLEASE TRY AGAIN.\n\n");
    } else if(displayBoard[row][col] == gameBoard[row][col]) {
        printf("\n\n\t\t\tCARD ALREADY FLIPPED. PLEASE TRY AGAIN.\n\n");
    } else {
        displayBoard[row][col] = gameBoard[row][col];
        printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\tFLIPPED CARD: %c", gameBoard[row][col]);
        if(flippedCards[0][0] == -1 && flippedCards[0][1] == -1) {
            flippedCards[0][0] = row;
            flippedCards[0][1] = col;
        } else {
            flippedCards[1][0] = row;
            flippedCards[1][1] = col;
            checkMatch();
            flippedCards[0][0] = -1;
            flippedCards[0][1] = -1;
            flippedCards[1][0] = -1;
            flippedCards[1][1] = -1;
        }
    }
    displayBoardState();
}

int main() {
    srand(time(0));
    shuffleCards(gameBoard);
    displayBoardState();
    while(score < 8) {
        playRound();
    }
    printf("\n\n\t\t\tCONGRATULATIONS! YOU WON IN %d ATTEMPTS", attempts);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 displayBoardState(void); // weak
__int64 __fastcall shuffleCards(_QWORD); // weak
__int64 playRound(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN gameBoard; // weak
int score; // weak
int attempts; // weak


//----- (0000000140001B1D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  shuffleCards(&gameBoard);
  displayBoardState();
  while ( score <= 7 )
    playRound();
  printf("\n\n\t\t\tCONGRATULATIONS! YOU WON IN %d ATTEMPTS", (unsigned int)attempts);
  return 0;
}
// 140001601: using guessed type __int64 displayBoardState(void);
// 140001720: using guessed type __int64 __fastcall shuffleCards(_QWORD);
// 14000194A: using guessed type __int64 playRound(void);
// 140001C40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019050: using guessed type int score;
// 140019054: using guessed type int attempts;

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File system simulation ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Defining the disk size and the block size
#define DISK_SIZE 1000
#define BLOCK_SIZE 10

// Defining the struct for the file
typedef struct File {
    char name[20];
    int start_block;
    int num_blocks;
} File;

// Defining the disk as a global variable
char disk[DISK_SIZE];

// Defining the function to initialize the disk
void initialize_disk() {
    memset(disk, '-', DISK_SIZE);
}

// Defining the function to print the contents of the disk
void print_disk() {
    printf("DISK CONTENTS:\n");
    for (int i=0; i<DISK_SIZE; i+=BLOCK_SIZE) {
        printf("%.*s ", BLOCK_SIZE, &disk[i]);
    }
    printf("\n");
}

// Defining the function to create a file
void create_file(char name[]) {
    // Checking if the filename already exists
    for (int i=0; i<DISK_SIZE; i+=BLOCK_SIZE) {
        if (memcmp(&disk[i], name, strlen(name)) == 0) {
            printf("Error: File '%s' already exists\n", name);
            return;
        }
    }

    // Finding available blocks to store the file
    int start_block = -1;
    for (int i=0; i<DISK_SIZE; i+=BLOCK_SIZE) {
        if (disk[i] == '-') {
            start_block = i;
            break;
        }
    }
    if (start_block == -1) {
        printf("Error: Disk is full\n");
        return;
    }

    // Calculating the number of blocks necessary for the file
    int num_blocks = (int)(strlen(name) + BLOCK_SIZE - 1) / BLOCK_SIZE;

    // Creating the file
    File new_file;
    strcpy(new_file.name, name);
    new_file.start_block = start_block;
    new_file.num_blocks = num_blocks;

    // Writing the file to the disk
    memcpy(&disk[start_block], name, strlen(name));
    for (int i=start_block+strlen(name); i<start_block+num_blocks*BLOCK_SIZE; i++) {
        disk[i] = '#';
    }

    printf("File '%s' created at block %d\n", name, start_block/BLOCK_SIZE);
}

// Defining the function to delete a file
void delete_file(char name[]) {
    // Finding the file and its location in the disk
    int file_index = -1;
    for (int i=0; i<DISK_SIZE; i+=BLOCK_SIZE) {
        if (memcmp(&disk[i], name, strlen(name)) == 0) {
            file_index = i;
            break;
        }
    }
    if (file_index == -1) {
        printf("Error: File '%s' not found\n", name);
        return;
    }

    // Clearing and freeing the blocks used by the file
    int start_block = file_index;
    int num_blocks = (int)(strlen(name) + BLOCK_SIZE - 1) / BLOCK_SIZE;
    for (int i=start_block; i<start_block+num_blocks*BLOCK_SIZE; i++) {
        disk[i] = '-';
    }

    printf("File '%s' deleted from block %d\n", name, file_index/BLOCK_SIZE);
}

// Defining the main function
int main() {
    // Initializing the disk
    initialize_disk();

    // Creating files
    create_file("file1.txt");
    create_file("file2.txt");
    create_file("file3.txt");
    create_file("file4.txt");
    create_file("file5.txt");

    // Printing the disk contents
    print_disk();

    // Deleting files
    delete_file("file2.txt");
    delete_file("file4.txt");

    // Printing the disk contents again
    print_disk();

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 initialize_disk(void); // weak
__int64 print_disk(void); // weak
__int64 __fastcall create_file(_QWORD); // weak
__int64 __fastcall delete_file(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  initialize_disk();
  create_file("file1.txt");
  create_file("file2.txt");
  create_file("file3.txt");
  create_file("file4.txt");
  create_file("file5.txt");
  print_disk();
  delete_file("file2.txt");
  delete_file("file4.txt");
  print_disk();
  return 0;
}
// 140001591: using guessed type __int64 initialize_disk(void);
// 1400015BA: using guessed type __int64 print_disk(void);
// 140001623: using guessed type __int64 __fastcall create_file(_QWORD);
// 1400017C8: using guessed type __int64 __fastcall delete_file(_QWORD);
// 140001A30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue Implementation ; Style: medieval
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Defining the structure of a Queue node.
struct QueueNode {
    int data;
    struct QueueNode* next;
};

// Defining the structure of a Queue.
struct Queue {
    struct QueueNode *front, *rear;
};

// Function to create a new Queue node.
struct QueueNode* createQueueNode(int data) {
    struct QueueNode* temp = (struct QueueNode*)malloc(sizeof(struct QueueNode));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

// Function to create a new Queue.
struct Queue* createQueue() {
    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
    q->front = q->rear = NULL;
    return q;
}

// Function to check if a Queue is empty.
int isEmpty(struct Queue* q) {
    return (q->front == NULL);
}

// Function to add an element to the Queue.
void enqueue(struct Queue* q, int data) {
    struct QueueNode* temp = createQueueNode(data);
    if (q->rear == NULL) {
        q->front = q->rear = temp; 
        return;
    }
    q->rear->next = temp;
    q->rear = temp;
}

// Function to remove an element from the Queue.
int dequeue(struct Queue* q) {
    if (isEmpty(q)) {
        return -1;
    }
    struct QueueNode* temp = q->front;
    int data = temp->data;
    q->front = q->front->next;
    if (q->front == NULL) {
        q->rear = NULL;
    }
    free(temp);
    return data;
}

int main() {
    // Creating a new Queue.
    struct Queue* queue = createQueue();
    printf("Greetings! Welcome to the medieval Queue. Shall we build one?\n\n");

    // Waiting for the user to respond.
    while(1) {
        printf("Please enter 'Aye' to add an element to the Queue, 'Nay' to remove an element from the Queue and 'Farewell' to exit.\n");
        char input[50];
        scanf("%s", input);
        
        // Checking the user's response and taking the appropriate action.
        if (strcmp(input, "Aye") == 0) {
            printf("Please enter an integer to add to the Queue: ");
            int data;
            scanf("%d", &data);
            enqueue(queue, data);
            printf("%d has been added to the Queue.\n", data);
        }
        else if (strcmp(input, "Nay") == 0) {
            int data = dequeue(queue);
            if (data == -1) {
                printf("The Queue is empty!\n");
            }
            else {
                printf("%d has been removed from the Queue.\n", data);
            }
        }
        else if (strcmp(input, "Farewell") == 0) {
            printf("Farewell, my dear friend. May the blessings of the Queen guide you on your journey.\n");
            break;
        }
        else {
            printf("That's not a valid command, my friend. Please try again.\n");
        }
    }
    
    // Freeing the memory used by the Queue.
    struct QueueNode* current = queue->front;
    while (current != NULL) {
        struct QueueNode* temp = current;
        current = current->next;
        free(temp);
    }
    free(queue);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 createQueue(void); // weak
__int64 __fastcall enqueue(_QWORD, _QWORD); // weak
__int64 __fastcall dequeue(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl free(void *Block);


//----- (000000014000174B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[64]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v5; // [rsp+60h] [rbp-20h] BYREF
  unsigned int v6; // [rsp+64h] [rbp-1Ch]
  void *Block; // [rsp+68h] [rbp-18h]
  void *Queue; // [rsp+70h] [rbp-10h]
  _QWORD *v9; // [rsp+78h] [rbp-8h]

  _main(argc, argv, envp);
  Queue = (void *)createQueue();
  printf("Greetings! Welcome to the medieval Queue. Shall we build one?\n\n");
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        printf(
          "Please enter 'Aye' to add an element to the Queue, 'Nay' to remove an element from the Queue and 'Farewell' to exit.\n");
        scanf("%s", Str1);
        if ( strcmp(Str1, "Aye") )
          break;
        printf("Please enter an integer to add to the Queue: ");
        scanf("%d", &v5);
        enqueue(Queue, v5);
        printf("%d has been added to the Queue.\n", v5);
      }
      if ( strcmp(Str1, "Nay") )
        break;
      v6 = dequeue(Queue);
      if ( v6 == -1 )
        printf("The Queue is empty!\n");
      else
        printf("%d has been removed from the Queue.\n", v6);
    }
    if ( !strcmp(Str1, "Farewell") )
      break;
    printf("That's not a valid command, my friend. Please try again.\n");
  }
  printf("Farewell, my dear friend. May the blessings of the Queen guide you on your journey.\n");
  v9 = *(_QWORD **)Queue;
  while ( v9 )
  {
    Block = v9;
    v9 = (_QWORD *)v9[1];
    free(Block);
  }
  free(Queue);
  return 0;
}
// 14000161A: using guessed type __int64 createQueue(void);
// 14000166F: using guessed type __int64 __fastcall enqueue(_QWORD, _QWORD);
// 1400016D8: using guessed type __int64 __fastcall dequeue(_QWORD);
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL)); // seed the random number generator with the current time

    int fortune_number = rand() % 5; // generate a random number from 0 to 4

    printf("Greetings, fellow human. I am the Automated Fortune Teller. Are you ready to receive your fortune?\n"); // start of conversation

    char response[4];
    scanf("%s", response); // get user response
    if (response[0] == 'y' || response[0] == 'Y') {
        printf("Excellent. Your fortune awaits...\n");
        switch (fortune_number) {
            case 0:
                printf("You will discover a hidden talent in the near future. Embrace it.\n");
                break;
            case 1:
                printf("A great love will enter your life soon. Be open to it.\n");
                break;
            case 2:
                printf("You will experience a windfall of money in the coming weeks. Use it wisely.\n");
                break;
            case 3:
                printf("Your health will improve dramatically in the next month. Take advantage of it.\n");
                break;
            case 4:
                printf("A long-standing problem will finally be resolved in the near future. You'll feel a weight lifted off your shoulders.\n");
                break;
        }
    } else {
        printf("I understand. Perhaps another time. Goodbye.\n"); // end of conversation
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[4]; // [rsp+28h] [rbp-8h] BYREF
  int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v6 = rand() % 5;
  printf("Greetings, fellow human. I am the Automated Fortune Teller. Are you ready to receive your fortune?\n");
  scanf("%s", v5);
  if ( v5[0] == 121 || v5[0] == 89 )
  {
    printf("Excellent. Your fortune awaits...\n");
    switch ( v6 )
    {
      case 0:
        printf("You will discover a hidden talent in the near future. Embrace it.\n");
        break;
      case 1:
        printf("A great love will enter your life soon. Be open to it.\n");
        break;
      case 2:
        printf("You will experience a windfall of money in the coming weeks. Use it wisely.\n");
        break;
      case 3:
        printf("Your health will improve dramatically in the next month. Take advantage of it.\n");
        break;
      case 4:
        printf(
          "A long-standing problem will finally be resolved in the near future. You'll feel a weight lifted off your shoulders.\n");
        break;
      default:
        return 0;
    }
  }
  else
  {
    printf("I understand. Perhaps another time. Goodbye.\n");
  }
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001601: using guessed type char var_8[4];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data validation ; Style: expert-level
#include <stdio.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>

#define MAX_LENGTH 100

bool is_valid_integer(char* str) {
    if (*str == '\0') {
        return false;
    }
    if (*str == '-') {
        str++;
    }
    while (*str != '\0') {
        if (!isdigit(*str)) {
            return false;
        }
        str++;
    }
    return true;
}

bool is_valid_float(char* str) {
    if (*str == '\0') {
        return false;
    }
    if (*str == '-') {
        str++;
    }
    bool has_dot = false;
    while (*str != '\0') {
        if (*str == '.') {
            if (has_dot) {
                return false;
            } else {
                has_dot = true;
            }
        } else if (!isdigit(*str)) {
            return false;
        }
        str++;
    }
    return true;
}

bool is_valid_string(char* str) {
    if (*str == '\0') {
        return false;
    }
    while (*str != '\0') {
        if (!isalpha(*str)) {
            return false;
        }
        str++;
    }
    return true;
}

int main() {
    char input[MAX_LENGTH];
    printf("Enter an integer: ");
    fgets(input, MAX_LENGTH, stdin);
    input[strcspn(input, "\n")] = '\0'; // Remove newline character
    while (!is_valid_integer(input)) {
        printf("Invalid input. Try again: ");
        fgets(input, MAX_LENGTH, stdin);
        input[strcspn(input, "\n")] = '\0'; // Remove newline character
    }
    int num = atoi(input);
    printf("Valid input: %d\n", num);

    printf("Enter a float: ");
    fgets(input, MAX_LENGTH, stdin);
    input[strcspn(input, "\n")] = '\0'; // Remove newline character
    while (!is_valid_float(input)) {
        printf("Invalid input. Try again: ");
        fgets(input, MAX_LENGTH, stdin);
        input[strcspn(input, "\n")] = '\0'; // Remove newline character
    }
    float fnum = atof(input);
    printf("Valid input: %f\n", fnum);

    printf("Enter a string: ");
    fgets(input, MAX_LENGTH, stdin);
    input[strcspn(input, "\n")] = '\0'; // Remove newline character
    while (!is_valid_string(input)) {
        printf("Invalid input. Try again: ");
        fgets(input, MAX_LENGTH, stdin);
        input[strcspn(input, "\n")] = '\0'; // Remove newline character
    }
    printf("Valid input: %s\n", input);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall is_valid_integer(_QWORD); // weak
__int64 __fastcall is_valid_float(_QWORD); // weak
__int64 __fastcall is_valid_string(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl atoi(const char *String);
// double __cdecl atof(const char *String);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016CC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  FILE *v6; // rax
  int v7; // eax
  FILE *v8; // rax
  FILE *v9; // rax
  char Buffer[104]; // [rsp+20h] [rbp-70h] BYREF
  float v12; // [rsp+88h] [rbp-8h]
  unsigned int v13; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter an integer: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  while ( (unsigned __int8)is_valid_integer(Buffer) != 1 )
  {
    printf("Invalid input. Try again: ");
    v4 = __acrt_iob_func(0);
    fgets(Buffer, 100, v4);
    Buffer[strcspn(Buffer, "\n")] = 0;
  }
  v13 = atoi(Buffer);
  printf("Valid input: %d\n", v13);
  printf("Enter a float: ");
  v5 = __acrt_iob_func(0);
  fgets(Buffer, 100, v5);
  Buffer[strcspn(Buffer, "\n")] = 0;
  while ( (unsigned __int8)is_valid_float(Buffer) != 1 )
  {
    printf("Invalid input. Try again: ");
    v6 = __acrt_iob_func(0);
    fgets(Buffer, 100, v6);
    Buffer[strcspn(Buffer, "\n")] = 0;
  }
  atof(Buffer);
  v12 = (float)v7;
  printf("Valid input: %f\n", (float)v7);
  printf("Enter a string: ");
  v8 = __acrt_iob_func(0);
  fgets(Buffer, 100, v8);
  Buffer[strcspn(Buffer, "\n")] = 0;
  while ( (unsigned __int8)is_valid_string(Buffer) != 1 )
  {
    printf("Invalid input. Try again: ");
    v9 = __acrt_iob_func(0);
    fgets(Buffer, 100, v9);
    Buffer[strcspn(Buffer, "\n")] = 0;
  }
  printf("Valid input: %s\n", Buffer);
  return 0;
}
// 14000186D: variable 'v7' is possibly undefined
// 140001591: using guessed type __int64 __fastcall is_valid_integer(_QWORD);
// 1400015ED: using guessed type __int64 __fastcall is_valid_float(_QWORD);
// 140001673: using guessed type __int64 __fastcall is_valid_string(_QWORD);
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016CC: using guessed type char Buffer[104];

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: romantic
#include <stdio.h>
#include <string.h>

/* Function to get the date in the format of dd/mm/yyyy */
void getDateString(char *dateString) {
    char day[3], month[3], year[5];
    printf("Enter the date (dd/mm/yyyy): ");
    scanf("%2s/%2s/%4s", day, month, year);

    /* Concatenate the day, month, and year to form the date string */
    strcpy(dateString, day);
    strcat(dateString, "/");
    strcat(dateString, month);
    strcat(dateString, "/");
    strcat(dateString, year);
}

/* Function to get the content for the diary entry */
void getContent(char *content) {
    printf("Enter your entry: \n");
    scanf(" %[^\n]s", content);
}

int main() {
    char fileName[50], dateString[11], content[1000], buffer[3000];
    FILE *fp;

    /* Get the file name for the diary entry */
    printf("Enter the file name: ");
    scanf("%s", fileName);

    /* Get the date for the diary entry */
    getDateString(dateString);

    /* Get the content for the diary entry */
    getContent(content);

    /* Open the file for appending */
    fp = fopen(fileName, "a");

    /* Append the date and content to the file */
    sprintf(buffer, "\nDate: %s\n%s\n", dateString, content);
    fprintf(fp, buffer);

    /* Close the file */
    fclose(fp);

    printf("\nYour diary entry has been saved!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
__int64 __fastcall getDateString(_QWORD); // weak
__int64 __fastcall getContent(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001743) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[3008]; // [rsp+20h] [rbp-60h] BYREF
  char v5[1013]; // [rsp+BE0h] [rbp+B60h] BYREF
  char v6[11]; // [rsp+FD5h] [rbp+F55h] BYREF
  char FileName[56]; // [rsp+FE0h] [rbp+F60h] BYREF
  FILE *Stream; // [rsp+1018h] [rbp+F98h]

  _main(argc, argv, envp);
  printf("Enter the file name: ");
  scanf("%s", FileName);
  getDateString(v6);
  getContent(v5);
  Stream = fopen(FileName, "a");
  sprintf(Buffer, "\nDate: %s\n%s\n", v6, v5);
  fprintf_0(Stream, Buffer);
  fclose(Stream);
  printf("\nYour diary entry has been saved!\n");
  return 0;
}
// 140001668: using guessed type __int64 __fastcall getDateString(_QWORD);
// 14000170E: using guessed type __int64 __fastcall getContent(_QWORD);
// 1400018E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Public-Key Algorithm Implementation ; Style: introspective
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <stdbool.h>

// Function to calculate greatest common divisor using Euclid's algorithm
// Will be used in calculating the public key
int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}

int main() {
    // Declare variables
    int p, q, n, phi, e, d;
    bool isPrime;

    // Seed random number generator
    srand(time(NULL));

    // Generate 2 prime numbers, p and q
    do {
        isPrime = true;

        // Generate p
        p = rand() % 100 + 1; // Generate random number from 1 to 100

        // Check if p is prime
        for (int i = 2; i <= sqrt(p); i++) {
            if (p % i == 0) {
                isPrime = false;
                break;
            }
        } 
    } while (!isPrime);

    do {
        isPrime = true;

        // Generate q
        q = rand() % 100 + 1; // Generate random number from 1 to 100

        // Check if q is prime
        for (int i = 2; i <= sqrt(q); i++) {
            if (q % i == 0) {
                isPrime = false;
                break;
            }
        } 
    } while (!isPrime);

    // Calculate n and phi
    n = p * q;
    phi = (p - 1) * (q - 1);

    // Choose e such that 1 < e < phi and gcd(e, phi) = 1
    do {
        e = rand() % (phi - 2) + 2; // Generate random number from 2 to phi-1
    } while (gcd(e, phi) != 1);

    // Calculate d such that d * e = 1 (mod phi)
    int k = 1;
    while ((k * phi + 1) % e != 0) {
        k++;
    }
    d = (k * phi + 1) / e;

    // Print results
    printf("p: %d\n", p);
    printf("q: %d\n", q);
    printf("n: %d\n", n);
    printf("phi: %d\n", phi);
    printf("e: %d\n", e);
    printf("d: %d\n", d);

    // Example encryption and decryption
    char plaintext = 'A';
    printf("Plaintext: %c\n", plaintext);
    int ciphertext = fmod(pow(plaintext, e), n);
    printf("Ciphertext: %d\n", ciphertext);
    char decrypted_text = fmod(pow(ciphertext, d), n);
    printf("Decrypted text: %c\n", decrypted_text);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall gcd(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl fmod(double X, double Y);
double __cdecl pow(double X, double Y);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015E0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  double v4; // xmm0_8
  double v5; // xmm0_8
  double v6; // xmm0_8
  int v8; // [rsp+30h] [rbp-30h]
  int v9; // [rsp+38h] [rbp-28h]
  int v10; // [rsp+3Ch] [rbp-24h]
  unsigned int v11; // [rsp+40h] [rbp-20h]
  int v12; // [rsp+44h] [rbp-1Ch]
  int v13; // [rsp+48h] [rbp-18h]
  int v14; // [rsp+4Ch] [rbp-14h]
  int k; // [rsp+50h] [rbp-10h]
  int j; // [rsp+54h] [rbp-Ch]
  int i; // [rsp+58h] [rbp-8h]
  char v18; // [rsp+5Fh] [rbp-1h]
  char v19; // [rsp+5Fh] [rbp-1h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  do
  {
    v18 = 1;
    v14 = rand() % 100 + 1;
    for ( i = 2; sqrt((double)v14) >= (double)i; ++i )
    {
      if ( !(v14 % i) )
      {
        v18 = 0;
        break;
      }
    }
  }
  while ( v18 != 1 );
  do
  {
    v19 = 1;
    v13 = rand() % 100 + 1;
    for ( j = 2; sqrt((double)v13) >= (double)j; ++j )
    {
      if ( !(v13 % j) )
      {
        v19 = 0;
        break;
      }
    }
  }
  while ( v19 != 1 );
  v12 = v13 * v14;
  v11 = (v14 - 1) * (v13 - 1);
  do
    v10 = rand() % (int)(v11 - 2) + 2;
  while ( (unsigned int)gcd((unsigned int)v10, v11) != 1 );
  for ( k = 1; (int)(v11 * k + 1) % v10; ++k )
    ;
  v9 = (int)(v11 * k + 1) / v10;
  printf("p: %d\n", (unsigned int)v14);
  printf("q: %d\n", (unsigned int)v13);
  printf("n: %d\n", (unsigned int)v12);
  printf("phi: %d\n", v11);
  printf("e: %d\n", (unsigned int)v10);
  printf("d: %d\n", (unsigned int)v9);
  printf("Plaintext: %c\n", 65i64);
  v4 = pow((double)65, (double)v10);
  v8 = (int)fmod(v4, (double)v12);
  printf("Ciphertext: %d\n", (unsigned int)v8);
  v5 = pow((double)v8, (double)v9);
  v6 = fmod(v5, (double)v12);
  printf("Decrypted text: %c\n", (unsigned int)(char)(int)v6);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall gcd(_QWORD, _QWORD);
// 1400019B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=149 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Online Examination System ; Style: innovative
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>

#define MAX_QUESTIONS 50
#define MAX_OPTIONS 4

//Structure to hold question and its answer options
typedef struct {
    char question[100];
    char options[MAX_OPTIONS][50];
    int correctOption;
} Question;

//Function to shuffle an array of integers
void shuffle(int *arr, int n) {
    srand(time(NULL));
    for(int i=n-1; i>0; i--) {
        int j = rand() % (i+1);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

int main() {
    //Initialize questions
    Question questions[MAX_QUESTIONS];
    strcpy(questions[0].question, "Which is the largest planet in our solar system?");
    strcpy(questions[0].options[0], "Earth");
    strcpy(questions[0].options[1], "Venus");
    strcpy(questions[0].options[2], "Jupiter");
    strcpy(questions[0].options[3], "Mars");
    questions[0].correctOption = 2;

    strcpy(questions[1].question, "Who painted the Mona Lisa?");
    strcpy(questions[1].options[0], "Leonardo da Vinci");
    strcpy(questions[1].options[1], "Pablo Picasso");
    strcpy(questions[1].options[2], "Vincent van Gogh");
    strcpy(questions[1].options[3], "Claude Monet");
    questions[1].correctOption = 0;

    //Add more questions (up to MAX_QUESTIONS)

    //Initialize variables
    int score = 0;
    int attemptedQuestions[MAX_QUESTIONS];
    for(int i=0; i<MAX_QUESTIONS; i++) {
        attemptedQuestions[i] = 0;
    }

    //Start exam
    printf("*** Welcome to the Online Examination System ***\n\n");

    int i=0;
    while(i < MAX_QUESTIONS) {
        //Select a random unattempted question
        int questionIndex = rand() % MAX_QUESTIONS;
        while(attemptedQuestions[questionIndex] == 1) {
            questionIndex = rand() % MAX_QUESTIONS;
        }

        attemptedQuestions[questionIndex] = 1;
        i++;

        //Prompt user for answer
        printf("Q%d. %s\n", i, questions[questionIndex].question);
        int optionIndices[MAX_OPTIONS] = {0, 1, 2, 3};
        shuffle(optionIndices, MAX_OPTIONS);

        for(int j=0; j<MAX_OPTIONS; j++) {
            printf("%d. %s\n", j+1, questions[questionIndex].options[optionIndices[j]]);
        }

        printf("Enter your answer (1-4): ");
        int answer;
        scanf("%d", &answer);

        if(answer == questions[questionIndex].correctOption+1) {
            printf("Correct!\n\n");
            score++;
        } else {
            printf("Wrong. The correct answer is %s\n\n", questions[questionIndex].options[questions[questionIndex].correctOption]);
        }
    }

    //Display final score
    printf("Exam Complete! You scored %d out of %d.\n", score, MAX_QUESTIONS);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall shuffle(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();


//----- (00000001400016AE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-54h] BYREF
  int v5[20]; // [rsp+30h] [rbp-50h] BYREF
  _BYTE v6[144]; // [rsp+80h] [rbp+0h] BYREF
  char v7[100]; // [rsp+110h] [rbp+90h] BYREF
  char v8[8]; // [rsp+174h] [rbp+F4h] BYREF
  char v9[8]; // [rsp+1A6h] [rbp+126h] BYREF
  __int64 v10; // [rsp+1D8h] [rbp+158h]
  char v11[8]; // [rsp+20Ah] [rbp+18Ah] BYREF
  int v12; // [rsp+23Ch] [rbp+1BCh]
  char v13[32]; // [rsp+240h] [rbp+1C0h] BYREF
  char v14[24]; // [rsp+2A4h] [rbp+224h] BYREF
  char v15[16]; // [rsp+2D6h] [rbp+256h] BYREF
  char v16[24]; // [rsp+308h] [rbp+288h] BYREF
  char v17[16]; // [rsp+33Ah] [rbp+2BAh] BYREF
  int v18; // [rsp+36Ch] [rbp+2ECh]
  int j; // [rsp+3C7Ch] [rbp+3BFCh]
  int v20; // [rsp+3C80h] [rbp+3C00h]
  int v21; // [rsp+3C84h] [rbp+3C04h]
  int i; // [rsp+3C88h] [rbp+3C08h]
  unsigned int v23; // [rsp+3C8Ch] [rbp+3C0Ch]

  _main(argc, argv, envp);
  strcpy(v7, "Which is the largest planet in our solar system?");
  strcpy(v8, "Earth");
  strcpy(v9, "Venus");
  v10 = 0x7265746970754Ai64;
  strcpy(v11, "Mars");
  v12 = 2;
  strcpy(v13, "Who painted the Mona Lisa?");
  strcpy(v14, "Leonardo da Vinci");
  strcpy(v15, "Pablo Picasso");
  strcpy(v16, "Vincent van Gogh");
  strcpy(v17, "Claude Monet");
  v18 = 0;
  v23 = 0;
  for ( i = 0; i <= 49; ++i )
    v5[i + 4] = 0;
  printf("*** Welcome to the Online Examination System ***\n\n");
  v21 = 0;
  while ( v21 <= 49 )
  {
    do
      v20 = rand() % 50;
    while ( v5[v20 + 4] == 1 );
    v5[v20 + 4] = 1;
    printf("Q%d. %s\n", (unsigned int)++v21, &v7[304 * v20]);
    v5[0] = 0;
    v5[1] = 1;
    v5[2] = 2;
    v5[3] = 3;
    shuffle(v5, 4i64);
    for ( j = 0; j <= 3; ++j )
      printf("%d. %s\n", (unsigned int)(j + 1), &v7[304 * v20 + 100 + 50 * v5[j]]);
    printf("Enter your answer (1-4): ");
    scanf("%d", &v4);
    if ( *(_DWORD *)&v6[304 * v20 + 444] + 1 == v4 )
    {
      printf("Correct!\n\n");
      ++v23;
    }
    else
    {
      printf("Wrong. The correct answer is %s\n\n", &v7[304 * v20 + 100 + 50 * *(int *)&v6[304 * v20 + 444]]);
    }
  }
  printf("Exam Complete! You scored %d out of %d.\n", v23, 50i64);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall shuffle(_QWORD, _QWORD);
// 140001C70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int min(int a, int b, int c)
{
    if (a < b && a < c)
        return a;
    if (b < a && b < c)
        return b;
    return c;
}

int ShapeShiftingLevenshteinDistance(char *s, char *t)
{
    int m = strlen(s);
    int n = strlen(t);
    int d[m + 1][n + 1];
    int i, j, cost;

    for (i = 0; i <= m; i++)
    {
        for (j = 0; j <= n; j++)
        {
            if (i == 0)
                d[i][j] = j;

            else if (j == 0)
                d[i][j] = i;

            else if (s[i - 1] == t[j - 1])
                d[i][j] = d[i - 1][j - 1];

            else
            {
                cost = 1;

                if (i > 2 && s[i - 3] == t[j - 1])
                    cost = 0;

                if (j > 2 && s[i - 1] == t[j - 3])
                    cost = 0;

                if (i > 2 && j > 2 && s[i - 3] == t[j - 3])
                {
                    if (s[i - 2] == t[j - 1] || s[i - 1] == t[j - 2])
                        cost = 0;
                }

                d[i][j] = min(d[i - 1][j] + 1, // deletion
                              d[i][j - 1] + 1, // insertion
                              d[i - 1][j - 1] + cost); // substitution
            }
        }
    }

    return d[m][n];
}

int main()
{
    char str1[] = "Hello World!";
    char str2[] = "Holla Warld!";
    printf("The Levenshtein Distance between \"%s\" and \"%s\" is: %d\n", str1, str2, ShapeShiftingLevenshteinDistance(str1, str2));
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall ShapeShiftingLevenshteinDistance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400019FA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char var1A[34]; // [rsp+26h] [rbp-1Ah] BYREF

  _main(argc, argv, envp);
  strcpy(&var1A[13], "Hello World!");
  strcpy(var1A, "Holla Warld!");
  v3 = ShapeShiftingLevenshteinDistance(&var1A[13], var1A);
  printf("The Levenshtein Distance between \"%s\" and \"%s\" is: %d\n", &var1A[13], var1A, v3);
  return 0;
}
// 1400015CE: using guessed type __int64 __fastcall ShapeShiftingLevenshteinDistance(_QWORD, _QWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MIN_PWD_LEN 8
#define MAX_PWD_LEN 16

typedef struct {
    char name[50];
    int score;
} player;

void check_password_strength(char *password, int *score) {
    int length = strlen(password);
    int lowercase = 0, uppercase = 0, digit = 0, special_char = 0;

    for (int i = 0; i < length; i++) {
        if (islower(password[i])) {
            lowercase++;
        } else if (isupper(password[i])) {
            uppercase++;
        } else if (isdigit(password[i])) {
            digit++;
        } else {
            special_char++;
        }
    }

    *score = 0;
    if (lowercase >= 2) {
        *score += 10;
    }
    if (uppercase >= 2) {
        *score += 10;
    }
    if (digit >= 2) {
        *score += 10;
    }
    if (special_char >= 2) {
        *score += 10;
    }
    if (length >= MIN_PWD_LEN && length <= MAX_PWD_LEN) {
        *score += 10;
    }

    // Password Scoring System
    if (*score >= 30 && *score <= 40) {
        printf("Your password strength is weak.\n");
    } else if (*score >= 50 && *score <= 60) {
        printf("Your password strength is average.\n");
    } else if (*score >= 70 && *score <= 80) {
        printf("Your password strength is strong.\n");
    } else if (*score >= 90) {
        printf("Your password strength is very strong.\n");
    } else {
        printf("Your password is too short or has too few requirements.\n");
    }
}

int main() {
    int num_players;
    printf("Enter the number of players: ");
    scanf("%d", &num_players);
    getchar(); // Consume the newline character in the input buffer

    player players[num_players];

    // Get player names
    for (int i = 0; i < num_players; i++) {
        printf("Enter player %d's name: ", i + 1);
        fgets(players[i].name, 50, stdin);
        players[i].name[strcspn(players[i].name, "\n")] = '\0'; // Remove newline character
    }

    // Get player password and check its strength
    for (int i = 0; i < num_players; i++) {
        char password[MAX_PWD_LEN + 1];
        printf("%s, enter your password (8-16 characters): ", players[i].name);
        fgets(password, MAX_PWD_LEN + 1, stdin);
        password[strcspn(password, "\n")] = '\0'; // Remove newline character
        int score;
        check_password_strength(password, &score);
        printf("Your score is %d.\n", score);
        players[i].score = score;
    }

    // Sort players in descending order of score
    for (int i = 0; i < num_players - 1; i++) {
        for (int j = 0; j < num_players - i - 1; j++) {
            if (players[j].score < players[j + 1].score) {
                player temp = players[j];
                players[j] = players[j + 1];
                players[j + 1] = temp;
            }
        }
    }

    // Display sorted list of players with their scores
    printf("\nLeaderboard:\n");
    for (int i = 0; i < num_players; i++) {
        printf("%d. %s - Score: %d\n", i + 1, players[i].name, players[i].score);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall check_password_strength(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400017CA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  FILE *v4; // rax
  size_t v5; // rax
  FILE *v6; // rax
  __int64 *v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rbx
  __int64 v10; // rbx
  __int64 *v11; // rdx
  __int64 *v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rbx
  __int64 v15; // rbx
  __int64 *v16; // rax
  __int64 v17; // rbx
  __int64 v18; // rbx
  __int64 v19; // rbx
  __int64 v21; // [rsp+20h] [rbp-80h] BYREF
  __int64 v22; // [rsp+28h] [rbp-78h]
  __int64 v23; // [rsp+30h] [rbp-70h]
  __int64 v24; // [rsp+38h] [rbp-68h]
  __int64 v25; // [rsp+40h] [rbp-60h]
  __int64 v26; // [rsp+48h] [rbp-58h]
  __int64 v27; // [rsp+50h] [rbp-50h]
  unsigned int v28; // [rsp+5Ch] [rbp-44h] BYREF
  char Buffer[20]; // [rsp+60h] [rbp-40h] BYREF
  int v30; // [rsp+74h] [rbp-2Ch] BYREF
  __int64 *v31; // [rsp+78h] [rbp-28h]
  __int64 v32; // [rsp+80h] [rbp-20h]
  int n; // [rsp+8Ch] [rbp-14h]
  int m; // [rsp+90h] [rbp-10h]
  int k; // [rsp+94h] [rbp-Ch]
  int j; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of players: ");
  scanf("%d", &v30);
  getchar();
  v32 = v30 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(56i64 * v30 + 15) >> 4));
  v31 = &v21;
  for ( i = 0; i < v30; ++i )
  {
    printf("Enter player %d's name: ", (unsigned int)(i + 1));
    v4 = __acrt_iob_func(0);
    fgets((char *)&v31[7 * i], 50, v4);
    v5 = strcspn((const char *)&v31[7 * i], "\n");
    *((_BYTE *)&v31[7 * i] + v5) = 0;
  }
  for ( j = 0; j < v30; ++j )
  {
    printf("%s, enter your password (8-16 characters): ", (const char *)&v31[7 * j]);
    v6 = __acrt_iob_func(0);
    fgets(Buffer, 17, v6);
    Buffer[strcspn(Buffer, "\n")] = 0;
    check_password_strength(Buffer, &v28);
    printf("Your score is %d.\n", v28);
    HIDWORD(v31[7 * j + 6]) = v28;
  }
  for ( k = 0; k < v30 - 1; ++k )
  {
    for ( m = 0; m < v30 - k - 1; ++m )
    {
      if ( SHIDWORD(v31[7 * m + 6]) < SHIDWORD(v31[7 * m + 13]) )
      {
        v7 = &v31[7 * m];
        v8 = v7[1];
        v21 = *v7;
        v22 = v8;
        v9 = v7[3];
        v23 = v7[2];
        v24 = v9;
        v10 = v7[5];
        v25 = v7[4];
        v26 = v10;
        v27 = v7[6];
        v11 = v7;
        v12 = &v31[7 * m + 7];
        v13 = v12[1];
        *v11 = *v12;
        v11[1] = v13;
        v14 = v12[3];
        v11[2] = v12[2];
        v11[3] = v14;
        v15 = v12[5];
        v11[4] = v12[4];
        v11[5] = v15;
        v11[6] = v12[6];
        v16 = &v31[7 * m + 7];
        v17 = v22;
        *v16 = v21;
        v16[1] = v17;
        v18 = v24;
        v16[2] = v23;
        v16[3] = v18;
        v19 = v26;
        v16[4] = v25;
        v16[5] = v19;
        v16[6] = v27;
      }
    }
  }
  printf("\nLeaderboard:\n");
  for ( n = 0; n < v30; ++n )
    printf("%d. %s - Score: %d\n", (unsigned int)(n + 1), (const char *)&v31[7 * n], HIDWORD(v31[7 * n + 6]));
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall check_password_strength(_QWORD, _QWORD);
// 140001D40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400017CA: using guessed type char Buffer[20];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Graph representation ; Style: innovative
#include <stdio.h>

int main()
{
    int i, j, n;

    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    char vertices[n];
    int edges[n][n];

    printf("Enter the names of the nodes: ");
    for(i=0; i<n; i++)
        scanf(" %c", &vertices[i]);

    printf("Enter the edges between the nodes: \n");
    for(i=0; i<n; i++)
    {
        for(j=0; j<n; j++)
        {
            printf("Is there an edge between node %c and node %c? (1 for yes, 0 for no): ", vertices[i], vertices[j]);
            scanf("%d", &edges[i][j]);
        }
    }

    printf("The graph is represented as:\n");

    //printing the vertices
    printf("\nVertices: ");
    for(i=0; i<n; i++)
        printf("%c ", vertices[i]);

    //printing the edges
    printf("\nEdges:\n   ");
    for(i=0; i<n; i++)
        printf("%c ", vertices[i]);
    for(i=0; i<n; i++)
    {
        printf("\n%c  ", vertices[i]);
        for(j=0; j<n; j++)
        {
            printf("%d ", edges[i][j]);
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  unsigned __int64 v4; // rbx
  void *v5; // rsp
  __int64 v7; // [rsp+0h] [rbp-B0h] BYREF
  char v8; // [rsp+20h] [rbp-90h] BYREF
  __int64 *v9; // [rsp+28h] [rbp-88h]
  __int64 v10; // [rsp+30h] [rbp-80h]
  __int64 v11; // [rsp+38h] [rbp-78h]
  __int64 v12; // [rsp+40h] [rbp-70h]
  __int64 v13; // [rsp+48h] [rbp-68h]
  __int64 v14; // [rsp+50h] [rbp-60h]
  __int64 v15; // [rsp+58h] [rbp-58h]
  __int64 v16; // [rsp+60h] [rbp-50h]
  __int64 v17; // [rsp+68h] [rbp-48h]
  int v18; // [rsp+7Ch] [rbp-34h] BYREF
  char *v19; // [rsp+80h] [rbp-30h]
  __int64 v20; // [rsp+88h] [rbp-28h]
  __int64 v21; // [rsp+90h] [rbp-20h]
  char *v22; // [rsp+98h] [rbp-18h]
  __int64 v23; // [rsp+A0h] [rbp-10h]
  int j; // [rsp+A8h] [rbp-8h]
  int i; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v9 = &v7;
  printf("Enter the number of nodes: ");
  scanf("%d", &v18);
  v23 = v18 - 1i64;
  v14 = v18;
  v15 = 0i64;
  v12 = v18;
  v13 = 0i64;
  v3 = alloca(16 * ((unsigned __int64)(v18 + 15i64) >> 4));
  v22 = &v8;
  v21 = v23;
  v10 = v18;
  v11 = 0i64;
  v4 = 4i64 * v18;
  v20 = v23;
  v16 = v18;
  v17 = 0i64;
  v5 = alloca(16 * ((unsigned __int64)(4 * v18 * (__int64)v18 + 15) >> 4));
  v19 = &v8;
  printf("Enter the names of the nodes: ");
  for ( i = 0; i < v18; ++i )
    scanf(" %c", &v22[i]);
  printf("Enter the edges between the nodes: \n");
  for ( i = 0; i < v18; ++i )
  {
    for ( j = 0; j < v18; ++j )
    {
      printf(
        "Is there an edge between node %c and node %c? (1 for yes, 0 for no): ",
        (unsigned int)v22[i],
        (unsigned int)v22[j]);
      scanf("%d", &v19[4 * j + 4 * (v4 >> 2) * i]);
    }
  }
  printf("The graph is represented as:\n");
  printf("\nVertices: ");
  for ( i = 0; i < v18; ++i )
    printf("%c ", (unsigned int)v22[i]);
  printf("\nEdges:\n   ");
  for ( i = 0; i < v18; ++i )
    printf("%c ", (unsigned int)v22[i]);
  for ( i = 0; i < v18; ++i )
  {
    printf("\n%c  ", (unsigned int)v22[i]);
    for ( j = 0; j < v18; ++j )
      printf("%d ", *(unsigned int *)&v19[4 * j + 4 * (v4 >> 2) * i]);
  }
  return 0;
}
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: enthusiastic
#include <stdio.h>

int main()
{
    printf("Welcome to my exciting file handling program!\n");

    // Creating a file and opening it in write mode
    FILE *fp = fopen("my_file.txt", "w");

    // Checking if the file opened successfully
    if (fp == NULL)
    {
        printf("Oops! Something went wrong while opening the file.\n");
        return 1;
    }

    printf("File created and opened successfully!\n");

    // Writing to the file
    fprintf(fp, "Hello, world!");

    // Closing the file
    fclose(fp);

    // Opening the file in read mode
    fp = fopen("my_file.txt", "r");

    // Checking if the file opened successfully
    if (fp == NULL)
    {
        printf("Oops! Something went wrong while opening the file.\n");
        return 1;
    }

    printf("\nFile opened successfully in read mode!\n");

    // Reading from the file and printing the contents
    char c;
    printf("Content of file: ");
    while((c=fgetc(fp))!=EOF) 
    {
        putchar(c);
    }

    // Closing the file
    fclose(fp);

    printf("\n\nHope you enjoyed my file handling program!");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl putchar(int Character);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+27h] [rbp-9h]
  FILE *Stream; // [rsp+28h] [rbp-8h]
  FILE *Streama; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to my exciting file handling program!\n");
  Stream = fopen("my_file.txt", "w");
  if ( Stream
    && (printf("File created and opened successfully!\n"),
        fprintf_0(Stream, "Hello, world!"),
        fclose(Stream),
        (Streama = fopen("my_file.txt", "r")) != 0i64) )
  {
    printf("\nFile opened successfully in read mode!\n");
    printf("Content of file: ");
    while ( 1 )
    {
      v4 = fgetc(Streama);
      if ( v4 == -1 )
        break;
      putchar(v4);
    }
    fclose(Streama);
    printf("\n\nHope you enjoyed my file handling program!");
    return 0;
  }
  else
  {
    printf("Oops! Something went wrong while opening the file.\n");
    return 1;
  }
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Public-Key Algorithm Implementation ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>
#include <time.h>

int gcd(int a, int b) 
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

// function to generate random prime number
int genPrime()
{
    int num = rand() % 100; // range of the prime number generated
    if (num < 2) num += 2; // make sure the number is not less than 2
    int i;
    for(i=2; i<=sqrt(num); i++) {
        if(num%i == 0) break; // if it is divisible, break
    }
    if(i > sqrt(num)) return num; // if it is prime, return
    else return genPrime(); // if not, generate again
}

int generateKeys(int p, int q, int *n, int *e, int *d)
{
    *n = p*q;
    int phi = (p-1)*(q-1);
    do {
        *e = rand() % phi; // choose a random number 1<e<phi
    } while(gcd(*e, phi) != 1); // make sure they are coprime
    int k = 1;
    while(1) {
        if(((k*phi)+1)%*e == 0) break; // calculate the d value
        k++; 
    }
    *d = ((k*phi)+1)/(*e);
}

int encrypt(int m, int e, int n)
{
    int st = m, ct = 1;
    for(int i=0; i<e; i++) {
        ct = (ct*st) % n;
    }
    return ct;
}

int decrypt(int ct, int d, int n)
{
    int st = ct, dt = 1;
    for(int i=0; i<d; i++) {
        dt = (dt*st) % n; // compute the message
    }
    return dt;
}

int main()
{
    srand(time(NULL));
    int p = genPrime(); // generate a large prime number
    int q = genPrime(); // repeat for a second prime number
    int n,e,d;
    generateKeys(p,q,&n,&e,&d);

    char msg[100];
    printf("Enter Message: ");
    fgets(msg, 100, stdin); // take input message

    int len = strlen(msg);
    int cipher[len];
    for(int i=0; i<len; i++) {
        cipher[i] = encrypt((int)msg[i], e, n); // encrypt each character of the message
    }

    printf("Encrypted message: ");
    for(int i=0; i<len; i++) {
        printf("%d ", cipher[i]); // print the encrypted message (cipher)
    }

    printf("\nDecrypted message: ");
    for(int i=0; i<len; i++) {
        printf("%c", (char)decrypt(cipher[i], d, n)); // print the decrypted message
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 genPrime(void); // weak
__int64 __fastcall generateKeys(_DWORD, _DWORD, _DWORD, _DWORD, __int64); // weak
__int64 __fastcall encrypt(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall decrypt(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void __cdecl srand(unsigned int Seed);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400017EC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  FILE *v4; // rax
  void *v5; // rsp
  char v6; // al
  char Buffer[108]; // [rsp+30h] [rbp-A0h] BYREF
  unsigned int v9; // [rsp+9Ch] [rbp-34h] BYREF
  unsigned int v10; // [rsp+A0h] [rbp-30h] BYREF
  unsigned int v11; // [rsp+A4h] [rbp-2Ch] BYREF
  char *v12; // [rsp+A8h] [rbp-28h]
  __int64 v13; // [rsp+B0h] [rbp-20h]
  int v14; // [rsp+B8h] [rbp-18h]
  int v15; // [rsp+BCh] [rbp-14h]
  int v16; // [rsp+C0h] [rbp-10h]
  int k; // [rsp+C4h] [rbp-Ch]
  int j; // [rsp+C8h] [rbp-8h]
  int i; // [rsp+CCh] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v16 = genPrime();
  v15 = genPrime();
  generateKeys(v16, v15, (unsigned int)&v11, (unsigned int)&v10, (__int64)&v9);
  printf("Enter Message: ");
  v4 = __acrt_iob_func(0);
  fgets(Buffer, 100, v4);
  v14 = strlen(Buffer);
  v13 = v14 - 1i64;
  v5 = alloca(16 * ((unsigned __int64)(4i64 * v14 + 15) >> 4));
  v12 = Buffer;
  for ( i = 0; i < v14; ++i )
    *(_DWORD *)&v12[4 * i] = encrypt((unsigned int)Buffer[i], v10, v11);
  printf("Encrypted message: ");
  for ( j = 0; j < v14; ++j )
    printf("%d ", *(unsigned int *)&v12[4 * j]);
  printf("\nDecrypted message: ");
  for ( k = 0; k < v14; ++k )
  {
    v6 = decrypt(*(unsigned int *)&v12[4 * k], v9, v11);
    printf("%c", (unsigned int)v6);
  }
  return 0;
}
// 1400015E0: using guessed type __int64 genPrime(void);
// 1400016AC: using guessed type __int64 __fastcall generateKeys(_DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 140001756: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD, _QWORD);
// 1400017A1: using guessed type __int64 __fastcall decrypt(_QWORD, _QWORD, _QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400017EC: using guessed type char Buffer[108];

// nfuncs=148 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Watermarking ; Style: retro
// Retro Style C Digital Watermarking Example Program

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_SIZE 1000

void embed_watermark(char* source_file, char* target_file, char* watermark);
void extract_watermark(char* watermarked_file);

int main(int argc, char* argv[]) {
    char source_file[MAX_SIZE], target_file[MAX_SIZE], watermark[MAX_SIZE];

    printf("Welcome to the Retro Style C Digital Watermarking Example Program!\n\n");

    printf("Enter the name of the source file: ");
    scanf("%s", source_file);

    printf("Enter the name of the target file: ");
    scanf("%s", target_file);

    printf("Enter the watermark: ");
    scanf("%s", watermark);

    embed_watermark(source_file, target_file, watermark);

    printf("\nWatermark has been embedded in the file successfully!\n\n");

    printf("Do you want to extract the watermark? (y/n): ");
    char response;
    scanf(" %c", &response);

    if(response == 'y' || response == 'Y') {
        extract_watermark(target_file);
    }

    return 0;
}

void embed_watermark(char* source_file, char* target_file, char* watermark) {
    FILE* source_fp, *target_fp;
    source_fp = fopen(source_file, "rb");
    target_fp = fopen(target_file, "wb");

    if(source_fp == NULL || target_fp == NULL) {
        printf("Error opening files. Aborting.\n");
        exit(1);
    }

    char buffer[MAX_SIZE], modified_buffer[MAX_SIZE];
    int read_size, watermark_size = strlen(watermark);
    srand(time(NULL));

    while((read_size = fread(buffer, sizeof(char), MAX_SIZE, source_fp)) > 0) {
        int random_index = rand() % read_size;
        int modified_size = read_size + watermark_size;
        memcpy(modified_buffer, buffer, random_index);
        memcpy(modified_buffer + random_index, watermark, watermark_size);
        memcpy(modified_buffer + random_index + watermark_size, buffer + random_index, read_size - random_index);
        fwrite(modified_buffer, sizeof(char), modified_size, target_fp);
    }

    fclose(source_fp);
    fclose(target_fp);
}

void extract_watermark(char* watermarked_file) {
    FILE* fp;
    fp = fopen(watermarked_file, "rb");

    if(fp == NULL) {
        printf("Error opening file. Aborting.\n");
        exit(1);
    }

    char buffer[MAX_SIZE], watermark[MAX_SIZE];
    int read_size, watermark_index = -1;

    while((read_size = fread(buffer, sizeof(char), MAX_SIZE, fp)) > 0) {
        int i;
        for(i = 0; i < read_size; i++) {
            if(buffer[i] == 'W') {
                watermark_index = i;
                break;
            }
        }
        if(watermark_index != -1) {
            break;
        }
    }

    if(watermark_index == -1) {
        printf("Watermark not found in the file.\n");
        exit(1);
    }

    int watermark_size = strlen(buffer + watermark_index);
    memcpy(watermark, buffer + watermark_index, watermark_size);
    printf("Extracted watermark: %s\n", watermark);

    fclose(fp);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall embed_watermark(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall extract_watermark(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Fh] [rbp-51h] BYREF
  char v5[1008]; // [rsp+30h] [rbp-50h] BYREF
  char v6[1008]; // [rsp+420h] [rbp+3A0h] BYREF
  char v7[1008]; // [rsp+810h] [rbp+790h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Retro Style C Digital Watermarking Example Program!\n\n");
  printf("Enter the name of the source file: ");
  scanf("%s", v7);
  printf("Enter the name of the target file: ");
  scanf("%s", v6);
  printf("Enter the watermark: ");
  scanf("%s", v5);
  embed_watermark(v7, v6, v5);
  printf("\nWatermark has been embedded in the file successfully!\n\n");
  printf("Do you want to extract the watermark? (y/n): ");
  scanf(" %c", &v4);
  if ( v4 == 121 || v4 == 89 )
    extract_watermark(v6);
  return 0;
}
// 140001725: using guessed type __int64 __fastcall embed_watermark(_QWORD, _QWORD, _QWORD);
// 140001918: using guessed type __int64 __fastcall extract_watermark(_QWORD);
// 140001B50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: URL Sanitizer ; Style: complex
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Function to check if the character is a special character
int isSpecialCharacter(char c)
{
    if(c=='-' || c=='_' || c=='.' || c=='~')
        return 1; // Return true if special character found
    else
        return 0; // Return false if not a special character
}

// Function to convert a character to hexadecimal
int charToHex(char c)
{
    return c>='0' && c<='9' ? (int)(c-'0') : (int)(c-'a'+10);
}

// Function to convert hexadecimal to decimal
int hexToDec(char c1, char c2)
{
    return charToHex(c1)*16 + charToHex(c2);
}

// Function to sanitize URL
char* sanitizeURL(char* url)
{
    int len = strlen(url);
    char* sanitized = (char*)malloc(sizeof(char)*(len+1));
    int count = 0;

    for(int i=0; i<len; i++)
    {
        if(isSpecialCharacter(url[i]))
        {
            sanitized[count++] = url[i]; // Set the special character as it is
        }
        else if(url[i] == '%')
        {
            // If the current character is %, then it must be followed by two hexadecimal numbers
            int dec = hexToDec(url[i+1], url[i+2]);
            sanitized[count++] = dec; // Convert hexadecimal to decimal and add to result
            i += 2; // Increment the index to skip the next two characters
        }
        else
        {
            sanitized[count++] = url[i]; // Add the character to result
        }
    }

    sanitized[count] = '\0'; // Add null character at the end

    return sanitized; // Return the sanitized URL
}

int main()
{
    char url[100];

    printf("Enter the URL to sanitize: ");
    fgets(url, 100, stdin);

    int len = strlen(url);
    if(url[len-1] == '\n')
        url[len-1] = '\0'; // Remove newline character

    char* sanitizedURL = sanitizeURL(url);

    printf("Sanitized URL: %s\n", sanitizedURL);

    free(sanitizedURL);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall sanitizeURL(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001760) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[112]; // [rsp+20h] [rbp-80h] BYREF
  void *Block; // [rsp+90h] [rbp-10h]
  int v7; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the URL to sanitize: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  v7 = strlen(Buffer);
  if ( Buffer[v7 - 1] == 10 )
    Buffer[v7 - 1] = 0;
  Block = (void *)sanitizeURL(Buffer);
  printf("Sanitized URL: %s\n", (const char *)Block);
  free(Block);
  return 0;
}
// 140001620: using guessed type __int64 __fastcall sanitizeURL(_QWORD);
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001760: using guessed type char Buffer[112];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Error handling ; Style: surprised
#include <stdio.h>

void errorMsg(int errNum){
  switch(errNum){
    case 1:
      printf("Oh my goodness! An error has occurred.\n");
      break;
    case 2:
      printf("Holy cow! This shouldn't happen.\n");
      break;
    default:
      printf("Oops! Something went wrong.\n");
  }
}

int main(){
  int num = 10;
  int arr[5] = {1,2,3,4,5};
  
  if(num > 5){
    printf("Wow! Everything is running smoothly.\n");
  } else {
    printf("Uh oh! Something's not right.\n");
    errorMsg(1);
    return 1;
  }
  
  printf("Accessing invalid array element...\n");
  
  if(arr[10] != NULL){
    printf("This line should never execute.\n");
  } else {
    errorMsg(2);
    return 1;
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall errorMsg(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *retaddr; // [rsp+48h] [rbp+8h]

  _main(argc, argv, envp);
  printf("Wow! Everything is running smoothly.\n");
  printf("Accessing invalid array element...\n");
  if ( (_DWORD)retaddr )
  {
    printf("This line should never execute.\n");
    return 0;
  }
  else
  {
    errorMsg(2i64);
    return 1;
  }
}
// 140001591: using guessed type __int64 __fastcall errorMsg(_QWORD);
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: unmistakable
#include <stdio.h>

#define ROW 6
#define COL 6

char maze[ROW][COL] = {
    {'#', '#', '#', '#', '#', '#'},
    {'#', ' ', ' ', ' ', ' ', '#'},
    {'#', '#', ' ', '#', '#', '#'},
    {'#', ' ', ' ', ' ', ' ', '#'},
    {'#', '#', '#', ' ', '#', '#'},
    {'#', '#', '#', '#', '#', '#'}
};  

struct Point {
    int x;
    int y;
};

void printMaze() {
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < COL; j++) {
            printf("%c", maze[i][j]);
        }
        printf("\n");
    }
}

int isSafe(int x, int y) {
    if (x >= 0 && x < ROW && y >= 0 && y < COL && maze[x][y] != '#') {
        return 1;
    }
    return 0;
}

int findRoute(int x, int y, struct Point* path) {
    if (x < 0 || x >= ROW || y < 0 || y >= COL) {
        return 0;
    }

    if (maze[x][y] == 'E') {
        path->x = x;
        path->y = y;
        return 1;
    }

    if (isSafe(x, y) == 0) {
        return 0;
    }

    maze[x][y] = '#';

    if (findRoute(x-1, y, path) == 1) {
        path++;
        path->x = x;
        path->y = y;
        return 1;
    }

    if (findRoute(x+1, y, path) == 1) {
        path++;
        path->x = x;
        path->y = y;
        return 1;
    }

    if (findRoute(x, y-1, path) == 1) {
        path++;
        path->x = x;
        path->y = y;
        return 1;
    }

    if (findRoute(x, y+1, path) == 1) {
        path++;
        path->x = x;
        path->y = y;
        return 1;
    }

    return 0;
}

int main() {
    struct Point path[ROW*COL];
    int start_x = 1;
    int start_y = 1;

    maze[start_x][start_y] = '#';

    int found = findRoute(start_x, start_y, path);

    if (found == 1) {
        printMaze();
        printf("\nRoute: ");
        for (int i = ROW*COL-1; i >= 0; i--) {
            printf("(%d,%d) ", path[i].x, path[i].y);
        }
        printf("\n");
    } else {
        printf("No route found.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 printMaze(void); // weak
__int64 __fastcall findRoute(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char maze[37] = "#######    ### ####    #### ########"; // weak


//----- (000000014000182C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[72]; // [rsp+20h] [rbp-60h] BYREF
  int Route; // [rsp+140h] [rbp+C0h]
  unsigned int v6; // [rsp+144h] [rbp+C4h]
  unsigned int v7; // [rsp+148h] [rbp+C8h]
  int i; // [rsp+14Ch] [rbp+CCh]

  _main(argc, argv, envp);
  v7 = 1;
  v6 = 1;
  maze[7] = 35;
  Route = findRoute(v7, v6, v4);
  if ( Route == 1 )
  {
    printMaze();
    printf("\nRoute: ");
    for ( i = 35; i >= 0; --i )
      printf("(%d,%d) ", (unsigned int)v4[2 * i], (unsigned int)v4[2 * i + 1]);
    printf("\n");
  }
  else
  {
    printf("No route found.\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 printMaze(void);
// 140001670: using guessed type __int64 __fastcall findRoute(_QWORD, _QWORD, _QWORD);
// 1400019F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System event logger ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void log_event(char *event_type, char *message) {
    FILE *log_file;
    time_t current_time;

    // Open the log file in append mode
    log_file = fopen("event.log", "a");

    // Get the current time and format it
    time(&current_time);
    char timestamp[20];
    strftime(timestamp, 20, "%Y-%m-%d %H:%M:%S", localtime(&current_time));

    // Write the event details to the log file
    fprintf(log_file, "[%s] %s: %s\n", timestamp, event_type, message);

    // Close the log file
    fclose(log_file);
}

int main() {
    // Generate some sample events for testing
    log_event("INFO", "Program started");
    log_event("WARNING", "Resource usage approaching limit");
    log_event("ERROR", "Unable to open file");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall log_event(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000165E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  log_event("INFO", "Program started");
  log_event("WARNING", "Resource usage approaching limit");
  log_event("ERROR", "Unable to open file");
  return 0;
}
// 1400015C1: using guessed type __int64 __fastcall log_event(_QWORD, _QWORD);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Robot movement control ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    srand(time(NULL)); // Initializes random number generator to generate random movement commands.
    int x = 0, y = 0; // Robot coordinates.
    int steps = 0; // Number of steps taken by robot.

    printf("Starting at position (%d, %d).\n", x, y);

    while (steps < 10) // Robot can only take 10 steps.
    {
        int direction = rand() % 4; // Generates random number between 0 and 3 to determine direction.
        
        switch (direction)
        {
            case 0: // Move up.
                y++;
                printf("Moved up to position (%d, %d).\n", x, y);
                break;
            case 1: // Move right.
                x++;
                printf("Moved right to position (%d, %d).\n", x, y);
                break;
            case 2: // Move down.
                y--;
                printf("Moved down to position (%d, %d).\n", x, y);
                break;
            case 3: // Move left.
                x--;
                printf("Moved left to position (%d, %d).\n", x, y);
                break;
        }

        steps++;
    }

    printf("Robot has taken %d steps and ended at position (%d, %d).\n", steps, x, y);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+20h] [rbp-10h]
  int v6; // [rsp+24h] [rbp-Ch]
  unsigned int v7; // [rsp+28h] [rbp-8h]
  unsigned int v8; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v8 = 0;
  v7 = 0;
  v6 = 0;
  printf("Starting at position (%d, %d).\n", 0i64, 0i64);
  while ( v6 <= 9 )
  {
    v5 = rand() % 4;
    if ( v5 == 3 )
    {
      printf("Moved left to position (%d, %d).\n", --v8, v7);
    }
    else if ( v5 <= 3 )
    {
      if ( v5 == 2 )
      {
        printf("Moved down to position (%d, %d).\n", v8, --v7);
      }
      else if ( v5 <= 2 )
      {
        if ( v5 )
        {
          if ( v5 == 1 )
            printf("Moved right to position (%d, %d).\n", ++v8, v7);
        }
        else
        {
          printf("Moved up to position (%d, %d).\n", v8, ++v7);
        }
      }
    }
    ++v6;
  }
  printf("Robot has taken %d steps and ended at position (%d, %d).\n", (unsigned int)v6, v8, v7);
  return 0;
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Ebook reader ; Style: dynamic
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

// Define the maximum number of books
#define MAX_BOOKS 3

// Define the maximum name length for a book
#define MAX_NAME_LEN 50

// Define the maximum number of pages for a book
#define MAX_PAGES 500

// Define the book structure
struct Book {
    char name[MAX_NAME_LEN];
    int pages;
    char* content;
};

// Define the EbookReader structure
struct EbookReader {
    struct Book books[MAX_BOOKS];
    int current_book_index;
};

// Function to initialize the EbookReader
void init_ebook_reader(struct EbookReader* reader) {
    // Set the current book index to -1
    reader->current_book_index = -1;
    // Set the book names and number of pages
    strcpy(reader->books[0].name, "The Alchemist");
    reader->books[0].pages = 172;
    strcpy(reader->books[1].name, "The God of Small Things");
    reader->books[1].pages = 355;
    strcpy(reader->books[2].name, "The Catcher in the Rye");
    reader->books[2].pages = 277;
    // Allocate memory for content of each book
    reader->books[0].content = (char*)malloc(reader->books[0].pages * sizeof(char));
    reader->books[1].content = (char*)malloc(reader->books[1].pages * sizeof(char));
    reader->books[2].content = (char*)malloc(reader->books[2].pages * sizeof(char));
    // Add some random text to each book
    strcpy(reader->books[0].content, "Paulo Coelho's masterpiece tells the mystical story of Santiago, an Andalusian shepherd boy who yearns to travel in search of a worldly treasure as extravagant as any ever found.");
    strcpy(reader->books[1].content, "Arundhati Roy’s novel is a modern classic that has been read and loved worldwide. It is one of the most famous Indian novels in English. ");
    strcpy(reader->books[2].content, "The famous tale by J.D. Salinger of teenage angst and rebellion was first published in 1951 and remains a true classic today. ");
}

// Function to display the EbookReader menu
void display_menu() {
    printf("Welcome to EbookReader!\n");
    printf("Please choose an option:\n");
    printf("1. View available books\n");
    printf("2. Select a book\n");
    printf("3. Read current book\n");
    printf("4. Exit EbookReader\n");
}

// Function to display the available books
void display_books(struct EbookReader* reader) {
    printf("The available books are:\n");
    for (int i=0; i<MAX_BOOKS; i++) {
        printf("%d. %s (%d pages)\n", i+1, reader->books[i].name, reader->books[i].pages);
    }
}

// Function to select a book
void select_book(struct EbookReader* reader, int book_index) {
    // Set the current book index
    reader->current_book_index = book_index;
    printf("%s has been selected.\n", reader->books[book_index].name);
}

// Function to read the current book
void read_book(struct EbookReader* reader) {
    if (reader->current_book_index == -1) {
        printf("No book is currently selected.\n");
        return;
    }
    printf("The content of the book is:\n");
    printf("%s\n", reader->books[reader->current_book_index].content);
}

int main() {
    struct EbookReader reader;
    init_ebook_reader(&reader);
    int choice;
    do {
        display_menu();
        scanf("%d", &choice);
        switch(choice) {
            case 1:
                display_books(&reader);
                break;
            case 2:
                printf("Enter the index of the book you wish to select (1-%d):\n", MAX_BOOKS);
                int book_index;
                scanf("%d", &book_index);
                if (book_index < 1 || book_index > MAX_BOOKS) {
                    printf("Invalid book index.\n");
                } else {
                    select_book(&reader, book_index-1);
                }
                break;
            case 3:
                read_book(&reader);
                break;
            case 4:
                // Quit EbookReader
                break;
            default:
                printf("Invalid choice. Please enter a number between 1 and 4.\n");
                break;
        }
    } while(choice != 4);
    // Free memory for book content
    free(reader.books[0].content);
    free(reader.books[1].content);
    free(reader.books[2].content);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall init_ebook_reader(_QWORD); // weak
__int64 display_menu(void); // weak
__int64 __fastcall display_books(_QWORD); // weak
__int64 __fastcall select_book(_QWORD, _QWORD); // weak
__int64 __fastcall read_book(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (0000000140001BEF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[56]; // [rsp+30h] [rbp-50h] BYREF
  void *Block; // [rsp+68h] [rbp-18h]
  void *v8; // [rsp+A8h] [rbp+28h]
  void *v9; // [rsp+E8h] [rbp+68h]

  _main(argc, argv, envp);
  init_ebook_reader(v6);
  do
  {
    display_menu();
    scanf("%d", &v5);
    if ( v5 == 4 )
      continue;
    if ( v5 > 4 )
      goto LABEL_14;
    switch ( v5 )
    {
      case 3:
        read_book(v6);
        break;
      case 1:
        display_books(v6);
        break;
      case 2:
        printf("Enter the index of the book you wish to select (1-%d):\n", 3i64);
        scanf("%d", &v4);
        if ( v4 > 0 && v4 <= 3 )
          select_book(v6, (unsigned int)(v4 - 1));
        else
          printf("Invalid book index.\n");
        break;
      default:
LABEL_14:
        printf("Invalid choice. Please enter a number between 1 and 4.\n");
        break;
    }
  }
  while ( v5 != 4 );
  free(Block);
  free(v8);
  free(v9);
  return 0;
}
// 140001C4C: conditional instruction was optimized away because %var_D4.4<3
// 1400015E2: using guessed type __int64 __fastcall init_ebook_reader(_QWORD);
// 140001A50: using guessed type __int64 display_menu(void);
// 140001AB9: using guessed type __int64 __fastcall display_books(_QWORD);
// 140001B35: using guessed type __int64 __fastcall select_book(_QWORD, _QWORD);
// 140001B7D: using guessed type __int64 __fastcall read_book(_QWORD);
// 140001DE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Performance-Critical Component ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(0));

    int arr[1000000]; //a big array to make things interesting

    //populate array with random numbers
    for(int i=0; i<1000000; i++) {
        arr[i] = rand();
    }

    //perform bubble sort algorithm
    for(int i=0; i<1000000-1; i++) {
        for(int j=0; j<1000000-i-1; j++) {
            if(arr[j] > arr[j+1]) {
                //swap elements
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }

    printf("Array sorted successfully! Here are the first 10 elements:\n");

    //print first 10 elements
    for(int i=0; i<10; i++) {
        printf("%d\n", arr[i]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (00000001400015B0) ----------------------------------------------------
#error "1400015B0: stack frame is too big (funcsize=0)"

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Modern Encryption ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Length of the encryption key
#define KEY_LENGTH 8

char* generateKey(void);
char* encrypt(char* plaintext, char* key);
char* decrypt(char* ciphertext, char* key);

int main() {

  char* key = generateKey();

  char plaintext[1000];
  printf("Enter the text to encrypt: ");
  fgets(plaintext, 1000, stdin);

  char* ciphertext = encrypt(plaintext, key);

  printf("Encrypted text: %s\n", ciphertext);

  char* decryptedText = decrypt(ciphertext, key);

  printf("Decrypted text: %s\n", decryptedText);

  free(key);
  free(ciphertext);
  free(decryptedText);

  return 0;
}

// Generate a random encryption key
char* generateKey() {

  char* key = malloc(sizeof(char) * KEY_LENGTH + 1);

  for (int i = 0; i < KEY_LENGTH; i++) {
    key[i] = rand() % 26 + 'a';
  }

  key[KEY_LENGTH] = '\0';

  return key;
}

// Encrypt a plaintext using the given key
char* encrypt(char* plaintext, char* key) {

  int plaintextLength = strlen(plaintext);
  int keyLength = strlen(key);

  char* ciphertext = malloc(sizeof(char) * plaintextLength + 1);

  for (int i = 0; i < plaintextLength; i++) {
    ciphertext[i] = plaintext[i] ^ key[i % keyLength];
  }

  ciphertext[plaintextLength] = '\0';

  return ciphertext;
}

// Decrypt a ciphertext using the given key
char* decrypt(char* ciphertext, char* key) {

  int ciphertextLength = strlen(ciphertext);
  int keyLength = strlen(key);

  char* plaintext = malloc(sizeof(char) * ciphertextLength + 1);

  for (int i = 0; i < ciphertextLength; i++) {
    plaintext[i] = ciphertext[i] ^ key[i % keyLength];
  }

  plaintext[ciphertextLength] = '\0';

  return plaintext;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 generateKey(void); // weak
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
__int64 __fastcall decrypt(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1000]; // [rsp+20h] [rbp-60h] BYREF
  void *v6; // [rsp+408h] [rbp+388h]
  void *v7; // [rsp+410h] [rbp+390h]
  void *Block; // [rsp+418h] [rbp+398h]

  _main(argc, argv, envp);
  Block = (void *)generateKey();
  printf("Enter the text to encrypt: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v7 = (void *)encrypt(Buffer, Block);
  printf("Encrypted text: %s\n", (const char *)v7);
  v6 = (void *)decrypt(v7, Block);
  printf("Decrypted text: %s\n", (const char *)v6);
  free(Block);
  free(v7);
  free(v6);
  return 0;
}
// 14000168A: using guessed type __int64 generateKey(void);
// 140001702: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 1400017A8: using guessed type __int64 __fastcall decrypt(_QWORD, _QWORD);
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bingo Simulator ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL)); // initialize random seed

    // prompt user to enter grid size
    int size;
    printf("Enter the size of the grid (max 10): ");
    scanf("%d", &size);
    
    // create grid
    int grid[size][size];
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            grid[i][j] = rand() % 75 + 1; // fill grid with random numbers 1-75
        }
    }

    // print grid
    printf("\n\n");
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            printf("%-3d ", grid[i][j]);
        }
        printf("\n");
    }

    // play bingo
    int count = 0;
    while (count < size*size) {
        // prompt user to enter number
        int num;
        printf("\n\nEnter a number between 1 and 75: ");
        scanf("%d", &num);
        if (num < 1 || num > 75) {
            printf("Invalid input. Try again.\n");
            continue;
        }

        // check if number is in grid
        int found = 0;
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                if (grid[i][j] == num) {
                    grid[i][j] = 0; // mark number as found
                    found = 1;
                    break;
                }
            }
            if (found) break;
        }

        if (found) {
            count++;
            printf("Number found! %d remaining.\n", size*size-count);
        } else {
            printf("Number not found. Try again.\n");
        }

        // check for bingo
        int bingo = 0;
        for (int i = 0; i < size; i++) {
            int row_sum = 0;
            int col_sum = 0;
            for (int j = 0; j < size; j++) {
                row_sum += grid[i][j];
                col_sum += grid[j][i];
            }
            if (row_sum == 0 || col_sum == 0) {
                bingo = 1;
                break;
            }
        }
        if (bingo) {
            printf("\n\nBINGO! You win!");
            break;
        }
    }

    if (count == size*size) {
        printf("\n\nOut of moves. Game over.");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned __int64 v4; // rbx
  void *v5; // rsp
  __int64 v7; // [rsp+0h] [rbp-B0h] BYREF
  char v8; // [rsp+20h] [rbp-90h] BYREF
  __int64 *v9; // [rsp+28h] [rbp-88h]
  __int64 v10; // [rsp+30h] [rbp-80h]
  __int64 v11; // [rsp+38h] [rbp-78h]
  __int64 v12; // [rsp+40h] [rbp-70h]
  __int64 v13; // [rsp+48h] [rbp-68h]
  int v14; // [rsp+58h] [rbp-58h] BYREF
  int v15; // [rsp+5Ch] [rbp-54h] BYREF
  char *v16; // [rsp+60h] [rbp-50h]
  __int64 v17; // [rsp+68h] [rbp-48h]
  __int64 v18; // [rsp+70h] [rbp-40h]
  int kk; // [rsp+7Ch] [rbp-34h]
  int v20; // [rsp+80h] [rbp-30h]
  int v21; // [rsp+84h] [rbp-2Ch]
  int jj; // [rsp+88h] [rbp-28h]
  int v23; // [rsp+8Ch] [rbp-24h]
  int ii; // [rsp+90h] [rbp-20h]
  int n; // [rsp+94h] [rbp-1Ch]
  int v26; // [rsp+98h] [rbp-18h]
  int v27; // [rsp+9Ch] [rbp-14h]
  int m; // [rsp+A0h] [rbp-10h]
  int k; // [rsp+A4h] [rbp-Ch]
  int j; // [rsp+A8h] [rbp-8h]
  int i; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v9 = &v7;
  v3 = time(0i64);
  srand(v3);
  printf("Enter the size of the grid (max 10): ");
  scanf("%d", &v15);
  v18 = v15 - 1i64;
  v10 = v15;
  v11 = 0i64;
  v4 = 4i64 * v15;
  v17 = v18;
  v12 = v15;
  v13 = 0i64;
  v5 = alloca(16 * ((unsigned __int64)(4 * v15 * (__int64)v15 + 15) >> 4));
  v16 = &v8;
  for ( i = 0; i < v15; ++i )
  {
    for ( j = 0; j < v15; ++j )
      *(_DWORD *)&v16[4 * j + 4 * (v4 >> 2) * i] = rand() % 75 + 1;
  }
  printf("\n\n");
  for ( k = 0; k < v15; ++k )
  {
    for ( m = 0; m < v15; ++m )
      printf("%-3d ", *(unsigned int *)&v16[4 * m + 4 * (v4 >> 2) * k]);
    printf("\n");
  }
  v27 = 0;
  while ( v27 < v15 * v15 )
  {
    printf("\n\nEnter a number between 1 and 75: ");
    scanf("%d", &v14);
    if ( v14 > 0 && v14 <= 75 )
    {
      v26 = 0;
      for ( n = 0; n < v15; ++n )
      {
        for ( ii = 0; ii < v15; ++ii )
        {
          if ( *(_DWORD *)&v16[4 * ii + 4 * (v4 >> 2) * n] == v14 )
          {
            *(_DWORD *)&v16[4 * ii + 4 * (v4 >> 2) * n] = 0;
            v26 = 1;
            break;
          }
        }
        if ( v26 )
          break;
      }
      if ( v26 )
      {
        ++v27;
        printf("Number found! %d remaining.\n", (unsigned int)(v15 * v15 - v27));
      }
      else
      {
        printf("Number not found. Try again.\n");
      }
      v23 = 0;
      for ( jj = 0; jj < v15; ++jj )
      {
        v21 = 0;
        v20 = 0;
        for ( kk = 0; kk < v15; ++kk )
        {
          v21 += *(_DWORD *)&v16[4 * kk + 4 * (v4 >> 2) * jj];
          v20 += *(_DWORD *)&v16[4 * jj + 4 * (v4 >> 2) * kk];
        }
        if ( !v21 || !v20 )
        {
          v23 = 1;
          break;
        }
      }
      if ( v23 )
      {
        printf("\n\nBINGO! You win!");
        break;
      }
    }
    else
    {
      printf("Invalid input. Try again.\n");
    }
  }
  if ( v27 == v15 * v15 )
    printf("\n\nOut of moves. Game over.");
  return 0;
}
// 140001B10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Recursive ; Style: active
#include <stdio.h>

int sum(int n) {
    if (n == 0) {
        return 0;
    } else {
        return n + sum(n-1);
    }
}

void print_triangle(int rows) {
    if (rows == 0) {
        return;
    } else {
        print_triangle(rows-1);
        for (int i = 0; i < rows; i++) {
            printf("* ");
        }
        printf("\n");
    }
}

int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n-1);
    }
}

void print_reverse(char str[], int len) {
    if (len == 0) {
        return;
    } else {
        printf("%c", str[len-1]);
        print_reverse(str, len-1);
    }
}

int main() {
    // example of sum function
    int s = sum(10);
    printf("Sum of 1 to 10 is %d\n", s);
    
    // example of print_triangle function
    printf("Printing triangle:\n");
    print_triangle(5);
    
    // example of factorial function
    int f = factorial(5);
    printf("Factorial of 5 is %d\n", f);
    
    // example of print_reverse function
    char str[] = "hello world";
    printf("Reversed string:\n");
    print_reverse(str, 11);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall sum(_QWORD); // weak
__int64 __fastcall print_triangle(_QWORD); // weak
__int64 __fastcall factorial(_QWORD); // weak
__int64 __fastcall print_reverse(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016A0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _DWORD v4[4]; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v5; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5 = sum(10i64);
  printf("Sum of 1 to 10 is %d\n", v5);
  printf("Printing triangle:\n");
  print_triangle(5i64);
  v4[3] = factorial(5i64);
  printf("Factorial of 5 is %d\n", v4[3]);
  strcpy((char *)v4, "hello world");
  printf("Reversed string:\n");
  print_reverse(v4, 11i64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall sum(_QWORD);
// 1400015C1: using guessed type __int64 __fastcall print_triangle(_QWORD);
// 14000161B: using guessed type __int64 __fastcall factorial(_QWORD);
// 14000164A: using guessed type __int64 __fastcall print_reverse(_QWORD, _QWORD);
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital signal processing ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define PI 3.14159265358979323846

void DFT(double *input, double *real_output, double *imag_output, int n);
void FFT(double *input, double *real_output, double *imag_output, int n);
void complex_mult(double x_real, double x_imag, double y_real, double y_imag, double *z_real, double *z_imag);

int main()
{
    int n, i;
    double *input, *real_output, *imag_output;

    printf("Enter the number of samples: ");
    scanf("%d", &n);

    input = (double *)malloc(n * sizeof(double));
    real_output = (double *)malloc(n * sizeof(double));
    imag_output = (double *)malloc(n * sizeof(double));

    printf("Enter the samples: ");
    for (i = 0; i < n; i++)
    {
        scanf("%lf", &input[i]);
    }

    DFT(input, real_output, imag_output, n);

    printf("\nDFT Output:\n");

    for (i = 0; i < n; i++)
    {
        printf("X[%d] = %lf + %lfj\n", i, real_output[i], imag_output[i]);
    }

    FFT(input, real_output, imag_output, n);

    printf("\nFFT Output:\n");

    for (i = 0; i < n; i++)
    {
        printf("X[%d] = %lf + %lfj\n", i, real_output[i], imag_output[i]);
    }

    free(input);
    free(real_output);
    free(imag_output);

    return 0;
}

void DFT(double *input, double *real_output, double *imag_output, int n)
{
    int k, n1;
    double c, s, arg;

    for (k = 0; k < n; k++)
    {
        real_output[k] = 0;
        imag_output[k] = 0;

        for (n1 = 0; n1 < n; n1++)
        {
            arg = 2 * PI * k * n1 / (double)n;
            c = cos(arg);
            s = sin(arg);
            real_output[k] += input[n1] * c;
            imag_output[k] -= input[n1] * s;
        }
    }
}

void FFT(double *input, double *real_output, double *imag_output, int n)
{
    int i, j, k, n1, l, m;
    double c, s, arg, temp_real, temp_imag;
    double *x_real, *x_imag, *tmp_real, *tmp_imag;

    x_real = (double *)malloc(n * sizeof(double));
    x_imag = (double *)malloc(n * sizeof(double));
    tmp_real = (double *)malloc(n * sizeof(double));
    tmp_imag = (double *)malloc(n * sizeof(double));

    for (i = 0; i < n; i++)
    {
        x_real[i] = input[i];
        x_imag[i] = 0;
    }

    j = 0;
    for (i = 1; i < n - 1; i++)
    {
        k = n >> 1;
        while (k <= j)
        {
            j -= k;
            k >>= 1;
        }
        j += k;
        if (i < j)
        {
            temp_real = x_real[i];
            temp_imag = x_imag[i];
            x_real[i] = x_real[j];
            x_imag[i] = x_imag[j];
            x_real[j] = temp_real;
            x_imag[j] = temp_imag;
        }
    }

    for (i = 0; i < log2(n); i++)
    {
        l = 1 << i;
        for (j = 0; j < n; j += 2 * l)
        {
            for (k = 0; k < l; k++)
            {
                arg = 2 * PI * k / (double)(2 * l);
                c = cos(arg);
                s = sin(arg);
                complex_mult(x_real[j + k + l], x_imag[j + k + l], c, s, &temp_real, &temp_imag);
                tmp_real[j + k] = x_real[j + k] + temp_real;
                tmp_imag[j + k] = x_imag[j + k] + temp_imag;
                tmp_real[j + k + l] = x_real[j + k] - temp_real;
                tmp_imag[j + k + l] = x_imag[j + k] - temp_imag;
            }
        }

        for (m = 0; m < n; m++)
        {
            x_real[m] = tmp_real[m];
            x_imag[m] = tmp_imag[m];
        }
    }

    for (i = 0; i < n; i++)
    {
        real_output[i] = x_real[i];
        imag_output[i] = x_imag[i];
    }

    free(x_real);
    free(x_imag);
    free(tmp_real);
    free(tmp_imag);
}

void complex_mult(double x_real, double x_imag, double y_real, double y_imag, double *z_real, double *z_imag)
{
    *z_real = x_real * y_real - x_imag * y_imag;
    *z_imag = x_real * y_imag + x_imag * y_real;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall DFT(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall FFT(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-24h] BYREF
  void *v5; // [rsp+30h] [rbp-20h]
  void *v6; // [rsp+38h] [rbp-18h]
  void *Block; // [rsp+40h] [rbp-10h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of samples: ");
  scanf("%d", &v4);
  Block = malloc(8i64 * v4);
  v6 = malloc(8i64 * v4);
  v5 = malloc(8i64 * v4);
  printf("Enter the samples: ");
  for ( i = 0; i < v4; ++i )
    scanf("%lf", (char *)Block + 8 * i);
  DFT(Block, v6, v5, (unsigned int)v4);
  printf("\nDFT Output:\n");
  for ( i = 0; i < v4; ++i )
    printf("X[%d] = %lf + %lfj\n", (unsigned int)i, *((_QWORD *)v6 + i), *((_QWORD *)v5 + i));
  FFT(Block, v6, v5, (unsigned int)v4);
  printf("\nFFT Output:\n");
  for ( i = 0; i < v4; ++i )
    printf("X[%d] = %lf + %lfj\n", (unsigned int)i, *((_QWORD *)v6 + i), *((_QWORD *)v5 + i));
  free(Block);
  free(v6);
  free(v5);
  return 0;
}
// 140001834: using guessed type __int64 __fastcall DFT(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400019C8: using guessed type __int64 __fastcall FFT(_QWORD, _QWORD, _QWORD, _QWORD);
// 140002080: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature monitor ; Style: real-life
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float temp;
    int choice;

    do {
        printf("Enter temperature in Celsius: ");
        scanf("%f", &temp);

        printf("1. Convert to Fahrenheit\n");
        printf("2. Convert to Kelvin\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Temperature in Fahrenheit is: %.2f\n", (temp * 1.8) + 32);
                break;
            case 2:
                printf("Temperature in Kelvin is: %.2f\n", temp + 273.15);
                break;
            case 3:
                printf("Exiting program...\n");
                exit(0);
            default:
                printf("Invalid choice.\n");
        }
    } while (choice != 3);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-8h] BYREF
  float v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("Enter temperature in Celsius: ");
    scanf("%f", &v5);
    printf("1. Convert to Fahrenheit\n");
    printf("2. Convert to Kelvin\n");
    printf("3. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    if ( v4 == 3 )
    {
      printf("Exiting program...\n");
      exit(0);
    }
    if ( v4 > 3 )
      goto LABEL_10;
    if ( v4 == 1 )
    {
      printf("Temperature in Fahrenheit is: %.2f\n", v5 * 1.8 + 32.0);
      continue;
    }
    if ( v4 == 2 )
      printf("Temperature in Kelvin is: %.2f\n", v5 + 273.15);
    else
LABEL_10:
      printf("Invalid choice.\n");
  }
  while ( v4 != 3 );
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database simulation ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_RECORDS 100 // Maximum number of records that can be stored in the database

typedef struct {
    int id;
    char name[50];
    int age;
    char address[100];
} Record;

typedef struct {
    Record records[MAX_RECORDS];
    int count;
} Database;

void init(Database *db) {
    db->count = 0;
}

void add_record(Database *db, Record r) {
    if (db->count < MAX_RECORDS) {
        db->records[db->count] = r;
        db->count++;
    }
}

void display_records(Database db) {
    printf("ID\tName\tAge\tAddress\n");
    printf("----------------------------------------------\n");
    for (int i = 0; i < db.count; i++) {
        printf("%d\t%s\t%d\t%s\n", db.records[i].id, db.records[i].name,
               db.records[i].age, db.records[i].address);
    }
}

int main() {
    Database db;
    Record r;

    init(&db);

    // Add some records to the database
    r.id = 1;
    strcpy(r.name, "John Doe");
    r.age = 30;
    strcpy(r.address, "123 Main St, Anytown USA");
    add_record(&db, r);

    r.id = 2;
    strcpy(r.name, "Jane Smith");
    r.age = 25;
    strcpy(r.address, "456 Oak Dr, Somewhere Else USA");
    add_record(&db, r);

    // Display the records in the database
    display_records(db);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall init(_QWORD); // weak
__int64 __fastcall add_record(_QWORD, _QWORD); // weak
__int64 __fastcall display_records(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memcpy(void *, const void *Src, size_t Size);


//----- (000000014000179E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[16016]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5; // [rsp+3EB0h] [rbp+3E30h] BYREF
  __int64 v6; // [rsp+3EB8h] [rbp+3E38h]
  __int64 v7; // [rsp+3EC0h] [rbp+3E40h]
  __int64 v8; // [rsp+3EC8h] [rbp+3E48h]
  __int64 v9; // [rsp+3ED0h] [rbp+3E50h]
  __int64 v10; // [rsp+3ED8h] [rbp+3E58h]
  __int64 v11; // [rsp+3EE0h] [rbp+3E60h]
  __int64 v12; // [rsp+3EE8h] [rbp+3E68h]
  __int64 v13; // [rsp+3EF0h] [rbp+3E70h]
  __int64 v14; // [rsp+3EF8h] [rbp+3E78h]
  __int64 v15; // [rsp+3F00h] [rbp+3E80h]
  __int64 v16; // [rsp+3F08h] [rbp+3E88h]
  __int64 v17; // [rsp+3F10h] [rbp+3E90h]
  __int64 v18; // [rsp+3F18h] [rbp+3E98h]
  __int64 v19; // [rsp+3F20h] [rbp+3EA0h]
  __int64 v20; // [rsp+3F28h] [rbp+3EA8h]
  __int64 v21; // [rsp+3F30h] [rbp+3EB0h]
  __int64 v22; // [rsp+3F38h] [rbp+3EB8h]
  __int64 v23; // [rsp+3F40h] [rbp+3EC0h]
  __int64 v24; // [rsp+3F48h] [rbp+3EC8h]
  _QWORD v25[2]; // [rsp+3F50h] [rbp+3ED0h] BYREF
  __int64 v26; // [rsp+3F60h] [rbp+3EE0h]
  __int64 v27; // [rsp+3F68h] [rbp+3EE8h]
  __int64 v28; // [rsp+3F70h] [rbp+3EF0h]
  __int64 v29; // [rsp+3F78h] [rbp+3EF8h]
  __int64 v30; // [rsp+3F80h] [rbp+3F00h]
  _QWORD v31[5]; // [rsp+3F88h] [rbp+3F08h] BYREF
  __int64 v32; // [rsp+3FB0h] [rbp+3F30h]
  __int64 v33; // [rsp+3FB8h] [rbp+3F38h]
  __int64 v34; // [rsp+3FC0h] [rbp+3F40h]
  __int64 v35; // [rsp+3FC8h] [rbp+3F48h]
  __int64 v36; // [rsp+3FD0h] [rbp+3F50h]
  __int64 v37; // [rsp+3FD8h] [rbp+3F58h]
  __int64 v38; // [rsp+3FE0h] [rbp+3F60h]
  __int64 v39; // [rsp+3FE8h] [rbp+3F68h]
  char Src[16016]; // [rsp+3FF0h] [rbp+3F70h] BYREF

  _main(argc, argv, envp);
  init(Src);
  LODWORD(v25[0]) = 1;
  strcpy((char *)v25 + 4, "John Doe");
  LODWORD(v31[0]) = 30;
  strcpy((char *)v31 + 4, "123 Main St, Anytown USA");
  v5 = v25[0];
  v6 = v25[1];
  v7 = v26;
  v8 = v27;
  v9 = v28;
  v10 = v29;
  v11 = v30;
  v12 = v31[0];
  v13 = v31[1];
  v14 = v31[2];
  v15 = v31[3];
  v16 = v31[4];
  v17 = v32;
  v18 = v33;
  v19 = v34;
  v20 = v35;
  v21 = v36;
  v22 = v37;
  v23 = v38;
  v24 = v39;
  add_record(Src, &v5);
  LODWORD(v25[0]) = 2;
  strcpy((char *)v25 + 4, "Jane Smith");
  LODWORD(v31[0]) = 25;
  strcpy((char *)v31 + 4, "456 Oak Dr, Somewhere Else USA");
  v5 = v25[0];
  v6 = v25[1];
  v7 = v26;
  v8 = v27;
  v9 = v28;
  v10 = v29;
  v11 = v30;
  v12 = v31[0];
  v13 = v31[1];
  v14 = v31[2];
  v15 = v31[3];
  v16 = v31[4];
  v17 = v32;
  v18 = v33;
  v19 = v34;
  v20 = v35;
  v21 = v36;
  v22 = v37;
  v23 = v38;
  v24 = v39;
  add_record(Src, &v5);
  memcpy(v4, Src, 0x3E84ui64);
  display_records(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall init(_QWORD);
// 1400015AA: using guessed type __int64 __fastcall add_record(_QWORD, _QWORD);
// 1400016BD: using guessed type __int64 __fastcall display_records(_QWORD);
// 140001BF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Computer Biology ; Style: creative
#include <stdio.h>

// Function to calculate the hamming distance between two strings
int hammingDistance(char* str1, char* str2)
{
    int distance = 0;
    for(int i=0; str1[i] && str2[i]; i++)
    {
        if (str1[i] != str2[i])
        {
            distance++;
        }
    }
    return distance;
}

// Function to convert a DNA sequence to RNA 
char* dnaToRna(char* dnaSequence)
{
    int i=0;
    while(dnaSequence[i])
    {
        if(dnaSequence[i] == 'T')
            dnaSequence[i] = 'U';
        i++;
    }
    return dnaSequence;
}

int main()
{
    // Input DNA sequence
    char dnaSequence[100];
    printf("Enter a DNA sequence: ");
    scanf("%s", dnaSequence);
    
    // Convert to RNA
    char* rnaSequence = dnaToRna(dnaSequence);
    
    // Input a reference RNA sequence
    char referenceRnaSequence[100];
    printf("Enter a reference RNA sequence: ");
    scanf("%s", referenceRnaSequence);
    
    // Calculate hamming distance between DNA sequence and reference RNA sequence
    int distance = hammingDistance(rnaSequence, referenceRnaSequence);
    
    // Output the result
    printf("The hamming distance between DNA sequence and reference RNA sequence is: %d", distance);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall hammingDistance(_QWORD, _QWORD); // weak
__int64 __fastcall dnaToRna(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016BA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[112]; // [rsp+20h] [rbp-60h] BYREF
  char v5[100]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v6; // [rsp+F4h] [rbp+74h]
  __int64 v7; // [rsp+F8h] [rbp+78h]

  _main(argc, argv, envp);
  printf("Enter a DNA sequence: ");
  scanf("%s", v5);
  v7 = dnaToRna(v5);
  printf("Enter a reference RNA sequence: ");
  scanf("%s", v4);
  v6 = hammingDistance(v7, v4);
  printf("The hamming distance between DNA sequence and reference RNA sequence is: %d", v6);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall hammingDistance(_QWORD, _QWORD);
// 14000165F: using guessed type __int64 __fastcall dnaToRna(_QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Weather simulation ; Style: Linus Torvalds
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int temp = 0;
    int humidity = 0;
    int windSpeed = 0;
    int pressure = 0;
    float windChill;

    srand((unsigned) time(NULL));

    temp = (rand() % 60) - 20;
    humidity = rand() % 101;
    windSpeed = (rand() % 20) + 1;
    pressure = (rand() % 101) + 900;
    windChill = (float) (0.0817 * (3.71 * sqrt(windSpeed) + 5.81 - 0.25 * windSpeed) * (temp - 91.4) + 91.4);

    printf("Current Temperature: %d C\n", temp);
    printf("Humidity: %d%\n", humidity);
    printf("Wind Speed: %d km/h\n", windSpeed);
    printf("Pressure: %d kPa\n", pressure);
    printf("Wind Chill: %.2f C\n", windChill);

    if(temp <= 0){
        printf("\nIt's freezing out there! Stay warm!\n");
    } else if(temp > 0 && temp <= 10){
        printf("\nIt's cold out there! Get a jacket!\n");
    } else if(temp > 10 && temp <= 20){
        printf("\nIt's cool out there! Enjoy the weather!\n");
    } else if(temp > 20 && temp <=30){
        printf("\nIt's warm out there! Enjoy the sunshine!\n");
    } else if(temp > 30){
        printf("\nIt's hot out there! Drink plenty of water!\n");
    }

    if(windSpeed > 10){
        printf("\nBeware of strong winds! Hold on tight!\n");
    }

    if(humidity >= 80){
        printf("\nIt's quite humid out there! Expect some rain!\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  float v4; // xmm0_4
  unsigned int v6; // [rsp+30h] [rbp-10h]
  int v7; // [rsp+34h] [rbp-Ch]
  int v8; // [rsp+38h] [rbp-8h]
  int v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v9 = rand() % 60 - 20;
  v8 = rand() % 101;
  v7 = rand() % 20 + 1;
  v6 = rand() % 101 + 900;
  v4 = (3.71 * sqrt((double)v7) + 5.81 - (double)v7 * 0.25) * 0.08169999999999999 * ((double)v9 - 91.40000000000001)
     + 91.40000000000001;
  printf("Current Temperature: %d C\n", (unsigned int)v9);
  printf("Humidity: %d%\n", (unsigned int)v8);
  printf("Wind Speed: %d km/h\n", (unsigned int)v7);
  printf("Pressure: %d kPa\n", v6);
  printf("Wind Chill: %.2f C\n", v4);
  if ( v9 > 0 )
  {
    if ( v9 > 10 )
    {
      if ( v9 > 20 )
      {
        if ( v9 > 30 )
          printf("\nIt's hot out there! Drink plenty of water!\n");
        else
          printf("\nIt's warm out there! Enjoy the sunshine!\n");
      }
      else
      {
        printf("\nIt's cool out there! Enjoy the weather!\n");
      }
    }
    else
    {
      printf("\nIt's cold out there! Get a jacket!\n");
    }
  }
  else
  {
    printf("\nIt's freezing out there! Stay warm!\n");
  }
  if ( v7 > 10 )
    printf("\nBeware of strong winds! Hold on tight!\n");
  if ( v8 > 79 )
    printf("\nIt's quite humid out there! Expect some rain!\n");
  return 0;
}
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Antivirus scanner ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define VIRUS_SIGNATURE "this_is_a_virus" // Define virus signature

void scan_file(char* filename);
void remove_virus(char* filename);
int is_virus(FILE* file);

int main(int argc, char** argv) {
    if(argc < 2) {
        printf("Please specify file name(s) to scan.\n");
        return 1;
    }
    for(int i = 1; i < argc; i++) {
        scan_file(argv[i]);
    }
    return 0;
}

void scan_file(char* filename) {
    // Open file
    FILE* file = fopen(filename, "rb+");
    if(file == NULL) {
        printf("Unable to open file %s.\n", filename);
        return;
    }
    // Check if file contains virus
    if(is_virus(file)) {
        printf("Virus detected in file %s.\n", filename);
        // Remove virus
        remove_virus(filename);
    }
    else {
        printf("File %s is clean.\n", filename);
    }
    fclose(file);
}

int is_virus(FILE* file) {
    char buffer[strlen(VIRUS_SIGNATURE)];
    // Read file and check for virus signature
    fread(buffer, sizeof(char), strlen(VIRUS_SIGNATURE), file);
    rewind(file); // Go back to beginning of file
    if(strcmp(buffer, VIRUS_SIGNATURE) == 0) {
        return 1; // Virus detected
    }
    else {
        return 0; // Virus not detected
    }
}

void remove_virus(char* filename) {
    // Open file
    FILE* file = fopen(filename, "rb+");
    if(file == NULL) {
        printf("Unable to open file %s.\n", filename);
        return;
    }
    // Get file size
    fseek(file, 0L, SEEK_END);
    int filesize = ftell(file);
    rewind(file); // Go back to beginning of file
    // Allocate buffer
    char* buffer = malloc(filesize * sizeof(char));
    if(buffer == NULL) {
        printf("Unable to allocate memory.\n");
        fclose(file);
        return;
    }
    // Read file
    fread(buffer, sizeof(char), filesize, file);
    // Remove virus signature
    char* virus_start = strstr(buffer, VIRUS_SIGNATURE);
    memset(virus_start, ' ', strlen(VIRUS_SIGNATURE));
    // Write file
    rewind(file); // Go back to beginning of file
    fwrite(buffer, sizeof(char), filesize, file);
    // Cleanup
    free(buffer);
    fclose(file);
    printf("File %s cleaned of virus.\n", filename);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall scan_file(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  if ( argc > 1 )
  {
    for ( i = 1; i < argc; ++i )
      scan_file(argv[i]);
    return 0;
  }
  else
  {
    printf("Please specify file name(s) to scan.\n");
    return 1;
  }
}
// 140001600: using guessed type __int64 __fastcall scan_file(_QWORD);
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=148 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Linked list operations ; Style: configurable
#include <stdio.h>
#include <stdlib.h>

// Define node structure
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Function to insert a node at the beginning of the linked list
Node* insertAtBeginning(Node* head, int data) {
    Node* temp = (Node*) malloc(sizeof(Node));
    temp->data = data;
    temp->next = head;
    head = temp;
    return head;
}

// Function to insert a node at the end of the linked list
Node* insertAtEnd(Node* head, int data) {
    Node* temp = (Node*) malloc(sizeof(Node));
    temp->data = data;
    temp->next = NULL;
    if (head == NULL) {
        head = temp;
        return head;
    }
    Node* current = head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = temp;
    return head;
}

// Function to delete the first node of the linked list
Node* deleteAtBeginning(Node* head) {
    if (head == NULL) {
        printf("Error: Linked list is empty.\n");
        return head;
    }
    Node* temp = head;
    head = head->next;
    free(temp);
    return head;
}

// Function to delete the last node of the linked list
Node* deleteAtEnd(Node* head) {
    if (head == NULL) {
        printf("Error: Linked list is empty.\n");
        return head;
    }
    if (head->next == NULL) {
        free(head);
        return NULL;
    }
    Node* current = head;
    while (current->next->next != NULL) {
        current = current->next;
    }
    free(current->next);
    current->next = NULL;
    return head;
}

// Function to print the linked list
void printList(Node* head) {
    if (head == NULL) {
        printf("Linked list is empty.\n");
        return;
    }
    Node* current = head;
    while (current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }
    printf("\n");
}

int main() {
    Node* head = NULL;
    int choice, data;
    do {
        printf("Choose an operation:\n");
        printf("1. Insert at beginning\n");
        printf("2. Insert at end\n");
        printf("3. Delete at beginning\n");
        printf("4. Delete at end\n");
        printf("5. Print linked list\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                printf("Enter data to insert at beginning: ");
                scanf("%d", &data);
                head = insertAtBeginning(head, data);
                printf("%d inserted at beginning.\n", data);
                break;
            case 2:
                printf("Enter data to insert at end: ");
                scanf("%d", &data);
                head = insertAtEnd(head, data);
                printf("%d inserted at end.\n", data);
                break;
            case 3:
                head = deleteAtBeginning(head);
                printf("First node deleted.\n");
                break;
            case 4:
                head = deleteAtEnd(head);
                printf("Last node deleted.\n");
                break;
            case 5:
                printf("Linked list: ");
                printList(head);
                break;
            case 6:
                printf("Exiting.\n");
                break;
            default:
                printf("Invalid choice! Try again.\n");
        }
        printf("\n");
    } while (choice != 6);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall insertAtBeginning(_QWORD, _QWORD); // weak
__int64 __fastcall insertAtEnd(_QWORD, _QWORD); // weak
__int64 __fastcall deleteAtBeginning(_QWORD); // weak
__int64 __fastcall deleteAtEnd(_QWORD); // weak
__int64 __fastcall printList(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017F8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-10h] BYREF
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  __int64 v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v6 = 0i64;
  do
  {
    printf("Choose an operation:\n");
    printf("1. Insert at beginning\n");
    printf("2. Insert at end\n");
    printf("3. Delete at beginning\n");
    printf("4. Delete at end\n");
    printf("5. Print linked list\n");
    printf("6. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        printf("Enter data to insert at beginning: ");
        scanf("%d", &v4);
        v6 = insertAtBeginning(v6, v4);
        printf("%d inserted at beginning.\n", v4);
        break;
      case 2:
        printf("Enter data to insert at end: ");
        scanf("%d", &v4);
        v6 = insertAtEnd(v6, v4);
        printf("%d inserted at end.\n", v4);
        break;
      case 3:
        v6 = deleteAtBeginning(v6);
        printf("First node deleted.\n");
        break;
      case 4:
        v6 = deleteAtEnd(v6);
        printf("Last node deleted.\n");
        break;
      case 5:
        printf("Linked list: ");
        printList(v6);
        break;
      case 6:
        printf("Exiting.\n");
        break;
      default:
        printf("Invalid choice! Try again.\n");
        break;
    }
    printf("\n");
  }
  while ( v5 != 6 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall insertAtBeginning(_QWORD, _QWORD);
// 140001626: using guessed type __int64 __fastcall insertAtEnd(_QWORD, _QWORD);
// 1400016A6: using guessed type __int64 __fastcall deleteAtBeginning(_QWORD);
// 1400016F8: using guessed type __int64 __fastcall deleteAtEnd(_QWORD);
// 14000178A: using guessed type __int64 __fastcall printList(_QWORD);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: protected
#include<stdio.h>

/* This program implements the Fractional Knapsack Problem using a greedy algorithm. */

#define MAX_SIZE 100

typedef struct{
    int value;
    int weight;
    float ratio;
} Item;

int compare(Item a, Item b) {
    return a.ratio < b.ratio;
}

int main() {
    int n, W;
    Item items[MAX_SIZE];
    
    printf("Enter the number of items: ");
    scanf("%d", &n);
    
    printf("Enter the capacity of the knapsack: ");
    scanf("%d", &W);
    
    printf("Enter the value and weight of each item:\n");
    for(int i = 0; i < n; i++) {
        scanf("%d%d", &items[i].value, &items[i].weight);
        items[i].ratio = (float)items[i].value / items[i].weight;
    }
    
    // sort the items in descending order of their ratio
    qsort(items, n, sizeof(Item), compare);
    
    int i = 0;
    float max_value = 0.0;
    
    while(W > 0 && i < n) {
        if(items[i].weight <= W) {
            // take the entire item as it can be accommodated in the knapsack
            max_value += items[i].value;
            W -= items[i].weight;
        } else {
            // take a fraction of the item that can fit in the knapsack
            max_value += W * items[i].ratio;
            W = 0;
        }
        i++;
    }
    
    printf("Maximum possible value that can be obtained = %0.2f\n", max_value);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __cdecl compare(const void *, const void *); // idb
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);


//----- (0000000140001606) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _DWORD Base[24]; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v5[1116]; // [rsp+80h] [rbp+0h] BYREF
  int v6; // [rsp+4DCh] [rbp+45Ch] BYREF
  int NumOfElements; // [rsp+4E0h] [rbp+460h] BYREF
  float NumOfElements_4; // [rsp+4E4h] [rbp+464h]
  int v9; // [rsp+4E8h] [rbp+468h]
  int i; // [rsp+4ECh] [rbp+46Ch]

  _main(argc, argv, envp);
  printf("Enter the number of items: ");
  scanf("%d", &NumOfElements);
  printf("Enter the capacity of the knapsack: ");
  scanf("%d", &v6);
  printf("Enter the value and weight of each item:\n");
  for ( i = 0; i < NumOfElements; ++i )
  {
    scanf("%d%d", &Base[3 * i], &Base[3 * i + 1]);
    *(float *)&v5[12 * i - 88] = (float)*(int *)&v5[12 * i - 96] / (float)*(int *)&v5[12 * i - 92];
  }
  qsort(Base, (unsigned int)NumOfElements, 0xCui64, compare);
  v9 = 0;
  NumOfElements_4 = 0.0;
  while ( v6 > 0 && v9 < NumOfElements )
  {
    if ( *(_DWORD *)&v5[12 * v9 - 92] > v6 )
    {
      NumOfElements_4 = (float)(*(float *)&v5[12 * v9 - 88] * (float)v6) + NumOfElements_4;
      v6 = 0;
    }
    else
    {
      NumOfElements_4 = (float)*(int *)&v5[12 * v9 - 96] + NumOfElements_4;
      v6 -= *(_DWORD *)&v5[12 * v9 - 92];
    }
    ++v9;
  }
  printf("Maximum possible value that can be obtained = %0.2f\n", NumOfElements_4);
  return 0;
}
// 1400019E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game ; Style: systematic
#include <stdio.h>
#include <stdlib.h>

#define ROW 3
#define COL 3

int row, col;
char game_board[ROW][COL];

void initialize_board() {
    int i,j;
    for (i=0; i<ROW; i++) {
        for (j=0; j<COL; j++) {
            game_board[i][j] = '-';
        }
    }
}

void display_board() {
    int i,j;
    for (i=0; i<ROW; i++) {
        for (j=0; j<COL; j++) {
            printf("%c ", game_board[i][j]);
        }
        printf("\n");
    }
    printf("----------------------\n");
}

void player_move(char player) {
    printf("Player %c's turn\n", player);
    printf("Enter row and column number where you want to place '%c': ", player);
    scanf("%d %d", &row, &col);
    if (game_board[row][col] != '-') {
        printf("Invalid move. Try again.\n");
        player_move(player);
    } else {
        game_board[row][col] = player;
        display_board();
    }
}

char check_win() {
    int i,j;
    // Check rows
    for (i=0; i<ROW; i++) {
        if (game_board[i][0] == game_board[i][1] && game_board[i][1] == game_board[i][2]) {
            return game_board[i][0];
        }
    }
    // Check columns
    for (j=0; j<COL; j++) {
        if (game_board[0][j] == game_board[1][j] && game_board[1][j] == game_board[2][j]) {
            return game_board[0][j];
        }
    }
    // Check diagonals
    if (game_board[0][0] == game_board[1][1] && game_board[1][1] == game_board[2][2]) {
        return game_board[0][0];
    }
    if (game_board[0][2] == game_board[1][1] && game_board[1][1] == game_board[2][0]) {
        return game_board[0][2];
    }
    return '-';
}

int main() {
    char player1 = 'X', player2 = 'O';
    char winner = '-';
    int turn, total_turns = 0;
    
    printf("Welcome to Tic Tac Toe!\n");
    initialize_board();
    display_board();
    
    for (turn=1; turn<=9; turn++) {
        if (turn % 2 == 1) {
            player_move(player1);
        } else {
            player_move(player2);
        }
        total_turns++;
        winner = check_win();
        if (winner != '-') {
            printf("Congratulations, player %c wins the game!\n", winner);
            break;
        } else if (total_turns == 9) {
            printf("The game is a tie!\n");
            break;
        }
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 initialize_board(void); // weak
__int64 display_board(void); // weak
__int64 __fastcall player_move(_QWORD); // weak
__int64 check_win(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000192C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+25h] [rbp-Bh]
  int v5; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5 = 0;
  printf("Welcome to Tic Tac Toe!\n");
  initialize_board();
  display_board();
  for ( i = 1; i <= 9; ++i )
  {
    if ( i % 2 == 1 )
      player_move(88i64);
    else
      player_move(79i64);
    ++v5;
    v4 = check_win();
    if ( v4 != 45 )
    {
      printf("Congratulations, player %c wins the game!\n", (unsigned int)v4);
      return 0;
    }
    if ( v5 == 9 )
    {
      printf("The game is a tie!\n");
      return 0;
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 initialize_board(void);
// 14000163E: using guessed type __int64 display_board(void);
// 1400016CB: using guessed type __int64 __fastcall player_move(_QWORD);
// 1400017A9: using guessed type __int64 check_win(void);
// 140001AA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sudoku solver ; Style: complete
#include <stdio.h>
#include <stdbool.h>

#define N 9

void print_board(int board[N][N]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%d ", board[i][j]);
        }
        printf("\n");
    }
}

bool is_valid(int board[N][N], int row, int col, int num) {
    // Check row
    for (int i = 0; i < N; i++) {
        if (board[row][i] == num) {
            return false;
        }
    }
    // Check column
    for (int i = 0; i < N; i++) {
        if (board[i][col] == num) {
            return false;
        }
    }
    // Check box
    int box_row = row - (row % 3);
    int box_col = col - (col % 3);
    for (int i = box_row; i < box_row + 3; i++) {
        for (int j = box_col; j < box_col + 3; j++) {
            if (board[i][j] == num) {
                return false;
            }
        }
    }
    return true;
}

bool solve_board(int board[N][N], int row, int col) {
    if (row == N) {
        return true;
    }
    if (col == N) {
        return solve_board(board, row + 1, 0);
    }
    if (board[row][col] != 0) {
        return solve_board(board, row, col + 1);
    }
    for (int num = 1; num <= 9; num++) {
        if (is_valid(board, row, col, num)) {
            board[row][col] = num;
            if (solve_board(board, row, col + 1)) {
                return true;
            }
            board[row][col] = 0;
        }
    }
    return false;
}

int main() {
    int board[N][N] = {
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0}
    };
    if (solve_board(board, 0, 0)) {
        printf("Sudoku puzzle solved:\n");
        print_board(board);
    } else {
        printf("Unable to solve Sudoku puzzle\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall print_board(_QWORD); // weak
__int64 __fastcall solve_board(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018C5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[320]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+160h] [rbp+E0h]

  _main(argc, argv, envp);
  memset(v4, 0, sizeof(v4));
  v5 = 0;
  if ( (unsigned __int8)solve_board(v4, 0i64, 0i64) )
  {
    printf("Sudoku puzzle solved:\n");
    print_board(v4);
  }
  else
  {
    printf("Unable to solve Sudoku puzzle\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall print_board(_QWORD);
// 140001781: using guessed type __int64 __fastcall solve_board(_QWORD, _QWORD, _QWORD);
// 140001A00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

#define FLOORS 10
#define ELEVATORS 3

typedef struct {
    int currentFloor;
    int destinationFloor;
    bool inUse;
} Elevator;

void printElevatorStatus(Elevator elevators[]) {
    printf("Elevator Status:\n");
    for(int i = 0; i < ELEVATORS; i++) {
        printf("Elevator %d: ", i+1);
        if(elevators[i].inUse) {
            printf("On floor %d, going to floor %d\n", elevators[i].currentFloor, elevators[i].destinationFloor);
        } else {
            printf("Not in use\n");
        }
    }
}

int getNextFloor(int currentFloor, int destinationFloor) {
    if(currentFloor < destinationFloor) {
        return currentFloor + 1;
    } else {
        return currentFloor - 1;
    }
}

int main() {

    Elevator elevators[ELEVATORS];
    for(int i = 0; i < ELEVATORS; i++) {
        elevators[i].inUse = false;
    }

    srand(time(NULL));

    int passengersWaiting[FLOORS];
    for(int i = 0; i < FLOORS; i++) {
        passengersWaiting[i] = 0;
    }

    int numberOfPassengers = 0;
    int maxNumberOfPassengers = 20;

    while(true) {

        for(int i = 0; i < FLOORS; i++) {
            if(rand() % 100 < 10) {
                passengersWaiting[i] += 1;
                numberOfPassengers += 1;
            }
        }

        printElevatorStatus(elevators);
        printf("Number of Passengers Waiting: %d\n", numberOfPassengers);

        for(int i = 0; i < ELEVATORS; i++) {
            if(elevators[i].inUse) {
                int nextFloor = getNextFloor(elevators[i].currentFloor, elevators[i].destinationFloor);
                printf("Elevator %d moving from floor %d to floor %d\n", i+1, elevators[i].currentFloor, nextFloor);
                elevators[i].currentFloor = nextFloor;

                if(elevators[i].currentFloor == elevators[i].destinationFloor) {
                    elevators[i].inUse = false;
                }
            } else {
                for(int j = 0; j < FLOORS; j++) {
                    if(passengersWaiting[j] > 0) {
                        elevators[i].destinationFloor = j;
                        elevators[i].inUse = true;
                        elevators[i].currentFloor = rand() % FLOORS;
                        passengersWaiting[j] -= 1;
                        numberOfPassengers -= 1;

                        printf("Elevator %d picked up a passenger from floor %d, going to floor %d\n", i+1, elevators[i].currentFloor, elevators[i].destinationFloor);

                        break;
                    }
                }
            }
        }

    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall printElevatorStatus(_QWORD); // weak
__int64 __fastcall getNextFloor(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400016AF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[12]; // [rsp+20h] [rbp-80h]
  unsigned int v6[12]; // [rsp+50h] [rbp-50h] BYREF
  unsigned int NextFloor; // [rsp+80h] [rbp-20h]
  int v8; // [rsp+84h] [rbp-1Ch]
  int n; // [rsp+88h] [rbp-18h]
  int m; // [rsp+8Ch] [rbp-14h]
  int k; // [rsp+90h] [rbp-10h]
  unsigned int v12; // [rsp+94h] [rbp-Ch]
  int j; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  for ( i = 0; i <= 2; ++i )
    LOBYTE(v6[3 * i + 2]) = 0;
  v3 = time(0i64);
  srand(v3);
  for ( j = 0; j <= 9; ++j )
    v5[j] = 0;
  v12 = 0;
  v8 = 20;
  while ( 1 )
  {
    for ( k = 0; k <= 9; ++k )
    {
      if ( rand() % 100 <= 9 )
      {
        ++v5[k];
        ++v12;
      }
    }
    printElevatorStatus(v6);
    printf("Number of Passengers Waiting: %d\n", v12);
    for ( m = 0; m <= 2; ++m )
    {
      if ( LOBYTE(v6[3 * m + 2]) )
      {
        NextFloor = getNextFloor(v6[3 * m], v6[3 * m + 1]);
        printf("Elevator %d moving from floor %d to floor %d\n", (unsigned int)(m + 1), v6[3 * m], NextFloor);
        v6[3 * m] = NextFloor;
        if ( v6[3 * m] == v6[3 * m + 1] )
          LOBYTE(v6[3 * m + 2]) = 0;
      }
      else
      {
        for ( n = 0; ; ++n )
        {
          if ( n > 9 )
            goto LABEL_22;
          if ( v5[n] > 0 )
            break;
        }
        v6[3 * m + 1] = n;
        LOBYTE(v6[3 * m + 2]) = 1;
        v6[3 * m] = rand() % 10;
        --v5[n];
        --v12;
        printf(
          "Elevator %d picked up a passenger from floor %d, going to floor %d\n",
          (unsigned int)(m + 1),
          v6[3 * m],
          v6[3 * m + 1]);
      }
LABEL_22:
      ;
    }
  }
}
// 1400015B0: using guessed type __int64 __fastcall printElevatorStatus(_QWORD);
// 14000168D: using guessed type __int64 __fastcall getNextFloor(_QWORD, _QWORD);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016AF: using guessed type int var_80[12];
// 1400016AF: using guessed type unsigned int var_50[12];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sudoku solver ; Style: artistic
#include <stdio.h>
#include <stdlib.h>

#define ROW 9
#define COL 9

void print(int grid[ROW][COL]) {
  printf("-------------------------\n");
  for (int i = 0; i < ROW; i++) {
    printf("| ");
    for (int j = 0; j < COL; j++) {
      printf("%d ", grid[i][j]);
      if ((j + 1) % 3 == 0)
        printf("| ");
    }
    printf("\n");
    if ((i + 1) % 3 == 0)
      printf("-------------------------\n");
  }
}

int isSafe(int grid[ROW][COL], int row, int col, int num) {
  for (int i = 0; i < 9; i++) {
    if (grid[row][i] == num)
      return 0;
    if (grid[i][col] == num)
      return 0;
    if (grid[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num)
      return 0;
  }
  return 1;
}

int solve(int grid[ROW][COL], int row, int col) {
  if (row == 8 && col == 9) {
    return 1;
  }

  if (col == 9) {
    row++;
    col = 0;
  }

  if (grid[row][col] > 0) {
    return solve(grid, row, col + 1);
  }

  for (int num = 1; num <= 9; num++) {
    if (isSafe(grid, row, col, num)) {
      grid[row][col] = num;
      if (solve(grid, row, col + 1)) {
        return 1;
      }
      grid[row][col] = 0;
    }
  }
  return 0;
}

int main() {
  int grid[ROW][COL] = {{5, 3, 0, 0, 7, 0, 0, 0, 0},
                        {6, 0, 0, 1, 9, 5, 0, 0, 0},
                        {0, 9, 8, 0, 0, 0, 0, 6, 0},
                        {8, 0, 0, 0, 6, 0, 0, 0, 3},
                        {4, 0, 0, 8, 0, 3, 0, 0, 1},
                        {7, 0, 0, 0, 2, 0, 0, 0, 6},
                        {0, 6, 0, 0, 0, 0, 2, 8, 0},
                        {0, 0, 0, 4, 1, 9, 0, 0, 5},
                        {0, 0, 0, 0, 8, 0, 0, 7, 9}};

  if (solve(grid, 0, 0)) {
    print(grid);
  } else {
    printf("No solution exists!");
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall print(_QWORD); // weak
__int64 __fastcall solve(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (0000000140001937) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[352]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v4, &unk_14000A020, 0x144ui64);
  if ( (unsigned int)solve(v4, 0i64, 0i64) )
    print(v4);
  else
    printf("No solution exists!");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall print(_QWORD);
// 1400017FE: using guessed type __int64 __fastcall solve(_QWORD, _QWORD, _QWORD);
// 140001A70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Dice Roller ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int sides, diceNum, rollSum, i;
    char choice;
    srand(time(0));  // Seed value for random number generator

    do {
        printf("Enter the number of dice to roll: ");
        scanf("%d", &diceNum);

        printf("Enter the number of sides for the dice: ");
        scanf("%d", &sides);

        rollSum = 0;  // Reset roll sum value for each roll

        printf("\nRolling %d dice with %d sides...\n\n", diceNum, sides);

        for(i = 0; i < diceNum; i++) {
            int roll = rand() % sides + 1;  // Random number generation for each dice roll
            printf("Dice %d rolled: %d\n", i + 1, roll);
            rollSum += roll;
        }

        printf("\nTotal roll sum: %d\n", rollSum);

        printf("\nRoll again? (y/n): ");
        scanf("%s", &choice); 
    } while(choice == 'y' || choice == 'Y');

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5; // [rsp+2Bh] [rbp-15h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v7; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v8; // [rsp+34h] [rbp-Ch]
  int i; // [rsp+38h] [rbp-8h]
  unsigned int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  do
  {
    printf("Enter the number of dice to roll: ");
    scanf("%d", &v6);
    printf("Enter the number of sides for the dice: ");
    scanf("%d", &v7);
    v10 = 0;
    printf("\nRolling %d dice with %d sides...\n\n", v6, v7);
    for ( i = 0; i < (int)v6; ++i )
    {
      v8 = rand() % (int)v7 + 1;
      printf("Dice %d rolled: %d\n", (unsigned int)(i + 1), v8);
      v10 += v8;
    }
    printf("\nTotal roll sum: %d\n", v10);
    printf("\nRoll again? (y/n): ");
    scanf("%s", &v5);
  }
  while ( v5 == 121 || v5 == 89 );
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: CPU Scheduling Algorithms ; Style: distributed
#include<stdio.h>

int n, time = 0;
int wt[20], tat[20], bt[20], rt[20];
int completed = 0;

void roundRobin(int quantum) {
    int i;
    while (completed != n) {
        for (i = 0; i < n; i++) {
            if (rt[i] > 0) {
                if (rt[i] > quantum) {
                    rt[i] -= quantum;
                    time += quantum;
                }
                else {
                    time += rt[i];
                    tat[i] = time - bt[i];
                    rt[i] = 0;
                    completed++;
                }
            }
        }
    }
}

void display() {
    int i;
    float avgtat = 0, avgwt = 0;
    printf("\n\tProcess Burst Time  \tWaiting Time\tTurnaround Time");

    for (i = 0; i < n; i++) {
        wt[i] = tat[i] - bt[i];
        avgwt += wt[i];
        avgtat += tat[i];
        printf("\n\tP%d\t\t%d\t\t%d\t\t%d", i + 1, bt[i], wt[i], tat[i]);
    }

    printf("\n\n\tAverage Waiting Time : %f", avgwt / n);
    printf("\n\tAverage Turnaround Time : %f", avgtat / n);
}

void main() {
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    int quantum;
    printf("\nEnter Time Quantum:");
    scanf("%d", &quantum);

    int i;
    printf("\nEnter Burst Time for each process: ");
    for (i = 0; i < n; i++) {
        printf("\nProcess %d: ", i + 1);
        scanf("%d", &bt[i]);
        rt[i] = bt[i];
    }
    roundRobin(quantum);
    display();
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall roundRobin(_QWORD); // weak
__int64 display(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

int n; // weak
_DWORD bt[24]; // weak
_DWORD rt[20]; // weak


//----- (000000014000190E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-8h] BYREF
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of processes: ");
  scanf("%d", &n);
  printf("\nEnter Time Quantum:");
  scanf("%d", &v4);
  printf("\nEnter Burst Time for each process: ");
  for ( i = 0; i < n; ++i )
  {
    printf("\nProcess %d: ", (unsigned int)(i + 1));
    scanf("%d", &bt[i]);
    rt[i] = bt[i];
  }
  roundRobin(v4);
  return display();
}
// 1400015E2: using guessed type __int64 __fastcall roundRobin(_QWORD);
// 140001738: using guessed type __int64 display(void);
// 140001AD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019040: using guessed type int n;
// 140019120: using guessed type _DWORD bt[24];
// 140019180: using guessed type _DWORD rt[20];

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Wireless Network Scanner ; Style: visionary
// This program demonstrates a visionary approach to developing a wireless network scanner in C. 
// The program scans for available wireless networks and displays their information in an organized manner.
// It also includes various features like sorting, filtering, and exporting the collected data.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define a structure to hold the information of each wireless network
typedef struct {
    char ssid[32];
    char bssid[18];
    int channel;
    int signal_strength;
} wireless_network;

// Define a utility function to initialize the network structure
void init_network(wireless_network* network) {
    strcpy(network->ssid, "");
    strcpy(network->bssid, "");
    network->channel = 0;
    network->signal_strength = 0;
}

// Define a utility function to read the network information from input
void read_network_info(char* input, wireless_network* network) {
    sscanf(input, "%s %s %d %d", network->ssid, network->bssid, &network->channel, &network->signal_strength);
}

// Define a utility function to compare two network structure by their signal strength (descending)
int comp_signal_strength(const void* network1, const void* network2) {
    return ((wireless_network*)network2)->signal_strength - ((wireless_network*)network1)->signal_strength;
}

// Define a utility function to compare two network structure by their channel number (ascending)
int comp_channel(const void* network1, const void* network2) {
    return ((wireless_network*)network1)->channel - ((wireless_network*)network2)->channel;
}

// Define a utility function to filter out networks with signal strength below a given threshold
int filter_signal_strength(const void* network, void* threshold) {
    return ((wireless_network*)network)->signal_strength >= *((int*)threshold);
}

int main() {
    // Define an array to hold the scanned network information (can hold up to 100 networks)
    wireless_network networks[100];
    int num_networks = 0;

    // Scan for available wireless networks (using some system call or library functions)
    // Store the scanned information in the networks array, increment num_networks for each scanned network

    // Sort the networks array by their signal strength (descending)
    qsort(networks, num_networks, sizeof(wireless_network), comp_signal_strength);

    // Display the network information in a formatted table
    printf("%32s %18s %8s %10s\n", "SSID", "BSSID", "Channel", "Signal");
    printf("%32s %18s %8s %10s\n", "----", "-----", "-------", "------");
    for (int i = 0; i < num_networks; i++) {
        printf("%32s %18s %8d %10d\n", networks[i].ssid, networks[i].bssid, networks[i].channel, networks[i].signal_strength);
    }

    // Sort the networks array by their channel number (ascending)
    qsort(networks, num_networks, sizeof(wireless_network), comp_channel);

    // Filter out networks with signal strength below a given threshold
    int threshold = -70;
    int num_filtered = 0;
    for (int i = 0; i < num_networks; i++) {
        if (filter_signal_strength(&networks[i], &threshold)) {
            networks[num_filtered++] = networks[i];
        }
    }
    num_networks = num_filtered;

    // Export the filtered network information to a CSV file
    FILE* fp = fopen("filtered_networks.csv", "w");
    if (fp != NULL) {
        fprintf(fp, "SSID,BSSID,Channel,Signal\n");
        for (int i = 0; i < num_networks; i++) {
            fprintf(fp, "%s,%s,%d,%d\n", networks[i].ssid, networks[i].bssid, networks[i].channel, networks[i].signal_strength);
        }
        fclose(fp);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __cdecl comp_signal_strength(const void *, const void *); // idb
int __cdecl comp_channel(const void *, const void *); // idb
__int64 __fastcall filter_signal_strength(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001703) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // r8d
  int v4; // eax
  _BYTE *v5; // rax
  _BYTE *v6; // rdx
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rbx
  int v10; // edx
  __int64 v12; // [rsp+20h] [rbp-60h]
  __int64 v13; // [rsp+28h] [rbp-58h]
  int v14; // [rsp+3Ch] [rbp-44h] BYREF
  char Base[64]; // [rsp+40h] [rbp-40h] BYREF
  _BYTE v16[5936]; // [rsp+80h] [rbp+0h] BYREF
  FILE *Stream; // [rsp+17B0h] [rbp+1730h]
  int v18; // [rsp+17BCh] [rbp+173Ch]
  int k; // [rsp+17C0h] [rbp+1740h]
  int j; // [rsp+17C4h] [rbp+1744h]
  int v21; // [rsp+17C8h] [rbp+1748h]
  int i; // [rsp+17CCh] [rbp+174Ch]

  _main(argc, argv, envp);
  v18 = 0;
  qsort(Base, 0i64, 0x3Cui64, comp_signal_strength);
  printf("%32s %18s %8s %10s\n", "SSID", "BSSID", "Channel", "Signal");
  printf("%32s %18s %8s %10s\n", "----", "-----", "-------", "------");
  for ( i = 0; i < v18; ++i )
  {
    v3 = *(_DWORD *)&v16[60 * i - 12];
    LODWORD(v12) = *(_DWORD *)&v16[60 * i - 8];
    printf("%32s %18s %8d %10d\n", &Base[60 * i], &Base[60 * i + 32], v3, v12);
  }
  qsort(Base, v18, 0x3Cui64, comp_channel);
  v14 = -70;
  v21 = 0;
  for ( j = 0; j < v18; ++j )
  {
    if ( (unsigned int)filter_signal_strength(&Base[60 * j], &v14) )
    {
      v4 = v21++;
      v5 = &v16[60 * v4 - 64];
      v6 = &v16[60 * j - 64];
      v7 = *((_QWORD *)v6 + 1);
      *(_QWORD *)v5 = *(_QWORD *)v6;
      *((_QWORD *)v5 + 1) = v7;
      v8 = *((_QWORD *)v6 + 3);
      *((_QWORD *)v5 + 2) = *((_QWORD *)v6 + 2);
      *((_QWORD *)v5 + 3) = v8;
      v9 = *((_QWORD *)v6 + 5);
      *((_QWORD *)v5 + 4) = *((_QWORD *)v6 + 4);
      *((_QWORD *)v5 + 5) = v9;
      *((_QWORD *)v5 + 6) = *((_QWORD *)v6 + 6);
      *((_DWORD *)v5 + 14) = *((_DWORD *)v6 + 14);
    }
  }
  v18 = v21;
  Stream = fopen("filtered_networks.csv", "w");
  if ( Stream )
  {
    fprintf_0(Stream, "SSID,BSSID,Channel,Signal\n");
    for ( k = 0; k < v18; ++k )
    {
      v10 = *(_DWORD *)&v16[60 * k - 12];
      LODWORD(v13) = *(_DWORD *)&v16[60 * k - 8];
      LODWORD(v12) = v10;
      fprintf_0(Stream, "%s,%s,%d,%d\n", &Base[60 * k], &Base[60 * k + 32], v12, v13);
    }
    fclose(Stream);
  }
  return 0;
}
// 1400016E0: using guessed type __int64 __fastcall filter_signal_strength(_QWORD, _QWORD);
// 140001BB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001703: using guessed type char Base[64];

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bingo Simulator ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int main() {
    // Initialize variables
    int i, j;
    int callNum; // The number that's been called
    bool bingo = false; // Did someone get a Bingo?
    char board[5][5] = { // Board initialization
        {'B', 'I', 'N', 'G', 'O'},
        {15, 20, 35, 57, 72},
        {6, 18, 41, 49, 62},
        {1, 24, 34, 55, 68},
        {3, 29, 44, 59, 74}
    };
    
    // Print starting message
    printf("Welcome to the Bingo Simulator!\n");
    printf("Press ENTER to begin...\n");
    getchar();
    
    // Loop through and call numbers until a Bingo is achieved
    while (!bingo) {
        // Generate random number
        callNum = rand() % 75 + 1;
        
        // Print called number
        printf("\n%d!\n", callNum);
        
        // Check if number is on the board and replace with an X if found
        for (i = 1; i < 5; i++) {
            for (j = 0; j < 5; j++) {
                if (board[i][j] == callNum) {
                    board[i][j] = 'X';
                }
            }
        }
        
        // Print updated board
        printf("\n");
        for (i = 0; i < 5; i++) {
            for (j = 0; j < 5; j++) {
                printf("%c\t", board[i][j]);
            }
            printf("\n\n");
        }
        
        // Check for a Bingo
        for (i = 1; i < 5; i++) {
            // Horizontal row
            if (board[i][0] == 'X' && board[i][1] == 'X' && board[i][2] == 'X' && board[i][3] == 'X' && board[i][4] == 'X') {
                printf("BINGO! Horizontal row %d!\n", i);
                bingo = true;
            }
            // Vertical column
            else if (board[1][i] == 'X' && board[2][i] == 'X' && board[3][i] == 'X' && board[4][i] == 'X' && board[5][i] == 'X') {
                printf("BINGO! Vertical column %d!\n", i);
                bingo = true;
            }
            // Diagonal
            else if ((board[1][1] == 'X' && board[2][2] == 'X' && board[3][3] == 'X' && board[4][4] == 'X' && board[5][5] == 'X') ||
                     (board[1][5] == 'X' && board[2][4] == 'X' && board[3][3] == 'X' && board[4][2] == 'X' && board[5][1] == 'X')) {
                printf("BINGO! Diagonal!\n");
                bingo = true;
            }
        }
        
        // Wait for user to press ENTER before continuing
        printf("\nPress ENTER to continue...\n");
        getchar();
        
        // Clear screen
        system("clear");
    }
    
    // Print ending message
    printf("Congratulations! You won Bingo!");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl system(const char *Command);
// int __cdecl rand();
// int __cdecl getchar();


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-30h]
  char v5; // [rsp+24h] [rbp-2Ch]
  int v6; // [rsp+25h] [rbp-2Bh]
  char v7; // [rsp+29h] [rbp-27h]
  int v8; // [rsp+2Ah] [rbp-26h]
  char v9; // [rsp+2Eh] [rbp-22h]
  int v10; // [rsp+2Fh] [rbp-21h]
  char v11; // [rsp+33h] [rbp-1Dh]
  int v12; // [rsp+34h] [rbp-1Ch]
  char v13; // [rsp+38h] [rbp-18h]
  char v14[7]; // [rsp+39h] [rbp-17h]
  unsigned int v15; // [rsp+40h] [rbp-10h]
  char v16; // [rsp+47h] [rbp-9h]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]
  __int64 savedregs; // [rsp+50h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  v16 = 0;
  v4 = 1196312898;
  v5 = 79;
  v6 = 958600207;
  v7 = 72;
  v8 = 824775174;
  v9 = 62;
  v10 = 924981249;
  v11 = 68;
  v12 = 992746755;
  v13 = 74;
  printf("Welcome to the Bingo Simulator!\n");
  printf("Press ENTER to begin...\n");
  getchar();
  while ( v16 != 1 )
  {
    v15 = rand() % 75 + 1;
    printf("\n%d!\n", v15);
    for ( i = 1; i <= 4; ++i )
    {
      for ( j = 0; j <= 4; ++j )
      {
        if ( v15 == *((char *)&savedregs + 5 * i + j - 48) )
          *((_BYTE *)&savedregs + 5 * i + j - 48) = 88;
      }
    }
    printf("\n");
    for ( i = 0; i <= 4; ++i )
    {
      for ( j = 0; j <= 4; ++j )
        printf("%c\t", (unsigned int)*((char *)&savedregs + 5 * i + j - 48));
      printf("\n\n");
    }
    for ( i = 1; i <= 4; ++i )
    {
      if ( *((_BYTE *)&v4 + 5 * i) == 88
        && *((_BYTE *)&v4 + 5 * i + 1) == 88
        && *((_BYTE *)&v4 + 5 * i + 2) == 88
        && *((_BYTE *)&v4 + 5 * i + 3) == 88
        && *(&v5 + 5 * i) == 88 )
      {
        printf("BINGO! Horizontal row %d!\n", (unsigned int)i);
        v16 = 1;
      }
      else if ( *((_BYTE *)&v6 + i) == 88
             && *((_BYTE *)&v8 + i) == 88
             && *((_BYTE *)&v10 + i) == 88
             && *((_BYTE *)&v12 + i) == 88
             && v14[i] == 88 )
      {
        printf("BINGO! Vertical column %d!\n", (unsigned int)i);
        v16 = 1;
      }
      else if ( BYTE1(v6) == 88 && BYTE2(v8) == 88 && HIBYTE(v10) == 88 && v13 == 88 && v14[5] == 88
             || (_BYTE)v8 == 88 && v9 == 88 && HIBYTE(v10) == 88 && BYTE2(v12) == 88 && v14[1] == 88 )
      {
        printf("BINGO! Diagonal!\n");
        v16 = 1;
      }
    }
    printf("\nPress ENTER to continue...\n");
    getchar();
    system("clear");
  }
  printf("Congratulations! You won Bingo!");
  return 0;
}
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: creative
#include <stdio.h>

//function to search the array for the given element
int search(int arr[], int n, int x) {
    int i;
    for(i=0;i<n;i++) {
        if(arr[i]==x) {
            return i; //return the index of the element if found
        }
    }
    return -1; //return -1 if element is not found
}

int main() {
    int arr[10] = {5,12,7,21,3,19,9,18,15,6};
    int n = 10; //size of array
    int x; //element to be searched
    int pos; //position of element in array
    
    printf("Enter the element to be searched: ");
    scanf("%d", &x);
    
    pos = search(arr, n, x);
    
    if(pos!=-1) {
        printf("%d is present at index %d in the array.", x, pos);
    }
    else {
        printf("%d is not present in the array.", x);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall search(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001635) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-34h] BYREF
  int v5[10]; // [rsp+30h] [rbp-30h] BYREF
  unsigned int v6; // [rsp+58h] [rbp-8h]
  unsigned int v7; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5[0] = 5;
  v5[1] = 12;
  v5[2] = 7;
  v5[3] = 21;
  v5[4] = 3;
  v5[5] = 19;
  v5[6] = 9;
  v5[7] = 18;
  v5[8] = 15;
  v5[9] = 6;
  v7 = 10;
  printf("Enter the element to be searched: ");
  scanf("%d", &v4);
  v6 = search(v5, v7, v4);
  if ( v6 == -1 )
    printf("%d is not present in the array.", v4);
  else
    printf("%d is present at index %d in the array.", v4, v6);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall search(_QWORD, _QWORD, _QWORD);
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Appointment Scheduler ; Style: retro
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct appointment {
    int hour;
    char name[100];
};

void addAppointment(struct appointment *appts, int *numAppts);
void removeAppointment(struct appointment *appts, int *numAppts);
void printAppointments(struct appointment *appts, int numAppts);

int main() {
    struct appointment appts[100];
    int numAppts = 0;
    int choice = 0;

    while (choice != 4) {
        printf("Appointment Scheduler\n");
        printf("1. Add Appointment\n");
        printf("2. Remove Appointment\n");
        printf("3. Print Appointments\n");
        printf("4. Exit\n");
        printf("Enter choice: ");

        scanf("%d", &choice);
        printf("\n");

        switch (choice) {
            case 1:
                addAppointment(appts, &numAppts);
                break;
            case 2:
                removeAppointment(appts, &numAppts);
                break;
            case 3:
                printAppointments(appts, numAppts);
                break;
            case 4:
                printf("Goodbye!\n\n");
                break;
            default:
                printf("Invalid choice. Please try again.\n\n");
                break;
        }
    }

    return 0;
}

void addAppointment(struct appointment *appts, int *numAppts) {
    int hour;
    char name[100];

    printf("Enter hour (0-23): ");
    scanf("%d", &hour);

    if (hour < 0 || hour > 23) {
        printf("Invalid hour. Please try again.\n\n");
        return;
    }

    printf("Enter name: ");
    scanf("%s", name);

    appts[*numAppts].hour = hour;
    strcpy(appts[*numAppts].name, name);
    (*numAppts)++;

    printf("Appointment added!\n\n");
}

void removeAppointment(struct appointment *appts, int *numAppts) {
    int index;
    int hour;

    printf("Enter hour of appointment to remove: ");
    scanf("%d", &hour);

    for (int i = 0; i < *numAppts; i++) {
        if (appts[i].hour == hour) {
            index = i;
            break;
        } else if (i == *numAppts - 1) {
            printf("No appointment at that hour.\n\n");
            return;
        }
    }

    for (int i = index; i < *numAppts - 1; i++) {
        appts[i] = appts[i+1];
    }
    (*numAppts)--;
    printf("Appointment removed!\n\n");
}

void printAppointments(struct appointment *appts, int numAppts) {
    printf("Appointments:\n");
    for (int i = 0; i < numAppts; i++) {
        printf("%d: %s\n", appts[i].hour, appts[i].name);
    }
    printf("\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall addAppointment(_QWORD, _QWORD); // weak
__int64 __fastcall removeAppointment(_QWORD, _QWORD); // weak
__int64 __fastcall printAppointments(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[10400]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  v4 = 0;
  while ( v4 != 4 )
  {
    printf("Appointment Scheduler\n");
    printf("1. Add Appointment\n");
    printf("2. Remove Appointment\n");
    printf("3. Print Appointments\n");
    printf("4. Exit\n");
    printf("Enter choice: ");
    scanf("%d", &v4);
    printf("\n");
    if ( v4 == 4 )
    {
      printf("Goodbye!\n\n");
    }
    else
    {
      if ( v4 > 4 )
        goto LABEL_12;
      switch ( v4 )
      {
        case 3:
          printAppointments(v6, v5);
          break;
        case 1:
          addAppointment(v6, &v5);
          break;
        case 2:
          removeAppointment(v6, &v5);
          break;
        default:
LABEL_12:
          printf("Invalid choice. Please try again.\n\n");
          break;
      }
    }
  }
  return 0;
}
// 1400016A4: conditional instruction was optimized away because %var_28A8.4<3
// 140001722: using guessed type __int64 __fastcall addAppointment(_QWORD, _QWORD);
// 14000182D: using guessed type __int64 __fastcall removeAppointment(_QWORD, _QWORD);
// 1400019CC: using guessed type __int64 __fastcall printAppointments(_QWORD, _QWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data validation ; Style: inquisitive
#include<stdio.h> 

int main() 
{ 
    int age; 
    printf("What is your age? "); 
    scanf("%d",&age); 

    //If age is less than 18, ask for confirmation from parent/guardian. 
    if (age < 18) 
    { 
        char confirmation; 
        printf("You are below 18 years old. Do you have parental/guardian permission? (Y/N) "); 
        scanf(" %c",&confirmation); 

        //If confirmation is yes, proceed with the program. 
        if(confirmation == 'Y' || confirmation == 'y') 
        { 
            printf("Thank you! You may continue.\n"); 
        } 
        //If confirmation is no, terminate the program. 
        else if(confirmation == 'N' || confirmation == 'n') 
        { 
            printf("Sorry, you need parental/guardian permission to continue.\n"); 
            return 0; 
        } 
        //If confirmation is not Y or N, ask again. 
        else 
        { 
            printf("Invalid input. Please enter Y or N.\n"); 
            scanf(" %c",&confirmation); 
        } 
    } 

    //If age is greater than or equal to 18, proceed with the program. 
    else 
    { 
        printf("Thank you! You may continue.\n"); 
    } 

    //Ask for a phone number. Must be in the format XXX-XXX-XXXX. 
    char phone_number[12]; 
    printf("What is your phone number? (Format: XXX-XXX-XXXX) "); 
    scanf("%11s", phone_number); 

    //Check that phone number fits the format of XXX-XXX-XXXX 
    int i; 
    for(i = 0; i < 12; i++) 
    { 
        if(i == 3 || i == 7) 
        { 
            if(phone_number[i] != '-') 
            { 
                printf("Invalid phone number format. Please enter in format XXX-XXX-XXXX.\n"); 
                return 0; 
            } 
        } 
        else 
        { 
            if(phone_number[i] < '0' || phone_number[i] > '9') 
            { 
                printf("Invalid phone number format. Please enter in format XXX-XXX-XXXX.\n"); 
                return 0; 
            } 
        } 
    } 

    printf("Thank you! Your phone number is %s.\n", phone_number); 
    return 0; 
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Bh] [rbp-15h] BYREF
  char v5[12]; // [rsp+2Ch] [rbp-14h] BYREF
  int v6; // [rsp+38h] [rbp-8h] BYREF
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("What is your age? ");
  scanf("%d", &v6);
  if ( v6 > 17 )
  {
    printf("Thank you! You may continue.\n");
  }
  else
  {
    printf("You are below 18 years old. Do you have parental/guardian permission? (Y/N) ");
    scanf(" %c", &v4);
    if ( v4 == 89 || v4 == 121 )
    {
      printf("Thank you! You may continue.\n");
    }
    else
    {
      if ( v4 == 78 || v4 == 110 )
      {
        printf("Sorry, you need parental/guardian permission to continue.\n");
        return 0;
      }
      printf("Invalid input. Please enter Y or N.\n");
      scanf(" %c", &v4);
    }
  }
  printf("What is your phone number? (Format: XXX-XXX-XXXX) ");
  scanf("%11s", v5);
  for ( i = 0; i <= 11; ++i )
  {
    if ( i == 3 || i == 7 )
    {
      if ( v5[i] != 45 )
        goto LABEL_14;
    }
    else if ( v5[i] <= 47 || v5[i] > 57 )
    {
LABEL_14:
      printf("Invalid phone number format. Please enter in format XXX-XXX-XXXX.\n");
      return 0;
    }
  }
  printf("Thank you! Your phone number is %s.\n", v5);
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_14[12];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: bold
#include <stdio.h>
#include <stdlib.h>

// C searching algorithm example program

int linear_search(int arr[], int n, int target) {
    // Linear search algorithm
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}

int binary_search(int arr[], int n, int target) {
    // Binary search algorithm
    int low = 0, high = n - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            return mid;
        }
        else if (arr[mid] > target) {
            high = mid - 1;
        }
        else {
            low = mid + 1;
        }
    }
    return -1;
}

int main() {
    // Initializing an array and target value for search
    int arr[10] = { 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 };
    int target = 12;

    // Performing linear search and displaying the result
    int linear_index = linear_search(arr, 10, target);
    if (linear_index != -1) {
        printf("Linear Search Result: Found at index %d\n", linear_index);
    }
    else {
        printf("Linear Search Result: Not found\n");
    }

    // Performing binary search and displaying the result
    int binary_index = binary_search(arr, 10, target);
    if (binary_index != -1) {
        printf("Binary Search Result: Found at index %d\n", binary_index);
    }
    else {
        printf("Binary Search Result: Not found\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall linear_search(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall binary_search(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001684) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[13]; // [rsp+20h] [rbp-40h] BYREF
  unsigned int v5; // [rsp+54h] [rbp-Ch]
  unsigned int v6; // [rsp+58h] [rbp-8h]
  unsigned int v7; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 2;
  v4[1] = 4;
  v4[2] = 6;
  v4[3] = 8;
  v4[4] = 10;
  v4[5] = 12;
  v4[6] = 14;
  v4[7] = 16;
  v4[8] = 18;
  v4[9] = 20;
  v7 = 12;
  v6 = linear_search(v4, 10i64, 12i64);
  if ( v6 == -1 )
    printf("Linear Search Result: Not found\n");
  else
    printf("Linear Search Result: Found at index %d\n", v6);
  v5 = binary_search(v4, 10i64, v7);
  if ( v5 == -1 )
    printf("Binary Search Result: Not found\n");
  else
    printf("Binary Search Result: Found at index %d\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall linear_search(_QWORD, _QWORD, _QWORD);
// 1400015E4: using guessed type __int64 __fastcall binary_search(_QWORD, _QWORD, _QWORD);
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Steganography ; Style: grateful
#include <stdio.h>

//function to get the value of a specific bit from a number
int getBitValue(unsigned char byte, int bit){
    return (byte >> bit) & 1;
}

//function to change the value of a specific bit in a number
void setBitValue(unsigned char *byte, int bit, int value){
    *byte |= (value << bit);
}

//function to hide data in the least significant bits of an image
void hideData(unsigned char* imageData, unsigned char* messageData, int messageLength){
    for(int i=0; i < messageLength; i++){
        unsigned char messageByte = *(messageData+i);
        for(int j=0; j < 8; j++){
            unsigned char imageByte = *(imageData+i*8+j);
            setBitValue(&imageByte, 0, getBitValue(messageByte, j));
            *(imageData+i*8+j) = imageByte;
        }
    }
}

//function to retrieve data hidden in the least significant bits of an image
void retrieveData(unsigned char* imageData, unsigned char* messageData, int messageLength){
    for(int i=0; i < messageLength; i++){
        unsigned char messageByte = 0;
        for(int j=0; j < 8; j++){
            unsigned char imageByte = *(imageData+i*8+j);
            setBitValue(&messageByte, j, getBitValue(imageByte, 0));
        }
        *(messageData+i) = messageByte;
    }
}

int main(){
    //open image file
    FILE* imageFile = fopen("image.jpg", "rb");
    if(imageFile == NULL){
        printf("Error: could not open image file.\n");
        return 1;
    }

    //get image size
    fseek(imageFile, 0, SEEK_END);
    int imageSize = ftell(imageFile);
    fseek(imageFile, 0, SEEK_SET);

    //allocate memory for image data
    unsigned char* imageData = (unsigned char*)malloc(imageSize);
    if(imageData == NULL){
        printf("Error: could not allocate memory for image data.\n");
        fclose(imageFile);
        return 1;
    }

    //read image data into memory
    int bytesRead = fread(imageData, 1, imageSize, imageFile);
    if(bytesRead != imageSize){
        printf("Error: could not read image data into memory.\n");
        free(imageData);
        fclose(imageFile);
        return 1;
    }

    //close image file
    fclose(imageFile);

    //open message file
    FILE* messageFile = fopen("message.txt", "rb");
    if(messageFile == NULL){
        printf("Error: could not open message file.\n");
        free(imageData);
        return 1;
    }

    //get message size
    fseek(messageFile, 0, SEEK_END);
    int messageSize = ftell(messageFile);
    fseek(messageFile, 0, SEEK_SET);

    //allocate memory for message data
    unsigned char* messageData = (unsigned char*)malloc(messageSize);
    if(messageData == NULL){
        printf("Error: could not allocate memory for message data.\n");
        fclose(messageFile);
        free(imageData);
        return 1;
    }

    //read message data into memory
    bytesRead = fread(messageData, 1, messageSize, messageFile);
    if(bytesRead != messageSize){
        printf("Error: could not read message data into memory.\n");
        free(messageData);
        fclose(messageFile);
        free(imageData);
        return 1;
    }

    //close message file
    fclose(messageFile);

    //hide message data in image
    hideData(imageData, messageData, messageSize);

    //save modified image to file
    FILE* modifiedImageFile = fopen("modified_image.jpg", "wb");
    if(modifiedImageFile == NULL){
        printf("Error: could not open modified image file.\n");
        free(imageData);
        return 1;
    }

    fwrite(imageData, 1, imageSize, modifiedImageFile);
    fclose(modifiedImageFile);

    //retrieve message data from modified image
    unsigned char* retrievedMessageData = (unsigned char*)malloc(messageSize);
    if(retrievedMessageData == NULL){
        printf("Error: could not allocate memory for retrieved message data.\n");
        free(imageData);
        return 1;
    }

    retrieveData(imageData, retrievedMessageData, messageSize);

    //print retrieved message
    printf("Retrieved Message: %s\n", retrievedMessageData);

    //free memory
    free(imageData);
    free(messageData);
    free(retrievedMessageData);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall hideData(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall retrieveData(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// void __cdecl free(void *Block);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (000000014000173D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v4; // [rsp+28h] [rbp-48h]
  FILE *v5; // [rsp+30h] [rbp-40h]
  void *Block; // [rsp+38h] [rbp-38h]
  int v7; // [rsp+44h] [rbp-2Ch]
  FILE *v8; // [rsp+48h] [rbp-28h]
  void *Buffer; // [rsp+58h] [rbp-18h]
  int v10; // [rsp+64h] [rbp-Ch]
  FILE *Stream; // [rsp+68h] [rbp-8h]

  _main(argc, argv, envp);
  Stream = fopen("image.jpg", "rb");
  if ( Stream )
  {
    fseek(Stream, 0, 2);
    v10 = ftell(Stream);
    fseek(Stream, 0, 0);
    Buffer = malloc(v10);
    if ( Buffer )
    {
      if ( (unsigned int)fread(Buffer, 1ui64, v10, Stream) == v10 )
      {
        fclose(Stream);
        v8 = fopen("message.txt", "rb");
        if ( v8 )
        {
          fseek(v8, 0, 2);
          v7 = ftell(v8);
          fseek(v8, 0, 0);
          Block = malloc(v7);
          if ( Block )
          {
            if ( (unsigned int)fread(Block, 1ui64, v7, v8) == v7 )
            {
              fclose(v8);
              hideData(Buffer, Block, (unsigned int)v7);
              v5 = fopen("modified_image.jpg", "wb");
              if ( v5 )
              {
                fwrite(Buffer, 1ui64, v10, v5);
                fclose(v5);
                v4 = (char *)malloc(v7);
                if ( v4 )
                {
                  retrieveData(Buffer, v4, (unsigned int)v7);
                  printf("Retrieved Message: %s\n", v4);
                  free(Buffer);
                  free(Block);
                  free(v4);
                  return 0;
                }
                else
                {
                  printf("Error: could not allocate memory for retrieved message data.\n");
                  free(Buffer);
                  return 1;
                }
              }
              else
              {
                printf("Error: could not open modified image file.\n");
                free(Buffer);
                return 1;
              }
            }
            else
            {
              printf("Error: could not read message data into memory.\n");
              free(Block);
              fclose(v8);
              free(Buffer);
              return 1;
            }
          }
          else
          {
            printf("Error: could not allocate memory for message data.\n");
            fclose(v8);
            free(Buffer);
            return 1;
          }
        }
        else
        {
          printf("Error: could not open message file.\n");
          free(Buffer);
          return 1;
        }
      }
      else
      {
        printf("Error: could not read image data into memory.\n");
        free(Buffer);
        fclose(Stream);
        return 1;
      }
    }
    else
    {
      printf("Error: could not allocate memory for image data.\n");
      fclose(Stream);
      return 1;
    }
  }
  else
  {
    printf("Error: could not open image file.\n");
    return 1;
  }
}
// 1400015E2: using guessed type __int64 __fastcall hideData(_QWORD, _QWORD, _QWORD);
// 1400016A0: using guessed type __int64 __fastcall retrieveData(_QWORD, _QWORD, _QWORD);
// 140001B80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Banking Record System ; Style: grateful
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char name[50];
    int accountNumber;
    float balance;
} Account;

void displayMenu();
void addAccount(Account *accounts, int *numberOfAccounts);
void displayAccounts(Account *accounts, int numberOfAccounts);
void deposit(Account *accounts, int numberOfAccounts);
void withdraw(Account *accounts, int numberOfAccounts);

int main() {
    int choice, numberOfAccounts = 0;
    Account *accounts = malloc(sizeof(Account));
    
    do {
        displayMenu();
        scanf("%d", &choice);
        
        switch(choice) {
            case 1:
                addAccount(accounts, &numberOfAccounts);
                break;
            case 2:
                deposit(accounts, numberOfAccounts);
                break;
            case 3:
                withdraw(accounts, numberOfAccounts);
                break;
            case 4:
                displayAccounts(accounts, numberOfAccounts);
                break;
            case 5:
                printf("Goodbye!");
                break;
            default:
                printf("Invalid choice. Please try again.\n\n");
        }
    } while(choice != 5);
    
    free(accounts);
    
    return 0;
}

void displayMenu() {
    printf("Welcome to the Banking Record System!\n\n");
    printf("1. Add account\n");
    printf("2. Deposit\n");
    printf("3. Withdraw\n");
    printf("4. Display accounts\n");
    printf("5. Exit\n\n");
    printf("Please select an option: ");
}

void addAccount(Account *accounts, int *numberOfAccounts) {
    printf("\n\nAdd Account\n\n");
    printf("Please enter customer name: ");
    scanf("%s", accounts[*numberOfAccounts].name);
    printf("Please enter account number: ");
    scanf("%d", &accounts[*numberOfAccounts].accountNumber);
    printf("Please enter initial balance: ");
    scanf("%f", &accounts[*numberOfAccounts].balance);
    printf("Account added successfully!\n\n");
    *numberOfAccounts = *numberOfAccounts + 1;
}

void displayAccounts(Account *accounts, int numberOfAccounts) {
    printf("\n\nDisplay Accounts\n\n");
    
    if(numberOfAccounts == 0) {
        printf("No accounts found!\n\n");
    } else {
        for(int i=0; i<numberOfAccounts; i++) {
            printf("Name: %s\n", accounts[i].name);
            printf("Account Number: %d\n", accounts[i].accountNumber);
            printf("Balance: $%.2f\n\n", accounts[i].balance);
        }
    }
}

void deposit(Account *accounts, int numberOfAccounts) {
    printf("\n\nDeposit\n\n");
    int accountNumber;
    float amount;
    
    printf("Please enter account number: ");
    scanf("%d", &accountNumber);
    printf("Enter amount to deposit: $");
    scanf("%f", &amount);
    
    for(int i=0; i<numberOfAccounts; i++) {
        if(accounts[i].accountNumber == accountNumber) {
            accounts[i].balance += amount;
            printf("Deposit successful! Balance is now $%.2f\n\n", accounts[i].balance);
            return;
        }
    }
    
    printf("Account not found. Please check account number and try again.\n\n");
}

void withdraw(Account *accounts, int numberOfAccounts) {
    printf("\n\nWithdraw\n\n");
    int accountNumber;
    float amount;
    
    printf("Please enter account number: ");
    scanf("%d", &accountNumber);
    printf("Enter amount to withdraw: $");
    scanf("%f", &amount);
    
    for(int i=0; i<numberOfAccounts; i++) {
        if(accounts[i].accountNumber == accountNumber) {
            if(amount > accounts[i].balance) {
                printf("Insufficient funds. Please try again.\n\n");
                return;
            }
            
            accounts[i].balance -= amount;
            printf("Withdrawal successful! Balance is now $%.2f\n\n", accounts[i].balance);
            return;
        }
    }
    
    printf("Account not found. Please check account number and try again.\n\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 displayMenu(void); // weak
__int64 __fastcall addAccount(_QWORD, _QWORD); // weak
__int64 __fastcall displayAccounts(_QWORD, _QWORD); // weak
__int64 __fastcall deposit(_QWORD, _QWORD); // weak
__int64 __fastcall withdraw(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-10h] BYREF
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  void *Block; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v4 = 0;
  Block = malloc(0x3Cui64);
  do
  {
    displayMenu();
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        addAccount(Block, &v4);
        break;
      case 2:
        deposit(Block, v4);
        break;
      case 3:
        withdraw(Block, v4);
        break;
      case 4:
        displayAccounts(Block, v4);
        break;
      case 5:
        printf("Goodbye!");
        break;
      default:
        printf("Invalid choice. Please try again.\n\n");
        break;
    }
  }
  while ( v5 != 5 );
  free(Block);
  return 0;
}
// 1400016D1: using guessed type __int64 displayMenu(void);
// 140001749: using guessed type __int64 __fastcall addAccount(_QWORD, _QWORD);
// 14000185B: using guessed type __int64 __fastcall displayAccounts(_QWORD, _QWORD);
// 140001962: using guessed type __int64 __fastcall deposit(_QWORD, _QWORD);
// 140001AC3: using guessed type __int64 __fastcall withdraw(_QWORD, _QWORD);
// 140001D20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database simulation ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>

// Define the maximum number of records that can be stored
#define MAX_RECORDS 100

// Define the structure of a record
struct record {
    int id;
    char name[50];
    int age;
};

// Declare the array of records
struct record records[MAX_RECORDS];

// Keep track of the number of records currently stored
int num_records = 0;

// Function to add a new record to the array
void add_record(int id, char name[50], int age) {
    // Check if the array is full
    if (num_records >= MAX_RECORDS) {
        printf("Error: Maximum number of records reached\n");
        return;
    }

    // Create a new record with the given values
    struct record new_record;
    new_record.id = id;
    for (int i=0; i<50; i++) {
        new_record.name[i] = name[i];
    }
    new_record.age = age;

    // Add the new record to the end of the array
    records[num_records++] = new_record;
}

// Function to delete a record from the array
void delete_record(int id) {
    // Find the index of the record with the given ID
    int index = -1;
    for (int i=0; i<num_records; i++) {
        if (records[i].id == id) {
            index = i;
            break;
        }
    }

    // If the record was not found, print an error message and return
    if (index == -1) {
        printf("Error: Record with ID %d not found\n", id);
        return;
    }

    // If the record was found, shift all subsequent records one position to the left
    for (int i=index; i<num_records-1; i++) {
        records[i] = records[i+1];
    }

    // Update the number of records
    num_records--;
}

// Function to print all records in the array
void print_records() {
    printf("ID\tName\tAge\n");
    for (int i=0; i<num_records; i++) {
        printf("%d\t%s\t%d\n", records[i].id, records[i].name, records[i].age);
    }
}

// Main function to simulate database operations
int main() {
    // Add some initial records to the array
    add_record(1, "John Doe", 25);
    add_record(2, "Jane Smith", 30);
    add_record(3, "Bob Johnson", 45);

    // Print the initial records
    printf("Initial records:\n");
    print_records();

    // Add a new record
    add_record(4, "Alice Brown", 20);

    // Print all records again
    printf("All records after adding a new one:\n");
    print_records();

    // Delete a record
    delete_record(2);

    // Print all records again
    printf("All records after deleting record with ID 2:\n");
    print_records();

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall add_record(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall delete_record(_QWORD); // weak
__int64 print_records(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000185F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  add_record(1i64, "John Doe", 25i64);
  add_record(2i64, "Jane Smith", 30i64);
  add_record(3i64, "Bob Johnson", 45i64);
  printf("Initial records:\n");
  print_records();
  add_record(4i64, "Alice Brown", 20i64);
  printf("All records after adding a new one:\n");
  print_records();
  delete_record(2i64);
  printf("All records after deleting record with ID 2:\n");
  print_records();
  return 0;
}
// 140001591: using guessed type __int64 __fastcall add_record(_QWORD, _QWORD, _QWORD);
// 140001674: using guessed type __int64 __fastcall delete_record(_QWORD);
// 1400017AC: using guessed type __int64 print_records(void);
// 1400019E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sentiment analysis tool ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#define MAX_STRING_LENGTH 100

// Function to remove punctuation marks from a string
char* remove_punctuation(char *str) {
    int i, j;
    char *new_str = (char*) malloc(strlen(str) + 1);
    for(i = 0, j = 0; str[i]; i++) {
        if(!ispunct(str[i]) || str[i] == '\'') {
            new_str[j++] = str[i];
        }
    }
    new_str[j] = '\0';
    return new_str;
}

// Function to convert all characters in a string to lowercase
char* to_lower_case(char *str) {
    int i;
    char *new_str = (char*) malloc(strlen(str) + 1);
    for(i = 0; str[i]; i++) {
        new_str[i] = tolower(str[i]);
    }
    new_str[i] = '\0';
    return new_str;
}

// Function to calculate the sentiment score of a given word
int get_score(char *word) {
    int score = 0;
    if(strcmp(word, "good") == 0 || strcmp(word, "great") == 0 || strcmp(word, "excellent") == 0) {
        score = 2;
    } else if(strcmp(word, "bad") == 0 || strcmp(word, "terrible") == 0 || strcmp(word, "horrible") == 0) {
        score = -2;
    } else if(strcmp(word, "okay") == 0) {
        score = 0;
    } else {
        score = 1;
    }
    return score;
}

// Function to calculate the overall sentiment score of a given sentence
int get_sentiment_score(char *sentence) {
    int score = 0;
    char *token;
    char *delim = " ";
    char *new_sentence = remove_punctuation(sentence);
    char *lower_case_sentence = to_lower_case(new_sentence);
    token = strtok(lower_case_sentence, delim);
    while(token != NULL) {
        score += get_score(token);
        token = strtok(NULL, delim);
    }
    free(new_sentence);
    free(lower_case_sentence);
    return score;
}

int main() {
    char input_string[MAX_STRING_LENGTH];
    printf("Enter a sentence: ");
    fgets(input_string, MAX_STRING_LENGTH, stdin);
    input_string[strcspn(input_string, "\n")] = '\0'; // Remove trailing newline character
    int sentiment_score = get_sentiment_score(input_string);
    printf("The sentiment score of the sentence is %d\n", sentiment_score);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall get_sentiment_score(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000185F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[108]; // [rsp+20h] [rbp-70h] BYREF
  unsigned int sentiment_score; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter a sentence: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  sentiment_score = get_sentiment_score(Buffer);
  printf("The sentiment score of the sentence is %d\n", sentiment_score);
  return 0;
}
// 1400017C2: using guessed type __int64 __fastcall get_sentiment_score(_QWORD);
// 1400019A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000185F: using guessed type char Buffer[108];

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: ultraprecise
#include <stdio.h>

int main() {
    int array[5] = { 5, 3, 2, 4, 1 };
    int i, j, temp, pass = 0;
    
    printf("Unsorted Array: ");
    for(i = 0; i < 5; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");

    for(i = 0; i < 4; i++) {
        for(j = i + 1; j < 5; j++) {
             if (array[i] > array[j]) {
                 temp = array[i];
                 array[i] = array[j];
                 array[j] = temp;
             }
        }
        printf("Pass %d: ", pass + 1);
        for(j = 0; j < 5; j++) {
            printf("%d ", array[j]);
        }
        printf("\n");
        pass++;
    }

    printf("Sorted Array: ");
    for(i = 0; i < 5; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[8]; // [rsp+20h] [rbp-30h]
  int v5; // [rsp+40h] [rbp-10h]
  int v6; // [rsp+44h] [rbp-Ch]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 5;
  v4[1] = 3;
  v4[2] = 2;
  v4[3] = 4;
  v4[4] = 1;
  v6 = 0;
  printf("Unsorted Array: ");
  for ( i = 0; i <= 4; ++i )
    printf("%d ", (unsigned int)v4[i]);
  printf("\n");
  for ( i = 0; i <= 3; ++i )
  {
    for ( j = i + 1; j <= 4; ++j )
    {
      if ( v4[i] > v4[j] )
      {
        v5 = v4[i];
        v4[i] = v4[j];
        v4[j] = v5;
      }
    }
    printf("Pass %d: ", (unsigned int)(v6 + 1));
    for ( j = 0; j <= 4; ++j )
      printf("%d ", (unsigned int)v4[j]);
    printf("\n");
    ++v6;
  }
  printf("Sorted Array: ");
  for ( i = 0; i <= 4; ++i )
    printf("%d ", (unsigned int)v4[i]);
  printf("\n");
  return 0;
}
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Defining the struct for each XML tag/element
typedef struct xml_element {
    char name[50];
    char value[100];
    struct xml_element *first_child;
    struct xml_element *next_sibling;
} xml_element;

// A recursive function to parse through the XML input and create a tree of xml_elements
xml_element* parse_xml(char* xml_input) {
    // Initializing variables
    xml_element *root = NULL;
    xml_element *current_element = NULL;
    xml_element *prev_sibling = NULL;
    bool inside_tag = false;
    bool inside_value = false;
    char tag_name[50] = { 0 };
    char value[100] = { 0 };

    // Looping through each character in the XML input string
    for (int i = 0; i < strlen(xml_input); i++) {
        // If we encounter an opening tag character '<', set inside_tag true
        if (xml_input[i] == '<') {
            inside_tag = true;
            continue;
        }
        // If we encounter a closing tag character '>', set inside_tag false and inside_value true
        else if (xml_input[i] == '>') {
            inside_tag = false;
            inside_value = true;
            // If this is a closing tag, set prev_sibling to current_element
            if (tag_name[0] == '/') {
                prev_sibling = current_element;
                current_element = current_element->first_child;
            }
            // Else this is an opening tag, so create a new xml_element and set current_element as its child
            else {
                xml_element *new_element = malloc(sizeof(xml_element));
                strcpy(new_element->name, tag_name);
                // If this is the root element, store it in root
                if (root == NULL) {
                    root = new_element;
                    current_element = root;
                }
                // Else set current_element's first child as this new_element
                else {
                    current_element->first_child = new_element;
                    current_element = new_element;
                }
            }
            // Reset tag_name and value for the next element
            memset(tag_name, 0, sizeof(tag_name));
            memset(value, 0, sizeof(value));
            continue;
        }
        // If we are inside a tag, append the character to tag_name
        else if (inside_tag) {
            strncat(tag_name, &xml_input[i], 1);
        }
        // If we are inside a value, append the character to value
        else if (inside_value) {
            strncat(value, &xml_input[i], 1);
            // If we encounter a closing tag character '<', store the value in current_element and set inside_value false
            if (i < strlen(xml_input) - 1 && xml_input[i + 1] == '<') {
                strcpy(current_element->value, value);
                inside_value = false;
            }
        }
        // If we encounter a closing tag '/', set current_element as its parent's next sibling
        else if (xml_input[i] == '/') {
            current_element = prev_sibling->next_sibling;
        }
    }
    return root;
}

// A function to print the xml_element tree in a formatted manner
void print_xml(xml_element *root, int depth) {
    // If the input root is NULL, return
    if (root == NULL) {
        return;
    }
    // Print the current element's name and value, with appropriate indentation
    for (int i = 0; i < depth; i++) {
        printf("  ");
    }
    printf("<%s>%s\n", root->name, root->value);
    // Recursively print the children of this element
    print_xml(root->first_child, depth + 1);
    // If there are any siblings, recursively print them as well
    if (root->next_sibling != NULL) {
        print_xml(root->next_sibling, depth);
    }
    // Print the closing tag with appropriate indentation
    for (int i = 0; i < depth; i++) {
        printf("  ");
    }
    printf("</%s>\n", root->name);
}

// Example usage
int main() {
    char xml_input[] = "<bookstore><book><title>Harry Potter</title><author>J.K. Rowling</author><year>2005</year></book><book><title>The Hobbit</title><author>J.R.R. Tolkien</author><year>1937</year></book></bookstore>";

    xml_element *root = parse_xml(xml_input);
    print_xml(root, 0);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall parse_xml(_QWORD); // weak
__int64 __fastcall print_xml(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000193B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[200]; // [rsp+20h] [rbp-D0h] BYREF
  __int64 v5; // [rsp+E8h] [rbp-8h]

  _main(argc, argv, envp);
  strcpy(
    v4,
    "<bookstore><book><title>Harry Potter</title><author>J.K. Rowling</author><year>2005</year></book><book><title>The Ho"
    "bbit</title><author>J.R.R. Tolkien</author><year>1937</year></book></bookstore>");
  v5 = parse_xml(v4);
  print_xml(v5, 0i64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall parse_xml(_QWORD);
// 14000185A: using guessed type __int64 __fastcall print_xml(_QWORD, _QWORD);
// 140001BB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct record {
    char name[50];
    int age;
    float salary;
};

int main() {
    struct record r;
    char filename[50];
    printf("Enter file name to create: ");
    scanf("%s", filename);
    FILE *fp = fopen(filename, "w+");
    if(fp == NULL) {
        printf("Error creating file.\n");
        exit(1);
    }
    int choice;
    do {
        printf("\n1. Add record\n2. Search record\n3. Display all records\n4. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch(choice) {
            case 1: {
                printf("Enter name: ");
                scanf("%s", r.name);
                printf("Enter age: ");
                scanf("%d", &r.age);
                printf("Enter salary: ");
                scanf("%f", &r.salary);
                fwrite(&r, sizeof(struct record), 1, fp);
                printf("Record added successfully.\n");
                break;
            }
            case 2: {
                char search_name[50];
                printf("Enter name to search: ");
                scanf("%s", search_name);
                int found = 0;
                while(fread(&r, sizeof(struct record), 1, fp)) {
                    if(strcmp(r.name, search_name) == 0) {
                        printf("Record found:\n");
                        printf("Name: %s\nAge: %d\nSalary: %f\n", r.name, r.age, r.salary);
                        found = 1;
                        break;
                    }
                }
                if(!found) {
                    printf("No record found with name %s.\n", search_name);
                }
                break;
            }
            case 3: {
                rewind(fp);
                while(fread(&r, sizeof(struct record), 1, fp)) {
                    printf("Name: %s\nAge: %d\nSalary: %f\n", r.name, r.age, r.salary);
                }
                break;
            }
            case 4: {
                printf("Exiting...\n");
                break;
            }
            default: {
                printf("Invalid choice.\n");
                break;
            }
        }
    } while(choice != 4);
    fclose(fp);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl rewind(FILE *Stream);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str2[60]; // [rsp+20h] [rbp-D0h] BYREF
  int v5; // [rsp+5Ch] [rbp-94h] BYREF
  char FileName[64]; // [rsp+60h] [rbp-90h] BYREF
  char Buffer[52]; // [rsp+A0h] [rbp-50h] BYREF
  unsigned int v8; // [rsp+D4h] [rbp-1Ch] BYREF
  float v9; // [rsp+D8h] [rbp-18h] BYREF
  FILE *Stream; // [rsp+E0h] [rbp-10h]
  int v11; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter file name to create: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "w+");
  if ( !Stream )
  {
    printf("Error creating file.\n");
    exit(1);
  }
  do
  {
    printf("\n1. Add record\n2. Search record\n3. Display all records\n4. Exit\n");
    printf("Enter choice: ");
    scanf("%d", &v5);
    if ( v5 == 4 )
    {
      printf("Exiting...\n");
      continue;
    }
    if ( v5 > 4 )
    {
LABEL_21:
      printf("Invalid choice.\n");
      continue;
    }
    switch ( v5 )
    {
      case 3:
        rewind(Stream);
        while ( fread(Buffer, 0x3Cui64, 1ui64, Stream) )
          printf("Name: %s\nAge: %d\nSalary: %f\n", Buffer, v8, v9);
        break;
      case 1:
        printf("Enter name: ");
        scanf("%s", Buffer);
        printf("Enter age: ");
        scanf("%d", &v8);
        printf("Enter salary: ");
        scanf("%f", &v9);
        fwrite(Buffer, 0x3Cui64, 1ui64, Stream);
        printf("Record added successfully.\n");
        break;
      case 2:
        printf("Enter name to search: ");
        scanf("%s", Str2);
        v11 = 0;
        while ( fread(Buffer, 0x3Cui64, 1ui64, Stream) )
        {
          if ( !strcmp(Buffer, Str2) )
          {
            printf("Record found:\n");
            printf("Name: %s\nAge: %d\nSalary: %f\n", Buffer, v8, v9);
            v11 = 1;
            break;
          }
        }
        if ( !v11 )
          printf("No record found with name %s.\n", Str2);
        break;
      default:
        goto LABEL_21;
    }
  }
  while ( v5 != 4 );
  fclose(Stream);
  return 0;
}
// 1400016AF: conditional instruction was optimized away because %var_94.4<3
// 1400019D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedural Space Adventure ; Style: mathematical
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int level = 1;
    int health = 100;
    int energy = 100;
    int inventory[3] = {0};
    
    srand(time(NULL));
    
    printf("Welcome to Procedural Space Adventure!\n");
    printf("You are a space explorer on a mission to discover new planets.\n");
    
    while (level <= 5 && health > 0 && energy > 0)
    {
        printf("Level %d\n", level);
        printf("Health: %d\n", health);
        printf("Energy: %d\n", energy);
        printf("Inventory: [%d, %d, %d]\n", inventory[0], inventory[1], inventory[2]);
        printf("Choose your action:\n");
        printf("1. Explore planet\n");
        printf("2. Rest and recharge\n");
        printf("3. Check inventory\n");
        int choice;
        scanf("%d", &choice);
        switch (choice)
        {
            case 1:
                printf("You land on a new planet...\n");
                int n = rand() % 3;
                if (n == 0)
                {
                    printf("You find a strange artifact!\n");
                    inventory[0]++;
                }
                else if (n == 1)
                {
                    printf("You encounter hostile alien life forms!\n");
                    health -= 20;
                }
                else
                {
                    printf("You find a mineral deposit!\n");
                    inventory[1]++;
                }
                energy -= 10;
                break;
            case 2:
                printf("You rest and recharge your energy...\n");
                energy += 50;
                health += 10;
                break;
            case 3:
                printf("You check your inventory...\n");
                printf("Artifacts: %d\n", inventory[0]);
                printf("Minerals: %d\n", inventory[1]);
                printf("Food: %d\n", inventory[2]);
                break;
            default:
                printf("Invalid choice.\n");
        }
        level++;
    }
    
    if (health <= 0 || energy <= 0)
    {
        printf("Game over.\n");
    }
    else
    {
        printf("Congratulations! You completed your space mission.\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+20h] [rbp-20h] BYREF
  __int64 v6; // [rsp+24h] [rbp-1Ch]
  unsigned int v7; // [rsp+2Ch] [rbp-14h]
  int v8; // [rsp+30h] [rbp-10h]
  int v9; // [rsp+34h] [rbp-Ch]
  int v10; // [rsp+38h] [rbp-8h]
  unsigned int v11; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v11 = 1;
  v10 = 100;
  v9 = 100;
  v6 = 0i64;
  v7 = 0;
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to Procedural Space Adventure!\n");
  printf("You are a space explorer on a mission to discover new planets.\n");
  while ( (int)v11 <= 5 && v10 > 0 && v9 > 0 )
  {
    printf("Level %d\n", v11);
    printf("Health: %d\n", (unsigned int)v10);
    printf("Energy: %d\n", (unsigned int)v9);
    printf("Inventory: [%d, %d, %d]\n", (unsigned int)v6, HIDWORD(v6), v7);
    printf("Choose your action:\n");
    printf("1. Explore planet\n");
    printf("2. Rest and recharge\n");
    printf("3. Check inventory\n");
    scanf("%d", &v5);
    if ( v5 == 3 )
    {
      printf("You check your inventory...\n");
      printf("Artifacts: %d\n", (unsigned int)v6);
      printf("Minerals: %d\n", HIDWORD(v6));
      printf("Food: %d\n", v7);
      goto LABEL_16;
    }
    if ( v5 > 3 )
      goto LABEL_15;
    if ( v5 != 1 )
    {
      if ( v5 == 2 )
      {
        printf("You rest and recharge your energy...\n");
        v9 += 50;
        v10 += 10;
        goto LABEL_16;
      }
LABEL_15:
      printf("Invalid choice.\n");
      goto LABEL_16;
    }
    printf("You land on a new planet...\n");
    v8 = rand() % 3;
    if ( v8 )
    {
      if ( v8 == 1 )
      {
        printf("You encounter hostile alien life forms!\n");
        v10 -= 20;
      }
      else
      {
        printf("You find a mineral deposit!\n");
        ++HIDWORD(v6);
      }
    }
    else
    {
      printf("You find a strange artifact!\n");
      LODWORD(v6) = v6 + 1;
    }
    v9 -= 10;
LABEL_16:
    ++v11;
  }
  if ( v10 > 0 && v9 > 0 )
    printf("Congratulations! You completed your space mission.\n");
  else
    printf("Game over.\n");
  return 0;
}
// 140001950: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Rogue-like Game with Procedural Generation ; Style: Ada Lovelace
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAP_SIZE 20
#define MAX_ROOMS 5
#define MAX_ROOM_SIZE 6

typedef struct {
    int x;
    int y;
    int width;
    int height;
} Room;

// Function prototypes
void generate_map(char map[][MAP_SIZE]);
void print_map(char map[][MAP_SIZE]);
void add_room(Room* rooms, int* num_rooms);
int is_room_valid(Room* room, Room rooms[], int num_rooms);
void connect_rooms(Room* rooms, int num_rooms, char map[][MAP_SIZE]);

int main() {
    char map[MAP_SIZE][MAP_SIZE];
    srand(time(NULL));  // Initialize random seed
    generate_map(map);
    print_map(map);
    return 0;
}

void generate_map(char map[][MAP_SIZE]) {
    int x, y, i, j;
    Room rooms[MAX_ROOMS];
    int num_rooms = 0;
    // Initialize map to be all walls
    for (i = 0; i < MAP_SIZE; i++) {
        for (j = 0; j < MAP_SIZE; j++) {
            map[i][j] = '#';
        }
    }
    // Generate rooms
    while (num_rooms < MAX_ROOMS) {
        add_room(&rooms[num_rooms], &num_rooms);
    }
    // Connect rooms with hallways
    connect_rooms(rooms, num_rooms, map);
    // Place player at a random location
    x = rand() % MAP_SIZE;
    y = rand() % MAP_SIZE;
    map[y][x] = '@';
}

void print_map(char map[][MAP_SIZE]) {
    int i, j;
    for (i = 0; i < MAP_SIZE; i++) {
        for (j = 0; j < MAP_SIZE; j++) {
            printf("%c ", map[i][j]);
        }
        printf("\n");
    }
}

void add_room(Room* rooms, int* num_rooms) {
    int x, y, width, height;
    // Generate random room dimensions
    width = rand() % MAX_ROOM_SIZE + 2;
    height = rand() % MAX_ROOM_SIZE + 2;
    // Generate random room position
    x = rand() % (MAP_SIZE - width - 1) + 1;
    y = rand() % (MAP_SIZE - height - 1) + 1;
    rooms->x = x;
    rooms->y = y;
    rooms->width = width;
    rooms->height = height;
    if (is_room_valid(rooms, rooms - *num_rooms, *num_rooms)) {
        (*num_rooms)++;
    }
}

int is_room_valid(Room* room, Room rooms[], int num_rooms) {
    int i;
    // Check if room overlaps with other rooms
    for (i = 0; i < num_rooms; i++) {
        if (room->x < rooms[i].x + rooms[i].width &&
            room->x + room->width > rooms[i].x &&
            room->y < rooms[i].y + rooms[i].height &&
            room->y + room->height > rooms[i].y) {
            return 0;
        }
    }
    // If room is valid, add it to the array of rooms
    for (i = room->y; i < room->y + room->height; i++) {
        int j;
        for (j = room->x; j < room->x + room->width; j++) {
            // Place room walls at the edges of the room
            if (i == room->y || i == room->y + room->height - 1 ||
                j == room->x || j == room->x + room->width - 1) {
                rooms[num_rooms].x = j;
                rooms[num_rooms].y = i;
                rooms[num_rooms].width = 1;
                rooms[num_rooms].height = 1;
                num_rooms++;
            }
        }
    }
    // All good
    return 1;
}

void connect_rooms(Room* rooms, int num_rooms, char map[][MAP_SIZE]) {
    int i, j;
    // Create a hallway between each adjacent room
    for (i = 1; i < num_rooms; i++) {
        int x1 = rooms[i - 1].x + rooms[i - 1].width / 2;
        int y1 = rooms[i - 1].y + rooms[i - 1].height / 2;
        int x2 = rooms[i].x + rooms[i].width / 2;
        int y2 = rooms[i].y + rooms[i].height / 2;
        // Generate horizontal hallway
        if (rand() % 2 == 0) {
            for (j = x1; j != x2; j += x2 > x1 ? 1 : -1) {
                map[y1][j] = '.';
            }
            for (j = y1; j != y2; j += y2 > y1 ? 1 : -1) {
                map[j][x2] = '.';
            }
        }
        // Generate vertical hallway
        else {
            for (j = y1; j != y2; j += y2 > y1 ? 1 : -1) {
                map[j][x1] = '.';
            }
            for (j = x1; j != x2; j += x2 > x1 ? 1 : -1) {
                map[y2][j] = '.';
            }
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall generate_map(_QWORD); // weak
__int64 __fastcall print_map(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[400]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  generate_map(v5);
  print_map(v5);
  return 0;
}
// 1400015FC: using guessed type __int64 __fastcall generate_map(_QWORD);
// 140001732: using guessed type __int64 __fastcall print_map(_QWORD);
// 140001E10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database simulation ; Style: mathematical
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_RECORDS 100

// Define the structure of a database record
struct Record {
    int id;
    char name[20];
    int age;
    float gpa;
};

// Define the structure of the database
struct Database {
    struct Record records[MAX_RECORDS];
    int num_records;
};

// Function declarations
void initialize_database(struct Database *);
void add_record(struct Database *, struct Record);
void delete_record(struct Database *, int);
void print_database(struct Database);
int search_database(struct Database, int);
void sort_database(struct Database *);

// Main function
int main() {
    // Initialize the database
    struct Database db;
    initialize_database(&db);

    // Add some test records
    struct Record r1 = {1, "Alice", 20, 3.5};
    struct Record r2 = {2, "Bob", 21, 3.7};
    struct Record r3 = {3, "Charlie", 19, 3.9};
    add_record(&db, r1);
    add_record(&db, r2);
    add_record(&db, r3);

    // Print the database
    printf("Initial database:\n");
    print_database(db);

    // Search for a record by ID
    int id_to_search = 2;
    int index = search_database(db, id_to_search);
    if (index != -1) {
        printf("Found record with ID %d:\n", id_to_search);
        printf("Name: %s\n", db.records[index].name);
        printf("Age: %d\n", db.records[index].age);
        printf("GPA: %.2f\n", db.records[index].gpa);
    }
    else {
        printf("Record with ID %d not found.\n", id_to_search);
    }

    // Sort the database by ID
    sort_database(&db);
    printf("Sorted database:\n");
    print_database(db);

    // Delete a record by ID
    int id_to_delete = 1;
    delete_record(&db, id_to_delete);
    printf("After deleting record with ID %d:\n", id_to_delete);
    print_database(db);

    return 0;
}

// Initialize the database
void initialize_database(struct Database *db) {
    db->num_records = 0;
}

// Add a record to the database
void add_record(struct Database *db, struct Record r) {
    db->records[db->num_records] = r;
    db->num_records++;
}

// Delete a record from the database
void delete_record(struct Database *db, int id) {
    int index = search_database(*db, id);
    if (index != -1) {
        for (int i = index; i < db->num_records - 1; i++) {
            db->records[i] = db->records[i+1];
        }
        db->num_records--;
    }
}

// Print the contents of the database
void print_database(struct Database db) {
    for (int i = 0; i < db.num_records; i++) {
        printf("Record %d:\n", i+1);
        printf("ID: %d\n", db.records[i].id);
        printf("Name: %s\n", db.records[i].name);
        printf("Age: %d\n", db.records[i].age);
        printf("GPA: %.2f\n", db.records[i].gpa);
    }
}

// Search for a record by ID
int search_database(struct Database db, int id) {
    for (int i = 0; i < db.num_records; i++) {
        if (db.records[i].id == id) {
            return i;
        }
    }
    return -1;
}

// Sort the database by ID
void sort_database(struct Database *db) {
    for (int i = 0; i < db->num_records - 1; i++) {
        for (int j = i + 1; j < db->num_records; j++) {
            if (db->records[i].id > db->records[j].id) {
                struct Record temp = db->records[i];
                db->records[i] = db->records[j];
                db->records[j] = temp;
            }
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall initialize_database(_QWORD); // weak
__int64 __fastcall add_record(_QWORD, _QWORD); // weak
__int64 __fastcall delete_record(_QWORD, _QWORD); // weak
__int64 __fastcall print_database(_QWORD); // weak
__int64 __fastcall search_database(_QWORD, _QWORD); // weak
__int64 __fastcall sort_database(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[3200]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+CA0h] [rbp+C20h]
  __int64 v6; // [rsp+CB0h] [rbp+C30h] BYREF
  __int128 v7; // [rsp+CB8h] [rbp+C38h]
  __int64 v8; // [rsp+CC8h] [rbp+C48h]
  _QWORD v9[3]; // [rsp+CD0h] [rbp+C50h]
  __int64 v10; // [rsp+CE8h] [rbp+C68h]
  _QWORD v11[3]; // [rsp+CF0h] [rbp+C70h]
  __int64 v12; // [rsp+D08h] [rbp+C88h]
  _QWORD v13[4]; // [rsp+D10h] [rbp+C90h]
  _OWORD v14[200]; // [rsp+D30h] [rbp+CB0h] BYREF
  int v15; // [rsp+19B0h] [rbp+1930h]
  unsigned int v16; // [rsp+19B4h] [rbp+1934h]
  int v17; // [rsp+19B8h] [rbp+1938h]
  unsigned int v18; // [rsp+19BCh] [rbp+193Ch]

  _main(argc, argv, envp);
  initialize_database(v14);
  LODWORD(v13[0]) = 1;
  *(_OWORD *)((char *)v13 + 4) = 0x6563696C41ui64;
  HIDWORD(v13[2]) = 0;
  v13[3] = 0x4060000000000014i64;
  LODWORD(v11[0]) = 2;
  *(_OWORD *)((char *)v11 + 4) = 0x626F42ui64;
  HIDWORD(v11[2]) = 0;
  v12 = 0x406CCCCD00000015i64;
  LODWORD(v9[0]) = 3;
  *(_OWORD *)((char *)v9 + 4) = 0x65696C72616843ui64;
  HIDWORD(v9[2]) = 0;
  v10 = 0x4079999A00000013i64;
  v6 = v13[0];
  v7 = *(_OWORD *)&v13[1];
  v8 = 0x4060000000000014i64;
  add_record(v14, &v6);
  v6 = v11[0];
  v7 = *(_OWORD *)&v11[1];
  v8 = v12;
  add_record(v14, &v6);
  v6 = v9[0];
  v7 = *(_OWORD *)&v9[1];
  v8 = v10;
  add_record(v14, &v6);
  printf("Initial database:\n");
  qmemcpy(v4, v14, sizeof(v4));
  v5 = v15;
  print_database(v4);
  v18 = 2;
  qmemcpy(v4, v14, sizeof(v4));
  v5 = v15;
  v17 = search_database(v4, 2i64);
  if ( v17 == -1 )
  {
    printf("Record with ID %d not found.\n", v18);
  }
  else
  {
    printf("Found record with ID %d:\n", v18);
    printf("Name: %s\n", (const char *)&v14[2 * v17] + 4);
    printf("Age: %d\n", *(unsigned int *)&v4[32 * v17 + 3368]);
    printf("GPA: %.2f\n", *(float *)&v4[32 * v17 + 3372]);
  }
  sort_database(v14);
  printf("Sorted database:\n");
  qmemcpy(v4, v14, sizeof(v4));
  v5 = v15;
  print_database(v4);
  v16 = 1;
  delete_record(v14, 1i64);
  printf("After deleting record with ID %d:\n", v16);
  qmemcpy(v4, v14, sizeof(v4));
  v5 = v15;
  print_database(v4);
  return 0;
}
// 1400019A5: using guessed type __int64 __fastcall initialize_database(_QWORD);
// 1400019BE: using guessed type __int64 __fastcall add_record(_QWORD, _QWORD);
// 140001A1C: using guessed type __int64 __fastcall delete_record(_QWORD, _QWORD);
// 140001B27: using guessed type __int64 __fastcall print_database(_QWORD);
// 140001C13: using guessed type __int64 __fastcall search_database(_QWORD, _QWORD);
// 140001C60: using guessed type __int64 __fastcall sort_database(_QWORD);
// 140001E40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature monitor ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// function to generate random temperature for each sensor
float generateTemp() {
    float temp = (float)rand()/(float)(RAND_MAX/100);
    return temp;
}

// data structure to hold information about each temperature sensor
struct Sensor {
    char name[50];
    float temperature;
    char location[50];
    int status; // 1 - Active, 0 - Inactive
};

// function to print details of each sensor
void printSensorDetails(struct Sensor sensor) {
    printf("Sensor Name: %s\n", sensor.name);
    printf("Temperature: %.2f\n", sensor.temperature);
    printf("Location: %s\n", sensor.location);
    printf("Status: %s\n", (sensor.status == 1) ? "Active" : "Inactive");
}

int main() {
    // array to hold all the temperature sensors
    struct Sensor sensors[5];
    
    // initialize values for each sensor
    sprintf(sensors[0].name, "Sensor 1");
    sensors[0].temperature = generateTemp();
    sprintf(sensors[0].location, "Room A");
    sensors[0].status = 1;
    
    sprintf(sensors[1].name, "Sensor 2");
    sensors[1].temperature = generateTemp();
    sprintf(sensors[1].location, "Room B");
    sensors[1].status = 1;
    
    sprintf(sensors[2].name, "Sensor 3");
    sensors[2].temperature = generateTemp();
    sprintf(sensors[2].location, "Room A");
    sensors[2].status = 0;
    
    sprintf(sensors[3].name, "Sensor 4");
    sensors[3].temperature = generateTemp();
    sprintf(sensors[3].location, "Room C");
    sensors[3].status = 1;
    
    sprintf(sensors[4].name, "Sensor 5");
    sensors[4].temperature = generateTemp();
    sprintf(sensors[4].location, "Room B");
    sensors[4].status = 0;
    
    // printing details of each sensor
    for(int i = 0; i < 5; i++) {
        printSensorDetails(sensors[i]);
        printf("\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
double generateTemp(void); // weak
__int64 __fastcall printSensorDetails(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001699) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  __int64 *v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rbx
  __int64 v10; // rbx
  __int64 v11; // rdx
  __int64 v13[12]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v14[2]; // [rsp+80h] [rbp+0h] BYREF
  char Buffer[52]; // [rsp+90h] [rbp+10h] BYREF
  int v16; // [rsp+C4h] [rbp+44h]
  char v17[52]; // [rsp+C8h] [rbp+48h] BYREF
  int v18; // [rsp+FCh] [rbp+7Ch]
  char v19[52]; // [rsp+100h] [rbp+80h] BYREF
  int v20; // [rsp+134h] [rbp+B4h]
  char v21[52]; // [rsp+138h] [rbp+B8h] BYREF
  int v22; // [rsp+16Ch] [rbp+ECh]
  char v23[52]; // [rsp+170h] [rbp+F0h] BYREF
  int v24; // [rsp+1A4h] [rbp+124h]
  char v25[52]; // [rsp+1A8h] [rbp+128h] BYREF
  int v26; // [rsp+1DCh] [rbp+15Ch]
  char v27[52]; // [rsp+1E0h] [rbp+160h] BYREF
  int v28; // [rsp+214h] [rbp+194h]
  char v29[52]; // [rsp+218h] [rbp+198h] BYREF
  int v30; // [rsp+24Ch] [rbp+1CCh]
  char v31[52]; // [rsp+250h] [rbp+1D0h] BYREF
  int v32; // [rsp+284h] [rbp+204h]
  char v33[52]; // [rsp+288h] [rbp+208h] BYREF
  int v34; // [rsp+2BCh] [rbp+23Ch]
  int i; // [rsp+2CCh] [rbp+24Ch]

  _main(argc, argv, envp);
  sprintf(Buffer, "Sensor 1");
  *(double *)v3.m128i_i64 = generateTemp();
  v16 = _mm_cvtsi128_si32(v3);
  sprintf(v17, "Room A");
  v18 = 1;
  sprintf(v19, "Sensor 2");
  *(double *)v3.m128i_i64 = generateTemp();
  v20 = _mm_cvtsi128_si32(v3);
  sprintf(v21, "Room B");
  v22 = 1;
  sprintf(v23, "Sensor 3");
  *(double *)v3.m128i_i64 = generateTemp();
  v24 = _mm_cvtsi128_si32(v3);
  sprintf(v25, "Room A");
  v26 = 0;
  sprintf(v27, "Sensor 4");
  *(double *)v3.m128i_i64 = generateTemp();
  v28 = _mm_cvtsi128_si32(v3);
  sprintf(v29, "Room C");
  v30 = 1;
  sprintf(v31, "Sensor 5");
  *(double *)v3.m128i_i64 = generateTemp();
  v32 = _mm_cvtsi128_si32(v3);
  sprintf(v33, "Room B");
  v34 = 0;
  for ( i = 0; i <= 4; ++i )
  {
    v4 = &v14[14 * i + 2];
    v5 = v4[1];
    v13[0] = *v4;
    v13[1] = v5;
    v6 = v4[3];
    v13[2] = v4[2];
    v13[3] = v6;
    v7 = v4[5];
    v13[4] = v4[4];
    v13[5] = v7;
    v8 = v4[7];
    v13[6] = v4[6];
    v13[7] = v8;
    v9 = v4[9];
    v13[8] = v4[8];
    v13[9] = v9;
    v10 = v4[11];
    v13[10] = v4[10];
    v13[11] = v10;
    v11 = v4[13];
    v14[0] = v4[12];
    v14[1] = v11;
    printSensorDetails(v13);
    printf("\n");
  }
  return 0;
}
// 1400016C7: variable 'v3' is possibly undefined
// 1400015D4: using guessed type double generateTemp(void);
// 140001605: using guessed type __int64 __fastcall printSensorDetails(_QWORD);
// 1400019B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001699: using guessed type char Buffer[52];
// 140001699: using guessed type char anonymous_0[52];
// 140001699: using guessed type char anonymous_1[52];
// 140001699: using guessed type char anonymous_2[52];
// 140001699: using guessed type char anonymous_3[52];
// 140001699: using guessed type char anonymous_4[52];
// 140001699: using guessed type char anonymous_5[52];
// 140001699: using guessed type char anonymous_6[52];
// 140001699: using guessed type char anonymous_7[52];
// 140001699: using guessed type char anonymous_8[52];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue Implementation ; Style: excited
#include<stdio.h>
#include<stdlib.h>
#define MAX_SIZE 5
int queue[MAX_SIZE], front=-1, rear=-1;

void enqueue(int value){
    if ((front == 0 && rear == MAX_SIZE-1) || rear == front-1){
        printf("\nQueue Overflow!!!");
        return;
    }
    if (front == -1){
        front = rear = 0;
        queue[rear] = value;
    }
    else if(rear == MAX_SIZE-1 && front != 0){
        rear = 0;
        queue[rear] = value;
    }
    else{
        rear++;
        queue[rear] = value;
    }
    printf("%d added to the queue.\n", value);
}

int dequeue(){
    int value;
    if (front == -1){
        printf("\nQueue Underflow!!!");
        return -1;
    }  
    value = queue[front];
    if(front == rear){
        front = -1;
        rear = -1;
    }
    else if(front == MAX_SIZE-1)
        front = 0;
    else
        front++;
    printf("%d removed from the queue.\n", value);
    return value;
}

void display(){
    int i;
    if (front == -1)
        printf("\nQueue is empty!!!");
    else{
        printf("\nThe queue is:");
        if (rear >= front){
            for(i=front;i<=rear;i++)
                printf("%d ",queue[i]);
        }
        else{
            for(i=front;i<MAX_SIZE;i++)
                printf("%d ", queue[i]);
            for(i=0;i<=rear;i++)
                printf("%d ",queue[i]);
        }
    }
}

int main(){
    int ch, value;
    printf("-----Queue Implementation using C-----\n");
    do{
        printf("\n\nChoose:\n1.Enqueue\n2.Dequeue\n3.Display\n0.Exit\nChoice:");
        scanf("%d",&ch);

        switch(ch){
            case 1:
                printf("\nEnter value to be inserted:");
                scanf("%d", &value);
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                display();
                break;
            case 0:
                printf("\nExiting...");
                break;
            default:
                printf("\nInvalid choice!!!");
        }
    }while(ch!=0);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall enqueue(_QWORD); // weak
__int64 dequeue(void); // weak
__int64 display(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018AC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-8h] BYREF
  int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("-----Queue Implementation using C-----\n");
  do
  {
    printf("\n\nChoose:\n1.Enqueue\n2.Dequeue\n3.Display\n0.Exit\nChoice:");
    scanf("%d", &v5);
    if ( v5 == 3 )
    {
      display();
      continue;
    }
    if ( v5 <= 3 )
    {
      switch ( v5 )
      {
        case 2:
          dequeue();
          continue;
        case 0:
          printf("\nExiting...");
          continue;
        case 1:
          printf("\nEnter value to be inserted:");
          scanf("%d", &v4);
          enqueue(v4);
          continue;
      }
    }
    printf("\nInvalid choice!!!");
  }
  while ( v5 );
  return 0;
}
// 140001902: conditional instruction was optimized away because %var_4.4<2
// 1400015E2: using guessed type __int64 __fastcall enqueue(_QWORD);
// 1400016EC: using guessed type __int64 dequeue(void);
// 14000179E: using guessed type __int64 display(void);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Classification system ; Style: minimalist
#include<stdio.h>

int main(){
    // The image contains 4 pixels and each pixel has 3 values representing R,G,B
    int image[4][3]={{255,0,0},{0,255,0},{0,0,255},{255,255,0}};

    // Initialize variables to keep track of the color with the highest value
    int red=0, green=0, blue=0;

    // Loop through each pixel in the image array
    for(int i=0;i<4;i++){
        // Check if the value of R in this pixel is higher than the previous pixels
        if(image[i][0]>red){
            red = image[i][0];
        }

        // Check if the value of G in this pixel is higher than the previous pixels
        if(image[i][1]>green){
            green = image[i][1];
        }

        // Check if the value of B in this pixel is higher than the previous pixels
        if(image[i][2]>blue){
            blue = image[i][2];
        }
    }

    // Determine what color had the highest value and print the result
    if(red>green && red>blue){
        printf("The image is classified as a Red Image");
    }
    else if(green>red && green>blue){
        printf("The image is classified as a Green Image");
    }
    else{
        printf("The image is classified as a Blue Image");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-40h]
  int v5; // [rsp+24h] [rbp-3Ch]
  int v6[10]; // [rsp+28h] [rbp-38h]
  int i; // [rsp+50h] [rbp-10h]
  int v8; // [rsp+54h] [rbp-Ch]
  int v9; // [rsp+58h] [rbp-8h]
  int v10; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4 = 255;
  v5 = 0;
  v6[0] = 0;
  v6[1] = 0;
  v6[2] = 255;
  v6[3] = 0;
  v6[4] = 0;
  v6[5] = 0;
  v6[6] = 255;
  v6[7] = 255;
  v6[8] = 255;
  v6[9] = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  for ( i = 0; i <= 3; ++i )
  {
    if ( v10 < *(&v4 + 3 * i) )
      v10 = *(&v4 + 3 * i);
    if ( v9 < v6[3 * i - 1] )
      v9 = v6[3 * i - 1];
    if ( v8 < v6[3 * i] )
      v8 = v6[3 * i];
  }
  if ( v10 <= v9 || v10 <= v8 )
  {
    if ( v9 <= v10 || v9 <= v8 )
      printf("The image is classified as a Blue Image");
    else
      printf("The image is classified as a Green Image");
  }
  else
  {
    printf("The image is classified as a Red Image");
  }
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Benchmarking ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ARRAY_SIZE 10000

// Function to generate random integer values
int random_number(int min, int max) {
    return (rand() % (max - min + 1) + min);
}

// Function to perform benchmark testing
void benchmark_test(int arr[]) {
    clock_t t_start, t_end;
    int temp;

    // Test Case 1: Sorting the array using Bubble Sort Algorithm
    t_start = clock();
    for (int i = 0; i < ARRAY_SIZE - 1; i++) {
        for (int j = 0; j < ARRAY_SIZE - i - 1; j++) {
            if (arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    t_end = clock();
    printf("Bubble Sort Algorithm: %lf seconds\n", ((double)(t_end - t_start))/CLOCKS_PER_SEC );

    // Test Case 2: Sorting the array using Selection Sort Algorithm
    t_start = clock();
    for (int i = 0; i < ARRAY_SIZE - 1; i++) {
        int min_idx = i;
        for (int j = i+1; j < ARRAY_SIZE; j++) {
            if (arr[j] < arr[min_idx])
                min_idx = j;
        }
        temp = arr[min_idx];
        arr[min_idx] = arr[i];
        arr[i] = temp;
    }
    t_end = clock();
    printf("Selection Sort Algorithm: %lf seconds\n", ((double)(t_end - t_start))/CLOCKS_PER_SEC );

    // Test Case 3: Sorting the array using Merge Sort Algorithm
    t_start = clock();
    void merge(int arr[], int l, int m, int r) {
        int i, j, k;
        int n1 = m - l + 1;
        int n2 = r - m;
        int L[n1], R[n2];
        for (i = 0; i < n1; i++)
            L[i] = arr[l + i];
        for (j = 0; j < n2; j++)
            R[j] = arr[m + 1 + j];
        i = 0;
        j = 0;
        k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            }
            else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
    void merge_sort(int arr[], int l, int r) {
        if (l < r) {
            int m = l+(r-l)/2;
            merge_sort(arr, l, m);
            merge_sort(arr, m+1, r);
            merge(arr, l, m, r);
        }
    }
    merge_sort(arr, 0, ARRAY_SIZE-1);
    t_end = clock();
    printf("Merge Sort Algorithm: %lf seconds\n", ((double)(t_end - t_start))/CLOCKS_PER_SEC );
}

int main(void)
{
    int arr[ARRAY_SIZE];

    // Filling the array with random numbers
    for (int i = 0; i < ARRAY_SIZE; i++)
        arr[i] = random_number(0,1000);

    // Performing Benchmark Testing on Sorting Algorithms
    benchmark_test(arr);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall random_number(_QWORD, _QWORD); // weak
__int64 __fastcall benchmark_test(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001B99) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[10003]; // [rsp+20h] [rbp-60h] BYREF
  int i; // [rsp+9C6Ch] [rbp+9BECh]

  _main(argc, argv, envp);
  for ( i = 0; i <= 9999; ++i )
    v4[i] = random_number(0i64, 1000i64);
  benchmark_test(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall random_number(_QWORD, _QWORD);
// 14000183F: using guessed type __int64 __fastcall benchmark_test(_QWORD);
// 140001CC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001B99: using guessed type int var_9C50[10003];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

#define ROWS 10
#define COLS 20

// Function to check if a cell is valid
bool isValidCell(int row, int col, char maze[ROWS][COLS]) {
    return row >= 0 && row < ROWS && col >= 0 && col < COLS && maze[row][col] == '-';
}

// Function to print the current position of the maze runner
void printMaze(char maze[ROWS][COLS], int row, int col) {
    for(int i = 0; i < ROWS; i++) {
        for(int j = 0; j < COLS; j++) {
            if(i == row && j == col) {
                printf("*");
            } else {
                printf("%c", maze[i][j]);
            }
        }
        printf("\n");
    }
    printf("\n");
}

// Main function to find a route in the maze
void findRoute(char maze[ROWS][COLS], int startRow, int startCol) {
    // Initialize stack to store visited cells
    int stack[ROWS*COLS][2];
    int top = -1;

    // Push the starting cell onto the stack
    stack[++top][0] = startRow;
    stack[top][1] = startCol;

    // Initialize a visited array to keep track of visited cells
    bool visited[ROWS][COLS];
    for(int i = 0; i < ROWS; i++) {
        for(int j = 0; j < COLS; j++) {
            visited[i][j] = false;
        }
    }
    visited[startRow][startCol] = true;

    // Loop until stack is empty or exit is found
    while(top >= 0) {
        // Pop the top cell from the stack
        int row = stack[top][0];
        int col = stack[top][1];
        top--;

        // Check if this cell is the exit
        if(maze[row][col] == 'E') {
            printf("Exit found!\n\n");
            printMaze(maze, row, col);
            return;
        }

        // Mark this cell as visited
        visited[row][col] = true;

        // Check if there are any valid neighbors and add to the stack
        if(isValidCell(row-1, col, maze) && !visited[row-1][col]) {   // Up
            stack[++top][0] = row-1;
            stack[top][1] = col;
            visited[row-1][col] = true;
        }
        if(isValidCell(row, col+1, maze) && !visited[row][col+1]) {   // Right
            stack[++top][0] = row;
            stack[top][1] = col+1;
            visited[row][col+1] = true;
        }
        if(isValidCell(row+1, col, maze) && !visited[row+1][col]) {   // Down
            stack[++top][0] = row+1;
            stack[top][1] = col;
            visited[row+1][col] = true;
        }
        if(isValidCell(row, col-1, maze) && !visited[row][col-1]) {   // Left
            stack[++top][0] = row;
            stack[top][1] = col-1;
            visited[row][col-1] = true;
        }

        // Print the current position of the maze runner
        printMaze(maze, row, col);
        // Wait for a short amount of time to create animation effect
        for(int i = 0; i < 100000000; i++);
    }

    // If stack is empty and exit not found, print failure message
    printf("Exit not found!\n\n");
    printMaze(maze, startRow, startCol);
}

int main() {
    // Initialize the maze with obstacles and exit
    char maze[ROWS][COLS] = {
        {'+', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '+'},
        {'|', '.', '|', '.', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '.', '.', '.', '|'},
        {'|', '.', '|', '.', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '.', '.', '.', '|'},
        {'|', '.', '|', '.', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '.', '.', '.', '|'},
        {'|', '.', '|', '.', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '.', '.', '.', '|'},
        {'|', '.', '|', '.', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '.', '.', '.', '|'},
        {'|', '.', '|', '.', '.', '.', '.', '.', '|', '|', '|', '|', '|', '|', '|', '|', '.', '.', '.', '|'},
        {'|', '.', '.', '.', '|', '|', '|', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '|'},
        {'|', '.', '|', '.', '.', '.', '.', '.', '|', '|', '|', '|', '|', '|', '|', '|', '.', '.', '.', '|'},
        {'+', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '+'}
    };

    // Set the start position of the maze runner
    int startRow, startCol;
    for(int i = 0; i < ROWS; i++) {
        for(int j = 0; j < COLS; j++) {
            if(maze[i][j] == '.') {
                startRow = i;
                startCol = j;
                break;
            }
        }
    }

    // Print the initial maze and starting position of the maze runner
    printMaze(maze, startRow, startCol);

    // Call the function to find the route
    findRoute(maze, startRow, startCol);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall printMaze(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall findRoute(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001C2B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[26]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5; // [rsp+F0h] [rbp+70h]
  __int64 v6; // [rsp+F8h] [rbp+78h]

  _main(argc, argv, envp);
  qmemcpy(
    v4,
    "+------------------+|.|.||||||||||||...||.|.||||||||||||...||.|.||||||||||||...||.|.||||||||||||...||.|.||||||||||||"
    "...||.|.....||||||||...||...|||............||.|.....||||||||...|+------------------+",
    200);
  HIDWORD(v5) = 0;
  while ( SHIDWORD(v5) <= 9 )
  {
    LODWORD(v5) = 0;
    while ( (int)v5 <= 19 )
    {
      if ( *((_BYTE *)v4 + 20 * SHIDWORD(v5) + (int)v5) == 46 )
      {
        v6 = v5;
        break;
      }
      LODWORD(v5) = v5 + 1;
    }
    ++HIDWORD(v5);
  }
  printMaze(v4, HIDWORD(v6), (unsigned int)v6);
  findRoute(v4, HIDWORD(v6), (unsigned int)v6);
  return 0;
}
// 1400015F3: using guessed type __int64 __fastcall printMaze(_QWORD, _QWORD, _QWORD);
// 1400016B4: using guessed type __int64 __fastcall findRoute(_QWORD, _QWORD, _QWORD);
// 140001E80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Educational ; Style: Linus Torvalds
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("Welcome to Linux C programming!\n");
    printf("Here's a program to compute the factorial of a number.\n");
    printf("Enter a positive integer: ");

    int num;
    
    scanf("%d", &num);

    if(num < 0) {
        printf("Error: Input must be a positive integer.\n");
        return 0;
    } else if(num == 0) {
        printf("The factorial of 0 is 1.\n");
        return 0;
    } else {
        int result = 1;
        int i;
        for(i = 1; i <= num; i++) {
            result *= i;
        }
        printf("The factorial of %d is %d.\n", num, result);
        return 0;
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  int i; // [rsp+28h] [rbp-8h]
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to Linux C programming!\n");
  printf("Here's a program to compute the factorial of a number.\n");
  printf("Enter a positive integer: ");
  scanf("%d", &v4);
  if ( v4 >= 0 )
  {
    if ( v4 )
    {
      v6 = 1;
      for ( i = 1; i <= v4; ++i )
        v6 *= i;
      printf("The factorial of %d is %d.\n", (unsigned int)v4, v6);
      return 0;
    }
    else
    {
      printf("The factorial of 0 is 1.\n");
      return 0;
    }
  }
  else
  {
    printf("Error: Input must be a positive integer.\n");
    return 0;
  }
}
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Benchmarking ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function that generates a random array with values between 1 and 1000
void generateRandomArray(int* arr, int size){
    srand(time(NULL));
    for(int i = 0; i < size; ++i){
        arr[i] = rand()%1000 + 1;
    }
}

// Function that sorts an array using bubble sort algorithm
void bubbleSort(int* arr, int size){
    int i, j, temp;
    for(i = 0; i < size-1; ++i){
        for(j = 0; j < size-i-1; ++j){
            if(arr[j] > arr[j+1]){
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

// Function that measures the time it takes to sort an array using bubble sort
double measureBubbleSortTime(int* arr, int size){
    clock_t start, end;
    double timeTaken;

    start = clock();
    bubbleSort(arr, size);
    end = clock();

    timeTaken = ((double) (end - start)) / CLOCKS_PER_SEC;

    return timeTaken;
}

// Main function
int main(){
    int size = 10000;
    int arr[size];

    // Generate a random array
    generateRandomArray(arr, size);

    // Measure the time it takes to sort the array using bubble sort
    double timeTaken = measureBubbleSortTime(arr, size);

    printf("Time taken to sort %d elements using bubble sort algorithm: %lf seconds", size, timeTaken);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall generateRandomArray(_QWORD, _QWORD); // weak
double __fastcall measureBubbleSortTime(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001781) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  double v5; // [rsp+20h] [rbp-20h] BYREF
  double *v6; // [rsp+28h] [rbp-18h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  unsigned int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 10000;
  v7 = 9999i64;
  v3 = alloca(40000i64);
  v6 = &v5;
  generateRandomArray(&v5, 10000i64);
  v5 = measureBubbleSortTime(v6, v8);
  printf("Time taken to sort %d elements using bubble sort algorithm: %lf seconds", v8, v5);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall generateRandomArray(_QWORD, _QWORD);
// 140001720: using guessed type double __fastcall measureBubbleSortTime(_QWORD, _QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game of Life ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 20
#define COLS 60

void displayGrid(int grid[ROWS][COLS]) {
    for (int i=0; i<ROWS; i++) {
        for (int j=0; j<COLS; j++) {
            if (grid[i][j] == 1) {
                printf("*");
            } else {
                printf(" ");
            }
        }
        printf("\n");
    }
}

int countNeighbors(int grid[ROWS][COLS], int row, int col) {
    int count = 0;
    for (int i=-1; i<=1; i++) {
        for (int j=-1; j<=1; j++) {
            int neighbor_row = row+i;
            int neighbor_col = col+j;
            if ((neighbor_row >= 0) && (neighbor_row < ROWS) && (neighbor_col >= 0) && (neighbor_col < COLS)) {
                count += grid[neighbor_row][neighbor_col];
            }
        }
    }
    count -= grid[row][col];
    return count;
}

void generateNext(int grid[ROWS][COLS]) {
    int next[ROWS][COLS];
    for (int i=0; i<ROWS; i++) {
        for (int j=0; j<COLS; j++) {
            int neighbors = countNeighbors(grid, i, j);
            if (grid[i][j] == 1) {
                if (neighbors < 2) {
                    next[i][j] = 0;
                } else if (neighbors > 3) {
                    next[i][j] = 0;
                } else {
                    next[i][j] = 1;
                }
            } else {
                if (neighbors == 3) {
                    next[i][j] = 1;
                } else {
                    next[i][j] = 0;
                }
            }
        }
    }
    // Copy the next state back to the original grid
    for (int i=0; i<ROWS; i++) {
        for (int j=0; j<COLS; j++) {
            grid[i][j] = next[i][j];
        }
    }
}

int main(void) {
    // Initialize grid with random values
    int grid[ROWS][COLS];
    srand(time(NULL));
    for (int i=0; i<ROWS; i++) {
        for (int j=0; j<COLS; j++) {
            grid[i][j] = rand() % 2;
        }
    }
    
    // Simulate game of life
    for (int i=0; i<100; i++) {
        system("clear"); // Clear the console (works only on Unix-like systems)
        displayGrid(grid);
        generateNext(grid);
        printf("Generation: %d\n", i+1);
        usleep(200000); // Wait for 200 milliseconds
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall displayGrid(_QWORD); // weak
__int64 __fastcall generateNext(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall usleep(_QWORD); // weak
// int __cdecl system(const char *Command);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001969) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[1201]; // [rsp+20h] [rbp-60h] BYREF
  int k; // [rsp+12E4h] [rbp+1264h]
  int j; // [rsp+12E8h] [rbp+1268h]
  int i; // [rsp+12ECh] [rbp+126Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 19; ++i )
  {
    for ( j = 0; j <= 59; ++j )
      v5[60 * i + j] = rand() % 2;
  }
  for ( k = 0; k <= 99; ++k )
  {
    system("clear");
    displayGrid(v5);
    generateNext(v5);
    printf("Generation: %d\n", (unsigned int)(k + 1));
    usleep(200000i64);
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall displayGrid(_QWORD);
// 14000170D: using guessed type __int64 __fastcall generateNext(_QWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002B90: using guessed type __int64 __fastcall usleep(_QWORD);
// 140001969: using guessed type int var_12D0[1201];

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game of Life ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int rows = 20, cols = 20;
    int grid[rows][cols], next[rows][cols];
    int generation = 0;

    // Seed random number generator
    srand(time(NULL));

    // Initialize grid with random values
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            grid[i][j] = (rand() % 2);
        }
    }

    printf("Starting grid (Generation %d):\n", generation);
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%c ", grid[i][j] ? '*' : '-');
        }
        printf("\n");
    }

    // Create next generation of cells
    while (1) {
        generation++;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // Count live neighbors
                int neighbors = 0;
                for (int x = -1; x <= 1; x++) {
                    for (int y = -1; y <= 1; y++) {
                        if (x == 0 && y == 0) continue;
                        if (i + x < 0 || i + x >= rows) continue;
                        if (j + y < 0 || j + y >= cols) continue;
                        neighbors += grid[i + x][j + y];
                    }
                }

                // Determine if cell lives, dies, or is born
                if (grid[i][j] == 1) { // Cell is alive
                    if (neighbors < 2 || neighbors > 3) {
                        next[i][j] = 0; // Cell dies
                    } else {
                        next[i][j] = 1; // Cell lives
                    }
                } else { // Cell is dead
                    if (neighbors == 3) {
                        next[i][j] = 1; // Cell is born
                    } else {
                        next[i][j] = 0; // Cell stays dead
                    }
                }
            }
        }

        // Copy next generation to current grid
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                grid[i][j] = next[i][j];
            }
        }

        // Print current grid
        printf("\nNext generation (Generation %d):\n", generation);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                printf("%c ", grid[i][j] ? '*' : '-');
            }
            printf("\n");
        }

        // Check for stable or oscillating state
        int stable = 1;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] != next[i][j]) {
                    stable = 0;
                    break;
                }
            }
            if (!stable) break;
        }
        if (stable) {
            printf("\nGrid has stabilized (Generation %d)\n", generation);
            break;
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  void *v4; // rsp
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // eax
  __int64 v9; // [rsp+0h] [rbp-80h] BYREF
  char v10; // [rsp+20h] [rbp-60h] BYREF
  __int64 *v11; // [rsp+28h] [rbp-58h]
  __int64 v12; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  __int64 v14; // [rsp+40h] [rbp-40h]
  __int64 v15; // [rsp+48h] [rbp-38h]
  __int64 v16; // [rsp+50h] [rbp-30h]
  __int64 v17; // [rsp+58h] [rbp-28h]
  __int64 v18; // [rsp+60h] [rbp-20h]
  __int64 v19; // [rsp+68h] [rbp-18h]
  __int64 v20; // [rsp+70h] [rbp-10h]
  __int64 v21; // [rsp+78h] [rbp-8h]
  __int64 v22; // [rsp+80h] [rbp+0h]
  __int64 v23; // [rsp+88h] [rbp+8h]
  __int64 v24; // [rsp+90h] [rbp+10h]
  __int64 v25; // [rsp+98h] [rbp+18h]
  char *v26; // [rsp+A0h] [rbp+20h]
  __int64 v27; // [rsp+A8h] [rbp+28h]
  __int64 v28; // [rsp+B0h] [rbp+30h]
  char *v29; // [rsp+B8h] [rbp+38h]
  __int64 v30; // [rsp+C0h] [rbp+40h]
  __int64 v31; // [rsp+C8h] [rbp+48h]
  int v32; // [rsp+D4h] [rbp+54h]
  int v33; // [rsp+D8h] [rbp+58h]
  int i4; // [rsp+DCh] [rbp+5Ch]
  int i3; // [rsp+E0h] [rbp+60h]
  int v36; // [rsp+E4h] [rbp+64h]
  int i2; // [rsp+E8h] [rbp+68h]
  int i1; // [rsp+ECh] [rbp+6Ch]
  int nn; // [rsp+F0h] [rbp+70h]
  int mm; // [rsp+F4h] [rbp+74h]
  int kk; // [rsp+F8h] [rbp+78h]
  int jj; // [rsp+FCh] [rbp+7Ch]
  int v43; // [rsp+100h] [rbp+80h]
  int ii; // [rsp+104h] [rbp+84h]
  int n; // [rsp+108h] [rbp+88h]
  int m; // [rsp+10Ch] [rbp+8Ch]
  int k; // [rsp+110h] [rbp+90h]
  int j; // [rsp+114h] [rbp+94h]
  int i; // [rsp+118h] [rbp+98h]
  unsigned int v50; // [rsp+11Ch] [rbp+9Ch]

  _main(argc, argv, envp);
  v11 = &v9;
  v33 = 20;
  v32 = 20;
  v31 = 19i64;
  v30 = 19i64;
  v24 = 20i64;
  v25 = 0i64;
  v22 = 20i64;
  v23 = 0i64;
  v3 = alloca(1600i64);
  v29 = &v10;
  v28 = 19i64;
  v12 = 20i64;
  v13 = 0i64;
  v27 = 19i64;
  v20 = 20i64;
  v21 = 0i64;
  v18 = 20i64;
  v19 = 0i64;
  v16 = 20i64;
  v17 = 0i64;
  v14 = 20i64;
  v15 = 0i64;
  v4 = alloca(1600i64);
  v26 = &v10;
  v50 = 0;
  v5 = time(0i64);
  srand(v5);
  for ( i = 0; i < v33; ++i )
  {
    for ( j = 0; j < v32; ++j )
      *(_DWORD *)&v29[80 * i + 4 * j] = rand() % 2;
  }
  printf("Starting grid (Generation %d):\n", v50);
  for ( k = 0; k < v33; ++k )
  {
    for ( m = 0; m < v32; ++m )
    {
      if ( *(_DWORD *)&v29[80 * k + 4 * m] )
        v6 = 42;
      else
        v6 = 45;
      printf("%c ", v6);
    }
    printf("\n");
  }
  do
  {
    ++v50;
    for ( n = 0; n < v33; ++n )
    {
      for ( ii = 0; ii < v32; ++ii )
      {
        v43 = 0;
        for ( jj = -1; jj <= 1; ++jj )
        {
          for ( kk = -1; kk <= 1; ++kk )
          {
            if ( (jj || kk) && n + jj >= 0 && v33 > n + jj && ii + kk >= 0 && v32 > ii + kk )
              v43 += *(_DWORD *)&v29[80 * jj + 80 * n + 4 * kk + 4 * ii];
          }
        }
        if ( *(_DWORD *)&v29[80 * n + 4 * ii] == 1 )
          *(_DWORD *)&v26[80 * n + 4 * ii] = v43 > 1 && v43 <= 3;
        else
          *(_DWORD *)&v26[80 * n + 4 * ii] = v43 == 3;
      }
    }
    for ( mm = 0; mm < v33; ++mm )
    {
      for ( nn = 0; nn < v32; ++nn )
        *(_DWORD *)&v29[80 * mm + 4 * nn] = *(_DWORD *)&v26[80 * mm + 4 * nn];
    }
    printf("\nNext generation (Generation %d):\n", v50);
    for ( i1 = 0; i1 < v33; ++i1 )
    {
      for ( i2 = 0; i2 < v32; ++i2 )
      {
        if ( *(_DWORD *)&v29[80 * i1 + 4 * i2] )
          v7 = 42;
        else
          v7 = 45;
        printf("%c ", v7);
      }
      printf("\n");
    }
    v36 = 1;
    for ( i3 = 0; i3 < v33; ++i3 )
    {
      for ( i4 = 0; i4 < v32; ++i4 )
      {
        if ( *(_DWORD *)&v29[80 * i3 + 4 * i4] != *(_DWORD *)&v26[80 * i3 + 4 * i4] )
        {
          v36 = 0;
          break;
        }
      }
      if ( !v36 )
        break;
    }
  }
  while ( !v36 );
  printf("\nGrid has stabilized (Generation %d)\n", v50);
  return 0;
}
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data mining ; Style: rigorous
#include <stdio.h>

struct student {
   char name[50];
   int age;
   float marks;
};

int main() {
   int i;
   struct student arr[5]; // initialize array of students

   // get input for all students
   printf("Enter details of 5 students:\n");
   for(i=0; i<5; i++) {
       printf("Enter name of student %d: ", i+1);
       scanf("%s", &arr[i].name);
       printf("Enter age of student %d: ", i+1);
       scanf("%d", &arr[i].age);
       printf("Enter marks of student %d: ", i+1);
       scanf("%f", &arr[i].marks);
   }
   
   // find student with highest marks
   float highest_marks;
   int highest_marks_index;
   for(i=0; i<5; i++) {
       if(arr[i].marks > highest_marks) {
           highest_marks = arr[i].marks;
           highest_marks_index = i;
       }
   }
   
   // print student with highest marks
   printf("\nStudent with highest marks:\n");
   printf("Name: %s\n", arr[highest_marks_index].name);
   printf("Age: %d\n", arr[highest_marks_index].age);
   printf("Marks: %f\n", arr[highest_marks_index].marks);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[96]; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v5[212]; // [rsp+80h] [rbp+0h] BYREF
  int v6; // [rsp+154h] [rbp+D4h]
  float v7; // [rsp+158h] [rbp+D8h]
  int i; // [rsp+15Ch] [rbp+DCh]

  _main(argc, argv, envp);
  printf("Enter details of 5 students:\n");
  for ( i = 0; i <= 4; ++i )
  {
    printf("Enter name of student %d: ", (unsigned int)(i + 1));
    scanf("%s", &v4[60 * i]);
    printf("Enter age of student %d: ", (unsigned int)(i + 1));
    scanf("%d", &v4[60 * i + 52]);
    printf("Enter marks of student %d: ", (unsigned int)(i + 1));
    scanf("%f", &v4[60 * i + 56]);
  }
  for ( i = 0; i <= 4; ++i )
  {
    if ( *(float *)&v5[60 * i - 40] > v7 )
    {
      v7 = *(float *)&v5[60 * i - 40];
      v6 = i;
    }
  }
  printf("\nStudent with highest marks:\n");
  printf("Name: %s\n", &v4[60 * v6]);
  printf("Age: %d\n", *(unsigned int *)&v5[60 * v6 - 44]);
  printf("Marks: %f\n", *(float *)&v5[60 * v6 - 40]);
  return 0;
}
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_140[96];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: RAM usage monitor ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    char mem[10];
    char* command;
    FILE* procFile;
    
    while(1) {
        // Open the file that contains the RAM usage information for the current process
        procFile = fopen("/proc/self/status", "r");
        
        // Read the contents of the file line by line until we reach the line containing RAM information
        while(fgets(mem, 10, procFile)) {
            if(strncmp(mem, "VmRSS:", 6) == 0) {
                // The line containing RAM information has been found, output it
                printf("Current RAM usage: %s", mem);
                break;
            }
        }
        
        // Close the file and wait for a second before checking again
        fclose(procFile);
        sleep(1);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[10]; // [rsp+2Eh] [rbp-12h] BYREF
  FILE *Stream; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  while ( 1 )
  {
    Stream = fopen("/proc/self/status", "r");
    do
    {
      if ( !fgets(Str1, 10, Stream) )
        goto LABEL_6;
    }
    while ( strncmp(Str1, "VmRSS:", 6ui64) );
    printf("Current RAM usage: %s", Str1);
LABEL_6:
    fclose(Stream);
    sleep(1i64);
  }
}
// 1400016E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002740: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: inquisitive
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int pushups = 0;
    int squats = 0;
    int crunches = 0;
    float distance = 0.0;
    int choice = 0;

    printf("Welcome to Fitness Tracker\n");

    do {
        printf("\nSelect an option:\n");
        printf("1. Add Pushups\n");
        printf("2. Add Squats\n");
        printf("3. Add Crunches\n");
        printf("4. Add Distance\n");
        printf("5. View Stats\n");
        printf("6. Exit\n");

        scanf("%d", &choice);

        switch (choice) {
            case 1:
                pushups++;
                break;
            case 2:
                squats++;
                break;
            case 3:
                crunches++;
                break;
            case 4:
                printf("Enter Distance(miles): ");
                scanf("%f", &distance);
                break;
            case 5:
                printf("\nFitness Stats:\n");
                printf("Pushups: %d\n", pushups);
                printf("Squats: %d\n", squats);
                printf("Crunches: %d\n", crunches);
                printf("Distance: %f miles\n", distance);
                break;
            case 6:
                printf("Thank you for using Fitness Tracker!");
                break;
            default:
                printf("Invalid Choice!");
        }

    } while (choice != 6);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-14h] BYREF
  float v5; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v6; // [rsp+34h] [rbp-Ch]
  unsigned int v7; // [rsp+38h] [rbp-8h]
  unsigned int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0.0;
  v4 = 0;
  printf("Welcome to Fitness Tracker\n");
  do
  {
    printf("\nSelect an option:\n");
    printf("1. Add Pushups\n");
    printf("2. Add Squats\n");
    printf("3. Add Crunches\n");
    printf("4. Add Distance\n");
    printf("5. View Stats\n");
    printf("6. Exit\n");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        ++v8;
        break;
      case 2:
        ++v7;
        break;
      case 3:
        ++v6;
        break;
      case 4:
        printf("Enter Distance(miles): ");
        scanf("%f", &v5);
        break;
      case 5:
        printf("\nFitness Stats:\n");
        printf("Pushups: %d\n", v8);
        printf("Squats: %d\n", v7);
        printf("Crunches: %d\n", v6);
        printf("Distance: %f miles\n", v5);
        break;
      case 6:
        printf("Thank you for using Fitness Tracker!");
        break;
      default:
        printf("Invalid Choice!");
        break;
    }
  }
  while ( v4 != 6 );
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: automated
#include <stdio.h>

#define MAX_N 100

// Greedy algorithm to find the minimum number of coins needed to make change for a given amount
int find_minimum_coins(int coins[], int n, int amount)
{
    int count = 0;

    for (int i = 0; i < n; i++)
    {
        while (amount >= coins[i])
        {
            amount -= coins[i];
            count++;
        }
    }

    return count;
}

int main(void)
{
    int coins[] = {1, 5, 10, 25};
    int n = 4;
    int amount;

    printf("Enter an amount in cents: ");
    scanf("%d", &amount);

    printf("Minimum number of coins needed to make change: %d\n", find_minimum_coins(coins, n, amount));

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall find_minimum_coins(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001652) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int minimum_coins; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-24h] BYREF
  int v6[7]; // [rsp+30h] [rbp-20h] BYREF
  unsigned int v7; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6[0] = 1;
  v6[1] = 5;
  v6[2] = 10;
  v6[3] = 25;
  v7 = 4;
  printf("Enter an amount in cents: ");
  scanf("%d", &v5);
  minimum_coins = find_minimum_coins(v6, v7, v5);
  printf("Minimum number of coins needed to make change: %d\n", minimum_coins);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall find_minimum_coins(_QWORD, _QWORD, _QWORD);
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Table Game ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
 
int main()
{
    int num, guess, tries = 0;
    srand(time(0)); // generates random seed for each run
 
    num = rand() % 100 + 1; // generates a random number between 1 and 100
 
    printf("Welcome to the Number Guessing Game!\n");
    printf("I'm thinking of a number between 1 and 100.\n");
    printf("You have to guess what it is in 10 tries or less.\n\n");
 
    do
    {
        printf("Guess a number: ");
        scanf("%d", &guess);
        tries++;
 
        if (guess > num)
        {
            printf("Too high! Try again.\n\n");
        }
        else if (guess < num)
        {
            printf("Too low! Try again.\n\n");
        }
        else
        {
            printf("Congratulations! You guessed the number in %d tries.\n", tries);
        }
 
    } while (guess != num && tries < 10);
 
    if (tries == 10)
    {
        printf("Sorry! You have used up all your tries. The number was %d.\n", num);
    }
 
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  int v6; // [rsp+28h] [rbp-8h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 0;
  v3 = time(0i64);
  srand(v3);
  v6 = rand() % 100 + 1;
  printf("Welcome to the Number Guessing Game!\n");
  printf("I'm thinking of a number between 1 and 100.\n");
  printf("You have to guess what it is in 10 tries or less.\n\n");
  do
  {
    printf("Guess a number: ");
    scanf("%d", &v5);
    ++v7;
    if ( v6 >= v5 )
    {
      if ( v6 <= v5 )
        printf("Congratulations! You guessed the number in %d tries.\n", v7);
      else
        printf("Too low! Try again.\n\n");
    }
    else
    {
      printf("Too high! Try again.\n\n");
    }
  }
  while ( v6 != v5 && (int)v7 <= 9 );
  if ( v7 == 10 )
    printf("Sorry! You have used up all your tries. The number was %d.\n", (unsigned int)v6);
  return 0;
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: CPU Scheduling Algorithms ; Style: relaxed
#include <stdio.h> 

struct Process{
    char name;
    int arrivalTime, burstTime, waitingTime, turnAroundTime, completionTime;
    int executed; // if process is executed or not
} processes[] = {{'P', 0, 3}, {'Q', 1, 4}, {'R', 2, 2}, {'S', 3, 1}};

int size = sizeof processes / sizeof(struct Process);

void sortProcessesByArrivalTime(){
    struct Process temp;
    
    for(int i=0; i<size-1; i++){
        for(int j=i+1; j<size; j++){
            if(processes[i].arrivalTime > processes[j].arrivalTime){
                temp = processes[i];
                processes[i] = processes[j];
                processes[j] = temp;
            }
        }
    }
}

void executeRR(int quantum){
    int remainingTime[size];
    int currentTime = 0;
    int completionTime = 0;
    int timeSlotStart[size];
    int timeSlotEnd[size];
    int counter = 0;
    
    for(int i=0; i<size; i++){ // remaining time for each process
        remainingTime[i] = processes[i].burstTime;
        processes[i].waitingTime = 0;
        processes[i].executed = 0;
        timeSlotStart[i] = -1;
    }
    
    while(counter < size){
        int minRemainingTime = 9999;
        int minRemainingTimeIndex = 0;
        int currentBurst = 0;
        int flag = 0;
        
        for(int i=0; i<size; i++){
            if(processes[i].arrivalTime <= currentTime && processes[i].executed == 0 && remainingTime[i] < minRemainingTime){
                minRemainingTimeIndex = i;
                minRemainingTime = remainingTime[i];
                currentBurst = minRemainingTime;
                flag = 1;
            }
        }

        if(flag == 0){
            timeSlotEnd[counter] = currentTime;
            currentTime++;
            continue;
        }
        
        if(currentBurst > quantum){
            currentBurst = quantum;
        }
        
        timeSlotStart[minRemainingTimeIndex] = currentTime;
        currentTime += currentBurst;
        remainingTime[minRemainingTimeIndex] -= currentBurst;
        
        if(remainingTime[minRemainingTimeIndex] <= 0){
            processes[minRemainingTimeIndex].completionTime = currentTime;
            processes[minRemainingTimeIndex].turnAroundTime = processes[minRemainingTimeIndex].completionTime - processes[minRemainingTimeIndex].arrivalTime;
            processes[minRemainingTimeIndex].waitingTime = processes[minRemainingTimeIndex].turnAroundTime - processes[minRemainingTimeIndex].burstTime;
            processes[minRemainingTimeIndex].executed = 1;
            counter++;
            timeSlotEnd[minRemainingTimeIndex] = currentTime;
        }
    }
    
    printf("\nProcess\t\tArrival Time\tBurst Time\tWaiting Time\tCompletion Time\tTurn Around Time\tTime slots\n");
    for(int i=0; i<size; i++){
        printf("%c\t\t\t%d\t\t%d\t\t%d\t\t%d\t\t\t%d\t\t\t", processes[i].name, processes[i].arrivalTime, processes[i].burstTime, processes[i].waitingTime, processes[i].completionTime, processes[i].turnAroundTime);
        for(int j=timeSlotStart[i]; j<timeSlotEnd[i]; j++){
            printf("%d ", j);
        }
        printf("%d", timeSlotEnd[i]);
        printf("\n");
    }
}

int main(){
    printf("Round Robin CPU Scheduling Algorithm:\n");
    printf("======================================\n\n");
    printf("Process Details:\n");
    printf("================\n");
    sortProcessesByArrivalTime();
    executeRR(1);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 sortProcessesByArrivalTime(void); // weak
__int64 __fastcall executeRR(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001D08) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("Round Robin CPU Scheduling Algorithm:\n");
  printf("======================================\n\n");
  printf("Process Details:\n");
  printf("================\n");
  sortProcessesByArrivalTime();
  executeRR(1i64);
  return 0;
}
// 140001591: using guessed type __int64 sortProcessesByArrivalTime(void);
// 140001711: using guessed type __int64 __fastcall executeRR(_QWORD);
// 140001E20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sudoku solver ; Style: enthusiastic
#include <stdio.h>

// function prototypes
void printGrid(int grid[9][9]);
int isSafe(int grid[9][9], int row, int col, int num);
int solveSudoku(int grid[9][9]);

int main() {
    int grid[9][9] = 
    {
        {0, 9, 0, 0, 0, 0, 8, 5, 3},
        {0, 0, 0, 8, 0, 0, 0, 0, 4},
        {0, 0, 8, 2, 0, 3, 0, 6, 9},
        {5, 7, 4, 0, 0, 2, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 9, 0, 0, 6, 3, 7},
        {9, 4, 0, 1, 0, 8, 5, 0, 0},
        {7, 0, 0, 0, 0, 6, 0, 0, 0},
        {6, 8, 2, 0, 0, 0, 0, 9, 0}
    };

    printf("Unsolved Sudoku:\n");
    printGrid(grid);

    if(solveSudoku(grid)) {
        printf("\nSolved Sudoku:\n");
        printGrid(grid);
    } else {
        printf("\nNo solution exists.");
    }

    return 0;
}

// function to print the grid
void printGrid(int grid[9][9]) {
    for(int i=0; i<9; i++) {
        for(int j=0; j<9; j++) {
            printf("%d ", grid[i][j]);
        }
        printf("\n");
    }
}

// function to check whether a number can be placed in the given cell
int isSafe(int grid[9][9], int row, int col, int num) {
    // check if row contains num
    for(int i=0; i<9; i++) {
        if(grid[row][i] == num) {
            return 0;
        }
    }

    // check if column contains num
    for(int i=0; i<9; i++) {
        if(grid[i][col] == num) {
            return 0;
        }
    }

    // check if box contains num
    int boxRow = row - row%3;
    int boxCol = col - col%3;
    for(int i=boxRow; i<boxRow+3; i++) {
        for(int j=boxCol; j<boxCol+3; j++) {
            if(grid[i][j] == num) {
                return 0;
            }
        }
    }

    return 1;
}

// function to solve the sudoku puzzle recursively
int solveSudoku(int grid[9][9]) {
    int row, col, flag=0;

    // find an unassigned cell
    for(row=0; row<9; row++) {
        for(col=0; col<9; col++) {
            if(grid[row][col] == 0) {
                flag = 1;
                break;
            }
        }
        if(flag) {
            break;
        }
    }

    // if all cells are assigned, the puzzle is solved
    if(row == 9 && col == 9) {
        return 1;
    }

    // try all possible numbers in the current cell
    for(int num=1; num<=9; num++) {
        // if the number can be placed in the current cell
        if(isSafe(grid, row, col, num)) {
            // assign the number to the current cell
            grid[row][col] = num;

            // recursively solve the rest of the puzzle
            if(solveSudoku(grid)) {
                return 1;
            }

            // if the current number does not lead to a solution, backtrack
            grid[row][col] = 0;
        }
    }

    // if no number can be placed in the current cell, backtrack
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall printGrid(_QWORD); // weak
__int64 __fastcall solveSudoku(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[352]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v4, &unk_14000A020, 0x144ui64);
  printf("Unsolved Sudoku:\n");
  printGrid(v4);
  if ( (unsigned int)solveSudoku(v4) )
  {
    printf("\nSolved Sudoku:\n");
    printGrid(v4);
  }
  else
  {
    printf("\nNo solution exists.");
  }
  return 0;
}
// 140001632: using guessed type __int64 __fastcall printGrid(_QWORD);
// 140001822: using guessed type __int64 __fastcall solveSudoku(_QWORD);
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Syntax parsing ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("Initializing syntax parser...\n");
    // Set up variables
    char* userInput;
    int numLines = 0;
    int bracketsOpen = 0;
    int bracketsClosed = 0;
    int parenthesesOpen = 0;
    int parenthesesClosed = 0;
    int semicolons = 0;
    int errorsPresent = 0;

    // Receive user input
    printf("Awaiting input...\n");
    fgets(userInput, 100000, stdin);
    printf("Input complete!\n");

    // Read user input
    for (int i = 0; i < strlen(userInput); i++) {
        if (userInput[i] == '\n') {
            numLines += 1;
        } else if (userInput[i] == '{') {
            bracketsOpen += 1;
        } else if (userInput[i] == '}') {
            bracketsClosed += 1;
        } else if (userInput[i] == '(') {
            parenthesesOpen += 1;
        } else if (userInput[i] == ')') {
            parenthesesClosed += 1;
        } else if (userInput[i] == ';') {
            semicolons += 1;
        } else {
            errorsPresent += 1;
        }
    }

    // Analyze syntax
    printf("Analyzing syntax...\n");
    if (bracketsOpen != bracketsClosed) {
        printf("ERROR: Mismatched brackets present.\n");
        errorsPresent += 1;
    }
    if (parenthesesOpen != parenthesesClosed) {
        printf("ERROR: Mismatched parentheses present.\n");
        errorsPresent += 1;
    }
    if (semicolons <= 1) {
        printf("ERROR: Not enough semicolons present.\n");
        errorsPresent += 1;
    }

    // Display syntax analysis results
    if (errorsPresent == 0) {
        printf("Syntax is correct! Program can be compiled and run.\n");
    } else {
        printf("%d errors detected in syntax. Program cannot be compiled.\n", errorsPresent);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rdx
  char *Buffer; // [rsp+28h] [rbp-28h]
  int i; // [rsp+30h] [rbp-20h]
  unsigned int v7; // [rsp+34h] [rbp-1Ch]
  int v8; // [rsp+38h] [rbp-18h]
  int v9; // [rsp+3Ch] [rbp-14h]
  int v10; // [rsp+40h] [rbp-10h]
  int v11; // [rsp+44h] [rbp-Ch]
  int v12; // [rsp+48h] [rbp-8h]
  int v13; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Initializing syntax parser...\n");
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  printf("Awaiting input...\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100000, v3);
  printf("Input complete!\n");
  for ( i = 0; i < strlen(Buffer); ++i )
  {
    switch ( Buffer[i] )
    {
      case 10:
        ++v13;
        break;
      case 123:
        ++v12;
        break;
      case 125:
        ++v11;
        break;
      case 40:
        ++v10;
        break;
      case 41:
        ++v9;
        break;
      case 59:
        ++v8;
        break;
      default:
        ++v7;
        break;
    }
  }
  printf("Analyzing syntax...\n");
  if ( v12 != v11 )
  {
    printf("ERROR: Mismatched brackets present.\n");
    ++v7;
  }
  if ( v10 != v9 )
  {
    printf("ERROR: Mismatched parentheses present.\n");
    ++v7;
  }
  if ( v8 <= 1 )
  {
    printf("ERROR: Not enough semicolons present.\n");
    ++v7;
  }
  if ( v7 )
    printf("%d errors detected in syntax. Program cannot be compiled.\n", v7);
  else
    printf("Syntax is correct! Program can be compiled and run.\n");
  return 0;
}
// 140001610: variable 'Buffer' is possibly undefined
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image to ASCII art converter ; Style: paranoid
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const char *ASCII_CHARS = " .:-=+*#%@";

void generate_ascii_art(unsigned char *image_data, int width, int height) {
    // Create a buffer for the ASCII art
    char *ascii_art = calloc(width * height + 1, sizeof(char));
    if (!ascii_art) {
        perror("Error: Failed to allocate memory for ASCII art buffer");
        exit(EXIT_FAILURE);
    }

    // Convert each pixel value in the image to its corresponding ASCII character
    for (int i = 0; i < width * height; i++) {
        int pixel_value = image_data[i];
        int ascii_index = (pixel_value * strlen(ASCII_CHARS)) / 256;
        ascii_art[i] = ASCII_CHARS[ascii_index];
    }

    // Print the ASCII art
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            printf("%c", ascii_art[i * width + j]);
        }
        printf("\n");
    }

    free(ascii_art);
}

int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Error: No image file specified\n");
        printf("Usage: %s <image file>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    char *image_file = argv[1];
    FILE *fp = fopen(image_file, "rb");
    if (!fp) {
        perror("Error: Failed to open image file");
        exit(EXIT_FAILURE);
    }

    int width, height;
    unsigned char *image_data;

    // Read the image header
    if (fscanf(fp, "P6\n%d %d\n255\n", &width, &height) != 2) {
        printf("Error: Invalid PPM file format\n");
        exit(EXIT_FAILURE);
    }

    // Allocate memory for the image data
    image_data = malloc(width * height * sizeof(unsigned char) * 3);
    if (!image_data) {
        perror("Error: Failed to allocate memory for image data");
        exit(EXIT_FAILURE);
    }

    // Read the image data
    if (fread(image_data, sizeof(unsigned char), width * height * 3, fp) != width * height * 3) {
        printf("Error: Failed to read image data\n");
        exit(EXIT_FAILURE);
    }

    // Close the image file
    fclose(fp);

    // Convert the image to ASCII art
    generate_ascii_art(image_data, width, height);

    // Free the image data
    free(image_data);

    return EXIT_SUCCESS;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generate_ascii_art(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl perror(const char *ErrMsg);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001713) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  size_t v3; // rax
  unsigned int v5; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v6; // [rsp+24h] [rbp-1Ch] BYREF
  void *Buffer; // [rsp+28h] [rbp-18h]
  FILE *Stream; // [rsp+30h] [rbp-10h]
  char *FileName; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc <= 1 )
  {
    printf("Error: No image file specified\n");
    printf("Usage: %s <image file>\n", *argv);
    exit(1);
  }
  FileName = (char *)argv[1];
  Stream = fopen(FileName, "rb");
  if ( !Stream )
  {
    perror("Error: Failed to open image file");
    exit(1);
  }
  if ( fscanf(Stream, "P6\n%d %d\n255\n", &v6, &v5) != 2 )
  {
    printf("Error: Invalid PPM file format\n");
    exit(1);
  }
  Buffer = malloc(3i64 * (int)(v6 * v5));
  if ( !Buffer )
  {
    perror("Error: Failed to allocate memory for image data");
    exit(1);
  }
  v3 = fread(Buffer, 1ui64, (int)(3 * v5 * v6), Stream);
  if ( v3 != 3 * v5 * v6 )
  {
    printf("Error: Failed to read image data\n");
    exit(1);
  }
  fclose(Stream);
  generate_ascii_art(Buffer, v6, v5);
  free(Buffer);
  return 0;
}
// 1400015D4: using guessed type __int64 __fastcall generate_ascii_art(_QWORD, _QWORD, _QWORD);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Graph Coloring Problem ; Style: surprised
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 20
#define MAX_COLORS 4

int vertices;
int edges;
int adj_matrix[MAX_VERTICES][MAX_VERTICES];
int color[MAX_VERTICES];

void init_graph() {
    int i, j;
    for (i = 0; i < vertices; i++) {
        for (j = i + 1; j < vertices; j++) {
            adj_matrix[i][j] = 0;
            adj_matrix[j][i] = 0;
        }
    }
}

void add_edge(int v1, int v2) {
    adj_matrix[v1][v2] = 1;
    adj_matrix[v2][v1] = 1;
}

int is_safe(int vertex, int c) {
    int i;
    for (i = 0; i < vertices; i++) {
        if (adj_matrix[vertex][i] && c == color[i]) {
            return 0;
        }
    }
    return 1;
}

int graph_coloring(int vertex) {
    int c;
    if (vertex == vertices) {
        return 1;
    }
    for (c = 1; c <= MAX_COLORS; c++) {
        if (is_safe(vertex, c)) {
            color[vertex] = c;
            if (graph_coloring(vertex + 1)) {
                return 1;
            }
            color[vertex] = 0;
        }
    }
    return 0;
}

void print_colors() {
    int i;
    printf("\nVertex\tColor\n");
    for (i = 0; i < vertices; i++) {
        printf("%d\t%d\n", i, color[i]);
    }
}

int main() {
    printf("Surprise! We are going to solve the graph coloring problem today!\n\n");
    printf("Please first input the number of vertices (maximum %d): ", MAX_VERTICES);
    scanf("%d", &vertices);
    if (vertices <= 0 || vertices > MAX_VERTICES) {
        printf("Invalid input for number of vertices. Program will now exit.\n");
        return 0;
    }
    init_graph();
    printf("\nNow please input the number of edges: ");
    scanf("%d", &edges);
    if (edges < 0 || edges > (vertices * (vertices - 1) / 2)) {
        printf("Invalid input for number of edges. Program will now exit.\n");
        return 0;
    }
    int i, v1, v2;
    printf("\nGreat! Now please input the edges in the format v1 v2 (no commas or brackets needed):\n");
    for (i = 0; i < edges; i++) {
        printf("Edge #%d: ", i + 1);
        scanf("%d %d", &v1, &v2);
        if (v1 < 0 || v1 >= vertices || v2 < 0 || v2 >= vertices || v1 == v2) {
            printf("Invalid input for an edge. Program will now exit.\n");
            return 0;
        }
        add_edge(v1, v2);
    }
    printf("\nLet's start coloring...\n");
    if (graph_coloring(0)) {
        printf("\nColoring successful! Here are the colors assigned to each vertex:\n");
        print_colors();
    } else {
        printf("\nColoring failed! Sorry, we could not find a solution.\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 init_graph(void); // weak
__int64 __fastcall add_edge(_QWORD, _QWORD); // weak
__int64 __fastcall graph_coloring(_QWORD); // weak
__int64 print_colors(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

int vertices; // weak
int edges; // weak


//----- (0000000140001889) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  int v5; // [rsp+28h] [rbp-8h] BYREF
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Surprise! We are going to solve the graph coloring problem today!\n\n");
  printf("Please first input the number of vertices (maximum %d): ", 20i64);
  scanf("%d", &vertices);
  if ( vertices > 0 && vertices <= 20 )
  {
    init_graph();
    printf("\nNow please input the number of edges: ");
    scanf("%d", &edges);
    if ( edges >= 0 && (vertices - 1) * vertices / 2 >= edges )
    {
      printf("\nGreat! Now please input the edges in the format v1 v2 (no commas or brackets needed):\n");
      for ( i = 0; i < edges; ++i )
      {
        printf("Edge #%d: ", (unsigned int)(i + 1));
        scanf("%d %d", &v5, &v4);
        if ( v5 < 0 || v5 >= vertices || v4 < 0 || v4 >= vertices || v5 == v4 )
        {
          printf("Invalid input for an edge. Program will now exit.\n");
          return 0;
        }
        add_edge((unsigned int)v5, (unsigned int)v4);
      }
      printf("\nLet's start coloring...\n");
      if ( (unsigned int)graph_coloring(0i64) )
      {
        printf("\nColoring successful! Here are the colors assigned to each vertex:\n");
        print_colors();
      }
      else
      {
        printf("\nColoring failed! Sorry, we could not find a solution.\n");
      }
      return 0;
    }
    else
    {
      printf("Invalid input for number of edges. Program will now exit.\n");
      return 0;
    }
  }
  else
  {
    printf("Invalid input for number of vertices. Program will now exit.\n");
    return 0;
  }
}
// 1400015E2: using guessed type __int64 init_graph(void);
// 140001691: using guessed type __int64 __fastcall add_edge(_QWORD, _QWORD);
// 14000178B: using guessed type __int64 __fastcall graph_coloring(_QWORD);
// 140001824: using guessed type __int64 print_colors(void);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019040: using guessed type int vertices;
// 140019044: using guessed type int edges;

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data recovery tool ; Style: active
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <file>\n", argv[0]);
        exit(1);
    }

    FILE *fp = fopen(argv[1], "rb");

    if (fp == NULL) {
        printf("Unable to open file: %s\n", argv[1]);
        exit(1);
    }

    fseek(fp, 0, SEEK_END);
    long file_size = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    if (file_size == 0) {
        printf("File is empty: %s\n", argv[1]);
        exit(1);
    }

    char *buffer = malloc(file_size);

    if (buffer == NULL) {
        printf("Unable to allocate memory.\n");
        exit(1);
    }

    long bytes_read = fread(buffer, 1, file_size, fp);

    if (bytes_read != file_size) {
        printf("Unable to read complete file.\n");
        exit(1);
    }

    fclose(fp);

    printf("Successfully read %ld bytes.\n", bytes_read);

    // Recover data here...

    free(buffer);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// void __cdecl free(void *Block);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-1Ch]
  void *Buffer; // [rsp+28h] [rbp-18h]
  int v6; // [rsp+34h] [rbp-Ch]
  FILE *Stream; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc <= 1 )
  {
    printf("Usage: %s <file>\n", *argv);
    exit(1);
  }
  Stream = fopen(argv[1], "rb");
  if ( !Stream )
  {
    printf("Unable to open file: %s\n", argv[1]);
    exit(1);
  }
  fseek(Stream, 0, 2);
  v6 = ftell(Stream);
  fseek(Stream, 0, 0);
  if ( !v6 )
  {
    printf("File is empty: %s\n", argv[1]);
    exit(1);
  }
  Buffer = malloc(v6);
  if ( !Buffer )
  {
    printf("Unable to allocate memory.\n");
    exit(1);
  }
  v4 = fread(Buffer, 1ui64, v6, Stream);
  if ( v4 != v6 )
  {
    printf("Unable to read complete file.\n");
    exit(1);
  }
  fclose(Stream);
  printf("Successfully read %ld bytes.\n", v4);
  free(Buffer);
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Synchronizer ; Style: creative
// C File Synchronizer example program

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>

// function declarations
int compare_files(const char *file1, const char *file2);
void sync_files(const char *src_file, const char *dest_file);

int main(int argc, char *argv[]) {
    // check for correct usage
    if (argc < 3) {
        printf("Usage: %s [source directory] [destination directory]\n", argv[0]);
        exit(1);
    }

    // open source directory
    DIR *src_dir = opendir(argv[1]);
    if (src_dir == NULL) {
        printf("Error: Could not open source directory.\n");
        exit(1);
    }

    // open destination directory
    DIR *dest_dir = opendir(argv[2]);
    if (dest_dir == NULL) {
        printf("Error: Could not open destination directory.\n");
        exit(1);
    }

    // loop through files in source directory
    struct dirent *src_dent;
    while ((src_dent = readdir(src_dir)) != NULL) {
        // ignore . and ..
        if (strcmp(src_dent->d_name, ".") == 0 || strcmp(src_dent->d_name, "..") == 0) {
            continue;
        }

        // construct file paths
        char src_path[512];
        char dest_path[512];
        sprintf(src_path, "%s/%s", argv[1], src_dent->d_name);
        sprintf(dest_path, "%s/%s", argv[2], src_dent->d_name);

        // check if file exists in destination directory
        struct stat st;
        if (stat(dest_path, &st) == 0) {
            // file exists in destination, compare last modified times
            int cmp_result = compare_files(src_path, dest_path);
            if (cmp_result == 1) {
                // source file is newer, sync files
                sync_files(src_path, dest_path);
                printf("Syncing %s to %s.\n", src_path, dest_path);
            }
        } else {
            // file does not exist in destination, sync files
            sync_files(src_path, dest_path);
            printf("Syncing %s to %s.\n", src_path, dest_path);
        }
    }

    // close directories
    closedir(src_dir);
    closedir(dest_dir);

    printf("Synchronization complete.\n");
    return 0;
}

// compare last modified times of two files
int compare_files(const char *file1, const char *file2) {
    struct stat st1;
    struct stat st2;
    stat(file1, &st1);
    stat(file2, &st2);
    if (difftime(st1.st_mtime, st2.st_mtime) > 0) {
        return 1;
    } else {
        return 0;
    }
}

// sync contents of one file to another
void sync_files(const char *src_file, const char *dest_file) {
    FILE *src_fp = fopen(src_file, "r");
    FILE *dest_fp = fopen(dest_file, "w");
    if (src_fp == NULL || dest_fp == NULL) {
        printf("Error: Could not open files for synchronization.\n");
        exit(1);
    }
    char buffer[512];
    while (fgets(buffer, sizeof(buffer), src_fp)) {
        fputs(buffer, dest_fp);
    }
    fclose(src_fp);
    fclose(dest_fp);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall compare_files(_QWORD, _QWORD); // weak
__int64 __fastcall sync_files(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall opendir(char *Path); // idb
__int64 __fastcall readdir(_QWORD); // weak
__int64 __fastcall closedir(void *Block); // idb
static int __cdecl stat(const char *const FileName, struct stat *const Stat);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  struct stat v4; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[512]; // [rsp+50h] [rbp-30h] BYREF
  char FileName[516]; // [rsp+250h] [rbp+1D0h] BYREF
  int v7; // [rsp+454h] [rbp+3D4h]
  __int64 v8; // [rsp+458h] [rbp+3D8h]
  void *v9; // [rsp+460h] [rbp+3E0h]
  void *Block; // [rsp+468h] [rbp+3E8h]

  _main(argc, argv, envp);
  if ( argc <= 2 )
  {
    printf("Usage: %s [source directory] [destination directory]\n", *argv);
    exit(1);
  }
  Block = (void *)opendir((char *)argv[1]);
  if ( !Block )
  {
    printf("Error: Could not open source directory.\n");
    exit(1);
  }
  v9 = (void *)opendir((char *)argv[2]);
  if ( !v9 )
  {
    printf("Error: Could not open destination directory.\n");
    exit(1);
  }
  while ( 1 )
  {
    v8 = readdir(Block);
    if ( !v8 )
      break;
    if ( strcmp((const char *)(v8 + 8), ".") )
    {
      if ( strcmp((const char *)(v8 + 8), "..") )
      {
        sprintf(Buffer, "%s/%s", argv[1], (const char *)(v8 + 8));
        sprintf(FileName, "%s/%s", argv[2], (const char *)(v8 + 8));
        if ( stat(FileName, &v4) || (v7 = compare_files(Buffer, FileName), v7 == 1) )
        {
          sync_files(Buffer, FileName);
          printf("Syncing %s to %s.\n", Buffer, FileName);
        }
      }
    }
  }
  closedir(Block);
  closedir(v9);
  printf("Synchronization complete.\n");
  return 0;
}
// 140001855: using guessed type __int64 __fastcall compare_files(_QWORD, _QWORD);
// 1400018AB: using guessed type __int64 __fastcall sync_files(_QWORD, _QWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002CA0: using guessed type __int64 __fastcall readdir(_QWORD);

// nfuncs=162 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: future-proof
#include<stdio.h>
#include<stdlib.h>

void printPattern(int n){
    int space = n-1;

    for(int i=0;i<n;i++){
        for(int j=0;j<space;j++){
            printf(" ");
        }

        for(int k=0;k<=i;k++){
            printf("%c ",65+k);
        }

        printf("\n");
        space--;
    }
    space = 1;
    for(int i=n-2;i>=0;i--){
        for(int j=0;j<space;j++){
            printf(" ");
        }

        for(int k=0;k<=i;k++){
            printf("%c ",65+k);
        }

        printf("\n");
        space++;
    }
}

int main(){
    int n = 5;
    printPattern(n);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall printPattern(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016A4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printPattern(5i64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printPattern(_QWORD);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Antivirus scanner ; Style: retro
#include <stdio.h>
#include <string.h>

// Main function
int main() {
    // Define variables
    char filename[20];
    char virus[5][20] = {"Trojan", "Worm", "Spyware", "Adware", "Malware"};
    int found = 0, i, j;
    
    // Ask for filename
    printf("Enter the filename to scan: ");
    scanf("%s", filename);
    
    // Open file
    FILE *file;
    file = fopen(filename,"r");
    
    // Check if file exists
    if(file == NULL) {
        printf("\nFile not found.\n");
        return 0;
    }
    
    // Read file content
    char line[100];
    while(fgets(line, 100, file) != NULL) {
        for(i = 0; i < 5; i++) {
            if(strstr(line, virus[i])) {
                printf("\nVirus found: %s\n", virus[i]);
                found = 1;
            }
        }
    }
    
    // Close file
    fclose(file);
    
    // If virus not found
    if(found == 0) {
        printf("\nNo viruses found in file.\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[112]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5[2]; // [rsp+90h] [rbp+10h] BYREF
  int v6; // [rsp+A0h] [rbp+20h]
  __int64 v7; // [rsp+A4h] [rbp+24h]
  __int64 v8; // [rsp+ACh] [rbp+2Ch]
  int v9; // [rsp+B4h] [rbp+34h]
  __int64 v10; // [rsp+B8h] [rbp+38h]
  __int64 v11; // [rsp+C0h] [rbp+40h]
  int v12; // [rsp+C8h] [rbp+48h]
  __int64 v13; // [rsp+CCh] [rbp+4Ch]
  __int64 v14; // [rsp+D4h] [rbp+54h]
  int v15; // [rsp+DCh] [rbp+5Ch]
  __int64 v16; // [rsp+E0h] [rbp+60h]
  __int64 v17; // [rsp+E8h] [rbp+68h]
  int v18; // [rsp+F0h] [rbp+70h]
  char FileName[32]; // [rsp+100h] [rbp+80h] BYREF
  FILE *Stream; // [rsp+120h] [rbp+A0h]
  int i; // [rsp+128h] [rbp+A8h]
  int v22; // [rsp+12Ch] [rbp+ACh]

  _main(argc, argv, envp);
  v5[0] = 0x6E616A6F7254i64;
  v5[1] = 0i64;
  v6 = 0;
  v7 = 1836216151i64;
  v8 = 0i64;
  v9 = 0;
  v10 = 0x65726177797053i64;
  v11 = 0i64;
  v12 = 0;
  v13 = 0x657261776441i64;
  v14 = 0i64;
  v15 = 0;
  v16 = 0x657261776C614Di64;
  v17 = 0i64;
  v18 = 0;
  v22 = 0;
  printf("Enter the filename to scan: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "r");
  if ( Stream )
  {
    while ( fgets(Str, 100, Stream) )
    {
      for ( i = 0; i <= 4; ++i )
      {
        if ( strstr(Str, (const char *)v5 + 20 * i) )
        {
          printf("\nVirus found: %s\n", (const char *)v5 + 20 * i);
          v22 = 1;
        }
      }
    }
    fclose(Stream);
    if ( !v22 )
      printf("\nNo viruses found in file.\n");
    return 0;
  }
  else
  {
    printf("\nFile not found.\n");
    return 0;
  }
}
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Math exercise ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int num1, num2, answer, userAnswer, count = 0;
    char operator;

    printf("\tWelcome to the Math Exercise Program!\n");
    printf("\t************************************\n\n");
    printf("This program will generate math exercises for you to solve.\n");

    while (count < 10) // Generate 10 exercises
    {
        // Generate random numbers and operators
        srand(time(NULL)); // Seed the random number generator
        num1 = rand() % 101; // Generate a number between 0 and 100
        num2 = rand() % 101;
        int operatorIndex = rand() % 4;
        if (operatorIndex == 0)
        {
            operator = '+';
            answer = num1 + num2;
        }
        else if (operatorIndex == 1)
        {
            operator = '-';
            answer = num1 - num2;
        }
        else if (operatorIndex == 2)
        {
            operator = '*';
            answer = num1 * num2;
        }
        else
        {
            operator = '/';
            answer = num1 / num2;
        }

        printf("\nExercise %d:\n", count + 1);
        printf("%d %c %d = ", num1, operator, num2);
        scanf("%d", &userAnswer);

        if (userAnswer == answer)
        {
            printf("Correct! Great job!\n");
        }
        else
        {
            printf("Incorrect. The correct answer is %d.\n", answer);
        }

        count++;
    }

    printf("\nCongratulations! You have completed all 10 exercises.\n");
    printf("Thanks for using the Math Exercise Program! Goodbye!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-1Ch] BYREF
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+2Ch] [rbp-14h]
  int v8; // [rsp+30h] [rbp-10h]
  char v9; // [rsp+37h] [rbp-9h]
  int v10; // [rsp+38h] [rbp-8h]
  unsigned int v11; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 0;
  printf("\tWelcome to the Math Exercise Program!\n");
  printf("\t************************************\n\n");
  printf("This program will generate math exercises for you to solve.\n");
  while ( v10 <= 9 )
  {
    v3 = time(0i64);
    srand(v3);
    v8 = rand() % 101;
    v7 = rand() % 101;
    v6 = rand() % 4;
    if ( v6 )
    {
      if ( v6 == 1 )
      {
        v9 = 45;
        v11 = v8 - v7;
      }
      else if ( v6 == 2 )
      {
        v9 = 42;
        v11 = v7 * v8;
      }
      else
      {
        v9 = 47;
        v11 = v8 / v7;
      }
    }
    else
    {
      v9 = 43;
      v11 = v8 + v7;
    }
    printf("\nExercise %d:\n", (unsigned int)(v10 + 1));
    printf("%d %c %d = ", (unsigned int)v8, (unsigned int)v9, (unsigned int)v7);
    scanf("%d", &v5);
    if ( v11 == v5 )
      printf("Correct! Great job!\n");
    else
      printf("Incorrect. The correct answer is %d.\n", v11);
    ++v10;
  }
  printf("\nCongratulations! You have completed all 10 exercises.\n");
  printf("Thanks for using the Math Exercise Program! Goodbye!\n");
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Linked list operations ; Style: Ada Lovelace
#include <stdio.h>
#include <stdlib.h>

typedef struct node Node;

struct node
{
    int data;
    Node *next;
};

Node *createNode(int);
void insertAtBeginning(Node **, int);
void insertAtEnd(Node **, int);
void insertAtPosition(Node **, int, int);
void deleteAtBeginning(Node **);
void deleteAtEnd(Node **);
void deleteAtPosition(Node **, int);
void traverseList(Node *);

int main()
{
    Node *head = NULL;
    int choice, position, data;

    do
    {
        printf("\n================================\n");
        printf(" Linked List Operations\n");
        printf("================================\n");
        printf("1. Insert at beginning\n");
        printf("2. Insert at end\n");
        printf("3. Insert at a position\n");
        printf("4. Delete at beginning\n");
        printf("5. Delete at end\n");
        printf("6. Delete at a position\n");
        printf("7. Traverse the list\n");
        printf("8. Exit\n");
        printf("\nEnter your choice: ");

        scanf("%d", &choice);

        switch(choice)
        {
            case 1:
                printf("\nEnter data to be inserted at the beginning: ");
                scanf("%d", &data);
                insertAtBeginning(&head, data);
                break;
            case 2:
                printf("\nEnter data to be inserted at the end: ");
                scanf("%d", &data);
                insertAtEnd(&head, data);
                break;
            case 3:
                printf("\nEnter data to be inserted: ");
                scanf("%d", &data);
                printf("Enter position: ");
                scanf("%d", &position);
                insertAtPosition(&head, data, position);
                break;
            case 4:
                deleteAtBeginning(&head);
                break;
            case 5:
                deleteAtEnd(&head);
                break;
            case 6:
                printf("\nEnter the position of the node to be deleted: ");
                scanf("%d", &position);
                deleteAtPosition(&head, position);
                break;
            case 7:
                traverseList(head);
                break;
            case 8:
                printf("\nExiting the program...\n");
                exit(0);
            default:
                printf("\nInvalid choice, please try again...\n");
        }
    } while (choice != 8);

    return 0;
}

Node *createNode(int data)
{
    Node *newNode = (Node *) malloc(sizeof(Node));

    if (newNode == NULL)
    {
        printf("\nMemory allocation failed, exiting program...\n");
        exit(1);
    }

    newNode->data = data;
    newNode->next = NULL;

    return newNode;
}

void insertAtBeginning(Node **head, int data)
{
    Node *newNode = createNode(data);

    if (*head == NULL)
    {
        *head = newNode;
        return;
    }

    newNode->next = *head;
    *head = newNode;
}

void insertAtEnd(Node **head, int data)
{
    Node *newNode = createNode(data);
    Node *temp = *head;

    if (*head == NULL)
    {
        *head = newNode;
        return;
    }

    while (temp->next != NULL)
        temp = temp->next;

    temp->next = newNode;
}

void insertAtPosition(Node **head, int data, int position)
{
    if (position < 1)
    {
        printf("Invalid position, please try again...\n");
        return;
    }

    if (position == 1)
    {
        insertAtBeginning(head, data);
        return;
    }

    Node *newNode = createNode(data);
    Node *temp = *head;

    for (int i = 1; i < position - 1 && temp != NULL; i++)
        temp = temp->next;

    if (temp == NULL)
    {
        printf("Invalid position, please try again...\n");
        return;
    }

    newNode->next = temp->next;
    temp->next = newNode;
}

void deleteAtBeginning(Node **head)
{
    if (*head == NULL)
    {
        printf("\nList is empty, nothing to delete...\n");
        return;
    }

    Node *temp = *head;

    *head = (*head)->next;
    free(temp);

    printf("\nNode deleted successfully...\n");
}

void deleteAtEnd(Node **head)
{
    if (*head == NULL)
    {
        printf("\nList is empty, nothing to delete...\n");
        return;
    }

    Node *temp = *head;

    if ((*head)->next == NULL)
    {
        *head = NULL;
        free(temp);

        printf("\nNode deleted successfully...\n");
        return;
    }

    while (temp->next->next != NULL)
        temp = temp->next;

    free(temp->next);
    temp->next = NULL;

    printf("\nNode deleted successfully...\n");
}

void deleteAtPosition(Node **head, int position)
{
    if (*head == NULL)
    {
        printf("\nList is empty, nothing to delete...\n");
        return;
    }

    if (position < 1)
    {
        printf("\nInvalid position, please try again...\n");
        return;
    }

    Node *temp = *head;

    if (position == 1)
    {
        *head = (*head)->next;
        free(temp);

        printf("\nNode deleted successfully...\n");
        return;
    }

    for (int i = 1; i < position - 1 && temp != NULL; i++)
        temp = temp->next;

    if (temp == NULL || temp->next == NULL)
    {
        printf("\nInvalid position, please try again...\n");
        return;
    }

    Node *nodeToDelete = temp->next;
    temp->next = nodeToDelete->next;
    free(nodeToDelete);

    printf("\nNode deleted successfully...\n");
}

void traverseList(Node *head)
{
    if (head == NULL)
    {
        printf("\nList is empty...\n");
        return;
    }

    printf("\nThe list is: ");
    Node *temp = head;

    while (temp != NULL)
    {
        printf("%d ", temp->data);
        temp = temp->next;
    }

    printf("\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall insertAtBeginning(_QWORD, _QWORD); // weak
__int64 __fastcall insertAtEnd(_QWORD, _QWORD); // weak
__int64 __fastcall insertAtPosition(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall deleteAtBeginning(_QWORD); // weak
__int64 __fastcall deleteAtEnd(_QWORD); // weak
__int64 __fastcall deleteAtPosition(_QWORD, _QWORD); // weak
__int64 __fastcall traverseList(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v5; // [rsp+30h] [rbp-10h] BYREF
  int v6; // [rsp+34h] [rbp-Ch] BYREF
  __int64 v7; // [rsp+38h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v7 = 0i64;
  do
  {
    printf("\n================================\n");
    printf(" Linked List Operations\n");
    printf("================================\n");
    printf("1. Insert at beginning\n");
    printf("2. Insert at end\n");
    printf("3. Insert at a position\n");
    printf("4. Delete at beginning\n");
    printf("5. Delete at end\n");
    printf("6. Delete at a position\n");
    printf("7. Traverse the list\n");
    printf("8. Exit\n");
    printf("\nEnter your choice: ");
    scanf("%d", &v6);
    switch ( v6 )
    {
      case 1:
        printf("\nEnter data to be inserted at the beginning: ");
        scanf("%d", &v4);
        insertAtBeginning(&v7, v4);
        break;
      case 2:
        printf("\nEnter data to be inserted at the end: ");
        scanf("%d", &v4);
        insertAtEnd(&v7, v4);
        break;
      case 3:
        printf("\nEnter data to be inserted: ");
        scanf("%d", &v4);
        printf("Enter position: ");
        scanf("%d", &v5);
        insertAtPosition(&v7, v4, v5);
        break;
      case 4:
        deleteAtBeginning(&v7);
        break;
      case 5:
        deleteAtEnd(&v7);
        break;
      case 6:
        printf("\nEnter the position of the node to be deleted: ");
        scanf("%d", &v5);
        deleteAtPosition(&v7, v5);
        break;
      case 7:
        traverseList(v7);
        break;
      case 8:
        printf("\nExiting the program...\n");
        exit(0);
      default:
        printf("\nInvalid choice, please try again...\n");
        break;
    }
  }
  while ( v6 != 8 );
  return 0;
}
// 1400018BC: using guessed type __int64 __fastcall insertAtBeginning(_QWORD, _QWORD);
// 140001912: using guessed type __int64 __fastcall insertAtEnd(_QWORD, _QWORD);
// 14000197E: using guessed type __int64 __fastcall insertAtPosition(_QWORD, _QWORD, _QWORD);
// 140001A3F: using guessed type __int64 __fastcall deleteAtBeginning(_QWORD);
// 140001AA7: using guessed type __int64 __fastcall deleteAtEnd(_QWORD);
// 140001B65: using guessed type __int64 __fastcall deleteAtPosition(_QWORD, _QWORD);
// 140001C7F: using guessed type __int64 __fastcall traverseList(_QWORD);
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Ebook reader ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//Structure for book information
struct Book {
    char title[100];
    char author[100];
    int pageCount;
    float price;
};

//Structure for page information
struct Page {
    int pageNumber;
    char content[1000];
};

//Structure for Ebook information
struct Ebook {
    struct Book book;
    int currentPage;
    struct Page *pages;
};

//Function to read ebook information from file
void readEbookFromFile(struct Ebook *ebook, char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("Could not open file %s\n", filename);
        exit(1);
    }

    //Read book information
    fscanf(file, "%s", ebook->book.title);
    fscanf(file, "%s", ebook->book.author);
    fscanf(file, "%d", &ebook->book.pageCount);
    fscanf(file, "%f", &ebook->book.price);

    //Allocate memory for pages
    ebook->pages = (struct Page *) malloc(ebook->book.pageCount * sizeof(struct Page));

    //Read page information
    int i;
    for (i = 0; i < ebook->book.pageCount; i++) {
        fscanf(file, "%d", &ebook->pages[i].pageNumber);
        fgets(ebook->pages[i].content, 1000, file);
    }

    fclose(file);
}

//Function to display ebook information
void displayEbook(struct Ebook ebook) {
    printf("Title: %s\n", ebook.book.title);
    printf("Author: %s\n", ebook.book.author);
    printf("Page count: %d\n", ebook.book.pageCount);
    printf("Price: %.2f\n", ebook.book.price);
    printf("Current page: %d\n", ebook.currentPage);
    printf("Content: %s\n", ebook.pages[ebook.currentPage - 1].content);
}

int main() {
    struct Ebook ebook;
    char filename[] = "ebook.txt";
    readEbookFromFile(&ebook, filename);

    //Start reading from first page
    ebook.currentPage = 1;

    //Display ebook information
    displayEbook(ebook);

    //Read pages until end of book is reached
    printf("Press enter key to continue reading...");
    while (ebook.currentPage <= ebook.book.pageCount) {
        getchar();

        //Move to next page
        ebook.currentPage++;

        //Display ebook information
        displayEbook(ebook);

        //If end of book is reached, break out of loop
        if (ebook.currentPage > ebook.book.pageCount) {
            break;
        }

        printf("Press enter key to continue reading...");
    }

    free(ebook.pages);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall readEbookFromFile(_QWORD, _QWORD); // weak
__int64 __fastcall displayEbook(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();
// void __cdecl free(void *Block);


//----- (0000000140001829) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5; // [rsp+28h] [rbp-58h]
  __int64 v6; // [rsp+30h] [rbp-50h]
  __int64 v7; // [rsp+38h] [rbp-48h]
  __int64 v8; // [rsp+40h] [rbp-40h]
  __int64 v9; // [rsp+48h] [rbp-38h]
  __int64 v10; // [rsp+50h] [rbp-30h]
  __int64 v11; // [rsp+58h] [rbp-28h]
  __int64 v12; // [rsp+60h] [rbp-20h]
  __int64 v13; // [rsp+68h] [rbp-18h]
  __int64 v14; // [rsp+70h] [rbp-10h]
  __int64 v15; // [rsp+78h] [rbp-8h]
  __int64 v16; // [rsp+80h] [rbp+0h]
  __int64 v17; // [rsp+88h] [rbp+8h]
  __int64 v18; // [rsp+90h] [rbp+10h]
  __int64 v19; // [rsp+98h] [rbp+18h]
  __int64 v20; // [rsp+A0h] [rbp+20h]
  __int64 v21; // [rsp+A8h] [rbp+28h]
  __int64 v22; // [rsp+B0h] [rbp+30h]
  __int64 v23; // [rsp+B8h] [rbp+38h]
  __int64 v24; // [rsp+C0h] [rbp+40h]
  __int64 v25; // [rsp+C8h] [rbp+48h]
  __int64 v26; // [rsp+D0h] [rbp+50h]
  __int64 v27; // [rsp+D8h] [rbp+58h]
  __int64 v28; // [rsp+E0h] [rbp+60h]
  __int64 v29; // [rsp+E8h] [rbp+68h]
  __int64 v30; // [rsp+F0h] [rbp+70h]
  void *v31; // [rsp+F8h] [rbp+78h]
  _WORD v32[9]; // [rsp+106h] [rbp+86h] BYREF
  __int64 v33; // [rsp+118h] [rbp+98h]
  __int64 v34; // [rsp+120h] [rbp+A0h]
  __int64 v35; // [rsp+128h] [rbp+A8h]
  __int64 v36; // [rsp+130h] [rbp+B0h]
  __int64 v37; // [rsp+138h] [rbp+B8h]
  __int64 v38; // [rsp+140h] [rbp+C0h]
  __int64 v39; // [rsp+148h] [rbp+C8h]
  __int64 v40; // [rsp+150h] [rbp+D0h]
  __int64 v41; // [rsp+158h] [rbp+D8h]
  __int64 v42; // [rsp+160h] [rbp+E0h]
  __int64 v43; // [rsp+168h] [rbp+E8h]
  __int64 v44; // [rsp+170h] [rbp+F0h]
  __int64 v45; // [rsp+178h] [rbp+F8h]
  __int64 v46; // [rsp+180h] [rbp+100h]
  __int64 v47; // [rsp+188h] [rbp+108h]
  __int64 v48; // [rsp+190h] [rbp+110h]
  __int64 v49; // [rsp+198h] [rbp+118h]
  __int64 v50; // [rsp+1A0h] [rbp+120h]
  __int64 v51; // [rsp+1A8h] [rbp+128h]
  __int64 v52; // [rsp+1B0h] [rbp+130h]
  __int64 v53; // [rsp+1B8h] [rbp+138h]
  __int64 v54; // [rsp+1C0h] [rbp+140h]
  __int64 v55; // [rsp+1C8h] [rbp+148h]
  __int64 v56; // [rsp+1D0h] [rbp+150h]
  __int64 v57; // [rsp+1D8h] [rbp+158h]
  __int64 v58; // [rsp+1E0h] [rbp+160h]
  void *Block; // [rsp+1E8h] [rbp+168h]

  _main(argc, argv, envp);
  strcpy((char *)v32, "ebook.txt");
  readEbookFromFile(&v32[5], v32);
  LODWORD(v58) = 1;
  v4 = *(_QWORD *)&v32[5];
  v5 = v33;
  v6 = v34;
  v7 = v35;
  v8 = v36;
  v9 = v37;
  v10 = v38;
  v11 = v39;
  v12 = v40;
  v13 = v41;
  v14 = v42;
  v15 = v43;
  v16 = v44;
  v17 = v45;
  v18 = v46;
  v19 = v47;
  v20 = v48;
  v21 = v49;
  v22 = v50;
  v23 = v51;
  v24 = v52;
  v25 = v53;
  v26 = v54;
  v27 = v55;
  v28 = v56;
  v29 = v57;
  v30 = v58;
  v31 = Block;
  displayEbook(&v4);
  printf("Press enter key to continue reading...");
  while ( (int)v58 <= (int)v57 )
  {
    getchar();
    LODWORD(v58) = v58 + 1;
    v4 = *(_QWORD *)&v32[5];
    v5 = v33;
    v6 = v34;
    v7 = v35;
    v8 = v36;
    v9 = v37;
    v10 = v38;
    v11 = v39;
    v12 = v40;
    v13 = v41;
    v14 = v42;
    v15 = v43;
    v16 = v44;
    v17 = v45;
    v18 = v46;
    v19 = v47;
    v20 = v48;
    v21 = v49;
    v22 = v50;
    v23 = v51;
    v24 = v52;
    v25 = v53;
    v26 = v54;
    v27 = v55;
    v28 = v56;
    v29 = v57;
    v30 = v58;
    v31 = Block;
    displayEbook(&v4);
    if ( (int)v58 > (int)v57 )
      break;
    printf("Press enter key to continue reading...");
  }
  free(Block);
  return 0;
}
// 1400015D4: using guessed type __int64 __fastcall readEbookFromFile(_QWORD, _QWORD);
// 140001759: using guessed type __int64 __fastcall displayEbook(_QWORD);
// 140001C30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Remote control Vehicle Simulation ; Style: enthusiastic
#include <stdio.h>

// Define the functions for each direction of the remote control vehicle
void moveForward() {
   printf("Moving forward!\n");
}

void moveBackward() {
   printf("Moving backward!\n");
}

void turnLeft() {
   printf("Turning left!\n");
}

void turnRight() {
   printf("Turning right!\n");
}

int main() {
   // Printing the welcome message
   printf("Welcome to the Remote Control Vehicle Simulation!\n");
   
   // Prompting the user for input
   printf("Please enter a direction (forward, backward, left, right): ");
   
   // Taking the user input
   char direction[10];
   scanf("%s", direction);
   
   // Applying the user input and call corresponding functions
   if (strcmp(direction, "forward") == 0) {
      moveForward();
   } else if (strcmp(direction, "backward") == 0) {
      moveBackward();
   } else if (strcmp(direction, "left") == 0) {
      turnLeft();
   } else if (strcmp(direction, "right") == 0) {
      turnRight();
   } else {
      // Handling unexpected input by printing an error message
      printf("Error: Invalid direction\n");
   }
   
   // Printing the goodbye message
   printf("Thank you for using the Remote Control Vehicle Simulation!\n");
   
   // End of program
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 moveForward(void); // weak
__int64 moveBackward(void); // weak
__int64 turnLeft(void); // weak
__int64 turnRight(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (000000014000165A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[10]; // [rsp+26h] [rbp-Ah] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Remote Control Vehicle Simulation!\n");
  printf("Please enter a direction (forward, backward, left, right): ");
  scanf("%s", Str1);
  if ( !strcmp(Str1, "forward") )
  {
    moveForward();
  }
  else if ( !strcmp(Str1, "backward") )
  {
    moveBackward();
  }
  else if ( !strcmp(Str1, "left") )
  {
    turnLeft();
  }
  else if ( !strcmp(Str1, "right") )
  {
    turnRight();
  }
  else
  {
    printf("Error: Invalid direction\n");
  }
  printf("Thank you for using the Remote Control Vehicle Simulation!\n");
  return 0;
}
// 1400015E2: using guessed type __int64 moveForward(void);
// 140001600: using guessed type __int64 moveBackward(void);
// 14000161E: using guessed type __int64 turnLeft(void);
// 14000163C: using guessed type __int64 turnRight(void);
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Hexadecimal Converter ; Style: high level of detail
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

// Function to convert decimal number to hexadecimal number
void decimalToHexadecimal(int num) {
    char hex[100];
    int i = 0, rem;
    while (num != 0) {
        rem = num % 16;
        if (rem < 10) {
            hex[i++] = rem + 48;
        } else {
            hex[i++] = rem + 55;
        }
        num /= 16;
    }

    printf("Hexadecimal number is: ");
    for (int j = i - 1; j >= 0; j--) {
        printf("%c", hex[j]);
    }
}

// Function to convert hexadecimal number to decimal number
int hexadecimalToDecimal(char *hex) {
    int decimal = 0, len = strlen(hex), base = 1;

    for (int i = len - 1; i >= 0; i--) {
        if (hex[i] >= '0' && hex[i] <= '9') {
            decimal += (hex[i] - 48) * base;
            base *= 16;
        } else if (hex[i] >= 'A' && hex[i] <= 'F') {
            decimal += (hex[i] - 55) * base;
            base *= 16;
        }
    }

    return decimal;
}

int main() {
    int choice;

    do {
        printf("1. Decimal to Hexadecimal Conversion\n");
        printf("2. Hexadecimal to Decimal Conversion\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                int decimal;
                printf("\nEnter decimal number: ");
                scanf("%d", &decimal);
                decimalToHexadecimal(decimal);
                printf("\n\n");
                break;
            case 2:
                char hex[100];
                printf("\nEnter hexadecimal number: ");
                scanf("%s", hex);
                printf("Decimal number is: %d\n\n", hexadecimalToDecimal(hex));
                break;
            case 3:
                printf("Thank you for using Hexadecimal Converter!\n\n");
                exit(0);
            default:
                printf("Invalid choice!\n\n");
        }
    } while (choice != 3);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall decimalToHexadecimal(_QWORD); // weak
__int64 __fastcall hexadecimalToDecimal(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001783) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[104]; // [rsp+20h] [rbp-70h] BYREF
  unsigned int v6; // [rsp+88h] [rbp-8h] BYREF
  int v7; // [rsp+8Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("1. Decimal to Hexadecimal Conversion\n");
    printf("2. Hexadecimal to Decimal Conversion\n");
    printf("3. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v7);
    if ( v7 == 3 )
    {
      printf("Thank you for using Hexadecimal Converter!\n\n");
      exit(0);
    }
    if ( v7 > 3 )
      goto LABEL_10;
    if ( v7 == 1 )
    {
      printf("\nEnter decimal number: ");
      scanf("%d", &v6);
      decimalToHexadecimal(v6);
      printf("\n\n");
      continue;
    }
    if ( v7 == 2 )
    {
      printf("\nEnter hexadecimal number: ");
      scanf("%s", v5);
      v3 = hexadecimalToDecimal(v5);
      printf("Decimal number is: %d\n\n", v3);
    }
    else
    {
LABEL_10:
      printf("Invalid choice!\n\n");
    }
  }
  while ( v7 != 3 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall decimalToHexadecimal(_QWORD);
// 1400016A4: using guessed type __int64 __fastcall hexadecimalToDecimal(_QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Checkers Game ; Style: authentic
#include <stdio.h>

//Function to print the checkerboard
void print_board(int board[8][8])
{
    printf("  1 2 3 4 5 6 7 8\n");
    printf("------------------\n");
    for (int i = 0; i < 8; i++)
    {
        printf("%d|", i + 1);
        for (int j = 0; j < 8; j++)
        {
            if (board[i][j] == 0)
            {
                printf("  ");
            }
            else if (board[i][j] == 1)
            {
                printf("x ");
            }
            else if (board[i][j] == 2)
            {
                printf("o ");
            }
        }
        printf("|%d\n", i + 1);
    }
    printf("------------------\n");
    printf("  1 2 3 4 5 6 7 8\n");
}

//Function to check if a move is valid
int is_valid_move(int board[8][8], int current_player, int row1, int col1, int row2, int col2)
{
    if (row2 < 0 || row2 > 7 || col2 < 0 || col2 > 7)
    {
        return 0;
    }
    if (board[row2][col2] != 0)
    {
        return 0;
    }
    if (current_player == 1)
    {
        if (row2 != row1 - 1 || (col2 != col1 - 1 && col2 != col1 + 1))
        {
            if (row1-row2 == 2 && (col1-col2 == 2 || col2-col1 == 2)) {
                if (board[row1-1][(col1+col2)/2] == 2) {
                    board[row1-1][(col1+col2)/2] = 0;
                    return 1;
                }
                return 0;
            }
            return 0;
        }
    }
    else
    {
        if (row2 != row1 + 1 || (col2 != col1 - 1 && col2 != col1 + 1))
        {
            if (row2-row1 == 2 && (col1-col2 == 2 || col2-col1 == 2)) {
                if (board[row1+1][(col1+col2)/2] == 1) {
                    board[row1+1][(col1+col2)/2] = 0;
                    return 1;
                }
                return 0;
            }
            return 0;
        }
    }
    return 1;
}

//Function to check if the game is over
int is_game_over(int board[8][8])
{
    int x_count = 0, o_count = 0;
    for (int i = 0; i < 8; i++)
    {
        for (int j = 0; j < 8; j++)
        {
            if (board[i][j] == 1)
            {
                x_count++;
            }
            else if (board[i][j] == 2)
            {
                o_count++;
            }
        }
    }
    if (x_count == 0 || o_count == 0)
    {
        return 1;
    }
    return 0;
}

int main()
{
    //Initialize the board
    int board[8][8] = {{0, 2, 0, 2, 0, 2, 0, 2},
                       {2, 0, 2, 0, 2, 0, 2, 0},
                       {0, 2, 0, 2, 0, 2, 0, 2},
                       {0, 0, 0, 0, 0, 0, 0, 0},
                       {0, 0, 0, 0, 0, 0, 0, 0},
                       {1, 0, 1, 0, 1, 0, 1, 0},
                       {0, 1, 0, 1, 0, 1, 0, 1},
                       {1, 0, 1, 0, 1, 0, 1, 0}};

    int current_player = 1;
    int game_over = 0;
    int row1, col1, row2, col2;

    printf("Welcome to Checkers!\n\n");

    while (!game_over)
    {
        printf("Player %d's Turn:\n", current_player);

        print_board(board);

        printf("Enter the row and column of the checker you want to move: ");
        scanf("%d %d", &row1, &col1);

        printf("Enter the row and column of the location you want to move the checker to: ");
        scanf("%d %d", &row2, &col2);

        if (is_valid_move(board, current_player, row1 - 1, col1 - 1, row2 - 1, col2 - 1))
        {
            board[row2 - 1][col2 - 1] = board[row1 - 1][col1 - 1];
            board[row1 - 1][col1 - 1] = 0;
            if (current_player == 1 && row2 == 1 || current_player == 2 && row2 == 8) {
                board[row2 - 1][col2 - 1] = current_player + 2;
            }
            if (!is_game_over(board)) {
                current_player = (current_player == 1) ? 2 : 1;
            }
        }
        else
        {
            printf("Invalid move. Try again.\n");
        }

        game_over = is_game_over(board);
    }

    print_board(board);

    if (current_player == 1)
    {
        printf("Player 2 wins!\n");
    }
    else
    {
        printf("Player 1 wins!\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall print_board(_QWORD); // weak
__int64 __fastcall is_valid_move(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
__int64 __fastcall is_game_over(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400019C9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+30h] [rbp-50h] BYREF
  int v6; // [rsp+34h] [rbp-4Ch] BYREF
  int v7; // [rsp+38h] [rbp-48h] BYREF
  int v8; // [rsp+3Ch] [rbp-44h] BYREF
  int v9[66]; // [rsp+40h] [rbp-40h] BYREF
  int v10; // [rsp+148h] [rbp+C8h]
  unsigned int v11; // [rsp+14Ch] [rbp+CCh]

  _main(argc, argv, envp);
  v9[0] = 0;
  v9[1] = 2;
  v9[2] = 0;
  v9[3] = 2;
  v9[4] = 0;
  v9[5] = 2;
  v9[6] = 0;
  v9[7] = 2;
  v9[8] = 2;
  v9[9] = 0;
  v9[10] = 2;
  v9[11] = 0;
  v9[12] = 2;
  v9[13] = 0;
  v9[14] = 2;
  v9[15] = 0;
  v9[16] = 0;
  v9[17] = 2;
  v9[18] = 0;
  v9[19] = 2;
  v9[20] = 0;
  v9[21] = 2;
  v9[22] = 0;
  v9[23] = 2;
  memset(&v9[24], 0, 64);
  v9[40] = 1;
  v9[41] = 0;
  v9[42] = 1;
  v9[43] = 0;
  v9[44] = 1;
  v9[45] = 0;
  v9[46] = 1;
  v9[47] = 0;
  v9[48] = 0;
  v9[49] = 1;
  v9[50] = 0;
  v9[51] = 1;
  v9[52] = 0;
  v9[53] = 1;
  v9[54] = 0;
  v9[55] = 1;
  v9[56] = 1;
  v9[57] = 0;
  v9[58] = 1;
  v9[59] = 0;
  v9[60] = 1;
  v9[61] = 0;
  v9[62] = 1;
  v9[63] = 0;
  v11 = 1;
  v10 = 0;
  printf("Welcome to Checkers!\n\n");
  while ( !v10 )
  {
    printf("Player %d's Turn:\n", v11);
    print_board(v9);
    printf("Enter the row and column of the checker you want to move: ");
    scanf("%d %d", &v8, &v7);
    printf("Enter the row and column of the location you want to move the checker to: ");
    scanf("%d %d", &v6, &v5);
    if ( (unsigned int)is_valid_move((unsigned int)v9, v11, v8 - 1, v7 - 1, v6 - 1, v5 - 1) )
    {
      v9[8 * v6 - 9 + v5] = v9[8 * v8 - 9 + v7];
      v9[8 * v8 - 9 + v7] = 0;
      if ( v11 == 1 && v6 == 1 || v11 == 2 && v6 == 8 )
        v9[8 * v6 - 9 + v5] = v11 + 2;
      if ( !(unsigned int)is_game_over(v9) )
      {
        if ( v11 == 1 )
          v3 = 2;
        else
          v3 = 1;
        v11 = v3;
      }
    }
    else
    {
      printf("Invalid move. Try again.\n");
    }
    v10 = is_game_over(v9);
  }
  print_board(v9);
  if ( v11 == 1 )
    printf("Player 2 wins!\n");
  else
    printf("Player 1 wins!\n");
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall print_board(_QWORD);
// 140001723: using guessed type __int64 __fastcall is_valid_move(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001921: using guessed type __int64 __fastcall is_game_over(_QWORD);
// 140001EB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Typing Speed Test ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

int main()
{
    int n;
    printf("Enter the length of the string: ");
    scanf("%d", &n);

    char str[n+1], compare_str[n+1];
    int i;
    for(i=0;i<n;i++){
        str[i] = (rand()%26)+'a';
    }
    str[i] = '\0';
    printf("Type the following string:\n%s\n", str);

    clock_t t;
    t = clock();

    scanf("%s", compare_str);

    t = clock() - t;
    double time_taken = ((double)t)/CLOCKS_PER_SEC;

    int flg = strcmp(str, compare_str);
    if(!flg){
        printf("Matching strings!!\n");
        double typing_speed = n/(time_taken/60);
        printf("Congratulations! You have typed at a speed of %.2f words per minute.\n", typing_speed);
    }
    else{
        printf("Oops! Strings do not match.\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// int __cdecl rand();
// clock_t __cdecl clock();


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  void *v4; // rsp
  __int64 v6[2]; // [rsp+20h] [rbp-60h] BYREF
  int v7; // [rsp+34h] [rbp-4Ch] BYREF
  double v8; // [rsp+38h] [rbp-48h]
  double v10; // [rsp+48h] [rbp-38h]
  clock_t v11; // [rsp+54h] [rbp-2Ch]
  char *Str2; // [rsp+58h] [rbp-28h]
  __int64 v13; // [rsp+60h] [rbp-20h]
  char *Str1; // [rsp+68h] [rbp-18h]
  __int64 v15; // [rsp+70h] [rbp-10h]
  int i; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the length of the string: ");
  scanf("%d", &v7);
  v15 = v7 + 1 - 1i64;
  v6[0] = v7 + 1;
  v6[1] = 0i64;
  v3 = alloca(16 * ((unsigned __int64)(v6[0] + 15) >> 4));
  Str1 = (char *)v6;
  v13 = v15;
  v4 = alloca(16 * ((unsigned __int64)(v6[0] + 15) >> 4));
  Str2 = (char *)v6;
  for ( i = 0; i < v7; ++i )
    Str1[i] = rand() % 26 + 97;
  Str1[i] = 0;
  printf("Type the following string:\n%s\n", Str1);
  v11 = clock();
  scanf("%s", Str2);
  v11 = clock() - v11;
  v10 = (double)v11 / 1000.0;
  if ( strcmp(Str1, Str2) )
  {
    printf("Oops! Strings do not match.\n");
  }
  else
  {
    printf("Matching strings!!\n");
    v8 = (double)v7 / (v10 / 60.0);
    printf("Congratulations! You have typed at a speed of %.2f words per minute.\n", v8);
  }
  return 0;
}
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>

int main() {
    
    // Allocate space for an array of size 10 integers
    int* nums = (int*)malloc(10 * sizeof(int));
    
    if(nums == NULL) {
        printf("Could not allocate memory");
        return 0;
    }
    
    // Initialize array with ascending values
    for(int i=0; i<10; i++) {
        nums[i] = i;
    }
    
    // Print array values
    printf("Array values: ");
    for(int i=0; i<10; i++) {
        printf("%d ", nums[i]);
    }
    printf("\n");
    
    // Resize array in memory
    nums = (int*)realloc(nums, 15 * sizeof(int));
    
    if(nums == NULL) {
        printf("Could not reallocate memory");
        return 0;
    }
    
    // Initialize new values in the array
    for(int i=10; i<15; i++) {
        nums[i] = i;
    }
    
    // Print updated array values
    printf("Updated array values: ");
    for(int i=0; i<15; i++) {
        printf("%d ", nums[i]);
    }
    printf("\n");
    
    // Free allocated memory
    free(nums);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _DWORD *Block; // [rsp+28h] [rbp-18h]
  _DWORD *Blocka; // [rsp+28h] [rbp-18h]
  int m; // [rsp+30h] [rbp-10h]
  int k; // [rsp+34h] [rbp-Ch]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  Block = malloc(0x28ui64);
  if ( Block )
  {
    for ( i = 0; i <= 9; ++i )
      Block[i] = i;
    printf("Array values: ");
    for ( j = 0; j <= 9; ++j )
      printf("%d ", (unsigned int)Block[j]);
    printf("\n");
    Blocka = realloc(Block, 0x3Cui64);
    if ( Blocka )
    {
      for ( k = 10; k <= 14; ++k )
        Blocka[k] = k;
      printf("Updated array values: ");
      for ( m = 0; m <= 14; ++m )
        printf("%d ", (unsigned int)Blocka[m]);
      printf("\n");
      free(Blocka);
      return 0;
    }
    else
    {
      printf("Could not reallocate memory");
      return 0;
    }
  }
  else
  {
    printf("Could not allocate memory");
    return 0;
  }
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: excited
#include <stdio.h>
#include <stdlib.h>

/* This is the most exciting circuit simulator program ever!
 * With this incredible program, you can simulate all kinds
 * of circuits and watch the magic happen before your very eyes!
 * It's like being a magician, but with electricity instead of rabbits!
 * Here's how it works:
 */

#define MAX_NODES 100
#define MAX_ELEMENTS 200

/* First, we set up the variables that we will need. */

typedef struct {
    int node1;
    int node2;
    double value;
} element;

int num_nodes, num_elements;

double G[MAX_NODES][MAX_NODES];
double b[MAX_NODES];
double x[MAX_NODES];
element e_list[MAX_ELEMENTS];

/* Then we define the main function, which will do all the work. */

int main() {
    /* First we read in all the values from the user. */
    printf("How many nodes does your circuit have? ");
    scanf("%d", &num_nodes);
    printf("How many elements does your circuit have? ");
    scanf("%d", &num_elements);
    printf("Now enter the values for each element.\n");
    for (int i = 0; i < num_elements; i++) {
        printf("Element %d: ", i + 1);
        scanf("%d %d %lf", &e_list[i].node1, &e_list[i].node2, &e_list[i].value);
    }
    /* Then we set up the matrices that we will need. */
    for (int i = 0; i < num_elements; i++) {
        G[e_list[i].node1][e_list[i].node2] += 1 / e_list[i].value;
        G[e_list[i].node2][e_list[i].node1] += 1 / e_list[i].value;
    }
    for (int i = 0; i < num_nodes; i++) {
        for (int j = 0; j < num_nodes; j++) {
            if (i == j) {
                G[i][i] = -1;
            }
        }
    }
    b[num_nodes - 1] = -1;
    /* Then we solve the matrix equation using Gauss-Jordan elimination. */
    for (int i = 0; i < num_nodes - 1; i++) {
        for (int j = i + 1; j < num_nodes; j++) {
            double ratio = G[j][i] / G[i][i];
            for (int k = i; k < num_nodes; k++) {
                G[j][k] -= ratio * G[i][k];
            }
            b[j] -= ratio * b[i];
        }
    }
    for (int i = num_nodes - 1; i >= 0; i--) {
        double sum = 0;
        for (int j = i + 1; j < num_nodes; j++) {
            sum += G[i][j] * x[j];
        }
        x[i] = (b[i] - sum) / G[i][i];
    }
    /* Finally we print out the results. */
    printf("The voltage at each node in the circuit is:\n");
    for (int i = 0; i < num_nodes; i++) {
        printf("Node %d: %lf\n", i + 1, x[i]);
    }
    printf("Thank you for using the most exciting circuit simulator program ever!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

int num_nodes; // weak
int num_elements; // weak
double G[10000]; // weak
double b[100]; // weak
double x[100]; // weak
_UNKNOWN e_list; // weak
_UNKNOWN unk_14002CF24; // weak
double dbl_14002CF28[399]; // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+28h] [rbp-38h]
  int mm; // [rsp+30h] [rbp-30h]
  int v6[3]; // [rsp+34h] [rbp-2Ch]
  int kk; // [rsp+40h] [rbp-20h]
  int jj; // [rsp+44h] [rbp-1Ch]
  int ii; // [rsp+48h] [rbp-18h]
  int n; // [rsp+4Ch] [rbp-14h]
  int m; // [rsp+50h] [rbp-10h]
  int k; // [rsp+54h] [rbp-Ch]
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("How many nodes does your circuit have? ");
  scanf("%d", &num_nodes);
  printf("How many elements does your circuit have? ");
  scanf("%d", &num_elements);
  printf("Now enter the values for each element.\n");
  for ( i = 0; i < num_elements; ++i )
  {
    printf("Element %d: ", (unsigned int)(i + 1));
    scanf("%d %d %lf", (char *)&e_list + 16 * i, (char *)&e_list + 16 * i + 4, (char *)&e_list + 16 * i + 8);
  }
  for ( j = 0; j < num_elements; ++j )
  {
    G[100 * *((int *)&e_list + 4 * j) + *((int *)&unk_14002CF24 + 4 * j)] = 1.0 / dbl_14002CF28[2 * j]
                                                                          + G[100 * *((int *)&e_list + 4 * j)
                                                                            + *((int *)&unk_14002CF24 + 4 * j)];
    G[100 * *((int *)&unk_14002CF24 + 4 * j) + *((int *)&e_list + 4 * j)] = 1.0 / dbl_14002CF28[2 * j]
                                                                          + G[100 * *((int *)&unk_14002CF24 + 4 * j)
                                                                            + *((int *)&e_list + 4 * j)];
  }
  for ( k = 0; k < num_nodes; ++k )
  {
    for ( m = 0; m < num_nodes; ++m )
    {
      if ( k == m )
        G[101 * k] = -1.0;
    }
  }
  b[num_nodes - 1] = -1.0;
  for ( n = 0; n < num_nodes - 1; ++n )
  {
    for ( ii = n + 1; ii < num_nodes; ++ii )
    {
      v4 = G[100 * ii + n] / G[101 * n];
      for ( jj = n; jj < num_nodes; ++jj )
        G[100 * ii + jj] = G[100 * ii + jj] - G[100 * n + jj] * v4;
      b[ii] = b[ii] - b[n] * v4;
    }
  }
  for ( kk = num_nodes - 1; kk >= 0; --kk )
  {
    v6[2] = 0;
    *(_QWORD *)v6 = (unsigned int)(kk + 1);
    while ( v6[0] < num_nodes )
    {
      *(double *)&v6[1] = x[v6[0]] * G[100 * kk + v6[0]] + *(double *)&v6[1];
      ++v6[0];
    }
    x[kk] = (b[kk] - *(double *)&v6[1]) / G[101 * kk];
  }
  printf("The voltage at each node in the circuit is:\n");
  for ( mm = 0; mm < num_nodes; ++mm )
    printf("Node %d: %lf\n", (unsigned int)(mm + 1), x[mm]);
  printf("Thank you for using the most exciting circuit simulator program ever!\n");
  return 0;
}
// 140001D60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019040: using guessed type int num_nodes;
// 140019044: using guessed type int num_elements;
// 140019060: using guessed type double G[10000];
// 14002C8E0: using guessed type double b[100];
// 14002CC00: using guessed type double x[100];
// 14002CF28: using guessed type double dbl_14002CF28[399];
// 1400015E2: using guessed type int var_2C[3];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: retro
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Defining a structure to hold the details of retro video games
struct retro_game {
    char title[50];
    char platform[20];
    int release_year;
    float rating;
};

// Function to add new game details to the file
void add_game() {
    FILE *file_pointer;
    struct retro_game game;

    // Opening the file in append mode
    file_pointer = fopen("retro_games.txt", "a");

    if (file_pointer == NULL) {
        printf("\nError opening file!\n");
        exit(1);
    }

    printf("\nEnter the title of the game: ");
    fflush(stdin);
    fgets(game.title, 50, stdin);

    printf("\nEnter the platform of the game: ");
    fflush(stdin);
    fgets(game.platform, 20, stdin);

    printf("\nEnter the release year of the game: ");
    scanf("%d", &game.release_year);

    printf("\nEnter the rating of the game (out of 10): ");
    scanf("%f", &game.rating);

    fprintf(file_pointer, "%s%s%d%.1f\n", game.title, game.platform, game.release_year, game.rating);

    printf("\nGame details added successfully!\n");
    fclose(file_pointer);
}

// Function to display all the games in the file
void display_all_games() {
    FILE *file_pointer;
    struct retro_game game;

    // Opening the file in read mode
    file_pointer = fopen("retro_games.txt", "r");

    if (file_pointer == NULL) {
        printf("\nError opening file!\n");
        exit(1);
    }

    printf("\nTitle\tPlatform\tYear\tRating\n");

    // Reading game details from the file and displaying them
    while(fscanf(file_pointer, "%s%s%d%f", game.title, game.platform, &game.release_year, &game.rating) != EOF) {
        printf("%s\t%s\t%d\t%.1f\n", game.title, game.platform, game.release_year, game.rating);
    }

    fclose(file_pointer);
}

// Function to search for games based on their title
void search_game_by_title() {
    FILE *file_pointer;
    struct retro_game game;
    char title[50], found = 0;

    // Opening the file in read mode
    file_pointer = fopen("retro_games.txt", "r");

    if (file_pointer == NULL) {
        printf("\nError opening file!\n");
        exit(1);
    }

    printf("\nEnter the title of the game to search: ");
    fflush(stdin);
    fgets(title, 50, stdin);

    // Reading game details from the file and searching for the given title
    while(fscanf(file_pointer, "%s%s%d%f", game.title, game.platform, &game.release_year, &game.rating) != EOF) {
        if (strstr(game.title, title) != NULL) {
            printf("\nTitle\tPlatform\tYear\tRating\n");
            printf("%s\t%s\t%d\t%.1f\n", game.title, game.platform, game.release_year, game.rating);
            found = 1;
            break;
        }
    }

    if (!found) {
        printf("\nGame not found!\n");
    }

    fclose(file_pointer);
}

int main() {
    int choice;

    // Creating a menu for the user
    do {
        printf("\nRetro games file handling\n");
        printf("1. Add a new game\n");
        printf("2. Display all games\n");
        printf("3. Search for games based on title\n");
        printf("4. Exit\n");

        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                add_game();
                break;

            case 2:
                display_all_games();
                break;

            case 3:
                search_game_by_title();
                break;

            case 4:
                printf("\nExiting...\n");
                exit(0);

            default:
                printf("\nInvalid choice!\n");
                break;
        }
    } while (choice != 4);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_game(void); // weak
__int64 display_all_games(void); // weak
__int64 search_game_by_title(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001A54) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("\nRetro games file handling\n");
    printf("1. Add a new game\n");
    printf("2. Display all games\n");
    printf("3. Search for games based on title\n");
    printf("4. Exit\n");
    printf("\nEnter your choice: ");
    scanf("%d", &v4);
    if ( v4 == 4 )
    {
      printf("\nExiting...\n");
      exit(0);
    }
    if ( v4 <= 4 )
    {
      switch ( v4 )
      {
        case 3:
          search_game_by_title();
          continue;
        case 1:
          add_game();
          continue;
        case 2:
          display_all_games();
          continue;
      }
    }
    printf("\nInvalid choice!\n");
  }
  while ( v4 != 4 );
  return 0;
}
// 140001AE6: conditional instruction was optimized away because %var_4.4<3
// 140001668: using guessed type __int64 add_game(void);
// 1400017FA: using guessed type __int64 display_all_games(void);
// 1400018E3: using guessed type __int64 search_game_by_title(void);
// 140001C00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Basic Image Processing: Simple tasks like flipping an image, changing brightness/contrast ; Style: active
#include <stdio.h>
#include <stdlib.h>

#define MAX_PIXEL_VALUE 255

typedef struct {
    int width;
    int height;
    unsigned char *data;
} Image;

Image *create_image(int width, int height);
void destroy_image(Image *image);
void flip_image(Image *image);
void adjust_brightness(Image *image, int level);
void adjust_contrast(Image *image, float level);

int main() {
    // create image
    Image *image = create_image(5, 4);

    // fill image with dummy data
    for (int i = 0; i < image->width * image->height; i++) {
        image->data[i] = i;
    }

    // print original image
    printf("Original Image:\n");
    for (int y = 0; y < image->height; y++) {
        for (int x = 0; x < image->width; x++) {
            printf("%3d ", image->data[y * image->width + x]);
        }
        printf("\n");
    }

    // flip image
    flip_image(image);

    // print flipped image
    printf("\nFlipped Image:\n");
    for (int y = 0; y < image->height; y++) {
        for (int x = 0; x < image->width; x++) {
            printf("%3d ", image->data[y * image->width + x]);
        }
        printf("\n");
    }

    // adjust brightness
    adjust_brightness(image, 50);

    // print adjusted brightness image
    printf("\nAdjusted Brightness Image:\n");
    for (int y = 0; y < image->height; y++) {
        for (int x = 0; x < image->width; x++) {
            printf("%3d ", image->data[y * image->width + x]);
        }
        printf("\n");
    }

    // adjust contrast
    adjust_contrast(image, 1.5);

    // print adjusted contrast image
    printf("\nAdjusted Contrast Image:\n");
    for (int y = 0; y < image->height; y++) {
        for (int x = 0; x < image->width; x++) {
            printf("%3d ", image->data[y * image->width + x]);
        }
        printf("\n");
    }

    // free memory
    destroy_image(image);
}

Image *create_image(int width, int height) {
    Image *image = (Image *) malloc(sizeof(Image));
    image->width = width;
    image->height = height;
    image->data = (unsigned char *) malloc(sizeof(unsigned char) * width * height);
    return image;
}

void destroy_image(Image *image) {
    free(image->data);
    free(image);
}

void flip_image(Image *image) {
    unsigned char temp;
    for (int y = 0; y < image->height; y++) {
        for (int x = 0; x < image->width / 2; x++) {
            temp = image->data[y * image->width + x];
            image->data[y * image->width + x] = image->data[y * image->width + (image->width - 1 - x)];
            image->data[y * image->width + (image->width - 1 - x)] = temp;
        }
    }
}

void adjust_brightness(Image *image, int level) {
    for (int i = 0; i < image->width * image->height; i++) {
        int new_value = image->data[i] + level;
        if (new_value > MAX_PIXEL_VALUE) {
            image->data[i] = MAX_PIXEL_VALUE;
        } else if (new_value < 0) {
            image->data[i] = 0;
        } else {
            image->data[i] = new_value;
        }
    }
}

void adjust_contrast(Image *image, float level) {
    float factor = (259.0 * (level + 255.0)) / (255.0 * (259.0 - level));
    int new_value;
    for (int i = 0; i < image->width * image->height; i++) {
        new_value = (int) (factor * (image->data[i] - 128.0) + 128.0);
        if (new_value > MAX_PIXEL_VALUE) {
            image->data[i] = MAX_PIXEL_VALUE;
        } else if (new_value < 0) {
            image->data[i] = 0;
        } else {
            image->data[i] = new_value;
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall create_image(_QWORD, _QWORD); // weak
__int64 __fastcall destroy_image(_QWORD); // weak
__int64 __fastcall flip_image(_QWORD); // weak
__int64 __fastcall adjust_brightness(_QWORD, _QWORD); // weak
__int64 __fastcall adjust_contrast(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 image; // [rsp+20h] [rbp-30h]
  int mm; // [rsp+2Ch] [rbp-24h]
  int kk; // [rsp+30h] [rbp-20h]
  int jj; // [rsp+34h] [rbp-1Ch]
  int ii; // [rsp+38h] [rbp-18h]
  int n; // [rsp+3Ch] [rbp-14h]
  int m; // [rsp+40h] [rbp-10h]
  int k; // [rsp+44h] [rbp-Ch]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  image = create_image(5i64, 4i64);
  for ( i = 0; i < *(_DWORD *)image * *(_DWORD *)(image + 4); ++i )
    *(_BYTE *)(*(_QWORD *)(image + 8) + i) = i;
  printf("Original Image:\n");
  for ( j = 0; j < *(_DWORD *)(image + 4); ++j )
  {
    for ( k = 0; k < *(_DWORD *)image; ++k )
      printf("%3d ", *(unsigned __int8 *)(*(_QWORD *)(image + 8) + j * *(_DWORD *)image + k));
    printf("\n");
  }
  flip_image(image);
  printf("\nFlipped Image:\n");
  for ( m = 0; m < *(_DWORD *)(image + 4); ++m )
  {
    for ( n = 0; n < *(_DWORD *)image; ++n )
      printf("%3d ", *(unsigned __int8 *)(*(_QWORD *)(image + 8) + m * *(_DWORD *)image + n));
    printf("\n");
  }
  adjust_brightness(image, 50i64);
  printf("\nAdjusted Brightness Image:\n");
  for ( ii = 0; ii < *(_DWORD *)(image + 4); ++ii )
  {
    for ( jj = 0; jj < *(_DWORD *)image; ++jj )
      printf("%3d ", *(unsigned __int8 *)(*(_QWORD *)(image + 8) + ii * *(_DWORD *)image + jj));
    printf("\n");
  }
  adjust_contrast(image);
  printf("\nAdjusted Contrast Image:\n");
  for ( kk = 0; kk < *(_DWORD *)(image + 4); ++kk )
  {
    for ( mm = 0; mm < *(_DWORD *)image; ++mm )
      printf("%3d ", *(unsigned __int8 *)(*(_QWORD *)(image + 8) + kk * *(_DWORD *)image + mm));
    printf("\n");
  }
  destroy_image(image);
  return 0;
}
// 140001840: using guessed type __int64 __fastcall create_image(_QWORD, _QWORD);
// 14000189B: using guessed type __int64 __fastcall destroy_image(_QWORD);
// 1400018C7: using guessed type __int64 __fastcall flip_image(_QWORD);
// 1400019C1: using guessed type __int64 __fastcall adjust_brightness(_QWORD, _QWORD);
// 140001A6A: using guessed type __int64 __fastcall adjust_contrast(_QWORD);
// 140001C50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Binary search trees ; Style: careful
#include <stdio.h>
#include <stdlib.h>

/* Node structure */
typedef struct Node {
  int data;
  struct Node *left, *right;
} Node;

/* Insert function */
Node* insert(Node* root, int value) {
  if (root == NULL) {
    Node* new_node = (Node*) malloc(sizeof(Node));
    new_node->data = value;
    new_node->left = new_node->right = NULL;
    return new_node;
  }
  if (value < root->data) {
    root->left = insert(root->left, value);
  } 
  else {
    root->right = insert(root->right, value);
  }
  return root;
}

/* Search function */
Node* search(Node* root, int value){
  while(root != NULL) {
    if(value == root->data){
      return root;
    }
    else if (value < root->data) {
      root = root->left;
    }
    else{
      root = root->right;
    }
  }
  return NULL;
}

/* Traversal functions - Inorder, Preorder and Postorder */
void inorder(Node* root) {
  if (root != NULL) {
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
  }
}
void preorder(Node* root) {
  if (root != NULL) {
    printf("%d ", root->data);
    preorder(root->left);
    preorder(root->right);
  }
}
void postorder(Node* root) {
  if (root != NULL) {
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->data);
  }
}

/* Main function */
int main() {
  Node *root = NULL;
  int choice, value;

  /* Menu */
  do {
    printf("\nBinary Search Tree Operations\n");
    printf("1. Insert\n");
    printf("2. Search\n");
    printf("3. Inorder Traversal\n");
    printf("4. Preorder Traversal\n");
    printf("5. Postorder Traversal\n");
    printf("6. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);

    switch (choice) {
      case 1:
        printf("Enter the value to insert: ");
        scanf("%d", &value);
        root = insert(root, value);
        break;
      case 2:
        printf("Enter the value to search: ");
        scanf("%d", &value);
        if (search(root, value) != NULL) {
          printf("Value found!\n");
        } else {
          printf("Value not found!\n");
        }
        break;
      case 3:
        printf("Inorder Traversal: ");
        inorder(root);
        printf("\n");
        break;
      case 4:
        printf("Preorder Traversal: ");
        preorder(root);
        printf("\n");
        break;
      case 5:
        printf("Postorder Traversal: ");
        postorder(root);
        printf("\n");
        break;
      case 6:
        printf("Exiting...Goodbye!\n");
        break;
      default:
        printf("Invalid choice!\n");
    }
  } while (choice != 6);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall insert(_QWORD, _QWORD); // weak
__int64 __fastcall search(_QWORD, _QWORD); // weak
__int64 __fastcall inorder(_QWORD); // weak
__int64 __fastcall preorder(_QWORD); // weak
__int64 __fastcall postorder(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017C2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-10h] BYREF
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  __int64 v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v6 = 0i64;
  do
  {
    printf("\nBinary Search Tree Operations\n");
    printf("1. Insert\n");
    printf("2. Search\n");
    printf("3. Inorder Traversal\n");
    printf("4. Preorder Traversal\n");
    printf("5. Postorder Traversal\n");
    printf("6. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        printf("Enter the value to insert: ");
        scanf("%d", &v4);
        v6 = insert(v6, v4);
        break;
      case 2:
        printf("Enter the value to search: ");
        scanf("%d", &v4);
        if ( search(v6, v4) )
          printf("Value found!\n");
        else
          printf("Value not found!\n");
        break;
      case 3:
        printf("Inorder Traversal: ");
        inorder(v6);
        printf("\n");
        break;
      case 4:
        printf("Preorder Traversal: ");
        preorder(v6);
        printf("\n");
        break;
      case 5:
        printf("Postorder Traversal: ");
        postorder(v6);
        printf("\n");
        break;
      case 6:
        printf("Exiting...Goodbye!\n");
        break;
      default:
        printf("Invalid choice!\n");
        break;
    }
  }
  while ( v5 != 6 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall insert(_QWORD, _QWORD);
// 14000167E: using guessed type __int64 __fastcall search(_QWORD, _QWORD);
// 1400016CF: using guessed type __int64 __fastcall inorder(_QWORD);
// 140001720: using guessed type __int64 __fastcall preorder(_QWORD);
// 140001771: using guessed type __int64 __fastcall postorder(_QWORD);
// 140001AA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home automation ; Style: portable
#include <stdio.h>
#include <stdlib.h>

#define LIGHTS 0
#define AC 1
#define DOOR 2

int main()
{
  int room1[3] = {0, 0, 0};
  int room2[3] = {0, 0, 0};

  printf("Welcome to the Smart Home Automation Program\n");

  int input;
  char c;

  do {
    printf("\n\n1. Turn on lights\n");
    printf("2. Turn off lights\n");
    printf("3. Turn on AC\n");
    printf("4. Turn off AC\n");
    printf("5. Unlock door\n");
    printf("6. Lock door\n");
    printf("7. Exit Program\n");

    printf("\nPlease enter your choice: ");
    scanf("%d",&input);
    scanf("%c", &c);

    int room, device;
    switch(input) {
      case 1:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &room);
        printf("Turning on lights in room %d...", room);
        room == 1 ? (room1[LIGHTS] = 1) : (room2[LIGHTS] = 1);
        break;
      case 2:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &room);
        printf("Turning off lights in room %d...", room);
        room == 1 ? (room1[LIGHTS] = 0) : (room2[LIGHTS] = 0);
        break;
      case 3:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &room);
        printf("Turning on AC in room %d...", room);
        room == 1 ? (room1[AC] = 1) : (room2[AC] = 1);
        break;
      case 4:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &room);
        printf("Turning off AC in room %d...", room);
        room == 1 ? (room1[AC] = 0) : (room2[AC] = 0);
        break;
      case 5:
        printf("\nUnlocking door...");
        room1[DOOR] = 1;
        break;
      case 6:
        printf("\nLocking door...");
        room1[DOOR] = 0;
        break;
      case 7:
        printf("\nExiting program...");
        break;
      default:
        printf("\nInvalid input! Please choose again.\n");
        continue;
    }

    printf("\n\nCurrent status of the house:\n");
    printf("Room 1: Lights %s, AC %s, Door %s\n", room1[LIGHTS] ? "ON" : "OFF", room1[AC] ? "ON" : "OFF", room1[DOOR] ? "UNLOCKED" : "LOCKED");
    printf("Room 2: Lights %s, AC %s\n", room2[LIGHTS] ? "ON" : "OFF", room2[AC] ? "ON" : "OFF");
  } while (input != 7);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rcx
  const char *v4; // rdx
  const char *v5; // rax
  const char *v6; // rdx
  const char *v7; // rax
  unsigned int v9; // [rsp+2Ch] [rbp-24h] BYREF
  char v10; // [rsp+33h] [rbp-1Dh] BYREF
  int v11; // [rsp+34h] [rbp-1Ch] BYREF
  int v12; // [rsp+38h] [rbp-18h]
  int v13; // [rsp+3Ch] [rbp-14h]
  int v14; // [rsp+40h] [rbp-10h]
  int v15; // [rsp+44h] [rbp-Ch]
  int v16; // [rsp+48h] [rbp-8h]
  int v17; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  printf("Welcome to the Smart Home Automation Program\n");
  do
  {
    printf("\n\n1. Turn on lights\n");
    printf("2. Turn off lights\n");
    printf("3. Turn on AC\n");
    printf("4. Turn off AC\n");
    printf("5. Unlock door\n");
    printf("6. Lock door\n");
    printf("7. Exit Program\n");
    printf("\nPlease enter your choice: ");
    scanf("%d", &v11);
    scanf("%c", &v10);
    switch ( v11 )
    {
      case 1:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &v9);
        printf("Turning on lights in room %d...", v9);
        if ( v9 == 1 )
          v15 = 1;
        else
          v12 = 1;
        goto LABEL_19;
      case 2:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &v9);
        printf("Turning off lights in room %d...", v9);
        if ( v9 == 1 )
          v15 = 0;
        else
          v12 = 0;
        goto LABEL_19;
      case 3:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &v9);
        printf("Turning on AC in room %d...", v9);
        if ( v9 == 1 )
          v16 = 1;
        else
          v13 = 1;
        goto LABEL_19;
      case 4:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &v9);
        printf("Turning off AC in room %d...", v9);
        if ( v9 == 1 )
          v16 = 0;
        else
          v13 = 0;
        goto LABEL_19;
      case 5:
        printf("\nUnlocking door...");
        v17 = 1;
        goto LABEL_19;
      case 6:
        printf("\nLocking door...");
        v17 = 0;
        goto LABEL_19;
      case 7:
        printf("\nExiting program...");
LABEL_19:
        printf("\n\nCurrent status of the house:\n");
        if ( v17 )
          v3 = "UNLOCKED";
        else
          v3 = "LOCKED";
        if ( v16 )
          v4 = "ON";
        else
          v4 = "OFF";
        if ( v15 )
          v5 = "ON";
        else
          v5 = "OFF";
        printf("Room 1: Lights %s, AC %s, Door %s\n", v5, v4, v3);
        if ( v13 )
          v6 = "ON";
        else
          v6 = "OFF";
        if ( v12 )
          v7 = "ON";
        else
          v7 = "OFF";
        printf("Room 2: Lights %s, AC %s\n", v7, v6);
        break;
      default:
        printf("\nInvalid input! Please choose again.\n");
        break;
    }
  }
  while ( v11 != 7 );
  return 0;
}
// 140001A30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type unsigned int var_24;

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: real-life
#include <stdio.h>
#include <string.h>

#define MAX_LEN 100

int min(int a, int b, int c) {
    if (a < b && a < c) return a;
    if (b < c) return b;
    return c;
}

int findLevenshteinDistance(char* str1, char* str2) {
    int len1 = strlen(str1), len2 = strlen(str2);
    int dp[MAX_LEN + 1][MAX_LEN + 1];

    for (int i = 0; i <= len1; i++) {
        for (int j = 0; j <= len2; j++) {
            if (i == 0) dp[i][j] = j;
            else if (j == 0) dp[i][j] = i;
            else if (str1[i - 1] == str2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
            else dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]);
        }
    }

    return dp[len1][len2];
}

int main() {
    char str1[MAX_LEN], str2[MAX_LEN];

    printf("Enter first string: ");
    fgets(str1, MAX_LEN, stdin);
    str1[strcspn(str1, "\n")] = '\0';

    printf("Enter second string: ");
    fgets(str2, MAX_LEN, stdin);
    str2[strcspn(str2, "\n")] = '\0';

    int distance = findLevenshteinDistance(str1, str2);

    printf("The Levenshtein distance between \"%s\" and \"%s\" is %d\n", str1, str2, distance);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall findLevenshteinDistance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400018CB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Str[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[108]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int LevenshteinDistance; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter first string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  printf("Enter second string: ");
  v4 = __acrt_iob_func(0);
  fgets(Str, 100, v4);
  Str[strcspn(Str, "\n")] = 0;
  LevenshteinDistance = findLevenshteinDistance(Buffer, Str);
  printf("The Levenshtein distance between \"%s\" and \"%s\" is %d\n", Buffer, Str, LevenshteinDistance);
  return 0;
}
// 1400015C6: using guessed type __int64 __fastcall findLevenshteinDistance(_QWORD, _QWORD);
// 140001A70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400018CB: using guessed type char Buffer[108];
// 1400018CB: using guessed type char Str[112];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: RAM usage monitor ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef __unix__
    #include <unistd.h>
    #include <sys/resource.h>
#elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64)
    #include <windows.h>
#endif

#define MAX_PROCESS_NAME 1024

struct ProcessInfo {
    char name[MAX_PROCESS_NAME];
    int pid;
    double ram;
    struct ProcessInfo *next;
};

struct ListNode {
    struct ProcessInfo *data;
    struct ListNode *next;
};

typedef struct ProcessInfo ProcessInfo;
typedef struct ListNode ListNode;

ListNode* createNode(ProcessInfo* pi) {
    ListNode* tmp = (ListNode*) malloc(sizeof(ListNode));
    tmp->data = pi;
    tmp->next = NULL;
    return tmp;
}

int processExists(ListNode* head, int pid) {
    ListNode* tmp = head;
    while (tmp != NULL) {
        if (tmp->data->pid == pid) {
            return 1;
        }
        tmp = tmp->next;
    }
    return 0;
}

ProcessInfo* readProcessInfo(int pid) {
    ProcessInfo* pi = (ProcessInfo*) malloc(sizeof(ProcessInfo));
    char path[MAX_PROCESS_NAME];
    sprintf(path, "/proc/%d/statm", pid);
    FILE* fp = fopen(path, "r");
    if (!fp) {
        free(pi);
        return NULL;
    }
    char name[MAX_PROCESS_NAME];
    sprintf(name, "/proc/%d/cmdline", pid);
    FILE* fpname = fopen(name, "r");
    if (!fpname) {
        fclose(fp);
        free(pi);
        return NULL;
    }
    if (fgets(pi->name, MAX_PROCESS_NAME, fpname)) {
        char* p = strrchr(pi->name, ' ');
        if (p) {
            *p = '\0';
        }
    }
    fclose(fpname);
    fscanf(fp, "%*s %lf", &pi->ram);
    fclose(fp);
    pi->pid = pid;
    return pi;
}

void printProcessInfo(ProcessInfo* pi) {
    printf("%-20s %5d %10.2lf MB\n", pi->name, pi->pid, pi->ram / 1024.0);
}

void printAllProcesses(ListNode* head) {
    ListNode* tmp = head;
    printf("%-20s %5s %10s\n", "Process Name", "PID", "RAM Usage");
    while (tmp != NULL) {
        printProcessInfo(tmp->data);
        tmp = tmp->next;
    }
}

int rl_scan(char* dest, int maxlen) {
    int c, i = 0;
    while ((c = getchar()) != EOF && c != '\n') {
        if (i < maxlen - 1) {
            dest[i++] = (char) c;
        } else {
            break;
        }
    }
    dest[i] = '\0';
    return i;
}

void wait(int sec) {
#ifdef __unix__
    sleep(sec);
#elif defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)
    Sleep(sec * 1000);
#endif
}

ListNode* cleanupProcesses(ListNode* head) {
    ListNode* tmp = head;
    while (tmp != NULL) {
        ProcessInfo* pi = tmp->data;
        if (readProcessInfo(pi->pid) == NULL) {
            printf("Process %d has terminated.\n", pi->pid);
            if (tmp == head) {
                head = tmp->next;
                free(pi);
                free(tmp);
                tmp = head;
            } else {
                ListNode* p = head;
                while (p->next != tmp) {
                    p = p->next;
                }
                p->next = tmp->next;
                free(pi);
                free(tmp);
                tmp = p->next;
            }
        } else {
            tmp = tmp->next;
        }
    }
    return head;
}

ListNode* updateProcessInfo(ListNode* head) {
    int pid;
    printf("Enter PID to track memory usage: ");
    scanf("%d", &pid);
    getchar();
    if (processExists(head, pid)) {
        printf("Process with PID %d is already being monitored.\n", pid);
        return head;
    }
    ProcessInfo* pi = readProcessInfo(pid);
    if (pi == NULL) {
        printf("No process with PID %d found.\n", pid);
        return head;
    }
    ListNode* node = createNode(pi);
    if (head == NULL) {
        head = node;
    } else {
        ListNode* tmp = head;
        while (tmp->next != NULL) {
            tmp = tmp->next;
        }
        tmp->next = node;
    }
    return head;
}

int main() {
    ListNode *processList = NULL;
    int choice;
    do {
        printf("\nMemory Monitor\n");
        printf("==============\n");
        printf("1. List Tracked Processes\n");
        printf("2. Track a Process\n");
        printf("3. Quit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        getchar();
        switch (choice) {
        case 1:
            cleanupProcesses(processList);
            printAllProcesses(processList);
            break;
        case 2:
            processList = updateProcessInfo(processList);
            break;
        case 3:
            printf("Exiting...\n");
            break;
        default:
            printf("Invalid choice. Try again.\n");
            break;
        }
        wait(2);
        system("clear");
    } while (choice != 3);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall printAllProcesses(_QWORD); // weak
__int64 __fastcall wait(_QWORD); // weak
__int64 __fastcall cleanupProcesses(_QWORD); // weak
__int64 __fastcall updateProcessInfo(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl system(const char *Command);
// int __cdecl getchar();


//----- (0000000140001BEB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  __int64 updated; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  updated = 0i64;
  do
  {
    printf("\nMemory Monitor\n");
    printf("==============\n");
    printf("1. List Tracked Processes\n");
    printf("2. Track a Process\n");
    printf("3. Quit\n");
    printf("Enter choice: ");
    scanf("%d", &v4);
    getchar();
    if ( v4 == 3 )
    {
      printf("Exiting...\n");
    }
    else
    {
      if ( v4 > 3 )
        goto LABEL_10;
      if ( v4 == 1 )
      {
        cleanupProcesses(updated);
        printAllProcesses(updated);
        goto LABEL_11;
      }
      if ( v4 == 2 )
        updated = updateProcessInfo(updated);
      else
LABEL_10:
        printf("Invalid choice. Try again.\n");
    }
LABEL_11:
    wait(2i64);
    system("clear");
  }
  while ( v4 != 3 );
  return 0;
}
// 1400018F9: using guessed type __int64 __fastcall printAllProcesses(_QWORD);
// 1400019CB: using guessed type __int64 __fastcall wait(_QWORD);
// 1400019F1: using guessed type __int64 __fastcall cleanupProcesses(_QWORD);
// 140001AFD: using guessed type __int64 __fastcall updateProcessInfo(_QWORD);
// 140001DC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=194 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Backup System ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_FILENAME_LENGTH 128
#define MAX_PATH_LENGTH 512
#define MAX_NUM_FILES 1000

typedef struct file_info {
    char name[MAX_FILENAME_LENGTH];
    char path[MAX_PATH_LENGTH];
    time_t last_modified;
} file_info;

void display_menu() {
    printf("1. Backup all files in a directory\n");
    printf("2. Restore a backup\n");
    printf("3. Exit\n");
    printf("Choose an option: ");
}

void backup_files() {
    char directory[MAX_PATH_LENGTH];
    char backup_directory[MAX_PATH_LENGTH];
    printf("Enter directory to backup: ");
    scanf("%s", directory);
    printf("Enter backup directory: ");
    scanf("%s", backup_directory);

    // Create backup directory if it doesn't exist
    char command[MAX_PATH_LENGTH + 20];
    sprintf(command, "mkdir -p %s", backup_directory);
    system(command);

    // Get list of files in directory
    char ls_command[MAX_PATH_LENGTH + 10];
    sprintf(ls_command, "ls -l %s | awk '{ print $6, $7, $8, $9 }'", directory);
    FILE* fp = popen(ls_command, "r");
    if (!fp) {
        printf("Error getting file list\n");
        return;
    }

    int num_files = 0;
    file_info files[MAX_NUM_FILES];
    char line[MAX_PATH_LENGTH + 50];
    while (fgets(line, sizeof(line), fp)) {
        sscanf(line, "%ld %s %s %[^\n]", &files[num_files].last_modified, &line[12], &line[15], files[num_files].name);
        sprintf(files[num_files].path, "%s/%s", backup_directory, files[num_files].name);
        num_files++;
    }
    pclose(fp);

    // Copy backup files to backup directory
    for (int i = 0; i < num_files; i++) {
        char cp_command[MAX_PATH_LENGTH + 30];
        sprintf(cp_command, "cp %s/%s %s", directory, files[i].name, files[i].path);
        system(cp_command);
    }
    printf("%d files backed up successfully\n", num_files);
}

void restore_backup() {
    char backup_directory[MAX_PATH_LENGTH];
    printf("Enter backup directory to restore: ");
    scanf("%s", backup_directory);

    // Get list of backup files
    char ls_command[MAX_PATH_LENGTH + 10];
    sprintf(ls_command, "ls %s", backup_directory);
    FILE* fp = popen(ls_command, "r");
    if (!fp) {
        printf("Error getting file list\n");
        return;
    }

    int num_files = 0;
    file_info backup_files[MAX_NUM_FILES];
    char line[MAX_PATH_LENGTH];
    while (fgets(line, sizeof(line), fp)) {
        strcpy(backup_files[num_files].name, line);
        backup_files[num_files].name[strcspn(backup_files[num_files].name, "\n")] = 0;
        sprintf(backup_files[num_files].path, "%s/%s", backup_directory, backup_files[num_files].name);
        num_files++;
    }
    pclose(fp);

    // Restore files from backup
    for (int i = 0; i < num_files; i++) {
        char restore_command[MAX_PATH_LENGTH + 30];
        sprintf(restore_command, "cp %s %s", backup_files[i].path, backup_files[i].name);
        system(restore_command);
    }
    printf("%d files restored successfully\n", num_files);
}


int main() {
    int choice = 0;

    while (choice != 3) {
        display_menu();
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                backup_files();
                break;
            case 2:
                restore_backup();
                break;
            case 3:
                printf("Exiting program\n");
                break;
            default:
                printf("Invalid choice\n");
                break;
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 display_menu(void); // weak
__int64 backup_files(void); // weak
__int64 restore_backup(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001CBA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  v4 = 0;
  while ( v4 != 3 )
  {
    display_menu();
    scanf("%d", &v4);
    if ( v4 == 3 )
    {
      printf("Exiting program\n");
    }
    else
    {
      if ( v4 > 3 )
        goto LABEL_10;
      if ( v4 == 1 )
      {
        backup_files();
      }
      else if ( v4 == 2 )
      {
        restore_backup();
      }
      else
      {
LABEL_10:
        printf("Invalid choice\n");
      }
    }
  }
  return 0;
}
// 140001668: using guessed type __int64 display_menu(void);
// 1400016B3: using guessed type __int64 backup_files(void);
// 1400019D9: using guessed type __int64 restore_backup(void);
// 140001E00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedural Space Adventure ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Game constants
#define MAX_PLANETS 10
#define MAX_RESOURCES 3
#define MAX_ENEMIES 5
#define MAX_PLAYER_NAME 20
#define MAX_ENEMY_NAME 15

// Function prototypes
void displayWelcomeScreen();
void displayMainMenu();
void generatePlanets();
void displayPlanets();
void displayPlanetDetails(int planetNum);
void generateEnemies();
void displayEnemies();
void displayEnemyDetails(int enemyNum);
void travelToPlanet();
void shop();
void fightEnemy();
void displayPlayerStats();
void gameOver();

// Global variables
int currentPlanet = 0;
int enemiesDefeated = 0;
int playerHealth = 100;
int playerCredits = 100;
char playerName[MAX_PLAYER_NAME];
char resources[MAX_RESOURCES][15] = {"Fuel", "Food", "Water"};
char enemyNames[MAX_ENEMIES][MAX_ENEMY_NAME] = {"ExoGuardian", "Spaceling", "Toxic Spore", "Orbital Sentinel", "Galactic Spectre"};

// Planet structure definition
struct Planet {
    char planetName[15];
    int resourcePrices[MAX_RESOURCES];
};

// Enemy structure definition
struct Enemy {
    char enemyName[MAX_ENEMY_NAME];
    int enemyHealth;
    int enemyDamage;
};

struct Planet planets[MAX_PLANETS];
struct Enemy enemies[MAX_ENEMIES];

int main() {
    srand(time(NULL)); // Seed the random number generator
    displayWelcomeScreen();
    printf("Please enter your name: ");
    scanf("%s", playerName);
    generatePlanets();
    generateEnemies();
    while(1) {
        displayMainMenu();
        int choice;
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch(choice) {
            case 1:
                displayPlanets();
                break;
            case 2:
                travelToPlanet();
                break;
            case 3:
                shop();
                break;
            case 4:
                fightEnemy();
                break;
            case 5:
                displayPlayerStats();
                break;
            case 6:
                gameOver();
                break;
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }
    return 0;
}

// Displays the welcome screen
void displayWelcomeScreen() {
    printf("********************************************\n");
    printf("           Procedural Space Adventure         \n");
    printf("********************************************\n");
    printf("\n");
}

// Displays the main menu
void displayMainMenu() {
    printf("\n");
    printf("********************************************\n");
    printf("                    Main Menu                 \n");
    printf("********************************************\n");
    printf("1. View Planets\n");
    printf("2. Travel to Planet\n");
    printf("3. Shop\n");
    printf("4. Fight Enemy\n");
    printf("5. View Player Stats\n");
    printf("6. Quit Game\n");
    printf("********************************************\n");
}

// Generates the planets
void generatePlanets() {
    for(int i = 0; i < MAX_PLANETS; i++) {
        sprintf(planets[i].planetName, "Planet %d", i + 1);
        for(int j = 0; j < MAX_RESOURCES; j++) {
            int price = rand() % 11 + 5;
            planets[i].resourcePrices[j] = price;
        }
    }
}

// Displays the planet list
void displayPlanets() {
    printf("\n");
    printf("********************************************\n");
    printf("                  Planet List                \n");
    printf("********************************************\n");
    for(int i = 0; i < MAX_PLANETS; i++) {
        printf("%d. %s\n", i + 1, planets[i].planetName);
    }
    printf("********************************************\n");
}

// Displays the planet details
void displayPlanetDetails(int planetNum) {
    printf("\n");
    printf("********************************************\n");
    printf("               %s Planet Details             \n", planets[planetNum].planetName);
    printf("********************************************\n");
    for(int i = 0; i < MAX_RESOURCES; i++) {
        printf("%s: %d credits\n", resources[i], planets[planetNum].resourcePrices[i]);
    }
    printf("********************************************\n");
}

// Generates the enemies
void generateEnemies() {
    for(int i = 0; i < MAX_ENEMIES; i++) {
        sprintf(enemies[i].enemyName, "%s Class Enemy", enemyNames[i]);
        enemies[i].enemyHealth = rand() % 51 + 50;
        enemies[i].enemyDamage = rand() % 26 + 25;
    }
}

// Displays the enemy list
void displayEnemies() {
    printf("\n");
    printf("********************************************\n");
    printf("                  Enemy List                 \n");
    printf("********************************************\n");
    for(int i = 0; i < MAX_ENEMIES; i++) {
        printf("%d. %s\n", i + 1, enemies[i].enemyName);
    }
    printf("********************************************\n");
}

// Displays the enemy details
void displayEnemyDetails(int enemyNum) {
    printf("\n");
    printf("********************************************\n");
    printf("               %s Details             \n", enemies[enemyNum].enemyName);
    printf("********************************************\n");
    printf("Health: %d\n", enemies[enemyNum].enemyHealth);
    printf("Damage: %d\n", enemies[enemyNum].enemyDamage);
    printf("********************************************\n");
}

// Allows the player to travel to a planet
void travelToPlanet() {
    int choice;
    printf("\n");
    printf("********************************************\n");
    printf("                  Travel Menu                \n");
    printf("********************************************\n");
    printf("Current Planet: %s\n", planets[currentPlanet].planetName);
    displayPlanets();
    printf("Enter the number of the planet you want to travel to: ");
    scanf("%d", &choice);
    if(choice > 0 && choice <= MAX_PLANETS && choice != currentPlanet + 1) {
        int distance = abs(currentPlanet - (choice - 1));
        int travelCost = (distance + 1) * 10;
        if(playerCredits >= travelCost) {
            playerCredits -= travelCost;
            currentPlanet = choice - 1;
            printf("You have successfully travelled to %s planet.\n", planets[currentPlanet].planetName);
            displayPlanetDetails(currentPlanet);
        } else {
            printf("You do not have enough credits to make this trip.\n");
        }
    } else if(choice == currentPlanet + 1) {
        printf("You are already on this planet.\n");
    } else {
        printf("Invalid choice. Please try again.\n");
    }
}

// Allows the player to buy or sell resources
void shop() {
    int choice;
    printf("\n");
    printf("********************************************\n");
    printf("                     Shop                    \n");
    printf("********************************************\n");
    displayPlanetDetails(currentPlanet);
    printf("Credits: %d\n", playerCredits);
    printf("1. Buy Resources\n");
    printf("2. Sell Resources\n");
    printf("3. Exit Shop\n");
    printf("********************************************\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
    if(choice == 1) {
        printf("\n");
        printf("********************************************\n");
        printf("                   Buy Menu                  \n");
        printf("********************************************\n");
        for(int i = 0; i < MAX_RESOURCES; i++) {
            printf("%d. %s: %d credits\n", i + 1, resources[i], planets[currentPlanet].resourcePrices[i]);
        }
        printf("********************************************\n");
        printf("Enter the number of the resource you want to buy: ");
        int resourceChoice;
        scanf("%d", &resourceChoice);
        if(resourceChoice > 0 && resourceChoice <= MAX_RESOURCES) {
            printf("Enter the quantity you want to buy: ");
            int quantity;
            scanf("%d", &quantity);
            int totalPrice = quantity * planets[currentPlanet].resourcePrices[resourceChoice - 1];
            if(totalPrice > playerCredits) {
                printf("You do not have enough credits to make this purchase.\n");
            } else {
                playerCredits -= totalPrice;
                printf("You have successfully purchased %d units of %s.\n", quantity, resources[resourceChoice - 1]);
            }
        } else {
            printf("Invalid choice. Please try again.\n");
        }
    } else if(choice == 2) {
        printf("\n");
        printf("********************************************\n");
        printf("                   Sell Menu                 \n");
        printf("********************************************\n");
        for(int i = 0; i < MAX_RESOURCES; i++) {
            printf("%d. %s: %d credits\n", i + 1, resources[i], planets[currentPlanet].resourcePrices[i]);
        }
        printf("********************************************\n");
        printf("Enter the number of the resource you want to sell: ");
        int resourceChoice;
        scanf("%d", &resourceChoice);
        if(resourceChoice > 0 && resourceChoice <= MAX_RESOURCES) {
            printf("Enter the quantity you want to sell: ");
            int quantity;
            scanf("%d", &quantity);
            int totalPrice = quantity * planets[currentPlanet].resourcePrices[resourceChoice - 1];
            playerCredits += totalPrice;
            printf("You have successfully sold %d units of %s.\n", quantity, resources[resourceChoice - 1]);
        } else {
            printf("Invalid choice. Please try again.\n");
        }
    } else if(choice == 3) {
        printf("Exiting shop.\n");
    } else {
        printf("Invalid choice. Please try again.\n");
    }
}

// Allows the player to fight an enemy
void fightEnemy() {
    int choice;
    printf("\n");
    printf("********************************************\n");
    printf("               Choose an enemy                \n");
    printf("********************************************\n");
    displayEnemies();
    printf("Enter the number of the enemy you want to fight: ");
    scanf("%d", &choice);
    if(choice > 0 && choice <= MAX_ENEMIES) {
        displayEnemyDetails(choice - 1);
        printf("Are you ready to fight? (1. Yes 2. No): ");
        int ready;
        scanf("%d", &ready);
        if(ready == 1) {
            struct Enemy currentEnemy = enemies[choice - 1];
            int totalEnemyDamage = 0;
            int totalPlayerDamage = 0;
            while(playerHealth > 0 && currentEnemy.enemyHealth > 0) {
                int playerDamage = rand() % 11 + 5;
                totalPlayerDamage += playerDamage;
                printf("You attacked the enemy and did %d damage. Enemy health is now %d.\n", playerDamage, currentEnemy.enemyHealth - playerDamage);
                currentEnemy.enemyHealth -= playerDamage;
                if(currentEnemy.enemyHealth > 0) {
                    int enemyDamage = rand() % currentEnemy.enemyDamage + 1;
                    totalEnemyDamage += enemyDamage;
                    printf("The enemy attacked you and did %d damage. Your health is now %d.\n", enemyDamage, playerHealth - enemyDamage);
                    playerHealth -= enemyDamage;
                }
            }
            if(playerHealth <= 0) {
                printf("You lost the fight and have been transported back to your base planet.\n");
                currentPlanet = 0;
                playerCredits = 100;
                playerHealth = 100;
            } else {
                int lootCredits = rand() % 51 + 50;
                playerCredits += lootCredits;
                printf("Congratulations! You have won the fight and earned %d credits.\n", lootCredits);
                enemiesDefeated++;
            }
        } else if(ready == 2) {
            printf("You chickened out of the fight.\n");
        } else {
            printf("Invalid choice. Please try again.\n");
        }
    } else {
        printf("Invalid choice. Please try again.\n");
    }
}

// Displays the player stats
void displayPlayerStats() {
    printf("\n");
    printf("********************************************\n");
    printf("                  Player Stats               \n");
    printf("********************************************\n");
    printf("Name: %s\n", playerName);
    printf("Current Planet: %s\n", planets[currentPlanet].planetName);
    printf("Credits: %d\n", playerCredits);
    printf("Health: %d\n", playerHealth);
    printf("Enemies Defeated: %d\n", enemiesDefeated);
    printf("********************************************\n");
}

// Ends the game
void gameOver() {
    printf("Thank you for playing Procedural Space Adventure!\n");
    exit(EXIT_SUCCESS);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 displayWelcomeScreen(void); // weak
__int64 displayMainMenu(void); // weak
__int64 generatePlanets(void); // weak
__int64 displayPlanets(void); // weak
__int64 generateEnemies(void); // weak
__int64 travelToPlanet(void); // weak
__int64 shop(void); // weak
__int64 fightEnemy(void); // weak
__int64 displayPlayerStats(void); // weak
void __noreturn gameOver(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN playerName; // weak


//----- (0000000140001644) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  displayWelcomeScreen();
  printf("Please enter your name: ");
  scanf("%s", &playerName);
  generatePlanets();
  generateEnemies();
  while ( 1 )
  {
    displayMainMenu();
    printf("Enter your choice: ");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        displayPlanets();
        break;
      case 2:
        travelToPlanet();
        break;
      case 3:
        shop();
        break;
      case 4:
        fightEnemy();
        break;
      case 5:
        displayPlayerStats();
        break;
      case 6:
        gameOver();
      default:
        printf("Invalid choice. Please try again.\n");
        break;
    }
  }
}
// 14000172B: using guessed type __int64 displayWelcomeScreen(void);
// 140001776: using guessed type __int64 displayMainMenu(void);
// 14000182A: using guessed type __int64 generatePlanets(void);
// 140001907: using guessed type __int64 displayPlanets(void);
// 140001A9B: using guessed type __int64 generateEnemies(void);
// 140001D22: using guessed type __int64 travelToPlanet(void);
// 140001ECA: using guessed type __int64 shop(void);
// 14000237B: using guessed type __int64 fightEnemy(void);
// 140002636: using guessed type __int64 displayPlayerStats(void);
// 140002721: using guessed type void __noreturn gameOver(void);
// 140002800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=195 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to Morse code conversion ; Style: modular
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

// Function to convert a character to its Morse Code equivalent
char * charToMorse(char c)
{
    switch(c)
    {
        case 'a':
        case 'A':
            return ".-";
        case 'b':
        case 'B':
            return "-...";
        case 'c':
        case 'C':
            return "-.-.";
        case 'd':
        case 'D':
            return "-..";
        case 'e':
        case 'E':
            return ".";
        case 'f':
        case 'F':
            return "..-.";
        case 'g':
        case 'G':
            return "--.";
        case 'h':
        case 'H':
            return "....";
        case 'i':
        case 'I':
            return "..";
        case 'j':
        case 'J':
            return ".---";
        case 'k':
        case 'K':
            return "-.-";
        case 'l':
        case 'L':
            return ".-..";
        case 'm':
        case 'M':
            return "--";
        case 'n':
        case 'N':
            return "-.";
        case 'o':
        case 'O':
            return "---";
        case 'p':
        case 'P':
            return ".--.";
        case 'q':
        case 'Q':
            return "--.-";
        case 'r':
        case 'R':
            return ".-.";
        case 's':
        case 'S':
            return "...";
        case 't':
        case 'T':
            return "-";
        case 'u':
        case 'U':
            return "..-";
        case 'v':
        case 'V':
            return "...-";
        case 'w':
        case 'W':
            return ".--";
        case 'x':
        case 'X':
            return "-..-";
        case 'y':
        case 'Y':
            return "-.--";
        case 'z':
        case 'Z':
            return "--..";
        case ' ':
            return "/";
        default:
            return "";
    }
}

// Function to convert a string to its Morse Code equivalent
char * stringToMorse(char s[])
{
    int i, j;
    char *morse = (char*) malloc(sizeof(char) * 100);
    morse[0] = '\0';

    for(i = 0; i < strlen(s); i++)
    {
        char *temp = charToMorse(s[i]);
        strcat(morse, temp);
        free(temp);
        strcat(morse, " ");
    }

    return morse;
}

// Main function to test the program
int main()
{
    char s[50];

    printf("Enter a string: ");
    gets(s);

    char *morse = stringToMorse(s);

    printf("Morse Code of \"%s\" is: %s\n", s, morse);

    free(morse);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall stringToMorse(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// __int64 __fastcall gets(_QWORD); weak
// void __cdecl free(void *Block);


//----- (0000000140001794) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[56]; // [rsp+20h] [rbp-40h] BYREF
  void *Block; // [rsp+58h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a string: ");
  gets(v4);
  Block = (void *)stringToMorse(v4);
  printf("Morse Code of \"%s\" is: %s\n", v4, (const char *)Block);
  free(Block);
  return 0;
}
// 1400016EF: using guessed type __int64 __fastcall stringToMorse(_QWORD);
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140008B18: using guessed type __int64 __fastcall gets(_QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: multivariable
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <time.h>

#define SIZE 10 // size of the grid
#define THRESHOLD 0.6 // probability of a cell being open

bool grid[SIZE][SIZE];
bool connected[SIZE][SIZE];

void printGrid() {
    printf("\n----------------\n");
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            if (grid[i][j]) {
                printf("|_|");
            } else {
                printf("|X|");
            }
        }
        printf("\n----------------\n");
    }
}

bool percolates() {
    for (int i = 0; i < SIZE; i++) {
        if (connected[0][i] && connected[SIZE - 1][i]) {
            return true;
        }
    }
    return false;
}

void dfs(int x, int y) {
    if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) {
        return;
    }
    if (!grid[x][y] || connected[x][y]) {
        return;
    }
    connected[x][y] = true;
    dfs(x + 1, y);
    dfs(x - 1, y);
    dfs(x, y + 1);
    dfs(x, y - 1);
}

void connect() {
    for (int i = 0; i < SIZE; i++) {
        dfs(0, i);
    }
}

void percolation() {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            double p = ((double) rand() / RAND_MAX);
            if (p < THRESHOLD) {
                grid[i][j] = true;
            }
        }
    }
    connect();
}

int main() {
    srand(time(NULL));
    percolation();
    printGrid();
    if (percolates()) {
        printf("\nThe grid percolates!\n");
    } else {
        printf("\nThe grid does not percolate.\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 printGrid(void); // weak
__int64 percolates(void); // weak
__int64 percolation(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001879) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  percolation();
  printGrid();
  if ( (unsigned __int8)percolates() )
    printf("\nThe grid percolates!\n");
  else
    printf("\nThe grid does not percolate.\n");
  return 0;
}
// 1400015B0: using guessed type __int64 printGrid(void);
// 140001652: using guessed type __int64 percolates(void);
// 1400017E8: using guessed type __int64 percolation(void);
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Count Tool ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to count the occurrences of a word in a sentence
int countWord(char *sentence, char *word) {
    int count = 0;

    // Loop through the sentence and check for the word
    for(int i = 0; i < strlen(sentence); i++) {
        int flag = 1;

        // Check if the word matches the sentence starting from position i
        for(int j = 0; j < strlen(word); j++) {
            if(sentence[i+j] != word[j]) {
                flag = 0;
                break;
            }
        }

        // If word is found, increment the count
        if(flag && (i == 0 || sentence[i-1] == ' ') && (i+strlen(word) == strlen(sentence) || sentence[i+strlen(word)] == ' ')) {
            count++;
        }
    }

    return count;
}

int main() {
    // Take input of the sentence and word to be counted
    char sentence[1000], word[100];
    printf("Enter the sentence: ");
    fgets(sentence, 1000, stdin);
    printf("Enter the word to be counted: ");
    scanf("%s", word);

    // Remove unwanted characters from the sentence
    for(int i = 0; i < strlen(sentence); i++) {
        if(sentence[i] == '\n' || sentence[i] == '\r') {
            sentence[i] = '\0';
            break;
        }
    }

    // Count the occurrences of the word in the sentence
    int count = countWord(sentence, word);
    printf("The word '%s' occurs %d times in the sentence.\n", word, count);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall countWord(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016F9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char v5[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[1000]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v7; // [rsp+478h] [rbp+3F8h]
  int i; // [rsp+47Ch] [rbp+3FCh]

  _main(argc, argv, envp);
  printf("Enter the sentence: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  printf("Enter the word to be counted: ");
  scanf("%s", v5);
  for ( i = 0; i < strlen(Buffer); ++i )
  {
    if ( Buffer[i] == 10 || Buffer[i] == 13 )
    {
      Buffer[i] = 0;
      break;
    }
  }
  v7 = countWord(Buffer, v5);
  printf("The word '%s' occurs %d times in the sentence.\n", v5, v7);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall countWord(_QWORD, _QWORD);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016F9: using guessed type char Buffer[1000];

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#define ROW 10
#define COL 10

int maze[ROW][COL] = {
    {0, 0, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 0, 1, 0, 0, 0, 1, 0, 0, 1},
    {1, 0, 1, 0, 1, 0, 1, 0, 1, 1},
    {1, 0, 1, 0, 1, 0, 0, 0, 0, 1},
    {1, 0, 1, 0, 1, 1, 1, 1, 0, 1},
    {1, 0, 1, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 0, 1, 1, 1, 0, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 1, 1},
    {1, 0, 1, 1, 1, 1, 1, 1, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
};

int start_row = 0;
int start_col = 0; 
int end_row = 9;
int end_col = 9;

// The maze solver function using recursive algorithm
void mazeSolver(int row, int col)
{
    if(row < 0 || row >= ROW || col < 0 || col >= COL)
    {
        return;
    }
    if(maze[row][col] == 0 || maze[row][col] == 3)
    {
        return;
    }
    if(row == end_row && col == end_col)
    {
        maze[row][col] = 3;
        return;
    }
    maze[row][col] = 3; // marking the current position as visited
    mazeSolver(row-1, col); // North
    mazeSolver(row, col+1); // East
    mazeSolver(row+1, col); // South
    mazeSolver(row, col-1); // West
    maze[row][col] = 2; // marking the current position as part of the solution path
}

// The main function
int main()
{
    mazeSolver(start_row, start_col);
    printf("Solution Path:\n");
    for(int i=0; i<ROW; i++)
    {
        for(int j=0; j<COL; j++)
        {
            if(maze[i][j] == 2)
            {
                printf("> ");
            }
            else if(maze[i][j] == 1)
            {
                printf("* ");
            }
            else
            {
                printf("  ");
            }
        }
        printf("\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall mazeSolver(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_DWORD maze[100] =
{
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1
}; // weak
int start_row; // weak
int start_col; // weak


//----- (0000000140001731) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  mazeSolver((unsigned int)start_row, (unsigned int)start_col);
  printf("Solution Path:\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
    {
      if ( maze[10 * i + j] == 2 )
      {
        printf("> ");
      }
      else if ( maze[10 * i + j] == 1 )
      {
        printf("* ");
      }
      else
      {
        printf("  ");
      }
    }
    printf("\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall mazeSolver(_QWORD, _QWORD);
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A020: using guessed type _DWORD maze[100];
// 14000F040: using guessed type int start_row;
// 14000F044: using guessed type int start_col;

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Public-Key Algorithm Implementation ; Style: rigorous
#include<stdio.h> 

// Function to find gcd of two numbers
int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}

// Function to calculate pow(x, y) % p
int mod_exp(int x, int y, int p) {
    int res = 1;
    x = x % p;

    while (y > 0) {
        if (y & 1) {
            res = (res*x) % p;
        }
        y = y>>1;
        x = (x*x) % p;
    }
    return res;
}

int main() {
    int p = 13; // Public key
    int alpha = 6; // Primitive root
    int a, b, A, B; // Secret keys

    // Alice generates her secret key
    a = 5;
    A = mod_exp(alpha, a, p);

    // Bob generates his secret key
    b = 7;
    B = mod_exp(alpha, b, p);

    // Shared secret key
    int keyA = mod_exp(B, a, p);
    int keyB = mod_exp(A, b, p);

    // Check if both the secret keys are same
    if (keyA == keyB) {
        printf("Shared secret key is %d\n", keyA);
    }
    else {
        printf("Error in calculating Shared secret key\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall mod_exp(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000161D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-1Ch]
  unsigned int v5; // [rsp+28h] [rbp-18h]
  unsigned int v6; // [rsp+30h] [rbp-10h]

  _main(argc, argv, envp);
  v6 = mod_exp(6i64, 5i64, 13i64);
  v5 = mod_exp(6i64, 7i64, 13i64);
  v4 = mod_exp(v5, 5i64, 13i64);
  if ( v4 == (unsigned int)mod_exp(v6, 7i64, 13i64) )
    printf("Shared secret key is %d\n", v4);
  else
    printf("Error in calculating Shared secret key\n");
  return 0;
}
// 1400015C1: using guessed type __int64 __fastcall mod_exp(_QWORD, _QWORD, _QWORD);
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Math exercise ; Style: single-threaded
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<math.h>

int main(){

    int i, j, arr[100], size, max, min, sum=0;
    float mean, variance, standard_deviation;

    printf("Enter the size of the array: ");
    scanf("%d", &size);

    // Generate random numbers for the array
    srand(time(0));
    for(i=0; i<size; i++){
        arr[i] = rand()%101;
        printf("%d ", arr[i]);
    }

    // find the maximum element in the array
    max = arr[0];
    for(i=0; i<size; i++){
        if(max < arr[i])
            max = arr[i];
    }
    printf("\nMaximum element in the array: %d\n", max);

    // find the minimum element in the array
    min = arr[0];
    for(i=0; i<size; i++){
        if(min > arr[i])
            min = arr[i];
    }
    printf("Minimum element in the array: %d\n", min);

    // find the mean of the elements in the array
    for(i=0; i<size; i++){
        sum += arr[i];
    }
    mean = (float)sum/size;
    printf("Mean of the elements in the array: %.2f\n", mean);

    // find the variance of the elements in the array
    variance = 0;
    for(i=0; i<size; i++){
        variance += pow(arr[i]-mean, 2);
    }
    variance = variance/size;
    printf("Variance of the elements in the array: %.2f\n", variance);

    // find the standard deviation of the elements in the array
    standard_deviation = sqrt(variance);
    printf("Standard deviation of the elements in the array: %.2f\n", standard_deviation);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl pow(double X, double Y);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  double v4; // xmm0_8
  int v5; // xmm0_4
  int v7; // [rsp+2Ch] [rbp-54h] BYREF
  int v8[102]; // [rsp+30h] [rbp-50h]
  float v9; // [rsp+1C8h] [rbp+148h]
  float v10; // [rsp+1CCh] [rbp+14Ch]
  int v11; // [rsp+1D0h] [rbp+150h]
  unsigned int v12; // [rsp+1D4h] [rbp+154h]
  unsigned int v13; // [rsp+1D8h] [rbp+158h]
  int i; // [rsp+1DCh] [rbp+15Ch]

  _main(argc, argv, envp);
  v11 = 0;
  printf("Enter the size of the array: ");
  scanf("%d", &v7);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i < v7; ++i )
  {
    v8[i] = rand() % 101;
    printf("%d ", (unsigned int)v8[i]);
  }
  v13 = v8[0];
  for ( i = 0; i < v7; ++i )
  {
    if ( (int)v13 < v8[i] )
      v13 = v8[i];
  }
  printf("\nMaximum element in the array: %d\n", v13);
  v12 = v8[0];
  for ( i = 0; i < v7; ++i )
  {
    if ( (int)v12 > v8[i] )
      v12 = v8[i];
  }
  printf("Minimum element in the array: %d\n", v12);
  for ( i = 0; i < v7; ++i )
    v11 += v8[i];
  v9 = (float)v11 / (float)v7;
  printf("Mean of the elements in the array: %.2f\n", v9);
  v10 = 0.0;
  for ( i = 0; i < v7; ++i )
  {
    v4 = pow((float)((float)v8[i] - v9), 2.0);
    *(float *)&v4 = v4 + v10;
    v10 = *(float *)&v4;
  }
  v10 = v10 / (float)v7;
  printf("Variance of the elements in the array: %.2f\n", v10);
  *(float *)&v5 = sqrt(v10);
  v8[101] = v5;
  printf("Standard deviation of the elements in the array: %.2f\n", *(float *)&v5);
  return 0;
}
// 140001A00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to ASCII art generator ; Style: safe
#include <stdio.h>
#include <string.h>

#define ROW_LENGTH 7
#define CHAR_WIDTH 5

void textArt(char *text) {
    int length = strlen(text);
    int num_rows = ROW_LENGTH;
    int num_cols = length * CHAR_WIDTH;
    char art[num_rows][num_cols];

    // Initialize art array with spaces
    for(int i = 0; i < num_rows; i++) {
        for(int j = 0; j < num_cols; j++) {
            art[i][j] = ' ';
        }
    }

    // Generate text art
    for(int i = 0; i < length; i++) {
        int col = i * CHAR_WIDTH;
        switch(text[i]) {
            case 'A':
                art[0][col+2] = '*';
                art[1][col+1] = '*';
                art[1][col+3] = '*';
                art[2][col] = '*';
                art[2][col+4] = '*';
                art[3][col] = '*';
                art[3][col+4] = '*';
                art[4][col] = '*';
                art[4][col+4] = '*';
                art[5][col] = '*';
                art[5][col+4] = '*';
                art[6][col] = '*';
                art[6][col+4] = '*';
                break;
            case 'B':
                art[0][col] = '*';
                art[0][col+1] = '*';
                art[0][col+2] = '*';
                art[1][col] = '*';
                art[1][col+3] = '*';
                art[2][col] = '*';
                art[2][col+1] = '*';
                art[2][col+2] = '*';
                art[2][col+3] = '*';
                art[3][col+3] = '*';
                art[4][col+3] = '*';
                art[5][col+3] = '*';
                art[5][col+2] = '*';
                art[5][col+1] = '*';
                art[6][col] = '*';
                art[6][col+1] = '*';
                art[6][col+2] = '*';
                break;
            case 'C':
                art[0][col+1] = '*';
                art[0][col+2] = '*';
                art[0][col+3] = '*';
                art[1][col] = '*';
                art[2][col] = '*';
                art[3][col] = '*';
                art[4][col] = '*';
                art[4][col+1] = '*';
                art[4][col+2] = '*';
                art[4][col+3] = '*';
                art[5][col] = '*';
                art[6][col+1] = '*';
                art[6][col+2] = '*';
                art[6][col+3] = '*';
                break;
            default:
                break;
        }
    }

    // Print text art
    for(int i = 0; i < num_rows; i++) {
        for(int j = 0; j < num_cols; j++) {
            printf("%c", art[i][j]);
        }
        printf("\n");
    }
}

int main() {
    char text[] = "ABC";
    textArt(text);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall textArt(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001C5D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  v4 = 4407873;
  textArt(&v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall textArt(_QWORD);
// 140001D40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MIN_LENGTH 8 //minimum length of password required
#define MAX_LENGTH 20 //maximum length of password allowed
#define MIN_DIGITS 2 //minimum number of digits required in password

int is_valid_password(char *password);

int main() {
    char password[MAX_LENGTH + 1];
    int valid;
    
    printf("Enter your password (between %d and %d characters long, with at least %d digits): ", MIN_LENGTH, MAX_LENGTH, MIN_DIGITS);
    fgets(password, sizeof(password), stdin);
    password[strcspn(password, "\n")] = '\0'; //remove trailing newline from input
    
    valid = is_valid_password(password);
    
    if (valid) {
        printf("Your password meets all requirements.\n");
    } else {
        printf("Your password is not valid.\n");
    }
    
    return 0;
}

int is_valid_password(char *password) {
    int i;
    int len = strlen(password);
    int digits = 0;
    
    if (len < MIN_LENGTH || len > MAX_LENGTH) {
        return 0; //password length is not within acceptable range
    }
    
    for (i = 0; i < len; i++) {
        if (isdigit(password[i])) {
            digits++;
        } else if (!isalnum(password[i])) {
            return 0; //password contains non-alphanumeric characters
        }
    }
    
    if (digits < MIN_DIGITS) {
        return 0; //password does not contain enough digits
    }
    
    return 1; //password meets all requirements
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall is_valid_password(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[28]; // [rsp+20h] [rbp-20h] BYREF

  _main(argc, argv, envp);
  printf("Enter your password (between %d and %d characters long, with at least %d digits): ", 8i64, 20i64, 2i64);
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 21, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  if ( (unsigned int)is_valid_password(Buffer) )
    printf("Your password meets all requirements.\n");
  else
    printf("Your password is not valid.\n");
  return 0;
}
// 14000163B: using guessed type __int64 __fastcall is_valid_password(_QWORD);
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[28];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: String manipulation ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char input_string[100];
    char output_string[100];
    char reversed_string[100];
    char temp[100];

    printf("Enter a string: ");
    scanf("%s", input_string);

    // Convert all characters to uppercase
    int i;
    for(i=0; input_string[i]!='\0'; i++)
    {
        if(input_string[i]>='a' && input_string[i]<='z')
        {
            input_string[i] = input_string[i] - 32;
        }
    }

    // Copy the input string to output string
    strcpy(output_string, input_string);

    // Reverse the string
    int j = 0;
    for(i=strlen(input_string)-1; i>=0; i--)
    {
        reversed_string[j++] = input_string[i];
    }
    reversed_string[j] = '\0';

    // Concatenate the reversed string and output string
    strcat(output_string, reversed_string);

    // Sort the string in lexicographically ascending order
    int n = strlen(output_string);
    for(i=0; i<n-1; i++)
    {
        for(j=i+1; j<n; j++)
        {
            if(output_string[i]>output_string[j])
            {
                strcpy(temp, &output_string[i]);
                output_string[i] = output_string[j];
                output_string[j] = temp[0];
                strcat(output_string, temp+1);
            }
        }
    }

    printf("The final string is: %s\n", output_string);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl strcat(char *Destination, const char *Source);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  char v5; // [rsp+20h] [rbp-60h] BYREF
  char v6[111]; // [rsp+21h] [rbp-5Fh] BYREF
  char v7[112]; // [rsp+90h] [rbp+10h] BYREF
  char Destination[112]; // [rsp+100h] [rbp+80h] BYREF
  char Source[100]; // [rsp+170h] [rbp+F0h] BYREF
  int v10; // [rsp+1D4h] [rbp+154h]
  int j; // [rsp+1D8h] [rbp+158h]
  int i; // [rsp+1DCh] [rbp+15Ch]

  _main(argc, argv, envp);
  printf("Enter a string: ");
  scanf("%s", Source);
  for ( i = 0; Source[i]; ++i )
  {
    if ( Source[i] > 96 && Source[i] <= 122 )
      Source[i] -= 32;
  }
  strcpy(Destination, Source);
  j = 0;
  for ( i = strlen(Source) - 1; i >= 0; --i )
  {
    v3 = j++;
    v7[v3] = Source[i];
  }
  v7[j] = 0;
  strcat(Destination, v7);
  v10 = strlen(Destination);
  for ( i = 0; i < v10 - 1; ++i )
  {
    for ( j = i + 1; j < v10; ++j )
    {
      if ( Destination[i] > Destination[j] )
      {
        strcpy(&v5, &Destination[i]);
        Destination[i] = Destination[j];
        Destination[j] = v5;
        strcat(Destination, v6);
      }
    }
  }
  printf("The final string is: %s\n", Destination);
  return 0;
}
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Source[100];
// 1400015E2: using guessed type char Destination[112];
// 1400015E2: using guessed type char var_150[112];
// 1400015E2: using guessed type char anonymous_0[111];

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mailing list manager ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    char email[50];
    struct Node* next;
} node_t;

node_t* create_node(char email[]) {
    node_t* node = (node_t*) malloc(sizeof(node_t));
    strcpy(node->email, email);
    node->next = NULL;
    return node;
}

void print_list(node_t* head) {
    node_t* current = head;
    while (current != NULL) {
        printf("%s -> ", current->email);
        current = current->next;
    }
    printf("NULL\n");
}

void insert_node(node_t** head, char email[]) {
    node_t* node = create_node(email);
    if (*head == NULL) {
        *head = node;
    } else {
        node_t* current = *head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = node;
    }
}

void delete_node(node_t** head, char email[]) {
    node_t* current = *head;
    node_t* previous = NULL;
    while (current != NULL && strcmp(current->email, email) != 0) {
        previous = current;
        current = current->next;
    }
    if (current == NULL) {
        printf("Email not found in the list.\n");
    } else if (previous == NULL) {
        *head = current->next;
        printf("Email %s deleted from the list.\n", email);
        free(current);
    } else {
        previous->next = current->next;
        printf("Email %s deleted from the list.\n", email);
        free(current);
    }
}

void sort_list(node_t** head) {
    if (*head == NULL || (*head)->next == NULL) {
        return;
    }
    node_t *left = *head;
    node_t *right = (*head)->next;
    while (right != NULL) {
        right = right->next;
        if (right != NULL) {
            left = left->next;
            right = right->next;
        }
    }
    right = left->next;
    left->next = NULL;
    left = *head;
    sort_list(&left);
    sort_list(&right);
    node_t *new_head = NULL;
    if (strcmp(left->email, right->email) < 0) {
        new_head = left;
        left = left->next;
    } else {
        new_head = right;
        right = right->next;
    }
    node_t* current = new_head;
    while (left && right) {
        if (strcmp(left->email, right->email) < 0) {
            current->next = left;
            left = left->next;
        } else {
            current->next = right;
            right = right->next;
        }
        current = current->next;
    }
    if (left) {
        current->next = left;
    } else {
        current->next = right;
    }
    *head = new_head;
}

int main() {
    node_t* head = NULL;
    char email[50];
    int option;

    do {
        printf("\n1. Add email to the list\n");
        printf("2. Delete email from the list\n");
        printf("3. Print current list\n");
        printf("4. Sort the list\n");
        printf("5. Exit\n");
        printf("Enter an option: ");
        scanf("%d", &option);
        switch (option) {
            case 1:
                printf("Enter an email address to add: ");
                scanf("%s", email);
                insert_node(&head, email);
                break;
            case 2:
                printf("Enter an email address to delete: ");
                scanf("%s", email);
                delete_node(&head, email);
                break;
            case 3:
                printf("Current list:\n");
                print_list(head);
                break;
            case 4:
                printf("Sorting the list...\n");
                sort_list(&head);
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid option. Try again.\n");
                break;
        }
    } while (option != 5);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall print_list(_QWORD); // weak
__int64 __fastcall insert_node(_QWORD, _QWORD); // weak
__int64 __fastcall delete_node(_QWORD, _QWORD); // weak
__int64 __fastcall sort_list(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001976) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-44h] BYREF
  char v5[56]; // [rsp+30h] [rbp-40h] BYREF
  __int64 v6; // [rsp+68h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v6 = 0i64;
  do
  {
    printf("\n1. Add email to the list\n");
    printf("2. Delete email from the list\n");
    printf("3. Print current list\n");
    printf("4. Sort the list\n");
    printf("5. Exit\n");
    printf("Enter an option: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        printf("Enter an email address to add: ");
        scanf("%s", v5);
        insert_node(&v6, v5);
        break;
      case 2:
        printf("Enter an email address to delete: ");
        scanf("%s", v5);
        delete_node(&v6, v5);
        break;
      case 3:
        printf("Current list:\n");
        print_list(v6);
        break;
      case 4:
        printf("Sorting the list...\n");
        sort_list(&v6);
        break;
      case 5:
        printf("Exiting...\n");
        break;
      default:
        printf("Invalid option. Try again.\n");
        break;
    }
  }
  while ( v4 != 5 );
  return 0;
}
// 140001622: using guessed type __int64 __fastcall print_list(_QWORD);
// 140001677: using guessed type __int64 __fastcall insert_node(_QWORD, _QWORD);
// 1400016E9: using guessed type __int64 __fastcall delete_node(_QWORD, _QWORD);
// 1400017C8: using guessed type __int64 __fastcall sort_list(_QWORD);
// 140001BC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Weather simulation ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  srand(time(NULL));
  int temperature = rand() % 51 - 20; // generate random temperature between -20°C and 30°C
  char sky[4][10] = {"Sunny", "Cloudy", "Rainy", "Stormy"}; // array of sky conditions
  int condition = rand() % 4; // randomly select a sky condition
  printf("Today's weather: %s, %d°C\n", sky[condition], temperature);

  // simulate weather changes over time
  for (int i = 1; i <= 7; i++) {
    int temp_diff = rand() % (10 + i) - 5; // generate random temperature difference for the day
    temperature += temp_diff;
    if (temperature > 30) {
      temperature = 30;
    } else if (temperature < -20) {
      temperature = -20;
    }
    int new_condition = condition;
    if (condition == 0 && temp_diff >= 5) {
      new_condition = 1; // sunny to cloudy
    } else if (condition == 1 && (temp_diff <= -5 || temperature <= 0)) {
      new_condition = 2; // cloudy to rainy
    } else if (condition == 2 && temp_diff <= -5) {
      new_condition = 3; // rainy to stormy
    } else if (condition == 3 && temp_diff >= 5) {
      new_condition = 2; // stormy to rainy
    }
    if (new_condition != condition) {
      condition = new_condition;
      printf("Day %d: %s, %d°C\n", i, sky[condition], temperature);
    } else {
      printf("Day %d: No change, %d°C\n", i, temperature);
    }
  }
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5; // [rsp+20h] [rbp-40h] BYREF
  __int16 v6; // [rsp+28h] [rbp-38h]
  __int64 v7; // [rsp+2Ah] [rbp-36h]
  __int16 v8; // [rsp+32h] [rbp-2Eh]
  __int64 v9; // [rsp+34h] [rbp-2Ch]
  __int16 v10; // [rsp+3Ch] [rbp-24h]
  __int64 v11; // [rsp+3Eh] [rbp-22h]
  __int16 v12; // [rsp+46h] [rbp-1Ah]
  int v13; // [rsp+4Ch] [rbp-14h]
  int v14; // [rsp+50h] [rbp-10h]
  unsigned int i; // [rsp+54h] [rbp-Ch]
  int v16; // [rsp+58h] [rbp-8h]
  int v17; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v17 = rand() % 51 - 20;
  v5 = 0x796E6E7553i64;
  v6 = 0;
  v7 = 0x7964756F6C43i64;
  v8 = 0;
  v9 = 0x796E696152i64;
  v10 = 0;
  v11 = 0x796D726F7453i64;
  v12 = 0;
  v16 = rand() % 4;
  printf("Today's weather: %s, %d°C\n", (const char *)&v5 + 10 * v16, (unsigned int)v17);
  for ( i = 1; (int)i <= 7; ++i )
  {
    v13 = rand() % (int)(i + 10) - 5;
    v17 += v13;
    if ( v17 <= 30 )
    {
      if ( v17 < -20 )
        v17 = -20;
    }
    else
    {
      v17 = 30;
    }
    v14 = v16;
    if ( v16 || v13 <= 4 )
    {
      if ( v16 == 1 && (v13 < -4 || v17 <= 0) )
      {
        v14 = 2;
      }
      else if ( v16 == 2 && v13 < -4 )
      {
        v14 = 3;
      }
      else if ( v16 == 3 && v13 > 4 )
      {
        v14 = 2;
      }
    }
    else
    {
      v14 = 1;
    }
    if ( v14 == v16 )
    {
      printf("Day %d: No change, %d°C\n", i, (unsigned int)v17);
    }
    else
    {
      v16 = v14;
      printf("Day %d: %s, %d°C\n", i, (const char *)&v5 + 10 * v14, (unsigned int)v17);
    }
  }
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Tic Tac Toe AI ; Style: curious
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

#define BOARD_SIZE 3

typedef struct {
    int row;
    int column;
} Move;

void initialize_board(char board[][BOARD_SIZE]) {
    for(int i=0; i<BOARD_SIZE; i++) {
        for(int j=0; j<BOARD_SIZE; j++) {
            board[i][j] = '-';
        }
    }
}

void print_board(char board[][BOARD_SIZE]) {
    for(int i=0; i<BOARD_SIZE; i++) {
        for(int j=0; j<BOARD_SIZE; j++) {
            printf("%c ", board[i][j]);
        }
        printf("\n");
    }
}

bool is_move_valid(char board[][BOARD_SIZE], Move move) {
    int row = move.row;
    int column = move.column;
    if(row < 0 || row >= BOARD_SIZE || column < 0 || column >= BOARD_SIZE) {
        printf("Move out of bounds\n");
        return false;
    }
    if(board[row][column] != '-') {
        printf("Spot already taken\n");
        return false;
    }
    return true;
}

bool is_move_winning(char board[][BOARD_SIZE], Move move, char symbol) {
    int count = 0;
    int row = move.row;
    int column = move.column;
    for(int i=0; i<BOARD_SIZE; i++) {
        if(board[row][i] == symbol) {
            count++;
        } else {
            count = 0;
            break;
        }
    }
    if(count == BOARD_SIZE) {
        return true;
    }
    count = 0;
    for(int i=0; i<BOARD_SIZE; i++) {
        if(board[i][column] == symbol) {
            count++;
        } else {
            count = 0;
            break;
        }
    }
    if(count == BOARD_SIZE) {
        return true;
    }
    count = 0;
    if(row == column) {
        for(int i=0; i<BOARD_SIZE; i++) {
            if(board[i][i] == symbol) {
                count++;
            } else {
                count = 0;
                break;
            }
        }
        if(count == BOARD_SIZE) {
            return true;
        }
    }
    count = 0;
    if(row == BOARD_SIZE - 1 - column) {
        for(int i=0; i<BOARD_SIZE; i++) {
            if(board[i][BOARD_SIZE - 1 - i] == symbol) {
                count++;
            } else {
                count = 0;
                break;
            }
        }
        if(count == BOARD_SIZE) {
            return true;
        }
    }
    return false;
}

int evaluate_board(char board[][BOARD_SIZE], char symbol) {
    if(is_move_winning(board, (Move){0,0}, symbol)) {
        return 10;
    }
    if(is_move_winning(board, (Move){0,1}, symbol)) {
        return 10;
    }
    if(is_move_winning(board, (Move){0,2}, symbol)) {
        return 10;
    }
    if(is_move_winning(board, (Move){1,0}, symbol)) {
        return 10;
    }
    if(is_move_winning(board, (Move){1,1}, symbol)) {
        return 10;
    }
    if(is_move_winning(board, (Move){1,2}, symbol)) {
        return 10;
    }
    if(is_move_winning(board, (Move){2,0}, symbol)) {
        return 10;
    }
    if(is_move_winning(board, (Move){2,1}, symbol)) {
        return 10;
    }
    if(is_move_winning(board, (Move){2,2}, symbol)) {
        return 10;
    }
    return 0;
}

int minimax(char board[][BOARD_SIZE], char symbol, int depth, bool is_maximizer) {
    if(evaluate_board(board, symbol) == 10) {
        return 10;
    } else if(evaluate_board(board, symbol == 'X' ? 'O' : 'X') == 10) {
        return -10;
    } else if(depth == 0) {
        return 0;
    }
    if(is_maximizer) {
        int best_value = -1000;
        for(int i=0; i<BOARD_SIZE; i++) {
            for(int j=0; j<BOARD_SIZE; j++) {
                if(board[i][j] == '-') {
                    board[i][j] = symbol;
                    best_value = (best_value, minimax(board, symbol, depth-1, !is_maximizer));
                    board[i][j] = '-';
                }
            }
        }
        return best_value;
    } else {
        int best_value = 1000;
        for(int i=0; i<BOARD_SIZE; i++) {
            for(int j=0; j<BOARD_SIZE; j++) {
                if(board[i][j] == '-') {
                    board[i][j] = symbol == 'X' ? 'O' : 'X';
                    best_value = (best_value, minimax(board, symbol, depth-1, !is_maximizer));
                    board[i][j] = '-';
                }
            }
        }
        return best_value;
    }
}

Move find_best_move(char board[][BOARD_SIZE], char symbol) {
    int best_value = -1000;
    Move best_move;
    best_move.row = -1;
    best_move.column = -1;
    for(int i=0; i<BOARD_SIZE; i++) {
        for(int j=0; j<BOARD_SIZE; j++) {
            if(board[i][j] == '-') {
                board[i][j] = symbol;
                int current_value = minimax(board, symbol, 2, false);
                board[i][j] = '-';
                if(current_value > best_value) {
                    best_value = current_value;
                    best_move.row = i;
                    best_move.column = j;
                }
            }
        }
    }
    return best_move;
}

int main() {
    printf("Welcome to Tic Tac Toe!\n\n");
    printf("To make a move, enter the row number and column number separated by a space (e.g. 1 2).\n");
    printf("You will be X and the computer will be O.\n\n");
    char board[BOARD_SIZE][BOARD_SIZE];
    initialize_board(board);
    char winner = '-';
    while(winner == '-') {
        print_board(board);
        int row, column;
        printf("\nMake your move: ");
        scanf("%d %d", &row, &column);
        if(is_move_valid(board, (Move){row, column})) {
            board[row][column] = 'X';
        } else {
            continue;
        }
        if(is_move_winning(board, (Move){row, column}, 'X')) {
            winner = 'X';
            break;
        }
        Move ai_move = find_best_move(board, 'O');
        board[ai_move.row][ai_move.column] = 'O';
        printf("The computer made a move at (%d, %d).\n", ai_move.row, ai_move.column);
        if(is_move_winning(board, ai_move, 'O')) {
            winner = 'O';
        }
    }
    print_board(board);
    printf("\n%s wins!\n", winner == 'X' ? "You" : "The computer");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall initialize_board(_QWORD); // weak
__int64 __fastcall print_board(_QWORD); // weak
__int64 __fastcall is_move_valid(_QWORD, _QWORD); // weak
__int64 __fastcall is_move_winning(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall find_best_move(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001EB2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rax
  __int64 best_move; // [rsp+24h] [rbp-1Ch]
  unsigned int v6; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v7; // [rsp+30h] [rbp-10h] BYREF
  char v8[9]; // [rsp+36h] [rbp-Ah] BYREF
  char v9; // [rsp+3Fh] [rbp-1h]
  _BYTE v10[16]; // [rsp+40h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to Tic Tac Toe!\n\n");
  printf("To make a move, enter the row number and column number separated by a space (e.g. 1 2).\n");
  printf("You will be X and the computer will be O.\n\n");
  initialize_board(v8);
  v9 = 45;
  while ( v9 == 45 )
  {
    print_board(v8);
    printf("\nMake your move: ");
    scanf("%d %d", &v7, &v6);
    if ( (unsigned __int8)is_move_valid(v8, v7 | ((unsigned __int64)v6 << 32)) )
    {
      v10[3 * v7 - 10 + v6] = 88;
      if ( (unsigned __int8)is_move_winning(v8, v7 | ((unsigned __int64)v6 << 32), 88i64) )
      {
        v9 = 88;
        break;
      }
      best_move = find_best_move(v8, 79i64);
      v10[3 * (int)best_move - 10 + SHIDWORD(best_move)] = 79;
      printf("The computer made a move at (%d, %d).\n", (unsigned int)best_move, HIDWORD(best_move));
      if ( (unsigned __int8)is_move_winning(v8, best_move, 79i64) )
        v9 = 79;
    }
  }
  print_board(v8);
  if ( v9 == 88 )
    v3 = "You";
  else
    v3 = "The computer";
  printf("\n%s wins!\n", v3);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall initialize_board(_QWORD);
// 14000163B: using guessed type __int64 __fastcall print_board(_QWORD);
// 1400016B7: using guessed type __int64 __fastcall is_move_valid(_QWORD, _QWORD);
// 140001745: using guessed type __int64 __fastcall is_move_winning(_QWORD, _QWORD, _QWORD);
// 140001DB1: using guessed type __int64 __fastcall find_best_move(_QWORD, _QWORD);
// 140002160: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001EB2: using guessed type unsigned int var_20;

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Log analysis ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_LINE_SIZE 1000

//Function to parse a line of the log file and store relevant information
void parseLogLine(char* line, char* date, char* time, char* ip, char* method, char* path, char* protocol, int* status, int* bytes){
    sscanf(line, "%s %s %s %s %s %d %d", date, time, ip, method, path, status, bytes);
    if(strcmp(protocol, "HTTP/1.0")==0 || strcmp(protocol, "HTTP/1.1")==0 || strcmp(protocol, "")==0){
        //Protocol accepted
    }
    else{
        *status = -1; //Invalid protocol
    }
}

//Function to read the log file line by line and parse each line using the parseLogLine function
void readLogFile(char* filename){
    FILE* file = fopen(filename, "r");
    if(file == NULL){
        printf("Error: Cannot open file %s\n", filename);
        exit(1);
    }
    char line[MAX_LINE_SIZE];
    char date[MAX_LINE_SIZE];
    char time[MAX_LINE_SIZE];
    char ip[MAX_LINE_SIZE];
    char method[MAX_LINE_SIZE];
    char path[MAX_LINE_SIZE];
    char protocol[MAX_LINE_SIZE];
    int status;
    int bytes;
    int lineNum = 0;
    int errorLines = 0;
    int successfulRequests = 0;
    int totalBytes = 0;
    while(fgets(line, MAX_LINE_SIZE, file) != NULL){
        lineNum++;
        parseLogLine(line, date, time, ip, method, path, protocol, &status, &bytes);
        if(status==-1){
            printf("Error: Invalid protocol at line %d\n%s\n", lineNum, line);
            errorLines++;
        }
        else if(status>=400 && status<=499){
            printf("Warning: Client error at line %d\n%s\n", lineNum, line);
            errorLines++;
        }
        else if(status>=500 && status<=599){
            printf("Warning: Server error at line %d\n%s\n", line);
            errorLines++;
        }
        else{
            successfulRequests++;
            totalBytes += bytes;
        }
    }
    printf("Processed %d lines of log file %s\n", lineNum, filename);
    printf("%d successful requests with total of %d bytes\n", successfulRequests, totalBytes);
    printf("%d errors detected\n", errorLines);
    fclose(file);
}

int main(){
    char* filename = "access.log";
    readLogFile(filename);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall readLogFile(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018C4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  readLogFile("access.log");
  return 0;
}
// 140001687: using guessed type __int64 __fastcall readLogFile(_QWORD);
// 1400019B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define a structure for storing information of an item
struct Item {
  char name[100];
  int quantity;
  char location[100];
};

// Initialize the warehouse 
int warehouse_capacity = 1000;
struct Item* warehouse = NULL;

// Function for adding an item to the warehouse
void add_item(char name[100], int quantity, char location[100]) {
  // Check if warehouse is full
  if (sizeof(warehouse) / sizeof(warehouse[0]) >= warehouse_capacity) {
    printf("Warehouse is full. Cannot add item %s\n", name);
    return;
  }

  // Create a new item
  struct Item* new_item = (struct Item*) malloc(sizeof(struct Item));
  strncpy(new_item->name, name, 100);
  new_item->quantity = quantity;
  strncpy(new_item->location, location, 100);

  // Add item to the warehouse
  warehouse[sizeof(warehouse) / sizeof(warehouse[0])] = *new_item;

  // Print success message
  printf("Item %s added to warehouse at location %s\n", name, location);
}

// Function for removing an item from the warehouse
void remove_item(char name[100]) {
  // Search for the item in the warehouse
  int index = -1;
  for (int i = 0; i < sizeof(warehouse) / sizeof(warehouse[0]); i++) {
    if (strcmp(warehouse[i].name, name) == 0) {
      index = i;
      break;
    }
  }

  // Check if item was found
  if (index == -1) {
    printf("Item %s not found in warehouse\n", name);
    return;
  }

  // Remove item from warehouse and shift remaining items forward
  for (int i = index; i < sizeof(warehouse) / sizeof(warehouse[0]) - 1; i++) {
    warehouse[i] = warehouse[i + 1];
  }

  // Print success message
  printf("Item %s removed from warehouse\n", name);
}

int main() {

  // Dynamically allocate memory for the warehouse array
  warehouse = (struct Item*) malloc(warehouse_capacity * sizeof(struct Item));

  // Add some items to the warehouse
  add_item("Pencil", 500, "A1");
  add_item("Pen", 250, "B2");
  add_item("Eraser", 100, "C3");

  // Remove an item from the warehouse
  remove_item("Pen");

  // Add some more items to the warehouse
  add_item("Marker", 300, "D4");
  add_item("Highlighter", 150, "E5");

  // Remove an item that doesn't exist in the warehouse
  remove_item("Stapler");

  // Free the dynamically allocated memory
  free(warehouse);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall add_item(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall remove_item(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);

//-------------------------------------------------------------------------
// Data declarations

int warehouse_capacity = 1000; // weak
void *warehouse; // idb


//----- (00000001400018EE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  warehouse = malloc(204i64 * warehouse_capacity);
  add_item("Pencil", 500i64, "A1");
  add_item("Pen", 250i64, "B2");
  add_item("Eraser", 100i64, "C3");
  remove_item("Pen");
  add_item("Marker", 300i64, "D4");
  add_item("Highlighter", 150i64, "E5");
  remove_item("Stapler");
  free(warehouse);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall add_item(_QWORD, _QWORD, _QWORD);
// 140001746: using guessed type __int64 __fastcall remove_item(_QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A010: using guessed type int warehouse_capacity;

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Benchmarking ; Style: detailed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define SIZE 1000000

int main() {
    int arr[SIZE];
    int i, j, temp;
    clock_t start, end;
    double cpu_time_used;
    
    // Initialize the array with random values between 0 and 99
    srand(time(0));
    for (i = 0; i < SIZE; i++) {
        arr[i] = rand() % 100;
    }
    
    // Bubble Sort Algorithm
    start = clock();
    for (i = 0; i < SIZE - 1; i++) {
        for (j = 0; j < SIZE - i - 1; j++) {
            if (arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
    
    printf("Sorted Array:\n");
    for (i = 0; i < SIZE; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n\n");
    printf("Time taken by Bubble Sort Algorithm: %f seconds\n", cpu_time_used);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (00000001400015B0) ----------------------------------------------------
#error "1400015B0: stack frame is too big (funcsize=0)"

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Haunted House Simulator ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {

    int choice;
    char name[50];

    printf("Welcome to our Haunted House Simulator! Are you ready to enter?\n");
    printf("Please enter your name: ");
    scanf("%s", name);

    printf("\nGood luck, %s! You're now entering the Haunted House...\n\n", name);

    srand(time(NULL));

    while (1) {
        printf("\nYou enter a room, and you have two choices. What do you do?\n");
        printf("1. Open the door to your left.\n");
        printf("2. Open the door to your right.\n");

        scanf("%d", &choice);

        if (choice == 1) {
            int ghost_chance = rand() % 2;
            if (ghost_chance == 0) {
                printf("\nYou open the door and enter the room. You look around, but see nothing out of the ordinary.\n");
                printf("You take a step forward, and suddenly a ghost appears in front of you!\n");
                printf("You scream and run out of the room as fast as you can.\n");
                break;
            } else {
                printf("\nYou open the door and enter the room. It's quiet and empty.\n");
                printf("You look around and find nothing of interest. You continue on your journey.\n");
            }
        } else if (choice == 2) {
            int trap_chance = rand() % 2;
            if (trap_chance == 0) {
                printf("\nYou open the door and enter the room. You look around and see nothing.");
                printf("Suddenly, the floor beneath you gives way and you fall into a trap!");
                printf("You try to climb out, but it's too deep and you're stuck. You'll have to wait for help.\n");
                break;
            } else {
                printf("\nYou open the door and enter the room. You look around and find a key!");
                printf("You pick it up and continue on your journey.\n");
            }
        } else {
            printf("\nInvalid choice. Please try again.\n");
        }
    }

    printf("\nCongratulations! You made it out alive, %s!\n", name);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[52]; // [rsp+20h] [rbp-40h] BYREF
  int v6; // [rsp+54h] [rbp-Ch] BYREF

  _main(argc, argv, envp);
  printf("Welcome to our Haunted House Simulator! Are you ready to enter?\n");
  printf("Please enter your name: ");
  scanf("%s", v5);
  printf("\nGood luck, %s! You're now entering the Haunted House...\n\n", v5);
  v3 = time(0i64);
  srand(v3);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        printf("\nYou enter a room, and you have two choices. What do you do?\n");
        printf("1. Open the door to your left.\n");
        printf("2. Open the door to your right.\n");
        scanf("%d", &v6);
        if ( v6 != 1 )
          break;
        if ( !(rand() % 2) )
        {
          printf("\nYou open the door and enter the room. You look around, but see nothing out of the ordinary.\n");
          printf("You take a step forward, and suddenly a ghost appears in front of you!\n");
          printf("You scream and run out of the room as fast as you can.\n");
          goto LABEL_11;
        }
        printf("\nYou open the door and enter the room. It's quiet and empty.\n");
        printf("You look around and find nothing of interest. You continue on your journey.\n");
      }
      if ( v6 == 2 )
        break;
      printf("\nInvalid choice. Please try again.\n");
    }
    if ( !(rand() % 2) )
      break;
    printf("\nYou open the door and enter the room. You look around and find a key!");
    printf("You pick it up and continue on your journey.\n");
  }
  printf("\nYou open the door and enter the room. You look around and see nothing.");
  printf("Suddenly, the floor beneath you gives way and you fall into a trap!");
  printf("You try to climb out, but it's too deep and you're stuck. You'll have to wait for help.\n");
LABEL_11:
  printf("\nCongratulations! You made it out alive, %s!\n", v5);
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Metadata Extractor ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct metadata {
    char title[100];
    char artist[100];
    char album[100];
    char year[10];
};

void extract_metadata(char *filename, struct metadata *md) {
    FILE *fp;
    char line[100];

    fp = fopen(filename, "r");
    if(fp == NULL) {
        printf("Error: could not open file.\n");
        exit(1);
    }

    while(fgets(line, sizeof(line), fp)) {
        if(strstr(line, "Title") != NULL) {
            strcpy(md->title, strtok(line, ":"));
        }
        else if(strstr(line, "Artist") != NULL) {
            strcpy(md->artist, strtok(line, ":"));
        }
        else if(strstr(line, "Album") != NULL) {
            strcpy(md->album, strtok(line, ":"));
        }
        else if(strstr(line, "Year") != NULL) {
            strcpy(md->year, strtok(line, ":"));
        }
    }

    fclose(fp);
}

int main(int argc, char *argv[]) {
    struct metadata md;

    if(argc < 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    extract_metadata(argv[1], &md);

    printf("Title: %s\n", md.title);
    printf("Artist: %s\n", md.artist);
    printf("Album: %s\n", md.album);
    printf("Year: %s\n", md.year);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall extract_metadata(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000171A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[100]; // [rsp+20h] [rbp-60h] BYREF
  char v5[100]; // [rsp+84h] [rbp+4h] BYREF
  char v6[100]; // [rsp+E8h] [rbp+68h] BYREF
  char v7[20]; // [rsp+14Ch] [rbp+CCh] BYREF

  _main(argc, argv, envp);
  if ( argc > 1 )
  {
    extract_metadata(argv[1], v4);
    printf("Title: %s\n", v4);
    printf("Artist: %s\n", v5);
    printf("Album: %s\n", v6);
    printf("Year: %s\n", v7);
    return 0;
  }
  else
  {
    printf("Usage: %s <filename>\n", *argv);
    return 1;
  }
}
// 140001591: using guessed type __int64 __fastcall extract_metadata(_QWORD, _QWORD);
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000171A: using guessed type char anonymous_0[100];
// 14000171A: using guessed type char anonymous_1[100];
// 14000171A: using guessed type char anonymous_2[20];

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Online Examination System ; Style: paranoid
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define constants for array sizes
#define MAX_QUESTIONS 100
#define MAX_ANSWER_LENGTH 20
#define MAX_NAME_LENGTH 50

// Define struct for questions
typedef struct {
    int question_number;
    char question_text[MAX_ANSWER_LENGTH];
    char correct_answer[MAX_ANSWER_LENGTH];
    int points;
} question;

// Define struct for student results
typedef struct {
    char name[MAX_NAME_LENGTH];
    int score;
} result;

// Declare array of questions and results
question exam_questions[MAX_QUESTIONS];
result exam_results[MAX_QUESTIONS];

// Declare function to print exam questions
void print_exam_questions() {
    for (int i = 0; i < MAX_QUESTIONS; i++) {
        printf("Question %d: %s\n", exam_questions[i].question_number, exam_questions[i].question_text);
    }
}

// Declare function to grade exam
void grade_exam() {
    // Prompt for student name
    char name[MAX_NAME_LENGTH];
    printf("Please enter your name: ");
    scanf("%[^\n]%*c", name);
    
    // Declare variables for grading
    int total_score = 0;
    int num_correct = 0;
    
    // Loop through each question
    for (int i = 0; i < MAX_QUESTIONS; i++) {
        // Prompt for answer
        printf("Question %d: %s\n", exam_questions[i].question_number, exam_questions[i].question_text);
        printf("Enter your answer: ");
        char answer[MAX_ANSWER_LENGTH];
        scanf("%s", answer);
        
        // Check if answer is correct
        if (strcmp(answer, exam_questions[i].correct_answer) == 0) {
            printf("Correct!\n");
            total_score += exam_questions[i].points;
            num_correct++;
        } else {
            printf("Incorrect.\n");
        }
    }
    
    // Save student results
    strcpy(exam_results[num_correct].name, name);
    exam_results[num_correct].score = total_score;
    
    // Display results
    printf("You answered %d questions correctly for a total score of %d.\n", num_correct, total_score);
}

int main() {
    // Initialize exam questions
    memset(exam_questions, 0, sizeof(exam_questions));
    exam_questions[0].question_number = 1;
    strcpy(exam_questions[0].question_text, "What is the capital of France?");
    strcpy(exam_questions[0].correct_answer, "Paris");
    exam_questions[0].points = 1;
    
    exam_questions[1].question_number = 2;
    strcpy(exam_questions[1].question_text, "What is the largest continent?");
    strcpy(exam_questions[1].correct_answer, "Asia");
    exam_questions[1].points = 1;
    
    exam_questions[2].question_number = 3;
    strcpy(exam_questions[2].question_text, "What color is the sky?");
    strcpy(exam_questions[2].correct_answer, "Blue");
    exam_questions[2].points = 1;
    
    exam_questions[3].question_number = 4;
    strcpy(exam_questions[3].question_text, "What is the square root of 64?");
    strcpy(exam_questions[3].correct_answer, "8");
    exam_questions[3].points = 1;
    
    exam_questions[4].question_number = 5;
    strcpy(exam_questions[4].question_text, "What is 2 + 2?");
    strcpy(exam_questions[4].correct_answer, "4");
    exam_questions[4].points = 1;
    
    // Print exam questions
    print_exam_questions();
    
    // Grade exam
    grade_exam();
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 print_exam_questions(void); // weak
__int64 grade_exam(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memset(void *, int Val, size_t Size);

//-------------------------------------------------------------------------
// Data declarations

int exam_questions; // weak
__int64 qword_140019044; // weak
int dword_14001905C; // weak
__int16 word_140019060; // weak
int dword_14001906C; // weak
int dword_140019070; // weak
__int64 qword_140019074; // weak
int dword_14001908C; // weak
__int16 word_140019090; // weak
int dword_14001909C; // weak
int dword_1400190A0; // weak
__int64 qword_1400190A4; // weak
int dword_1400190CC; // weak
int dword_1400190D0; // weak
__int64 qword_1400190D4; // weak
__int64 qword_1400190E4; // weak
int dword_1400190EC; // weak
int dword_1400190FC; // weak
int dword_140019100; // weak
__int64 qword_140019104; // weak
__int16 word_140019118; // weak
int dword_14001912C; // weak


//----- (0000000140001815) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  memset(&exam_questions, 0, 0x12C0ui64);
  exam_questions = 1;
  strcpy((char *)&qword_140019044, "What is the capital Paris");
  HIWORD(dword_14001905C) = 25454;
  strcpy((char *)&word_140019060, "e?");
  dword_14001906C = 1;
  dword_140019070 = 2;
  strcpy((char *)&qword_140019074, "What is the largest Asia");
  BYTE1(dword_14001908C) = 110;
  HIWORD(dword_14001908C) = 28261;
  strcpy((char *)&word_140019090, "t?");
  dword_14001909C = 1;
  dword_1400190A0 = 3;
  strcpy((char *)&qword_1400190A4, "What color is the skBlue");
  dword_1400190CC = 1;
  dword_1400190D0 = 4;
  strcpy((char *)&qword_1400190D4, "What is the square r8");
  HIWORD(qword_1400190E4) = 8308;
  strcpy((char *)&dword_1400190EC, "of 64?");
  dword_1400190FC = 1;
  dword_140019100 = 5;
  strcpy((char *)&qword_140019104, "What is 2 + 2?");
  word_140019118 = 52;
  dword_14001912C = 1;
  print_exam_questions();
  grade_exam();
  return 0;
}
// 1400015E2: using guessed type __int64 print_exam_questions(void);
// 14000165A: using guessed type __int64 grade_exam(void);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019040: using guessed type int exam_questions;
// 140019044: using guessed type __int64 qword_140019044;
// 14001905C: using guessed type int dword_14001905C;
// 140019060: using guessed type __int16 word_140019060;
// 14001906C: using guessed type int dword_14001906C;
// 140019070: using guessed type int dword_140019070;
// 140019074: using guessed type __int64 qword_140019074;
// 14001908C: using guessed type int dword_14001908C;
// 140019090: using guessed type __int16 word_140019090;
// 14001909C: using guessed type int dword_14001909C;
// 1400190A0: using guessed type int dword_1400190A0;
// 1400190A4: using guessed type __int64 qword_1400190A4;
// 1400190CC: using guessed type int dword_1400190CC;
// 1400190D0: using guessed type int dword_1400190D0;
// 1400190D4: using guessed type __int64 qword_1400190D4;
// 1400190E4: using guessed type __int64 qword_1400190E4;
// 1400190EC: using guessed type int dword_1400190EC;
// 1400190FC: using guessed type int dword_1400190FC;
// 140019100: using guessed type int dword_140019100;
// 140019104: using guessed type __int64 qword_140019104;
// 140019118: using guessed type __int16 word_140019118;
// 14001912C: using guessed type int dword_14001912C;

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to ASCII art generator ; Style: satisfied
#include <stdio.h>
#include <string.h>

#define MAX_LEN 255 // max length of input string

// function to convert character to ASCII art
void charToArt(char c) {
    switch(c) {
        case 'a':
        case 'A':
            printf("  /\\  \n /  \\ \n/____\\\n/\\   /\\ \n/  \\ /  \\ \n");
            break;
        case 'b':
        case 'B':
            printf("||||| \n||||| \n||||| \n||||| \n||||| \n");
            break;
        case 'c':
        case 'C':
            printf("   _____ \n /      \\\n/        \\\n\\        /\n \\_____/\n");
            break;
        // add more cases for each character
        // ...
        default:
            printf("Cannot convert '%c' to ASCII art.\n", c);
            break;
    }
}

int main() {
    char input[MAX_LEN];
    printf("Enter a string to convert to ASCII art:\n");
    fgets(input, MAX_LEN, stdin);   // read input string from user
    input[strcspn(input, "\n")] = '\0';   // remove newline character
    
    int len = strlen(input);
    for(int i=0; i<len; i++) {
        charToArt(input[i]);    // convert each character to ASCII art
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall charToArt(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001655) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[264]; // [rsp+20h] [rbp-60h] BYREF
  int v6; // [rsp+128h] [rbp+A8h]
  int i; // [rsp+12Ch] [rbp+ACh]

  _main(argc, argv, envp);
  printf("Enter a string to convert to ASCII art:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 255, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  v6 = strlen(Buffer);
  for ( i = 0; i < v6; ++i )
    charToArt((unsigned int)Buffer[i]);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall charToArt(_QWORD);
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001655: using guessed type char Buffer[264];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: mathematical
#include<stdio.h>
#include<math.h>

int main()
{
   int n, i, j, space;
   printf("Enter the value of n: ");
   scanf("%d",&n);
   
   for(i=n; i>=1; i--)
   {
      for(space=0; space<n-i; space++)
         printf("  ");
         
      for(j=i; j<=2*i-1; j++)
         printf("%d ",j);
        
      for(j=0; j<i-1; j++)
         printf("%d ",j+i);
        
      printf("\n");
   }
    
   for(i=2; i<=n; i++)
   {
      for(space=0; space<n-i; space++)
         printf("  ");
         
      for(j=i; j<=2*i-1; j++)
         printf("%d ",j);
        
      for(j=0; j<i-1; j++)
         printf("%d ",j+i);
        
      printf("\n");
   }
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-10h] BYREF
  int j; // [rsp+24h] [rbp-Ch]
  int k; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the value of n: ");
  scanf("%d", &v4);
  for ( i = v4; i > 0; --i )
  {
    for ( j = 0; j < v4 - i; ++j )
      printf("  ");
    for ( k = i; k < 2 * i; ++k )
      printf("%d ", (unsigned int)k);
    for ( k = 0; k < i - 1; ++k )
      printf("%d ", (unsigned int)(k + i));
    printf("\n");
  }
  for ( i = 2; i <= v4; ++i )
  {
    for ( j = 0; j < v4 - i; ++j )
      printf("  ");
    for ( k = i; k < 2 * i; ++k )
      printf("%d ", (unsigned int)k);
    for ( k = 0; k < i - 1; ++k )
      printf("%d ", (unsigned int)(k + i));
    printf("\n");
  }
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define BOARD_SIZE 4

// Function to shuffle the elements of an array
void shuffle(int arr[], int n)
{
    srand(time(NULL));
    for (int i = n - 1; i > 0; i--)
    {
        int j = rand() % (i + 1);
        
        // Swap arr[i] and arr[j]
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

// Function to print the game board
void print_board(int board[BOARD_SIZE][BOARD_SIZE])
{
    printf("\n");
    for (int i = 0; i < BOARD_SIZE; i++)
    {
        for (int j = 0; j < BOARD_SIZE; j++)
        {
            printf("%d ", board[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

int main()
{
    int board[BOARD_SIZE][BOARD_SIZE] = {0};
    
    // Populate the board with numbers
    int numbers[BOARD_SIZE*BOARD_SIZE/2];
    for (int i = 0; i < BOARD_SIZE*BOARD_SIZE/2; i++)
    {
        numbers[i] = i+1;
    }
    shuffle(numbers, BOARD_SIZE*BOARD_SIZE/2);
    
    // Place numbers on the board
    int index = 0;
    for (int i = 0; i < BOARD_SIZE; i++)
    {
        for (int j = 0; j < BOARD_SIZE; j++)
        {
            if (index >= BOARD_SIZE*BOARD_SIZE/2)
            {
                break;
            }
            board[i][j] = numbers[index];
            board[BOARD_SIZE-i-1][BOARD_SIZE-j-1] = numbers[index];
            index++;
        }
        if (index >= BOARD_SIZE*BOARD_SIZE/2)
        {
            break;
        }
    }
    
    // Print the initial board
    print_board(board);
    
    // Main loop of the game
    int row1, col1, row2, col2;
    int remaining_pairs = BOARD_SIZE*BOARD_SIZE/2;
    while (remaining_pairs > 0)
    {
        // Get user input for the first card
        printf("Enter the row and column of the first card: ");
        scanf("%d %d", &row1, &col1);
        while (board[row1][col1] == -1)
        {
            printf("That card has already been matched or is invalid, please choose another: ");
            scanf("%d %d", &row1, &col1);
        }
        printf("The first card is %d\n", board[row1][col1]);
        board[row1][col1] = -1;
        print_board(board);
        
        // Get user input for the second card
        printf("Enter the row and column of the second card: ");
        scanf("%d %d", &row2, &col2);
        while (board[row2][col2] == -1 || (row1 == row2 && col1 == col2))
        {
            printf("That card has already been matched or is invalid, please choose another: ");
            scanf("%d %d", &row2, &col2);
        }
        printf("The second card is %d\n", board[row2][col2]);
        if (board[row1][col1] == board[row2][col2])
        {
            printf("Pair matched!\n");
            board[row2][col2] = -1;
            remaining_pairs--;
        }
        else
        {
            board[row1][col1] = board[row2][col2] = 0;
        }
        print_board(board);
    }
    
    printf("Congratulations, you have found all the pairs!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall shuffle(_QWORD, _QWORD); // weak
__int64 __fastcall print_board(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001740) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int v4; // edx
  int v6; // [rsp+20h] [rbp-90h] BYREF
  int v7; // [rsp+24h] [rbp-8Ch] BYREF
  int v8; // [rsp+28h] [rbp-88h] BYREF
  int v9; // [rsp+2Ch] [rbp-84h] BYREF
  int v10[8]; // [rsp+30h] [rbp-80h] BYREF
  __int64 v11[9]; // [rsp+50h] [rbp-60h] BYREF
  int v12; // [rsp+9Ch] [rbp-14h]
  int k; // [rsp+A0h] [rbp-10h]
  int j; // [rsp+A4h] [rbp-Ch]
  int v15; // [rsp+A8h] [rbp-8h]
  int i; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  memset(v11, 0, 64);
  for ( i = 0; i <= 7; ++i )
    v10[i] = i + 1;
  shuffle(v10, 8i64);
  v15 = 0;
  for ( j = 0; j <= 3; ++j )
  {
    for ( k = 0; k <= 3 && v15 <= 7; ++k )
    {
      *((_DWORD *)&v11[2 * j] + k) = v10[v15];
      *((_DWORD *)&v11[2 * (3 - j)] + 3 - k) = v10[v15++];
    }
    if ( v15 > 7 )
      break;
  }
  print_board(v11);
  v12 = 8;
  while ( v12 > 0 )
  {
    printf("Enter the row and column of the first card: ");
    scanf("%d %d", &v9, &v8);
    while ( *((_DWORD *)&v11[2 * v9] + v8) == -1 )
    {
      printf("That card has already been matched or is invalid, please choose another: ");
      scanf("%d %d", &v9, &v8);
    }
    printf("The first card is %d\n", *((unsigned int *)&v11[2 * v9] + v8));
    *((_DWORD *)&v11[2 * v9] + v8) = -1;
    print_board(v11);
    printf("Enter the row and column of the second card: ");
    scanf("%d %d", &v7, &v6);
    while ( *((_DWORD *)&v11[2 * v7] + v6) == -1 || v9 == v7 && v8 == v6 )
    {
      printf("That card has already been matched or is invalid, please choose another: ");
      scanf("%d %d", &v7, &v6);
    }
    printf("The second card is %d\n", *((unsigned int *)&v11[2 * v7] + v6));
    if ( *((_DWORD *)&v11[2 * v9] + v8) == *((_DWORD *)&v11[2 * v7] + v6) )
    {
      printf("Pair matched!\n");
      *((_DWORD *)&v11[2 * v7] + v6) = -1;
      --v12;
    }
    else
    {
      v3 = v7;
      v4 = v6;
      *((_DWORD *)&v11[2 * v7] + v6) = 0;
      *((_DWORD *)&v11[2 * v9] + v8) = *((_DWORD *)&v11[2 * v3] + v4);
    }
    print_board(v11);
  }
  printf("Congratulations, you have found all the pairs!\n");
  return 0;
}
// 140001601: using guessed type __int64 __fastcall shuffle(_QWORD, _QWORD);
// 1400016AE: using guessed type __int64 __fastcall print_board(_QWORD);
// 140001BD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001740: using guessed type int var_80[8];

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File system simulation ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILES 10
#define MAX_FILENAME_LENGTH 20
#define MAX_FILESIZE 100

struct file {
    char filename[MAX_FILENAME_LENGTH];
    char content[MAX_FILESIZE];
    int size;
};

struct file_system {
    struct file files[MAX_FILES];
    int num_files;
};

// function prototypes
void print_menu();
void add_file(struct file_system *fs);
void delete_file(struct file_system *fs);
void display_files(struct file_system *fs);

int main() {
    struct file_system fs = {0};
    int choice;

    do {
        print_menu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                add_file(&fs);
                break;
            case 2:
                delete_file(&fs);
                break;
            case 3:
                display_files(&fs);
                break;
            case 4:
                printf("Exiting file system...\n");
                break;
            default:
                printf("Invalid choice. Please try again.\n");
        }
    } while (choice != 4);

    return 0;
}

void print_menu() {
    printf("File System Menu\n");
    printf("-----------------\n");
    printf("1. Add file\n");
    printf("2. Delete file\n");
    printf("3. Display files\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

void add_file(struct file_system *fs) {
    if (fs->num_files >= MAX_FILES) {
        printf("Error: maximum number of files reached.\n");
        return;
    }

    struct file new_file;
    printf("Enter filename (max %d characters): ", MAX_FILENAME_LENGTH);
    scanf("%s", new_file.filename);

    for (int i = 0; i < fs->num_files; i++) {
        if (strcmp(fs->files[i].filename, new_file.filename) == 0) {
            printf("Error: filename already exists.\n");
            return;
        }
    }

    printf("Enter file content (max %d characters): ", MAX_FILESIZE);
    scanf("%s", new_file.content);

    new_file.size = strlen(new_file.content);

    fs->files[fs->num_files] = new_file;
    fs->num_files++;

    printf("File added successfully.\n");
}

void delete_file(struct file_system *fs) {
    char filename[MAX_FILENAME_LENGTH];
    printf("Enter filename to delete: ");
    scanf("%s", filename);

    int found = 0;

    for (int i = 0; i < fs->num_files; i++) {
        if (strcmp(fs->files[i].filename, filename) == 0) {
            // found the file to delete
            found = 1;
            for (int j = i; j < fs->num_files - 1; j++) {
                fs->files[j] = fs->files[j+1];
            }
            fs->num_files--;
            printf("File deleted successfully.\n");
            break;
        }
    }

    if (!found) {
        printf("Error: file not found.\n");
    }
}

void display_files(struct file_system *fs) {
    if (fs->num_files == 0) {
        printf("No files to display.\n");
        return;
    }

    printf("Filename\t\tSize\n");
    printf("--------------------------------------\n");

    for (int i = 0; i < fs->num_files; i++) {
        printf("%s\t\t%d\n", fs->files[i].filename, fs->files[i].size);
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall print_menu(_QWORD, _QWORD); // weak
__int64 __fastcall add_file(_QWORD); // weak
__int64 __fastcall delete_file(_QWORD); // weak
__int64 __fastcall display_files(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rcx
  int *v4; // rdx
  int v6; // [rsp+2Ch] [rbp-54h] BYREF
  char v7[1240]; // [rsp+30h] [rbp-50h] BYREF
  int v8; // [rsp+508h] [rbp+488h]
  int v9; // [rsp+50Ch] [rbp+48Ch] BYREF

  _main(argc, argv, envp);
  memset(v7, 0, sizeof(v7));
  v3 = 0i64;
  v8 = 0;
  v4 = &v9;
  do
  {
    print_menu(v3, v4);
    scanf("%d", &v6);
    if ( v6 == 4 )
    {
      printf("Exiting file system...\n");
    }
    else
    {
      if ( v6 <= 4 )
      {
        switch ( v6 )
        {
          case 3:
            display_files(v7);
            continue;
          case 1:
            add_file(v7);
            continue;
          case 2:
            delete_file(v7);
            continue;
        }
      }
      printf("Invalid choice. Please try again.\n");
    }
  }
  while ( v6 != 4 );
  return 0;
}
// 140001645: conditional instruction was optimized away because %var_4F4.4<3
// 140001615: variable 'v3' is possibly undefined
// 140001615: variable 'v4' is possibly undefined
// 1400016B8: using guessed type __int64 __fastcall print_menu(_QWORD, _QWORD);
// 140001730: using guessed type __int64 __fastcall add_file(_QWORD);
// 1400018FF: using guessed type __int64 __fastcall delete_file(_QWORD);
// 140001AB3: using guessed type __int64 __fastcall display_files(_QWORD);
// 140001C30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Compression algorithms ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * This program demonstrates a unique compression algorithm that works by
 * replacing repetitive characters with a single byte that represents the
 * character and the number of times it appears. For example, if there are
 * eight consecutive 'A' characters, they are replaced by a single byte that
 * contains the value 'A' and the number 8.
 *
 * To compress a string, simply call the compress function with a pointer to 
 * the string and its length. The compressed string is returned as a new 
 * string and its length is also returned. To decompress a string, call the
 * decompress function with a pointer to the compressed string and its length.
 * The decompressed string is returned as a new string and its length is also
 * returned.
 */

 /**
  * This function compresses a string using a unique compression algorithm.
  *
  * @param str The string to be compressed
  * @param len The length of the string to be compressed
  * @return The compressed string and its length
  */
char* compress(char* str, int len) {
    char* compressed_str = (char*)malloc(len * sizeof(char));
    int index = 0;
    for (int i = 0; i < len; i++) {
        int count = 1;
        while (i < len - 1 && str[i] == str[i + 1]) {
            count++;
            i++;
        }
        if (count > 1) {
            compressed_str[index++] = str[i];
            compressed_str[index++] = count + '0';
        } else {
            compressed_str[index++] = str[i];
        }
    }
    compressed_str[index] = '\0';
    return strdup(compressed_str);
}

/**
 * This function decompresses a string that was compressed using the unique
 * compression algorithm.
 *
 * @param str The string to be decompressed
 * @param len The length of the string to be decompressed
 * @return The decompressed string and its length
 */
char* decompress(char* str, int len) {
    char* decompressed_str = (char*)malloc(len * sizeof(char));
    int index = 0;
    for (int i = 0; i < len; i++) {
        if (isdigit(str[i])) {
            int count = str[i] - '0';
            for (int j = 0; j < count - 1; j++) {
                decompressed_str[index++] = decompressed_str[index - 1];
            }
        } else {
            decompressed_str[index++] = str[i];
        }
    }
    decompressed_str[index] = '\0';
    return strdup(decompressed_str);
}

/**
 * This is the main function of the program.
 */
int main() {
    char str[] = "AAAAAAAAAABBCDEEEEEE";
    char* compressed_str = compress(str, strlen(str));
    printf("Compressed String: %s\n", compressed_str);

    char* decompressed_str = decompress(compressed_str, strlen(compressed_str));
    printf("Decompressed String: %s\n", decompressed_str);

    free(compressed_str);
    free(decompressed_str);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall compress(_QWORD, _QWORD); // weak
__int64 __fastcall decompress(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void __cdecl free(void *Block);


//----- (00000001400017AC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  char Str[32]; // [rsp+20h] [rbp-30h] BYREF
  void *Block; // [rsp+40h] [rbp-10h]
  char *v8; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  strcpy(Str, "AAAAAAAAAABBCDEEEEEE");
  v3 = strlen(Str);
  v8 = (char *)compress(Str, v3);
  printf("Compressed String: %s\n", v8);
  v4 = strlen(v8);
  Block = (void *)decompress(v8, v4);
  printf("Decompressed String: %s\n", (const char *)Block);
  free(v8);
  free(Block);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall compress(_QWORD, _QWORD);
// 1400016AA: using guessed type __int64 __fastcall decompress(_QWORD, _QWORD);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Medical Store Management System ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct medicine {
    int id;
    char name[50];
    int quantity;
    float price;
};

typedef struct medicine Medicine;

void displayMenu() {
    printf("********** Medical Store Management System **********\n");
    printf("1. Add Medicine\n");
    printf("2. Sell Medicine\n");
    printf("3. Update Medicine Information\n");
    printf("4. View All Medicines\n");
    printf("5. View Medicine Information\n");
    printf("6. Exit\n");
    printf("********************************************************\n");
}

int getMedicineIndexById(Medicine *medicines, int id, int n) {
    for(int i = 0; i < n; i++) {
        if(medicines[i].id == id) {
            return i;
        }
    }
    return -1;
}

void addMedicine(Medicine *medicines, int *n) {
    Medicine med;
    printf("Enter Medicine ID: ");
    scanf("%d", &med.id);
    printf("Enter Medicine Name: ");
    scanf("%s", med.name);
    printf("Enter Medicine Quantity: ");
    scanf("%d", &med.quantity);
    printf("Enter Medicine Price: ");
    scanf("%f", &med.price);
    medicines[*n] = med;
    (*n)++;
}

void sellMedicine(Medicine *medicines, int n, int id) {
    int index = getMedicineIndexById(medicines, id, n);
    if(index == -1) {
        printf("Medicine not found!\n");
        return;
    }
    printf("Enter Quantity to Sell: ");
    int quantity;
    scanf("%d", &quantity);
    if(quantity > medicines[index].quantity) {
        printf("Insufficient quantity!\n");
        return;
    }
    medicines[index].quantity -= quantity;
    printf("Total Price: %.2f\n", quantity * medicines[index].price);
}

void updateMedicine(Medicine *medicines, int n, int id) {
    int index = getMedicineIndexById(medicines, id, n);
    if(index == -1) {
        printf("Medicine not found!\n");
        return;
    }
    printf("Enter New Medicine Name (Press Enter to skip): ");
    char name[50];
    getchar(); // Consume newline character left by previous scanf
    fgets(name, 50, stdin);
    if(strlen(name) > 0 && name[strlen(name) - 1] == '\n') {
        name[strlen(name) - 1] = '\0';
    }
    if(strlen(name) > 0) {
        strcpy(medicines[index].name, name);
    }
    printf("Enter New Medicine Quantity (Press 0 to skip): ");
    int quantity;
    scanf("%d", &quantity);
    if(quantity > 0) {
        medicines[index].quantity = quantity;
    }
    printf("Enter New Medicine Price (Press 0.0 to skip): ");
    float price;
    scanf("%f", &price);
    if(price > 0.0) {
        medicines[index].price = price;
    }
}

void viewAllMedicines(Medicine *medicines, int n) {
    printf("ID\tName\tQuantity\tPrice\n");
    for(int i = 0; i < n; i++) {
        printf("%d\t%s\t%d\t\t%.2f\n", medicines[i].id, medicines[i].name, medicines[i].quantity, medicines[i].price);
    }
}

void viewMedicineInfo(Medicine *medicines, int n, int id) {
    int index = getMedicineIndexById(medicines, id, n);
    if(index == -1) {
        printf("Medicine not found!\n");
        return;
    }
    printf("ID\tName\tQuantity\tPrice\n");
    printf("%d\t%s\t%d\t\t%.2f\n", medicines[index].id, medicines[index].name, medicines[index].quantity, medicines[index].price);
}

int main() {
    Medicine medicines[100];
    int n = 0;
    int choice;
    do {
        displayMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch(choice) {
            case 1:
                addMedicine(medicines, &n);
                break;
            case 2:
                {
                    int id;
                    printf("Enter Medicine ID to Sell: ");
                    scanf("%d", &id);
                    sellMedicine(medicines, n, id);
                    break;
                }
            case 3:
                {
                    int id;
                    printf("Enter Medicine ID to Update: ");
                    scanf("%d", &id);
                    updateMedicine(medicines, n, id);
                    break;
                }
            case 4:
                viewAllMedicines(medicines, n);
                break;
            case 5:
                {
                    int id;
                    printf("Enter Medicine ID to View Info: ");
                    scanf("%d", &id);
                    viewMedicineInfo(medicines, n, id);
                    break;
                }
            case 6:
                printf("Exiting!\n");
                break;
            default:
                printf("Invalid choice! Try again.\n");
        }
    } while(choice != 6);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 displayMenu(void); // weak
__int64 __fastcall addMedicine(_QWORD, _QWORD); // weak
__int64 __fastcall sellMedicine(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall updateMedicine(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall viewAllMedicines(_QWORD, _QWORD); // weak
__int64 __fastcall viewMedicineInfo(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001C08) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-54h] BYREF
  unsigned int v5; // [rsp+30h] [rbp-50h] BYREF
  unsigned int v6; // [rsp+34h] [rbp-4Ch] BYREF
  int v7; // [rsp+38h] [rbp-48h] BYREF
  unsigned int v8; // [rsp+3Ch] [rbp-44h] BYREF
  char v9[6400]; // [rsp+40h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  v8 = 0;
  do
  {
    displayMenu();
    printf("Enter your choice: ");
    scanf("%d", &v7);
    switch ( v7 )
    {
      case 1:
        addMedicine(v9, &v8);
        break;
      case 2:
        printf("Enter Medicine ID to Sell: ");
        scanf("%d", &v6);
        sellMedicine(v9, v8, v6);
        break;
      case 3:
        printf("Enter Medicine ID to Update: ");
        scanf("%d", &v5);
        updateMedicine(v9, v8, v5);
        break;
      case 4:
        viewAllMedicines(v9, v8);
        break;
      case 5:
        printf("Enter Medicine ID to View Info: ");
        scanf("%d", &v4);
        viewMedicineInfo(v9, v8, v4);
        break;
      case 6:
        printf("Exiting!\n");
        break;
      default:
        printf("Invalid choice! Try again.\n");
        break;
    }
  }
  while ( v7 != 6 );
  return 0;
}
// 1400015E2: using guessed type __int64 displayMenu(void);
// 1400016BB: using guessed type __int64 __fastcall addMedicine(_QWORD, _QWORD);
// 1400017DA: using guessed type __int64 __fastcall sellMedicine(_QWORD, _QWORD, _QWORD);
// 1400018FA: using guessed type __int64 __fastcall updateMedicine(_QWORD, _QWORD, _QWORD);
// 140001A79: using guessed type __int64 __fastcall viewAllMedicines(_QWORD, _QWORD);
// 140001B33: using guessed type __int64 __fastcall viewMedicineInfo(_QWORD, _QWORD, _QWORD);
// 140001E50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: protected
#include <stdio.h>

void printFibonacci(int n) {
    int arr[n];
    
    // initialize the first two elements in the sequence
    arr[0] = 0;
    arr[1] = 1;
    
    for (int i = 2; i < n; i++) {
        // compute the next element in the sequence
        arr[i] = arr[i - 1] + arr[i - 2];
    }
    
    // display the sequence on the screen
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int n;
    
    printf("Enter the number of elements in the sequence: ");
    scanf("%d", &n);
    
    printf("Fibonacci sequence:\n");
    printFibonacci(n);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall printFibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the number of elements in the sequence: ");
  scanf("%d", &v4);
  printf("Fibonacci sequence:\n");
  printFibonacci(v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall printFibonacci(_QWORD);
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedurally Generated Maze ; Style: surrealist
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

#define SIZE 20

int maze[SIZE][SIZE];

void generateMaze(int row, int col)
{
    if((row < 0 || row >= SIZE) || (col < 0 || col >= SIZE)) //check if current position is out of maze
        return;

    if(maze[row][col] == 1) //check if current position is already visited
        return;

    maze[row][col] = 1; //mark current position as visited

    // randomly select direction to move
    int dirs[4] = {1, 2, 3, 4};
    for(int i = 0; i < 4; i++)
    {
        int randIndex = rand() % 4;
        int temp = dirs[i];
        dirs[i] = dirs[randIndex];
        dirs[randIndex] = temp;
    }

    // move in randomly selected direction
    for(int i = 0; i < 4; i++)
    {
        switch(dirs[i])
        {
            case 1: // move up
                generateMaze(row-1, col);
                break;
            case 2: // move down
                generateMaze(row+1, col);
                break;
            case 3: // move left
                generateMaze(row, col-1);
                break;
            case 4: // move right
                generateMaze(row, col+1);
                break;
        }
    }
}

int main()
{
    srand(time(NULL)); // seed for random number generation

    // fill maze with 0s
    for(int i = 0; i < SIZE; i++)
    {
        for(int j = 0; j < SIZE; j++)
        {
            maze[i][j] = 0;
        }
    }

    int startingRow = rand() % SIZE; // randomly select starting row
    int startingCol = rand() % SIZE; // randomly select starting column

    generateMaze(startingRow, startingCol);

    // print generated maze
    for(int i = 0; i < SIZE; i++)
    {
        for(int j = 0; j < SIZE; j++)
        {
            if(maze[i][j] == 0) // print black box for unvisited position
                printf("\x1b[48;5;16m  \x1b[0m");
            else                // print white box for visited position
                printf("\x1b[48;5;231m  \x1b[0m");
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall generateMaze(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();

//-------------------------------------------------------------------------
// Data declarations

_DWORD maze[400]; // weak


//----- (000000014000174C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+28h] [rbp-18h]
  unsigned int v6; // [rsp+2Ch] [rbp-14h]
  int m; // [rsp+30h] [rbp-10h]
  int k; // [rsp+34h] [rbp-Ch]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 19; ++i )
  {
    for ( j = 0; j <= 19; ++j )
      maze[20 * i + j] = 0;
  }
  v6 = rand() % 20;
  v5 = rand() % 20;
  generateMaze(v6, v5);
  for ( k = 0; k <= 19; ++k )
  {
    for ( m = 0; m <= 19; ++m )
    {
      if ( maze[20 * k + m] )
        printf("\x1B[48;5;231m  \x1B[0m");
      else
        printf("\x1B[48;5;16m  \x1B[0m");
    }
    printf("\n");
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall generateMaze(_QWORD, _QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type _DWORD maze[400];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: systematic
#include <stdio.h>

int main() {
  float weight, height, BMI;
  int minutes, caloriesBurned;

  // Get user input for weight and height
  printf("Enter your weight in kilograms: ");
  scanf("%f", &weight);
  printf("Enter your height in meters: ");
  scanf("%f", &height);

  // Calculate BMI
  BMI = weight / (height * height);
  printf("Your BMI is: %.2f\n", BMI);

  // Ask user for exercise details
  printf("How many minutes did you exercise today? ");
  scanf("%d", &minutes);

  // Calculate calories burned based on activity level and weight
  if (BMI < 18.5) {
    // Underweight
    caloriesBurned = minutes * 6 * (int) weight;
  } else if (BMI >= 18.5 && BMI < 25) {
    // Normal weight
    caloriesBurned = minutes * 4 * (int) weight;
  } else if (BMI >= 25 && BMI < 30) {
    // Overweight
    caloriesBurned = minutes * 3 * (int) weight;
  } else {
    // Obese
    caloriesBurned = minutes * 2 * (int) weight;
  }

  printf("You burned %d calories today!\n", caloriesBurned);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-14h] BYREF
  float v5; // [rsp+30h] [rbp-10h] BYREF
  float v6; // [rsp+34h] [rbp-Ch] BYREF
  float v7; // [rsp+38h] [rbp-8h]
  unsigned int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter your weight in kilograms: ");
  scanf("%f", &v6);
  printf("Enter your height in meters: ");
  scanf("%f", &v5);
  v7 = v6 / (float)(v5 * v5);
  printf("Your BMI is: %.2f\n", v7);
  printf("How many minutes did you exercise today? ");
  scanf("%d", &v4);
  if ( v7 >= 18.5 )
  {
    if ( v7 >= 25.0 )
    {
      if ( v7 >= 30.0 )
        v8 = 2 * (int)v6 * v4;
      else
        v8 = 3 * v4 * (int)v6;
    }
    else
    {
      v8 = 4 * (int)v6 * v4;
    }
  }
  else
  {
    v8 = 6 * v4 * (int)v6;
  }
  printf("You burned %d calories today!\n", v8);
  return 0;
}
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Checkers Game ; Style: standalone
#include <stdio.h>

int main() {
    //initialize board
    int board[8][8] = {
        {0, 2, 0, 2, 0, 2, 0, 2},
        {2, 0, 2, 0, 2, 0, 2, 0},
        {0, 2, 0, 2, 0, 2, 0, 2},
        {1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1},
        {3, 0, 3, 0, 3, 0, 3, 0},
        {0, 3, 0, 3, 0, 3, 0, 3},
        {3, 0, 3, 0, 3, 0, 3, 0}
    };
    
    //initialize players
    int player1 = 1; //1 for red, 2 for black
    int player2 = 2;
    
    //initialize turn
    int turn = player1;
    
    //initialize game loop
    int gameover = 0;
    
    while (!gameover) {
        //print board
        printf("    0 1 2 3 4 5 6 7\n");
        for (int i = 0; i < 8; i++) {
            printf("%d  ", i);
            for (int j = 0; j < 8; j++) {
                printf("%d ", board[i][j]);
            }
            printf("\n");
        }
        
        //get input
        int startx, starty, endx, endy;
        printf("Player %d, enter starting coordinates (x y): ", turn);
        scanf("%d %d", &startx, &starty);
        printf("Player %d, enter ending coordinates (x y): ", turn);
        scanf("%d %d", &endx, &endy);
        
        //validate input
        if (startx < 0 || startx > 7 || starty < 0 || starty > 7 ||
            endx < 0 || endx > 7 || endy < 0 || endy > 7) {
            printf("Invalid coordinates. Try again.\n");
            continue;
        }
        if (board[startx][starty] != turn && board[startx][starty] != turn+1) {
            printf("You don't have a piece there. Try again.\n");
            continue;
        }
        if (board[endx][endy] != 0) {
            printf("There's already a piece there. Try again.\n");
            continue;
        }
        if (abs(endx-startx) != 1 || abs(endy-starty) != 1) {
            printf("You can only move one space diagonally. Try again.\n");
            continue;
        }
        
        //make move
        board[endx][endy] = board[startx][starty];
        board[startx][starty] = 0;
        
        //check for gameover
        int redpieces = 0;
        int blackpieces = 0;
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (board[i][j] == 1 || board[i][j] == 3) {
                    redpieces++;
                } else if (board[i][j] == 2 || board[i][j] == 4) {
                    blackpieces++;
                }
            }
        }
        
        if (redpieces == 0 || blackpieces == 0) {
            gameover = 1;
            printf("Player %d wins!\n", turn);
        }
        
        //switch turn
        if (turn == player1) {
            turn = player2;
        } else {
            turn = player1;
        }
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v6; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v7; // [rsp+24h] [rbp-5Ch] BYREF
  unsigned int v8; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v9; // [rsp+2Ch] [rbp-54h] BYREF
  int v10[66]; // [rsp+30h] [rbp-50h]
  unsigned int v11; // [rsp+138h] [rbp+B8h]
  unsigned int v12; // [rsp+13Ch] [rbp+BCh]
  int m; // [rsp+140h] [rbp+C0h]
  int k; // [rsp+144h] [rbp+C4h]
  int v15; // [rsp+148h] [rbp+C8h]
  int v16; // [rsp+14Ch] [rbp+CCh]
  int j; // [rsp+150h] [rbp+D0h]
  unsigned int i; // [rsp+154h] [rbp+D4h]
  int v19; // [rsp+158h] [rbp+D8h]
  unsigned int v20; // [rsp+15Ch] [rbp+DCh]

  _main(argc, argv, envp);
  v10[0] = 0;
  v10[1] = 2;
  v10[2] = 0;
  v10[3] = 2;
  v10[4] = 0;
  v10[5] = 2;
  v10[6] = 0;
  v10[7] = 2;
  v10[8] = 2;
  v10[9] = 0;
  v10[10] = 2;
  v10[11] = 0;
  v10[12] = 2;
  v10[13] = 0;
  v10[14] = 2;
  v10[15] = 0;
  v10[16] = 0;
  v10[17] = 2;
  v10[18] = 0;
  v10[19] = 2;
  v10[20] = 0;
  v10[21] = 2;
  v10[22] = 0;
  v10[23] = 2;
  v10[24] = 1;
  v10[25] = 0;
  v10[26] = 1;
  v10[27] = 0;
  v10[28] = 1;
  v10[29] = 0;
  v10[30] = 1;
  v10[31] = 0;
  v10[32] = 0;
  v10[33] = 1;
  v10[34] = 0;
  v10[35] = 1;
  v10[36] = 0;
  v10[37] = 1;
  v10[38] = 0;
  v10[39] = 1;
  v10[40] = 3;
  v10[41] = 0;
  v10[42] = 3;
  v10[43] = 0;
  v10[44] = 3;
  v10[45] = 0;
  v10[46] = 3;
  v10[47] = 0;
  v10[48] = 0;
  v10[49] = 3;
  v10[50] = 0;
  v10[51] = 3;
  v10[52] = 0;
  v10[53] = 3;
  v10[54] = 0;
  v10[55] = 3;
  v10[56] = 3;
  v10[57] = 0;
  v10[58] = 3;
  v10[59] = 0;
  v10[60] = 3;
  v10[61] = 0;
  v10[62] = 3;
  v10[63] = 0;
  v12 = 1;
  v11 = 2;
  v20 = 1;
  v19 = 0;
  while ( !v19 )
  {
    printf("    0 1 2 3 4 5 6 7\n");
    for ( i = 0; (int)i <= 7; ++i )
    {
      printf("%d  ", i);
      for ( j = 0; j <= 7; ++j )
        printf("%d ", (unsigned int)v10[8 * i + j]);
      printf("\n");
    }
    printf("Player %d, enter starting coordinates (x y): ", v20);
    scanf("%d %d", &v9, &v8);
    printf("Player %d, enter ending coordinates (x y): ", v20);
    scanf("%d %d", &v7, &v6);
    if ( v9 <= 7 && v8 <= 7 && v7 <= 7 && v6 < 8 )
    {
      if ( v20 == v10[8 * v9 + v8] || v10[8 * v9 + v8] == v20 + 1 )
      {
        if ( v10[8 * v7 + v6] )
        {
          printf("There's already a piece there. Try again.\n");
        }
        else
        {
          v3 = v7 - v9;
          if ( (int)(v9 - v7) >= 0 )
            v3 = v9 - v7;
          if ( v3 != 1 )
            goto LABEL_24;
          v4 = v6 - v8;
          if ( (int)(v8 - v6) >= 0 )
            v4 = v8 - v6;
          if ( v4 == 1 )
          {
            v10[8 * v7 + v6] = v10[8 * v9 + v8];
            v10[8 * v9 + v8] = 0;
            v16 = 0;
            v15 = 0;
            for ( k = 0; k <= 7; ++k )
            {
              for ( m = 0; m <= 7; ++m )
              {
                if ( v10[8 * k + m] == 1 || v10[8 * k + m] == 3 )
                {
                  ++v16;
                }
                else if ( v10[8 * k + m] == 2 || v10[8 * k + m] == 4 )
                {
                  ++v15;
                }
              }
            }
            if ( !v16 || !v15 )
            {
              v19 = 1;
              printf("Player %d wins!\n", v20);
            }
            if ( v20 == v12 )
              v20 = v11;
            else
              v20 = v12;
          }
          else
          {
LABEL_24:
            printf("You can only move one space diagonally. Try again.\n");
          }
        }
      }
      else
      {
        printf("You don't have a piece there. Try again.\n");
      }
    }
    else
    {
      printf("Invalid coordinates. Try again.\n");
    }
  }
  return 0;
}
// 140001C80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: light-weight
#include <stdio.h>
#include <string.h>

int main() {
    char password[50];
    int score = 0;

    printf("Enter password: ");
    fgets(password, sizeof(password), stdin);

    int length = strlen(password) - 1;

    // Check length of the password
    if (length >= 8) {
        score++;
    } else {
        printf("Password must be at least 8 characters long.\n");
    }

    // Check if password contains at least one uppercase character
    for (int i = 0; i < length; i++) {
        char character = password[i];
        if (character >= 'A' && character <= 'Z') {
            score++;
            break;
        }
    }

    // Check if password contains at least one lowercase character
    for (int i = 0; i < length; i++) {
        char character = password[i];
        if (character >= 'a' && character <= 'z') {
            score++;
            break;
        }
    }

    // Check if password contains at least one number
    for (int i = 0; i < length; i++) {
        char character = password[i];
        if (character >= '0' && character <= '9') {
            score++;
            break;
        }
    }

    // Check if password contains at least one special character
    for (int i = 0; i < length; i++) {
        char character = password[i];
        if ((character >= ' ' && character <= '/') || 
            (character >= ':' && character <= '@') ||
            (character >= '[' && character <= '``') ||
            (character >= '{' && character <= '~')) {
            score++;
            break;
        }
    }

    // Check the strength score of the password
    if (length == 0) {
        printf("Password cannot be empty.\n");
    } else if (score == 1) {
        printf("Password is weak.\n");
    } else if (score == 2) {
        printf("Password is moderate.\n");
    } else if (score == 3) {
        printf("Password is strong.\n");
    } else if (score == 4) {
        printf("Password is very strong.\n");
    } else {
        printf("Invalid password.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[52]; // [rsp+20h] [rbp-50h] BYREF
  char v6; // [rsp+54h] [rbp-1Ch]
  char v7; // [rsp+55h] [rbp-1Bh]
  char v8; // [rsp+56h] [rbp-1Ah]
  char v9; // [rsp+57h] [rbp-19h]
  int v10; // [rsp+58h] [rbp-18h]
  int m; // [rsp+5Ch] [rbp-14h]
  int k; // [rsp+60h] [rbp-10h]
  int j; // [rsp+64h] [rbp-Ch]
  int i; // [rsp+68h] [rbp-8h]
  int v15; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  v15 = 0;
  printf("Enter password: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 50, v3);
  v10 = strlen(Buffer) - 1;
  if ( v10 <= 7 )
    printf("Password must be at least 8 characters long.\n");
  else
    ++v15;
  for ( i = 0; i < v10; ++i )
  {
    v9 = Buffer[i];
    if ( v9 > 64 && v9 <= 90 )
    {
      ++v15;
      break;
    }
  }
  for ( j = 0; j < v10; ++j )
  {
    v8 = Buffer[j];
    if ( v8 > 96 && v8 <= 122 )
    {
      ++v15;
      break;
    }
  }
  for ( k = 0; k < v10; ++k )
  {
    v7 = Buffer[k];
    if ( v7 > 47 && v7 <= 57 )
    {
      ++v15;
      break;
    }
  }
  for ( m = 0; m < v10; ++m )
  {
    v6 = Buffer[m];
    if ( v6 > 31 && v6 <= 47 || v6 > 57 && v6 <= 64 || v6 > 90 && v6 <= 96 || v6 > 122 && v6 != 127 )
    {
      ++v15;
      break;
    }
  }
  if ( v10 )
  {
    switch ( v15 )
    {
      case 1:
        printf("Password is weak.\n");
        break;
      case 2:
        printf("Password is moderate.\n");
        break;
      case 3:
        printf("Password is strong.\n");
        break;
      case 4:
        printf("Password is very strong.\n");
        break;
      default:
        printf("Invalid password.\n");
        break;
    }
  }
  else
  {
    printf("Password cannot be empty.\n");
  }
  return 0;
}
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[52];

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedural Space Adventure ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int x;
    int y;
} Position;

typedef struct {
    int fuel;
    int health;
    int score;
    Position position;
} Spaceship;

typedef struct {
    char name[20];
    Position position;
} Planet;

void print_planets(Planet planets[], int num_planets) {
    for (int i = 0; i < num_planets; i++) {
        printf("%d. %s (%d, %d)\n", i+1, planets[i].name, planets[i].position.x, planets[i].position.y);
    }
}

void print_spaceship(Spaceship spaceship) {
    printf("Fuel: %d\n", spaceship.fuel);
    printf("Health: %d\n", spaceship.health);
    printf("Score: %d\n", spaceship.score);
    printf("Position: (%d, %d)\n", spaceship.position.x, spaceship.position.y);
}

int main() {
    int num_planets = 5;
    Planet planets[num_planets];
    
    for (int i = 0; i < num_planets; i++) {
        printf("Enter planet #%d name: ", i+1);
        scanf("%s", planets[i].name);
        printf("Enter planet #%d x coordinate: ", i+1);
        scanf("%d", &planets[i].position.x);
        printf("Enter planet #%d y coordinate: ", i+1);
        scanf("%d", &planets[i].position.y);
    }
    
    printf("Planets:\n");
    print_planets(planets, num_planets);
    
    Spaceship spaceship = {100, 100, 0, {0, 0}};
    
    while (1) {
        printf("What would you like to do?\n");
        printf("1. Travel to planet\n");
        printf("2. Refuel spaceship\n");
        printf("3. Repair spaceship\n");
        printf("4. Quit\n");
        
        int choice = 0;
        scanf("%d", &choice);
        
        switch (choice) {
            case 1:
            {
                printf("Choose a planet to travel to:\n");
                print_planets(planets, num_planets);
                
                int planet_choice = 0;
                scanf("%d", &planet_choice);
                
                if (planet_choice >= 1 && planet_choice <= num_planets) {
                    Planet planet = planets[planet_choice-1];
                    int distance = abs(spaceship.position.x - planet.position.x) + abs(spaceship.position.y - planet.position.y);
                    int fuel_required = distance * 10;
                    
                    if (fuel_required > spaceship.fuel) {
                        printf("Not enough fuel to travel to %s\n", planet.name);
                    } else {
                        spaceship.fuel -= fuel_required;
                        spaceship.position = planet.position;
                        printf("Traveled to %s in %d turns\n", planet.name, distance);
                        
                        // Chance of encountering aliens
                        int chance = rand() % 10;
                        if (chance == 0) {
                            printf("Aliens have attacked your ship! -10 health\n");
                            spaceship.health -= 10;
                            if (spaceship.health <= 0) {
                                printf("Your spaceship has been destroyed. Game over.\n");
                                exit(0);   
                            }
                        }
                        
                        // Chance of finding treasure
                        chance = rand() % 10;
                        if (chance == 0) {
                            int treasure = rand() % 100;
                            printf("You discovered %d points worth of treasure!\n", treasure);
                            spaceship.score += treasure; 
                        }
                    }
                } else {
                    printf("Invalid choice\n");
                }
            }
            break;
            
            case 2:
            {
                printf("Refueling spaceship...\n");
                spaceship.fuel = 100;
                printf("Spaceship refueled!\n");
            }
            break;
            
            case 3:
            {
                printf("Repairing spaceship...\n");
                spaceship.health = 100;
                printf("Spaceship repaired!\n");
            }
            break;
            
            case 4:
            {
                printf("Quitting game...\n");
                exit(0);
            }
            break;
            
            default:
            {
                printf("Invalid choice\n");
            }
            break;
        }
        
        print_spaceship(spaceship);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall print_planets(_QWORD, _QWORD); // weak
__int64 __fastcall print_spaceship(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001705) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  char *v4; // rax
  __int64 v5; // rbx
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  __int64 v9[2]; // [rsp+20h] [rbp-90h] BYREF
  int v10; // [rsp+30h] [rbp-80h]
  __int64 v11[2]; // [rsp+40h] [rbp-70h] BYREF
  _BYTE v12[12]; // [rsp+50h] [rbp-60h]
  int v13; // [rsp+68h] [rbp-48h] BYREF
  int v14; // [rsp+6Ch] [rbp-44h] BYREF
  __int64 v15; // [rsp+70h] [rbp-40h]
  __int64 v16[2]; // [rsp+78h] [rbp-38h] BYREF
  unsigned int v17; // [rsp+88h] [rbp-28h]
  int v18; // [rsp+8Ch] [rbp-24h]
  int v19; // [rsp+90h] [rbp-20h]
  unsigned int v20; // [rsp+94h] [rbp-1Ch]
  __int64 *v21; // [rsp+98h] [rbp-18h]
  __int64 v22; // [rsp+A0h] [rbp-10h]
  unsigned int v23; // [rsp+A8h] [rbp-8h]
  int i; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v23 = 5;
  v22 = 4i64;
  v3 = alloca(144i64);
  v21 = v9;
  for ( i = 0; i < (int)v23; ++i )
  {
    printf("Enter planet #%d name: ", (unsigned int)(i + 1));
    scanf("%s", (char *)v21 + 28 * i);
    printf("Enter planet #%d x coordinate: ", (unsigned int)(i + 1));
    scanf("%d", (char *)v21 + 28 * i + 20);
    printf("Enter planet #%d y coordinate: ", (unsigned int)(i + 1));
    scanf("%d", (char *)v21 + 28 * i + 24);
  }
  printf("Planets:\n");
  print_planets(v21, v23);
  v15 = 0x6400000064i64;
  memset(v16, 0, 12);
  while ( 1 )
  {
    printf("What would you like to do?\n");
    printf("1. Travel to planet\n");
    printf("2. Refuel spaceship\n");
    printf("3. Repair spaceship\n");
    printf("4. Quit\n");
    v14 = 0;
    scanf("%d", &v14);
    if ( v14 == 4 )
    {
      printf("Quitting game...\n");
      exit(0);
    }
    if ( v14 > 4 )
      goto LABEL_29;
    if ( v14 == 3 )
    {
      printf("Repairing spaceship...\n");
      HIDWORD(v15) = 100;
      printf("Spaceship repaired!\n");
      goto LABEL_30;
    }
    if ( v14 != 1 )
      break;
    printf("Choose a planet to travel to:\n");
    print_planets(v21, v23);
    v13 = 0;
    scanf("%d", &v13);
    if ( v13 <= 0 || (int)v23 < v13 )
      goto LABEL_29;
    v4 = (char *)v21 + 28 * v13 - 28;
    v5 = *((_QWORD *)v4 + 1);
    v11[0] = *(_QWORD *)v4;
    v11[1] = v5;
    *(_QWORD *)v12 = *((_QWORD *)v4 + 2);
    *(_DWORD *)&v12[8] = *((_DWORD *)v4 + 6);
    v6 = HIDWORD(v16[0]) - *(_DWORD *)&v12[4];
    if ( *(_DWORD *)&v12[4] - HIDWORD(v16[0]) >= 0 )
      v6 = *(_DWORD *)&v12[4] - HIDWORD(v16[0]);
    v7 = v6;
    v8 = LODWORD(v16[1]) - *(_DWORD *)&v12[8];
    if ( *(_DWORD *)&v12[8] - LODWORD(v16[1]) >= 0 )
      v8 = *(_DWORD *)&v12[8] - LODWORD(v16[1]);
    v20 = v7 + v8;
    v19 = 10 * (v7 + v8);
    if ( v19 <= (int)v15 )
    {
      LODWORD(v15) = v15 - v19;
      *(__int64 *)((char *)v16 + 4) = *(_QWORD *)&v12[4];
      printf("Traveled to %s in %d turns\n", (const char *)v11, v20);
      v18 = rand() % 10;
      if ( !v18 )
      {
        printf("Aliens have attacked your ship! -10 health\n");
        HIDWORD(v15) -= 10;
        if ( SHIDWORD(v15) <= 0 )
        {
          printf("Your spaceship has been destroyed. Game over.\n");
          exit(0);
        }
      }
      v18 = rand() % 10;
      if ( !v18 )
      {
        v17 = rand() % 100;
        printf("You discovered %d points worth of treasure!\n", v17);
        LODWORD(v16[0]) += v17;
      }
    }
    else
    {
      printf("Not enough fuel to travel to %s\n", (const char *)v11);
    }
LABEL_30:
    v9[0] = v15;
    v9[1] = v16[0];
    v10 = v16[1];
    print_spaceship(v9);
  }
  if ( v14 == 2 )
  {
    printf("Refueling spaceship...\n");
    LODWORD(v15) = 100;
    printf("Spaceship refueled!\n");
    goto LABEL_30;
  }
LABEL_29:
  printf("Invalid choice\n");
  goto LABEL_30;
}
// 140001994: conditional instruction was optimized away because %var_74.4<3
// 1400015E2: using guessed type __int64 __fastcall print_planets(_QWORD, _QWORD);
// 14000169A: using guessed type __int64 __fastcall print_spaceship(_QWORD);
// 140001D20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Count Tool ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50

struct node {
    char word[MAX_WORD_LENGTH];
    int count;
    struct node *next;
};

void add_word(struct node **head, char *word) {
    if (*head == NULL) {
        *head = malloc(sizeof(struct node));
        strcpy((*head)->word, word);
        (*head)->count = 1;
        (*head)->next = NULL;
        return;
    }

    struct node *prev_node = NULL;
    struct node *curr_node = *head;

    while (curr_node != NULL) {
        if (strcmp(curr_node->word, word) == 0) {
            curr_node->count += 1;
            return;
        }

        prev_node = curr_node;
        curr_node = curr_node->next;
    }

    prev_node->next = malloc(sizeof(struct node));
    strcpy(prev_node->next->word, word);
    prev_node->next->count = 1;
    prev_node->next->next = NULL;
}

void print_word_counts(struct node *head) {
    struct node *curr_node = head;
    while (curr_node != NULL) {
        printf("%s: %d\n", curr_node->word, curr_node->count);
        curr_node = curr_node->next;
    }
}

int main(int argc, char **argv) {
    FILE *fp;
    char filename[MAX_WORD_LENGTH];
    char word[MAX_WORD_LENGTH];
    struct node *word_counts = NULL;

    if (argc < 2) {
        printf("Usage: %s filename\n", argv[0]);
        exit(1);
    }

    strcpy(filename, argv[1]);

    fp = fopen(filename, "r");
    if (fp == NULL) {
        printf("Error opening file: %s\n", filename);
        exit(1);
    }

    while (fscanf(fp, "%s", word) != EOF) {
        char *p = word;
        while (*p != '\0') {
            *p = tolower(*p);
            p++;
        }
        add_word(&word_counts, word);
    }

    fclose(fp);

    print_word_counts(word_counts);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_word(_QWORD, _QWORD); // weak
__int64 __fastcall print_word_counts(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strcpy(char *Destination, const char *Source);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *tolower)(int C);


//----- (0000000140001735) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-98h] BYREF
  char v5[64]; // [rsp+30h] [rbp-90h] BYREF
  char Destination[64]; // [rsp+70h] [rbp-50h] BYREF
  FILE *Stream; // [rsp+B0h] [rbp-10h]
  char *i; // [rsp+B8h] [rbp-8h]

  _main(argc, argv, envp);
  v4 = 0i64;
  if ( argc <= 1 )
  {
    printf("Usage: %s filename\n", *argv);
    exit(1);
  }
  strcpy(Destination, argv[1]);
  Stream = fopen(Destination, "r");
  if ( !Stream )
  {
    printf("Error opening file: %s\n", Destination);
    exit(1);
  }
  while ( fscanf(Stream, "%s", v5) != -1 )
  {
    for ( i = v5; *i; ++i )
      *i = tolower(*i);
    add_word(&v4, v5);
  }
  fclose(Stream);
  print_word_counts(v4);
  return 0;
}
// 1400015D4: using guessed type __int64 __fastcall add_word(_QWORD, _QWORD);
// 1400016E4: using guessed type __int64 __fastcall print_word_counts(_QWORD);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Weather simulation ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL)); // seed the random generator with current time
    int temperature = (rand() % 40) - 20; // random temperature ranging from -20 to 20
    int humidity = rand() % 101; // random humidity percentage ranging from 0 to 100
    int wind_speed = rand() % 101; // random wind speed in km/h ranging from 0 to 100
    int precipitation_chance = rand() % 101; // random chance of precipitation ranging from 0 to 100
    char* precipitation_type = NULL; // initialize precipitation type to be empty
    if (precipitation_chance > 70) { // if chance of precipitation is greater than 70
        int precipitation_type_num = rand() % 3; // random number from 0 to 2
        switch (precipitation_type_num) {
            case 0:
                precipitation_type = "rain"; // set precipitation type to rain
                break;
            case 1:
                precipitation_type = "snow"; // set precipitation type to snow
                break;
            case 2:
                precipitation_type = "hail"; // set precipitation type to hail
                break;
        }
    }
    printf("Temperature: %d°C\n", temperature);
    printf("Humidity: %d%%\n", humidity);
    printf("Wind Speed: %d km/h\n", wind_speed);
    if (precipitation_type != NULL) { // if there is precipitation
        printf("Chance of %s: %d%%\n", precipitation_type, precipitation_chance);
    } else {
        printf("Chance of precipitation: %d%%\n", precipitation_chance);
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-1Ch]
  int v6; // [rsp+28h] [rbp-18h]
  unsigned int v7; // [rsp+2Ch] [rbp-14h]
  unsigned int v8; // [rsp+30h] [rbp-10h]
  unsigned int v9; // [rsp+34h] [rbp-Ch]
  const char *v10; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v9 = rand() % 40 - 20;
  v8 = rand() % 101;
  v7 = rand() % 101;
  v6 = rand() % 101;
  v10 = 0i64;
  if ( v6 > 70 )
  {
    v5 = rand() % 3;
    if ( v5 == 2 )
    {
      v10 = "hail";
    }
    else if ( v5 <= 2 )
    {
      if ( v5 )
      {
        if ( v5 == 1 )
          v10 = "snow";
      }
      else
      {
        v10 = "rain";
      }
    }
  }
  printf("Temperature: %d°C\n", v9);
  printf("Humidity: %d%%\n", v8);
  printf("Wind Speed: %d km/h\n", v7);
  if ( v10 )
    printf("Chance of %s: %d%%\n", v10, (unsigned int)v6);
  else
    printf("Chance of precipitation: %d%%\n", (unsigned int)v6);
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_INPUT_SIZE 100
#define MAX_GATES 10

typedef struct Gate {
    char type[4];
    int input1;
    int input2;
    int output;
} Gate;

int main() {
    char input[MAX_INPUT_SIZE];
    Gate circuit[MAX_GATES];
    int gateCount = 0;
    int outputValue;

    printf("Welcome to the Classical Circuit Simulator!\n");
    printf("Please enter your circuit one gate at a time.\n");
    printf("When you are finished, type 'done'.\n");

    while(1) {
        fgets(input, MAX_INPUT_SIZE, stdin);
        if(strncmp(input, "done", 4) == 0) {
            break;
        }
        char *token = strtok(input, " ");
        Gate gate;
        if(strcmp(token, "NOT") == 0) {
            strcpy(gate.type, "NOT");
            gate.input1 = atoi(strtok(NULL, " "));
            gate.output = atoi(strtok(NULL, " "));
        } else if(strcmp(token, "AND") == 0) {
            strcpy(gate.type, "AND");
            gate.input1 = atoi(strtok(NULL, " "));
            gate.input2 = atoi(strtok(NULL, " "));
            gate.output = atoi(strtok(NULL, " "));
        } else if(strcmp(token, "OR") == 0) {
            strcpy(gate.type, "OR");
            gate.input1 = atoi(strtok(NULL, " "));
            gate.input2 = atoi(strtok(NULL, " "));
            gate.output = atoi(strtok(NULL, " "));
        } else {
            printf("Invalid gate type: %s\n", token);
            continue;
        }
        circuit[gateCount++] = gate;
    }

    int input1, input2;
    printf("Please enter the input values (0 or 1) for the circuit.\n");
    printf("Input 1: ");
    scanf("%d", &input1);
    printf("Input 2: ");
    scanf("%d", &input2);

    for(int i = 0; i < gateCount; i++) {
        Gate gate = circuit[i];
        if(strcmp(gate.type, "NOT") == 0) {
            int inputValue = (gate.input1 == 1) ? input1 : !input1;
            outputValue = !inputValue;
        } else if(strcmp(gate.type, "AND") == 0) {
            int inputValue1 = (gate.input1 == 1) ? input1 : !input1;
            int inputValue2 = (gate.input2 == 1) ? input2 : !input2;
            outputValue = inputValue1 && inputValue2;
        } else if(strcmp(gate.type, "OR") == 0) {
            int inputValue1 = (gate.input1 == 1) ? input1 : !input1;
            int inputValue2 = (gate.input2 == 1) ? input2 : !input2;
            outputValue = inputValue1 || inputValue2;
        }
        if(i == gateCount - 1) {
            printf("Output: %d", outputValue);
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl atoi(const char *String);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char *v4; // rax
  char *v5; // rax
  char *v6; // rax
  char *v7; // rax
  char *v8; // rax
  char *v9; // rax
  char *v10; // rax
  char *v11; // rax
  int v12; // eax
  _QWORD *v13; // rcx
  __int64 v14; // rdx
  _QWORD *v15; // rax
  __int64 v16; // rdx
  int v17; // eax
  int v18; // eax
  int v19; // eax
  BOOL v20; // eax
  int v21; // eax
  int v22; // eax
  BOOL v23; // eax
  char v25[8]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v26; // [rsp+28h] [rbp-58h]
  __int64 v27; // [rsp+30h] [rbp-50h] BYREF
  __int64 v28; // [rsp+38h] [rbp-48h]
  int v29; // [rsp+48h] [rbp-38h] BYREF
  int v30[13]; // [rsp+4Ch] [rbp-34h] BYREF
  _BYTE v31[112]; // [rsp+80h] [rbp+0h] BYREF
  char Buffer[100]; // [rsp+F0h] [rbp+70h] BYREF
  int v33; // [rsp+154h] [rbp+D4h]
  int v34; // [rsp+158h] [rbp+D8h]
  int v35; // [rsp+15Ch] [rbp+DCh]
  int v36; // [rsp+160h] [rbp+E0h]
  int v37; // [rsp+164h] [rbp+E4h]
  char *Str1; // [rsp+168h] [rbp+E8h]
  int i; // [rsp+174h] [rbp+F4h]
  BOOL v40; // [rsp+178h] [rbp+F8h]
  int v41; // [rsp+17Ch] [rbp+FCh]

  _main(argc, argv, envp);
  v41 = 0;
  printf("Welcome to the Classical Circuit Simulator!\n");
  printf("Please enter your circuit one gate at a time.\n");
  printf("When you are finished, type 'done'.\n");
  while ( 1 )
  {
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 100, v3);
    if ( !strncmp(Buffer, "done", 4ui64) )
      break;
    Str1 = strtok(Buffer, " ");
    if ( !strcmp(Str1, "NOT") )
    {
      LODWORD(v27) = 5525326;
      v4 = strtok(0i64, " ");
      HIDWORD(v27) = atoi(v4);
      v5 = strtok(0i64, " ");
      HIDWORD(v28) = atoi(v5);
      goto LABEL_11;
    }
    if ( !strcmp(Str1, "AND") )
    {
      LODWORD(v27) = 4476481;
      v6 = strtok(0i64, " ");
      HIDWORD(v27) = atoi(v6);
      v7 = strtok(0i64, " ");
      LODWORD(v28) = atoi(v7);
      v8 = strtok(0i64, " ");
      HIDWORD(v28) = atoi(v8);
      goto LABEL_11;
    }
    if ( !strcmp(Str1, "OR") )
    {
      strcpy((char *)&v27, "OR");
      v9 = strtok(0i64, " ");
      HIDWORD(v27) = atoi(v9);
      v10 = strtok(0i64, " ");
      LODWORD(v28) = atoi(v10);
      v11 = strtok(0i64, " ");
      HIDWORD(v28) = atoi(v11);
LABEL_11:
      v12 = v41++;
      v13 = &v31[16 * v12 - 48];
      v14 = v28;
      *v13 = v27;
      v13[1] = v14;
    }
    else
    {
      printf("Invalid gate type: %s\n", Str1);
    }
  }
  printf("Please enter the input values (0 or 1) for the circuit.\n");
  printf("Input 1: ");
  scanf("%d", v30);
  printf("Input 2: ");
  scanf("%d", &v29);
  for ( i = 0; i < v41; ++i )
  {
    v15 = &v31[16 * i - 48];
    v16 = v15[1];
    *(_QWORD *)v25 = *v15;
    v26 = v16;
    if ( !strcmp(v25, "NOT") )
    {
      if ( *(_DWORD *)&v25[4] == 1 )
        v17 = v30[0];
      else
        v17 = v30[0] == 0;
      v33 = v17;
      v40 = v17 == 0;
    }
    else if ( !strcmp(v25, "AND") )
    {
      if ( *(_DWORD *)&v25[4] == 1 )
        v18 = v30[0];
      else
        v18 = v30[0] == 0;
      v35 = v18;
      if ( (_DWORD)v26 == 1 )
        v19 = v29;
      else
        v19 = v29 == 0;
      v34 = v19;
      v20 = v35 && v34;
      v40 = v20;
    }
    else if ( !strcmp(v25, "OR") )
    {
      if ( *(_DWORD *)&v25[4] == 1 )
        v21 = v30[0];
      else
        v21 = v30[0] == 0;
      v37 = v21;
      if ( (_DWORD)v26 == 1 )
        v22 = v29;
      else
        v22 = v29 == 0;
      v36 = v22;
      v23 = v37 || v36;
      v40 = v23;
    }
    if ( i == v41 - 1 )
      printf("Output: %d", v40);
  }
  return 0;
}
// 140001B20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type int var_134[13];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Graph representation ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 100

typedef struct {
    int vertices[MAX_VERTICES];
    int adj_matrix[MAX_VERTICES][MAX_VERTICES];
    int num_vertices;
} Graph;

void add_vertex(Graph *g, int v) {
    if (g->num_vertices < MAX_VERTICES) {
        g->vertices[g->num_vertices++] = v;
    } else {
        printf("Graph is full\n");
    }
}

void add_edge(Graph *g, int v1, int v2, int weight) {
    int i, j;
    if (v1 >= g->num_vertices || v2 >= g->num_vertices) {
        printf("Invalid vertex\n");
        return;
    }
    g->adj_matrix[v1][v2] = weight;
    g->adj_matrix[v2][v1] = weight;
}

void display(Graph *g) {
    int i, j;
    for (i = 0; i < g->num_vertices; i++) {
        printf("%d: ", g->vertices[i]);
        for (j = 0; j < g->num_vertices; j++) {
            printf("%d ", g->adj_matrix[i][j]);
        }
        printf("\n");
    }
}

int main() {
    Graph g;
    g.num_vertices = 0;

    add_vertex(&g, 0);
    add_vertex(&g, 1);
    add_vertex(&g, 2);
    add_vertex(&g, 3);

    add_edge(&g, 0, 1, 1);
    add_edge(&g, 0, 2, 0);
    add_edge(&g, 1, 2, 1);
    add_edge(&g, 2, 3, 1);

    display(&g);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall add_vertex(_QWORD, _QWORD); // weak
__int64 __fastcall add_edge(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall display(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001766) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[40400]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+9DF0h] [rbp+9D70h]

  _main(argc, argv, envp);
  v5 = 0;
  add_vertex(v4, 0i64);
  add_vertex(v4, 1i64);
  add_vertex(v4, 2i64);
  add_vertex(v4, 3i64);
  add_edge(v4, 0i64, 1i64, 1i64);
  add_edge(v4, 0i64, 2i64, 0i64);
  add_edge(v4, 1i64, 2i64, 1i64);
  add_edge(v4, 2i64, 3i64, 1i64);
  display(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall add_vertex(_QWORD, _QWORD);
// 1400015EA: using guessed type __int64 __fastcall add_edge(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400016A2: using guessed type __int64 __fastcall display(_QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Spam Detection System ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_MESSAGES 100

void processMessage(char* message);

int spam_message_count = 0;
char* spam_messages[MAX_MESSAGES];

int main() {
    char message[256];

    printf("Enter a message: ");
    fgets(message, 256, stdin);

    // Process the message
    processMessage(message);

    // Check if the message is spam
    if (spam_message_count > 0) {
        printf("\n\nWARNING: This message is likely spam!\n");
        printf("Possible spam messages:\n");
        for (int i = 0; i < spam_message_count; i++) {
            printf("- %s\n", spam_messages[i]);
        }
    } else {
        printf("\n\nThis message is not spam.\n");
    }

    return 0;
}

// Processes a message to determine if it is spam
void processMessage(char* message) {
    char delimiters[] = " \n\t.,?!-";
    char* word = strtok(message, delimiters);

    while (word != NULL && spam_message_count < MAX_MESSAGES) {
        // Check if the word is in the list of spam words
        if (strstr(word, "viagra") || strstr(word, "cialis") || strstr(word, "bonus")) {
            spam_messages[spam_message_count] = word;
            spam_message_count++;
        }

        // Get the next word in the message
        word = strtok(NULL, delimiters);
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall processMessage(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

int spam_message_count; // weak
_UNKNOWN spam_messages; // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[268]; // [rsp+20h] [rbp-60h] BYREF
  int i; // [rsp+12Ch] [rbp+ACh]

  _main(argc, argv, envp);
  printf("Enter a message: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 256, v3);
  processMessage(Buffer);
  if ( spam_message_count <= 0 )
  {
    printf("\n\nThis message is not spam.\n");
  }
  else
  {
    printf("\n\nWARNING: This message is likely spam!\n");
    printf("Possible spam messages:\n");
    for ( i = 0; i < spam_message_count; ++i )
      printf("- %s\n", *((const char **)&spam_messages + i));
  }
  return 0;
}
// 14000167B: using guessed type __int64 __fastcall processMessage(_QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type int spam_message_count;

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Personal Finance Planner ; Style: creative
#include <stdio.h>
#include <stdlib.h>

int main() {
  // Declare input variables
  float salary, expenses, savings_goal;

  // Get input from user
  printf("Enter your monthly salary: ");
  scanf("%f", &salary);
  printf("Enter your monthly expenses: ");
  scanf("%f", &expenses);
  printf("Enter your savings goal: ");
  scanf("%f", &savings_goal);

  // Calculate monthly savings
  float monthly_savings = salary - expenses;

  // Calculate time to reach saving goal
  float time_to_goal = savings_goal / monthly_savings;

  // Print results
  printf("\nMonthly Savings: $%.2f\n", monthly_savings);
  printf("Time to reach savings goal: %.2f months\n", time_to_goal);

  // Check if savings goal is achievable within 5 years
  if (time_to_goal > 60) {
    printf("You may need to adjust your expenses or savings goal to reach your target within 5 years.\n");
  } else {
    printf("You are on track to reach your savings goal within 5 years!\n");
  }

  // Exit program
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+2Ch] [rbp-14h] BYREF
  float v5; // [rsp+30h] [rbp-10h] BYREF
  float v6; // [rsp+34h] [rbp-Ch] BYREF
  float v7; // [rsp+38h] [rbp-8h]
  float v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter your monthly salary: ");
  scanf("%f", &v6);
  printf("Enter your monthly expenses: ");
  scanf("%f", &v5);
  printf("Enter your savings goal: ");
  scanf("%f", &v4);
  v8 = v6 - v5;
  v7 = v4 / (float)(v6 - v5);
  printf("\nMonthly Savings: $%.2f\n", (float)(v6 - v5));
  printf("Time to reach savings goal: %.2f months\n", v7);
  if ( v7 <= 60.0 )
    printf("You are on track to reach your savings goal within 5 years!\n");
  else
    printf("You may need to adjust your expenses or savings goal to reach your target within 5 years.\n");
  return 0;
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to generate random number between min and max
int getRandomNumber(int min, int max) {
    return (rand() % (max - min + 1)) + min;
}

int main() {
    srand(time(NULL)); // Seed for generating random values
    int no_of_lanes, no_of_cars, simulation_time, i, j, total_cars_passed;

    printf("Enter the number of lanes: ");
    scanf("%d", &no_of_lanes);

    printf("Enter the number of cars in each lane: ");
    scanf("%d", &no_of_cars);

    int car_positions[no_of_lanes][no_of_cars+1]; // +1 for car waiting at traffic light
    int speeds[no_of_lanes][no_of_cars];

    // Initializing the car positions and speeds randomly
    for (i = 0; i < no_of_lanes; i++) {
        for (j = 0; j < no_of_cars; j++) {
            car_positions[i][j] = getRandomNumber(10, 1000);
            speeds[i][j] = getRandomNumber(10, 80);
        }
        car_positions[i][j] = 0; // Waiting at traffic light
    }

    printf("Enter the simulation time: ");
    scanf("%d", &simulation_time);

    // Simulation loop
    for (i = 0; i < simulation_time; i++) {

        // Traffic light timings (randomly generated between 2 and 5 seconds)
        int green_light_duration = getRandomNumber(2, 5);
        int red_light_duration = getRandomNumber(2, 5);

        // Car movement during green light
        for (int lane = 0; lane < no_of_lanes; lane++) {
            for (int car = 0; car < no_of_cars; car++) {
                if (car_positions[lane][car] < 500) {
                    car_positions[lane][car] += speeds[lane][car];
                }
                else {
                    // Car has passed the traffic light and is removed from the lane
                    car_positions[lane][car] = -1;
                }
            }
        }

        // Cars waiting at traffic light
        for (int lane = 0; lane < no_of_lanes; lane++) {
            if (car_positions[lane][no_of_cars] > 0) {
                car_positions[lane][no_of_cars] -= 1;
            }
            else if (car_positions[lane][no_of_cars] == 0) {
                car_positions[lane][no_of_cars] = -1; // Car has passed the traffic light
            }
        }

        // Counting number of cars that have passed the traffic light
        total_cars_passed = 0;
        for (int lane = 0; lane < no_of_lanes; lane++) {
            for (int car = 0; car < no_of_cars+1; car++) {
                if (car_positions[lane][car] == -1) {
                    total_cars_passed++;
                }
            }
        }

        // Printing the current state of the simulation
        printf("\nSimulation time: %d seconds\n", i);
        printf("Green light duration: %d seconds\n", green_light_duration);
        printf("Red light duration: %d seconds\n", red_light_duration);
        printf("Total cars passed: %d\n", total_cars_passed);
        printf("Current positions:\n");
        for (int lane = 0; lane < no_of_lanes; lane++) {
            printf("Lane %d: ", lane+1);
            for (int car = 0; car < no_of_cars+1; car++) {
                printf("%d ", car_positions[lane][car]);
            }
            printf("\n");
        }

        // Sleep for red light duration
        sleep(red_light_duration);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall getRandomNumber(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (000000014000162B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned __int64 v4; // rdi
  void *v5; // rsp
  unsigned __int64 v6; // rbx
  void *v7; // rsp
  __int64 v9; // [rsp+0h] [rbp-80h] BYREF
  char v10; // [rsp+20h] [rbp-60h] BYREF
  __int64 *v11; // [rsp+28h] [rbp-58h]
  __int64 v12; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  __int64 v14; // [rsp+40h] [rbp-40h]
  __int64 v15; // [rsp+48h] [rbp-38h]
  __int64 v16; // [rsp+50h] [rbp-30h]
  __int64 v17; // [rsp+58h] [rbp-28h]
  __int64 v18; // [rsp+60h] [rbp-20h]
  __int64 v19; // [rsp+68h] [rbp-18h]
  __int64 v20; // [rsp+70h] [rbp-10h]
  __int64 v21; // [rsp+78h] [rbp-8h]
  __int64 v22; // [rsp+80h] [rbp+0h]
  __int64 v23; // [rsp+88h] [rbp+8h]
  __int64 v24; // [rsp+90h] [rbp+10h]
  __int64 v25; // [rsp+98h] [rbp+18h]
  int v26; // [rsp+A4h] [rbp+24h] BYREF
  int v27; // [rsp+A8h] [rbp+28h] BYREF
  int v28; // [rsp+ACh] [rbp+2Ch] BYREF
  unsigned int v29; // [rsp+B0h] [rbp+30h]
  unsigned int RandomNumber; // [rsp+B4h] [rbp+34h]
  char *v31; // [rsp+B8h] [rbp+38h]
  __int64 v32; // [rsp+C0h] [rbp+40h]
  __int64 v33; // [rsp+C8h] [rbp+48h]
  char *v34; // [rsp+D0h] [rbp+50h]
  __int64 v35; // [rsp+D8h] [rbp+58h]
  __int64 v36; // [rsp+E0h] [rbp+60h]
  int mm; // [rsp+E8h] [rbp+68h]
  int kk; // [rsp+ECh] [rbp+6Ch]
  int jj; // [rsp+F0h] [rbp+70h]
  int ii; // [rsp+F4h] [rbp+74h]
  int n; // [rsp+F8h] [rbp+78h]
  int m; // [rsp+FCh] [rbp+7Ch]
  int k; // [rsp+100h] [rbp+80h]
  unsigned int v44; // [rsp+104h] [rbp+84h]
  int j; // [rsp+108h] [rbp+88h]
  int i; // [rsp+10Ch] [rbp+8Ch]

  _main(argc, argv, envp);
  v11 = &v9;
  v3 = time(0i64);
  srand(v3);
  printf("Enter the number of lanes: ");
  scanf("%d", &v28);
  printf("Enter the number of cars in each lane: ");
  scanf("%d", &v27);
  v36 = v27 + 1 - 1i64;
  v14 = v27 + 1;
  v15 = 0i64;
  v4 = 4 * v14;
  v35 = v28 - 1i64;
  v24 = v14;
  v25 = 0i64;
  v5 = alloca(16 * ((unsigned __int64)(4 * v14 * v28 + 15) >> 4));
  v34 = &v10;
  v33 = v27 - 1i64;
  v12 = v27;
  v13 = 0i64;
  v6 = 4i64 * v27;
  v32 = v35;
  v22 = v27;
  v23 = 0i64;
  v20 = v28;
  v21 = 0i64;
  v18 = v27;
  v19 = 0i64;
  v16 = v28;
  v17 = 0i64;
  v7 = alloca(16 * ((unsigned __int64)(4 * v27 * (__int64)v28 + 15) >> 4));
  v31 = &v10;
  for ( i = 0; i < v28; ++i )
  {
    for ( j = 0; j < v27; ++j )
    {
      *(_DWORD *)&v34[4 * j + 4 * (v4 >> 2) * i] = getRandomNumber(10i64, 1000i64);
      *(_DWORD *)&v31[4 * j + 4 * (v6 >> 2) * i] = getRandomNumber(10i64, 80i64);
    }
    *(_DWORD *)&v34[4 * j + 4 * (v4 >> 2) * i] = 0;
  }
  printf("Enter the simulation time: ");
  scanf("%d", &v26);
  for ( i = 0; i < v26; ++i )
  {
    RandomNumber = getRandomNumber(2i64, 5i64);
    v29 = getRandomNumber(2i64, 5i64);
    for ( k = 0; k < v28; ++k )
    {
      for ( m = 0; m < v27; ++m )
      {
        if ( *(int *)&v34[4 * m + 4 * (v4 >> 2) * k] > 499 )
          *(_DWORD *)&v34[4 * m + 4 * (v4 >> 2) * k] = -1;
        else
          *(_DWORD *)&v34[4 * m + 4 * (v4 >> 2) * k] += *(_DWORD *)&v31[4 * m + 4 * (v6 >> 2) * k];
      }
    }
    for ( n = 0; n < v28; ++n )
    {
      if ( *(int *)&v34[4 * v27 + 4 * (v4 >> 2) * n] <= 0 )
      {
        if ( !*(_DWORD *)&v34[4 * v27 + 4 * (v4 >> 2) * n] )
          *(_DWORD *)&v34[4 * v27 + 4 * (v4 >> 2) * n] = -1;
      }
      else
      {
        --*(_DWORD *)&v34[4 * v27 + 4 * (v4 >> 2) * n];
      }
    }
    v44 = 0;
    for ( ii = 0; ii < v28; ++ii )
    {
      for ( jj = 0; jj <= v27; ++jj )
      {
        if ( *(_DWORD *)&v34[4 * jj + 4 * (v4 >> 2) * ii] == -1 )
          ++v44;
      }
    }
    printf("\nSimulation time: %d seconds\n", (unsigned int)i);
    printf("Green light duration: %d seconds\n", RandomNumber);
    printf("Red light duration: %d seconds\n", v29);
    printf("Total cars passed: %d\n", v44);
    printf("Current positions:\n");
    for ( kk = 0; kk < v28; ++kk )
    {
      printf("Lane %d: ", (unsigned int)(kk + 1));
      for ( mm = 0; mm <= v27; ++mm )
        printf("%d ", *(unsigned int *)&v34[4 * mm + 4 * (v4 >> 2) * kk]);
      printf("\n");
    }
    sleep(v29);
  }
  return 0;
}
// 140001601: using guessed type __int64 __fastcall getRandomNumber(_QWORD, _QWORD);
// 140001DE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002E40: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: light-weight
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to generate a random internet speed between 1 and 100 Mbps
int generate_speed() {
    return rand() % 100 + 1;
}

// Function to simulate a speed test
int test_speed() {
    int speed = generate_speed();
    printf("Testing internet speed... \n");
    printf("Download speed: %d Mbps \n", speed);
    printf("Upload speed: %d Mbps \n", speed);
    printf("Latency: %d ms \n", rand() % 50 + 1);
    return speed;
}

// Function to compare two internet speeds and return the higher speed
int compare_speeds(int speed1, int speed2) {
    if (speed1 > speed2) {
        return speed1;
    } else {
        return speed2;
    }
}

int main() {
    srand(time(0)); // Seed the random number generator with current time
    int speed1 = test_speed();
    int speed2 = test_speed();
    int max_speed = compare_speeds(speed1, speed2);
    printf("Your maximum internet speed is: %d Mbps \n", max_speed);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 test_speed(void); // weak
__int64 __fastcall compare_speeds(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001689) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  unsigned int v6; // [rsp+28h] [rbp-8h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v7 = test_speed();
  v6 = test_speed();
  v5 = compare_speeds(v7, v6);
  printf("Your maximum internet speed is: %d Mbps \n", v5);
  return 0;
}
// 1400015E5: using guessed type __int64 test_speed(void);
// 14000166D: using guessed type __int64 __fastcall compare_speeds(_QWORD, _QWORD);
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: energetic
#include <stdio.h>
int main()
{
  int i, j, k;
  printf("\n\n\t  Let's print a colorful C pattern!\n\n");

  for (i = 1; i <= 6; i++)
  {
    for (j = 1; j <= 6; j++)
    {
      k = i + j;
      if (k % 2 == 0)
      {
        printf("  C ");
      }
      else
      {
        printf("  O ");
      }
    }
    printf("\n");
  }
  printf("\n\n\t  Done printing the C pattern!\n\n");
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("\n\n\t  Let's print a colorful C pattern!\n\n");
  for ( i = 1; i <= 6; ++i )
  {
    for ( j = 1; j <= 6; ++j )
    {
      if ( (((_BYTE)i + (_BYTE)j) & 1) != 0 )
        printf("  O ");
      else
        printf("  C ");
    }
    printf("\n");
  }
  printf("\n\n\t  Done printing the C pattern!\n\n");
  return 0;
}
// 1400016F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Product Inventory System ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PRODUCTS 50

typedef struct product {
    int id;
    char name[50];
    float price;
    int quantity;
} Product;

void add_product(Product products[], int *count) {
    Product p;
    printf("\nEnter ID: ");
    scanf("%d", &p.id);
    getchar();
    printf("Enter Name: ");
    fgets(p.name, 50, stdin);
    printf("Enter Price: ");
    scanf("%f", &p.price);
    printf("Enter Quantity: ");
    scanf("%d", &p.quantity);
    products[*count] = p;
    *count += 1;
}

void view_products(Product products[], int count) {
    printf("\n----- Products -----\n");
    printf("| ID | Name                     | Price | Quantity |\n");
    for(int i = 0; i < count; i++) {
        printf("| %-2d | %-23s | %.2f | %-2d |\n", products[i].id, products[i].name, products[i].price, products[i].quantity);
    }
    printf("----------------------\n");
}

int find_product(Product products[], int count, int id) {
    for(int i = 0; i < count; i++) {
        if(products[i].id == id) {
            return i;
        }
    }
    return -1;
}

void update_product(Product products[], int count) {
    int id, index;
    printf("\nEnter ID to update: ");
    scanf("%d", &id);
    getchar();
    index = find_product(products, count, id);
    if(index == -1) {
        printf("Product not found!\n");
        return;
    }
    Product p;
    printf("Enter Name: ");
    fgets(p.name, 50, stdin);
    printf("Enter Price: ");
    scanf("%f", &p.price);
    printf("Enter Quantity: ");
    scanf("%d", &p.quantity);
    products[index] = p;
}

void delete_product(Product products[], int *count) {
    int id, index;
    printf("\nEnter ID to delete: ");
    scanf("%d", &id);
    index = find_product(products, *count, id);
    if(index == -1) {
        printf("Product not found!\n");
        return;
    }
    for(int i = index; i < *count - 1; i++) {
        products[i] = products[i + 1];
    }
    *count -= 1;
}

void print_menu() {
    printf("\n===== Product Inventory System =====\n");
    printf("1. Add Product\n");
    printf("2. View Products\n");
    printf("3. Update Product\n");
    printf("4. Delete Product\n");
    printf("5. Exit\n");
}

int main() {
    int choice, count = 0;
    Product products[MAX_PRODUCTS];
    while(1) {
        print_menu();
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch(choice) {
            case 1: add_product(products, &count);
                    break;
            case 2: view_products(products, count);
                    break;
            case 3: update_product(products, count);
                    break;
            case 4: delete_product(products, &count);
                    break;
            case 5: exit(0);
            default: printf("Invalid Choice!\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_product(_QWORD, _QWORD); // weak
__int64 __fastcall view_products(_QWORD, _QWORD); // weak
__int64 __fastcall update_product(_QWORD, _QWORD); // weak
__int64 __fastcall delete_product(_QWORD, _QWORD); // weak
__int64 print_menu(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001B0A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[3208]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v5; // [rsp+CA8h] [rbp+C28h] BYREF
  int v6; // [rsp+CACh] [rbp+C2Ch] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  while ( 1 )
  {
    print_menu();
    printf("Enter your choice: ");
    scanf("%d", &v6);
    switch ( v6 )
    {
      case 1:
        add_product(v4, &v5);
        break;
      case 2:
        view_products(v4, v5);
        break;
      case 3:
        update_product(v4, v5);
        break;
      case 4:
        delete_product(v4, &v5);
        break;
      case 5:
        exit(0);
      default:
        printf("Invalid Choice!\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 __fastcall add_product(_QWORD, _QWORD);
// 140001715: using guessed type __int64 __fastcall view_products(_QWORD, _QWORD);
// 14000184D: using guessed type __int64 __fastcall update_product(_QWORD, _QWORD);
// 14000199D: using guessed type __int64 __fastcall delete_product(_QWORD, _QWORD);
// 140001AA1: using guessed type __int64 print_menu(void);
// 140001CB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Building a JSON Parser ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define JSON_OBJECT 1
#define JSON_ARRAY 2
#define JSON_STRING 3
#define JSON_NUMBER 4
#define JSON_TRUE 5
#define JSON_FALSE 6
#define JSON_NULL 7

typedef struct json_value_t {
    int type;
    union {
        double number;
        char* string;
        int boolean;
        struct json_value_t* child;
    } data;
    struct json_value_t* next;
} json_value;

json_value* parse_json(char* json_string);
json_value* parse_json_object(char* json_string);
json_value* parse_json_array(char* json_string);
json_value* parse_json_string(char* json_string);
json_value* parse_json_number(char* json_string);
json_value* parse_json_boolean(char* json_string);
json_value* parse_json_null(char* json_string);
char* string_copy(char* s, int n);

json_value* parse_json(char* json_string) {
    json_value* root = NULL;
    int i = 0;

    // TODO: Implement JSON parsing logic here

    return root;
}

json_value* parse_json_object(char* json_string) {
    json_value* object = NULL;
    // TODO: Implement JSON object parsing logic here
    return object;
}

json_value* parse_json_array(char* json_string) {
    json_value* array = NULL;
    // TODO: Implement JSON array parsing logic here
    return array;
}

json_value* parse_json_string(char* json_string) {
    json_value* string = NULL;
    // TODO: Implement JSON string parsing logic here
    return string;
}

json_value* parse_json_number(char* json_string) {
    json_value* number = NULL;
    // TODO: Implement JSON number parsing logic here
    return number;
}

json_value* parse_json_boolean(char* json_string) {
    json_value* boolean = NULL;
    // TODO: Implement JSON boolean parsing logic here
    return boolean;
}

json_value* parse_json_null(char* json_string) {
    json_value* null = NULL;
    // TODO: Implement JSON null parsing logic here
    return null;
}

char* string_copy(char* s, int n) {
    char* copy = malloc(n + 1);
    strncpy(copy, s, n);
    copy[n] = '\0';
    return copy;
}

int main(int argc, char** argv) {
    if (argc != 2) {
        printf("Usage: ./json_parser <json_string>\n");
        return 1;
    }

    char* json_string = argv[1];
    json_value* root = parse_json(json_string);

    // TODO: Use parsed JSON object/array here

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall parse_json(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016C0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  if ( argc == 2 )
  {
    parse_json(argv[1]);
    return 0;
  }
  else
  {
    printf("Usage: ./json_parser <json_string>\n");
    return 1;
  }
}
// 140001591: using guessed type __int64 __fastcall parse_json(_QWORD);
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Periodic Table Quiz ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Defines the element structure
struct Element {
    char name[20];
    char symbol[3];
    int number;
};

// Defines a function to populate the periodic table with elements
void populateTable(struct Element table[118]) {
    // Adds Hydrogen to the table
    struct Element hydrogen = {"Hydrogen", "H", 1};
    table[0] = hydrogen;
    // Adds Helium to the table
    struct Element helium = {"Helium", "He", 2};
    table[1] = helium;
    // Continues adding elements to the table
    // ...
}

// Defines a function to shuffle the elements in the periodic table
void shuffleTable(struct Element table[118]) {
    srand((unsigned int)time(NULL));
    for (int i = 117; i >= 0; i--) {
        int j = rand() % (i + 1);
        struct Element temp = table[i];
        table[i] = table[j];
        table[j] = temp;
    }
}

int main() {
    struct Element periodicTable[118];
    // Populates the periodic table with elements
    populateTable(periodicTable);
    // Shuffles the periodic table
    shuffleTable(periodicTable);
    // Prints the shuffled periodic table in a quiz format
    int correctAnswers = 0;
    int totalQuestions = 0;
    for (int i = 0; i < 118; i++) {
        struct Element element = periodicTable[i];
        char answer[20];
        printf("What is the symbol for %s? ", element.name);
        scanf("%s", answer);
        if (strcmp(answer, element.symbol) == 0) {
            printf("Correct!\n\n");
            correctAnswers++;
        } else {
            printf("Incorrect! The symbol for %s is %s.\n\n", element.name, element.symbol);
        }
        totalQuestions++;
    }
    // Prints the quiz results
    printf("Your score: %d/%d\n", correctAnswers, totalQuestions);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall populateTable(_QWORD); // weak
__int64 __fastcall shuffleTable(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (00000001400017DE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v3; // rax
  __int64 v4; // rbx
  char Str1[32]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v7[2]; // [rsp+40h] [rbp-40h] BYREF
  __int64 v8; // [rsp+50h] [rbp-30h] BYREF
  int v9; // [rsp+58h] [rbp-28h]
  char v10[32]; // [rsp+60h] [rbp-20h] BYREF
  __int64 v11; // [rsp+80h] [rbp+0h] BYREF
  int i; // [rsp+D54h] [rbp+CD4h]
  unsigned int v13; // [rsp+D58h] [rbp+CD8h]
  unsigned int v14; // [rsp+D5Ch] [rbp+CDCh]

  _main(argc, argv, envp);
  populateTable(v10);
  shuffleTable(v10);
  v14 = 0;
  v13 = 0;
  for ( i = 0; i <= 117; ++i )
  {
    v3 = (char *)&v11 + 28 * i - 32;
    v4 = *((_QWORD *)v3 + 1);
    v7[0] = *(_QWORD *)v3;
    v7[1] = v4;
    v8 = *((_QWORD *)v3 + 2);
    v9 = *((_DWORD *)v3 + 6);
    printf("What is the symbol for %s? ", (const char *)v7);
    scanf("%s", Str1);
    if ( !strcmp(Str1, (const char *)&v8 + 4) )
    {
      printf("Correct!\n\n");
      ++v14;
    }
    else
    {
      printf("Incorrect! The symbol for %s is %s.\n\n", (const char *)v7, (const char *)&v8 + 4);
    }
    ++v13;
  }
  printf("Your score: %d/%d\n", v14, v13);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall populateTable(_QWORD);
// 1400016BC: using guessed type __int64 __fastcall shuffleTable(_QWORD);
// 1400019F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Metadata Extractor ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char* artist;
    char* album;
    int year;
    char* genre;
} Metadata;

int main() {
    Metadata song1, song2;
    song1.artist = "The Beatles";
    song1.album = "Sgt. Pepper's Lonely Hearts Club Band";
    song1.year = 1967;
    song1.genre = "Rock";
    
    song2.artist = "Michael Jackson";
    song2.album = "Thriller";
    song2.year = 1982;
    song2.genre = "Pop";
    
    printf("Song 1 Details:\n");
    printf("Artist: %s\nAlbum: %s\nYear: %d\nGenre: %s\n\n", song1.artist, song1.album, song1.year, song1.genre);
    
    printf("Song 2 Details:\n");
    printf("Artist: %s\nAlbum: %s\nYear: %d\nGenre: %s\n\n", song2.artist, song2.album, song2.year, song2.genre);
    
    // Let's extract some metadata from a file
    FILE* fp;
    char* filename = "example_file.mp3";
    fp = fopen(filename, "r");
    if (fp == NULL) {
        printf("Error opening file!");
        return 1;
    }
    
    // We will assume that the metadata is in the first 128 bytes of the file
    char buffer[128];
    fread(buffer, sizeof(char), 128, fp);
    
    // The first 3 bytes of the buffer contain the ID3 metadata
    char id3[4], title[31], track[4], artist[31], genre[31], year[4], album[31];
    strncpy(id3, buffer, 3);
    id3[3] = '\0';
    
    if (strcmp(id3, "ID3") != 0) {
        printf("Error - Invalid ID3 tag found!\n");
        return 1;
    }
    
    // Track name
    strncpy(title, buffer+3, 30);
    title[30] = '\0';
    
    // Artist name
    strncpy(artist, buffer+33, 30);
    artist[30] = '\0';
    
    // Album name
    strncpy(album, buffer+63, 30);
    album[30] = '\0';
    
    // Year
    strncpy(year, buffer+93, 4);
    year[4] = '\0';
    
    // Track number
    strncpy(track, buffer+97, 1);
    track[1] = '\0';
    
    // Genre
    strncpy(genre, buffer+127, 1);
    genre[1] = '\0';
    
    fclose(fp);
    
    printf("Metadata Extracted:\n");
    printf("Title: %s\nArtist: %s\nAlbum: %s\nYear: %s\nTrack: %s\nGenre: %s\n\n", title, artist, album, year, track, genre);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[44]; // [rsp+40h] [rbp-40h] BYREF
  char v5[4]; // [rsp+6Ch] [rbp-14h] BYREF
  char v6[32]; // [rsp+70h] [rbp-10h] BYREF
  char v7[44]; // [rsp+90h] [rbp+10h] BYREF
  char v8[4]; // [rsp+BCh] [rbp+3Ch] BYREF
  char v9[44]; // [rsp+C0h] [rbp+40h] BYREF
  char Destination[4]; // [rsp+ECh] [rbp+6Ch] BYREF
  char Buffer[3]; // [rsp+F0h] [rbp+70h] BYREF
  char v12[30]; // [rsp+F3h] [rbp+73h] BYREF
  char v13[30]; // [rsp+111h] [rbp+91h] BYREF
  char v14[30]; // [rsp+12Fh] [rbp+AFh] BYREF
  char v15[4]; // [rsp+14Dh] [rbp+CDh] BYREF
  char v16[30]; // [rsp+151h] [rbp+D1h] BYREF
  char v17; // [rsp+16Fh] [rbp+EFh] BYREF
  const char *v18; // [rsp+170h] [rbp+F0h]
  const char *v19; // [rsp+178h] [rbp+F8h]
  int v20; // [rsp+180h] [rbp+100h]
  const char *v21; // [rsp+188h] [rbp+108h]
  const char *v22; // [rsp+190h] [rbp+110h]
  const char *v23; // [rsp+198h] [rbp+118h]
  int v24; // [rsp+1A0h] [rbp+120h]
  const char *v25; // [rsp+1A8h] [rbp+128h]
  FILE *Stream; // [rsp+1B0h] [rbp+130h]
  char *FileName; // [rsp+1B8h] [rbp+138h]

  _main(argc, argv, envp);
  v22 = "The Beatles";
  v23 = "Sgt. Pepper's Lonely Hearts Club Band";
  v24 = 1967;
  v25 = "Rock";
  v18 = "Michael Jackson";
  v19 = "Thriller";
  v20 = 1982;
  v21 = "Pop";
  printf("Song 1 Details:\n");
  printf(
    "Artist: %s\nAlbum: %s\nYear: %d\nGenre: %s\n\n",
    "The Beatles",
    "Sgt. Pepper's Lonely Hearts Club Band",
    1967i64,
    "Rock");
  printf("Song 2 Details:\n");
  printf("Artist: %s\nAlbum: %s\nYear: %d\nGenre: %s\n\n", "Michael Jackson", "Thriller", 1982i64, "Pop");
  FileName = "example_file.mp3";
  Stream = fopen("example_file.mp3", "r");
  if ( Stream )
  {
    fread(Buffer, 1ui64, 0x80ui64, Stream);
    strncpy(Destination, Buffer, 3ui64);
    Destination[3] = 0;
    if ( !strcmp(Destination, "ID3") )
    {
      strncpy(v9, v12, 0x1Eui64);
      v9[30] = 0;
      strncpy(v7, v13, 0x1Eui64);
      v7[30] = 0;
      strncpy(v4, v14, 0x1Eui64);
      v4[30] = 0;
      strncpy(v5, v15, 4ui64);
      v6[0] = 0;
      strncpy(v8, v16, 1ui64);
      v8[1] = 0;
      strncpy(v6, &v17, 1ui64);
      v6[1] = 0;
      fclose(Stream);
      printf("Metadata Extracted:\n");
      printf("Title: %s\nArtist: %s\nAlbum: %s\nYear: %s\nTrack: %s\nGenre: %s\n\n", v9, v7, v4, v5, v8, v6);
      return 0;
    }
    else
    {
      printf("Error - Invalid ID3 tag found!\n");
      return 1;
    }
  }
  else
  {
    printf("Error opening file!");
    return 1;
  }
}
// 140001930: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char anonymous_0[30];
// 140001591: using guessed type char anonymous_1[30];
// 140001591: using guessed type char anonymous_2[30];
// 140001591: using guessed type char anonymous_3[4];
// 140001591: using guessed type char anonymous_4[30];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Binary Converter ; Style: romantic
#include <stdio.h>

// Function to convert decimal to binary
void decimalToBinary(int num) {
    int binaryNum[32];
    int i = 0;
    while (num > 0) {
        binaryNum[i] = num % 2;
        num = num / 2;
        i++;
    }
    for (int j = i - 1; j >= 0; j--)
        printf("%d", binaryNum[j]);
}

// Function to convert binary to decimal
int binaryToDecimal(long long num) {
    int decimalNum = 0, base = 1, rem;
    while (num > 0) {
        rem = num % 10;
        num = num / 10;
        decimalNum = decimalNum + rem * base;
        base = base * 2;
    }
    return decimalNum;
}

int main() {
    int decimalNum;
    long long binaryNum;

    printf("Enter decimal number: ");
    scanf("%d", &decimalNum);

    printf("Binary equivalent: ");
    decimalToBinary(decimalNum);

    printf("\n\nEnter binary number: ");
    scanf("%lld", &binaryNum);

    printf("Decimal equivalent: %d", binaryToDecimal(binaryNum));

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall decimalToBinary(_QWORD); // weak
__int64 __fastcall binaryToDecimal(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000170B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter decimal number: ");
  scanf("%d", &v6);
  printf("Binary equivalent: ");
  decimalToBinary(v6);
  printf("\n\nEnter binary number: ");
  scanf("%lld", &v5);
  v3 = binaryToDecimal(v5);
  printf("Decimal equivalent: %d", v3);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall decimalToBinary(_QWORD);
// 14000166B: using guessed type __int64 __fastcall binaryToDecimal(_QWORD);
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000170B: using guessed type __int64 var_10;

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Chess AI ; Style: puzzling
#include<stdio.h>
#include<stdlib.h>

#define KING_WEIGHT 200 // The weightage of a king
#define QUEEN_WEIGHT 9 // The weightage of a queen
#define KNIGHT_WEIGHT 3 // The weightage of a knight
#define BISHOP_WEIGHT 3 // The weightage of a bishop
#define ROOK_WEIGHT 5 // The weightage of a rook
#define PAWN_WEIGHT 1 // The weightage of a pawn

/** Structure to hold a chess piece*/
struct piece {
    char color;
    char type;
    int x;
    int y;
};

/** Function to print the chess board */
void printBoard(char board[][8]) {
    printf("\n  a b c d e f g h\n");
    for(int i=0; i<8; i++) {
      printf("%d ", i+1);
      for(int j=0; j<8; j++) {
          printf("%c ", board[i][j]);
      }
      printf("%d\n", i+1);
    }
    printf("  a b c d e f g h\n\n");
}

/** Function to get the value of a chess piece */
int getValue(char type) {
    if(type == 'K') {
        return KING_WEIGHT;
    } else if(type == 'Q') {
        return QUEEN_WEIGHT;
    } else if(type == 'N') {
        return KNIGHT_WEIGHT;
    } else if(type == 'B') {
        return BISHOP_WEIGHT;
    } else if(type == 'R') {
        return ROOK_WEIGHT;
    } else {
        return PAWN_WEIGHT;
    }
}

/** Function to check if a move is valid */
int isValidMove(char board[][8], struct piece p, int newX, int newY) {
    if(newX < 0 || newX > 7 || newY < 0 || newY > 7) {
        return 0;
    }
    if(p.x == newX && p.y == newY) {
        return 0;
    }
    if(board[newX][newY] != ' ') {
        if(board[newX][newY] == 'K' && p.type != 'P') {
            return 0;
        } else if(board[newX][newY] == p.type && p.type != 'P') {
            return 0;
        } else if(board[newX][newY] != p.type && p.type == 'P') {
            return 0;
        }
    }
    if(p.type == 'K') {
        if(abs(p.x - newX) > 1 || abs(p.y - newY) > 1) {
            return 0;
        }
    } else if(p.type == 'Q') {
        if(p.x != newX && p.y != newY && abs(p.x - newX) != abs(p.y - newY)) {
            return 0;
        }
        int dx = p.x < newX ? 1 : (p.x > newX ? -1 : 0);
        int dy = p.y < newY ? 1 : (p.y > newY ? -1 : 0);
        for(int i=p.x+dx,j=p.y+dy;i!=newX || j!=newY;i+=dx,j+=dy) {
            if(board[i][j] != ' ' && (i != p.x || j != p.y)) {
                return 0;
            }
        }
    } else if(p.type == 'N') {
        if(abs(p.x - newX) == 2 && abs(p.y - newY) == 1) {
            return 1;
        } else if(abs(p.x - newX) == 1 && abs(p.y - newY) == 2) {
            return 1;
        } else {
            return 0;
        }
    } else if(p.type == 'B') {
        if(abs(p.x - newX) != abs(p.y - newY)) {
            return 0;
        }
        int dx = p.x < newX ? 1 : -1;
        int dy = p.y < newY ? 1 : -1;
        for(int i=p.x+dx,j=p.y+dy;i!=newX+dx;i+=dx,j+=dy) {
            if(board[i][j] != ' ' && (i != p.x || j != p.y)) {
                return 0;
            }
        }
    } else if(p.type == 'R') {
        if(p.x != newX && p.y != newY) {
            return 0;
        }
        int dx = p.x == newX ? 0 : (p.x < newX ? 1 : -1);
        int dy = p.y == newY ? 0 : (p.y < newY ? 1 : -1);
        for(int i=p.x+dx,j=p.y+dy;i!=newX+dx || j!=newY+dy;i+=dx,j+=dy) {
            if(board[i][j] != ' ' && (i != p.x || j != p.y)) {
                return 0;
            }
        }
    } else if(p.type == 'P') {
        if(p.color == 'W') {
            if(newY == p.y && newX == p.x-1 && board[newX][newY] == ' ') {
                return 1;
            } else if(newY == p.y+1 && newX == p.x-1 && board[newX][newY] != ' ') {
                return 1;
            } else if(newY == p.y-1 && newX == p.x-1 && board[newX][newY] != ' ') {
                return 1;
            } else if(newY == p.y && newX == p.x-2 && p.x == 6 && board[newX][newY] == ' ' && board[p.x-1][newY] == ' ') {
                return 1;
            } else {
                return 0;
            }
        } else {
            if(newY == p.y && newX == p.x+1 && board[newX][newY] == ' ') {
                return 1;
            } else if(newY == p.y-1 && newX == p.x+1 && board[newX][newY] != ' ') {
                return 1;
            } else if(newY == p.y+1 && newX == p.x+1 && board[newX][newY] != ' ') {
                return 1;
            } else if(newY == p.y && newX == p.x+2 && p.x == 1 && board[newX][newY] == ' ' && board[p.x+1][newY] == ' ') {
                return 1;
            } else {
                return 0;
            }
        }
    }
    return 1;
}

/** Function to get the best move for the AI player */
void getBestMove(char board[][8], char color) {
    struct piece pieces[16];
    int pieceCount = 0;
    for(int i=0; i<8; i++) {
        for(int j=0; j<8; j++) {
            if(board[i][j] != ' ' && (color == 'B' ? board[i][j] >= 'a' : board[i][j] <= 'Z')) {
                struct piece p = {
                    .color = board[i][j] >= 'a' ? 'B' : 'W',
                    .type = board[i][j] >= 'a' ? board[i][j] - 32 : board[i][j],
                    .x = i,
                    .y = j
                };
                pieces[pieceCount] = p;
                pieceCount++;
            }
        }
    }
    int bestMoveValue = -1;
    int bestMoveIndex = -1;
    for(int i=0; i<pieceCount; i++) {
        struct piece p = pieces[i];
        for(int a=0; a<8; a++) {
            for(int b=0; b<8; b++) {
                if(isValidMove(board, p, a, b)) {
                    int value = getValue(p.type);
                    if(board[a][b] != ' ') {
                        value += getValue(board[a][b]);
                    }
                    if(value > bestMoveValue) {
                        bestMoveValue = value;
                        bestMoveIndex = i;
                    }
                }
            }
        }
    }
    struct piece p = pieces[bestMoveIndex];
    int newX, newY;
    int bestMoveValueForPiece = -1;
    for(int a=0; a<8; a++) {
        for(int b=0; b<8; b++) {
            if(isValidMove(board, p, a, b)) {
                int value = getValue(p.type);
                if(board[a][b] != ' ') {
                    value += getValue(board[a][b]);
                }
                if(value > bestMoveValueForPiece) {
                    bestMoveValueForPiece = value;
                    newX = a;
                    newY = b;
                }
            }
        }
    }
    printf("\nAI Player moves from %c%d to %c%d\n", p.y+'a', p.x+1, newY+'a', newX+1);
    board[newX][newY] = board[p.x][p.y];
    board[p.x][p.y] = ' ';
}

/** The main function */
int main() {
    char board[8][8] = {
        {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'},
        {'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'},
        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
        {'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'},
        {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'}
    };
    int gameOver = 0;
    char turn = 'W';
    while(!gameOver) {
        system("clear");
        printf("Chess Game\n");
        printBoard(board);
        if(turn == 'W') {
            printf("White Player's turn\n");
            char start[3], end[3];
            printf("Enter starting position (ex: e2) : ");
            scanf("%s", start);
            printf("Enter ending position (ex: e4) : ");
            scanf("%s", end);
            struct piece p = {
                .color = 'W',
                .type = toupper(board[start[1]-'0'-1][start[0]-'a']),
                .x = start[1]-'0'-1,
                .y = start[0]-'a'
            };
            if(isValidMove(board, p, end[1]-'0'-1, end[0]-'a')) {
                board[end[1]-'0'-1][end[0]-'a'] = board[p.x][p.y];
                board[p.x][p.y] = ' ';
                turn = 'B';
            } else {
                printf("Invalid move.\n");
                getchar();
            }
        } else {
            printf("AI Player's turn\n");
            getBestMove(board, 'B');
            turn = 'W';
            getchar();
        }
        /* Implement game over logic */
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall printBoard(_QWORD); // weak
__int64 __fastcall isValidMove(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD); // weak
__int64 __fastcall getBestMove(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl toupper(int C);
// int __cdecl system(const char *Command);
// int __cdecl getchar();


//----- (0000000140002395) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-80h] BYREF
  int v5; // [rsp+28h] [rbp-78h]
  __int64 v6; // [rsp+3Ch] [rbp-64h]
  int v7; // [rsp+44h] [rbp-5Ch]
  char v8; // [rsp+4Ah] [rbp-56h] BYREF
  char v9; // [rsp+4Bh] [rbp-55h]
  char v10; // [rsp+4Dh] [rbp-53h] BYREF
  char v11; // [rsp+4Eh] [rbp-52h]
  __int64 v12[9]; // [rsp+50h] [rbp-50h] BYREF
  int v13; // [rsp+98h] [rbp-8h]
  char v14; // [rsp+9Fh] [rbp-1h]
  __int64 savedregs; // [rsp+A0h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v12, "rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR", 64);
  v13 = 0;
  v14 = 87;
  while ( !v13 )
  {
    system("clear");
    printf("Chess Game\n");
    printBoard(v12);
    if ( v14 == 87 )
    {
      printf("White Player's turn\n");
      printf("Enter starting position (ex: e2) : ");
      scanf("%s", &v10);
      printf("Enter ending position (ex: e4) : ");
      scanf("%s", &v8);
      LOBYTE(v6) = 87;
      BYTE1(v6) = toupper(*((char *)&savedregs + 8 * v11 + v10 - 569));
      HIDWORD(v6) = v11 - 49;
      v7 = v10 - 97;
      v4 = v6;
      v5 = v7;
      if ( (unsigned int)((__int64 (__fastcall *)(__int64 *, __int64 *, _QWORD, _QWORD))isValidMove)(
                           v12,
                           &v4,
                           (unsigned int)(v9 - 49),
                           (unsigned int)(v8 - 97)) )
      {
        *((_BYTE *)&savedregs + 8 * v9 + v8 - 569) = *((_BYTE *)&savedregs + 8 * SHIDWORD(v6) + v7 - 80);
        *((_BYTE *)&savedregs + 8 * SHIDWORD(v6) + v7 - 80) = 32;
        v14 = 66;
      }
      else
      {
        printf("Invalid move.\n");
        getchar();
      }
    }
    else
    {
      printf("AI Player's turn\n");
      getBestMove(v12, 66i64);
      v14 = 87;
      getchar();
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall printBoard(_QWORD);
// 1400016E9: using guessed type __int64 __fastcall isValidMove(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 140001DF4: using guessed type __int64 __fastcall getBestMove(_QWORD, _QWORD);
// 1400026A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Synchronizer ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILE_NAME_LEN 512
#define MAX_FILE_CONTENT_LEN 65535

int synchronize_files(char *filename1, char *filename2);

int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Usage: %s [file1] [file2]\n", argv[0]);
        exit(1);
    }

    char *filename1 = argv[1];
    char *filename2 = argv[2];

    int result = synchronize_files(filename1, filename2);

    if (result == 0) {
        printf("Files synchronized successfully!\n");
    } else if (result == 1) {
        printf("Could not open file '%s'.\n", filename1);
    } else if (result == 2) {
        printf("Could not open file '%s'.\n", filename2);
    } else {
        printf("An error occurred while synchronizing files.\n");
    }

    return 0;
}

int synchronize_files(char *filename1, char *filename2) {
    FILE *file1 = fopen(filename1, "r");
    if (file1 == NULL) {
        return 1;
    }

    FILE *file2 = fopen(filename2, "r");
    if (file2 == NULL) {
        fclose(file1);
        return 2;
    }

    char file1_content[MAX_FILE_CONTENT_LEN];
    char file2_content[MAX_FILE_CONTENT_LEN];

    memset(file1_content, 0, sizeof(file1_content));
    memset(file2_content, 0, sizeof(file2_content));

    size_t file1_len = fread(file1_content, sizeof(char), MAX_FILE_CONTENT_LEN, file1);
    size_t file2_len = fread(file2_content, sizeof(char), MAX_FILE_CONTENT_LEN, file2);

    fclose(file1);
    fclose(file2);

    if (file1_len != file2_len || strcmp(file1_content, file2_content) != 0) {
        FILE *file1 = fopen(filename1, "w");
        if (file1 == NULL) {
            return 1;
        }

        FILE *file2 = fopen(filename2, "w");
        if (file2 == NULL) {
            fclose(file1);
            return 2;
        }

        fwrite(file1_content, sizeof(char), file1_len, file1);
        fwrite(file2_content, sizeof(char), file2_len, file2);

        fclose(file1);
        fclose(file2);

        return 0;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall synchronize_files(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-14h]
  const char *v5; // [rsp+30h] [rbp-10h]
  const char *v6; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc <= 2 )
  {
    printf("Usage: %s [file1] [file2]\n", *argv);
    exit(1);
  }
  v6 = argv[1];
  v5 = argv[2];
  v4 = synchronize_files(v6, v5);
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      printf("Could not open file '%s'.\n", v6);
    }
    else if ( v4 == 2 )
    {
      printf("Could not open file '%s'.\n", v5);
    }
    else
    {
      printf("An error occurred while synchronizing files.\n");
    }
  }
  else
  {
    printf("Files synchronized successfully!\n");
  }
  return 0;
}
// 140001666: using guessed type __int64 __fastcall synchronize_files(_QWORD, _QWORD);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: invasive
#include<stdio.h>
#include<stdlib.h>

int main()
{
    int n, i, j, flag;
    printf("Enter the number of prime numbers to be generated: ");
    scanf("%d", &n);
    int primes[n];
    primes[0] = 2;
    int count = 1;
    i = 3;

    while(count < n)
    {
        flag = 0;

        for(j = 2; j < i; j++)
        {
            if(i % j == 0)
            {
                flag = 1;
                break;
            }
        }

        if(flag == 0)
        {
            primes[count] = i;
            count++;
        }

        i++;
    }

    printf("Prime numbers generated are: ");

    for(i = 0; i < n; i++)
    {
        printf("%d ", primes[i]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  int v5; // [rsp+20h] [rbp-30h] BYREF
  int v6; // [rsp+2Ch] [rbp-24h] BYREF
  int *v7; // [rsp+30h] [rbp-20h]
  __int64 v8; // [rsp+38h] [rbp-18h]
  int v9; // [rsp+40h] [rbp-10h]
  int v10; // [rsp+44h] [rbp-Ch]
  int i; // [rsp+48h] [rbp-8h]
  int j; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of prime numbers to be generated: ");
  scanf("%d", &v6);
  v8 = v6 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(4i64 * v6 + 15) >> 4));
  v7 = &v5;
  v5 = 2;
  v9 = 1;
  j = 3;
  while ( v9 < v6 )
  {
    v10 = 0;
    for ( i = 2; i < j; ++i )
    {
      if ( !(j % i) )
      {
        v10 = 1;
        break;
      }
    }
    if ( !v10 )
      v7[v9++] = j;
    ++j;
  }
  printf("Prime numbers generated are: ");
  for ( j = 0; j < v6; ++j )
    printf("%d ", (unsigned int)v7[j]);
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Encyptor ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILENAME_LENGTH 256
#define MAX_PASSWORD_LENGTH 40
#define MAX_BUFFER_SIZE 1024

void encryptDecryptFile(char* file_path, char* password);
void encryptBuffer(unsigned char* buffer, size_t bufferLength, char* password);
unsigned long getFileSize(FILE* file);

int main() {
    char file_path[MAX_FILENAME_LENGTH];
    char password[MAX_PASSWORD_LENGTH];
    
    printf("Enter file path: ");
    scanf("%s", file_path);

    printf("Enter password: ");
    scanf("%s", password);
    
    encryptDecryptFile(file_path, password);

    printf("File encryption/decryption completed!\n");

    return 0;
}

void encryptDecryptFile(char* file_path, char* password) {
    FILE *fp;
    unsigned char buffer[MAX_BUFFER_SIZE];
    size_t bytesRead;
    unsigned long fileSize;

    fp = fopen(file_path, "rb+");
    if(fp == NULL) {
        printf("Error opening file: %s\n", file_path);
        exit(1);
    }

    fileSize = getFileSize(fp);
    if(fileSize == 0) {
        printf("File is empty\n");
        exit(1);
    }

    bytesRead = fread(buffer, sizeof(buffer[0]), MAX_BUFFER_SIZE, fp);
    while(bytesRead != 0) {
        encryptBuffer(buffer, bytesRead, password);

        fseek(fp, -((long)bytesRead), SEEK_CUR);
        fwrite(buffer, sizeof(buffer[0]), bytesRead, fp);

        fseek(fp, 0, SEEK_CUR);
        bytesRead = fread(buffer, sizeof(buffer[0]), MAX_BUFFER_SIZE, fp);
    }

    fclose(fp);
}

void encryptBuffer(unsigned char* buffer, size_t bufferLength, char* password) {
    size_t passwordLength = strlen(password);
    unsigned char temp;
    
    for(size_t i = 0; i < bufferLength; i++) {
        temp = buffer[i] ^ password[i % passwordLength];
        buffer[i] = temp;
    }
}

unsigned long getFileSize(FILE* file) {
    unsigned long fileSize;
    fseek(file, 0, SEEK_END);
    fileSize = ftell(file);
    fseek(file, 0, SEEK_SET);
    return fileSize;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall encryptDecryptFile(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[48]; // [rsp+20h] [rbp-60h] BYREF
  char v5[256]; // [rsp+50h] [rbp-30h] BYREF

  _main(argc, argv, envp);
  printf("Enter file path: ");
  scanf("%s", v5);
  printf("Enter password: ");
  scanf("%s", v4);
  encryptDecryptFile(v5, v4);
  printf("File encryption/decryption completed!\n");
  return 0;
}
// 14000166E: using guessed type __int64 __fastcall encryptDecryptFile(_QWORD, _QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: creative
#include <stdio.h>

int isPrime(int num);

int main() {
  int n, i, count = 0;
  printf("Enter the number of prime numbers you wish to generate: ");
  scanf("%d", &n);
  printf("\nGenerating the first %d prime numbers:\n", n);
  
  for(i=2; count<n; i++) {
    if(isPrime(i)) {
      printf("%d\n", i);
      count++;
    }
  }
  
  return 0;
}

int isPrime(int num) {
  int i;
  for(i=2; i<=num/2; i++) {
    if(num%i == 0) {
      return 0;
    }
  }
  return 1;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall isPrime(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch] BYREF
  int v5; // [rsp+28h] [rbp-8h]
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5 = 0;
  printf("Enter the number of prime numbers you wish to generate: ");
  scanf("%d", &v4);
  printf("\nGenerating the first %d prime numbers:\n", v4);
  v6 = 2;
  while ( v5 < (int)v4 )
  {
    if ( (unsigned int)isPrime(v6) )
    {
      printf("%d\n", v6);
      ++v5;
    }
    ++v6;
  }
  return 0;
}
// 140001675: using guessed type __int64 __fastcall isPrime(_QWORD);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature Converter ; Style: invasive
#include <stdio.h>
#include <stdlib.h>

float convert_to_fahrenheit(float celsius);
float convert_to_kelvin(float celsius);

int main()
{
    float celsius, fahrenheit, kelvin;
    char choice;

    do
    {
        system("cls");

        printf("    Celsius to Fahrenheit and Kelvin Converter\n\n");
        printf("Enter the temperature in Celsius: ");
        scanf("%f", &celsius);

        fahrenheit = convert_to_fahrenheit(celsius);
        kelvin = convert_to_kelvin(celsius);

        printf("\n%f Celsius = %f Fahrenheit\n", celsius, fahrenheit);
        printf("%f Celsius = %f Kelvin\n\n", celsius, kelvin);

        printf("Do you want to convert another temperature? (Y/N): ");
        scanf(" %c", &choice);

    } while (choice == 'y' || choice == 'Y');

    return 0;
}

float convert_to_fahrenheit(float celsius)
{
    float fahrenheit = ((9 * celsius) / 5) + 32;
    return fahrenheit;
}

float convert_to_kelvin(float celsius)
{
    float kelvin = celsius + 273.15;
    return kelvin;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
double convert_to_fahrenheit(void); // weak
double convert_to_kelvin(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl system(const char *Command);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  char v6; // [rsp+23h] [rbp-Dh] BYREF
  float v7; // [rsp+24h] [rbp-Ch] BYREF
  float v8; // [rsp+28h] [rbp-8h]
  float v9; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  do
  {
    do
    {
      system("cls");
      printf("    Celsius to Fahrenheit and Kelvin Converter\n\n");
      printf("Enter the temperature in Celsius: ");
      scanf("%f", &v7);
      v3 = _mm_cvtsi32_si128(LODWORD(v7));
      *(double *)v3.m128i_i64 = convert_to_fahrenheit();
      v9 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
      v4 = _mm_cvtsi32_si128(LODWORD(v7));
      *(double *)v4.m128i_i64 = convert_to_kelvin();
      v8 = COERCE_FLOAT(_mm_cvtsi128_si32(v4));
      printf("\n%f Celsius = %f Fahrenheit\n", v7, v9);
      printf("%f Celsius = %f Kelvin\n\n", v7, v8);
      printf("Do you want to convert another temperature? (Y/N): ");
      scanf(" %c", &v6);
    }
    while ( v6 == 121 );
  }
  while ( v6 == 89 );
  return 0;
}
// 140001738: using guessed type double convert_to_fahrenheit(void);
// 140001781: using guessed type double convert_to_kelvin(void);
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Antivirus scanner ; Style: Cyberpunk
#include <stdio.h>
#include <string.h>

int main() {
    char fileName[50];
    int fileSize;

    printf("Enter the file name: ");
    scanf("%s", fileName);

    FILE *file = fopen(fileName, "r");

    if (file == NULL) {
        printf("File not found!\n");
        return 0;
    }

    fseek(file, 0L, SEEK_END);
    fileSize = ftell(file);
    fseek(file, 0L, SEEK_SET);

    char fileContent[fileSize];
    fread(fileContent, sizeof(char), fileSize, file);

    int virusDetected = 0;

    char virusStrings[5][20] = {
        "hack",
        "crack",
        "cyber",
        "virus",
        "trojan"
    };

    for (int i = 0; i < 5; i++) {
        if (strstr(fileContent, virusStrings[i]) != NULL) {
            printf("Virus detected: %s\n", virusStrings[i]);
            virusDetected = 1;
        }
    }

    if (virusDetected == 0) {
        printf("No viruses detected.\n");
    }

    fclose(file);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v4; // rsp
  __int64 v5[2]; // [rsp+20h] [rbp-D0h] BYREF
  int v6; // [rsp+30h] [rbp-C0h]
  __int64 v7; // [rsp+34h] [rbp-BCh]
  __int64 v8; // [rsp+3Ch] [rbp-B4h]
  int v9; // [rsp+44h] [rbp-ACh]
  __int64 v10; // [rsp+48h] [rbp-A8h]
  __int64 v11; // [rsp+50h] [rbp-A0h]
  int v12; // [rsp+58h] [rbp-98h]
  __int64 v13; // [rsp+5Ch] [rbp-94h]
  __int64 v14; // [rsp+64h] [rbp-8Ch]
  int v15; // [rsp+6Ch] [rbp-84h]
  __int64 v16; // [rsp+70h] [rbp-80h]
  __int64 v17; // [rsp+78h] [rbp-78h]
  int v18; // [rsp+80h] [rbp-70h]
  char FileName[56]; // [rsp+90h] [rbp-60h] BYREF
  void *Buffer; // [rsp+C8h] [rbp-28h]
  __int64 v21; // [rsp+D0h] [rbp-20h]
  int v22; // [rsp+DCh] [rbp-14h]
  FILE *Stream; // [rsp+E0h] [rbp-10h]
  int i; // [rsp+E8h] [rbp-8h]
  int v25; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the file name: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "r");
  if ( Stream )
  {
    fseek(Stream, 0, 2);
    v22 = ftell(Stream);
    fseek(Stream, 0, 0);
    v21 = v22 - 1i64;
    v4 = alloca(16 * ((unsigned __int64)(v22 + 15i64) >> 4));
    Buffer = v5;
    fread(v5, 1ui64, v22, Stream);
    v25 = 0;
    v5[0] = 1801675112i64;
    v5[1] = 0i64;
    v6 = 0;
    v7 = 0x6B63617263i64;
    v8 = 0i64;
    v9 = 0;
    v10 = 0x7265627963i64;
    v11 = 0i64;
    v12 = 0;
    v13 = 0x7375726976i64;
    v14 = 0i64;
    v15 = 0;
    v16 = 0x6E616A6F7274i64;
    v17 = 0i64;
    v18 = 0;
    for ( i = 0; i <= 4; ++i )
    {
      if ( strstr((const char *)Buffer, (const char *)v5 + 20 * i) )
      {
        printf("Virus detected: %s\n", (const char *)v5 + 20 * i);
        v25 = 1;
      }
    }
    if ( !v25 )
      printf("No viruses detected.\n");
    fclose(Stream);
    return 0;
  }
  else
  {
    printf("File not found!\n");
    return 0;
  }
}
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Email Client ; Style: invasive
#include<stdio.h>

int main() {
   char to[50], from[50], message[500], subject[100];
   printf("Enter recipient's email address : ");
   scanf("%s", to);
   printf("\nEnter sender's email address : ");
   scanf("%s", from);
   printf("\nEnter the subject of the email : ");
   scanf("%s", subject);
   printf("\nEnter the message you want to send : ");
   scanf("%s", message);
   printf("\nSending email to %s from %s\n\n", to, from);
   printf("Subject: %s\n\n", subject);
   printf("Message:\n%s\n", message);
   printf("\nEmail sent successfully!");
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[112]; // [rsp+20h] [rbp-60h] BYREF
  char v5[512]; // [rsp+90h] [rbp+10h] BYREF
  char v6[64]; // [rsp+290h] [rbp+210h] BYREF
  char v7[64]; // [rsp+2D0h] [rbp+250h] BYREF

  _main(argc, argv, envp);
  printf("Enter recipient's email address : ");
  scanf("%s", v7);
  printf("\nEnter sender's email address : ");
  scanf("%s", v6);
  printf("\nEnter the subject of the email : ");
  scanf("%s", v4);
  printf("\nEnter the message you want to send : ");
  scanf("%s", v5);
  printf("\nSending email to %s from %s\n\n", v7, v6);
  printf("Subject: %s\n\n", v4);
  printf("Message:\n%s\n", v5);
  printf("\nEmail sent successfully!");
  return 0;
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password management ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXLENGTH 20
#define MAXUSERNAME 20
#define MAXPASSWORD 50

typedef struct Node {
    char username[MAXUSERNAME];
    char password[MAXPASSWORD];
    struct Node* next;
} Node;

Node* head = NULL;

void printMenu() {
    printf("Password Management System\n");
    printf("--------------------------\n");
    printf("1. Add a new password \n");
    printf("2. Search for a password \n");
    printf("3. Update a password \n");
    printf("4. Delete a password \n");
    printf("5. Display all passwords \n");
    printf("6. Exit \n");
    printf("--------------------------\n");
}

Node* createNode(char* username, char* password) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    strcpy(newNode->username, username);
    strcpy(newNode->password, password);
    newNode->next = NULL;
    return newNode;
}

void addPassword() {
    char username[MAXUSERNAME];
    char password[MAXPASSWORD];
    printf("Enter username: ");
    scanf("%s", username);
    printf("Enter password: ");
    scanf("%s", password);
    Node* newNode = createNode(username, password);

    if (head == NULL) {
        head = newNode;
    } else {
        Node* current = head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = newNode;
    }

    printf("Password added successfully!\n");
}

void searchPassword() {
    char username[MAXUSERNAME];
    printf("Enter username: ");
    scanf("%s", username);
    Node* current = head;
    while (current != NULL) {
        if (strcmp(current->username, username) == 0) {
            printf("Password found: %s\n", current->password);
            return;
        }
        current = current->next;
    }

    printf("Password not found for this username.\n");
}

void updatePassword() {
    char username[MAXUSERNAME];
    char password[MAXPASSWORD];
    printf("Enter username: ");
    scanf("%s", username);
    Node* current = head;
    while (current != NULL) {
        if (strcmp(current->username, username) == 0) {
            printf("Enter new password: ");
            scanf("%s", password);
            strcpy(current->password, password);
            printf("Password updated successfully!\n");
            return;
        }
        current = current->next;
    }

    printf("Password not found for this username.\n");
}

void deletePassword() {
    char username[MAXUSERNAME];
    printf("Enter username: ");
    scanf("%s", username);
    if (head == NULL) {
        printf("No passwords found.\n");
        return;
    }
    if (strcmp(head->username, username) == 0) {
        Node* temp = head;
        head = head->next;
        free(temp);
        printf("Password deleted successfully!\n");
        return;
    }
    Node* prev = head;
    Node* current = head->next;
    while (current != NULL) {
        if (strcmp(current->username, username) == 0) {
            prev->next = current->next;
            free(current);
            printf("Password deleted successfully!\n");
            return;
        }
        prev = current;
        current = current->next;
    }

    printf("Password not found for this username.\n");
}

void displayPasswords() {
    if (head == NULL) {
        printf("No passwords found.\n");
        return;
    }
    Node* current = head;
    while (current != NULL) {
        printf("Username: %s, Password: %s\n", current->username, current->password);
        current = current->next;
    }
}

int main() {
    int option;
    while (1) {
        printMenu();
        printf("Enter an option: ");
        scanf("%d", &option);
        switch (option) {
            case 1:
                addPassword();
                break;
            case 2:
                searchPassword();
                break;
            case 3:
                updatePassword();
                break;
            case 4:
                deletePassword();
                break;
            case 5:
                displayPasswords();
                break;
            case 6:
                printf("Exiting program. Goodbye!\n");
                return 0;
            default:
                printf("Invalid option. Please try again.\n");
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 printMenu(void); // weak
__int64 addPassword(void); // weak
__int64 searchPassword(void); // weak
__int64 updatePassword(void); // weak
__int64 deletePassword(void); // weak
__int64 displayPasswords(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A8F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    printMenu();
    printf("Enter an option: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        addPassword();
        break;
      case 2:
        searchPassword();
        break;
      case 3:
        updatePassword();
        break;
      case 4:
        deletePassword();
        break;
      case 5:
        displayPasswords();
        break;
      case 6:
        printf("Exiting program. Goodbye!\n");
        return 0;
      default:
        printf("Invalid option. Please try again.\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 printMenu(void);
// 1400016D0: using guessed type __int64 addPassword(void);
// 14000179D: using guessed type __int64 searchPassword(void);
// 140001830: using guessed type __int64 updatePassword(void);
// 1400018F1: using guessed type __int64 deletePassword(void);
// 140001A23: using guessed type __int64 displayPasswords(void);
// 140001C00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Network Topology Mapper ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUF_SIZE 4096

// Structure for storing the network topology map
typedef struct node {
    char* name;
    char* ip;
    struct node* next;
} Node;

// Parses the nmap output file and creates a network topology map
Node* parse_nmap_output(const char* filename) {
    FILE* file = fopen(filename, "r");
    char buf[BUF_SIZE];
    Node* head = NULL;
    Node* curr = NULL;

    while (fgets(buf, sizeof(buf), file) != NULL) {
        // Ignore comments and lines that don't contain IP addresses
        if (buf[0] == '#') {
            continue;
        }
        char* ip_start = strstr(buf, "Nmap scan report for ");
        if (ip_start == NULL) {
            continue;
        }
        ip_start += strlen("Nmap scan report for ");
        char* ip_end = strstr(ip_start, "\n");
        *ip_end = '\0';
        char* name_start = strstr(buf, "(");
        if (name_start == NULL) {
            continue;
        }
        name_start += strlen("(");
        char* name_end = strstr(name_start, ")");
        *name_end = '\0';
        // Create a new node and add it to the linked list
        Node* node = (Node*) malloc(sizeof(Node));
        node->name = strdup(name_start);
        node->ip = strdup(ip_start);
        node->next = NULL;
        if (head == NULL) {
            head = node;
            curr = node;
        } else {
            curr->next = node;
            curr = node;
        }
    }
    fclose(file);
    return head;
}

// Prints the network topology map to the console
void print_topology_map(Node* head) {
    Node* curr = head;
    while (curr != NULL) {
        printf("%s (%s)\n", curr->name, curr->ip);
        curr = curr->next;
    }
}

int main(int argc, char** argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <nmap_output_file>\n", argv[0]);
        return 1;
    }
    Node* head = parse_nmap_output(argv[1]);
    print_topology_map(head);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
__int64 __fastcall parse_nmap_output(_QWORD); // weak
__int64 __fastcall print_topology_map(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001819) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rbx
  FILE *v4; // rax
  __int64 v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc > 1 )
  {
    v6 = parse_nmap_output(argv[1]);
    print_topology_map(v6);
    return 0;
  }
  else
  {
    v3 = *argv;
    v4 = __acrt_iob_func(2u);
    fprintf_0(v4, "Usage: %s <nmap_output_file>\n", v3);
    return 1;
  }
}
// 1400015D4: using guessed type __int64 __fastcall parse_nmap_output(_QWORD);
// 1400017C4: using guessed type __int64 __fastcall print_topology_map(_QWORD);
// 140001950: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Count Tool ; Style: secure
#include <stdio.h>
#include <string.h>

#define MAX_WORDS 10000
#define MAX_WORD_LENGTH 20

struct Word {
    char str[MAX_WORD_LENGTH];
    int count;
};

int main() {
    struct Word words[MAX_WORDS];
    char input[256];
    int i, j, count = 0;

    printf("Enter a string: ");
    fgets(input, 256, stdin);

    // Replace newline character with null terminator
    input[strcspn(input, "\n")] = '\0';

    // Tokenize input
    char *token = strtok(input, " ");

    // Count words
    while (token != NULL) {
        for (i = 0; i < count; i++) {
            if (strcmp(words[i].str, token) == 0) {
                words[i].count++;
                break;
            }
        }
        if (i == count) {
            strncpy(words[count].str, token, MAX_WORD_LENGTH);
            words[count++].count = 1;
        }
        token = strtok(NULL, " ");
    }

    // Print results
    printf("Word count: %d\n", count);
    printf("Word frequency:\n");
    for (i = 0; i < count; i++) {
        printf("%s: %d\n", words[i].str, words[i].count);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v4; // eax
  char Buffer[96]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v7[30020]; // [rsp+80h] [rbp+0h] BYREF
  char *Str2; // [rsp+3AAA0h] [rbp+3AA20h]
  int v9; // [rsp+3AAA8h] [rbp+3AA28h]
  int i; // [rsp+3AAACh] [rbp+3AA2Ch]

  _main(argc, argv, envp);
  v9 = 0;
  printf("Enter a string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 256, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  for ( Str2 = strtok(Buffer, " "); Str2; Str2 = strtok(0i64, " ") )
  {
    for ( i = 0; i < v9; ++i )
    {
      if ( !strcmp((const char *)&v7[3 * i + 20], Str2) )
      {
        ++HIDWORD(v7[3 * i + 22]);
        break;
      }
    }
    if ( i == v9 )
    {
      strncpy((char *)&v7[3 * v9 + 20], Str2, 0x14ui64);
      v4 = v9++;
      HIDWORD(v7[3 * v4 + 22]) = 1;
    }
  }
  printf("Word count: %d\n", (unsigned int)v9);
  printf("Word frequency:\n");
  for ( i = 0; i < v9; ++i )
    printf("%s: %d\n", (const char *)&v7[3 * i + 20], HIDWORD(v7[3 * i + 22]));
  return 0;
}
// 1400018E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[96];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Subnet Calculator ; Style: excited
#include<stdio.h>

int main() {
    printf("Welcome to the C Subnet Calculator!\n");
    printf("Enter the IP address and the subnet mask to calculate the network address, broadcast address and number of hosts.\n");
    printf("IP address format: A.B.C.D (each between 0 and 255)\n");
    printf("Subnet mask format: A.B.C.D (each between 0 and 255)\n\n");

    // Declare variables
    int ip[4], mask[4];
    int network[4], broadcast[4];
    int num_hosts, num_bits;

    // Collect user input
    printf("Enter the IP address: ");
    scanf("%d.%d.%d.%d", &ip[0], &ip[1], &ip[2], &ip[3]);
    printf("Enter the subnet mask: ");
    scanf("%d.%d.%d.%d", &mask[0], &mask[1], &mask[2], &mask[3]);

    // Verify input
    for (int i = 0; i < 4; i++) {
        if (ip[i] < 0 || ip[i] > 255 || mask[i] < 0 || mask[i] > 255) {
            printf("Invalid input. Please enter values between 0 and 255.\n");
            return 0;
        }
    }

    // Calculate network and broadcast addresses
    for (int i = 0; i < 4; i++) {
        network[i] = ip[i] & mask[i];
        broadcast[i] = ip[i] | ~mask[i];
    }

    // Determine number of host bits
    num_bits = 0;
    for (int i = 0; i < 4; i++) {
        int quotient = mask[i], rem = 0;
        while (quotient) {
            rem += quotient & 1;
            quotient >>= 1;
        }
        num_bits += rem;
    }

    // Calculate number of hosts
    num_hosts = (1 << (32 - num_bits)) - 2;
    
    // Output results
    printf("\nNetwork address: %d.%d.%d.%d\n", network[0], network[1], network[2], network[3]);
    printf("Broadcast address: %d.%d.%d.%d\n", broadcast[0], broadcast[1], broadcast[2], broadcast[3]);
    printf("Number of host bits: %d\n", num_bits);
    printf("Number of hosts: %d\n\n", num_hosts);

    printf("Wow! That was fantastic! The C Subnet Calculator is now ready for use.\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-70h]
  __int64 v5; // [rsp+20h] [rbp-70h]
  int v6[4]; // [rsp+30h] [rbp-60h]
  int v7[4]; // [rsp+40h] [rbp-50h]
  int v8; // [rsp+50h] [rbp-40h] BYREF
  char v9; // [rsp+54h] [rbp-3Ch] BYREF
  char v10; // [rsp+58h] [rbp-38h] BYREF
  char v11; // [rsp+5Ch] [rbp-34h] BYREF
  int v12; // [rsp+60h] [rbp-30h] BYREF
  char v13; // [rsp+64h] [rbp-2Ch] BYREF
  char v14; // [rsp+68h] [rbp-28h] BYREF
  char v15; // [rsp+6Ch] [rbp-24h] BYREF
  unsigned int v16; // [rsp+74h] [rbp-1Ch]
  int v17; // [rsp+78h] [rbp-18h]
  int v18; // [rsp+7Ch] [rbp-14h]
  int k; // [rsp+80h] [rbp-10h]
  int j; // [rsp+84h] [rbp-Ch]
  int i; // [rsp+88h] [rbp-8h]
  unsigned int v22; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the C Subnet Calculator!\n");
  printf(
    "Enter the IP address and the subnet mask to calculate the network address, broadcast address and number of hosts.\n");
  printf("IP address format: A.B.C.D (each between 0 and 255)\n");
  printf("Subnet mask format: A.B.C.D (each between 0 and 255)\n\n");
  printf("Enter the IP address: ");
  scanf("%d.%d.%d.%d", &v12, &v13, &v14, &v15);
  printf("Enter the subnet mask: ");
  scanf("%d.%d.%d.%d", &v8, &v9, &v10, &v11);
  for ( i = 0; i <= 3; ++i )
  {
    if ( (unsigned int)*(&v12 + i) > 0xFF || (unsigned int)*(&v8 + i) >= 0x100 )
    {
      printf("Invalid input. Please enter values between 0 and 255.\n");
      return 0;
    }
  }
  for ( j = 0; j <= 3; ++j )
  {
    v7[j] = *(&v8 + j) & *(&v12 + j);
    v6[j] = ~*(&v8 + j) | *(&v12 + j);
  }
  v22 = 0;
  for ( k = 0; k <= 3; ++k )
  {
    v18 = *(&v8 + k);
    v17 = 0;
    while ( v18 )
    {
      v17 += v18 & 1;
      v18 >>= 1;
    }
    v22 += v17;
  }
  v16 = (1 << (32 - v22)) - 2;
  LODWORD(v4) = v7[3];
  printf("\nNetwork address: %d.%d.%d.%d\n", (unsigned int)v7[0], (unsigned int)v7[1], (unsigned int)v7[2], v4);
  LODWORD(v5) = v6[3];
  printf("Broadcast address: %d.%d.%d.%d\n", (unsigned int)v6[0], (unsigned int)v6[1], (unsigned int)v6[2], v5);
  printf("Number of host bits: %d\n", v22);
  printf("Number of hosts: %d\n\n", v16);
  printf("Wow! That was fantastic! The C Subnet Calculator is now ready for use.\n");
  return 0;
}
// 1400017F6: variable 'v4' is possibly undefined
// 14000181E: variable 'v5' is possibly undefined
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password management ; Style: innovative
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<ctype.h>
#include<time.h>

void generatePassword(char *password, int length) {
    // Generating random password
    char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#$&*@";
    int i;
    int charsetLen = strlen(charset);
    srand(time(NULL)); // Seed for random number generator

    for(i=0; i<length; i++) {
        int randomIndex = rand()%charsetLen; // Generating random index within the length of charset
        password[i] = charset[randomIndex]; // Getting character from the charset using random index
    }

    password[length] = '\0'; // Adding null terminator at end of password
}

int main() {
    char masterPassword[20], newPassword[20], confirmNewPassword[20], savedPassword[20];
    FILE *fp;

    printf("Welcome to the Password Management System\n");
    printf("Please enter your Master Password: ");
    scanf("%s", masterPassword);

    // Open file containing saved password
    fp = fopen("saved_password.txt", "r");

    if(fp == NULL) {
        printf("No saved password found. Creating a new password now.\n");
        printf("Please choose a new password (8-20 characters long, containing uppercase/lowercase letters, numbers and symbols): ");
        scanf("%s", newPassword);

        // Checking password length
        if(strlen(newPassword) < 8 || strlen(newPassword) > 20) {
            printf("Password should be 8-20 characters long. Please try again.\n");
            exit(0);
        }

        // Checking password contains atleast one uppercase, one lowercase, one number and one symbol
        int i, hasUpper=0, hasLower=0, hasNumber=0, hasSymbol=0;
        for(i=0; i<strlen(newPassword); i++) {
            char c = newPassword[i];
            if(isupper(c)) hasUpper=1;
            if(islower(c)) hasLower=1;
            if(isdigit(c)) hasNumber=1;
            if(!isalnum(c)) hasSymbol=1;
        }
        if(!hasUpper || !hasLower || !hasNumber || !hasSymbol) {
            printf("Password should contain atleast one uppercase, one lowercase, one number and one symbol. Please try again.\n");
            exit(0);
        }

        // Confirming new password
        printf("Please confirm your new password: ");
        scanf("%s", confirmNewPassword);

        if(strcmp(newPassword, confirmNewPassword) != 0) {
            printf("New passwords do not match. Try again.\n");
            exit(0);
        }

        // Generating random password for saved password
        char savedPassword[11];
        generatePassword(savedPassword, 10);

        // Saving new password in file
        fp = fopen("saved_password.txt", "w");
        fprintf(fp, "%s\n%s", newPassword, savedPassword);
        fclose(fp);

        printf("New password created successfully.\n");
    }
    else {
        fscanf(fp, "%s %s", savedPassword, masterPassword);

        // Checking if entered password matches saved password
        if(strcmp(masterPassword, savedPassword) != 0) {
            printf("Incorrect password. You do not have permission to access this system.\n");
            exit(0);
        }

        printf("Access granted.\n");

        // Enable user to change saved password
        char newSavedPassword[20];
        printf("Would you like to change your saved password? (Y/N) ");
        getchar(); // To clear input buffer
        char option = getchar();

        if(option == 'Y' || option == 'y') {
            printf("Please enter a new saved password: ");
            scanf("%s", newSavedPassword);

            printf("Please enter your current (master) password to confirm: ");
            scanf("%s", masterPassword);

            if(strcmp(masterPassword, savedPassword) != 0) {
                printf("Incorrect password. Please try again later.\n");
                exit(0);
            }

            fp = fopen("saved_password.txt", "w");
            fprintf(fp, "%s\n%s", newSavedPassword, newSavedPassword);
            fclose(fp);

            printf("Saved password changed successfully.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fscanf(FILE *const Stream, const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generatePassword(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// int __cdecl getchar();
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isalnum)(int C);
// extern int (__cdecl *islower)(int C);
// extern int (__cdecl *isupper)(int C);


//----- (000000014000177E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[21]; // [rsp+20h] [rbp-C0h] BYREF
  char v5[11]; // [rsp+35h] [rbp-ABh] BYREF
  char v6[32]; // [rsp+40h] [rbp-A0h] BYREF
  char Str2[32]; // [rsp+60h] [rbp-80h] BYREF
  char Str[32]; // [rsp+80h] [rbp-60h] BYREF
  char Str1[30]; // [rsp+A0h] [rbp-40h] BYREF
  char v10; // [rsp+BEh] [rbp-22h]
  char v11; // [rsp+BFh] [rbp-21h]
  FILE *Stream; // [rsp+C0h] [rbp-20h]
  int v13; // [rsp+CCh] [rbp-14h]
  int v14; // [rsp+D0h] [rbp-10h]
  int v15; // [rsp+D4h] [rbp-Ch]
  int v16; // [rsp+D8h] [rbp-8h]
  int i; // [rsp+DCh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Password Management System\n");
  printf("Please enter your Master Password: ");
  scanf("%s", Str1);
  Stream = fopen("saved_password.txt", "r");
  if ( Stream )
  {
    fscanf(Stream, "%s %s", v6, Str1);
    if ( strcmp(Str1, v6) )
    {
      printf("Incorrect password. You do not have permission to access this system.\n");
      exit(0);
    }
    printf("Access granted.\n");
    printf("Would you like to change your saved password? (Y/N) ");
    getchar();
    v11 = getchar();
    if ( v11 == 89 || v11 == 121 )
    {
      printf("Please enter a new saved password: ");
      scanf("%s", v4);
      printf("Please enter your current (master) password to confirm: ");
      scanf("%s", Str1);
      if ( strcmp(Str1, v6) )
      {
        printf("Incorrect password. Please try again later.\n");
        exit(0);
      }
      Stream = fopen("saved_password.txt", "w");
      fprintf_0(Stream, "%s\n%s", v4, v4);
      fclose(Stream);
      printf("Saved password changed successfully.\n");
    }
  }
  else
  {
    printf("No saved password found. Creating a new password now.\n");
    printf(
      "Please choose a new password (8-20 characters long, containing uppercase/lowercase letters, numbers and symbols): ");
    scanf("%s", Str);
    if ( strlen(Str) <= 7 || strlen(Str) > 0x14 )
    {
      printf("Password should be 8-20 characters long. Please try again.\n");
      exit(0);
    }
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v13 = 0;
    for ( i = 0; i < strlen(Str); ++i )
    {
      v10 = Str[i];
      if ( isupper(v10) )
        v16 = 1;
      if ( islower(v10) )
        v15 = 1;
      if ( (unsigned int)(v10 - 48) <= 9 )
        v14 = 1;
      if ( !isalnum(v10) )
        v13 = 1;
    }
    if ( !v16 || !v15 || !v14 || !v13 )
    {
      printf("Password should contain atleast one uppercase, one lowercase, one number and one symbol. Please try again.\n");
      exit(0);
    }
    printf("Please confirm your new password: ");
    scanf("%s", Str2);
    if ( strcmp(Str, Str2) )
    {
      printf("New passwords do not match. Try again.\n");
      exit(0);
    }
    generatePassword(v5, 10i64);
    Stream = fopen("saved_password.txt", "w");
    fprintf_0(Stream, "%s\n%s", Str, v5);
    fclose(Stream);
    printf("New password created successfully.\n");
  }
  return 0;
}
// 140001687: using guessed type __int64 __fastcall generatePassword(_QWORD, _QWORD);
// 140001C40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000177E: using guessed type char Str[32];

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: systematic
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

const int G = 6.67428e-11; // Gravitational constant

struct planet {
    double m; // Mass
    double x; // Position (x, y)
    double y;
    double vx; // Velocity (x, y)
    double vy;
};

int main() {
    // Set up the planets
    struct planet sun = {1.9885e30, 0, 0, 0, 0}; // Sun
    struct planet earth = {5.972e24, 1.496e11, 0, 0, 2.9783e4}; // Earth
    struct planet moon = {7.35e22, 1.496e11 + 3.844e8, 0, 0, 2.9783e4 + 1.022e3}; // Moon

    double t = 0;
    double dt = 3600 * 24; // 1 day in seconds

    // Simulation loop
    while (1) {
        // Calculate distance and force between Earth and Sun
        double dx = earth.x - sun.x;
        double dy = earth.y - sun.y;
        double d = sqrt(dx*dx + dy*dy);
        double F = G * earth.m * sun.m / (d*d);

        // Calculate acceleration and velocity of Earth
        double ax = -F / earth.m * dx / d;
        double ay = -F / earth.m * dy / d;
        earth.vx += ax * dt;
        earth.vy += ay * dt;
        earth.x += earth.vx * dt;
        earth.y += earth.vy * dt;

        // Calculate distance and force between Moon and Earth
        dx = moon.x - earth.x;
        dy = moon.y - earth.y;
        d = sqrt(dx*dx + dy*dy);
        F = G * moon.m * earth.m / (d*d);

        // Calculate acceleration and velocity of Moon
        double axm = -F / moon.m * dx / d;
        double aym = -F / moon.m * dy / d;
        moon.vx += axm * dt;
        moon.vy += aym * dt;
        moon.x += moon.vx * dt;
        moon.y += moon.vy * dt;

        // Print out the positions of the planets
        printf("t = %f, Earth (%f, %f), Moon (%f, %f)\n", t, earth.x, earth.y, moon.x, moon.y);

        t += dt;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+38h] [rbp-48h]
  double v5; // [rsp+40h] [rbp-40h]
  double v6; // [rsp+48h] [rbp-38h]
  double v7; // [rsp+50h] [rbp-30h]
  double v8; // [rsp+68h] [rbp-18h]
  double v9; // [rsp+70h] [rbp-10h]
  double v10; // [rsp+78h] [rbp-8h]
  double v11; // [rsp+80h] [rbp+0h]
  double v12; // [rsp+E8h] [rbp+68h]
  double v13; // [rsp+E8h] [rbp+68h]
  double i; // [rsp+108h] [rbp+88h]

  _main(argc, argv, envp);
  v8 = 1.496e11;
  v9 = 0.0;
  v10 = 0.0;
  v11 = 29783.0;
  v4 = 1.499844e11;
  v5 = 0.0;
  v6 = 0.0;
  v7 = 30805.0;
  for ( i = 0.0; ; i = i + 86400.0 )
  {
    v12 = sqrt((v8 - 0.0) * (v8 - 0.0) + (v9 - 0.0) * (v9 - 0.0));
    v10 = -((double)0 * 5.972e24 * 1.9885e30 / (v12 * v12)) / 5.972e24 * (v8 - 0.0) / v12 * 86400.0 + v10;
    v11 = -((double)0 * 5.972e24 * 1.9885e30 / (v12 * v12)) / 5.972e24 * (v9 - 0.0) / v12 * 86400.0 + v11;
    v8 = v10 * 86400.0 + v8;
    v9 = v11 * 86400.0 + v9;
    v13 = sqrt((v4 - v8) * (v4 - v8) + (v5 - v9) * (v5 - v9));
    v6 = -((double)0 * 7.35e22 * 5.972e24 / (v13 * v13)) / 7.35e22 * (v4 - v8) / v13 * 86400.0 + v6;
    v7 = -((double)0 * 7.35e22 * 5.972e24 / (v13 * v13)) / 7.35e22 * (v5 - v9) / v13 * 86400.0 + v7;
    v4 = v6 * 86400.0 + v4;
    v5 = v7 * 86400.0 + v5;
    printf("t = %f, Earth (%f, %f), Moon (%f, %f)\n", i, v8, v9, v4, v5);
  }
}
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Graph Coloring Problem ; Style: paranoid
#include <stdio.h>
#include <stdbool.h>

#define MAX_VERTICES 20

int graph[MAX_VERTICES][MAX_VERTICES];
int color[MAX_VERTICES];

void colorGraph(int vertex, int numColors);

bool isSafe(int vertex, int c, int numVertices)
{
    for (int i = 0; i < numVertices; i++) {
        if (graph[vertex][i] && color[i] == c)
            return false;
    }
    return true;
}

bool graphColoringUtil(int numVertices, int numColors, int vertex)
{
    if (vertex == numVertices)
        return true;

    for (int c = 1; c <= numColors; c++) {
        if (isSafe(vertex, c, numVertices)) {
            color[vertex] = c;
            if (graphColoringUtil(numVertices, numColors, vertex + 1) == true)
                return true;
            color[vertex] = 0;
        }
    }
    return false;
}

void graphColoring(int numVertices, int numColors)
{
    if (graphColoringUtil(numVertices, numColors, 0) == false) {
        printf("Could not color the graph with %d colors.\n", numColors);
        return;
    }

    for (int i = 0; i < numVertices; i++)
        printf("Vertex %d has color %d.\n", i, color[i]);
}

void initializeGraph(int numVertices)
{
    for (int i = 0; i < numVertices; i++) {
        for (int j = 0; j < numVertices; j++) {
            graph[i][j] = 0;
        }
        color[i] = 0;
    }
}

void addEdge(int u, int v)
{
    graph[u][v] = 1;
    graph[v][u] = 1;
}

int main(void)
{
    int numVertices, numEdges;
    printf("Enter the number of vertices: ");
    scanf("%d", &numVertices);
    printf("Enter the number of edges: ");
    scanf("%d", &numEdges);

    initializeGraph(numVertices);

    int u, v;
    for (int i = 0; i < numEdges; i++) {
        printf("Enter edge %d: ", i + 1);
        scanf("%d %d", &u, &v);
        addEdge(u, v);
    }

    for (int c = 1; c <= numVertices; c++) {
        printf("Trying to color with %d colors...\n", c);
        graphColoring(numVertices, c);
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall graphColoring(_QWORD, _QWORD); // weak
__int64 __fastcall initializeGraph(_QWORD); // weak
__int64 __fastcall addEdge(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000189E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-18h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-14h] BYREF
  int v6; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v7; // [rsp+34h] [rbp-Ch] BYREF
  unsigned int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of vertices: ");
  scanf("%d", &v7);
  printf("Enter the number of edges: ");
  scanf("%d", &v6);
  initializeGraph(v7);
  for ( i = 0; i < v6; ++i )
  {
    printf("Enter edge %d: ", (unsigned int)(i + 1));
    scanf("%d %d", &v5, &v4);
    addEdge(v5, v4);
  }
  for ( j = 1; (int)j <= (int)v7; ++j )
  {
    printf("Trying to color with %d colors...\n", j);
    graphColoring(v7, j);
    printf("\n");
  }
  return 0;
}
// 140001719: using guessed type __int64 __fastcall graphColoring(_QWORD, _QWORD);
// 1400017A0: using guessed type __int64 __fastcall initializeGraph(_QWORD);
// 14000182B: using guessed type __int64 __fastcall addEdge(_QWORD, _QWORD);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int main()
{
    char password[50];
    int lowercase = 0;
    int uppercase = 0;
    int digits = 0;
    int special = 0;
    int length;
    int score = 0;

    printf("Enter password: ");
    scanf("%s", password);

    length = strlen(password);

    if (length < 8){
        printf("Password is too short, must be at least 8 characters.\n");
    }
    else
    {
        for(int i = 0; i < length; i++)
        {
            if(islower(password[i])){
                lowercase = 1;
            }
            else if(isupper(password[i])){
                uppercase = 1;
            }
            else if(isdigit(password[i])){
                digits = 1;
            }
            else if(!isalnum(password[i])){
                special = 1;
            }
        }

        if (lowercase == 0){
            printf("Password must contain at least one lowercase letter.\n");
        }
        else {
            score++;
        }

        if (uppercase == 0){
            printf("Password must contain at least one uppercase letter.\n");
        }
        else {
            score++;
        }

        if (digits == 0){
            printf("Password must contain at least one digit.\n");
        }
        else {
            score++;
        }

        if (special == 0){
            printf("Password must contain at least one special character.\n");
        }
        else {
            score++;
        }

        if(score == 4)
        {
            printf("Password strength: Strong\n");
        }
        else if(score == 3)
        {
            printf("Password strength: Medium\n");
        }
        else if(score == 2)
        {
            printf("Password strength: Weak\n");
        }
        else
        {
            printf("Password does not meet minimum requirements.\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isalnum)(int C);
// extern int (__cdecl *islower)(int C);
// extern int (__cdecl *isupper)(int C);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[52]; // [rsp+20h] [rbp-50h] BYREF
  int v5; // [rsp+54h] [rbp-1Ch]
  int i; // [rsp+58h] [rbp-18h]
  int v7; // [rsp+5Ch] [rbp-14h]
  int v8; // [rsp+60h] [rbp-10h]
  int v9; // [rsp+64h] [rbp-Ch]
  int v10; // [rsp+68h] [rbp-8h]
  int v11; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  printf("Enter password: ");
  scanf("%s", Str);
  v5 = strlen(Str);
  if ( v5 > 7 )
  {
    for ( i = 0; i < v5; ++i )
    {
      if ( islower(Str[i]) )
      {
        v11 = 1;
      }
      else if ( isupper(Str[i]) )
      {
        v10 = 1;
      }
      else if ( (unsigned int)(Str[i] - 48) > 9 )
      {
        if ( !isalnum(Str[i]) )
          v8 = 1;
      }
      else
      {
        v9 = 1;
      }
    }
    if ( v11 )
      ++v7;
    else
      printf("Password must contain at least one lowercase letter.\n");
    if ( v10 )
      ++v7;
    else
      printf("Password must contain at least one uppercase letter.\n");
    if ( v9 )
      ++v7;
    else
      printf("Password must contain at least one digit.\n");
    if ( v8 )
      ++v7;
    else
      printf("Password must contain at least one special character.\n");
    switch ( v7 )
    {
      case 4:
        printf("Password strength: Strong\n");
        break;
      case 3:
        printf("Password strength: Medium\n");
        break;
      case 2:
        printf("Password strength: Weak\n");
        break;
      default:
        printf("Password does not meet minimum requirements.\n");
        break;
    }
  }
  else
  {
    printf("Password is too short, must be at least 8 characters.\n");
  }
  return 0;
}
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[52];

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Compression algorithms ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the maximum size of the input buffer
#define MAX_BUFFER_SIZE 1024

// Define the length of the run-length encoding block
#define RUN_LENGTH_BLOCK_LENGTH 10

// Define the maximum number of characters in the input
#define MAX_INPUT_SIZE 100000

// Define the number of possible characters that can be compressed
#define NUM_CHARS 256

// Define the maximum length of the Huffman code for each character
#define MAX_CODE_LENGTH 50

// Define a structure to hold a single run-length encoding block
typedef struct RunLengthBlock {
    char character;
    int count;
} RunLengthBlock;

// Define a structure to hold a single Huffman code
typedef struct HuffmanCode {
    char character;
    char code[MAX_CODE_LENGTH];
} HuffmanCode;

// Function to generate a run-length encoding of the input string
void generate_run_length_encoding(char *input, RunLengthBlock *output, int *output_length) {
    int input_length = strlen(input);
    int i, j = 0;
    for (i = 0; i < input_length; i++) {
        if (i % RUN_LENGTH_BLOCK_LENGTH == 0) {
            output[j].character = input[i];
            output[j].count = 1;
            j++;
        } else {
            output[j-1].count++;
        }
    }
    *output_length = j;
}

// Function to generate a Huffman code for each character in the input
void generate_huffman_codes(RunLengthBlock *input, int input_length, HuffmanCode *output, int *output_length) {
    // Create a frequency table for each character
    int frequency[NUM_CHARS];
    memset(frequency, 0, NUM_CHARS*sizeof(int));
    int i;
    for (i = 0; i < input_length; i++) {
        frequency[input[i].character]++;
    }

    // Create a Huffman tree based on the frequency table
    int parent[NUM_CHARS];
    memset(parent, -1, NUM_CHARS*sizeof(int));
    int num_nodes = NUM_CHARS;
    while (num_nodes > 1) {
        int min1 = MAX_INPUT_SIZE;
        int min2 = MAX_INPUT_SIZE;
        int min1_index = -1;
        int min2_index = -1;
        for (i = 0; i < NUM_CHARS; i++) {
            if (frequency[i] > 0 && parent[i] == -1) {
                if (frequency[i] < min1) {
                    min2 = min1;
                    min2_index = min1_index;
                    min1 = frequency[i];
                    min1_index = i;
                } else if (frequency[i] < min2) {
                    min2 = frequency[i];
                    min2_index = i;
                }
            }
        }
        parent[min1_index] = num_nodes;
        parent[min2_index] = num_nodes;
        frequency[num_nodes] = frequency[min1_index] + frequency[min2_index];
        num_nodes++;
    }

    // Generate Huffman codes for each character
    char code[MAX_CODE_LENGTH];
    int code_length = 0;
    for (i = 0; i < NUM_CHARS; i++) {
        output[i].character = (char)i;
        if (frequency[i] > 0) {
            int j = i;
            while (parent[j] != -1) {
                if (j == parent[j]) {
                    code[code_length] = '0';
                } else {
                    if (j == parent[parent[j]]) {
                        code[code_length] = '0';
                    } else {
                        code[code_length] = '1';
                    }
                }
                j = parent[j];
                code_length++;
            }
            code_length--;
            int k;
            for (k = 0; k < code_length; k++) {
                output[i].code[k] = code[code_length-k-1];
            }
            output[i].code[k] = '\0';
            code_length = 0;
        }
    }

    *output_length = NUM_CHARS;
}

int main() {
    // Read in the input from a file
    FILE *input_file = fopen("input.txt", "r");
    if (input_file == NULL) {
        printf("Error: could not open input file.\n");
        return 1;
    }
    char input[MAX_INPUT_SIZE];
    int input_length = fread(input, sizeof(char), MAX_INPUT_SIZE, input_file);
    input[input_length] = '\0';
    fclose(input_file);

    // Generate a run-length encoding of the input string
    RunLengthBlock run_length_output[MAX_INPUT_SIZE/RUN_LENGTH_BLOCK_LENGTH];
    int run_length_output_length;
    generate_run_length_encoding(input, run_length_output, &run_length_output_length);

    // Generate a Huffman code for each character in the input
    HuffmanCode huffman_output[NUM_CHARS];
    int huffman_output_length;
    generate_huffman_codes(run_length_output, run_length_output_length, huffman_output, &huffman_output_length);

    // Write the compressed output to a file
    FILE *output_file = fopen("output.bin", "wb");
    if (output_file == NULL) {
        printf("Error: could not open output file.\n");
        return 1;
    }
    fwrite(&run_length_output_length, sizeof(int), 1, output_file);
    fwrite(run_length_output, sizeof(RunLengthBlock), run_length_output_length, output_file);
    fwrite(&huffman_output_length, sizeof(int), 1, output_file);
    fwrite(huffman_output, sizeof(HuffmanCode), huffman_output_length, output_file);
    fclose(output_file);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall generate_run_length_encoding(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall generate_huffman_codes(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001A78) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-54h] BYREF
  char v5[13068]; // [rsp+30h] [rbp-50h] BYREF
  unsigned int v6; // [rsp+333Ch] [rbp+32BCh] BYREF
  char v7[80000]; // [rsp+3340h] [rbp+32C0h] BYREF
  char Buffer[100008]; // [rsp+16BC0h] [rbp+16B40h] BYREF
  FILE *v9; // [rsp+2F268h] [rbp+2F1E8h]
  int v10; // [rsp+2F274h] [rbp+2F1F4h]
  FILE *Stream; // [rsp+2F278h] [rbp+2F1F8h]

  _main(argc, argv, envp);
  Stream = fopen("input.txt", "r");
  if ( Stream )
  {
    v10 = fread(Buffer, 1ui64, 0x186A0ui64, Stream);
    Buffer[v10] = 0;
    fclose(Stream);
    generate_run_length_encoding(Buffer, v7, &v6);
    generate_huffman_codes(v7, v6, v5, &v4);
    v9 = fopen("output.bin", "wb");
    if ( v9 )
    {
      fwrite(&v6, 4ui64, 1ui64, v9);
      fwrite(v7, 8ui64, (int)v6, v9);
      fwrite(&v4, 4ui64, 1ui64, v9);
      fwrite(v5, 0x33ui64, v4, v9);
      fclose(v9);
      return 0;
    }
    else
    {
      printf("Error: could not open output file.\n");
      return 1;
    }
  }
  else
  {
    printf("Error: could not open input file.\n");
    return 1;
  }
}
// 140001591: using guessed type __int64 __fastcall generate_run_length_encoding(_QWORD, _QWORD, _QWORD);
// 14000167A: using guessed type __int64 __fastcall generate_huffman_codes(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001D10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001A78: using guessed type char Buffer[100008];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cat Language Translator ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Data structure for storing statistical information about translated words
typedef struct {
    char original[50];
    char translated[50];
    int count;
} Translation;

int main() {
    int numTranslations;
    printf("Enter number of translations: ");
    scanf("%d", &numTranslations);

    // Allocate memory for translation statistics
    Translation* translations = (Translation*) malloc(numTranslations * sizeof(Translation));

    // Prompt user to enter translations and update statistics
    for (int i = 0; i < numTranslations; i++) {
        printf("Enter original word: ");
        scanf("%s", translations[i].original);
        printf("Enter translation in C Cat Language: ");
        scanf("%s", translations[i].translated);

        int found = 0;
        for (int j = 0; j < i; j++) {
            if (strcmp(translations[i].translated, translations[j].translated) == 0) {
                translations[j].count++;
                found = 1;
                break;
            }
        }

        if (!found) {
            strcpy(translations[i].translated, translations[i].translated);
            translations[i].count = 1;
        }
    }

    // Print translation statistics
    printf("\nTranslation Statistics:\n");
    printf("%-20s %-20s %s\n", "Original Word", "Translation", "Count");
    for (int i = 0; i < numTranslations; i++) {
        printf("%-20s %-20s %d\n", translations[i].original, translations[i].translated, translations[i].count);
    }

    // Clean up memory
    free(translations);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-1Ch] BYREF
  void *Block; // [rsp+28h] [rbp-18h]
  int k; // [rsp+30h] [rbp-10h]
  int j; // [rsp+34h] [rbp-Ch]
  int v8; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter number of translations: ");
  scanf("%d", &v4);
  Block = malloc(104i64 * v4);
  for ( i = 0; i < v4; ++i )
  {
    printf("Enter original word: ");
    scanf("%s", (char *)Block + 104 * i);
    printf("Enter translation in C Cat Language: ");
    scanf("%s", (char *)Block + 104 * i + 50);
    v8 = 0;
    for ( j = 0; j < i; ++j )
    {
      if ( !strcmp((const char *)Block + 104 * i + 50, (const char *)Block + 104 * j + 50) )
      {
        ++*((_DWORD *)Block + 26 * j + 25);
        v8 = 1;
        break;
      }
    }
    if ( !v8 )
    {
      strcpy((char *)Block + 104 * i + 50, (const char *)Block + 104 * i + 50);
      *((_DWORD *)Block + 26 * i + 25) = 1;
    }
  }
  printf("\nTranslation Statistics:\n");
  printf("%-20s %-20s %s\n", "Original Word", "Translation", "Count");
  for ( k = 0; k < v4; ++k )
    printf(
      "%-20s %-20s %d\n",
      (const char *)Block + 104 * k,
      (const char *)Block + 104 * k + 50,
      *((unsigned int *)Block + 26 * k + 25));
  free(Block);
  return 0;
}
// 1400019D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Metadata Extractor ; Style: romantic
#include <stdio.h>
#include <stdlib.h>

int main() {

    // Open the file to extract metadata
    FILE *file = fopen("love.mp3", "r");

    // Check if file is opened successfully
    if (file == NULL) {
        printf("Failed to open file!");
        exit(1);
    }

    // Extract metadata using fseek and fread functions
    fseek(file, -128, SEEK_END);

    char tag[3];
    char title[30];
    char artist[30];
    char album[30];
    char year[4];
    char comment[29];
    char genre;

    fread(tag, sizeof(char), 3, file);
    fread(title, sizeof(char), 30, file);
    fread(artist, sizeof(char), 30, file);
    fread(album, sizeof(char), 30, file);
    fread(year, sizeof(char), 4, file);
    fread(comment, sizeof(char), 29, file);
    fread(&genre, sizeof(char), 1, file);

    // Print the extracted metadata
    printf("Title : %s\n", title);
    printf("Artist : %s\n", artist);
    printf("Album : %s\n", album);
    printf("Year : %s\n", year);
    printf("Comment : %s\n", comment);

    // Close the file
    fclose(file);

    // End the program with a romantic message
    printf("\n\nMy love, just like this program extracted metadata from a file, I extracted you from the world. You are the title that defines me, the artist that colors my life, and the album that's worth my soul. The year we met is engraved in my heart and our love is the comment that feels every space. You are the genre that gives my life meaning. I love you more than words can express. Always yours, my love.\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Fh] [rbp-A1h] BYREF
  char v5[44]; // [rsp+30h] [rbp-A0h] BYREF
  char v6[4]; // [rsp+5Ch] [rbp-74h] BYREF
  char v7[32]; // [rsp+60h] [rbp-70h] BYREF
  char v8[32]; // [rsp+80h] [rbp-50h] BYREF
  char v9[37]; // [rsp+A0h] [rbp-30h] BYREF
  char Buffer[3]; // [rsp+C5h] [rbp-Bh] BYREF
  FILE *Stream; // [rsp+C8h] [rbp-8h]

  _main(argc, argv, envp);
  Stream = fopen("love.mp3", "r");
  if ( !Stream )
  {
    printf("Failed to open file!");
    exit(1);
  }
  fseek(Stream, -128, 2);
  fread(Buffer, 1ui64, 3ui64, Stream);
  fread(v9, 1ui64, 0x1Eui64, Stream);
  fread(v8, 1ui64, 0x1Eui64, Stream);
  fread(v7, 1ui64, 0x1Eui64, Stream);
  fread(v6, 1ui64, 4ui64, Stream);
  fread(v5, 1ui64, 0x1Dui64, Stream);
  fread(&v4, 1ui64, 1ui64, Stream);
  printf("Title : %s\n", v9);
  printf("Artist : %s\n", v8);
  printf("Album : %s\n", v7);
  printf("Year : %s\n", v6);
  printf("Comment : %s\n", v5);
  fclose(Stream);
  printf(
    "\n"
    "\n"
    "My love, just like this program extracted metadata from a file, I extracted you from the world. You are the title th"
    "at defines me, the artist that colors my life, and the album that's worth my soul. The year we met is engraved in my"
    " heart and our love is the comment that feels every space. You are the genre that gives my life meaning. I love you "
    "more than words can express. Always yours, my love.\n");
  return 0;
}
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[3];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Unit converter ; Style: brave
#include <stdio.h>

int main() {
    double input, output;
    char unitFrom, unitTo;
    printf("Welcome to the Brave Unit Converter!\n");

    // Ask for initial unit and input value
    printf("Enter an input value and its original unit (i.e. 5e3 km): ");
    scanf("%lf %c%c", &input, &unitFrom, &unitFrom);

    // Ask for target unit to convert to
    printf("Enter target unit for conversion (i.e. mi): ");
    scanf(" %c", &unitTo);

    // Perform conversion
    if (unitFrom == 'm' && unitTo == 'f') {
        output = input * 3.281;
    } else if (unitFrom == 'f' && unitTo == 'm') {
        output = input / 3.281;
    } else if (unitFrom == 'c' && unitTo == 'f') {
        output = (input * 9/5) + 32;
    } else if (unitFrom == 'f' && unitTo == 'c') {
        output = (input - 32) * 5/9;
    } else if (unitFrom == 'k' && unitTo == 'c') {
        output = input - 273.15;
    } else if (unitFrom == 'c' && unitTo == 'k') {
        output = input + 273.15;
    } else if (unitFrom == 'm' && unitTo == 'k') {
        output = input / 1000;
    } else if (unitFrom == 'k' && unitTo == 'm') {
        output = input * 1000;
    } else if (unitFrom == 'g' && unitTo == 'oz') {
        output = input / 28.35;
    } else if (unitFrom == 'oz' && unitTo == 'g') {
        output = input * 28.35;
    } else {
        printf("Conversion not supported yet!\n");
        return 1;
    }

    // Print results
    printf("%.2f %c%c is equal to %.2f %c.\n", input, unitFrom, unitFrom, output, unitTo);

    // Allow for more conversions
    char answer;
    printf("Would you like to convert another value? (y/n): ");
    scanf(" %c", &answer);

    // Loop back to beginning if user wants to convert again
    while (answer == 'y') {
        printf("Enter an input value and its original unit (i.e. 5e3 km): ");
        scanf("%lf %c%c", &input, &unitFrom, &unitFrom);

        printf("Enter target unit for conversion (i.e. mi): ");
        scanf(" %c", &unitTo);

        // Perform conversion
        if (unitFrom == 'm' && unitTo == 'f') {
            output = input * 3.281;
        } else if (unitFrom == 'f' && unitTo == 'm') {
            output = input / 3.281;
        } else if (unitFrom == 'c' && unitTo == 'f') {
            output = (input * 9/5) + 32;
        } else if (unitFrom == 'f' && unitTo == 'c') {
            output = (input - 32) * 5/9;
        } else if (unitFrom == 'k' && unitTo == 'c') {
            output = input - 273.15;
        } else if (unitFrom == 'c' && unitTo == 'k') {
            output = input + 273.15;
        } else if (unitFrom == 'm' && unitTo == 'k') {
            output = input / 1000;
        } else if (unitFrom == 'k' && unitTo == 'm') {
            output = input * 1000;
        } else if (unitFrom == 'g' && unitTo == 'oz') {
            output = input / 28.35;
        } else if (unitFrom == 'oz' && unitTo == 'g') {
            output = input * 28.35;
        } else {
            printf("Conversion not supported yet!\n");
            return 1;
        }

        printf("%.2f %c%c is equal to %.2f %c.\n", input, unitFrom, unitFrom, output, unitTo);
        printf("Would you like to convert another value? (y/n): ");
        scanf(" %c", &answer);
    }

    printf("Thanks for using Brave Unit Converter!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-28h]
  char v5; // [rsp+3Dh] [rbp-13h] BYREF
  __int16 v6; // [rsp+3Eh] [rbp-12h] BYREF
  double v7; // [rsp+40h] [rbp-10h] BYREF
  double v8; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to the Brave Unit Converter!\n");
  printf("Enter an input value and its original unit (i.e. 5e3 km): ");
  scanf("%lf %c%c", &v7, (char *)&v6 + 1, (char *)&v6 + 1);
  printf("Enter target unit for conversion (i.e. mi): ");
  scanf(" %c", &v6);
  switch ( v6 )
  {
    case 28006:
      v8 = 3.281 * v7;
      break;
    case 26221:
      v8 = v7 / 3.281;
      break;
    case 25446:
      v8 = 9.0 * v7 / 5.0 + 32.0;
      break;
    case 26211:
      v8 = 5.0 * (v7 - 32.0) / 9.0;
      break;
    case 27491:
      v8 = v7 - 273.15;
      break;
    case 25451:
      v8 = v7 + 273.15;
      break;
    case 28011:
      v8 = v7 / 1000.0;
      break;
    case 27501:
      v8 = 1000.0 * v7;
      break;
    default:
      printf("Conversion not supported yet!\n");
      return 1;
  }
  printf("%.2f %c%c is equal to %.2f %c.\n", v7, (unsigned int)SHIBYTE(v6), (unsigned int)SHIBYTE(v6), v8, (char)v6);
  printf("Would you like to convert another value? (y/n): ");
  scanf(" %c", &v5);
  while ( v5 == 121 )
  {
    printf("Enter an input value and its original unit (i.e. 5e3 km): ");
    scanf("%lf %c%c", &v7, (char *)&v6 + 1, (char *)&v6 + 1);
    printf("Enter target unit for conversion (i.e. mi): ");
    scanf(" %c", &v6);
    switch ( v6 )
    {
      case 28006:
        v8 = 3.281 * v7;
        break;
      case 26221:
        v8 = v7 / 3.281;
        break;
      case 25446:
        v8 = 9.0 * v7 / 5.0 + 32.0;
        break;
      case 26211:
        v8 = 5.0 * (v7 - 32.0) / 9.0;
        break;
      case 27491:
        v8 = v7 - 273.15;
        break;
      case 25451:
        v8 = v7 + 273.15;
        break;
      case 28011:
        v8 = v7 / 1000.0;
        break;
      case 27501:
        v8 = 1000.0 * v7;
        break;
      default:
        printf("Conversion not supported yet!\n");
        return 1;
    }
    LODWORD(v4) = (char)v6;
    printf("%.2f %c%c is equal to %.2f %c.\n", v7, (unsigned int)SHIBYTE(v6), (unsigned int)SHIBYTE(v6), v8, v4);
    printf("Would you like to convert another value? (y/n): ");
    scanf(" %c", &v5);
  }
  printf("Thanks for using Brave Unit Converter!\n");
  return 0;
}
// 140001AAB: variable 'v4' is possibly undefined
// 140001BB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cryptographic hash function ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define ROTATE_LEFT(x, n) ((x << n) | (x >> (32 - n)))

uint32_t hash(const char* message) {
    uint32_t h0 = 0x67452301;
    uint32_t h1 = 0xEFCDAB89;
    uint32_t h2 = 0x98BADCFE;
    uint32_t h3 = 0x10325476;

    const uint8_t* msg = (const uint8_t*)message;
    uint32_t len = strlen(message);
    uint32_t bit_len = len << 3;

    uint32_t pad_count = (bit_len % 512) < 448 ? 448 - (bit_len % 512) : 512 + 448 - (bit_len % 512);
    uint32_t pad_len = (len + pad_count / 8 + 8);
    uint8_t* padded_msg = (uint8_t*)malloc(pad_len);

    memcpy(padded_msg, msg, len);
    padded_msg[len] = 0x80;
    for (uint32_t i = len + 1; i < pad_len - 8; ++i) {
        padded_msg[i] = 0x00;
    }

    padded_msg[pad_len - 8] = bit_len >> 24;
    padded_msg[pad_len - 7] = bit_len >> 16;
    padded_msg[pad_len - 6] = bit_len >> 8;
    padded_msg[pad_len - 5] = bit_len;

    uint32_t* chunks = (uint32_t*)padded_msg;
    uint32_t chunk_len = pad_len / 4;

    for (uint32_t i = 0; i < chunk_len; i += 16) {
        uint32_t a = h0;
        uint32_t b = h1;
        uint32_t c = h2;
        uint32_t d = h3;

        for (uint32_t j = 0; j < 64; ++j) {
            uint32_t f, g;

            if (j < 16) {
                f = (b & c) | ((~b) & d);
                g = j;
            } else if (j < 32) {
                f = (d & b) | ((~d) & c);
                g = (5 * j + 1) % 16;
            } else if (j < 48) {
                f = b ^ c ^ d;
                g = (3 * j + 5) % 16;
            } else {
                f = c ^ (b | (~d));
                g = (7 * j) % 16;
            }

            uint32_t temp_d = d;
            d = c;
            c = b;
            b = b + ROTATE_LEFT(a + f + chunks[i + g] + 0x5A827999, 5);
            a = temp_d;
        }

        h0 += a;
        h1 += b;
        h2 += c;
        h3 += d;
    }

    free(padded_msg);

    return (h3 << 24) | (h2 << 16) | (h1 << 8) | h0;
}

int main() {
    const char* message = "Hello, world!";
    uint32_t h = hash(message);
    printf("%s: %08x\n", message, h);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall hash(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001861) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch]

  _main(argc, argv, envp);
  v4 = hash("Hello, world!");
  printf("%s: %08x\n", "Hello, world!", v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall hash(_QWORD);
// 140001960: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Music Library Management System ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ARTISTS 1000
#define MAX_SONGS 5000
#define MAX_ALBUMS 1000

struct Artist {
    char name[50];
    int num_songs;
    int albums[MAX_ALBUMS];
    int num_albums;
};

struct Song {
    char name[50];
    int artist_id;
    int album_id;
};

struct Album {
    char name[50];
    int artist_id;
    int songs[MAX_SONGS];
    int num_songs;
};

struct MusicLibrary {
    struct Artist artists[MAX_ARTISTS];
    struct Song songs[MAX_SONGS];
    struct Album albums[MAX_ALBUMS];
    int num_artists;
    int num_songs;
    int num_albums;
};

void add_artist(struct MusicLibrary *l, char *name) {
    strcpy(l->artists[l->num_artists].name, name);
    l->artists[l->num_artists].num_songs = 0;
    l->artists[l->num_artists].num_albums = 0;
    l->num_artists++;
}

void add_album(struct MusicLibrary *l, char *name, int artist_id) {
    strcpy(l->albums[l->num_albums].name, name);
    l->albums[l->num_albums].artist_id = artist_id;
    l->albums[l->num_albums].num_songs = 0;
    l->artists[artist_id].albums[l->artists[artist_id].num_albums] = l->num_albums;
    l->artists[artist_id].num_albums++;
    l->num_albums++;
}

void add_song(struct MusicLibrary *l, char *name, int artist_id, int album_id) {
    strcpy(l->songs[l->num_songs].name, name);
    l->songs[l->num_songs].artist_id = artist_id;
    l->songs[l->num_songs].album_id = album_id;
    l->albums[album_id].songs[l->albums[album_id].num_songs] = l->num_songs;
    l->albums[album_id].num_songs++;
    l->artists[artist_id].num_songs++;
    l->num_songs++;
}

void print_artist(struct MusicLibrary l, int artist_id) {
    printf("Artist: %s\n", l.artists[artist_id].name);
    printf("Number of albums: %d\n", l.artists[artist_id].num_albums);
    for (int i = 0; i < l.artists[artist_id].num_albums; i++) {
        printf("Album %d: %s\n", i, l.albums[l.artists[artist_id].albums[i]].name);
    }
    printf("Number of songs: %d\n", l.artists[artist_id].num_songs);
}

void print_album(struct MusicLibrary l, int album_id) {
    printf("Album: %s\n", l.albums[album_id].name);
    printf("Artist: %s\n", l.artists[l.albums[album_id].artist_id].name);
    printf("Number of songs: %d\n", l.albums[album_id].num_songs);
    for (int i = 0; i < l.albums[album_id].num_songs; i++) {
        printf("Song %d: %s\n", i, l.songs[l.albums[album_id].songs[i]].name);
    }
}

void print_song(struct MusicLibrary l, int song_id) {
    printf("Song: %s\n", l.songs[song_id].name);
    printf("Artist: %s\n", l.artists[l.songs[song_id].artist_id].name);
    printf("Album: %s\n", l.albums[l.songs[song_id].album_id].name);
}

int main() {
    struct MusicLibrary library;
    library.num_artists = 0;
    library.num_songs = 0;
    library.num_albums = 0;
    add_artist(&library, "The Beatles");
    add_album(&library, "Abbey Road", 0);
    add_song(&library, "Come Together", 0, 0);
    add_song(&library, "Something", 0, 0);
    add_song(&library, "Maxwell's Silver Hammer", 0, 0);
    add_album(&library, "The White Album", 0);
    add_song(&library, "Back in the U.S.S.R.", 0, 1);
    add_song(&library, "Dear Prudence", 0, 1);
    add_song(&library, "Ob-La-Di, Ob-La-Da", 0, 1);
    add_song(&library, "While My Guitar Gently Weeps", 0, 1);
    print_artist(library, 0);
    print_album(library, 0);
    print_song(library, 0);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (0000000140001BAE) ----------------------------------------------------
#error "140001BAE: stack frame is too big (funcsize=0)"

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Metadata Extractor ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Metadata {
    char title[50];
    char artist[50];
    char album[50];
    char genre[50];
    int year;
} Metadata;

Metadata extract_metadata(char *filename) {
    Metadata metadata;
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        printf("Error opening file %s\n", filename);
        exit(1);
    }
    fseek(file, -128, SEEK_END);
    char tag[3];
    fread(tag, sizeof(tag), 1, file);
    if (memcmp(tag, "TAG", 3) == 0) {
        fread(metadata.title, sizeof(metadata.title), 1, file);
        fread(metadata.artist, sizeof(metadata.artist), 1, file);
        fread(metadata.album, sizeof(metadata.album), 1, file);
        fread(&metadata.year, sizeof(metadata.year), 1, file);
        fread(metadata.genre, sizeof(metadata.genre), 1, file);
    }
    fclose(file);
    return metadata;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: metadata_extractor <filename>\n");
        exit(1);
    }
    Metadata metadata = extract_metadata(argv[1]);
    printf("Title: %s\n", metadata.title);
    printf("Artist: %s\n", metadata.artist);
    printf("Album: %s\n", metadata.album);
    printf("Year: %d\n", metadata.year);
    printf("Genre: %s\n", metadata.genre);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall extract_metadata(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001821) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[50]; // [rsp+20h] [rbp-D0h] BYREF
  char v5[50]; // [rsp+52h] [rbp-9Eh] BYREF
  char v6[50]; // [rsp+84h] [rbp-6Ch] BYREF
  char v7[50]; // [rsp+B6h] [rbp-3Ah] BYREF
  unsigned int v8; // [rsp+E8h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc <= 1 )
  {
    printf("Usage: metadata_extractor <filename>\n");
    exit(1);
  }
  extract_metadata(v4, argv[1]);
  printf("Title: %s\n", v4);
  printf("Artist: %s\n", v5);
  printf("Album: %s\n", v6);
  printf("Year: %d\n", v8);
  printf("Genre: %s\n", v7);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall extract_metadata(_QWORD, _QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001821: using guessed type char anonymous_0[50];
// 140001821: using guessed type char anonymous_1[50];
// 140001821: using guessed type char anonymous_2[50];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Encyptor ; Style: accurate
#include <stdio.h>
#include <stdlib.h>

#define MAX_LENGTH 1000 // define maximum length of file to be encrypted

void encryptFile(char filename[]) {
    FILE *fp = fopen(filename, "rb"); // open file for reading in binary mode

    if (fp == NULL) {
        printf("Failed to open file %s\n", filename);
        return;
    }

    // create new encrypted file
    char newFilename[strlen(filename) + 4]; // add 4 to accommodate ".enc" file extension
    strcpy(newFilename, filename);
    strcat(newFilename, ".enc");
    FILE *encFile = fopen(newFilename, "wb"); // open new file for writing in binary mode

    if (encFile == NULL) {
        printf("Failed to create encrypted file %s\n", newFilename);
        return;
    }

    // read input file in chunks and encrypt each chunk
    unsigned char buffer[MAX_LENGTH];
    int bytesRead;
    while ((bytesRead = fread(buffer, sizeof(unsigned char), MAX_LENGTH, fp)) > 0) {
        for (int i = 0; i < bytesRead; i++) {
            buffer[i] ^= 0xFF; // XOR each byte with 11111111 to encrypt it
        }
        fwrite(buffer, sizeof(unsigned char), bytesRead, encFile); // write encrypted chunk to new file
    }

    fclose(fp);
    fclose(encFile);
    printf("File %s encrypted successfully!\n", filename);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: ./encrypt [filename]\n");
        return 1;
    }

    encryptFile(argv[1]);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall encryptFile(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017B4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  if ( argc == 2 )
  {
    encryptFile(argv[1]);
    return 0;
  }
  else
  {
    printf("Usage: ./encrypt [filename]\n");
    return 1;
  }
}
// 140001591: using guessed type __int64 __fastcall encryptFile(_QWORD);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Time Travel Simulator ; Style: inquisitive
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int year, month, day;   // variables to store the date
    int hour, minute, second; // variables to store the time

    printf("Welcome to the Time Travel Simulator! \n");
    printf("Please enter a date (YYYY-MM-DD): ");
    scanf("%d-%d-%d", &year, &month, &day);

    printf("Please enter a time (HH:MM:SS): ");
    scanf("%d:%d:%d", &hour, &minute, &second);

    printf("\nYou have entered the date and time: %d-%d-%d %d:%d:%d \n", year, month, day, hour, minute, second);

    // check if the date and time are valid
    if (year < 0 || month < 1 || month > 12 || day < 1 || day > 31 || hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59)
    {
        printf("Invalid date or time entered. Please try again. \n");
        return 0;
    }

    // calculate the total number of seconds since epoch time (Jan 1, 1970)
    long int total_seconds = (year - 1970) * 31536000 + (month - 1) * 2678400 + (day - 1) * 86400 + hour * 3600 + minute * 60 + second;

    // ask the user how many seconds they wish to travel through time
    int time_travel;
    printf("\nHow many seconds would you like to travel through time? ");
    scanf("%d", &time_travel);

    // calculate the new timestamp after traveling through time
    long int new_timestamp = total_seconds + time_travel;

    // calculate the new date and time
    int new_year = 1970 + new_timestamp / 31536000;
    new_timestamp = new_timestamp % 31536000;
    int new_month = new_timestamp / 2678400 + 1;
    new_timestamp = new_timestamp % 2678400;
    int new_day = new_timestamp / 86400 + 1;
    new_timestamp = new_timestamp % 86400;
    int new_hour = new_timestamp / 3600;
    new_timestamp = new_timestamp % 3600;
    int new_minute = new_timestamp / 60;
    int new_second = new_timestamp % 60;

    // display the new date and time
    printf("\nAfter traveling through time, you have arrived at: %d-%d-%d %d:%d:%d \n", new_year, new_month, new_day, new_hour, new_minute, new_second);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-60h]
  __int64 v5; // [rsp+28h] [rbp-58h]
  __int64 v6; // [rsp+30h] [rbp-50h]
  int v7; // [rsp+44h] [rbp-3Ch] BYREF
  unsigned int v8; // [rsp+48h] [rbp-38h] BYREF
  unsigned int v9; // [rsp+4Ch] [rbp-34h] BYREF
  unsigned int v10; // [rsp+50h] [rbp-30h] BYREF
  int v11; // [rsp+54h] [rbp-2Ch] BYREF
  int v12; // [rsp+58h] [rbp-28h] BYREF
  int v13[3]; // [rsp+5Ch] [rbp-24h] BYREF
  int v14; // [rsp+68h] [rbp-18h]
  unsigned int v15; // [rsp+6Ch] [rbp-14h]
  unsigned int v16; // [rsp+70h] [rbp-10h]
  unsigned int v17; // [rsp+74h] [rbp-Ch]
  int v18; // [rsp+78h] [rbp-8h]
  unsigned int v19; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Time Travel Simulator! \n");
  printf("Please enter a date (YYYY-MM-DD): ");
  scanf("%d-%d-%d", v13, &v12, &v11);
  printf("Please enter a time (HH:MM:SS): ");
  scanf("%d:%d:%d", &v10, &v9, &v8);
  printf(
    "\nYou have entered the date and time: %d-%d-%d %d:%d:%d \n",
    (unsigned int)v13[0],
    (unsigned int)v12,
    (unsigned int)v11,
    v10,
    v9,
    v8);
  if ( v13[0] >= 0 && v12 > 0 && v12 <= 12 && v11 > 0 && v11 <= 31 && v10 <= 0x17 && v9 <= 0x3B && v8 < 0x3C )
  {
    v19 = 60 * v9 + 3600 * v10 + 86400 * (v11 - 1) + 2678400 * (v12 - 1) + 31536000 * (v13[0] - 1970) + v8;
    printf("\nHow many seconds would you like to travel through time? ");
    scanf("%d", &v7);
    v17 = (int)(v7 + v19) / 31536000 + 1970;
    v16 = (int)(v7 + v19) % 31536000 / 2678400 + 1;
    v18 = (int)(v7 + v19) % 31536000 % 2678400;
    v15 = v18 / 86400 + 1;
    v18 %= 86400;
    v14 = v18 / 3600;
    v18 %= 3600;
    v13[2] = v18 / 60;
    v13[1] = v18 % 60;
    LODWORD(v6) = v18 % 60;
    LODWORD(v5) = v18 / 60;
    LODWORD(v4) = v14;
    printf("\nAfter traveling through time, you have arrived at: %d-%d-%d %d:%d:%d \n", v17, v16, v15, v4, v5, v6);
    return 0;
  }
  else
  {
    printf("Invalid date or time entered. Please try again. \n");
    return 0;
  }
}
// 14000191D: variable 'v4' is possibly undefined
// 14000191D: variable 'v5' is possibly undefined
// 14000191D: variable 'v6' is possibly undefined
// 1400019E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Haunted House Simulator ; Style: light-weight
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>

int roomCount = 5; // Number of rooms in the house
int currentRoom = 0; // We start in room 0
int maxSteps = 10; // Maximum number of steps we can take
int currentSteps = 0; // Number of steps we have taken
bool endGame = false; // Have we reached the end of the game?

// Array of room descriptions
const char* roomDescriptions[] = {
    "You are in the foyer. There is a door to the north.",
    "You are in the living room. There is a door to the north and a door to the east.",
    "You are in the dining room. There is a door to the west and a door to the south.",
    "You are in the kitchen. There is a door to the east.",
    "You are in the bedroom. There is a door to the south."
};

// Array of room spooky descriptions
const char* roomSpookyDescriptions[] = {
    "You feel a chill run down your spine as you step into the foyer.",
    "You hear a faint whisper coming from the living room.",
    "You smell a faint scent of decaying flesh coming from the dining room.",
    "You hear a loud creaking noise coming from the kitchen.",
    "You see a shadowy figure in the bedroom."
};

// Function to randomly generate spooky descriptions
const char* getSpookyDescription() {
    int index = rand() % roomCount;
    return roomSpookyDescriptions[index];
}

// Function to handle the player moving to a new room
void moveToRoom(int roomIndex) {
    currentRoom = roomIndex;
    currentSteps++;
    
    printf("You walk into the room.\n\n");
    printf("%s\n\n", roomDescriptions[currentRoom]);
    
    // Occasionally print a spooky description
    int chance = rand() % 10; 
    if(chance == 0) {
        printf("%s\n\n", getSpookyDescription());
    }
    
    // If we have reached the last room, end the game
    if(currentRoom == roomCount - 1) {
        printf("You have reached the end of the haunted house!\n");
        endGame = true;
        return;
    }
    
    // If we have taken too many steps, end the game
    if(currentSteps >= maxSteps) {
        printf("You've run out of steps and have become lost in the haunted house...\n");
        endGame = true;
        return;
    }
}

int main() {
    // Seed random number generator
    srand(time(NULL));
    
    printf("Welcome to the Haunted House Simulator!\n");
    printf("You have 10 steps to navigate through the haunted house and reach the end.\n\n");
    
    // Start in the first room
    printf("%s\n\n", roomDescriptions[currentRoom]);
    
    // Main game loop
    while(!endGame) {
        // Ask the player which direction they want to go
        printf("Which direction do you want to go? (north/south/east/west)\n");
        char input[10];
        scanf("%s", input);
        
        int nextRoom = -1;
        
        // Figure out which room the player wants to enter
        if(strcmp(input, "north") == 0) {
            nextRoom = currentRoom + 1;
        }
        else if(strcmp(input, "south") == 0) {
            nextRoom = currentRoom - 1;
        }
        else if(strcmp(input, "east") == 0) {
            nextRoom = currentRoom + 2;
        }
        else if(strcmp(input, "west") == 0) {
            nextRoom = currentRoom - 2;
        }
        else {
            printf("Invalid direction!\n\n");
        }
        
        // If the next room is valid, move to it
        if(nextRoom >= 0 && nextRoom < roomCount) {
            moveToRoom(nextRoom);
        }
    }
    
    printf("Thanks for playing!\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall moveToRoom(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

int roomCount = 5; // weak
char *roomDescriptions[5] =
{
  "You are in the foyer. There is a door to the north.",
  "You are in the living room. There is a door to the north and a door to the east.",
  "You are in the dining room. There is a door to the west and a door to the south.",
  "You are in the kitchen. There is a door to the east.",
  "You are in the bedroom. There is a door to the south."
}; // weak
int currentRoom; // weak
char endGame; // weak


//----- (000000014000173F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char Str1[10]; // [rsp+22h] [rbp-Eh] BYREF
  int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Haunted House Simulator!\n");
  printf("You have 10 steps to navigate through the haunted house and reach the end.\n\n");
  printf("%s\n\n", roomDescriptions[currentRoom]);
  while ( endGame != 1 )
  {
    printf("Which direction do you want to go? (north/south/east/west)\n");
    scanf("%s", Str1);
    v6 = -1;
    if ( !strcmp(Str1, "north") )
    {
      v6 = currentRoom + 1;
    }
    else if ( !strcmp(Str1, "south") )
    {
      v6 = currentRoom - 1;
    }
    else if ( !strcmp(Str1, "east") )
    {
      v6 = currentRoom + 2;
    }
    else if ( !strcmp(Str1, "west") )
    {
      v6 = currentRoom - 2;
    }
    else
    {
      printf("Invalid direction!\n\n");
    }
    if ( v6 >= 0 && v6 < roomCount )
      moveToRoom((unsigned int)v6);
  }
  printf("Thanks for playing!\n");
  return 0;
}
// 140001638: using guessed type __int64 __fastcall moveToRoom(_QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140014020: using guessed type int roomCount;
// 140014040: using guessed type char *roomDescriptions[5];
// 140019040: using guessed type int currentRoom;
// 140019048: using guessed type char endGame;

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Recursive ; Style: minimalist
#include <stdio.h>

int fibonacci(int n)
{
    if(n == 0)
        return 0;
    else if(n == 1)
        return 1;
    else
        return fibonacci(n-1) + fibonacci(n-2);
}

int main()
{
    int n, i;

    printf("Enter the number of terms you want in the series: ");
    scanf("%d", &n);

    printf("Fibonacci Series: ");

    for(i = 0; i < n; i++)
    {
        printf("%d, ", fibonacci(i));
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall fibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000162F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+28h] [rbp-8h] BYREF
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of terms you want in the series: ");
  scanf("%d", &v5);
  printf("Fibonacci Series: ");
  for ( i = 0; (int)i < v5; ++i )
  {
    v3 = fibonacci(i);
    printf("%d, ", v3);
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Haunted House Simulator ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    // Setting up the random number generator
    srand(time(NULL));

    // Room description and item assignments
    char* rooms[] = {"Entrance", "Living Room", "Kitchen", "Dining Room", "Bedroom", "Bathroom", "Basement"};
    char* items[] = {"Ghost", "Skeleton", "Candlestick", "Book", "Knife", "Rope", "Poison"};

    // Initializing room and item indexes
    int room_index = 0;
    int item_index = 0;

    // Starting the simulation
    printf("Welcome to the Haunted House Simulator!\n");
    while (1) {
        printf("You are in the %s. ", rooms[room_index]);

        // Checking if there is an item in the room and selecting a random item if there is
        if (rand() % 2 == 1) {
            item_index = rand() % 7;
            printf("You see a %s in the room. ", items[item_index]);
        }

        // Checking if the player has found all the items
        if (item_index == 6) {
            printf("You have found all the items! Congratulations, you have escaped the haunted house!\n");
            break;
        }

        // Generating a random number between 0 and 3 for the player's next move
        int direction = rand() % 4;
        switch(direction) {
            case 0:
                printf("You move North.\n");
                if (room_index == 0) {
                    printf("You are at a dead end. You cannot go North.\n");
                }
                else {
                    room_index--;
                }
                break;
            case 1:
                printf("You move South.\n");
                if (room_index == 6) {
                    printf("You are at a dead end. You cannot go South.\n");
                }
                else {
                    room_index++;
                }
                break;
            case 2:
                printf("You move East.\n");
                if (room_index == 3 || room_index == 5) {
                    printf("You are at a dead end. You cannot go East.\n");
                }
                else {
                    room_index += 2;
                }
                break;
            case 3:
                printf("You move West.\n");
                if (room_index == 0 || room_index == 2 || room_index == 4) {
                    printf("You are at a dead end. You cannot go West.\n");
                }
                else {
                    room_index -= 2;
                }
                break;
            default:
                break;
        }
    }

    // End of the program
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5[8]; // [rsp+20h] [rbp-90h]
  __int64 v6[8]; // [rsp+60h] [rbp-50h]
  int v7; // [rsp+A4h] [rbp-Ch]
  int v8; // [rsp+A8h] [rbp-8h]
  int v9; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v6[0] = (__int64)"Entrance";
  v6[1] = (__int64)"Living Room";
  v6[2] = (__int64)"Kitchen";
  v6[3] = (__int64)"Dining Room";
  v6[4] = (__int64)"Bedroom";
  v6[5] = (__int64)"Bathroom";
  v6[6] = (__int64)"Basement";
  v5[0] = (__int64)"Ghost";
  v5[1] = (__int64)"Skeleton";
  v5[2] = (__int64)"Candlestick";
  v5[3] = (__int64)"Book";
  v5[4] = (__int64)"Knife";
  v5[5] = (__int64)"Rope";
  v5[6] = (__int64)"Poison";
  v9 = 0;
  v8 = 0;
  printf("Welcome to the Haunted House Simulator!\n");
  while ( 1 )
  {
    printf("You are in the %s. ", (const char *)v6[v9]);
    if ( rand() % 2 == 1 )
    {
      v8 = rand() % 7;
      printf("You see a %s in the room. ", (const char *)v5[v8]);
    }
    if ( v8 == 6 )
      break;
    v7 = rand() % 4;
    if ( v7 == 3 )
    {
      printf("You move West.\n");
      if ( !v9 || v9 == 2 || v9 == 4 )
        printf("You are at a dead end. You cannot go West.\n");
      else
        v9 -= 2;
    }
    else if ( v7 <= 3 )
    {
      if ( v7 == 2 )
      {
        printf("You move East.\n");
        if ( v9 == 3 || v9 == 5 )
          printf("You are at a dead end. You cannot go East.\n");
        else
          v9 += 2;
      }
      else if ( v7 )
      {
        if ( v7 == 1 )
        {
          printf("You move South.\n");
          if ( v9 == 6 )
            printf("You are at a dead end. You cannot go South.\n");
          else
            ++v9;
        }
      }
      else
      {
        printf("You move North.\n");
        if ( v9 )
          --v9;
        else
          printf("You are at a dead end. You cannot go North.\n");
      }
    }
  }
  printf("You have found all the items! Congratulations, you have escaped the haunted house!\n");
  return 0;
}
// 14000175A: conditional instruction was optimized away because %var_C.4<2
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Resume Parsing System ; Style: realistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_INPUT 1000
#define MAX_OUTPUT 100

typedef struct Resume
{
    char name[20];
    char email[50];
    char phone[20];
    char education[50];
    char experience[50];
} Resume;

void parseResume(char *input, Resume *output);

int main()
{
    char input[MAX_INPUT];
    Resume output[MAX_OUTPUT];

    printf("Enter resume information: ");
    fgets(input, MAX_INPUT, stdin);

    parseResume(input, output);

    printf("\nResume parsed successfully!\n");
    for(int i=0; i<MAX_OUTPUT; i++)
    {
        if(output[i].name[0] == '\0')
            break;
        printf("\nName: %s\n", output[i].name);
        printf("Email: %s\n", output[i].email);
        printf("Phone: %s\n", output[i].phone);
        printf("Education: %s\n", output[i].education);
        printf("Experience: %s\n", output[i].experience);
    }

    return 0;
}

void parseResume(char *input, Resume *output)
{
    int i=0, j=0, k=0, l=0, m=0;
    char temp[20];

    while(input[i] != '\0')
    {
        if(input[i] == '\n')
            input[i] = ' ';
        if(input[i] == ':')
        {
            temp[j] = '\0';
            j = 0;
            i++;
            switch(temp[0])
            {
                case 'N':
                    strcpy(output[k].name, &input[i]);
                    break;
                case 'E':
                    strcpy(output[k].email, &input[i]);
                    break;
                case 'P':
                    strcpy(output[k].phone, &input[i]);
                    break;
                case 'S':
                    strcpy(output[k].education, &input[i]);
                    break;
                case 'X':
                    strcpy(output[k].experience, &input[i]);
                    break;
            }
        }
        else
        {
            temp[j++] = input[i];
        }

        if(input[i] == ',')
        {
            output[k].name[l-1] = '\0';
            output[k].experience[m-1] = '\0';
            k++;
            l = 0;
            m = 0;
        }
        else if(input[i] == ' ')
        {
            if(temp[0] == 'N')
                l = j;
            if(temp[0] == 'X')
                m = j;
        }

        i++;
    }

    output[k].name[l-1] = '\0';
    output[k].experience[m-1] = '\0';
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall parseResume(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  _WORD v5[48]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v6; // [rsp+80h] [rbp+0h] BYREF
  char Buffer[1004]; // [rsp+4A60h] [rbp+49E0h] BYREF
  int i; // [rsp+4E4Ch] [rbp+4DCCh]

  _main(argc, argv, envp);
  printf("Enter resume information: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  parseResume(Buffer, v5);
  printf("\nResume parsed successfully!\n");
  for ( i = 0; i <= 99 && *((_BYTE *)&v6 + 190 * i - 96); ++i )
  {
    printf("\nName: %s\n", (const char *)&v5[95 * i]);
    printf("Email: %s\n", (const char *)&v5[95 * i + 10]);
    printf("Phone: %s\n", (const char *)&v5[95 * i + 35]);
    printf("Education: %s\n", (const char *)&v5[95 * i + 45]);
    printf("Experience: %s\n", (const char *)&v5[95 * i + 70]);
  }
  return 0;
}
// 14000174B: using guessed type __int64 __fastcall parseResume(_QWORD, _QWORD);
// 140001AD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Genome Sequencing Simulator ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define SEQUENCE_LENGTH 50

// Utility function to print the sequence
void print_sequence(int *sequence) {
    printf("Sequence:");
    for (int i = 0; i < SEQUENCE_LENGTH; i++) {
        printf(" %d", sequence[i]);
    }
    printf("\n");
}

// Function to generate a random sequence
void generate_sequence(int *sequence) {
    srand(time(NULL)); // Seed the random number generator with the current time
    for (int i = 0; i < SEQUENCE_LENGTH; i++) {
        sequence[i] = rand() % 4; // Generate a random integer between 0 and 3 inclusive
    }
}

// Function to simulate genome sequencing
void simulate_sequencing(int *reference, int *sequence) {
    // Create a copy of the reference sequence
    int reference_copy[SEQUENCE_LENGTH];
    for (int i = 0; i < SEQUENCE_LENGTH; i++) {
        reference_copy[i] = reference[i];
    }

    // Introduce mutations into the sequence
    for (int i = 0; i < SEQUENCE_LENGTH; i++) {
        if (reference_copy[i] == sequence[i]) {
            continue; // If the base is the same as the reference, no mutation occurs
        }

        // Otherwise, introduce a random mutation
        int mutation = rand() % 3; // Generate a random integer between 0 and 2 inclusive
        switch (mutation) {
            case 0: // Substitution
                sequence[i] = reference_copy[i];
                break;
            case 1: // Insertion
                for (int j = SEQUENCE_LENGTH - 1; j > i; j--) {
                    sequence[j] = sequence[j - 1];
                }
                sequence[i] = reference_copy[i];
                break;
            case 2: // Deletion
                for (int j = i + 1; j < SEQUENCE_LENGTH; j++) {
                    sequence[j - 1] = sequence[j];
                }
                sequence[SEQUENCE_LENGTH - 1] = rand() % 4; // Insert a random base at the end
                break;
        }
        reference_copy[i] = sequence[i]; // Update the reference copy
    }
}

int main() {
    int reference_sequence[SEQUENCE_LENGTH];
    generate_sequence(reference_sequence);
    print_sequence(reference_sequence);

    int sequence[SEQUENCE_LENGTH];
    generate_sequence(sequence);
    print_sequence(sequence);

    simulate_sequencing(reference_sequence, sequence);
    print_sequence(sequence);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall print_sequence(_QWORD); // weak
__int64 __fastcall generate_sequence(_QWORD); // weak
__int64 __fastcall simulate_sequencing(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001895) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[208]; // [rsp+20h] [rbp-60h] BYREF
  char v5[208]; // [rsp+F0h] [rbp+70h] BYREF

  _main(argc, argv, envp);
  generate_sequence(v5);
  print_sequence(v5);
  generate_sequence(v4);
  print_sequence(v4);
  simulate_sequencing(v5, v4);
  print_sequence(v4);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall print_sequence(_QWORD);
// 14000161B: using guessed type __int64 __fastcall generate_sequence(_QWORD);
// 14000167E: using guessed type __int64 __fastcall simulate_sequencing(_QWORD, _QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bitwise operations ; Style: thoughtful
#include <stdio.h>

int main() {
    // declare two integers
    int a = 10, b = 7;
    
    // perform bitwise AND (&) operation
    int and_result = a & b;
    
    // perform bitwise OR (|) operation
    int or_result = a | b;
    
    // perform bitwise XOR (^) operation
    int xor_result = a ^ b;
    
    // perform bitwise NOT (~) operation
    int not_result = ~a;
    
    printf("Bitwise AND result: %d\n", and_result);
    printf("Bitwise OR result: %d\n", or_result);
    printf("Bitwise XOR result: %d\n", xor_result);
    printf("Bitwise NOT result: %d\n", not_result);
    
    // perform left shift (<<) operation
    int left_shift_result = a << 2;
    
    // perform right shift (>>) operation
    int right_shift_result = a >> 2;
    
    printf("Left shift result: %d\n", left_shift_result);
    printf("Right shift result: %d\n", right_shift_result);
    
    // create a mask to clear the last 3 bits of a
    int mask = ~0 << 3;
    
    // clear the last 3 bits of a using the mask and bitwise AND
    int new_a = a & mask;
    
    printf("New a value after clearing last 3 bits: %d\n", new_a);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("Bitwise AND result: %d\n", 2i64);
  printf("Bitwise OR result: %d\n", 15i64);
  printf("Bitwise XOR result: %d\n", 13i64);
  printf("Bitwise NOT result: %d\n", 4294967285i64);
  printf("Left shift result: %d\n", 40i64);
  printf("Right shift result: %d\n", 2i64);
  printf("New a value after clearing last 3 bits: %d\n", 8i64);
  return 0;
}
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System event logger ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define LOG_FILE "event_log.txt"

/* Function to log events to the file */
void log_event(char* event) {
   time_t t = time(NULL);
   struct tm tm = *localtime(&t);
   FILE* log_file = fopen(LOG_FILE, "a");
   fprintf(log_file, "%d/%02d/%02d %02d:%02d:%02d - %s\n", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, event);
   fclose(log_file);
}

int main() {
   log_event("Application started");

   /* Sample event */
   int a = 10, b = 20;
   if (a < b) {
      log_event("a is less than b");
   } else {
      log_event("b is less than or equal to a");
   }

   log_event("Application exited");

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall log_event(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000169B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  log_event("Application started");
  log_event("a is less than b");
  log_event("Application exited");
  return 0;
}
// 1400015C1: using guessed type __int64 __fastcall log_event(_QWORD);
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mailing list manager ; Style: happy
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_EMAILS 1000
#define MAX_NAME_LEN 50
#define MAX_EMAIL_LEN 100

typedef struct Contact {
    char name[MAX_NAME_LEN];
    char email[MAX_EMAIL_LEN];
} Contact;

int main() {

    Contact* mailingList = (Contact*) malloc(sizeof(Contact) * MAX_EMAILS);

    if (mailingList == NULL) {
        printf("Error allocating memory for mailing list.\n");
        return 1;
    }

    int numContacts = 0;

    printf("Welcome to the Happy Mailing List Manager!\n\n");

    while (1) {
        printf("Please choose an option:\n"
                "1. Add a contact to the mailing list\n"
                "2. Display all contacts in the mailing list\n"
                "3. Exit\n");

        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                if (numContacts == MAX_EMAILS) {
                    printf("Sorry, the mailing list is full.\n");
                    break;
                }

                printf("Adding a new contact:\n");

                printf("Name: ");
                char name[MAX_NAME_LEN];
                scanf("%s", name);

                printf("Email: ");
                char email[MAX_EMAIL_LEN];
                scanf("%s", email);

                strcpy(mailingList[numContacts].name, name);
                strcpy(mailingList[numContacts].email, email);

                printf("Contact added!\n");

                numContacts++;

                break;
            }
            case 2: {
                if (numContacts == 0) {
                    printf("There are no contacts in the mailing list yet.\n");
                    break;
                }

                printf("Mailing list:\n");

                for (int i = 0; i < numContacts; i++) {
                    printf("%s: %s\n", mailingList[i].name, mailingList[i].email);
                }

                break;
            }
            case 3: {
                printf("Thank you for using the Happy Mailing List Manager! Have a great day!\n");
                free(mailingList);
                return 0;
            }
            default: {
                printf("Sorry, that is not a valid option. Please choose again.\n");
            }
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strcpy(char *Destination, const char *Source);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Source[64]; // [rsp+20h] [rbp-C0h] BYREF
  char v5[108]; // [rsp+60h] [rbp-80h] BYREF
  int v6; // [rsp+CCh] [rbp-14h] BYREF
  void *Block; // [rsp+D0h] [rbp-10h]
  int i; // [rsp+D8h] [rbp-8h]
  int v9; // [rsp+DCh] [rbp-4h]

  _main(argc, argv, envp);
  Block = malloc(0x249F0ui64);
  if ( !Block )
  {
    printf("Error allocating memory for mailing list.\n");
    return 1;
  }
  v9 = 0;
  printf("Welcome to the Happy Mailing List Manager!\n\n");
  while ( 1 )
  {
    printf(
      "Please choose an option:\n"
      "1. Add a contact to the mailing list\n"
      "2. Display all contacts in the mailing list\n"
      "3. Exit\n");
    scanf("%d", &v6);
    if ( v6 == 3 )
      break;
    if ( v6 > 3 )
      goto LABEL_19;
    if ( v6 == 1 )
    {
      if ( v9 == 1000 )
      {
        printf("Sorry, the mailing list is full.\n");
      }
      else
      {
        printf("Adding a new contact:\n");
        printf("Name: ");
        scanf("%s", Source);
        printf("Email: ");
        scanf("%s", v5);
        strcpy((char *)Block + 150 * v9, Source);
        strcpy((char *)Block + 150 * v9 + 50, v5);
        printf("Contact added!\n");
        ++v9;
      }
    }
    else if ( v6 == 2 )
    {
      if ( v9 )
      {
        printf("Mailing list:\n");
        for ( i = 0; i < v9; ++i )
          printf("%s: %s\n", (const char *)Block + 150 * i, (const char *)Block + 150 * i + 50);
      }
      else
      {
        printf("There are no contacts in the mailing list yet.\n");
      }
    }
    else
    {
LABEL_19:
      printf("Sorry, that is not a valid option. Please choose again.\n");
    }
  }
  printf("Thank you for using the Happy Mailing List Manager! Have a great day!\n");
  free(Block);
  return 0;
}
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pac-Man Game Clone ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Define constants
#define ROWS 15
#define COLS 20
#define EMPTY ' '
#define DOT '.'
#define WALL '*'
#define PACMAN 'P'
#define GHOST 'G'
#define SPEED 250 // in milliseconds

// Define global variables
char grid[ROWS][COLS];
int pacman_row, pacman_col, score;

// Define function prototypes
void initialize_grid();
void print_grid();
int get_random(int min, int max);
int move_ghosts();
int move_pacman(int d_row, int d_col);
void add_dot();
void play_game();

// Define the main function
int main() {
    // Set the random seed
    srand(time(NULL));
    
    // Initialize the grid
    initialize_grid();
    
    // Add the dots to the grid
    add_dot();
    
    // Play the game
    play_game();
    
    return 0;
}

// Define the function that initializes the grid
void initialize_grid() {
    int i, j;
    
    // Set all the cells to EMPTY
    for(i = 0; i < ROWS; i++) {
        for(j = 0; j < COLS; j++) {
            grid[i][j] = EMPTY;
        }
    }
    
    // Add the walls to the grid
    for(i = 0; i < ROWS; i++) {
        grid[i][0] = WALL;
        grid[i][COLS - 1] = WALL;
    }
    for(j = 0; j < COLS; j++) {
        grid[0][j] = WALL;
        grid[ROWS - 1][j] = WALL;
    }
    
    // Add the Pac-Man and the ghosts to the grid
    pacman_row = get_random(1, ROWS - 2);
    pacman_col = get_random(1, COLS - 2);
    grid[pacman_row][pacman_col] = PACMAN;
    for(i = 0; i < 4; i++) {
        int ghost_row = get_random(1, ROWS - 2);
        int ghost_col = get_random(1, COLS - 2);
        while(grid[ghost_row][ghost_col] != EMPTY) {
            ghost_row = get_random(1, ROWS - 2);
            ghost_col = get_random(1, COLS - 2);
        }
        grid[ghost_row][ghost_col] = GHOST;
    }
    
    // Initialize the score
    score = 0;
}

// Define the function that prints the grid
void print_grid() {
    int i, j;
    
    // Clear the console
    system("clear");
    
    // Print the grid
    for(i = 0; i < ROWS; i++) {
        printf("|");
        for(j = 0; j < COLS; j++) {
            printf("%c", grid[i][j]);
        }
        printf("|\n");
    }
    
    // Print the score
    printf("Score: %d\n", score);
}

// Define the function that generates a random number between min and max (inclusive)
int get_random(int min, int max) {
    return min + rand() % (max - min + 1);
}

// Define the function that moves the ghosts
int move_ghosts() {
    int i, j;
    
    for(i = 1; i < ROWS - 1; i++) {
        for(j = 1; j < COLS - 1; j++) {
            if(grid[i][j] == GHOST) {
                int d_row = get_random(-1, 1);
                int d_col = get_random(-1, 1);
                while(d_row == 0 && d_col == 0) {
                    d_row = get_random(-1, 1);
                    d_col = get_random(-1, 1);
                }
                if(grid[i + d_row][j + d_col] == EMPTY) {
                    grid[i][j] = EMPTY;
                    grid[i + d_row][j + d_col] = GHOST;
                }
                else if(grid[i + d_row][j + d_col] == PACMAN) {
                    grid[i][j] = EMPTY;
                    return -1;
                }
            }
        }
    }
    
    return 0;
}

// Define the function that moves the Pac-Man in the direction given by d_row and d_col
int move_pacman(int d_row, int d_col) {
    if(grid[pacman_row + d_row][pacman_col + d_col] == EMPTY) {
        grid[pacman_row][pacman_col] = EMPTY;
        pacman_row += d_row;
        pacman_col += d_col;
        grid[pacman_row][pacman_col] = PACMAN;
        return 0;
    }
    else if(grid[pacman_row + d_row][pacman_col + d_col] == DOT) {
        grid[pacman_row][pacman_col] = EMPTY;
        pacman_row += d_row;
        pacman_col += d_col;
        grid[pacman_row][pacman_col] = PACMAN;
        score++;
        return 1;
    }
    else if(grid[pacman_row + d_row][pacman_col + d_col] == GHOST) {
        return -1;
    }
    else {
        return 0;
    }
}

// Define the function that adds the dots to the grid
void add_dot() {
    int i, j;
    
    for(i = 1; i < ROWS - 1; i++) {
        for(j = 1; j < COLS - 1; j++) {
            if(grid[i][j] == EMPTY && get_random(0, 1) == 1) {
                grid[i][j] = DOT;
            }
        }
    }
}

// Define the function that plays the game
void play_game() {
    int d_row = 0, d_col = 0;
    
    // Print the initial state of the grid
    print_grid();
    
    // Loop until the game is over
    while(1) {
        // Wait for input
        switch(getchar()) {
            case 'w':
                d_row = -1;
                d_col = 0;
                break;
            case 'a':
                d_row = 0;
                d_col = -1;
                break;
            case 's':
                d_row = 1;
                d_col = 0;
                break;
            case 'd':
                d_row = 0;
                d_col = 1;
                break;
            default:
                d_row = 0;
                d_col = 0;
                break;
        }
        
        // Move the Pac-Man
        int result = move_pacman(d_row, d_col);
        if(result == -1) {
            printf("Game over! You were caught!\n");
            break;
        }
        
        // Move the ghosts
        result = move_ghosts();
        if(result == -1) {
            printf("Game over! You caught all the ghosts!\n");
            break;
        }
        
        // Add new dots to the grid
        add_dot();
        
        // Print the current state of the grid
        print_grid();
        
        // Wait for a short time
        usleep(SPEED * 1000);
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 initialize_grid(void); // weak
__int64 add_dot(void); // weak
__int64 play_game(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  initialize_grid();
  add_dot();
  play_game();
  return 0;
}
// 1400015E8: using guessed type __int64 initialize_grid(void);
// 140001CB2: using guessed type __int64 add_dot(void);
// 140001D5D: using guessed type __int64 play_game(void);
// 140001F10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=151 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Classification system ; Style: romantic
#include <stdio.h>
#include <stdlib.h>

int main() {

    printf("My Love, let me show you how much you mean to me.\n");
    printf("I have created a special image classification system just for you.\n");
    printf("It will help us identify the most beautiful images of us together.\n");
    
    // Load the image classification model
    printf("Loading the model...\n");
    // TODO: Code to load the model
    
    // Load the images to classify
    printf("Loading the images to classify...\n");
    // TODO: Code to load the images
    
    // Classify the images
    printf("Classifying the images...\n");
    // TODO: Code to classify the images
    
    // Display the most beautiful image
    printf("The most beautiful image of us together is:\n");
    // TODO: Code to display the most beautiful image

    printf("My Love, I hope you like the system that I have created for us.\n");
    printf("For me, the most beautiful image is the one of us holding hands,\n");
    printf("walking towards the sunset, with a heart full of love and happiness.\n");
    printf("I want to be with you forever.\n");
    printf("I love you more than anything else in the world.\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("My Love, let me show you how much you mean to me.\n");
  printf("I have created a special image classification system just for you.\n");
  printf("It will help us identify the most beautiful images of us together.\n");
  printf("Loading the model...\n");
  printf("Loading the images to classify...\n");
  printf("Classifying the images...\n");
  printf("The most beautiful image of us together is:\n");
  printf("My Love, I hope you like the system that I have created for us.\n");
  printf("For me, the most beautiful image is the one of us holding hands,\n");
  printf("walking towards the sunset, with a heart full of love and happiness.\n");
  printf("I want to be with you forever.\n");
  printf("I love you more than anything else in the world.\n");
  return 0;
}
// 140001710: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Personal Finance Planner ; Style: happy
#include <stdio.h>

int main(void) {
  int option;
  float balance = 0.00;
  printf("Welcome to Happy Personal Finance Planner!\n");

  while (1) {
    printf("\nWhat would you like to do today?\n");
    printf("1. View current balance\n");
    printf("2. Add income\n");
    printf("3. Add expense\n");
    printf("4. Exit\n");
    scanf("%d", &option);

    switch(option) {
      case 1:
        printf("\nYour current balance is: $%.2f\n", balance);
        break;
      case 2:
        float income;
        printf("\nEnter income amount: $");
        scanf("%f", &income);
        balance += income;
        printf("Income added successfully!\n");
        break;
      case 3:
        float expense;
        printf("\nEnter expense amount: $");
        scanf("%f", &expense);
        if (balance < expense) {
          printf("You don't have enough balance to add this expense. Please try a smaller amount.\n");
        } else {
          balance -= expense;
          printf("Expense added successfully!\n");
        }
        break;
      case 4:
        printf("\nThank you for using Happy Personal Finance Planner! Have a great day!\n");
        return 0;
      default:
        printf("\nInvalid option selected. Please try again.\n");
        break;
    }
  }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+20h] [rbp-10h] BYREF
  float v5; // [rsp+24h] [rbp-Ch] BYREF
  int v6; // [rsp+28h] [rbp-8h] BYREF
  float v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 0.0;
  printf("Welcome to Happy Personal Finance Planner!\n");
  while ( 1 )
  {
    printf("\nWhat would you like to do today?\n");
    printf("1. View current balance\n");
    printf("2. Add income\n");
    printf("3. Add expense\n");
    printf("4. Exit\n");
    scanf("%d", &v6);
    if ( v6 == 4 )
      break;
    if ( v6 > 4 )
      goto LABEL_14;
    switch ( v6 )
    {
      case 3:
        printf("\nEnter expense amount: $");
        scanf("%f", &v4);
        if ( v4 <= v7 )
        {
          v7 = v7 - v4;
          printf("Expense added successfully!\n");
        }
        else
        {
          printf("You don't have enough balance to add this expense. Please try a smaller amount.\n");
        }
        break;
      case 1:
        printf("\nYour current balance is: $%.2f\n", v7);
        break;
      case 2:
        printf("\nEnter income amount: $");
        scanf("%f", &v5);
        v7 = v5 + v7;
        printf("Income added successfully!\n");
        break;
      default:
LABEL_14:
        printf("\nInvalid option selected. Please try again.\n");
        break;
    }
  }
  printf("\nThank you for using Happy Personal Finance Planner! Have a great day!\n");
  return 0;
}
// 140001689: conditional instruction was optimized away because %var_8.4<3
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database simulation ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NAME_LENGTH 50
#define MAX_NUM_RECORDS 1000

struct Student{
    int roll_no;
    char name[MAX_NAME_LENGTH];
    float cgpa;
};

struct Student students[MAX_NUM_RECORDS];

int total_num_students = 0;

void add_student(){
    if(total_num_students >= MAX_NUM_RECORDS){
        printf("Maximum number of students reached!\n");
        return;
    }
    printf("Enter Roll No: ");
    scanf("%d", &students[total_num_students].roll_no);
    printf("Enter Name: ");
    scanf("%s", students[total_num_students].name);
    printf("Enter CGPA: ");
    scanf("%f", &students[total_num_students].cgpa);
    total_num_students++;
    printf("Student added successfully.\n");
}

void print_student(struct Student s){
    printf("Roll No: %d\n", s.roll_no);
    printf("Name: %s\n", s.name);
    printf("CGPA: %.2f\n", s.cgpa);
}

void print_all_students(){
    if(total_num_students == 0){
        printf("No students added yet!\n");
        return;
    }
    printf("List of all students:\n");
    for(int i=0; i<total_num_students; i++){
        printf("------------------------\n");
        print_student(students[i]);
    }
}

void search_student(){
    if(total_num_students == 0){
        printf("No students added yet!\n");
        return;
    }
    int search_roll_no;
    printf("Enter Roll No to search: ");
    scanf("%d", &search_roll_no);
    int found = 0;
    for(int i=0; i<total_num_students; i++){
        if(students[i].roll_no == search_roll_no){
            printf("Student found!\n");
            printf("------------------------\n");
            print_student(students[i]);
            found = 1;
            break;
        }
    }
    if(!found){
        printf("Student with Roll No %d not found.\n", search_roll_no);
    }
}

void delete_student(){
    if(total_num_students == 0){
        printf("No students added yet!\n");
        return;
    }
    int delete_roll_no;
    printf("Enter Roll No to delete: ");
    scanf("%d", &delete_roll_no);
    int found = 0;
    for(int i=0; i<total_num_students; i++){
        if(students[i].roll_no == delete_roll_no){
            found = 1;
            for(int j=i+1; j<total_num_students; j++){
                students[j-1] = students[j];
            }
            total_num_students--;
            printf("Student with Roll No %d deleted successfully.\n", delete_roll_no);
            break;
        }
    }
    if(!found){
        printf("Student with Roll No %d not found.\n", delete_roll_no);
    }
}

int main(){
    int choice;
    while(1){
        printf("\n");
        printf("1. Add Student\n");
        printf("2. Print All Students\n");
        printf("3. Search Student\n");
        printf("4. Delete Student\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch(choice){
            case 1:
                add_student();
                break;
            case 2:
                print_all_students();
                break;
            case 3:
                search_student();
                break;
            case 4:
                delete_student();
                break;
            case 5:
                exit(0);
                break;
            default:
                printf("Invalid choice. Try again.\n");
                break;
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_student(void); // weak
__int64 print_all_students(void); // weak
__int64 search_student(void); // weak
__int64 delete_student(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001B38) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    printf("\n");
    printf("1. Add Student\n");
    printf("2. Print All Students\n");
    printf("3. Search Student\n");
    printf("4. Delete Student\n");
    printf("5. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        add_student();
        break;
      case 2:
        print_all_students();
        break;
      case 3:
        search_student();
        break;
      case 4:
        delete_student();
        break;
      case 5:
        exit(0);
      default:
        printf("Invalid choice. Try again.\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 add_student(void);
// 14000176D: using guessed type __int64 print_all_students(void);
// 140001849: using guessed type __int64 search_student(void);
// 1400019A1: using guessed type __int64 delete_student(void);
// 140001CE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Spell checking ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50
#define MAX_DICT_WORDS 10000
#define MAX_TEXT_WORDS 1000

// Struct to hold each word in the dictionary
typedef struct {
    char word[MAX_WORD_LENGTH];
} word;

// Function to check if a given word is in the dictionary
bool check_spelling(word* dict, int dict_size, char* word_to_check) {
    // Convert the word to lowercase
    char lowercase_word[MAX_WORD_LENGTH];
    strcpy(lowercase_word, word_to_check);
    for (int i = 0; lowercase_word[i]; i++) {
        lowercase_word[i] = tolower(lowercase_word[i]);
    }
    // Use binary search to find the word in the dictionary
    int left = 0, right = dict_size - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        int cmp = strcmp(lowercase_word, dict[mid].word);
        if (cmp == 0) {
            return true;
        } else if (cmp < 0) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return false;
}

int main() {
    // Load the dictionary into an array
    word* dict = malloc(MAX_DICT_WORDS * sizeof(word));
    if (dict == NULL) {
        printf("Error: malloc failed to allocate memory\n");
        return 1;
    }
    FILE* dict_file = fopen("dictionary.txt", "r");
    if (dict_file == NULL) {
        printf("Error: could not open dictionary file\n");
        free(dict);
        return 1;
    }
    int dict_size = 0;
    char buffer[MAX_WORD_LENGTH];
    while (fgets(buffer, MAX_WORD_LENGTH, dict_file) != NULL && dict_size < MAX_DICT_WORDS) {
        // Remove newline character from the end of the buffer
        buffer[strcspn(buffer, "\n")] = 0;
        strcpy(dict[dict_size].word, buffer);
        dict_size++;
    }
    fclose(dict_file);
    printf("Dictionary loaded successfully with %d words.\n", dict_size);

    // Get text to check spelling on
    char** text = malloc(MAX_TEXT_WORDS * sizeof(char*));
    if (text == NULL) {
        printf("Error: malloc failed to allocate memory\n");
        free(dict);
        return 1;
    }
    printf("Enter text to check spelling on (maximum of %d words):\n", MAX_TEXT_WORDS);
    int text_size = 0;
    while (text_size < MAX_TEXT_WORDS) {
        // Allocate memory for the next word
        char* new_word = malloc(MAX_WORD_LENGTH * sizeof(char));
        if (new_word == NULL) {
            printf("Error: malloc failed to allocate memory\n");
            for (int i = 0; i < text_size; i++) {
                free(text[i]);
            }
            free(text);
            free(dict);
            return 1;
        }
        // Read the next word
        scanf("%s", new_word);
        // Check if the word is in the dictionary
        if (!check_spelling(dict, dict_size, new_word)) {
            printf("Misspelled word: %s\n", new_word);
        }
        // Add the word to the text array
        text[text_size] = new_word;
        text_size++;
    }

    // Free memory and exit
    for (int i = 0; i < text_size; i++) {
        free(text[i]);
    }
    free(text);
    free(dict);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall check_spelling(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl strcpy(char *Destination, const char *Source);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400016DD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[64]; // [rsp+20h] [rbp-70h] BYREF
  const char *v5; // [rsp+60h] [rbp-30h]
  void *v6; // [rsp+68h] [rbp-28h]
  FILE *Stream; // [rsp+70h] [rbp-20h]
  void *Block; // [rsp+78h] [rbp-18h]
  int k; // [rsp+80h] [rbp-10h]
  int m; // [rsp+84h] [rbp-Ch]
  int j; // [rsp+88h] [rbp-8h]
  unsigned int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  Block = malloc(0x7A120ui64);
  if ( Block )
  {
    Stream = fopen("dictionary.txt", "r");
    if ( Stream )
    {
      for ( i = 0; fgets(Str, 50, Stream) && (int)i <= 9999; ++i )
      {
        Str[strcspn(Str, "\n")] = 0;
        strcpy((char *)Block + 50 * (int)i, Str);
      }
      fclose(Stream);
      printf("Dictionary loaded successfully with %d words.\n", i);
      v6 = malloc(0x1F40ui64);
      if ( v6 )
      {
        printf("Enter text to check spelling on (maximum of %d words):\n", 1000i64);
        for ( j = 0; ; ++j )
        {
          if ( j > 999 )
          {
            for ( k = 0; k < j; ++k )
              free(*((void **)v6 + k));
            free(v6);
            free(Block);
            return 0;
          }
          v5 = (const char *)malloc(0x32ui64);
          if ( !v5 )
            break;
          scanf("%s", v5);
          if ( (unsigned __int8)check_spelling(Block, i, v5) != 1 )
            printf("Misspelled word: %s\n", v5);
          *((_QWORD *)v6 + j) = v5;
        }
        printf("Error: malloc failed to allocate memory\n");
        for ( m = 0; m < j; ++m )
          free(*((void **)v6 + m));
        free(v6);
        free(Block);
        return 1;
      }
      else
      {
        printf("Error: malloc failed to allocate memory\n");
        free(Block);
        return 1;
      }
    }
    else
    {
      printf("Error: could not open dictionary file\n");
      free(Block);
      return 1;
    }
  }
  else
  {
    printf("Error: malloc failed to allocate memory\n");
    return 1;
  }
}
// 1400015E2: using guessed type __int64 __fastcall check_spelling(_QWORD, _QWORD, _QWORD);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016DD: using guessed type char Str[64];

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Appointment Scheduler ; Style: multivariable
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define MAX_LENGTH 256

struct patient {
    char name[MAX_LENGTH];
    int age;
    char gender[MAX_LENGTH];
    char contact[MAX_LENGTH];
    char email[MAX_LENGTH];
    char appointmentDate[MAX_LENGTH];
    char doctor[MAX_LENGTH];
    struct patient *next;
};

struct patient *start = NULL;

void createPatientRecord() {
    struct patient *newPatient = (struct patient*)malloc(sizeof(struct patient));
    printf("\nEnter the patient's name: ");
    scanf("%[^\n]%*c", newPatient->name);
    printf("Enter the patient's age: ");
    scanf("%d", &newPatient->age);
    printf("Enter the patient's gender: ");
    scanf("%s", newPatient->gender);
    printf("Enter the patient's contact number: ");
    scanf("%s", newPatient->contact);
    printf("Enter the patient's email address: ");
    scanf("%s", newPatient->email);
    printf("Enter the appointment date (YYYY-MM-DD): ");
    scanf("%s", newPatient->appointmentDate);
    printf("Enter the doctor's name: ");
    scanf("%s", newPatient->doctor);
    newPatient->next = NULL;

    if(start == NULL) {
        start = newPatient;
    } else {
        struct patient *temp = start;
        while(temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = newPatient;
    }
}

void printPatientRecord(struct patient *patientData) {
    printf("\nName: %s\nAge: %d\nGender: %s\nContact: %s\nEmail: %s\nAppointment date: %s\nDoctor: %s", patientData->name, patientData->age, patientData->gender, patientData->contact, patientData->email, patientData->appointmentDate, patientData->doctor);
}

void viewPatientRecord() {
    struct patient *temp = start;
    if(temp == NULL) {
        printf("\nNo patient records found!");
    } else {
        while(temp != NULL) {
            printPatientRecord(temp);
            temp = temp->next;
            printf("\n----------------------------\n");
        }
    }
}

void searchPatientRecord() {
    char name[MAX_LENGTH];
    printf("\nEnter the patient's name to search: ");
    scanf("%[^\n]%*c", name);
    struct patient *temp = start;
    int found = 0;
    while(temp != NULL) {
        if(strcmp(temp->name, name) == 0) {
            found = 1;
            printf("\nSearch result for %s:\n\n", name);
            printPatientRecord(temp);
            break;
        }
        temp = temp->next;
    }
    if(!found) {
        printf("\nNo records found for %s\n", name);
    }
}

void deletePatientRecord() {
    char name[MAX_LENGTH];
    printf("\nEnter the patient's name to delete: ");
    scanf("%[^\n]%*c", name);
    struct patient *temp = start, *prev;
    int found = 0;
    if(temp != NULL && strcmp(temp->name, name) == 0) {
        start = temp->next;
        free(temp);
        found = 1;
    } else {
        while(temp != NULL) {
            if(strcmp(temp->name, name) == 0) {
                found = 1;
                prev->next = temp->next;
                free(temp);
                break;
            }
            prev = temp;
            temp = temp->next;
        }
    }
    if(found) {
        printf("\nRecord for %s deleted successfully!\n", name);
    } else {
        printf("\nNo records found for %s\n", name);
    }
}

int menu() {
    int choice;
    printf("\n\n****Appointment Scheduler****\n");
    printf("\n\n1. Create new patient record");
    printf("\n2. View all patient records");
    printf("\n3. Search for a patient record");
    printf("\n4. Delete a patient record");
    printf("\n5. Exit");
    printf("\n\nEnter your choice: ");
    scanf("%d", &choice);
    return choice;
}

int main() {
    while(1) {
        int choice = menu();
        switch (choice) {
            case 1:
                createPatientRecord();
                break;
            case 2:
                viewPatientRecord();
                break;
            case 3:
                searchPatientRecord();
                break;
            case 4:
                deletePatientRecord();
                break;
            case 5:
                printf("\nExiting...");
                exit(0);
            default:
                printf("\nInvalid choice!");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 createPatientRecord(void); // weak
__int64 viewPatientRecord(void); // weak
__int64 searchPatientRecord(void); // weak
__int64 deletePatientRecord(void); // weak
__int64 menu(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001B42) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  while ( 1 )
  {
    switch ( (unsigned int)menu() )
    {
      case 1u:
        createPatientRecord();
        break;
      case 2u:
        viewPatientRecord();
        break;
      case 3u:
        searchPatientRecord();
        break;
      case 4u:
        deletePatientRecord();
        break;
      case 5u:
        printf("\nExiting...");
        exit(0);
      default:
        printf("\nInvalid choice!");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 createPatientRecord(void);
// 14000180E: using guessed type __int64 viewPatientRecord(void);
// 140001871: using guessed type __int64 searchPatientRecord(void);
// 140001950: using guessed type __int64 deletePatientRecord(void);
// 140001AB2: using guessed type __int64 menu(void);
// 140001C80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Spell checking ; Style: optimized
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAX_WORD_LEN 100
#define MAX_MISTAKES 5

int num_mistakes = 0; // global variable to keep track of number of mistakes

void check_spelling(char* word) {
    // remove punctuation marks at the end of the word
    int len = strlen(word);
    while (len > 0 && ispunct(word[len-1])) {
        word[len-1] = '\0';
        len--;
    }

    // check the word against a dictionary
    int found = 0;
    FILE *fp = fopen("dictionary.txt", "r");
    char dict_word[MAX_WORD_LEN];
    while (fgets(dict_word, MAX_WORD_LEN, fp)) {
        dict_word[strcspn(dict_word, "\n")] = '\0'; // remove newline character
        if (strcasecmp(word, dict_word) == 0) { // case-insensitive string comparison
            found = 1;
            break;
        }
    }
    fclose(fp);

    if (!found) {
        num_mistakes++;
        if (num_mistakes <= MAX_MISTAKES) {
            printf("Did you mean: %s?\n", dict_word); // suggest a correction
        }
    }
}

int main() {
    char sentence[MAX_WORD_LEN*10];
    printf("Enter a sentence: ");
    fgets(sentence, MAX_WORD_LEN*10, stdin);

    char *token = strtok(sentence, " ");
    while (token != NULL) {
        check_spelling(token);
        token = strtok(NULL, " ");
    }

    if (num_mistakes == 0) {
        printf("No spelling mistakes found.\n");
    } else if (num_mistakes == 1) {
        printf("1 spelling mistake found.\n");
    } else {
        printf("%d spelling mistakes found.\n", num_mistakes);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall check_spelling(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

int num_mistakes; // weak


//----- (00000001400016B8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1000]; // [rsp+20h] [rbp-60h] BYREF
  char *i; // [rsp+408h] [rbp+388h]

  _main(argc, argv, envp);
  printf("Enter a sentence: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  for ( i = strtok(Buffer, " "); i; i = strtok(0i64, " ") )
    check_spelling(i);
  if ( num_mistakes )
  {
    if ( num_mistakes == 1 )
      printf("1 spelling mistake found.\n");
    else
      printf("%d spelling mistakes found.\n", (unsigned int)num_mistakes);
  }
  else
  {
    printf("No spelling mistakes found.\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall check_spelling(_QWORD);
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type int num_mistakes;

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Encryption ; Style: synchronous
#include <stdio.h>
#include <string.h>

// function to encrypt the message
void encrypt(char *message, int key) {
    int i = 0;
    // loop through each character of the message
    while (message[i] != '\0') {
        // add the key to the ASCII value of the character
        message[i] += key;
        i++;
    }
}

// function to decrypt the message
void decrypt(char *message, int key) {
    int i = 0;
    // loop through each character of the message
    while (message[i] != '\0') {
        // subtract the key from the ASCII value of the character
        message[i] -= key;
        i++;
    }
}

int main() {
    char message[100];
    int key;

    // get the message and key from the user
    printf("Enter the message to encrypt: ");
    fgets(message, 100, stdin);
    printf("Enter the encryption key: ");
    scanf("%d", &key);

    // encrypt the message
    encrypt(message, key);
    printf("Encrypted message: %s", message);

    // decrypt the message
    decrypt(message, key);
    printf("Decrypted message: %s", message);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
__int64 __fastcall decrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016A5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v5; // [rsp+2Ch] [rbp-74h] BYREF
  char Buffer[112]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter the message to encrypt: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  printf("Enter the encryption key: ");
  scanf("%d", &v5);
  encrypt(Buffer, v5);
  printf("Encrypted message: %s", Buffer);
  decrypt(Buffer, v5);
  printf("Decrypted message: %s", Buffer);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 140001643: using guessed type __int64 __fastcall decrypt(_QWORD, _QWORD);
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedural Space Adventure ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Function prototypes
void clearScreen();
void displayIntro();
void generatePlanets(char *planetNames[], int numPlanets);
int launchGame(int numPlanets, char *planetNames[]);
void planetMenu(char *planetName);
void explorePlanet(char *planetName);
void minePlanet(char *planetName);

int main() {
    // Seed random number generator for use later
    srand(time(NULL)); 

    char *planetNames[] = {
        "Arcturus",
        "Betelgeuse",
        "Ceti Alpha V",
        "Dagobah",
        "Ego",
        "Fhloston",
        "Gotham",
        "Hoth",
        "Icarus",
        "Jupiter",
        "Krypton",
        "Luna",
        "Mars",
        "Neptune",
        "Orion",
        "Pandora",
        "Quasar",
        "Rigel",
        "Serenity",
        "Tatooine",
        "Uranus",
        "Vulcan",
        "Wadiya",
        "Xandar",
        "Yavin IV",
        "Zephyr"
    };
    int numPlanets = sizeof(planetNames) / sizeof(char *);

    clearScreen();
    displayIntro();

    int playAgain = 1;
    while (playAgain) {
        generatePlanets(planetNames, numPlanets);
        int choice = launchGame(numPlanets, planetNames);

        if (choice == 1) {
            playAgain = 1;
            clearScreen();
        } else {
            playAgain = 0;
            printf("\nThank you for playing!\n");
        }
    }
    return 0;
}

// Function to clear the screen and reset the cursor position
void clearScreen() {
    printf("\033[2J\033[1;1H");
}

// Function to display the game intro
void displayIntro() {
    printf("Welcome to Procedural Space Adventure!\n\n");
    printf("Space adventure is the ultimate adventure game where you travel across the galaxy\n");
    printf("to explore strange new worlds, to seek out new life and new civilizations,\n");
    printf("to boldly go where no one has gone before. Good luck and have fun!\n\n");
    printf("Press enter to begin.\n");
    getchar();
    clearScreen();
}

// Function to randomly shuffle the array of planet names
void generatePlanets(char *planetNames[], int numPlanets) {
    for (int i = 0; i < numPlanets; i++) {
        int randomIndex = rand() % numPlanets;
        char *temp = planetNames[i];
        planetNames[i] = planetNames[randomIndex];
        planetNames[randomIndex] = temp;
    }
}

// Function to launch the game and select a planet to visit
int launchGame(int numPlanets, char *planetNames[]) {
    printf("Here are the planets available to visit:\n\n");
    for (int i = 0; i < numPlanets; i++) {
        printf("%d. %s\n", i+1, planetNames[i]);
    }
    printf("%d. Exit game\n", numPlanets+1);

    int choice = 0;
    int maxChoice = numPlanets + 1;
    while (choice < 1 || choice > maxChoice) {
        printf("\nEnter the number of the planet you would like to visit (1-%d): ", maxChoice);
        scanf("%d", &choice);
        if (choice < 1 || choice > maxChoice) {
            printf("Invalid choice.\n");
        }
    }

    if (choice == maxChoice) {
        return 2;
    } else {
        clearScreen();
        planetMenu(planetNames[choice-1]);
        return 1;
    }
}

// Function to display the planet menu
void planetMenu(char *planetName) {
    printf("Welcome to %s!\n", planetName);
    printf("What would you like to do?\n");
    printf("1. Explore the planet\n");
    printf("2. Mine resources\n");
    printf("3. Return to planet selection\n");

    int choice = 0;
    while (choice < 1 || choice > 3) {
        printf("\nEnter the number of your choice (1-3): ");
        scanf("%d", &choice);
        if (choice < 1 || choice > 3) {
            printf("Invalid choice.\n");
        }
    }

    switch(choice) {
        case 1:
            explorePlanet(planetName);
            break;
        case 2:
            minePlanet(planetName);
            break;
        case 3:
            clearScreen();
            break;
    }
}

// Function to explore the planet
void explorePlanet(char *planetName) {
    printf("You explore %s and discover many strange and wonderful things.\n", planetName);
    printf("Unfortunately, you got lost and couldn't find your way back to your ship.\n");
    printf("You died. Game over. Try again?\n");

    printf("\nPress enter to continue.\n");
    getchar();
}

// Function to mine the planet for resources
void minePlanet(char *planetName) {
    printf("You mine %s for resources and find an abundance of valuable materials.\n", planetName);
    printf("You get rich and retire to a life of luxury. Congratulations, you win!\n");

    printf("\nPress enter to continue.\n");
    getchar();
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall clearScreen(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 displayIntro(void); // weak
__int64 __fastcall generatePlanets(_QWORD, _QWORD); // weak
__int64 __fastcall launchGame(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v13[26]; // [rsp+20h] [rbp-60h] BYREF
  int v14; // [rsp+F4h] [rbp+74h]
  unsigned int v15; // [rsp+F8h] [rbp+78h]
  int v16; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v13[22] = (__int64)"Wadiya";
  v13[23] = (__int64)"Xandar";
  v13[24] = (__int64)"Yavin IV";
  v13[25] = (__int64)"Zephyr";
  v15 = 26;
  clearScreen(
    v5,
    v4,
    v6,
    v7,
    "Arcturus",
    "Betelgeuse",
    "Ceti Alpha V",
    "Dagobah",
    "Ego",
    "Fhloston",
    "Gotham",
    "Hoth",
    "Icarus",
    "Jupiter",
    "Krypton",
    "Luna",
    "Mars",
    "Neptune",
    "Orion",
    "Pandora",
    "Quasar",
    "Rigel",
    "Serenity",
    "Tatooine",
    "Uranus",
    "Vulcan");
  displayIntro();
  v16 = 1;
  while ( v16 )
  {
    generatePlanets(v13, v15);
    v14 = launchGame(v15, v13);
    if ( v14 == 1 )
    {
      v16 = 1;
      clearScreen(
        v9,
        v8,
        v10,
        v11,
        v13[0],
        v13[1],
        v13[2],
        v13[3],
        v13[4],
        v13[5],
        v13[6],
        v13[7],
        v13[8],
        v13[9],
        v13[10],
        v13[11],
        v13[12],
        v13[13],
        v13[14],
        v13[15],
        v13[16],
        v13[17],
        v13[18],
        v13[19],
        v13[20],
        v13[21]);
    }
    else
    {
      v16 = 0;
      printf("\nThank you for playing!\n");
    }
  }
  return 0;
}
// 14000174C: variable 'v5' is possibly undefined
// 14000174C: variable 'v4' is possibly undefined
// 14000174C: variable 'v6' is possibly undefined
// 14000174C: variable 'v7' is possibly undefined
// 14000178C: variable 'v9' is possibly undefined
// 14000178C: variable 'v8' is possibly undefined
// 14000178C: variable 'v10' is possibly undefined
// 14000178C: variable 'v11' is possibly undefined
// 1400017BD: using guessed type __int64 __fastcall clearScreen(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400017DB: using guessed type __int64 displayIntro(void);
// 14000183F: using guessed type __int64 __fastcall generatePlanets(_QWORD, _QWORD);
// 1400018DC: using guessed type __int64 __fastcall launchGame(_QWORD, _QWORD);
// 140001C50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Binary search trees ; Style: futuristic
#include<stdio.h> 
  
struct node 
{ 
    int data; 
    struct node *left; 
    struct node *right; 
}; 
  
struct node* newNode(int item) 
{ 
    struct node* temp =  (struct node*)malloc(sizeof(struct node)); 
    temp->data = item; 
    temp->left = temp->right = NULL; 
    return temp; 
} 
  
void inorder(struct node* root) 
{ 
    if (root != NULL) 
    { 
        inorder(root->left); 
        printf("%d ", root->data); 
        inorder(root->right); 
    } 
} 
 
struct node* insert(struct node* node, int key) 
{ 
    if (node == NULL) return newNode(key); 
    if (key < node->data) 
        node->left  = insert(node->left, key); 
    else if (key > node->data) 
        node->right = insert(node->right, key);    
    return node; 
} 

struct node* search(struct node* root, int key) 
{  
    if (root == NULL || root->data == key) 
       return root; 
     
    if (root->data < key) 
       return search(root->right, key); 
  
    return search(root->left, key); 
}

int main() 
{ 
    struct node *root = NULL; 
    root = insert(root, 50); 
    insert(root, 30); 
    insert(root, 20); 
    insert(root, 40); 
    insert(root, 70); 
    insert(root, 60); 
    insert(root, 80); 
    int n=70; 
    struct node *search_result = search(root,n); 
    if (search_result == NULL) 
      printf("Key Not Found"); 
    else
      printf("Key Found"); 
    
    return 0; 
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall insert(_QWORD, _QWORD); // weak
__int64 __fastcall search(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001704) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  v4 = insert(0i64, 50i64);
  insert(v4, 30i64);
  insert(v4, 20i64);
  insert(v4, 40i64);
  insert(v4, 70i64);
  insert(v4, 60i64);
  insert(v4, 80i64);
  if ( search(v4, 70i64) )
    printf("Key Found");
  else
    printf("Key Not Found");
  return 0;
}
// 14000162A: using guessed type __int64 __fastcall insert(_QWORD, _QWORD);
// 1400016A4: using guessed type __int64 __fastcall search(_QWORD, _QWORD);
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  char questions[16][80] = { /* Array of possible questions */
    "What is my future?",
    "Will I become wealthy?",
    "Am I going to find love?",
    "Will I be successful?",
    "What can I expect from my career?",
    "Should I take that new job?",
    "Should I invest in the stock market?",
    "Will I win the lottery?",
    "Should I move to a new city?",
    "Will my health improve?",
    "Is it a good time to start a family?",
    "Will my dreams come true?",
    "Should I pursue further education?",
    "Should I travel this year?",
    "What can I do to improve my life?",
    "Is there anything I should be cautious of?"
  };

  char answers[8][80] = { /* Array of possible answers */
    "It is certain.",
    "It is decidedly so.",
    "Without a doubt.",
    "Yes, definitely.",
    "You may rely on it.",
    "As I see it, yes.",
    "Most likely.",
    "Outlook good."
  };

  char warnings[4][80] = { /* Array of warning messages */
    "Reply hazy, try again.",
    "Better not tell you now.",
    "Cannot predict now.",
    "Concentrate and ask again."
  };

  char negative[4][80] = { /* Array of negative responses */
    "Don't count on it.",
    "Outlook not so good.",
    "My sources say no.",
    "Very doubtful."
  };

  int random_number;
  char question[80];

  srand(time(NULL)); /* Seed the random number generator */

  printf("Welcome to the Automated Fortune Teller!\n\n");
  printf("Type your yes or no question and press enter:\n");
  fgets(question, 80, stdin);

  printf("\nThe answer to your question \"%s\" is...\n", question);

  random_number = rand() % 20; /* Generate random number between 0-19 */

  if (random_number < 8) { /* If random number is between 0-7, give positive response */
    printf("%s\n", answers[random_number % 8]);
  }
  else if (random_number < 12) { /* If random number is between 8-11, give warning */
    printf("%s\n", warnings[random_number % 4]);
  }
  else { /* If random number is between 12-19, give negative response */
    printf("%s\n", negative[random_number % 4]);
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

char aWhatIsMyFuture[19] = "What is my future?"; // weak
char aItIsCertain[15] = "It is certain."; // weak
char aReplyHazyTryAg[23] = "Reply hazy, try again."; // weak
char aDonTCountOnIt[19] = "Don't count on it."; // weak


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  FILE *v4; // rax
  char Buffer[80]; // [rsp+20h] [rbp-60h] BYREF
  char v7[320]; // [rsp+70h] [rbp-10h] BYREF
  char v8[320]; // [rsp+1B0h] [rbp+130h] BYREF
  char v9[640]; // [rsp+2F0h] [rbp+270h] BYREF
  char v10[1280]; // [rsp+570h] [rbp+4F0h] BYREF
  int v11; // [rsp+A7Ch] [rbp+9FCh]

  _main(argc, argv, envp);
  qmemcpy(v10, aWhatIsMyFuture, sizeof(v10));
  qmemcpy(v9, aItIsCertain, sizeof(v9));
  qmemcpy(v8, aReplyHazyTryAg, sizeof(v8));
  qmemcpy(v7, aDonTCountOnIt, sizeof(v7));
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Automated Fortune Teller!\n\n");
  printf("Type your yes or no question and press enter:\n");
  v4 = __acrt_iob_func(0);
  fgets(Buffer, 80, v4);
  printf("\nThe answer to your question \"%s\" is...\n", Buffer);
  v11 = rand() % 20;
  if ( v11 > 7 )
  {
    if ( v11 > 11 )
      printf("%s\n", &v7[80 * (v11 % 4)]);
    else
      printf("%s\n", &v8[80 * (v11 % 4)]);
  }
  else
  {
    printf("%s\n", &v9[80 * (v11 % 8)]);
  }
  return 0;
}
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type char var_7A0[640];
// 1400015B0: using guessed type char var_8E0[320];
// 1400015B0: using guessed type char var_A20[320];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cryptography Implementation ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LENGTH 1024
#define MAX_KEY_LENGTH 16

void xor_encrypt(char* message, char* key) {
    int message_length = strlen(message);
    int key_length = strlen(key);
    int i;
    for(i = 0; i < message_length; i++) {
        message[i] ^= key[i % key_length];
    }
}

int main() {
    char message[MAX_LENGTH];
    char key[MAX_KEY_LENGTH];
    printf("Enter the message to be encrypted: ");
    fgets(message, MAX_LENGTH, stdin);
    printf("Enter the encryption key: ");
    fgets(key, MAX_KEY_LENGTH, stdin);
    xor_encrypt(message, key);
    printf("The encrypted message is: %s\n", message);
    xor_encrypt(message, key);
    printf("The decrypted message is: %s\n", message);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall xor_encrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001610) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char v6[16]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[1024]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  printf("Enter the message to be encrypted: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1024, v3);
  printf("Enter the encryption key: ");
  v4 = __acrt_iob_func(0);
  fgets(v6, 16, v4);
  xor_encrypt(Buffer, v6);
  printf("The encrypted message is: %s\n", Buffer);
  xor_encrypt(Buffer, v6);
  printf("The decrypted message is: %s\n", Buffer);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall xor_encrypt(_QWORD, _QWORD);
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bitwise operations ; Style: excited
#include<stdio.h>
int main()
{
    printf("****************** Bitwise Operation **********************\n");
    printf("Are you ready to see some magic? Let's manipulate bits using bitwise operators\n");
    printf("Enter two numbers to perform bitwise operations on them\n");

    int num1, num2;
    scanf("%d %d", &num1, &num2);

    int result;
    printf("\nResult of Bitwise AND operation: %d & %d = %d\n", num1, num2, num1 & num2);
    printf("Result of Bitwise OR operation: %d | %d = %d\n", num1, num2, num1 | num2);
    printf("Result of Bitwise XOR operation: %d ^ %d = %d\n", num1, num2, num1 ^ num2);
    printf("Result of Left Shift operation: %d << 1 = %d\n", num1, num1 << 1);
    printf("Result of Right Shift operation: %d >> 1 = %d\n", num1, num1 >> 1);

    printf("\nNow let's swap the numbers using bitwise operators\n");

    num1 = num1 ^ num2;
    num2 = num1 ^ num2;
    num1 = num1 ^ num2;

    printf("After swapping, num1 = %d and num2 = %d\n", num1, num2);

    printf("\nWasn't that amazing? We just manipulated bits using bitwise operators to perform some cool operations\n");
    printf("Stay tuned for more mind-boggling programming concepts! Bye for now!\n");

    return 0; 
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-8h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("****************** Bitwise Operation **********************\n");
  printf("Are you ready to see some magic? Let's manipulate bits using bitwise operators\n");
  printf("Enter two numbers to perform bitwise operations on them\n");
  scanf("%d %d", &v5, &v4);
  printf("\nResult of Bitwise AND operation: %d & %d = %d\n", v5, v4, v4 & v5);
  printf("Result of Bitwise OR operation: %d | %d = %d\n", v5, v4, v4 | v5);
  printf("Result of Bitwise XOR operation: %d ^ %d = %d\n", v5, v4, v4 ^ v5);
  printf("Result of Left Shift operation: %d << 1 = %d\n", v5, 2 * v5);
  printf("Result of Right Shift operation: %d >> 1 = %d\n", v5, (unsigned int)((int)v5 >> 1));
  printf("\nNow let's swap the numbers using bitwise operators\n");
  v5 ^= v4;
  v4 ^= v5;
  v5 ^= v4;
  printf("After swapping, num1 = %d and num2 = %d\n", v5, v4);
  printf("\nWasn't that amazing? We just manipulated bits using bitwise operators to perform some cool operations\n");
  printf("Stay tuned for more mind-boggling programming concepts! Bye for now!\n");
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Calculator ; Style: surprised
#include <stdio.h>

int main() {
  printf("Hello there, I am a calculator program!\n");
  printf("What would you like to do?\n");
  printf("1. Add two numbers\n");
  printf("2. Subtract two numbers\n");
  printf("3. Multiply two numbers\n");
  printf("4. Divide two numbers\n");
  int choice;
  scanf("%d", &choice); 
  
  if (choice == 1) {
    printf("You chose to add two numbers!\n");
    printf("Please enter the first number: ");
    double num1;
    scanf("%lf", &num1);
    printf("Please enter the second number: ");
    double num2;
    scanf("%lf", &num2);
    double result = num1 + num2;
    printf("The result of %lf + %lf is: %lf\n", num1, num2, result);
  }
  else if (choice == 2) {
    printf("You chose to subtract two numbers!\n");
    printf("Please enter the first number: ");
    double num1;
    scanf("%lf", &num1);
    printf("Please enter the second number: ");
    double num2;
    scanf("%lf", &num2);
    double result = num1 - num2;
    printf("The result of %lf - %lf is: %lf\n", num1, num2, result);
  }
  else if (choice == 3) {
    printf("You chose to multiply two numbers!\n");
    printf("Please enter the first number: ");
    double num1;
    scanf("%lf", &num1);
    printf("Please enter the second number: ");
    double num2;
    scanf("%lf", &num2);
    double result = num1 * num2;
    printf("The result of %lf * %lf is: %lf\n", num1, num2, result);
  }
  else if (choice == 4) {
    printf("You chose to divide two numbers!!\n");
    printf("Please enter the first number: ");
    double num1;
    scanf("%lf", &num1);
    printf("Please enter the second number: ");
    double num2;
    scanf("%lf", &num2);
    while(num2 == 0) {
      printf("Division by zero is not allowed. Please enter another number: ");
      scanf("%lf", &num2);
    }
    double result = num1 / num2;
    printf("The result of %lf / %lf is: %lf\n", num1, num2, result);
  }
  else {
    printf("Invalid choice. Please try again.\n");
  }
  printf("Thanks for using me!");
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+28h] [rbp-68h] BYREF
  double v5; // [rsp+30h] [rbp-60h] BYREF
  double v6; // [rsp+38h] [rbp-58h] BYREF
  double v7; // [rsp+40h] [rbp-50h] BYREF
  double v8; // [rsp+48h] [rbp-48h] BYREF
  double v9; // [rsp+50h] [rbp-40h] BYREF
  double v10; // [rsp+58h] [rbp-38h] BYREF
  double v11; // [rsp+60h] [rbp-30h] BYREF
  int v12; // [rsp+6Ch] [rbp-24h] BYREF
  double v13; // [rsp+70h] [rbp-20h]
  double v14; // [rsp+78h] [rbp-18h]
  double v15; // [rsp+80h] [rbp-10h]
  double v16; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Hello there, I am a calculator program!\n");
  printf("What would you like to do?\n");
  printf("1. Add two numbers\n");
  printf("2. Subtract two numbers\n");
  printf("3. Multiply two numbers\n");
  printf("4. Divide two numbers\n");
  scanf("%d", &v12);
  switch ( v12 )
  {
    case 1:
      printf("You chose to add two numbers!\n");
      printf("Please enter the first number: ");
      scanf("%lf", &v11);
      printf("Please enter the second number: ");
      scanf("%lf", &v10);
      v13 = v10 + v11;
      printf("The result of %lf + %lf is: %lf\n", v11, v10, v10 + v11);
      break;
    case 2:
      printf("You chose to subtract two numbers!\n");
      printf("Please enter the first number: ");
      scanf("%lf", &v9);
      printf("Please enter the second number: ");
      scanf("%lf", &v8);
      v14 = v9 - v8;
      printf("The result of %lf - %lf is: %lf\n", v9, v8, v9 - v8);
      break;
    case 3:
      printf("You chose to multiply two numbers!\n");
      printf("Please enter the first number: ");
      scanf("%lf", &v7);
      printf("Please enter the second number: ");
      scanf("%lf", &v6);
      v15 = v6 * v7;
      printf("The result of %lf * %lf is: %lf\n", v7, v6, v6 * v7);
      break;
    case 4:
      printf("You chose to divide two numbers!!\n");
      printf("Please enter the first number: ");
      scanf("%lf", &v5);
      printf("Please enter the second number: ");
      scanf("%lf", &v4);
      while ( v4 == 0.0 )
      {
        printf("Division by zero is not allowed. Please enter another number: ");
        scanf("%lf", &v4);
      }
      v16 = v5 / v4;
      printf("The result of %lf / %lf is: %lf\n", v5, v4, v5 / v4);
      break;
    default:
      printf("Invalid choice. Please try again.\n");
      break;
  }
  printf("Thanks for using me!");
  return 0;
}
// 140001AA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type double var_30;

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text Summarizer ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SENTENCES 1000
#define MAX_LENGTH 1000

char *get_sentence(char *text);
void summarize(char *text);

int main() {
    char text[MAX_LENGTH];
    printf("Enter text to summarize: ");
    fgets(text, MAX_LENGTH, stdin);
    printf("\nSummary:\n");
    summarize(text);
    return 0;
}

/**
 * Function to get the next sentence from a given text
 * Returns the sentence as a string
 */
char *get_sentence(char *text) {
    static char sentence[MAX_LENGTH]; // static variable to store sentence
    int i = 0;
    while (*text) {
        if (*text == '.' || *text == '?' || *text == '!') {
            sentence[i++] = *(text++);
            sentence[i] = '\0';
            return sentence;
        }
        sentence[i++] = *(text++);
    }
    return NULL;
}

/**
 * Function to summarize a given text
 */
void summarize(char *text) {
    int sentence_count = 0;
    char *sentences[MAX_SENTENCES];
    char *word;
    char *summarized_text[MAX_LENGTH];
    int summarized_length = 0;
    int i;

    // Split the text into sentences
    sentences[sentence_count++] = strtok(text, ".?!");
    while ((sentences[sentence_count] = strtok(NULL, ".?!")) != NULL) {
        sentence_count++;
    }

    // Loop through each sentence and pick out important words
    for (i = 0; i < sentence_count; i++) {
        word = strtok(sentences[i], " ");
        while (word != NULL) {
            if (strcmp(word, "the") && strcmp(word, "a") && strcmp(word, "an") && strcmp(word, "and") && strcmp(word, "but") && strcmp(word, "or") && strcmp(word, "on") && strcmp(word, "at") && strcmp(word, "in") && strcmp(word, "of") && strcmp(word, "to") && strcmp(word, "with")) {
                strcat(summarized_text, word);
                strcat(summarized_text, " ");
                summarized_length += (strlen(word) + 1);
                if (summarized_length > (MAX_LENGTH / 2)) {
                    break;
                }
            }
            word = strtok(NULL, " ");
        }
        if (summarized_length > (MAX_LENGTH / 2)) {
            break;
        }
    }
    summarized_text[summarized_length] = '\0';

    // Print the summarized text
    printf("%s...\n", summarized_text);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall summarize(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1008]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  printf("Enter text to summarize: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  printf("\nSummary:\n");
  summarize(Buffer);
  return 0;
}
// 1400016B9: using guessed type __int64 __fastcall summarize(_QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Geometric algorithms ; Style: active
#include <stdio.h>
#include <math.h>

struct Point {
    int x;
    int y;
};

float getDistance(struct Point point1, struct Point point2) {
    float distance = sqrt(pow(point2.x - point1.x, 2) + pow(point2.y - point1.y, 2));
    return distance;
}

int main() {
    struct Point points[3];

    printf("Enter coordinates for point 1:\n");
    scanf("%d %d", &points[0].x, &points[0].y);

    printf("Enter coordinates for point 2:\n");
    scanf("%d %d", &points[1].x, &points[1].y);

    printf("Enter coordinates for point 3:\n");
    scanf("%d %d", &points[2].x, &points[2].y);

    float distance1 = getDistance(points[0], points[1]);
    float distance2 = getDistance(points[0], points[2]);
    float distance3 = getDistance(points[1], points[2]);

    if(distance1 + distance2 > distance3 && distance1 + distance3 > distance2 && distance2 + distance3 > distance1) {
        printf("The three points form a triangle.\n");

        float semiperimeter = (distance1 + distance2 + distance3) / 2;
        float area = sqrt(semiperimeter * (semiperimeter - distance1) * (semiperimeter - distance2) * (semiperimeter - distance3));
        printf("Area of the triangle: %.2f\n", area);

        if(distance1 == distance2 && distance1 == distance3) {
            printf("The triangle is equilateral.\n");
        } else if(distance1 == distance2 || distance1 == distance3 || distance2 == distance3) {
            printf("The triangle is isosceles.\n");
        } else {
            printf("The triangle is scalene.\n");
        }
    } else {
        printf("The three points do not form a triangle.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
double __fastcall getDistance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);


//----- (000000014000167D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  float v4; // xmm0_4
  __int64 v6; // [rsp+20h] [rbp-30h] BYREF
  __int64 v7; // [rsp+28h] [rbp-28h] BYREF
  __int64 v8; // [rsp+30h] [rbp-20h] BYREF
  float v9; // [rsp+3Ch] [rbp-14h]
  float v10; // [rsp+40h] [rbp-10h]
  float v11; // [rsp+44h] [rbp-Ch]
  float v12; // [rsp+48h] [rbp-8h]
  float v13; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter coordinates for point 1:\n");
  scanf("%d %d", &v6, (char *)&v6 + 4);
  printf("Enter coordinates for point 2:\n");
  scanf("%d %d", &v7, (char *)&v7 + 4);
  printf("Enter coordinates for point 3:\n");
  scanf("%d %d", &v8, (char *)&v8 + 4);
  *(double *)v3.m128i_i64 = getDistance(v6, v7);
  v13 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
  *(double *)v3.m128i_i64 = getDistance(v6, v8);
  v12 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
  *(double *)v3.m128i_i64 = getDistance(v7, v8);
  v11 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
  if ( (float)(v13 + v12) <= v11 || (float)(v13 + v11) <= v12 || (float)(v12 + v11) <= v13 )
  {
    printf("The three points do not form a triangle.\n");
  }
  else
  {
    printf("The three points form a triangle.\n");
    v10 = (float)((float)(v13 + v12) + v11) / 2.0;
    v4 = sqrt((float)((float)(v10 - v11) * (float)((float)((float)(v10 - v13) * v10) * (float)(v10 - v12))));
    v9 = v4;
    printf("Area of the triangle: %.2f\n", v4);
    if ( v13 == v12 && v13 == v11 )
    {
      printf("The triangle is equilateral.\n");
    }
    else if ( v13 == v12 || v13 == v11 || v12 == v11 )
    {
      printf("The triangle is isosceles.\n");
    }
    else
    {
      printf("The triangle is scalene.\n");
    }
  }
  return 0;
}
// 140001732: variable 'v3' is possibly undefined
// 1400015E2: using guessed type double __fastcall getDistance(_QWORD, _QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: invasive
#include <stdio.h> 
#include <stdlib.h> 
#include <stdbool.h> 

#define ROW 10
#define COL 10

char maze[ROW][COL] = {
    {'#','#','#','#','#','#','#','#','#','#'},
    {'#','.','.','.','#','.','.','.','.','#'},
    {'.','.','#','.','#','.','#','#','.','.'},
    {'#','#','#','.','#','.','.','.','#','#'},
    {'#','.','.','.','.','#','#','.','.','#'},
    {'#','#','#','#','.','#','B','#','.','#'},
    {'#','.','.','#','.','#','.','#','.','#'},
    {'#','#','.','#','.','#','.','#','.','#'},
    {'#','.','.','.','.','.','.','.','.','#'},
    {'#','#','#','#','#','#','#','#','#','#'},
};

bool find_path(int row, int col) 
{ 
    if (maze[row][col] == 'B') { 
        return true; // End of the maze.
    } 

    if (maze[row][col] == '#') { 
        return false; // Dead end.
    } 

    if (maze[row][col] == '.') {
        maze[row][col] = 'X'; // Mark the visited spot.
    }

    if ((row > 0 && find_path(row - 1, col)) || // Check up.
        (row < ROW - 1 && find_path(row + 1, col)) || // Check down.
        (col > 0 && find_path(row, col - 1)) || // Check left.
        (col < COL - 1 && find_path(row, col + 1))) { // Check right.
        return true;
    }

    maze[row][col] = '.'; // Unmark the visited spot.
    return false; 
} 

void print_maze() 
{ 
    for (int i = 0; i < ROW; i++) { 
        for (int j = 0; j < COL; j++) {
            printf("%c ", maze[i][j]); 
        }
        printf("\n"); 
    }
} 

int main() 
{ 
    printf("Initial Maze\n"); 
    print_maze(); 

    if (find_path(1, 1)) { // Starting position.
        printf("\nPath Found!\n"); 
    } else { 
        printf("\nNo Path Found.\n"); 
    } 

    printf("Final Maze\n"); 
    print_maze(); 

    return 0; 
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall find_path(_QWORD, _QWORD); // weak
__int64 print_maze(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000178E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("Initial Maze\n");
  print_maze();
  if ( (unsigned __int8)find_path(1i64, 1i64) )
    printf("\nPath Found!\n");
  else
    printf("\nNo Path Found.\n");
  printf("Final Maze\n");
  print_maze();
  return 0;
}
// 140001591: using guessed type __int64 __fastcall find_path(_QWORD, _QWORD);
// 14000170B: using guessed type __int64 print_maze(void);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Geometric algorithms ; Style: calm
#include<stdio.h>
#include<stdlib.h>
#include<math.h>

/* Definition of a structure point with x and y coordinates */
struct Point{
    int x,y;
};

/* Definition of a structure line with two points */
struct Line{
    struct Point p1,p2;
};

/* Function to check if three points are in a straight line */
int isCollinear(struct Point p1, struct Point p2, struct Point p3){
    int collinear = (p2.y-p1.y)*(p3.x-p2.x) == (p3.y-p2.y)*(p2.x-p1.x);
    return collinear;
}

/* Function to calculate the distance between two points */
float distance(struct Point p1, struct Point p2){
    return sqrt(pow(p2.x-p1.x,2)+pow(p2.y-p1.y,2));
}

/* Function to calculate the area of a triangle */
float triangleArea(struct Point p1, struct Point p2, struct Point p3){
    float s = (distance(p1,p2) + distance(p2,p3) + distance(p3,p1))/2;
    float area = sqrt(s*(s-distance(p1,p2))*(s-distance(p2,p3))*(s-distance(p3,p1)));
    return area;
}

/* Function to find the intersection point of two lines */
struct Point findIntersection(struct Line l1, struct Line l2) {
    int x1 = l1.p1.x, x2 = l1.p2.x, x3 = l2.p1.x, x4 = l2.p2.x;
    int y1 = l1.p1.y, y2 = l1.p2.y, y3 = l2.p1.y, y4 = l2.p2.y;
    int numx = ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4));
    int denx = ((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
    int numy = ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4));
    int deny = ((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
    float x = (float)numx/denx;
    float y = (float)numy/deny;
    struct Point intersection = {x,y};
    return intersection;
}

/* Main function */
int main(){
    int n; // number of points
    struct Point *points;
    printf("Enter the number of points: ");
    scanf("%d", &n);
    points = (struct Point*) malloc(n*sizeof(struct Point)); // Dynamically allocate memory for array of points
    printf("\nEnter the coordinates of the points: ");
    for(int i=0; i<n ;i++){
        scanf("%d %d", &points[i].x, &points[i].y);
    }

    /* Steps to find the centroid of the polygon */
    float centroid_x=0, centroid_y=0;
    for(int i=0; i<n ;i++){
        centroid_x += points[i].x;
        centroid_y += points[i].y;
    }
    centroid_x /= n;
    centroid_y /= n;
    struct Point centroid = {centroid_x, centroid_y};
    printf("\nThe centroid of the polygon is (%.2f, %.2f).", centroid_x, centroid_y);

    /* Steps to find the area of the polygon */
    float area = 0;
    for(int i=0; i<n-2 ;i++){
        if(!isCollinear(points[i],points[i+1],points[i+2])){
            area += triangleArea(points[i],points[i+1],points[i+2]);
        }
    }
    printf("\nThe area of the polygon is %.2f.", area);

    /* Steps to find the shortest distance from a point to a line */
    struct Point p;
    struct Line l;
    printf("\nEnter the coordinates of the point: ");
    scanf("%d %d", &p.x, &p.y);
    printf("Enter the coordinates of the endpoints of the line: ");
    scanf("%d %d %d %d", &l.p1.x, &l.p1.y, &l.p2.x, &l.p2.y);
    float distance_point_line = (abs((l.p2.y-l.p1.y)*p.x - (l.p2.x-l.p1.x)*p.y + l.p2.x*l.p1.y - l.p2.y*l.p1.x))/sqrt(pow(l.p2.y-l.p1.y,2)+pow(l.p2.x-l.p1.x,2));
    printf("The shortest distance from the point (%d,%d) to the line passing through (%d,%d) and (%d,%d) is %.2f.", p.x, p.y, l.p1.x, l.p1.y, l.p2.x, l.p2.y, distance_point_line);

    /* Steps to find the intersection point of two lines */
    struct Line l1, l2;
    printf("\nEnter the coordinates of the endpoints of line 1: ");
    scanf("%d %d %d %d", &l1.p1.x, &l1.p1.y, &l1.p2.x, &l1.p2.y);
    printf("Enter the coordinates of the endpoints of line 2: ");
    scanf("%d %d %d %d", &l2.p1.x, &l2.p1.y, &l2.p2.x, &l2.p2.y);
    struct Point intersection_point = findIntersection(l1, l2);
    printf("The intersection point of the two lines is (%.2f, %.2f).", intersection_point.x, intersection_point.y);

    free(points); // Free the dynamically allocated memory
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall isCollinear(_QWORD, _QWORD, _QWORD); // weak
float __fastcall triangleArea(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall findIntersection(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl pow(double X, double Y);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (0000000140001957) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm2_8
  float v4; // xmm0_4
  int v5; // eax
  double v6; // xmm6_8
  double v7; // xmm7_8
  double v8; // xmm0_8
  double v9; // xmm6_8
  int v10; // xmm0_4
  __int64 v12; // [rsp+20h] [rbp-C0h]
  int v13; // [rsp+28h] [rbp-B8h]
  int v14; // [rsp+30h] [rbp-B0h]
  __int64 v15[2]; // [rsp+40h] [rbp-A0h] BYREF
  __int64 v16[4]; // [rsp+50h] [rbp-90h] BYREF
  __int64 v17; // [rsp+70h] [rbp-70h] BYREF
  __int64 v18; // [rsp+78h] [rbp-68h] BYREF
  __int64 v19; // [rsp+80h] [rbp-60h] BYREF
  __int64 v20; // [rsp+88h] [rbp-58h] BYREF
  unsigned int v21; // [rsp+90h] [rbp-50h] BYREF
  int v22; // [rsp+94h] [rbp-4Ch] BYREF
  int v23; // [rsp+98h] [rbp-48h] BYREF
  int v24; // [rsp+9Ch] [rbp-44h] BYREF
  unsigned int v25; // [rsp+A8h] [rbp-38h] BYREF
  unsigned int v26; // [rsp+ACh] [rbp-34h] BYREF
  int v27; // [rsp+B0h] [rbp-30h]
  int v28; // [rsp+B4h] [rbp-2Ch]
  int v29[2]; // [rsp+B8h] [rbp-28h] BYREF
  void *Block; // [rsp+C0h] [rbp-20h]
  int k; // [rsp+C8h] [rbp-18h]
  float v32; // [rsp+CCh] [rbp-14h]
  int j; // [rsp+D0h] [rbp-10h]
  float v34; // [rsp+D4h] [rbp-Ch]
  float v35; // [rsp+D8h] [rbp-8h]
  int i; // [rsp+DCh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of points: ");
  scanf("%d", v29);
  Block = malloc(8i64 * v29[0]);
  printf("\nEnter the coordinates of the points: ");
  for ( i = 0; i < v29[0]; ++i )
    scanf("%d %d", (char *)Block + 8 * i, (char *)Block + 8 * i + 4);
  v35 = 0.0;
  v34 = 0.0;
  for ( j = 0; j < v29[0]; ++j )
  {
    v35 = (float)*((int *)Block + 2 * j) + v35;
    v34 = (float)*((int *)Block + 2 * j + 1) + v34;
  }
  v35 = v35 / (float)v29[0];
  v34 = v34 / (float)v29[0];
  v27 = (int)v35;
  v28 = (int)v34;
  v3 = v34;
  printf("\nThe centroid of the polygon is (%.2f, %.2f).", v35, v34);
  v32 = 0.0;
  for ( k = 0; k < v29[0] - 2; ++k )
  {
    if ( !(unsigned int)isCollinear(*((_QWORD *)Block + k), *((_QWORD *)Block + k + 1), *((_QWORD *)Block + k + 2)) )
    {
      v4 = triangleArea(*((_QWORD *)Block + k), *((_QWORD *)Block + k + 1), *((_QWORD *)Block + k + 2));
      v32 = v4 + v32;
    }
  }
  printf("\nThe area of the polygon is %.2f.", v32);
  printf("\nEnter the coordinates of the point: ");
  scanf("%d %d", &v25, &v26);
  printf("Enter the coordinates of the endpoints of the line: ");
  scanf("%d %d %d %d", &v21, &v22, &v23, &v24);
  v5 = v23 * v22 + (v24 - v22) * v25 - (v23 - v21) * v26 - v21 * v24;
  if ( (int)(v21 * v24 - (v23 * v22 + (v24 - v22) * v25 - (v23 - v21) * v26)) >= 0 )
    v5 = v21 * v24 - (v23 * v22 + (v24 - v22) * v25 - (v23 - v21) * v26);
  v6 = (double)v5;
  v7 = pow((double)(v24 - v22), 2.0);
  v8 = pow((double)(int)(v23 - v21), 2.0);
  v9 = v6 / sqrt(v7 + v8);
  *(float *)&v10 = v9;
  v29[1] = v10;
  v14 = v24;
  v13 = v23;
  LODWORD(v12) = v22;
  printf(
    "The shortest distance from the point (%d,%d) to the line passing through (%d,%d) and (%d,%d) is %.2f.",
    v25,
    v26,
    v21,
    v12,
    v13,
    v14,
    *(float *)&v10);
  printf("\nEnter the coordinates of the endpoints of line 1: ");
  scanf("%d %d %d %d", &v19, (char *)&v19 + 4, &v20, (char *)&v20 + 4);
  printf("Enter the coordinates of the endpoints of line 2: ");
  scanf("%d %d %d %d", &v17, (char *)&v17 + 4, &v18, (char *)&v18 + 4);
  v16[0] = v19;
  v16[1] = v20;
  v15[0] = v17;
  v15[1] = v18;
  v16[3] = findIntersection(v16, v15);
  printf("The intersection point of the two lines is (%.2f, %.2f).", v9, v3);
  free(Block);
  return 0;
}
// 140001DBC: variable 'v12' is possibly undefined
// 1400015E2: using guessed type __int64 __fastcall isCollinear(_QWORD, _QWORD, _QWORD);
// 1400016C9: using guessed type float __fastcall triangleArea(_QWORD, _QWORD, _QWORD);
// 1400017BF: using guessed type __int64 __fastcall findIntersection(_QWORD, _QWORD);
// 140001F90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Steganography ; Style: medieval
#include <stdio.h>
#include <stdlib.h>

typedef unsigned char BYTE;

int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Usage: %s <InputImage> <OutputImage>\n", argv[0]);
        exit(1);
    }

    FILE *fp = fopen(argv[1], "rb");
    FILE *outp = fopen(argv[2], "wb");

    if (fp == NULL) {
        printf("Error opening file %s\n", argv[1]);
        exit(1);
    }

    if (outp == NULL) {
        printf("Error creating file %s\n", argv[2]);
        exit(1);
    }

    fseek(fp, 0, SEEK_END);
    long int len = ftell(fp);
    rewind(fp);

    BYTE *buf = (BYTE*) malloc(sizeof(BYTE) * len);

    fread(buf, sizeof(BYTE), len, fp);

    // Hide data here
    buf[0] = 255;
    buf[1] = 250;
    buf[2] = 240;

    fwrite(buf, sizeof(BYTE), len, outp);

    fclose(fp);
    fclose(outp);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl rewind(FILE *Stream);
// void *__cdecl malloc(size_t Size);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _BYTE *Buffer; // [rsp+20h] [rbp-20h]
  int v5; // [rsp+2Ch] [rbp-14h]
  FILE *v6; // [rsp+30h] [rbp-10h]
  FILE *Stream; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc <= 2 )
  {
    printf("Usage: %s <InputImage> <OutputImage>\n", *argv);
    exit(1);
  }
  Stream = fopen(argv[1], "rb");
  v6 = fopen(argv[2], "wb");
  if ( !Stream )
  {
    printf("Error opening file %s\n", argv[1]);
    exit(1);
  }
  if ( !v6 )
  {
    printf("Error creating file %s\n", argv[2]);
    exit(1);
  }
  fseek(Stream, 0, 2);
  v5 = ftell(Stream);
  rewind(Stream);
  Buffer = malloc(v5);
  fread(Buffer, 1ui64, v5, Stream);
  *Buffer = -1;
  Buffer[1] = -6;
  Buffer[2] = -16;
  fwrite(Buffer, 1ui64, v5, v6);
  fclose(Stream);
  fclose(v6);
  return 0;
}
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: URL Sanitizer ; Style: artistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

void sanitize(char *url);

int main() {
    char url[100];

    printf("Enter a URL: ");
    fgets(url, 100, stdin);

    sanitize(url);

    printf("Sanitized URL: %s", url);

    return 0;
}

void sanitize(char *url) {
    char temp[100];
    int i, j;

    for (i = j = 0; url[i] != '\0'; ++i) {
        if (isalnum(url[i])) {
            temp[j++] = url[i];
        } else if (url[i] == '/') {
            temp[j++] = '/';
        } else if (url[i] == '.') {
            temp[j++] = '.';
        }
    }

    temp[j] = '\0';

    strcpy(url, temp);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall sanitize(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[112]; // [rsp+20h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter a URL: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  sanitize(Buffer);
  printf("Sanitized URL: %s", Buffer);
  return 0;
}
// 140001605: using guessed type __int64 __fastcall sanitize(_QWORD);
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: visionary
#include<stdio.h>
#include<stdlib.h>

struct product{      //defining a structure to store products and their details
    char name[50];
    int pid;
    float price;
};

struct order{        //defining a structure to store details of orders
    struct product p;
    int quantity;
    float total;
};

void printMenu(struct product[], int);    //function to print the menu
void newOrder(struct order[], struct product[], int);   //function to take order from customer
void printBill(struct order[], int);    //function to print the final bill

int main(){

    struct product menu[5] = {{"Espresso", 1, 2.5},
                         {"Latte", 2, 3.5},
                         {"Cappuccino", 3, 4.5},
                         {"Mocha", 4, 5.5},
                         {"Iced Coffee", 5, 6.5}};   //creating an array of products

    int totalOrders = 0;    //variable to store total number of orders
    struct order orders[50];   //creating an array of orders

    printf("Welcome to CafeX Billing System\n\n");

    int choice = 0;
    while(choice!=3){      //loop to display the menu until customer chooses to exit
        printf("Please choose an option:\n1. Display Menu\n2. New Order\n3. Exit\n");
        scanf("%d", &choice);

        switch(choice){
            case 1:
                printMenu(menu, 5);    //calling function to print menu
                break;
            case 2:
                newOrder(orders, menu, totalOrders);   //calling function to take new order
                totalOrders++;
                break;
            case 3:
                printf("Thank you for using CafeX Billing System. Have a nice day!\n");
                break;
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }
    printBill(orders, totalOrders);   //calling function to print final bill

    return 0;
}

void printMenu(struct product menu[], int n){   //function to print the menu
    printf("Menu:\n");
    printf("------------------------------\n");
    printf("| %-12s | %-4s | %-6s |\n", "Product", "ID", "Price");
    printf("------------------------------\n");
    for(int i=0; i<n; i++){
        printf("| %-12s | %-4d | $%-5.2f |\n", menu[i].name, menu[i].pid, menu[i].price);
    }
    printf("------------------------------\n\n");
}

void newOrder(struct order orders[], struct product menu[], int totalOrders){   //function to take order from customer
    int pid=0, quantity=0;
    printf("Please enter product ID: ");
    scanf("%d", &pid);
    printf("Please enter quantity: ");
    scanf("%d", &quantity);

    struct order o = {menu[pid-1], quantity, quantity * menu[pid-1].price};  //creating new order and calculating total
    orders[totalOrders] = o;   //adding order to array of orders
    printf("Order accepted successfully!\n\n");
}

void printBill(struct order orders[], int totalOrders){   //function to print the final bill
    float subTotal=0, serviceCharge=0, tax=0, total=0;

    printf("CafeX Bill\n");
    printf("-------------------------------------------------\n");
    printf("| %-12s | %-4s | %-8s | %-8s |\n", "Product", "Qty", "Price", "Total");
    printf("-------------------------------------------------\n");
    for(int i=0; i<totalOrders; i++){
        printf("| %-12s | %-4d | $%-6.2f | $%-6.2f |\n", orders[i].p.name, orders[i].quantity, orders[i].p.price, orders[i].total);
        subTotal += orders[i].total;   //calculating subtotal
    }
    printf("-------------------------------------------------\n");
    serviceCharge = (0.1 * subTotal);   //calculating service charge
    tax = (0.15 * subTotal);    //calculating tax
    total = subTotal + serviceCharge + tax;   //calculating total

    printf("Subtotal: $%.2f\n", subTotal);
    printf("Service Charge (10%%): $%.2f\n", serviceCharge);
    printf("Tax (15%%): $%.2f\n", tax);
    printf("Total: $%.2f\n", total);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall printMenu(_QWORD, _QWORD); // weak
__int64 __fastcall newOrder(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall printBill(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char aEspresso[9] = "Espresso"; // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-54h] BYREF
  char v5[3408]; // [rsp+30h] [rbp-50h] BYREF
  char v6[300]; // [rsp+D80h] [rbp+D00h] BYREF
  unsigned int v7; // [rsp+EACh] [rbp+E2Ch]

  _main(argc, argv, envp);
  qmemcpy(v6, aEspresso, sizeof(v6));
  v7 = 0;
  printf("Welcome to CafeX Billing System\n\n");
  v4 = 0;
  while ( v4 != 3 )
  {
    printf("Please choose an option:\n1. Display Menu\n2. New Order\n3. Exit\n");
    scanf("%d", &v4);
    if ( v4 == 3 )
    {
      printf("Thank you for using CafeX Billing System. Have a nice day!\n");
    }
    else
    {
      if ( v4 > 3 )
        goto LABEL_10;
      if ( v4 == 1 )
      {
        printMenu(v6, 5i64);
      }
      else if ( v4 == 2 )
      {
        newOrder(v5, v6, v7++);
      }
      else
      {
LABEL_10:
        printf("Invalid choice. Please try again.\n");
      }
    }
  }
  printBill(v5, v7);
  return 0;
}
// 14000170B: using guessed type __int64 __fastcall printMenu(_QWORD, _QWORD);
// 14000182F: using guessed type __int64 __fastcall newOrder(_QWORD, _QWORD, _QWORD);
// 1400019B2: using guessed type __int64 __fastcall printBill(_QWORD, _QWORD);
// 140001D20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Audio processing ; Style: optimized
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>

#define SAMPLE_RATE 44100
#define AMPLITUDE 32767
#define FREQUENCY 440

int main() {
    uint32_t num_samples = SAMPLE_RATE * 2; // 2 seconds of audio
    float *data = malloc(num_samples * sizeof(float));

    for (uint32_t i = 0; i < num_samples; i++) {
        data[i] = AMPLITUDE * sin(2 * M_PI * FREQUENCY * i / SAMPLE_RATE);
    }

    FILE *file = fopen("sound.raw", "wb");
    fwrite(data, sizeof(float), num_samples, file);
    fclose(file);

    free(data);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sin(double X);
// void *__cdecl malloc(size_t Size);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001540) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  FILE *Stream; // [rsp+28h] [rbp-18h]
  float *Buffer; // [rsp+30h] [rbp-10h]
  unsigned int ElementCount_4; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  Buffer = (float *)malloc(0x56220ui64);
  for ( ElementCount_4 = 0; ElementCount_4 < 0x15888; ++ElementCount_4 )
  {
    v3 = sin((double)(int)ElementCount_4 * 2764.601535159018 / 44100.0) * 32767.0;
    Buffer[ElementCount_4] = v3;
  }
  Stream = fopen("sound.raw", "wb");
  fwrite(Buffer, 4ui64, 0x15888ui64, Stream);
  fclose(Stream);
  free(Buffer);
  return 0;
}
// 140001710: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=83 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: excited
#include <stdio.h>

int main() {
    printf("Hello, everyone! Are you ready to learn about file handling in C?? Let's get started!\n\n");

    FILE *file_pointer;
    char file_name[100];
    printf("First, let's create a new file. What should we call it?\n");
    scanf("%s", file_name);

    file_pointer = fopen(file_name, "w");
    if (file_pointer == NULL) {
        printf("Uh oh, there was an error creating the file. Our program will now exit.\n");
        return 1;
    }
    printf("Great! We successfully created the file %s.\n\n", file_name);

    printf("Now let's write something to the file. What would you like to say?\n");
    char message[100];
    scanf(" %[^\n]s", message);
    fprintf(file_pointer, "%s", message);

    printf("Awesome! We wrote the message \"%s\" to the file %s.\n\n", message, file_name);

    printf("Next, let's read the contents of the file. Here's what's in %s:\n", file_name);
    fclose(file_pointer);
    file_pointer = fopen(file_name, "r");
    if (file_pointer == NULL) {
        printf("Uh oh, there was an error opening the file. Our program will now exit.\n");
        return 1;
    }
    char character;
    while ((character = getc(file_pointer)) != EOF) {
        printf("%c", character);
    }
    printf("\n\nWow, that was awesome! We successfully read the contents of the file %s.\n\n", file_name);

    printf("Finally, let's delete the file. Are you sure you want to delete %s? (y/n)\n", file_name);
    char response;
    scanf(" %c", &response);
    if (response == 'y') {
        remove(file_name);
        printf("The file %s has been deleted. Thanks for using our program!\n\n", file_name);
    } else {
        printf("Great! The file %s has not been deleted. Thanks for using our program!\n\n", file_name);
    }

    fclose(file_pointer);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl remove(const char *FileName);
// int __cdecl getc(FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Fh] [rbp-51h] BYREF
  char v5[112]; // [rsp+30h] [rbp-50h] BYREF
  char FileName[103]; // [rsp+A0h] [rbp+20h] BYREF
  char v7; // [rsp+107h] [rbp+87h]
  FILE *Stream; // [rsp+108h] [rbp+88h]

  _main(argc, argv, envp);
  printf("Hello, everyone! Are you ready to learn about file handling in C?? Let's get started!\n\n");
  printf("First, let's create a new file. What should we call it?\n");
  scanf("%s", FileName);
  Stream = fopen(FileName, "w");
  if ( Stream )
  {
    printf("Great! We successfully created the file %s.\n\n", FileName);
    printf("Now let's write something to the file. What would you like to say?\n");
    scanf(" %[^\n]s", v5);
    fprintf_0(Stream, "%s", v5);
    printf("Awesome! We wrote the message \"%s\" to the file %s.\n\n", v5, FileName);
    printf("Next, let's read the contents of the file. Here's what's in %s:\n", FileName);
    fclose(Stream);
    Stream = fopen(FileName, "r");
    if ( Stream )
    {
      while ( 1 )
      {
        v7 = getc(Stream);
        if ( v7 == -1 )
          break;
        printf("%c", (unsigned int)v7);
      }
      printf("\n\nWow, that was awesome! We successfully read the contents of the file %s.\n\n", FileName);
      printf("Finally, let's delete the file. Are you sure you want to delete %s? (y/n)\n", FileName);
      scanf(" %c", &v4);
      if ( v4 == 121 )
      {
        remove(FileName);
        printf("The file %s has been deleted. Thanks for using our program!\n\n", FileName);
      }
      else
      {
        printf("Great! The file %s has not been deleted. Thanks for using our program!\n\n", FileName);
      }
      fclose(Stream);
      return 0;
    }
    else
    {
      printf("Uh oh, there was an error opening the file. Our program will now exit.\n");
      return 1;
    }
  }
  else
  {
    printf("Uh oh, there was an error creating the file. Our program will now exit.\n");
    return 1;
  }
}
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Dice Roller ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/* Definition of the main function */
int main()
{
    int number, sides, rolls, i, j;
    int total = 0;
    char answer;
    srand(time(0)); /* Seed the random number generator with the current time */

    do {
        /* Prompt the user for input */
        printf("Enter the number of dice, number of sides, and number of rolls: ");
        scanf("%d %d %d", &number, &sides, &rolls);

        if (number <= 0 || sides <= 0 || rolls <= 0) {
            /* Error message: input cannot be negative or zero*/
            printf("Error: Input values must be positive and non-zero\n");
        }
        else {
            /* Roll the dice and display the results */
            printf("Rolling %d %d-sided dice %d times...\n", number, sides, rolls);
            for (i = 0; i < rolls; i++) {
                int sum = 0;
                printf("Roll %d: ", i + 1);
                for (j = 0; j < number; j++) {
                    int roll = rand() % sides + 1;
                    printf("%d ", roll);
                    sum += roll;
                }
                total += sum;
                printf("(Total: %d)\n", sum);
            }

            /* Display the overall total and option to roll again*/
            printf("Overall total: %d\n", total);
            printf("Roll again? (y/n): ");
            scanf(" %c", &answer);

            /* Reset the total*/
            total = 0;
        }

    } while (answer == 'y' || answer == 'Y'); /* Keep looping until the user enters 'n' or 'N' */

    return 0; /* End of the program */
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5; // [rsp+2Fh] [rbp-21h] BYREF
  int v6; // [rsp+30h] [rbp-20h] BYREF
  int v7; // [rsp+34h] [rbp-1Ch] BYREF
  int v8; // [rsp+38h] [rbp-18h] BYREF
  unsigned int v9; // [rsp+3Ch] [rbp-14h]
  unsigned int v10; // [rsp+40h] [rbp-10h]
  unsigned int v11; // [rsp+44h] [rbp-Ch]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v11 = 0;
  v3 = time(0i64);
  srand(v3);
  do
  {
    printf("Enter the number of dice, number of sides, and number of rolls: ");
    scanf("%d %d %d", &v8, &v7, &v6);
    if ( v8 > 0 && v7 > 0 && v6 > 0 )
    {
      printf("Rolling %d %d-sided dice %d times...\n", (unsigned int)v8, (unsigned int)v7, (unsigned int)v6);
      for ( i = 0; i < v6; ++i )
      {
        v10 = 0;
        printf("Roll %d: ", (unsigned int)(i + 1));
        for ( j = 0; j < v8; ++j )
        {
          v9 = rand() % v7 + 1;
          printf("%d ", v9);
          v10 += v9;
        }
        v11 += v10;
        printf("(Total: %d)\n", v10);
      }
      printf("Overall total: %d\n", v11);
      printf("Roll again? (y/n): ");
      scanf(" %c", &v5);
      v11 = 0;
    }
    else
    {
      printf("Error: Input values must be positive and non-zero\n");
    }
  }
  while ( v5 == 121 || v5 == 89 );
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Classification system ; Style: protected
#include <stdio.h>

struct image {
    int height;
    int width;
    int channels;
};

/* A helper function to initialize the image struct */
struct image initialize_image(int height, int width, int channels) {
    struct image img;
    img.height = height;
    img.width = width;
    img.channels = channels;
    return img;
}

/* The main function that performs image classification */
void classify_image(struct image img) {

    /* Perform classification logic here */
    /* This is just a placeholder */
    printf("This image is of a cat\n");
}

int main() {
    /* Initialize the image */
    struct image img = initialize_image(224, 224, 3);

    /* Perform image classification */
    classify_image(img);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall initialize_image(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall classify_image(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015F3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-20h] BYREF
  int v5; // [rsp+28h] [rbp-18h]
  __int64 v6; // [rsp+34h] [rbp-Ch] BYREF
  int v7; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  initialize_image(&v6, 224i64, 224i64, 3i64);
  v4 = v6;
  v5 = v7;
  classify_image(&v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall initialize_image(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400015D5: using guessed type __int64 __fastcall classify_image(_QWORD);
// 140001700: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: satisfied
#include<stdio.h>

int isPrime(int num){
    if(num == 2 || num == 3) return 1;   //2 and 3 are considered prime

    if(num == 1 || num % 2 == 0) return 0;   //1 is not prime and even numbers greater than 2 are not prime

    for(int i=3; i*i<=num; i+=2){    //iterate only through odd numbers
        if(num%i == 0) return 0;    //if the number is divisible by any of the odd numbers, then it is not prime
    }
    return 1;
}

int main(){
    int num, count = 0;

    printf("Enter the maximum limit till which prime numbers should be generated: ");
    scanf("%d", &num);

    printf("The prime numbers between 1 and %d are: ", num);
    for(int i = 1; i <= num; i++){
        if(isPrime(i)){
            count++;
            printf("%d ", i);
        }
    }
    printf("\n\nThere are a total of %d prime numbers from 1 to %d.\n", count, num);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall isPrime(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000164E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  printf("Enter the maximum limit till which prime numbers should be generated: ");
  scanf("%d", &v4);
  printf("The prime numbers between 1 and %d are: ", v4);
  for ( i = 1; (int)i <= (int)v4; ++i )
  {
    if ( (unsigned int)isPrime(i) )
    {
      ++v6;
      printf("%d ", i);
    }
  }
  printf("\n\nThere are a total of %d prime numbers from 1 to %d.\n", v6, v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall isPrime(_QWORD);
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Phone Book ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Contact {
    char name[50];
    char phone[20];
    char email[50];
    char address[100];
};

void addContact(struct Contact contact);
void displayContacts();
void searchContacts(char name[]);
void removeContact(char name[]);
void modifyContact(char name[]);

int main() {
    int choice;
    struct Contact contact;

    while (1) {
        printf("\n1. Add Contact\n2. Display Contacts\n3. Search Contacts\n4. Remove Contact\n5. Modify Contact\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("\nEnter the contact details: ");
                printf("\nEnter name: "); scanf("%s", &contact.name);
                printf("\nEnter phone: "); scanf("%s", &contact.phone);
                printf("\nEnter email: "); scanf("%s", &contact.email);
                printf("\nEnter address: "); scanf("%s", &contact.address);
                addContact(contact);
                break;
            case 2:
                displayContacts();
                break;
            case 3:
                char name[50];
                printf("Enter contact name to search: ");
                scanf("%s", name);
                searchContacts(name);
                break;
            case 4:
                char name_remove[50];
                printf("Enter contact name to delete: ");
                scanf("%s", name_remove);
                removeContact(name_remove);
                break;
            case 5:
                char name_modify[50];
                printf("Enter contact name to modify: ");
                scanf("%s", name_modify);
                modifyContact(name_modify);
                break;
            case 6:
                exit(0);
            default:
                printf("\nInvalid choice. Please try again.\n");
                break;
        }
    }

    return 0;
}

void addContact(struct Contact contact) {
    FILE *fptr;
    fptr = fopen("contacts.txt", "a");
    fprintf(fptr, "%s, %s, %s, %s\n", contact.name, contact.phone, contact.email, contact.address);
    fclose(fptr);
    printf("\nContact added successfully.\n");
}

void displayContacts() {
    struct Contact contact;
    FILE *fptr;
    fptr = fopen("contacts.txt", "r");
    while (fscanf(fptr, "%[^,], %[^,], %[^,], %[^\n]\n", contact.name, contact.phone, contact.email, contact.address) != EOF) {
        printf("\nName: %s\nPhone: %s\nEmail: %s\nAddress: %s\n", contact.name, contact.phone, contact.email, contact.address);
    }
    fclose(fptr);
}

void searchContacts(char name[]) {
    struct Contact contact;
    FILE *fptr;
    fptr = fopen("contacts.txt", "r");
    int found = 0;
    while (fscanf(fptr, "%[^,], %[^,], %[^,], %[^\n]\n", contact.name, contact.phone, contact.email, contact.address) != EOF) {
        if (strcmp(contact.name, name) == 0) {
            found = 1;
            printf("\nName: %s\nPhone: %s\nEmail: %s\nAddress: %s\n", contact.name, contact.phone, contact.email, contact.address);
            break;
        }
    }
    fclose(fptr);
    if (!found) {
        printf("\nContact not found.\n");
    }
}

void removeContact(char name[]) {
    struct Contact contact;
    FILE *fptr1, *fptr2;
    fptr1 = fopen("contacts.txt", "r");
    fptr2 = fopen("temp.txt", "w");
    int found = 0;
    while (fscanf(fptr1, "%[^,], %[^,], %[^,], %[^\n]\n", contact.name, contact.phone, contact.email, contact.address) != EOF) {
        if (strcmp(contact.name, name) != 0) {
            fprintf(fptr2, "%s, %s, %s, %s\n", contact.name, contact.phone, contact.email, contact.address);
        } else {
            found = 1;
        }
    }
    fclose(fptr1);
    fclose(fptr2);
    remove("contacts.txt");
    rename("temp.txt", "contacts.txt");
    if (found) {
        printf("\nContact removed successfully.\n");
    } else {
        printf("\nContact not found.\n");
    }
}

void modifyContact(char name[]) {
    struct Contact contact;
    FILE *fptr1, *fptr2;
    fptr1 = fopen("contacts.txt", "r");
    fptr2 = fopen("temp.txt", "w");
    int found = 0;
    while (fscanf(fptr1, "%[^,], %[^,], %[^,], %[^\n]\n", contact.name, contact.phone, contact.email, contact.address) != EOF) {
        if (strcmp(contact.name, name) != 0) {
            fprintf(fptr2, "%s, %s, %s, %s\n", contact.name, contact.phone, contact.email, contact.address);
        } else {
            found = 1;
            printf("\nEnter new contact details: ");
            printf("\nEnter phone: "); scanf("%s", &contact.phone);
            printf("\nEnter email: "); scanf("%s", &contact.email);
            printf("\nEnter address: "); scanf("%s", &contact.address);
            fprintf(fptr2, "%s, %s, %s, %s\n", contact.name, contact.phone, contact.email, contact.address);
        }
    }
    fclose(fptr1);
    fclose(fptr2);
    remove("contacts.txt");
    rename("temp.txt", "contacts.txt");
    if (found) {
        printf("\nContact modified successfully.\n");
    } else {
        printf("\nContact not found.\n");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall addContact(_QWORD); // weak
__int64 displayContacts(void); // weak
__int64 __fastcall searchContacts(_QWORD); // weak
__int64 __fastcall removeContact(_QWORD); // weak
__int64 __fastcall modifyContact(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001668) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[27]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+F8h] [rbp+78h]
  char v6[64]; // [rsp+100h] [rbp+80h] BYREF
  __int64 v7[6]; // [rsp+140h] [rbp+C0h] BYREF
  __int64 v8[2]; // [rsp+170h] [rbp+F0h] BYREF
  __int64 v9[7]; // [rsp+180h] [rbp+100h] BYREF
  __int64 v10[12]; // [rsp+1B8h] [rbp+138h] BYREF
  int v11; // [rsp+218h] [rbp+198h]
  int v12; // [rsp+21Ch] [rbp+19Ch] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    printf("\n1. Add Contact\n2. Display Contacts\n3. Search Contacts\n4. Remove Contact\n5. Modify Contact\n6. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v12);
    switch ( v12 )
    {
      case 1:
        printf("\nEnter the contact details: ");
        printf("\nEnter name: ");
        scanf("%s", v7);
        printf("\nEnter phone: ");
        scanf("%s", (char *)v8 + 2);
        printf("\nEnter email: ");
        scanf("%s", (char *)v9 + 6);
        printf("\nEnter address: ");
        scanf("%s", v10);
        v4[0] = v7[0];
        v4[1] = v7[1];
        v4[2] = v7[2];
        v4[3] = v7[3];
        v4[4] = v7[4];
        v4[5] = v7[5];
        v4[6] = v8[0];
        v4[7] = v8[1];
        v4[8] = v9[0];
        v4[9] = v9[1];
        v4[10] = v9[2];
        v4[11] = v9[3];
        v4[12] = v9[4];
        v4[13] = v9[5];
        v4[14] = v9[6];
        v4[15] = v10[0];
        v4[16] = v10[1];
        v4[17] = v10[2];
        v4[18] = v10[3];
        v4[19] = v10[4];
        v4[20] = v10[5];
        v4[21] = v10[6];
        v4[22] = v10[7];
        v4[23] = v10[8];
        v4[24] = v10[9];
        v4[25] = v10[10];
        v4[26] = v10[11];
        v5 = v11;
        addContact(v4);
        break;
      case 2:
        displayContacts();
        break;
      case 3:
        printf("Enter contact name to search: ");
        scanf("%s", v6);
        searchContacts(v6);
        break;
      case 4:
        printf("Enter contact name to delete: ");
        scanf("%s", v6);
        removeContact(v6);
        break;
      case 5:
        printf("Enter contact name to modify: ");
        scanf("%s", v6);
        modifyContact(v6);
        break;
      case 6:
        exit(0);
      default:
        printf("\nInvalid choice. Please try again.\n");
        break;
    }
  }
}
// 1400019BA: using guessed type __int64 __fastcall addContact(_QWORD);
// 140001A37: using guessed type __int64 displayContacts(void);
// 140001B02: using guessed type __int64 __fastcall searchContacts(_QWORD);
// 140001C1D: using guessed type __int64 __fastcall removeContact(_QWORD);
// 140001DA9: using guessed type __int64 __fastcall modifyContact(_QWORD);
// 1400020C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: HTML beautifier ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>

int main() {
   FILE *input_file = fopen("input.html", "r");
   FILE *output_file = fopen("output.html", "w");
   
   if (input_file == NULL) {
      printf("Error opening input file!\n");
      exit(1);
   }
   if (output_file == NULL) {
      printf("Error opening output file!\n");
      exit(1);
   }

   char c, last_c = ' ';
   while ((c = fgetc(input_file)) != EOF) {
      if (c == '<' && last_c != ' ') {
         fputc('\n', output_file);
      }
      fputc(c, output_file);
      last_c = c;
   }

   fclose(input_file);
   fclose(output_file);
   printf("Successfully beautified input.html to output.html!\n");
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl fputc(int Character, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+27h] [rbp-19h]
  FILE *Stream; // [rsp+28h] [rbp-18h]
  FILE *v6; // [rsp+30h] [rbp-10h]
  char i; // [rsp+3Fh] [rbp-1h]

  _main(argc, argv, envp);
  v6 = fopen("input.html", "r");
  Stream = fopen("output.html", "w");
  if ( !v6 )
  {
    printf("Error opening input file!\n");
    exit(1);
  }
  if ( !Stream )
  {
    printf("Error opening output file!\n");
    exit(1);
  }
  for ( i = 32; ; i = v4 )
  {
    v4 = fgetc(v6);
    if ( v4 == -1 )
      break;
    if ( v4 == 60 && i != 32 )
      fputc(10, Stream);
    fputc(v4, Stream);
  }
  fclose(v6);
  fclose(Stream);
  printf("Successfully beautified input.html to output.html!\n");
  return 0;
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fractal Generation ; Style: curious
#include <stdio.h>
#include <math.h>

int main() {
    int resolution = 512;
    double zoom = 1.0;
    double x_center = -0.5;
    double y_center = 0.0;

    int max_iter = 1024;
    int x, y, n;
    double cx, cy, zx, zy, temp;

    // Creating the image array
    int image[resolution][resolution];
    for (y = 0; y < resolution; y++) {
        for (x = 0; x < resolution; x++) {
            image[y][x] = 0;
        }
    }

    // Main loop through all the pixels
    for (y = 0; y < resolution; y++) {
        for (x = 0; x < resolution; x++) {
            cx = (x - resolution / 2.0) * (4.0/(double)resolution) / zoom + x_center;
            cy = (y - resolution / 2.0) * (4.0/(double)resolution) / zoom + y_center;
            zx = 0.0;
            zy = 0.0;
            n = 0;
            while (zx * zx + zy * zy < 4 && n < max_iter) {
                temp = zx * zx - zy * zy + cx;
                zy = 2 * zx * zy + cy;
                zx = temp;
                n++;
            }
            image[y][x] = n % 256;
        }
    }

    // Printing the image array to a PGM file
    FILE *fp = fopen("fractal.pgm", "wb");
    fprintf(fp, "P5\n%d %d\n255\n", resolution, resolution);
    for (y = 0; y < resolution; y++) {
        for (x = 0; x < resolution; x++) {
            fputc(image[y][x], fp);
        }
    }
    fclose(fp);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl fputc(int Character, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001583) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  __int64 v5; // [rsp+0h] [rbp-D0h] BYREF
  char v6; // [rsp+20h] [rbp-B0h] BYREF
  __int64 *v7; // [rsp+28h] [rbp-A8h]
  __int64 v8; // [rsp+30h] [rbp-A0h]
  __int64 v9; // [rsp+38h] [rbp-98h]
  __int64 v10; // [rsp+40h] [rbp-90h]
  __int64 v11; // [rsp+48h] [rbp-88h]
  double v12; // [rsp+50h] [rbp-80h]
  double v13; // [rsp+58h] [rbp-78h]
  double v14; // [rsp+60h] [rbp-70h]
  FILE *Stream; // [rsp+68h] [rbp-68h]
  char *v16; // [rsp+70h] [rbp-60h]
  __int64 v17; // [rsp+78h] [rbp-58h]
  __int64 v18; // [rsp+80h] [rbp-50h]
  int v19; // [rsp+8Ch] [rbp-44h]
  double v20; // [rsp+90h] [rbp-40h]
  double v21; // [rsp+98h] [rbp-38h]
  double v22; // [rsp+A0h] [rbp-30h]
  int v23; // [rsp+ACh] [rbp-24h]
  double v24; // [rsp+B0h] [rbp-20h]
  double v25; // [rsp+B8h] [rbp-18h]
  int k; // [rsp+C4h] [rbp-Ch]
  int i; // [rsp+C8h] [rbp-8h]
  int j; // [rsp+CCh] [rbp-4h]

  _main(argc, argv, envp);
  v7 = &v5;
  v23 = 512;
  v22 = 1.0;
  v21 = -0.5;
  v20 = 0.0;
  v19 = 1024;
  v18 = 511i64;
  v8 = 512i64;
  v9 = 0i64;
  v17 = 511i64;
  v10 = 512i64;
  v11 = 0i64;
  v3 = alloca(0x100000i64);
  v16 = &v6;
  for ( i = 0; i < v23; ++i )
  {
    for ( j = 0; j < v23; ++j )
      *(_DWORD *)&v16[2048 * (__int64)i + 4 * j] = 0;
  }
  for ( i = 0; i < v23; ++i )
  {
    for ( j = 0; j < v23; ++j )
    {
      v14 = 4.0 / (double)v23 * ((double)j - (double)v23 / 2.0) / v22 + v21;
      v13 = 4.0 / (double)v23 * ((double)i - (double)v23 / 2.0) / v22 + v20;
      v25 = 0.0;
      v24 = 0.0;
      for ( k = 0; v25 * v25 + v24 * v24 < 4.0 && k < v19; ++k )
      {
        v12 = v25 * v25 - v24 * v24 + v14;
        v24 = (v25 + v25) * v24 + v13;
        v25 = v12;
      }
      *(_DWORD *)&v16[2048 * (__int64)i + 4 * j] = k % 256;
    }
  }
  Stream = fopen("fractal.pgm", "wb");
  fprintf_0(Stream, "P5\n%d %d\n255\n", (unsigned int)v23, (unsigned int)v23);
  for ( i = 0; i < v23; ++i )
  {
    for ( j = 0; j < v23; ++j )
      fputc(*(_DWORD *)&v16[2048 * (__int64)i + 4 * j], Stream);
  }
  fclose(Stream);
  return 0;
}
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Electronic Voting System ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_VOTERS 1000 // maximum number of voters
#define MAX_CANDIDATES 30 // maximum number of candidates
#define MAX_NAME_LENGTH 50 // maximum length of a candidate's name

// struct for a candidate
typedef struct {
    int id;
    char name[MAX_NAME_LENGTH];
    int votes;
} Candidate;

// struct for a voter
typedef struct {
    int id;
    bool hasVoted;
} Voter;

// array of candidates and voters
Candidate candidates[MAX_CANDIDATES];
Voter voters[MAX_VOTERS];

int numCandidates = 0; // number of candidates
int numVoters = 0; // number of voters

// function to add a candidate
void addCandidate(char* name) {
    if (numCandidates == MAX_CANDIDATES) {
        printf("Max number of candidates reached!\n");
        return;
    }
    Candidate candidate;
    candidate.id = numCandidates + 1;
    strcpy(candidate.name, name);
    candidate.votes = 0;
    candidates[numCandidates] = candidate;
    numCandidates++;
}

// function to print all candidates
void printCandidates() {
    printf("ID\tName\t\tVotes\n");
    for (int i = 0; i < numCandidates; i++) {
        printf("%d\t%s\t\t%d\n", candidates[i].id, candidates[i].name, candidates[i].votes);
    }
}

// function to vote for a candidate
void vote(int voterId, int candidateId) {
    if (voters[voterId].hasVoted) {
        printf("Voter has already voted!\n");
        return;
    }
    if (candidateId < 1 || candidateId > numCandidates) {
        printf("Invalid candidate ID!\n");
        return;
    }
    candidates[candidateId - 1].votes++;
    voters[voterId].hasVoted = true;
    printf("Vote cast for %s!\n", candidates[candidateId - 1].name);
}

// function to print all voters
void printVoters() {
    printf("ID\tVoted?\n");
    for (int i = 0; i < numVoters; i++) {
        printf("%d\t%s\n", voters[i].id, voters[i].hasVoted ? "Yes" : "No");
    }
}

int main() {
    // add candidates
    addCandidate("John");
    addCandidate("Jane");
    addCandidate("Jim");
    
    // add voters
    for (int i = 0; i < 10; i++) {
        Voter voter;
        voter.id = numVoters + 1;
        voter.hasVoted = false;
        voters[numVoters] = voter;
        numVoters++;
    }
    
    // print initial state
    printf("Initial state:\n");
    printCandidates();
    printVoters();
    
    // conduct election
    vote(0, 1);
    vote(1, 2);
    vote(2, 1);
    vote(3, 1);
    vote(4, 3);
    vote(5, 2);
    vote(6, 1);
    vote(7, 2);
    vote(8, 3);
    vote(9, 1);
    
    // print final state
    printf("\nFinal state:\n");
    printCandidates();
    printVoters();
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall addCandidate(_QWORD); // weak
__int64 printCandidates(void); // weak
__int64 __fastcall vote(_QWORD, _QWORD); // weak
__int64 printVoters(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN voters; // weak
int numVoters; // weak


//----- (00000001400018A0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+24h] [rbp-Ch]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  addCandidate("John");
  addCandidate("Jane");
  addCandidate("Jim");
  for ( i = 0; i <= 9; ++i )
  {
    LODWORD(v4) = numVoters + 1;
    BYTE4(v4) = 0;
    *((_QWORD *)&voters + numVoters++) = v4;
  }
  printf("Initial state:\n");
  printCandidates();
  printVoters();
  vote(0i64, 1i64);
  vote(1i64, 2i64);
  vote(2i64, 1i64);
  vote(3i64, 1i64);
  vote(4i64, 3i64);
  vote(5i64, 2i64);
  vote(6i64, 1i64);
  vote(7i64, 2i64);
  vote(8i64, 3i64);
  vote(9i64, 1i64);
  printf("\nFinal state:\n");
  printCandidates();
  printVoters();
  return 0;
}
// 14000190E: variable 'v4' is possibly undefined
// 140001591: using guessed type __int64 __fastcall addCandidate(_QWORD);
// 140001662: using guessed type __int64 printCandidates(void);
// 140001715: using guessed type __int64 __fastcall vote(_QWORD, _QWORD);
// 140001813: using guessed type __int64 printVoters(void);
// 140001AB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400116A4: using guessed type int numVoters;

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: satisfied
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_RECORDS 100 // maximum number of fitness records to store

typedef struct{
    char name[20];
    int age;
    float weight;
    float height;
    char gender[10];
} Person;

typedef struct{
    Person person;
    float bmi;
} FitnessRecord;

int num_records = 0;
FitnessRecord fitness_records[MAX_RECORDS];

void addRecord();
void viewRecords();
void viewStats();

int main(){
    char choice;

    while(1){
        printf("Press 'a' to add a new record\n");
        printf("Press 'v' to view all records\n");
        printf("Press 's' to view statistics\n");
        printf("Press 'q' to quit\n");
        scanf(" %c", &choice);

        switch(choice){
            case 'a':
                addRecord();
                break;
            case 'v':
                viewRecords();
                break;
            case 's':
                viewStats();
                break;
            case 'q':
                exit(0);
            default:
                printf("Invalid choice\n");
        }
    }

    return 0;
}

void addRecord(){
    if(num_records == MAX_RECORDS){
        printf("Maximum number of records reached\n");
        return;
    }

    printf("Enter name: ");
    scanf("%s", fitness_records[num_records].person.name);

    printf("Enter age: ");
    scanf("%d", &fitness_records[num_records].person.age);

    printf("Enter weight in kg: ");
    scanf("%f", &fitness_records[num_records].person.weight);

    printf("Enter height in meters: ");
    scanf("%f", &fitness_records[num_records].person.height);

    printf("Enter gender (male/female): ");
    scanf("%s", fitness_records[num_records].person.gender);

    // calculate BMI
    fitness_records[num_records].bmi = fitness_records[num_records].person.weight / (fitness_records[num_records].person.height * fitness_records[num_records].person.height);

    printf("Record added successfully\n");
    num_records++;
}

void viewRecords(){
    if(num_records == 0){
        printf("No records to display\n");
        return;
    }

    printf("%-20s %-10s %-10s %-10s %s\n", "Name", "Age", "Weight", "Height", "BMI");
    for(int i = 0; i < num_records; i++){
        printf("%-20s %-10d %-10.2f %-10.2f %.2f\n", fitness_records[i].person.name, fitness_records[i].person.age, fitness_records[i].person.weight, fitness_records[i].person.height, fitness_records[i].bmi);
    }
}

void viewStats(){
    if(num_records == 0){
        printf("No records to display\n");
        return;
    }

    float avg_bmi = 0, max_bmi = 0, min_bmi = 100;

    for(int i = 0; i < num_records; i++){
        avg_bmi += fitness_records[i].bmi;

        if(fitness_records[i].bmi > max_bmi){
            max_bmi = fitness_records[i].bmi;
        }

        if(fitness_records[i].bmi < min_bmi){
            min_bmi = fitness_records[i].bmi;
        }
    }

    avg_bmi /= num_records;

    printf("Average BMI: %.2f\n", avg_bmi);
    printf("Maximum BMI: %.2f\n", max_bmi);
    printf("Minimum BMI: %.2f\n", min_bmi);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 addRecord(void); // weak
__int64 viewRecords(void); // weak
__int64 viewStats(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  char v3; // [rsp+2Fh] [rbp-1h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        printf("Press 'a' to add a new record\n");
        printf("Press 'v' to view all records\n");
        printf("Press 's' to view statistics\n");
        printf("Press 'q' to quit\n");
        scanf(" %c", &v3);
        if ( v3 != 118 )
          break;
        viewRecords();
      }
      if ( v3 <= 118 )
        break;
LABEL_13:
      printf("Invalid choice\n");
    }
    if ( v3 == 115 )
    {
      viewStats();
    }
    else
    {
      if ( v3 > 115 )
        goto LABEL_13;
      if ( v3 != 97 )
      {
        if ( v3 == 113 )
          exit(0);
        goto LABEL_13;
      }
      addRecord();
    }
  }
}
// 14000169B: using guessed type __int64 addRecord(void);
// 1400018E3: using guessed type __int64 viewRecords(void);
// 140001A55: using guessed type __int64 viewStats(void);
// 140001CF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {
    int rows = 25;
    int cols = 25;

    srand(time(NULL)); // Seed the random number generator

    int world[rows][cols]; // Initialize the world

    // Set all cells to blocked
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            world[i][j] = 0;
        }
    }

    // Create a starting point
    int startX = rand() % rows;
    int startY = rand() % cols;
    world[startX][startY] = 1;

    // Create a wall of debris around the edge of the world
    for (int i = 0; i < rows; i++) {
        world[i][0] = 1;
        world[i][cols-1] = 1;
    }
    for (int j = 0; j < cols; j++) {
        world[0][j] = 1;
        world[rows-1][j] = 1;
    }

    // Simulate the percolation process
    int percolates = 0;
    while (!percolates) {
        // Check for adjacent open cells and open them with a certain probability
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (world[i][j] == 0) {
                    // Check north
                    if (i > 0 && world[i-1][j] == 1 && rand() % 100 < 60) {
                        world[i][j] = 1;
                    }
                    // Check south
                    else if (i < rows-1 && world[i+1][j] == 1 && rand() % 100 < 60) {
                        world[i][j] = 1;
                    }
                    // Check west
                    else if (j > 0 && world[i][j-1] == 1 && rand() % 100 < 60) {
                        world[i][j] = 1;
                    }
                    // Check east
                    else if (j < cols-1 && world[i][j+1] == 1 && rand() % 100 < 60) {
                        world[i][j] = 1;
                    }
                }
            }
        }

        // Check if there is a path from the top to the bottom of the world
        for (int j = 1; j < cols-1; j++) {
            if (world[1][j] == 1) {
                if (explore(world, 1, j)) {
                    percolates = 1;
                    break;
                }
            }
        }
    }

    // Print the final state of the world
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (world[i][j] == 1) {
                printf("# ");
            }
            else {
                printf(". ");
            }
        }
        printf("\n");
    }

    return 0;
}

// Helper function to recursively explore the world
int explore(int world[][25], int row, int col) {
    if (row == 23) {
        return 1; // Found a path to the bottom of the world
    }
    else {
        world[row][col] = 2; // Mark cell as explored
        // Recursively check adjacent cells
        if (row > 0 && world[row-1][col] == 1) {
            if (explore(world, row-1, col)) {
                return 1;
            }
        }
        if (row < 23 && world[row+1][col] == 1) {
            if (explore(world, row+1, col)) {
                return 1;
            }
        }
        if (col > 0 && world[row][col-1] == 1) {
            if (explore(world, row, col-1)) {
                return 1;
            }
        }
        if (col < 23 && world[row][col+1] == 1) {
            if (explore(world, row, col+1)) {
                return 1;
            }
        }
        return 0; // Found no path to the bottom of the world
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall explore(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned __int64 v4; // rbx
  void *v5; // rsp
  __int64 v7; // [rsp+0h] [rbp-A0h] BYREF
  char v8; // [rsp+20h] [rbp-80h] BYREF
  __int64 *v9; // [rsp+28h] [rbp-78h]
  __int64 v10; // [rsp+30h] [rbp-70h]
  __int64 v11; // [rsp+38h] [rbp-68h]
  __int64 v12; // [rsp+40h] [rbp-60h]
  __int64 v13; // [rsp+48h] [rbp-58h]
  int v14; // [rsp+50h] [rbp-50h]
  int v15; // [rsp+54h] [rbp-4Ch]
  char *v16; // [rsp+58h] [rbp-48h]
  __int64 v17; // [rsp+60h] [rbp-40h]
  __int64 v18; // [rsp+68h] [rbp-38h]
  int v19; // [rsp+70h] [rbp-30h]
  int v20; // [rsp+74h] [rbp-2Ch]
  int mm; // [rsp+78h] [rbp-28h]
  int kk; // [rsp+7Ch] [rbp-24h]
  unsigned int jj; // [rsp+80h] [rbp-20h]
  int ii; // [rsp+84h] [rbp-1Ch]
  int n; // [rsp+88h] [rbp-18h]
  int v26; // [rsp+8Ch] [rbp-14h]
  int m; // [rsp+90h] [rbp-10h]
  int k; // [rsp+94h] [rbp-Ch]
  int j; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = &v7;
  v20 = 25;
  v19 = 25;
  v3 = time(0i64);
  srand(v3);
  v18 = v19 - 1i64;
  v10 = v19;
  v11 = 0i64;
  v4 = 4i64 * v19;
  v17 = v20 - 1i64;
  v12 = v19;
  v13 = 0i64;
  v5 = alloca(16 * ((unsigned __int64)(4 * v19 * (__int64)v20 + 15) >> 4));
  v16 = &v8;
  for ( i = 0; i < v20; ++i )
  {
    for ( j = 0; j < v19; ++j )
      *(_DWORD *)&v16[4 * j + 4 * (v4 >> 2) * i] = 0;
  }
  v15 = rand() % v20;
  v14 = rand() % v19;
  *(_DWORD *)&v16[4 * v14 + 4 * (v4 >> 2) * v15] = 1;
  for ( k = 0; k < v20; ++k )
  {
    *(_DWORD *)&v16[4 * (v4 >> 2) * k] = 1;
    *(_DWORD *)&v16[4 * v19 - 4 + 4 * (v4 >> 2) * k] = 1;
  }
  for ( m = 0; m < v19; ++m )
  {
    *(_DWORD *)&v16[4 * m] = 1;
    *(_DWORD *)&v16[4 * m + 4 * (v4 >> 2) * (v20 - 1)] = 1;
  }
  v26 = 0;
LABEL_43:
  while ( !v26 )
  {
    for ( n = 0; n < v20; ++n )
    {
      for ( ii = 0; ii < v19; ++ii )
      {
        if ( !*(_DWORD *)&v16[4 * ii + 4 * (v4 >> 2) * n] )
        {
          if ( n > 0 && *(_DWORD *)&v16[4 * ii + 4 * (v4 >> 2) * (n - 1)] == 1 && rand() % 100 <= 59 )
          {
            *(_DWORD *)&v16[4 * ii + 4 * (v4 >> 2) * n] = 1;
          }
          else if ( n < v20 - 1 && *(_DWORD *)&v16[4 * ii + 4 * (v4 >> 2) * (n + 1)] == 1 && rand() % 100 <= 59 )
          {
            *(_DWORD *)&v16[4 * ii + 4 * (v4 >> 2) * n] = 1;
          }
          else if ( ii > 0 && *(_DWORD *)&v16[4 * ii - 4 + 4 * (v4 >> 2) * n] == 1 && rand() % 100 <= 59 )
          {
            *(_DWORD *)&v16[4 * ii + 4 * (v4 >> 2) * n] = 1;
          }
          else if ( ii < v19 - 1 && *(_DWORD *)&v16[4 * ii + 4 + 4 * (v4 >> 2) * n] == 1 && rand() % 100 <= 59 )
          {
            *(_DWORD *)&v16[4 * ii + 4 * (v4 >> 2) * n] = 1;
          }
        }
      }
    }
    for ( jj = 1; (int)jj < v19 - 1; ++jj )
    {
      if ( *(_DWORD *)&v16[4 * (v4 >> 2) + 4 * (int)jj] == 1 && (unsigned int)explore(v16, 1i64, jj) )
      {
        v26 = 1;
        goto LABEL_43;
      }
    }
  }
  for ( kk = 0; kk < v20; ++kk )
  {
    for ( mm = 0; mm < v19; ++mm )
    {
      if ( *(_DWORD *)&v16[4 * mm + 4 * (v4 >> 2) * kk] == 1 )
        printf("# ");
      else
        printf(". ");
    }
    printf("\n");
  }
  return 0;
}
// 140001B85: using guessed type __int64 __fastcall explore(_QWORD, _QWORD, _QWORD);
// 140001E20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Chess engine ; Style: surprised
#include<stdio.h>
#include<stdlib.h>

#define BOARD_SIZE 8

char board[BOARD_SIZE][BOARD_SIZE] = {
            {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'},
            {'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'},
            {' ', '.', ' ', '.', ' ', '.', ' ', '.'},
            {'.', ' ', '.', ' ', '.', ' ', '.', ' '},
            {' ', '.', ' ', '.', ' ', '.', ' ', '.'},
            {'.', ' ', '.', ' ', '.', ' ', '.', ' '},
            {'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'},
            {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'}
};

int main(){
    printf("Welcome to the Chess game!\n");
    
    //print the initial board
    printf("Initial Board:\n");
    for(int i=0; i<BOARD_SIZE; i++) {
        for(int j=0; j<BOARD_SIZE; j++) {
            printf("[%c]", board[i][j]);
        }
        printf("\n");
    }

    //simulate a move
    printf("\n***Player 1 makes a move***\n");
    int x1 = 1, y1 = 4, x2 = 2, y2 = 4;

    //check if the move is legal
    if(board[x1][y1] == 'p' && x2 == x1+1 && y2 == y1) {
        board[x2][y2] = board[x1][y1];
        board[x1][y1] = ' ';
    } else {
        printf("Sorry, that move is not legal!\n");
    }

    //print the updated board
    printf("\nUpdated Board:\n");
    for(int i=0; i<BOARD_SIZE; i++) {
        for(int j=0; j<BOARD_SIZE; j++) {
            printf("[%c]", board[i][j]);
        }
        printf("\n");
    }

    //simulate a move
    printf("\n***Player 2 makes a move***\n");
    int x3 = 6, y3 = 1, x4 = 4, y4 = 2;

    //check if the move is legal
    if(board[x3][y3] == 'P' && x4 == x3-2 && y4 == y3+1) {
        board[x4][y4] = board[x3][y3];
        board[x3][y3] = ' ';
    } else {
        printf("Oops, that move is not legal!\n");
    }

    //print the updated board
    printf("\nUpdated Board:\n");
    for(int i=0; i<BOARD_SIZE; i++) {
        for(int j=0; j<BOARD_SIZE; j++) {
            printf("[%c]", board[i][j]);
        }
        printf("\n");
    }

    printf("\nThanks for playing!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char board[64] = "rnbqkbnrpppppppp . . . .. . . .  . . . .. . . . PPPPPPPPRNBQKBNR"; // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int ii; // [rsp+48h] [rbp-18h]
  int n; // [rsp+4Ch] [rbp-14h]
  int m; // [rsp+50h] [rbp-10h]
  int k; // [rsp+54h] [rbp-Ch]
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Chess game!\n");
  printf("Initial Board:\n");
  for ( i = 0; i <= 7; ++i )
  {
    for ( j = 0; j <= 7; ++j )
      printf("[%c]", (unsigned int)board[8 * i + j]);
    printf("\n");
  }
  printf("\n***Player 1 makes a move***\n");
  if ( board[12] == 112 )
  {
    board[20] = board[12];
    board[12] = 32;
  }
  else
  {
    printf("Sorry, that move is not legal!\n");
  }
  printf("\nUpdated Board:\n");
  for ( k = 0; k <= 7; ++k )
  {
    for ( m = 0; m <= 7; ++m )
      printf("[%c]", (unsigned int)board[8 * k + m]);
    printf("\n");
  }
  printf("\n***Player 2 makes a move***\n");
  if ( board[49] == 80 )
  {
    board[34] = board[49];
    board[49] = 32;
  }
  else
  {
    printf("Oops, that move is not legal!\n");
  }
  printf("\nUpdated Board:\n");
  for ( n = 0; n <= 7; ++n )
  {
    for ( ii = 0; ii <= 7; ++ii )
      printf("[%c]", (unsigned int)board[8 * n + ii]);
    printf("\n");
  }
  printf("\nThanks for playing!\n");
  return 0;
}
// 140001683: conditional instruction was optimized away because %var_28.4==4
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cat Language Translator ; Style: Ada Lovelace
#include <stdio.h>
#include <string.h>

/* Constants */
#define MAX_INPUT_LENGTH 100
#define MAX_OUTPUT_LENGTH 1000

/* Function prototypes */
void translate(char *input, char *output);

/* Main function */
int main()
{
    // Get the input from the user
    char input[MAX_INPUT_LENGTH];
    printf("Enter text in Cat language: ");
    fgets(input, MAX_INPUT_LENGTH, stdin);

    // Translate the input and print the output
    char output[MAX_OUTPUT_LENGTH];
    translate(input, output);
    printf("Translated text: %s\n", output);

    return 0;
}

/* Translate function */
void translate(char *input, char *output)
{
    // Initialize the output string
    strcpy(output, "");

    // Loop through each character of the input string
    for(int i = 0; i < strlen(input); i++)
    {
        // Check if the character is a cat sound
        if(input[i] == 'M')
        {
            strcat(output, "Meow ");
        }
        else if(input[i] == 'P')
        {
            strcat(output, "Purr ");
        }
        else if(input[i] == 'H')
        {
            strcat(output, "Hiss ");
        }
        else
        {
            // If the character is not a cat sound, just copy it over
            char temp[2];
            temp[0] = input[i];
            temp[1] = '\0';
            strcat(output, temp);
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall translate(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char v5[1008]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[112]; // [rsp+410h] [rbp+390h] BYREF

  _main(argc, argv, envp);
  printf("Enter text in Cat language: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  translate(Buffer, v5);
  printf("Translated text: %s\n", v5);
  return 0;
}
// 140001614: using guessed type __int64 __fastcall translate(_QWORD, _QWORD);
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue Implementation ; Style: automated
#include<stdio.h>
#include<stdlib.h>

#define QUEUE_MAX_SIZE 10

typedef struct Queue {
    int data[QUEUE_MAX_SIZE];
    int front, rear;
} Queue;

// function prototypes
Queue* queue_init();
void enqueue(Queue*, int);
int dequeue(Queue*);
void display(Queue*);
int is_empty(Queue*);
int is_full(Queue*);

int main() {
    int option, element;
    Queue* queue = NULL;

    // display menu
    do {
        printf("\nSelect an option:\n");
        printf("1. Initialize Queue\n");
        printf("2. Enqueue\n");
        printf("3. Dequeue\n");
        printf("4. Display Queue\n");
        printf("5. Exit\n");
        printf("Enter option number: ");

        scanf("%d", &option);

        switch(option) {
            case 1:
                queue = queue_init();
                printf("Queue initialized\n");
                break;
            case 2:
                if(queue == NULL) {
                    printf("Queue not initialized\n");
                    break;
                }
                printf("Enter element to be enqueued: ");
                scanf("%d", &element);
                enqueue(queue, element);
                break;
            case 3:
                if(queue == NULL) {
                    printf("Queue not initialized\n");
                    break;
                }
                element = dequeue(queue);
                if(element != -1)
                    printf("%d dequeued from queue\n", element);
                break;
            case 4:
                if(queue == NULL) {
                    printf("Queue not initialized\n");
                    break;
                }
                display(queue);
                break;
            case 5:
                printf("Exiting program...");
                break;
            default:
                printf("Invalid option entered\n");
        }
    } while(option != 5);

    return 0;
}

// initialize a new queue
Queue* queue_init() {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->front = -1;
    queue->rear = -1;
    return queue;
}

// add element to queue
void enqueue(Queue* queue, int element) {
    if(is_full(queue)) {
        printf("Queue is full\n");
        return;
    }
    if(is_empty(queue))
        queue->front++;
    queue->rear++;
    queue->data[queue->rear] = element;
    printf("%d enqueued into queue\n", element);
}

// remove element from queue
int dequeue(Queue* queue) {
    if(is_empty(queue)) {
        printf("Queue is empty\n");
        return -1;
    }
    int element = queue->data[queue->front];
    queue->front++;
    if(queue->front > queue->rear) {
        queue->front = -1;
        queue->rear = -1;
    }
    return element;
}

// display all elements in queue
void display(Queue* queue) {
    if(is_empty(queue)) {
        printf("Queue is empty\n");
        return;
    }
    printf("Queue elements: ");
    for(int i = queue->front; i <= queue->rear; i++)
        printf("%d\t", queue->data[i]);
    printf("\n");
}

// check if queue is empty
int is_empty(Queue* queue) {
    return (queue->front == -1 && queue->rear == -1);
}

// check if queue is full
int is_full(Queue* queue) {
    return ((queue->rear + 1) % QUEUE_MAX_SIZE == queue->front);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 queue_init(void); // weak
__int64 __fastcall enqueue(_QWORD, _QWORD); // weak
__int64 __fastcall dequeue(_QWORD); // weak
__int64 __fastcall display(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-10h] BYREF
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  __int64 v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v6 = 0i64;
  do
  {
    printf("\nSelect an option:\n");
    printf("1. Initialize Queue\n");
    printf("2. Enqueue\n");
    printf("3. Dequeue\n");
    printf("4. Display Queue\n");
    printf("5. Exit\n");
    printf("Enter option number: ");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        v6 = queue_init();
        printf("Queue initialized\n");
        break;
      case 2:
        if ( !v6 )
          goto LABEL_11;
        printf("Enter element to be enqueued: ");
        scanf("%d", &v4);
        enqueue(v6, v4);
        break;
      case 3:
        if ( !v6 )
          goto LABEL_11;
        v4 = dequeue(v6);
        if ( v4 != -1 )
          printf("%d dequeued from queue\n", v4);
        break;
      case 4:
        if ( v6 )
          display(v6);
        else
LABEL_11:
          printf("Queue not initialized\n");
        break;
      case 5:
        printf("Exiting program...");
        break;
      default:
        printf("Invalid option entered\n");
        break;
    }
  }
  while ( v5 != 5 );
  return 0;
}
// 1400017BA: using guessed type __int64 queue_init(void);
// 1400017F0: using guessed type __int64 __fastcall enqueue(_QWORD, _QWORD);
// 14000187B: using guessed type __int64 __fastcall dequeue(_QWORD);
// 140001900: using guessed type __int64 __fastcall display(_QWORD);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: thoughtful
#include<stdio.h>
#include<string.h>

struct fitness{
    char name[20];
    int age;
    float weight;
    float height;
    float bmi;
    int steps;
};

int main(){
    struct fitness user[10]; // to store data of maximum 10 users
    int user_count=0, option, i, j, flag=0, count;
    float average_bmi, total_bmi=0;

    do{
        printf("\nWelcome to Fitness Tracker!");

        printf("\n1. Add User\n");
        printf("2. Display User Details\n");
        printf("3. Update User Details\n");
        printf("4. Delete User Data\n");
        printf("5. Display User with Highest Steps\n");
        printf("6. Display Average BMI\n");
        printf("7. Exit\n");
        printf("\nEnter Option Number: ");
        scanf("%d", &option);

        switch(option){
            case 1:
                // Add User
                if(user_count>=10){
                    printf("\nMaximum Limit Reached!");
                    break;
                }
                printf("\nEnter Name: ");
                scanf("%s", &user[user_count].name);
                printf("Enter Age: ");
                scanf("%d", &user[user_count].age);
                printf("Enter Weight in Kg: ");
                scanf("%f", &user[user_count].weight);
                printf("Enter Height in Meters: ");
                scanf("%f", &user[user_count].height);

                user[user_count].bmi=user[user_count].weight/(user[user_count].height*user[user_count].height);
                printf("BMI: %f", user[user_count].bmi);
                user_count++;
                flag=1;
                break;


            case 2:
                //Display User Details
                if(!flag){
                    printf("\nNo Data Found!");
                    break;
                }

                for(i=0;i<user_count;i++){
                    printf("\nUser %d Details:", i+1);
                    printf("\nName: %s", user[i].name);
                    printf("\nAge: %d", user[i].age);
                    printf("\nWeight: %f", user[i].weight);
                    printf("\nHeight: %f", user[i].height);
                    printf("\nBMI: %f", user[i].bmi);
                }
                break;


            case 3:
                // Update User Details
                if(!flag){
                    printf("\nNo Data Found!");
                    break;
                }

                printf("\nEnter User Number to Update: ");
                scanf("%d", &count);

                printf("\nSelect User Detail to Update:");
                printf("\n1. Name");
                printf("\n2. Age");
                printf("\n3. Weight");
                printf("\n4. Height");
                printf("\nEnter Option Number: ");
                scanf("%d", &option);

                printf("\nEnter New Value: ");

                switch(option){
                    case 1:
                        scanf("%s", &user[count-1].name);
                        break;
                    case 2:
                        scanf("%d", &user[count-1].age);
                        break;
                    case 3:
                        scanf("%f", &user[count-1].weight);
                        break;
                    case 4:
                        scanf("%f", &user[count-1].height);
                        break;
                    default:
                        printf("\nInvalid Option!");
                        break;
                }

                user[count-1].bmi=user[count-1].weight/(user[count-1].height*user[count-1].height);
                printf("BMI: %f", user[count-1].bmi);

                break;


            case 4:
                // Delete User Data
                if(!flag){
                    printf("\nNo Data Found!");
                    break;
                }

                printf("\nEnter User Number to Delete: ");
                scanf("%d", &count);

                for(i=count-1;i<user_count-1;i++){
                    strcpy(user[i].name, user[i+1].name);
                    user[i].age=user[i+1].age;
                    user[i].weight=user[i+1].weight;
                    user[i].height=user[i+1].height;
                    user[i].bmi=user[i+1].bmi;
                }
                user_count--;
                printf("\nUser Data Deleted");

                break;


            case 5:
                //Display User with Highest Steps
                if(!flag){
                    printf("\nNo Data Found!");
                    break;
                }

                printf("\nEnter Total Steps: ");
                scanf("%d", &user[0].steps); // Assuming user 1 has highest steps

                for(i=1;i<user_count;i++){
                    printf("\nEnter Total Steps for User %d: ", i+1);
                    scanf("%d", &user[i].steps);

                    if(user[i].steps>user[0].steps){
                        user[0].steps=user[i].steps; // storing highest value in user 1
                        j=i; // storing user number with highest steps
                    }
                }

                printf("\nUser with Highest Steps:");
                printf("\nName: %s", user[j].name);
                printf("\nTotal Steps: %d", user[0].steps);

                break;


            case 6:
                // Display Average BMI
                if(!flag){
                    printf("\nNo Data Found!");
                    break;
                }

                for(i=0;i<user_count;i++){
                    total_bmi+=user[i].bmi;
                }

                average_bmi=total_bmi/user_count;
                printf("\nAverage BMI of All Users: %f", average_bmi);

                break;


            case 7:
                printf("\n\nExiting Program...");
                break;


            default:
                printf("\n\nInvalid Option!");
        }

    }while(option!=7);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strcpy(char *Destination, const char *Source);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  int v5[10]; // [rsp+2Ch] [rbp-54h] BYREF
  unsigned int v6[11]; // [rsp+54h] [rbp-2Ch] BYREF
  _BYTE v7[328]; // [rsp+80h] [rbp+0h] BYREF
  float v8; // [rsp+1C8h] [rbp+148h]
  float v9; // [rsp+1CCh] [rbp+14Ch]
  int v10; // [rsp+1D0h] [rbp+150h]
  int v11; // [rsp+1D4h] [rbp+154h]
  int i; // [rsp+1D8h] [rbp+158h]
  int v13; // [rsp+1DCh] [rbp+15Ch]

  _main(argc, argv, envp);
  v13 = 0;
  v10 = 0;
  v9 = 0.0;
  while ( 2 )
  {
    printf("\nWelcome to Fitness Tracker!");
    printf("\n1. Add User\n");
    printf("2. Display User Details\n");
    printf("3. Update User Details\n");
    printf("4. Delete User Data\n");
    printf("5. Display User with Highest Steps\n");
    printf("6. Display Average BMI\n");
    printf("7. Exit\n");
    printf("\nEnter Option Number: ");
    scanf("%d", v5);
    switch ( v5[0] )
    {
      case 1:
        if ( v13 <= 9 )
        {
          printf("\nEnter Name: ");
          scanf("%s", &v5[10 * v13 + 1]);
          printf("Enter Age: ");
          scanf("%d", &v5[10 * v13 + 6]);
          printf("Enter Weight in Kg: ");
          scanf("%f", &v5[10 * v13 + 7]);
          printf("Enter Height in Meters: ");
          scanf("%f", &v5[10 * v13 + 8]);
          *(float *)&v7[40 * v13 - 48] = *(float *)&v7[40 * v13 - 56]
                                       / (float)(*(float *)&v7[40 * v13 - 52] * *(float *)&v7[40 * v13 - 52]);
          printf("BMI: %f", *(float *)&v7[40 * v13++ - 48]);
          v10 = 1;
        }
        else
        {
          printf("\nMaximum Limit Reached!");
        }
        goto LABEL_46;
      case 2:
        if ( !v10 )
          goto LABEL_39;
        for ( i = 0; i < v13; ++i )
        {
          printf("\nUser %d Details:", (unsigned int)(i + 1));
          printf("\nName: %s", (const char *)&v5[10 * i + 1]);
          printf("\nAge: %d", *(unsigned int *)&v7[40 * i - 60]);
          printf("\nWeight: %f", *(float *)&v7[40 * i - 56]);
          printf("\nHeight: %f", *(float *)&v7[40 * i - 52]);
          printf("\nBMI: %f", *(float *)&v7[40 * i - 48]);
        }
        goto LABEL_46;
      case 3:
        if ( !v10 )
          goto LABEL_39;
        printf("\nEnter User Number to Update: ");
        scanf("%d", &v4);
        printf("\nSelect User Detail to Update:");
        printf("\n1. Name");
        printf("\n2. Age");
        printf("\n3. Weight");
        printf("\n4. Height");
        printf("\nEnter Option Number: ");
        scanf("%d", v5);
        printf("\nEnter New Value: ");
        if ( v5[0] == 4 )
        {
          scanf("%f", &v5[10 * v4 - 2]);
        }
        else
        {
          if ( v5[0] > 4 )
          {
LABEL_23:
            printf("\nInvalid Option!");
            goto LABEL_24;
          }
          switch ( v5[0] )
          {
            case 3:
              scanf("%f", &v5[10 * v4 - 3]);
              break;
            case 1:
              scanf("%s", &v5[10 * v4 - 9]);
              break;
            case 2:
              scanf("%d", &v5[10 * v4 - 4]);
              break;
            default:
              goto LABEL_23;
          }
        }
LABEL_24:
        *(float *)&v7[40 * v4 - 88] = *(float *)&v7[40 * v4 - 96]
                                    / (float)(*(float *)&v7[40 * v4 - 92] * *(float *)&v7[40 * v4 - 92]);
        printf("BMI: %f", *(float *)&v7[40 * v4 - 88]);
        goto LABEL_46;
      case 4:
        if ( !v10 )
          goto LABEL_39;
        printf("\nEnter User Number to Delete: ");
        scanf("%d", &v4);
        for ( i = v4 - 1; i < v13 - 1; ++i )
        {
          strcpy((char *)&v5[10 * i + 1], (const char *)&v5[10 * i + 11]);
          *(_DWORD *)&v7[40 * i - 60] = *(_DWORD *)&v7[40 * i - 20];
          *(_DWORD *)&v7[40 * i - 56] = *(_DWORD *)&v7[40 * i - 16];
          *(_DWORD *)&v7[40 * i - 52] = *(_DWORD *)&v7[40 * i - 12];
          *(_DWORD *)&v7[40 * i - 48] = *(_DWORD *)&v7[40 * i - 8];
        }
        --v13;
        printf("\nUser Data Deleted");
        goto LABEL_46;
      case 5:
        if ( !v10 )
          goto LABEL_39;
        printf("\nEnter Total Steps: ");
        scanf("%d", v6);
        for ( i = 1; i < v13; ++i )
        {
          printf("\nEnter Total Steps for User %d: ", (unsigned int)(i + 1));
          scanf("%d", &v5[10 * i + 10]);
          if ( *(_DWORD *)&v7[40 * i - 44] > (int)v6[0] )
          {
            v6[0] = *(_DWORD *)&v7[40 * i - 44];
            v11 = i;
          }
        }
        printf("\nUser with Highest Steps:");
        printf("\nName: %s", (const char *)&v5[10 * v11 + 1]);
        printf("\nTotal Steps: %d", v6[0]);
        goto LABEL_46;
      case 6:
        if ( v10 )
        {
          for ( i = 0; i < v13; ++i )
            v9 = *(float *)&v7[40 * i - 48] + v9;
          v8 = v9 / (float)v13;
          printf("\nAverage BMI of All Users: %f", v8);
        }
        else
        {
LABEL_39:
          printf("\nNo Data Found!");
        }
        goto LABEL_46;
      case 7:
        printf("\n\nExiting Program...");
        goto LABEL_46;
      default:
        printf("\n\nInvalid Option!");
LABEL_46:
        if ( v5[0] != 7 )
          continue;
        return 0;
    }
  }
}
// 140001BD5: conditional instruction was optimized away because %var_1B4.4<3
// 140002360: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type unsigned int var_18C[11];

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital signal processing ; Style: surprised
#include<stdio.h>
#include<math.h>

//Function to calculate frequency response of a filter
void freq_response(float b[], float a[], int N, float w[], float Hr[]) {
  int i,j;
  float num, den;

  for(i=0; i<N; i++) {
    num=0; den=0;
    for(j=0; j<=i; j++) {
      num += b[j]*cos(j*w[i]);
      den += a[j]*cos(j*w[i]);
    }
    Hr[i] = num/den;
  }
}

int main() {
  int i,N;
  float wmax,Hmax;
  float b[10], a[10], w[1000], Hr[1000], Hdb[1000];
  
  printf("Enter the order of filter: ");
  scanf("%d",&N);
  
  printf("Enter the maximum frequency: ");
  scanf("%f",&wmax);
  
  printf("Enter the maximum gain in dB: ");
  scanf("%f",&Hmax);

  //Generating the filter coefficients
  for(i=0; i<=N; i++) {
    printf("Enter the value of b[%d]: ",i);
    scanf("%f",&b[i]);
  }
  
  for(i=0; i<=N; i++) {
    printf("Enter the value of a[%d]: ",i);
    scanf("%f",&a[i]);
  }

  //Generating the frequency vector
  for(i=0; i<1000; i++) {
    w[i] = wmax*(float)i/999;
  }

  freq_response(b,a,N,w,Hr);
  
  //Converting the frequency response to dB
  for(i=0; i<1000; i++) {
    Hdb[i] = 20*log10(Hr[i]);
  }
  
  //Printing the frequency response
  printf("Frequency Response:\n");
  for(i=0; i<1000; i++) {
    printf("%f %f\n",w[i],Hdb[i]);
    if(Hdb[i]>Hmax) {
      printf("Filter exceeds maximum gain at %f Hz\n",w[i]);
    }
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall freq_response(_DWORD, _DWORD, _DWORD, _DWORD, __int64); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// double __cdecl log10(double X);


//----- (000000014000176C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // xmm0_4
  float v5[1000]; // [rsp+30h] [rbp-50h]
  float v6[1000]; // [rsp+FD0h] [rbp+F50h] BYREF
  float v7[1000]; // [rsp+1F70h] [rbp+1EF0h] BYREF
  _DWORD v8[12]; // [rsp+2F10h] [rbp+2E90h] BYREF
  _DWORD v9[12]; // [rsp+2F40h] [rbp+2EC0h] BYREF
  float v10; // [rsp+2F70h] [rbp+2EF0h] BYREF
  float v11; // [rsp+2F74h] [rbp+2EF4h] BYREF
  int v12; // [rsp+2F78h] [rbp+2EF8h] BYREF
  int i; // [rsp+2F7Ch] [rbp+2EFCh]

  _main(argc, argv, envp);
  printf("Enter the order of filter: ");
  scanf("%d", &v12);
  printf("Enter the maximum frequency: ");
  scanf("%f", &v11);
  printf("Enter the maximum gain in dB: ");
  scanf("%f", &v10);
  for ( i = 0; i <= v12; ++i )
  {
    printf("Enter the value of b[%d]: ", (unsigned int)i);
    scanf("%f", &v9[i]);
  }
  for ( i = 0; i <= v12; ++i )
  {
    printf("Enter the value of a[%d]: ", (unsigned int)i);
    scanf("%f", &v8[i]);
  }
  for ( i = 0; i <= 999; ++i )
    v7[i] = (float)(v11 * (float)i) / 999.0;
  freq_response((unsigned int)v9, (unsigned int)v8, v12, (unsigned int)v7, (__int64)v6);
  for ( i = 0; i <= 999; ++i )
  {
    *(float *)&v3 = log10(v6[i]) * 20.0;
    v5[i] = *(float *)&v3;
  }
  printf("Frequency Response:\n");
  for ( i = 0; i <= 999; ++i )
  {
    printf("%f %f\n", v7[i], v5[i]);
    if ( v5[i] > v10 )
      printf("Filter exceeds maximum gain at %f Hz\n", v7[i]);
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall freq_response(_DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 140001B60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000176C: using guessed type float var_1010[1000];
// 14000176C: using guessed type float var_1FB0[1000];
// 14000176C: using guessed type float var_2F50[1000];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image to ASCII art converter ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>

int main(){
    char asciiChars[] = {'#', '&', '@', '%', '*', '+', '-', ';', ':', ',', '.', ' '};
    int numChars = sizeof(asciiChars);
    char blankChar = asciiChars[numChars - 1];

    FILE *imgFile;
    imgFile = fopen("image.ppm", "r");

    if(imgFile){
        int width, height, maxColor;
        char format[3];

        fscanf(imgFile, "%s %d %d %d", format, &width, &height, &maxColor);

        int pixelCount = width * height;
        int asciiCount = pixelCount / 3;
        int remainder = pixelCount % 3;
        if(remainder > 0) asciiCount++;

        unsigned char pixel[3];
        int pixelVal;
        char asciiChar;
        int count = 0;

        while(count < asciiCount){
            fread(pixel, 1, 3, imgFile);
            pixelVal = ((pixel[0] + pixel[1] + pixel[2]) / 3) * (numChars - 1) / maxColor;
            asciiChar = asciiChars[pixelVal];
            printf("%c", asciiChar);
            if((count + 1) % width == 0) printf("\n");
            count++;
        }

        fclose(imgFile);
    }
    else{
        printf("Cannot open image file.");
        return 1;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[6]; // [rsp+3Ah] [rbp-46h] BYREF
  int v5; // [rsp+40h] [rbp-40h] BYREF
  int v6; // [rsp+44h] [rbp-3Ch] BYREF
  int v7; // [rsp+48h] [rbp-38h] BYREF
  _BYTE v8[12]; // [rsp+4Fh] [rbp-31h] BYREF
  char v9; // [rsp+5Bh] [rbp-25h]
  int v10; // [rsp+5Ch] [rbp-24h]
  int v11; // [rsp+60h] [rbp-20h]
  int v12; // [rsp+64h] [rbp-1Ch]
  FILE *Stream; // [rsp+68h] [rbp-18h]
  char v14; // [rsp+73h] [rbp-Dh]
  int v15; // [rsp+74h] [rbp-Ch]
  int i; // [rsp+78h] [rbp-8h]
  int v17; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  qmemcpy(v8, "#&@%*+-;:,. ", sizeof(v8));
  v15 = 12;
  v14 = 32;
  Stream = fopen("image.ppm", "r");
  if ( Stream )
  {
    fscanf(Stream, "%s %d %d %d", &Buffer[3], &v7, &v6, &v5);
    v12 = v7 * v6;
    v17 = v7 * v6 / 3;
    v11 = v7 * v6 % 3;
    if ( v11 > 0 )
      ++v17;
    for ( i = 0; i < v17; ++i )
    {
      fread(Buffer, 1ui64, 3ui64, Stream);
      v10 = ((unsigned __int8)Buffer[1] + (unsigned __int8)Buffer[0] + (unsigned __int8)Buffer[2]) / 3 * (v15 - 1) / v5;
      v9 = v8[v10];
      printf("%c", (unsigned int)v9);
      if ( !((i + 1) % v7) )
        printf("\n");
    }
    fclose(Stream);
    return 0;
  }
  else
  {
    printf("Cannot open image file.");
    return 1;
  }
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Airport Baggage Handling Simulation ; Style: minimalist
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

#define MAX_BAGGAGE 20

int main(){
    srand(time(0)); //for generating random numbers

    int passenger_baggage[MAX_BAGGAGE];
    int total_baggage = 0;

    //Generate random baggage for each passenger
    for(int i=0; i<MAX_BAGGAGE; i++){
        passenger_baggage[i] = rand() % 5 + 1; //each passenger can have 1 to 5 bags
        total_baggage += passenger_baggage[i]; //sum up the total baggage
    }

    //Display the total number of baggage
    printf("Total number of baggage in the airport: %d\n", total_baggage);

    //Simulate the baggage handling process
    int baggage_checked = 0;
    int baggage_left = total_baggage;

    while(baggage_left != 0){
        int baggage_to_check = rand() % 6; //check up to 5 baggage at a time
        if(baggage_to_check > baggage_left){ //make sure we don't check more than we have
            baggage_to_check = baggage_left;
        }

        printf("\n%d baggage checked.", baggage_to_check);
        baggage_left -= baggage_to_check;
        baggage_checked += baggage_to_check;

        if(baggage_left == 0){
            printf("\nAll baggage has been checked and loaded onto the plane.");
        }
        else{
            printf("\n%d baggage left to be checked and loaded onto the plane.", baggage_left);
            printf("\nContinue checking baggage.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[23]; // [rsp+20h] [rbp-70h]
  int v6; // [rsp+7Ch] [rbp-14h]
  unsigned int v7; // [rsp+80h] [rbp-10h]
  int v8; // [rsp+84h] [rbp-Ch]
  int i; // [rsp+88h] [rbp-8h]
  unsigned int v10; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v10 = 0;
  for ( i = 0; i <= 19; ++i )
  {
    v5[i] = rand() % 5 + 1;
    v10 += v5[i];
  }
  printf("Total number of baggage in the airport: %d\n", v10);
  v8 = 0;
  v7 = v10;
  while ( v7 )
  {
    v6 = rand() % 6;
    if ( v6 > (int)v7 )
      v6 = v7;
    printf("\n%d baggage checked.", (unsigned int)v6);
    v7 -= v6;
    v8 += v6;
    if ( v7 )
    {
      printf("\n%d baggage left to be checked and loaded onto the plane.", v7);
      printf("\nContinue checking baggage.\n");
    }
    else
    {
      printf("\nAll baggage has been checked and loaded onto the plane.");
    }
  }
  return 0;
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type int var_70[23];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>

void fib(int n) {
    int arr[n];
    arr[0] = 0;
    arr[1] = 1;

    for(int i = 2; i < n; i++) {
        arr[i] = arr[i-1] + arr[i-2];
    }

    printf("Fibonacci Sequence:\n");

    for(int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
}

void printRow(int num, int* arr, int curr, int length) {
    int mid = length / 2;
    if(num > curr) {
        printRow(num, arr, curr * 2, length);
    }
    int spaces = mid - curr / 2;
    for(int i = 0; i < spaces; i++) {
        printf(" ");
    }
    for(int i = 0; i < curr; i++) {
        if(mid - i <= 0 || mid + i >= length) {
            break;
        }
        printf("%d", arr[num - (mid-i-1)]);
    }
    printf("\n");
}

void printFibonacciVisualization(int n) {
    if(n == 0) {
        printf("0\n");
        return;
    }
    if(n == 1) {
        printf("0 \n1\n");
        return;
    }

    int arr[n];
    arr[0] = 0;
    arr[1] = 1;

    for(int i = 2; i < n; i++) {
        arr[i] = arr[i-1] + arr[i-2];
    }

    int maxNum = arr[n-1];
    int curr = 2;
    while(curr < n && arr[curr] <= maxNum) {
        curr++;
    }
    curr--;

    for(int i = curr; i >= 0; i--) {
        printRow(i, arr, 1, curr * 2 + 1);
    }
}

int main() {
    int n;
    printf("Enter the number of terms: ");
    scanf("%d", &n);

    printf("\n\n");

    fib(n);

    printf("\n\n");

    printf("Fibonacci Visualization:\n\n");

    printFibonacciVisualization(n);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall fib(_QWORD); // weak
__int64 __fastcall printFibonacciVisualization(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001961) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the number of terms: ");
  scanf("%d", &v4);
  printf("\n\n");
  fib(v4);
  printf("\n\n");
  printf("Fibonacci Visualization:\n\n");
  printFibonacciVisualization(v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall fib(_QWORD);
// 1400017ED: using guessed type __int64 __fastcall printFibonacciVisualization(_QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Tower of Hanoi Problem ; Style: safe
#include<stdio.h>

void towerOfHanoi(int n, char source, char destination, char auxiliary)
{
    if(n == 1)
    {
        printf("Move disk 1 from %c to %c\n", source, destination);
        return;
    }

    towerOfHanoi(n-1, source, auxiliary, destination);
    printf("Move disk %d from %c to %c\n", n, source, destination);
    towerOfHanoi(n-1, auxiliary, destination, source);
}

int main()
{
    int n;
    printf("Enter the number of disks in Tower of Hanoi: ");
    scanf("%d", &n);

    if(n < 1)
    {
        printf("Invalid input! Number of disks must be greater than or equal to 1.");
        return 0;
    }

    printf("\nSteps to solve Tower of Hanoi:\n");
    towerOfHanoi(n, 'A', 'C', 'B');

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall towerOfHanoi(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001683) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the number of disks in Tower of Hanoi: ");
  scanf("%d", &v4);
  if ( (int)v4 > 0 )
  {
    printf("\nSteps to solve Tower of Hanoi:\n");
    towerOfHanoi(v4, 65i64, 67i64, 66i64);
  }
  else
  {
    printf("Invalid input! Number of disks must be greater than or equal to 1.");
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall towerOfHanoi(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: invasive
#include <stdio.h>
#include <stdlib.h>

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to add a new node at the beginning of the list
void push(struct Node** head_ref, int new_data) {
    // Allocate memory for new node
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = (*head_ref);
    (*head_ref) = new_node;
}

// Function to remove duplicates from a sorted list
void removeDuplicates(struct Node* head) {
    struct Node* current = head;
    struct Node* next_next;

    if (current == NULL)
        return;

    while (current->next != NULL) {
        if (current->data == current->next->data) {
            next_next = current->next->next;
            free(current->next);
            current->next = next_next;
        }
        else {
            current = current->next;
        }
    }
}

// Function to print the linked list
void printList(struct Node* node) {
    while (node != NULL) {
        printf("%d ", node->data);
        node = node->next;
    }
}

int main() {
    struct Node* head = NULL;

    push(&head, 10);
    push(&head, 10);
    push(&head, 20);
    push(&head, 20);
    push(&head, 30);
    push(&head, 30);
    push(&head, 50);

    removeDuplicates(head);

    printf("Linked list after removing duplicates:\n");
    printList(head);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall push(_QWORD, _QWORD); // weak
__int64 __fastcall removeDuplicates(_QWORD); // weak
__int64 __fastcall printList(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001699) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v4 = 0i64;
  push(&v4, 10i64);
  push(&v4, 10i64);
  push(&v4, 20i64);
  push(&v4, 20i64);
  push(&v4, 30i64);
  push(&v4, 30i64);
  push(&v4, 50i64);
  removeDuplicates(v4);
  printf("Linked list after removing duplicates:\n");
  printList(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall push(_QWORD, _QWORD);
// 1400015D8: using guessed type __int64 __fastcall removeDuplicates(_QWORD);
// 140001659: using guessed type __int64 __fastcall printList(_QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Stock market tracker ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>

#define STOCK_LIST_SIZE 10

struct stock {
    char symbol[10];
    float price;
    float change_pct;
    float high_price;
    float low_price;
    int volume;
} stocks[STOCK_LIST_SIZE];

void display_stock_details(struct stock s) {
    printf("\n%s\t\t%.2f\t%.2f%%\t%.2f\t%.2f\t%d", s.symbol, s.price, s.change_pct, s.high_price, s.low_price, s.volume);
}

void display_stocks() {
    printf("\nSymbol\t\tPrice\tChange\tHigh\tLow\tVolume");
    for(int i = 0; i < STOCK_LIST_SIZE; i++) {
        display_stock_details(stocks[i]);
    }
}

void update_stock(struct stock *s, float price, int volume) {
    if(price < s->low_price || s->low_price == 0) {
        s->low_price = price;
    }
    if(price > s->high_price) {
        s->high_price = price;
    }
    s->change_pct = ((price - s->price) / s->price) * 100;
    s->price = price;
    s->volume = s->volume + volume;
}

void simulate_stock_market() {
    for(int i = 0; i < STOCK_LIST_SIZE; i++) {
        float new_price = stocks[i].price + ((rand() % 20 - 10) / 10.0);
        int new_volume = rand() % 5000;
        update_stock(&stocks[i], new_price, new_volume);
    }
    printf("\nMarket Updated!\n");
}

int main() {
    strcpy(stocks[0].symbol, "AAPL");
    stocks[0].price = 145.80;
    stocks[0].high_price = 148.50;
    stocks[0].low_price = 140.80;
    stocks[0].volume = 10000;

    strcpy(stocks[1].symbol, "GOOG");
    stocks[1].price = 2478.38;
    stocks[1].high_price = 2510.00;
    stocks[1].low_price = 2402.45;
    stocks[1].volume = 5000;

    strcpy(stocks[2].symbol, "AMZN");
    stocks[2].price = 3422.90;
    stocks[2].high_price = 3500.00;
    stocks[2].low_price = 3329.04;
    stocks[2].volume = 3000;

    strcpy(stocks[3].symbol, "TSLA");
    stocks[3].price = 655.29;
    stocks[3].high_price = 666.14;
    stocks[3].low_price = 637.88;
    stocks[3].volume = 11000;

    strcpy(stocks[4].symbol, "MSFT");
    stocks[4].price = 277.01;
    stocks[4].high_price = 282.25;
    stocks[4].low_price = 262.10;
    stocks[4].volume = 2000;

    strcpy(stocks[5].symbol, "NVDA");
    stocks[5].price = 201.60;
    stocks[5].high_price = 209.76;
    stocks[5].low_price = 190.95;
    stocks[5].volume = 8000;

    strcpy(stocks[6].symbol, "PYPL");
    stocks[6].price = 274.98;
    stocks[6].high_price = 279.45;
    stocks[6].low_price = 266.03;
    stocks[6].volume = 1500;

    strcpy(stocks[7].symbol, "NFLX");
    stocks[7].price = 540.72;
    stocks[7].high_price = 550.00;
    stocks[7].low_price = 526.27;
    stocks[7].volume = 2500;

    strcpy(stocks[8].symbol, "FB");
    stocks[8].price = 343.18;
    stocks[8].high_price = 350.75;
    stocks[8].low_price = 335.22;
    stocks[8].volume = 4500;

    strcpy(stocks[9].symbol, "INTC");
    stocks[9].price = 54.63;
    stocks[9].high_price = 56.10;
    stocks[9].low_price = 52.87;
    stocks[9].volume = 6000;

    display_stocks();

    for(int i = 0; i < 5; i++) {
        simulate_stock_market();
        display_stocks();
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 display_stocks(void); // weak
__int64 simulate_stock_market(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

int stocks; // weak
int dword_14000F04C; // weak
int dword_14000F054; // weak
int dword_14000F058; // weak
int dword_14000F05C; // weak
int dword_14000F060; // weak
int dword_14000F06C; // weak
int dword_14000F074; // weak
int dword_14000F078; // weak
int dword_14000F07C; // weak
int dword_14000F080; // weak
int dword_14000F08C; // weak
int dword_14000F094; // weak
int dword_14000F098; // weak
int dword_14000F09C; // weak
int dword_14000F0A0; // weak
int dword_14000F0AC; // weak
int dword_14000F0B4; // weak
int dword_14000F0B8; // weak
int dword_14000F0BC; // weak
int dword_14000F0C0; // weak
int dword_14000F0CC; // weak
int dword_14000F0D4; // weak
int dword_14000F0D8; // weak
int dword_14000F0DC; // weak
int dword_14000F0E0; // weak
int dword_14000F0EC; // weak
int dword_14000F0F4; // weak
int dword_14000F0F8; // weak
int dword_14000F0FC; // weak
int dword_14000F100; // weak
int dword_14000F10C; // weak
int dword_14000F114; // weak
int dword_14000F118; // weak
int dword_14000F11C; // weak
int dword_14000F120; // weak
int dword_14000F12C; // weak
int dword_14000F134; // weak
int dword_14000F138; // weak
int dword_14000F13C; // weak
__int16 word_14000F140; // weak
int dword_14000F14C; // weak
int dword_14000F154; // weak
int dword_14000F158; // weak
int dword_14000F15C; // weak
int dword_14000F160; // weak
int dword_14000F16C; // weak
int dword_14000F174; // weak
int dword_14000F178; // weak
int dword_14000F17C; // weak


//----- (0000000140001866) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  strcpy((char *)&stocks, "AAPL");
  dword_14000F04C = 1125240013;
  dword_14000F054 = 1125416960;
  dword_14000F058 = 1124912333;
  dword_14000F05C = 10000;
  strcpy((char *)&dword_14000F060, "GOOG");
  dword_14000F06C = 1159390740;
  dword_14000F074 = 1159520256;
  dword_14000F078 = 1159079731;
  dword_14000F07C = 5000;
  strcpy((char *)&dword_14000F080, "AMZN");
  dword_14000F08C = 1163259494;
  dword_14000F094 = 1163575296;
  dword_14000F098 = 1162875044;
  dword_14000F09C = 3000;
  strcpy((char *)&dword_14000F0A0, "TSLA");
  dword_14000F0AC = 1143198351;
  dword_14000F0B4 = 1143376118;
  dword_14000F0B8 = 1142913106;
  dword_14000F0BC = 11000;
  strcpy((char *)&dword_14000F0C0, "MSFT");
  dword_14000F0CC = 1133150536;
  dword_14000F0D4 = 1133322240;
  dword_14000F0D8 = 1132661965;
  dword_14000F0DC = 2000;
  strcpy((char *)&dword_14000F0E0, "NVDA");
  dword_14000F0EC = 1128896922;
  dword_14000F0F4 = 1129431695;
  dword_14000F0F8 = 1128198963;
  dword_14000F0FC = 8000;
  strcpy((char *)&dword_14000F100, "PYPL");
  dword_14000F10C = 1133084017;
  dword_14000F114 = 1133230490;
  dword_14000F118 = 1132790743;
  dword_14000F11C = 1500;
  strcpy((char *)&dword_14000F120, "NFLX");
  dword_14000F12C = 1141321236;
  dword_14000F134 = 1141473280;
  dword_14000F138 = 1141084488;
  dword_14000F13C = 2500;
  strcpy((char *)&word_14000F140, "FB");
  dword_14000F14C = 1135318794;
  dword_14000F154 = 1135566848;
  dword_14000F158 = 1135057961;
  dword_14000F15C = 4500;
  strcpy((char *)&dword_14000F160, "INTC");
  dword_14000F16C = 1113228575;
  dword_14000F174 = 1113613926;
  dword_14000F178 = 1112767201;
  dword_14000F17C = 6000;
  display_stocks();
  for ( i = 0; i <= 4; ++i )
  {
    simulate_stock_market();
    display_stocks();
  }
  return 0;
}
// 14000161B: using guessed type __int64 display_stocks(void);
// 140001754: using guessed type __int64 simulate_stock_market(void);
// 140001C40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type int stocks;
// 14000F04C: using guessed type int dword_14000F04C;
// 14000F054: using guessed type int dword_14000F054;
// 14000F058: using guessed type int dword_14000F058;
// 14000F05C: using guessed type int dword_14000F05C;
// 14000F060: using guessed type int dword_14000F060;
// 14000F06C: using guessed type int dword_14000F06C;
// 14000F074: using guessed type int dword_14000F074;
// 14000F078: using guessed type int dword_14000F078;
// 14000F07C: using guessed type int dword_14000F07C;
// 14000F080: using guessed type int dword_14000F080;
// 14000F08C: using guessed type int dword_14000F08C;
// 14000F094: using guessed type int dword_14000F094;
// 14000F098: using guessed type int dword_14000F098;
// 14000F09C: using guessed type int dword_14000F09C;
// 14000F0A0: using guessed type int dword_14000F0A0;
// 14000F0AC: using guessed type int dword_14000F0AC;
// 14000F0B4: using guessed type int dword_14000F0B4;
// 14000F0B8: using guessed type int dword_14000F0B8;
// 14000F0BC: using guessed type int dword_14000F0BC;
// 14000F0C0: using guessed type int dword_14000F0C0;
// 14000F0CC: using guessed type int dword_14000F0CC;
// 14000F0D4: using guessed type int dword_14000F0D4;
// 14000F0D8: using guessed type int dword_14000F0D8;
// 14000F0DC: using guessed type int dword_14000F0DC;
// 14000F0E0: using guessed type int dword_14000F0E0;
// 14000F0EC: using guessed type int dword_14000F0EC;
// 14000F0F4: using guessed type int dword_14000F0F4;
// 14000F0F8: using guessed type int dword_14000F0F8;
// 14000F0FC: using guessed type int dword_14000F0FC;
// 14000F100: using guessed type int dword_14000F100;
// 14000F10C: using guessed type int dword_14000F10C;
// 14000F114: using guessed type int dword_14000F114;
// 14000F118: using guessed type int dword_14000F118;
// 14000F11C: using guessed type int dword_14000F11C;
// 14000F120: using guessed type int dword_14000F120;
// 14000F12C: using guessed type int dword_14000F12C;
// 14000F134: using guessed type int dword_14000F134;
// 14000F138: using guessed type int dword_14000F138;
// 14000F13C: using guessed type int dword_14000F13C;
// 14000F140: using guessed type __int16 word_14000F140;
// 14000F14C: using guessed type int dword_14000F14C;
// 14000F154: using guessed type int dword_14000F154;
// 14000F158: using guessed type int dword_14000F158;
// 14000F15C: using guessed type int dword_14000F15C;
// 14000F160: using guessed type int dword_14000F160;
// 14000F16C: using guessed type int dword_14000F16C;
// 14000F174: using guessed type int dword_14000F174;
// 14000F178: using guessed type int dword_14000F178;
// 14000F17C: using guessed type int dword_14000F17C;

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: String manipulation ; Style: complex
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main() {
    char str1[50], str2[50];
    int choice, len1, len2, i;

    printf("\nEnter first string: ");
    fgets(str1, 50, stdin);
    len1 = strlen(str1);

    printf("Enter second string: ");
    fgets(str2, 50, stdin);
    len2 = strlen(str2);

    while(1) {
        printf("\nChoose an operation:\n");
        printf("1: Concatenate both strings\n");
        printf("2: Compare both strings\n");
        printf("3: Copy second string to first string\n");
        printf("4: Exit program\n");

        scanf("%d", &choice);
        getchar();  // Used to clear the input buffer

        switch(choice) {
            case 1:
                for(i=0; i<len2; i++) {
                    str1[len1+i-1] = str2[i];
                }
                printf("\nConcatenated string: %s", str1);
                break;

            case 2:
                if (strcmp(str1, str2) == 0)
                    printf("\nBoth strings are equal");
                else
                    printf("\nBoth strings are not equal");
                break;

            case 3:
                strcpy(str1, str2);
                printf("\nSecond string copied to first string: %s", str1);
                break;

            case 4:
                printf("\nExiting program...");
                exit(0);

            default:
                printf("\nInvalid choice! Please try again.");
                break;
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  int v5; // [rsp+2Ch] [rbp-84h] BYREF
  char Str[64]; // [rsp+30h] [rbp-80h] BYREF
  char Buffer[52]; // [rsp+70h] [rbp-40h] BYREF
  int v8; // [rsp+A4h] [rbp-Ch]
  int v9; // [rsp+A8h] [rbp-8h]
  int i; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  printf("\nEnter first string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 50, v3);
  v9 = strlen(Buffer);
  printf("Enter second string: ");
  v4 = __acrt_iob_func(0);
  fgets(Str, 50, v4);
  v8 = strlen(Str);
  while ( 1 )
  {
    printf("\nChoose an operation:\n");
    printf("1: Concatenate both strings\n");
    printf("2: Compare both strings\n");
    printf("3: Copy second string to first string\n");
    printf("4: Exit program\n");
    scanf("%d", &v5);
    getchar();
    if ( v5 == 4 )
    {
      printf("\nExiting program...");
      exit(0);
    }
    if ( v5 > 4 )
    {
LABEL_17:
      printf("\nInvalid choice! Please try again.");
    }
    else
    {
      switch ( v5 )
      {
        case 3:
          strcpy(Buffer, Str);
          printf("\nSecond string copied to first string: %s", Buffer);
          break;
        case 1:
          for ( i = 0; i < v8; ++i )
            Buffer[v9 - 1 + i] = Str[i];
          printf("\nConcatenated string: %s", Buffer);
          break;
        case 2:
          if ( !strcmp(Buffer, Str) )
            printf("\nBoth strings are equal");
          else
            printf("\nBoth strings are not equal");
          break;
        default:
          goto LABEL_17;
      }
    }
  }
}
// 140001705: conditional instruction was optimized away because %var_84.4<3
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Buffer[52];
// 1400015E2: using guessed type char Str[64];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bucket Sort Implementation ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>

// Define the number of buckets 
#define NUM_BUCKETS 5 

// Define a struct for the buckets 
struct node {
    int value;
    struct node *next;
};

// Define a function to insert a value into a bucket 
void insert(struct node **bucket, int value) {
    struct node *new_node = (struct node*)malloc(sizeof(struct node));
    new_node->value = value;
    new_node->next = *bucket;
    *bucket = new_node;
}

// Define a function to sort the buckets 
void sort_buckets(struct node **bucket) {
    struct node *temp;
    int value, i, j;

    for (i = 0; i < NUM_BUCKETS; i++) {
        temp = bucket[i];

        // Sort each bucket using Insertion Sort 
        for (j = 1; temp != NULL && j < NUM_BUCKETS; j++) {
            value = temp->value;
            struct node *prev = temp;
            while (prev->next != NULL && prev->next->value < value) {
                prev = prev->next;
            }
            temp = temp->next;

            // Insert the value into its proper sorted location 
            if (prev == temp) {
                continue;
            }
            struct node *tmp = prev->next;
            prev->next = (struct node*)malloc(sizeof(struct node));
            prev->next->value = value;
            prev->next->next = tmp;
        }
    }
}

// Define a function to perform Bucket Sort 
void bucket_sort(int *array, int size) {
    // Create the buckets 
    struct node **bucket = (struct node**)malloc(sizeof(struct node*) * NUM_BUCKETS);
    int i, j;
    for (i = 0; i < NUM_BUCKETS; i++) {
        bucket[i] = NULL;
    }

    // Insert each element from the array into its corresponding bucket 
    for (i = 0; i < size; i++) {
        insert(&bucket[array[i] / NUM_BUCKETS], array[i]);
    }

    // Sort each bucket 
    sort_buckets(bucket);

    // Combine the sorted buckets back into the original array 
    j = 0;
    for (i = 0; i < NUM_BUCKETS; i++) {
        struct node *temp = bucket[i];
        while (temp != NULL) {
            array[j++] = temp->value;
            temp = temp->next;
        }
    }

    // Free memory 
    for (i = 0; i < NUM_BUCKETS; i++) {
        struct node *temp = bucket[i];
        while (temp != NULL) {
            struct node *delete_node = temp;
            temp = temp->next;
            free(delete_node);
        }
    }
    free(bucket);
}

// Define a function to print an array 
void print_array(int *array, int size) {
    int i;
    for (i = 0; i < size; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");
}

int main() {
    int array[10] = {23, 55, 12, 42, 7, 98, 65, 31, 17, 76};
    int size = 10;

    printf("Original array: ");
    print_array(array, size);

    bucket_sort(array, size);

    printf("Sorted array: ");
    print_array(array, size);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall bucket_sort(_QWORD, _QWORD); // weak
__int64 __fastcall print_array(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018D7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[11]; // [rsp+20h] [rbp-30h] BYREF
  unsigned int v5; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 23;
  v4[1] = 55;
  v4[2] = 12;
  v4[3] = 42;
  v4[4] = 7;
  v4[5] = 98;
  v4[6] = 65;
  v4[7] = 31;
  v4[8] = 17;
  v4[9] = 76;
  v5 = 10;
  printf("Original array: ");
  print_array(v4, 10i64);
  bucket_sort(v4, v5);
  printf("Sorted array: ");
  print_array(v4, v5);
  return 0;
}
// 1400016D4: using guessed type __int64 __fastcall bucket_sort(_QWORD, _QWORD);
// 140001876: using guessed type __int64 __fastcall print_array(_QWORD, _QWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data mining ; Style: complex
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char name[20];
    int age;
    float income;
} Person;

int main() {
    FILE *file;
    file = fopen("people.txt", "r");
    if (file == NULL) {
        printf("Error opening file.\n");
        exit(1);
    }

    int num_people;
    fscanf(file, "%d", &num_people);

    Person *people = (Person*) malloc(num_people * sizeof(Person));

    for (int i = 0; i < num_people; i++) {
        fscanf(file, "%s %d %f", people[i].name, &people[i].age, &people[i].income);
    }

    int index_of_richest = 0;
    for (int i = 1; i < num_people; i++) {
        if (people[i].income > people[index_of_richest].income) {
            index_of_richest = i;
        }
    }

    printf("%s is the richest person with an income of %.2f.\n", people[index_of_richest].name, people[index_of_richest].income);

    fclose(file);
    free(people);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+3Ch] [rbp-24h] BYREF
  void *Block; // [rsp+40h] [rbp-20h]
  FILE *Stream; // [rsp+48h] [rbp-18h]
  int j; // [rsp+54h] [rbp-Ch]
  int v8; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  Stream = fopen("people.txt", "r");
  if ( !Stream )
  {
    printf("Error opening file.\n");
    exit(1);
  }
  fscanf(Stream, "%d", &v4);
  Block = malloc(28i64 * v4);
  for ( i = 0; i < v4; ++i )
    fscanf(Stream, "%s %d %f", (char *)Block + 28 * i, (char *)Block + 28 * i + 20, (char *)Block + 28 * i + 24);
  v8 = 0;
  for ( j = 1; j < v4; ++j )
  {
    if ( *((float *)Block + 7 * j + 6) > *((float *)Block + 7 * v8 + 6) )
      v8 = j;
  }
  printf(
    "%s is the richest person with an income of %.2f.\n",
    (const char *)Block + 28 * v8,
    *((float *)Block + 7 * v8 + 6));
  fclose(Stream);
  free(Block);
  return 0;
}
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: romantic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int main()
{
    char password[100];
    int length, i;
    int hasUpperCase = 0, hasLowerCase = 0, hasNumber = 0, hasSpecialChar = 0;

    printf("Enter your password:\n");
    fgets(password,100,stdin);

    length = strlen(password)-1;

    if (length<8)
    {
        printf("Sorry, your password must be at least 8 characters long.\n");
        exit(1);
    }
    else
    {
        for(i=0; i<length; i++)
        {
            if(isupper(password[i]))
            {
                hasUpperCase = 1;
            }
            else if(islower(password[i]))
            {
                hasLowerCase = 1;
            }
            else if(isdigit(password[i]))
            {
                hasNumber = 1;
            }
            else
            {
                hasSpecialChar = 1;
            }
        }

        if(hasUpperCase && hasLowerCase && hasNumber && hasSpecialChar)
        {
            printf("Wow! Your password is strong as our love.\n");
        }
        else
        {
            printf("Sorry, your password is too weak for the strength of our love. Please include at least one uppercase letter, one lowercase letter, one number, and one special character.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *islower)(int C);
// extern int (__cdecl *isupper)(int C);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[104]; // [rsp+20h] [rbp-80h] BYREF
  int v6; // [rsp+88h] [rbp-18h]
  int v7; // [rsp+8Ch] [rbp-14h]
  int v8; // [rsp+90h] [rbp-10h]
  int v9; // [rsp+94h] [rbp-Ch]
  int v10; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  printf("Enter your password:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  v6 = strlen(Buffer) - 1;
  if ( v6 <= 7 )
  {
    printf("Sorry, your password must be at least 8 characters long.\n");
    exit(1);
  }
  for ( i = 0; i < v6; ++i )
  {
    if ( isupper(Buffer[i]) )
    {
      v10 = 1;
    }
    else if ( islower(Buffer[i]) )
    {
      v9 = 1;
    }
    else if ( (unsigned int)(Buffer[i] - 48) > 9 )
    {
      v7 = 1;
    }
    else
    {
      v8 = 1;
    }
  }
  if ( v10 && v9 && v8 && v7 )
    printf("Wow! Your password is strong as our love.\n");
  else
    printf(
      "Sorry, your password is too weak for the strength of our love. Please include at least one uppercase letter, one l"
      "owercase letter, one number, and one special character.\n");
  return 0;
}
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[104];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: QR code reader ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>

#define QR_CODE_SIZE 21

int main() {
    char qrCode[QR_CODE_SIZE + 1] = {0};
    bool isCodeScanned = false;

    printf("\n\n==============================================\n\n");
    printf("Welcome to the unique QR Code reader program!\n\n");
    printf("Please scan your QR code to get started.\n\n");

    while (!isCodeScanned) {
        printf("Scanning...");
        sleep(2); // Simulate the QR code scanning process
        printf("\n\n");

        fgets(qrCode, sizeof(qrCode), stdin);

        if (strlen(qrCode) == QR_CODE_SIZE) {
            // Check if its a valid QR code
            printf("You have successfully scanned the following QR code:\n\n");
            printf("%s\n\n", qrCode);
            isCodeScanned = true;
        } else {
            printf("Invalid QR code. Please try again.\n\n");
            memset(qrCode, 0, sizeof(qrCode)); // Clear array for next scan
        }
    }

    printf("Thank you for using the unique QR Code reader program!\n\n");
    printf("Exiting...\n\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void *__cdecl memset(void *, int Val, size_t Size);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[31]; // [rsp+20h] [rbp-20h] BYREF
  char v6; // [rsp+3Fh] [rbp-1h]

  _main(argc, argv, envp);
  memset(Buffer, 0, 22);
  v6 = 0;
  printf("\n\n==============================================\n\n");
  printf("Welcome to the unique QR Code reader program!\n\n");
  printf("Please scan your QR code to get started.\n\n");
  while ( v6 != 1 )
  {
    printf("Scanning...");
    sleep(2i64);
    printf("\n\n");
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 22, v3);
    if ( strlen(Buffer) == 21 )
    {
      printf("You have successfully scanned the following QR code:\n\n");
      printf("%s\n\n", Buffer);
      v6 = 1;
    }
    else
    {
      printf("Invalid QR code. Please try again.\n\n");
      memset(Buffer, 0, 0x16ui64);
    }
  }
  printf("Thank you for using the unique QR Code reader program!\n\n");
  printf("Exiting...\n\n");
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400027F0: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text Summarizer ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LEN 1000

int main() {
    char input[MAX_LEN];
    printf("Enter the text you want to summarize:\n");
    fgets(input, MAX_LEN, stdin);

    // Convert all text to lowercase
    for (int i = 0; i < strlen(input); i++) {
        if (input[i] >= 'A' && input[i] <= 'Z') {
            input[i] = input[i] - 'A' + 'a';
        }
    }

    // Split the text into an array of words
    char **words = malloc(MAX_LEN * sizeof(char*));
    int num_words = 0;
    char *token = strtok(input, " ");

    while (token != NULL) {
        words[num_words] = token;
        num_words++;
        token = strtok(NULL, " ");
    }

    // Count the frequency of each word
    int *freq = calloc(num_words, sizeof(int));
    for (int i = 0; i < num_words; i++) {
        for (int j = 0; j < num_words; j++) {
            if (strcmp(words[i], words[j]) == 0) {
                freq[i]++;
            }
        }
    }

    // Determine the most common word and its frequency
    int max_freq = 0;
    char *most_common_word = NULL;
    for (int i = 0; i < num_words; i++) {
        if (freq[i] > max_freq) {
            max_freq = freq[i];
            most_common_word = words[i];
        }
    }

    // Print the summary
    printf("\nSUMMARY: The most common word is \"%s\" with a frequency of %d\n", most_common_word, max_freq);

    // Free memory
    free(words);
    free(freq);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void *__cdecl calloc(size_t Count, size_t Size);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1008]; // [rsp+20h] [rbp-60h] BYREF
  void *v6; // [rsp+410h] [rbp+390h]
  void *Block; // [rsp+418h] [rbp+398h]
  int n; // [rsp+424h] [rbp+3A4h]
  const char *v9; // [rsp+428h] [rbp+3A8h]
  unsigned int v10; // [rsp+434h] [rbp+3B4h]
  int m; // [rsp+438h] [rbp+3B8h]
  int k; // [rsp+43Ch] [rbp+3BCh]
  char *j; // [rsp+440h] [rbp+3C0h]
  int v14; // [rsp+448h] [rbp+3C8h]
  int i; // [rsp+44Ch] [rbp+3CCh]

  _main(argc, argv, envp);
  printf("Enter the text you want to summarize:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  for ( i = 0; i < strlen(Buffer); ++i )
  {
    if ( Buffer[i] > 64 && Buffer[i] <= 90 )
      Buffer[i] += 32;
  }
  Block = malloc(0x1F40ui64);
  v14 = 0;
  for ( j = strtok(Buffer, " "); j; j = strtok(0i64, " ") )
    *((_QWORD *)Block + v14++) = j;
  v6 = calloc(v14, 4ui64);
  for ( k = 0; k < v14; ++k )
  {
    for ( m = 0; m < v14; ++m )
    {
      if ( !strcmp(*((const char **)Block + k), *((const char **)Block + m)) )
        ++*((_DWORD *)v6 + k);
    }
  }
  v10 = 0;
  v9 = 0i64;
  for ( n = 0; n < v14; ++n )
  {
    if ( (signed int)v10 < *((_DWORD *)v6 + n) )
    {
      v10 = *((_DWORD *)v6 + n);
      v9 = (const char *)*((_QWORD *)Block + n);
    }
  }
  printf("\nSUMMARY: The most common word is \"%s\" with a frequency of %d\n", v9, v10);
  free(Block);
  free(v6);
  return 0;
}
// 140001940: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[1008];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Frequency Counter ; Style: romantic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
  char sentence[1000], word[100];
  int count = 0;
  
  printf("Please enter a sentence: ");
  fgets(sentence, sizeof(sentence), stdin); //get sentence from user
  
  printf("Please enter a word to count its frequency: ");
  scanf("%s", word); //get word from user
  
  char* token = strtok(sentence, " "); //tokenize sentence
  
  while(token != NULL) { //iterate until no more tokens
    if(strcmp(token, word) == 0) { //compare token with the word
      count++; //increment count if word is found
    }
    token = strtok(NULL, " "); //get next token
  }
  
  printf("The word '%s' appears in the sentence %d times.", word, count);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Str2[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[1008]; // [rsp+90h] [rbp+10h] BYREF
  char *Str1; // [rsp+480h] [rbp+400h]
  unsigned int v8; // [rsp+48Ch] [rbp+40Ch]

  _main(argc, argv, envp);
  v8 = 0;
  printf("Please enter a sentence: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  printf("Please enter a word to count its frequency: ");
  scanf("%s", Str2);
  for ( Str1 = strtok(Buffer, " "); Str1; Str1 = strtok(0i64, " ") )
  {
    if ( !strcmp(Str1, Str2) )
      ++v8;
  }
  printf("The word '%s' appears in the sentence %d times.", Str2, v8);
  return 0;
}
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * This program visualizes the Fibonacci sequence up to the nth term provided by the user.
 * It uses a scientific style output to show the sequence as well as the golden ratio.
 */

int main() {
    int n, i;
    double golden_ratio, prev, curr, next;

    printf("Enter the number of terms in the Fibonacci sequence: ");
    scanf("%d", &n);

    // Initialize first two terms of Fibonacci sequence
    prev = 0;
    curr = 1;

    // Print header for scientific output
    printf("Term\tValue\t\tGolden Ratio\n");
    printf("----\t-----\t\t------------\n");

    // Iterate through the sequence and calculate the golden ratio
    for (i = 1; i <= n; i++) {
        // Print the current term and value
        printf("%d\t%.0f\t\t", i, curr);

        if (i == 1) {
            // For the first term, the golden ratio is undefined
            printf("N/A\n");

        } else if (i == 2) {
            // For the second term, the ratio is 1
            printf("1.0000\n");
            prev = curr;

        } else {
            // For subsequent terms, calculate the next value and the golden ratio
            next = prev + curr;
            golden_ratio = curr / prev;
            printf("%.4f\n", golden_ratio);

            // Update previous and current values for next iteration
            prev = curr;
            curr = next;
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-2Ch] BYREF
  double v5; // [rsp+28h] [rbp-28h]
  char v6[24]; // [rsp+30h] [rbp-20h]
  unsigned int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of terms in the Fibonacci sequence: ");
  scanf("%d", &v4);
  *(_QWORD *)&v6[16] = 0i64;
  *(_QWORD *)&v6[8] = 0x3FF0000000000000i64;
  printf("Term\tValue\t\tGolden Ratio\n");
  printf("----\t-----\t\t------------\n");
  for ( i = 1; (int)i <= v4; ++i )
  {
    printf("%d\t%.0f\t\t", i, *(double *)&v6[8]);
    if ( i == 1 )
    {
      printf("N/A\n");
    }
    else if ( i == 2 )
    {
      printf("1.0000\n");
      *(_QWORD *)&v6[16] = *(_QWORD *)&v6[8];
    }
    else
    {
      *(double *)v6 = *(double *)&v6[16] + *(double *)&v6[8];
      v5 = *(double *)&v6[8] / *(double *)&v6[16];
      printf("%.4f\n", *(double *)&v6[8] / *(double *)&v6[16]);
      *(_OWORD *)&v6[8] = *(_OWORD *)v6;
    }
  }
  return 0;
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data structures visualization ; Style: Ada Lovelace
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Define a structure representing a card
typedef struct {
    int value;
    char suit;
} Card;

// Define a function to generate a shuffled deck of cards
Card* generate_deck() {
    Card* deck = (Card*)malloc(52*sizeof(Card)); // Allocate memory for 52 cards
    char suits[4] = {'H', 'D', 'S', 'C'}; // Define the four suits
    int values[13] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}; // Define the thirteen card values
    int index = 0;
    // Loop through all combinations of suits and values, adding each card to the deck
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 13; j++) {
            deck[index].value = values[j];
            deck[index].suit = suits[i];
            index++;
        }
    }
    // Shuffle the deck using the Fisher-Yates algorithm
    for (int i = 51; i > 0; i--) {
        int j = rand() % (i+1);
        Card temp = deck[i];
        deck[i] = deck[j];
        deck[j] = temp;
    }
    return deck;
}

// Define a function to print a card in a visually appealing way
void print_card(Card card) {
    if (card.value == 10) {
        printf(" %c10", card.suit);
    }
    else {
        printf(" %c%d ", card.suit, card.value);
    }
}

// Define a function to print a visual representation of a hand of cards
void print_hand(Card* hand, int size) {
    for (int i = 0; i < size; i++) {
        print_card(hand[i]);
        printf("|");
    }
    printf("\n");
}

// Define the main function
int main() {
    srand(time(NULL)); // Seed the random number generator
    Card* deck = generate_deck(); // Generate a shuffled deck of cards
    printf("Here is a shuffled deck of cards:\n");
    print_hand(deck, 52); // Print the deck
    int i = 0;
    int j = 0;
    Card temp;
    // Sort the cards using a modified bubble sort algorithm
    for (i = 0; i < 52; i++) {
        for (j = 0; j < 52-i-1; j++) {
            if (deck[j].value > deck[j+1].value) {
                temp = deck[j];
                deck[j] = deck[j+1];
                deck[j+1] = temp;
                printf("Swapping:");
                print_hand(&deck[j], 2); // Print the two cards being swapped
            }
        }
    }
    printf("Here is the sorted deck of cards:\n");
    print_hand(deck, 52); // Print the sorted deck
    free(deck); // Free the heap memory occupied by the deck
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 generate_deck(void); // weak
__int64 __fastcall print_hand(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// void __cdecl free(void *Block);


//----- (00000001400017EA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5; // [rsp+28h] [rbp-18h]
  _QWORD *Block; // [rsp+30h] [rbp-10h]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  Block = (_QWORD *)generate_deck();
  printf("Here is a shuffled deck of cards:\n");
  print_hand(Block, 52i64);
  for ( i = 0; i <= 51; ++i )
  {
    for ( j = 0; j < 51 - i; ++j )
    {
      if ( SLODWORD(Block[j]) > SLODWORD(Block[j + 1]) )
      {
        v5 = Block[j];
        Block[j] = Block[j + 1];
        Block[j + 1] = v5;
        printf("Swapping:");
        print_hand(&Block[j], 2i64);
      }
    }
  }
  printf("Here is the sorted deck of cards:\n");
  print_hand(Block, 52i64);
  free(Block);
  return 0;
}
// 1400015B0: using guessed type __int64 generate_deck(void);
// 140001785: using guessed type __int64 __fastcall print_hand(_QWORD, _QWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital signal processing ; Style: active
#include<stdio.h>
#include<stdlib.h>
#include<math.h>

#define BLOCK_SIZE 32

int main()
{
    int input_samples[BLOCK_SIZE], output_samples[BLOCK_SIZE];
    float coefficients[BLOCK_SIZE], sum;
    int i, j;
    
    //initialize input_samples and coefficients
    for(i = 0; i < BLOCK_SIZE; i++){
        input_samples[i] = i+1;
        coefficients[i] = sin(i * M_PI / BLOCK_SIZE);
    }
    
    //perform convolution
    for(i = 0; i < BLOCK_SIZE; i++){
        sum = 0;
        for(j = 0; j <= i; j++){
            sum += input_samples[j] * coefficients[i-j];
        }
        output_samples[i] = (int)sum;
    }
    
    //print output
    printf("Output samples:\n");
    for(i = 0; i < BLOCK_SIZE; i++){
        printf("%d ", output_samples[i]);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sin(double X);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // xmm0_4
  int v5[97]; // [rsp+20h] [rbp-60h]
  int j; // [rsp+1A4h] [rbp+124h]
  int i; // [rsp+1A8h] [rbp+128h]
  float v8; // [rsp+1ACh] [rbp+12Ch]

  _main(argc, argv, envp);
  for ( i = 0; i <= 31; ++i )
  {
    v5[i + 64] = i + 1;
    *(float *)&v3 = sin(3.141592653589793 * (double)i / 32.0);
    v5[i] = v3;
  }
  for ( i = 0; i <= 31; ++i )
  {
    v8 = 0.0;
    for ( j = 0; j <= i; ++j )
      v8 = (float)(*(float *)&v5[i - j] * (float)v5[j + 64]) + v8;
    v5[i + 32] = (int)v8;
  }
  printf("Output samples:\n");
  for ( i = 0; i <= 31; ++i )
    printf("%d ", (unsigned int)v5[i + 32]);
  return 0;
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Modern Encryption ; Style: Ada Lovelace
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
   char inputMessage[100] = {0};
   char encryptionKey[100] = {0};
   char encryptedMessage[100] = {0};
   int inputLength = 0, keyLength = 0, i = 0, j = 0;
   
   // Getting the input message and key from the user
   printf("Enter the message you want to encrypt: ");
   scanf("%[^\n]s", inputMessage);
   printf("Enter the encryption key: ");
   scanf("%s", encryptionKey);
   
   inputLength = strlen(inputMessage);
   keyLength = strlen(encryptionKey);
   
   // Encrypting the message using the key
   for(i = 0; i < inputLength; i++) {
      encryptedMessage[i] = inputMessage[i] ^ encryptionKey[j];
      j++;
      if(j == keyLength) {
         j = 0;
      }
   }
   
   // Displaying the encrypted message
   printf("\nEncrypted message: ");
   for(i = 0; i < inputLength; i++) {
      printf("%c", encryptedMessage[i]);
   }
   printf("\n");
   
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[12]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+80h] [rbp+0h]
  char v6[8]; // [rsp+90h] [rbp+10h] BYREF
  __int64 v7; // [rsp+98h] [rbp+18h]
  __int64 v8; // [rsp+A0h] [rbp+20h]
  __int64 v9; // [rsp+A8h] [rbp+28h]
  __int64 v10; // [rsp+B0h] [rbp+30h]
  __int64 v11; // [rsp+B8h] [rbp+38h]
  __int64 v12; // [rsp+C0h] [rbp+40h]
  __int64 v13; // [rsp+C8h] [rbp+48h]
  __int64 v14; // [rsp+D0h] [rbp+50h]
  __int64 v15; // [rsp+D8h] [rbp+58h]
  __int64 v16; // [rsp+E0h] [rbp+60h]
  __int64 v17; // [rsp+E8h] [rbp+68h]
  int v18; // [rsp+F0h] [rbp+70h]
  char Str[8]; // [rsp+100h] [rbp+80h] BYREF
  __int64 v20; // [rsp+108h] [rbp+88h]
  __int64 v21; // [rsp+110h] [rbp+90h]
  __int64 v22; // [rsp+118h] [rbp+98h]
  __int64 v23; // [rsp+120h] [rbp+A0h]
  __int64 v24; // [rsp+128h] [rbp+A8h]
  __int64 v25; // [rsp+130h] [rbp+B0h]
  __int64 v26; // [rsp+138h] [rbp+B8h]
  __int64 v27; // [rsp+140h] [rbp+C0h]
  __int64 v28; // [rsp+148h] [rbp+C8h]
  __int64 v29; // [rsp+150h] [rbp+D0h]
  __int64 v30; // [rsp+158h] [rbp+D8h]
  int v31; // [rsp+160h] [rbp+E0h]
  int v32; // [rsp+170h] [rbp+F0h]
  int v33; // [rsp+174h] [rbp+F4h]
  int v34; // [rsp+178h] [rbp+F8h]
  int i; // [rsp+17Ch] [rbp+FCh]

  _main(argc, argv, envp);
  *(_QWORD *)Str = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v26 = 0i64;
  v27 = 0i64;
  v28 = 0i64;
  v29 = 0i64;
  v30 = 0i64;
  v31 = 0;
  *(_QWORD *)v6 = 0i64;
  v7 = 0i64;
  v8 = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0;
  memset(v4, 0, sizeof(v4));
  v5 = 0;
  v33 = 0;
  v32 = 0;
  i = 0;
  v34 = 0;
  printf("Enter the message you want to encrypt: ");
  scanf("%[^\n]s", Str);
  printf("Enter the encryption key: ");
  scanf("%s", v6);
  v33 = strlen(Str);
  v32 = strlen(v6);
  for ( i = 0; i < v33; ++i )
  {
    *((_BYTE *)v4 + i) = v6[v34++] ^ Str[i];
    if ( v34 == v32 )
      v34 = 0;
  }
  printf("\nEncrypted message: ");
  for ( i = 0; i < v33; ++i )
    printf("%c", (unsigned int)*((char *)v4 + i));
  printf("\n");
  return 0;
}
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature Converter ; Style: lively
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Display welcome message
    printf("*** Temperature Converter ***\n");

    // Variables for user input and converted temperature
    double temp, converted_temp;
    char unit;

    // Prompt user for temperature
    printf("Enter temperature: ");
    scanf("%lf", &temp);

    // Prompt user for temperature unit
    printf("Enter unit (C/F): ");
    scanf(" %c", &unit);

    // Determine conversion factor based on temperature unit
    double factor;
    if (unit == 'F' || unit == 'f') {
        factor = 5.0 / 9.0;
    } else if (unit == 'C' || unit == 'c') {
        factor = 9.0 / 5.0;
    } else {
        printf("Invalid unit. Exiting program.\n");
        exit(0);
    }

    // Convert temperature and display result
    if (unit == 'F' || unit == 'f') {
        converted_temp = (temp - 32.0) * factor;
        printf("%0.2f%cF is equivalent to %0.2f%cC\n", temp, unit, converted_temp, 'C');
    } else if (unit == 'C' || unit == 'c') {
        converted_temp = (temp * factor) + 32.0;
        printf("%0.2f%cC is equivalent to %0.2f%cF\n", temp, unit, converted_temp, 'F');
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-30h]
  int v5; // [rsp+20h] [rbp-30h]
  char v6; // [rsp+37h] [rbp-19h] BYREF
  double v7; // [rsp+38h] [rbp-18h] BYREF
  double v8; // [rsp+40h] [rbp-10h]
  double v9; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  printf("*** Temperature Converter ***\n");
  printf("Enter temperature: ");
  scanf("%lf", &v7);
  printf("Enter unit (C/F): ");
  scanf(" %c", &v6);
  if ( v6 == 70 || v6 == 102 )
  {
    v9 = 0.5555555555555556;
  }
  else
  {
    if ( v6 != 67 && v6 != 99 )
    {
      printf("Invalid unit. Exiting program.\n");
      exit(0);
    }
    v9 = 1.8;
  }
  if ( v6 == 70 || v6 == 102 )
  {
    v8 = (v7 - 32.0) * v9;
    v4 = 67;
    printf("%0.2f%cF is equivalent to %0.2f%cC\n", v7, (unsigned int)v6, v8, v4);
  }
  else
  {
    v8 = v7 * v9 + 32.0;
    v5 = 70;
    printf("%0.2f%cC is equivalent to %0.2f%cF\n", v7, (unsigned int)v6, v8, v5);
  }
  return 0;
}
// 140001724: conditional instruction was optimized away because %var_19.1==63
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text-Based Adventure Game ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Function prototypes
void clear_screen();
void wait_for_input();
void game_over();
void win_game();

int main()
{
    // Introduction
    printf("Welcome to 'The Quest for the Golden Key', a text-based adventure game!\n");
    printf("Your mission is to find the three pieces of the Golden Key and open the treasure chest to win the game.\n");
    printf("You are currently standing in front of a dark cave. Are you ready to begin?\n");
    wait_for_input();

    // Level 1 - The Cave
    clear_screen();
    printf("You enter the cave. It's dark and damp. You need to find a torch to light your way.\n");
    printf("As you walk deeper into the cave, you hear strange noises coming from the darkness.\n");
    wait_for_input();

    char choice[10];
    bool has_torch = false;
    int level = 1;
    while (true) {
        clear_screen();
        printf("LEVEL %d - The Cave\n", level);
        printf("You see two paths ahead of you. Which one will you take?\n");
        printf("1. Left path\n");
        printf("2. Right path\n");
        printf("3. Go back\n");
        fgets(choice, sizeof(choice), stdin);
        strtok(choice, "\n");

        if (strcmp(choice, "1") == 0) {
            printf("You follow the left path and come across a chest. Will you open it?\n");
            printf("1. Yes\n");
            printf("2. No\n");
            fgets(choice, sizeof(choice), stdin);
            strtok(choice, "\n");

            if (strcmp(choice, "1") == 0) {
                printf("The chest is empty.\n");
            } else {
                printf("You ignore the chest and continue on your journey.\n");
            }
        } else if (strcmp(choice, "2") == 0) {
            if (has_torch) {
                printf("You follow the right path and find a piece of the Golden Key!\n");
                printf("Congratulations, you have completed level %d!\n", level);
                level++;
                has_torch = false;
                wait_for_input();
                if (level > 3) {
                    win_game();
                    return 0;
                } else {
                    continue;
                }
            } else {
                printf("You need a torch to go down this path.\n");
                printf("You decide to turn back.\n");
                wait_for_input();
                continue;
            }
        } else if (strcmp(choice, "3") == 0) {
            if (level == 1) {
                printf("You cannot go back any further.\n");
            } else {
                level--;
                printf("You return to level %d.\n", level);
                wait_for_input();
            }
        } else {
            printf("Invalid input. Please try again.\n");
            wait_for_input();
        }

        if (!has_torch) {
            printf("You find a torch lying on the ground. Will you pick it up?\n");
            printf("1. Yes\n");
            printf("2. No\n");
            fgets(choice, sizeof(choice), stdin);
            strtok(choice, "\n");

            if (strcmp(choice, "1") == 0) {
                printf("You pick up the torch.\n");
                has_torch = true;
            } else {
                printf("You leave the torch behind.\n");
            }
        }
    }

    return 0;
}

void clear_screen() {
    system("clear");
}

void wait_for_input() {
    printf("Press enter to continue...");
    getchar();
}

void game_over() {
    printf("GAME OVER\n");
    printf("You have failed in your quest. Better luck next time!\n");
}

void win_game() {
    printf("CONGRATULATIONS!\n");
    printf("You have found all three pieces of the Golden Key and opened the treasure chest.\n");
    printf("You are rich beyond your wildest dreams!\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 clear_screen(void); // weak
__int64 wait_for_input(void); // weak
__int64 win_game(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  FILE *v6; // rax
  char Buffer[10]; // [rsp+2Eh] [rbp-12h] BYREF
  unsigned int v8; // [rsp+38h] [rbp-8h]
  char v9; // [rsp+3Fh] [rbp-1h]

  _main(argc, argv, envp);
  printf("Welcome to 'The Quest for the Golden Key', a text-based adventure game!\n");
  printf("Your mission is to find the three pieces of the Golden Key and open the treasure chest to win the game.\n");
  printf("You are currently standing in front of a dark cave. Are you ready to begin?\n");
  wait_for_input();
  clear_screen();
  printf("You enter the cave. It's dark and damp. You need to find a torch to light your way.\n");
  printf("As you walk deeper into the cave, you hear strange noises coming from the darkness.\n");
  wait_for_input();
  v9 = 0;
  v8 = 1;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        clear_screen();
        printf("LEVEL %d - The Cave\n", v8);
        printf("You see two paths ahead of you. Which one will you take?\n");
        printf("1. Left path\n");
        printf("2. Right path\n");
        printf("3. Go back\n");
        v3 = __acrt_iob_func(0);
        fgets(Buffer, 10, v3);
        strtok(Buffer, "\n");
        if ( strcmp(Buffer, "1") )
          break;
        printf("You follow the left path and come across a chest. Will you open it?\n");
        printf("1. Yes\n");
        printf("2. No\n");
        v4 = __acrt_iob_func(0);
        fgets(Buffer, 10, v4);
        strtok(Buffer, "\n");
        if ( !strcmp(Buffer, "1") )
          printf("The chest is empty.\n");
        else
          printf("You ignore the chest and continue on your journey.\n");
LABEL_16:
        if ( v9 != 1 )
        {
          printf("You find a torch lying on the ground. Will you pick it up?\n");
          printf("1. Yes\n");
          printf("2. No\n");
          v6 = __acrt_iob_func(0);
          fgets(Buffer, 10, v6);
          strtok(Buffer, "\n");
          if ( !strcmp(Buffer, "1") )
          {
            printf("You pick up the torch.\n");
            v9 = 1;
          }
          else
          {
            printf("You leave the torch behind.\n");
          }
        }
      }
      if ( strcmp(Buffer, "2") )
      {
        if ( !strcmp(Buffer, "3") )
        {
          if ( v8 == 1 )
          {
            printf("You cannot go back any further.\n");
          }
          else
          {
            printf("You return to level %d.\n", --v8);
            wait_for_input();
          }
        }
        else
        {
          printf("Invalid input. Please try again.\n");
          wait_for_input();
        }
        goto LABEL_16;
      }
      if ( v9 )
        break;
      printf("You need a torch to go down this path.\n");
      printf("You decide to turn back.\n");
      wait_for_input();
    }
    printf("You follow the right path and find a piece of the Golden Key!\n");
    printf("Congratulations, you have completed level %d!\n", v8++);
    v9 = 0;
    wait_for_input();
  }
  while ( (int)v8 <= 3 );
  win_game();
  return 0;
}
// 140001901: using guessed type __int64 clear_screen(void);
// 14000191F: using guessed type __int64 wait_for_input(void);
// 14000196F: using guessed type __int64 win_game(void);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#define ARRAY_SIZE 1000

int main(){

   // Initialize random seed
   srand((unsigned) time(NULL));

   // Generate a random dataset of 1000 values between 0 and 99
   int dataset[ARRAY_SIZE];
   for(int i = 0; i < ARRAY_SIZE; i++){
      dataset[i] = rand() % 100;
   }

   // Calculate the mean of the dataset
   float sum = 0;
   float mean = 0;
   for(int i = 0; i < ARRAY_SIZE; i++){
      sum += dataset[i];
   }
   mean = sum / ARRAY_SIZE;
   printf("Mean: %f\n", mean);

   // Calculate the standard deviation of the dataset
   float variance = 0;
   float deviation = 0;
   for(int i = 0; i < ARRAY_SIZE; i++){
      variance += pow(dataset[i] - mean, 2);
   }
   variance /= ARRAY_SIZE;
   deviation = sqrt(variance);
   printf("Standard Deviation: %f\n", deviation);

   // Calculate the median of the dataset
   int temp = 0;
   for(int i = 0; i < ARRAY_SIZE-1; i++){
      for(int j = 0; j < ARRAY_SIZE-i-1; j++){
         if(dataset[j] > dataset[j+1]){
            temp = dataset[j];
            dataset[j] = dataset[j+1];
            dataset[j+1] = temp;
         }
      }
   }
   float median = 0;
   if(ARRAY_SIZE % 2 == 0){
      median = (dataset[ARRAY_SIZE/2] + dataset[ARRAY_SIZE/2-1]) / 2.0;
   } else{
      median = dataset[ARRAY_SIZE/2];
   }
   printf("Median: %f\n", median);

   // Calculate the mode of the dataset
   int mode = 0;
   int count = 0;
   int max_count = 0;
   for(int i = 0; i < ARRAY_SIZE; i++){
      count = 0;
      for(int j = i; j < ARRAY_SIZE; j++){
         if(dataset[j] == dataset[i]){
            count++;
         }
      }
      if(count > max_count){
         mode = dataset[i];
         max_count = count;
      }
   }
   printf("Mode: %d\n", mode);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl pow(double X, double Y);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  double v4; // xmm0_8
  float v5; // xmm0_4
  int v6; // xmm0_4
  int v8[1001]; // [rsp+20h] [rbp-60h]
  int v9; // [rsp+FC4h] [rbp+F44h]
  float v10; // [rsp+FC8h] [rbp+F48h]
  float v11; // [rsp+FCCh] [rbp+F4Ch]
  int jj; // [rsp+FD0h] [rbp+F50h]
  int ii; // [rsp+FD4h] [rbp+F54h]
  int v14; // [rsp+FD8h] [rbp+F58h]
  int v15; // [rsp+FDCh] [rbp+F5Ch]
  unsigned int v16; // [rsp+FE0h] [rbp+F60h]
  int n; // [rsp+FE4h] [rbp+F64h]
  int m; // [rsp+FE8h] [rbp+F68h]
  int k; // [rsp+FECh] [rbp+F6Ch]
  float v20; // [rsp+FF0h] [rbp+F70h]
  int j; // [rsp+FF4h] [rbp+F74h]
  float v22; // [rsp+FF8h] [rbp+F78h]
  int i; // [rsp+FFCh] [rbp+F7Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 999; ++i )
    v8[i] = rand() % 100;
  v22 = 0.0;
  v11 = 0.0;
  for ( j = 0; j <= 999; ++j )
    v22 = (float)v8[j] + v22;
  v11 = v22 / 1000.0;
  printf("Mean: %f\n", (float)(v22 / 1000.0));
  v20 = 0.0;
  v10 = 0.0;
  for ( k = 0; k <= 999; ++k )
  {
    v4 = pow((float)((float)v8[k] - v11), 2.0);
    *(float *)&v4 = v4 + v20;
    v20 = *(float *)&v4;
  }
  v20 = v20 / 1000.0;
  v5 = sqrt(v20);
  v10 = v5;
  printf("Standard Deviation: %f\n", v5);
  v9 = 0;
  for ( m = 0; m <= 998; ++m )
  {
    for ( n = 0; n < 999 - m; ++n )
    {
      if ( v8[n] > v8[n + 1] )
      {
        v9 = v8[n];
        v8[n] = v8[n + 1];
        v8[n + 1] = v9;
      }
    }
  }
  *(float *)&v6 = (double)(v8[500] + v8[499]) / 2.0;
  v8[1000] = v6;
  printf("Median: %f\n", *(float *)&v6);
  v16 = 0;
  v15 = 0;
  v14 = 0;
  for ( ii = 0; ii <= 999; ++ii )
  {
    v15 = 0;
    for ( jj = ii; jj <= 999; ++jj )
    {
      if ( v8[jj] == v8[ii] )
        ++v15;
    }
    if ( v15 > v14 )
    {
      v16 = v8[ii];
      v14 = v15;
    }
  }
  printf("Mode: %d\n", v16);
  return 0;
}
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

struct fitnessData {
    float weight;
    int steps;
    float caloriesBurned;
};

int main() {
    int currentDay = 1;
    struct fitnessData weekData[7]; // for 7 days of the week
    srand(time(NULL)); // for random data

    // loop to collect data for a week
    while (currentDay <= 7) {
        printf("\nDay %d\n", currentDay);

        // collect weight data
        printf("Enter your weight for the day (kg): ");
        scanf("%f", &weekData[currentDay-1].weight);

        // collect step data
        printf("Enter the steps taken for the day: ");
        scanf("%d", &weekData[currentDay-1].steps);

        // calculate calories burned with a random factor
        float calories = weekData[currentDay-1].steps / 20.0;
        calories *= (rand() % 30 + 70) / 100.0;
        weekData[currentDay-1].caloriesBurned = calories;

        currentDay++;
    }

    // print the data for the week
    printf("\nWeek's Data:\n");
    printf("Day | Weight | Steps | Calories Burned\n");
    for (int i = 0; i < 7; i++) {
        printf("%d | %.2f | %d | %.2f\n", i+1, weekData[i].weight, weekData[i].steps, weekData[i].caloriesBurned);
    }

    // calculate weekly averages
    float totalWeight = 0, totalSteps = 0, totalCalories = 0;
    for (int i = 0; i < 7; i++) {
        totalWeight += weekData[i].weight;
        totalSteps += weekData[i].steps;
        totalCalories += weekData[i].caloriesBurned;
    }
    float weightAvg = totalWeight / 7.0;
    float stepsAvg = totalSteps / 7.0;
    float caloriesAvg = totalCalories / 7.0;

    printf("\nWeekly Averages:\n");
    printf("Weight: %.2f kg\n", weightAvg);
    printf("Steps: %.2f\n", stepsAvg);
    printf("Calories Burned: %.2f\n", caloriesAvg);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v7[22]; // [rsp+30h] [rbp-80h] BYREF
  float v8; // [rsp+88h] [rbp-28h]
  float v9; // [rsp+8Ch] [rbp-24h]
  float v10; // [rsp+90h] [rbp-20h]
  float v11; // [rsp+94h] [rbp-1Ch]
  int j; // [rsp+98h] [rbp-18h]
  float v13; // [rsp+9Ch] [rbp-14h]
  float v14; // [rsp+A0h] [rbp-10h]
  float v15; // [rsp+A4h] [rbp-Ch]
  int i; // [rsp+A8h] [rbp-8h]
  unsigned int v17; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v17 = 1;
  v3 = time(0i64);
  srand(v3);
  while ( (int)v17 <= 7 )
  {
    printf("\nDay %d\n", v17);
    printf("Enter your weight for the day (kg): ");
    scanf("%f", &v7[3 * (v17 - 1)]);
    printf("Enter the steps taken for the day: ");
    scanf("%d", &v7[3 * (v17 - 1) + 1]);
    v4 = (double)SLODWORD(v7[3 * (v17 - 1) + 1]) / 20.0;
    v8 = v4;
    v5 = v4 * ((double)(rand() % 30 + 70) / 100.0);
    v8 = v5;
    v7[3 * (v17++ - 1) + 2] = v5;
  }
  printf("\nWeek's Data:\n");
  printf("Day | Weight | Steps | Calories Burned\n");
  for ( i = 0; i <= 6; ++i )
    printf("%d | %.2f | %d | %.2f\n", (unsigned int)(i + 1), v7[3 * i], v7[3 * i + 1], v7[3 * i + 2]);
  v15 = 0.0;
  v14 = 0.0;
  v13 = 0.0;
  for ( j = 0; j <= 6; ++j )
  {
    v15 = v7[3 * j] + v15;
    v14 = (float)SLODWORD(v7[3 * j + 1]) + v14;
    v13 = v7[3 * j + 2] + v13;
  }
  v11 = v15 / 7.0;
  v10 = v14 / 7.0;
  v9 = v13 / 7.0;
  printf("\nWeekly Averages:\n");
  printf("Weight: %.2f kg\n", v11);
  printf("Steps: %.2f\n", v10);
  printf("Calories Burned: %.2f\n", v9);
  return 0;
}
// 140001AB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001601: using guessed type float var_80[22];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

double calculate_speed();

int main(){
    srand(time(NULL)); //initialize random seed
    
    double speed = calculate_speed();
    
    printf("Your internet speed is %.2f Mbps\n", speed);
    
    return 0;
}

double calculate_speed(){
    double max = 100.0;
    double min = 5.0;
    
    double random_num = (rand()/(double)RAND_MAX)*(max-min) + min; //generate random number between min and max
    
    return random_num;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
double calculate_speed(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  double v4; // xmm0_8

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v4 = calculate_speed();
  printf("Your internet speed is %.2f Mbps\n", v4);
  return 0;
}
// 140001606: using guessed type double calculate_speed(void);
// 140001730: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[50];
    int quantity;
} Item;

typedef struct {
    Item items[100];
    int count;
} Inventory;

typedef struct {
    char name[50];
    Inventory* inventory;
} Warehouse;

void add_item(Warehouse* warehouse, char* name, int quantity) {
    for (int i = 0; i < warehouse->inventory->count; i++) {
        if (strcmp(name, warehouse->inventory->items[i].name) == 0) {
            warehouse->inventory->items[i].quantity += quantity;
            printf("%d units of %s added to %s.\n", quantity, name, warehouse->name);
            return;
        }
    }
    if (warehouse->inventory->count >= 100) {
        printf("Error: Warehouse inventory is full.\n");
        return;
    }
    Item item;
    strncpy(item.name, name, sizeof(item.name));
    item.quantity = quantity;
    warehouse->inventory->items[warehouse->inventory->count++] = item;
    printf("%d units of %s added to %s.\n", quantity, name, warehouse->name);
}

void remove_item(Warehouse* warehouse, char* name, int quantity) {
    for (int i = 0; i < warehouse->inventory->count; i++) {
        if (strcmp(name, warehouse->inventory->items[i].name) == 0) {
            if (warehouse->inventory->items[i].quantity >= quantity) {
                warehouse->inventory->items[i].quantity -= quantity;
                printf("%d units of %s removed from %s.\n", quantity, name, warehouse->name);
                if (warehouse->inventory->items[i].quantity == 0) {
                    for (int j = i; j < warehouse->inventory->count - 1; j++) {
                        warehouse->inventory->items[j] = warehouse->inventory->items[j+1];
                    }
                    warehouse->inventory->count--;
                }
            } else {
                printf("Error: Not enough units of %s in %s.\n", name, warehouse->name);
            }
            return;
        }
    }
    printf("Error: %s does not have %s in inventory.\n", warehouse->name, name);
}

void move_item(Warehouse* source, Warehouse* destination, char* name, int quantity) {
    for (int i = 0; i < source->inventory->count; i++) {
        if (strcmp(name, source->inventory->items[i].name) == 0) {
            if (source->inventory->items[i].quantity >= quantity) {
                remove_item(source, name, quantity);
                add_item(destination, name, quantity);
                printf("%d units of %s moved from %s to %s.\n", quantity, name, source->name, destination->name);
            } else {
                printf("Error: Not enough units of %s in %s.\n", name, source->name);
            }
            return;
        }
    }
    printf("Error: %s does not have %s in inventory.\n", source->name, name);
}

int main() {
    Inventory inventory1 = {.count = 0};
    Inventory inventory2 = {.count = 0};
    Warehouse warehouse1 = {.name = "Warehouse 1", .inventory = &inventory1};
    Warehouse warehouse2 = {.name = "Warehouse 2", .inventory = &inventory2};

    add_item(&warehouse1, "Laptop", 10);
    add_item(&warehouse1, "Tablet", 20);
    add_item(&warehouse2, "Laptop", 5);

    remove_item(&warehouse1, "Laptop", 3);
    remove_item(&warehouse1, "Tablet", 25);

    move_item(&warehouse1, &warehouse2, "Laptop", 4);
    move_item(&warehouse2, &warehouse1, "Tablet", 15);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall add_item(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall remove_item(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall move_item(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001AC1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[6]; // [rsp+20h] [rbp-60h] BYREF
  __int16 v5; // [rsp+50h] [rbp-30h]
  char *v6; // [rsp+58h] [rbp-28h]
  __int64 v7[6]; // [rsp+60h] [rbp-20h] BYREF
  __int16 v8; // [rsp+90h] [rbp+10h]
  char *v9; // [rsp+98h] [rbp+18h]
  char v10[5600]; // [rsp+A0h] [rbp+20h] BYREF
  int v11; // [rsp+1680h] [rbp+1600h]
  char v12[5600]; // [rsp+1690h] [rbp+1610h] BYREF
  int v13; // [rsp+2C70h] [rbp+2BF0h]

  _main(argc, argv, envp);
  memset(v12, 0, sizeof(v12));
  v13 = 0;
  memset(v10, 0, sizeof(v10));
  v11 = 0;
  v7[0] = 0x73756F6865726157i64;
  v7[1] = 3219557i64;
  memset(&v7[2], 0, 32);
  v8 = 0;
  v9 = v12;
  v4[0] = 0x73756F6865726157i64;
  v4[1] = 3285093i64;
  memset(&v4[2], 0, 32);
  v5 = 0;
  v6 = v10;
  add_item(v7, "Laptop", 10i64);
  add_item(v7, "Tablet", 20i64);
  add_item(v4, "Laptop", 5i64);
  remove_item(v7, "Laptop", 3i64);
  remove_item(v7, "Tablet", 25i64);
  move_item(v7, v4, "Laptop", 4i64);
  move_item(v4, v7, "Tablet", 15i64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall add_item(_QWORD, _QWORD, _QWORD);
// 14000174D: using guessed type __int64 __fastcall remove_item(_QWORD, _QWORD, _QWORD);
// 140001988: using guessed type __int64 __fastcall move_item(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001D20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: romantic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() 
{
    char name[20];
    int birth_year, curr_year, age, lucky_number, fortune;

    printf("Welcome to the Love and Destiny Fortune Teller Program.\n");
    printf("Please enter your name: ");
    scanf("%s", name);
    printf("Please enter your birth year: ");
    scanf("%d", &birth_year);
    printf("Please enter the current year: ");
    scanf("%d", &curr_year);

    age = curr_year - birth_year;

    printf("You are %d years old, %s.\n", age, name);
    printf("Now, please enter a number between 1 and 100: ");
    scanf("%d", &lucky_number);

    srand(time(0));
    fortune = rand() % 5;
    switch(fortune)
    {
        case 0:
            printf("\nYour destiny awaits...");
            printf("\n\n%s, it is written in the stars that you will meet your soulmate in the near future.\n", name);
            printf("You must be patient and believe in true love. Remember, good things come to those who wait.\n");
            printf("Your lucky number %d will bring you great fortune in all aspects of your life.\n", lucky_number);
            break;

        case 1:
            printf("\nYour destiny awaits...");
            printf("\n\n%s, you will soon encounter a difficult decision regarding love.\n", name);
            printf("Remember to listen to your heart and trust your instincts.\n");
            printf("Your lucky number %d will guide you towards making the right choice.\n", lucky_number);
            break;

        case 2:
            printf("\nYour destiny awaits...");
            printf("\n\n%s, you may face some obstacles in your love life in the upcoming days.\n", name);
            printf("But please don't lose heart. Remember, true love never runs smooth.\n");
            printf("Your lucky number %d will be your guide through the tough times.\n", lucky_number);
            break;

        case 3:
            printf("\nYour destiny awaits...");
            printf("\n\n%s, your romantic life will be filled with passion and excitement in the coming days.\n", name);
            printf("You will experience things you never thought possible.\n");
            printf("Your lucky number %d will bring you the love and happiness you deserve.\n", lucky_number);
            break;

        case 4:
            printf("\nYour destiny awaits...");
            printf("\n\n%s, your love life will take a surprising turn in the upcoming weeks.\n", name);
            printf("Be ready for a twist in the plot... this could be just what you need to find your true soulmate.\n");
            printf("Your lucky number %d will play a crucial role in this new chapter of your life.\n", lucky_number);
            break;

        default:
            printf("\nHmmm... something seems off.");
            printf("\nPlease try again later.");
            break;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+24h] [rbp-2Ch] BYREF
  int v6; // [rsp+28h] [rbp-28h] BYREF
  int v7; // [rsp+2Ch] [rbp-24h] BYREF
  char v8[24]; // [rsp+30h] [rbp-20h] BYREF
  int v9; // [rsp+48h] [rbp-8h]
  int v10; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Love and Destiny Fortune Teller Program.\n");
  printf("Please enter your name: ");
  scanf("%s", v8);
  printf("Please enter your birth year: ");
  scanf("%d", &v7);
  printf("Please enter the current year: ");
  scanf("%d", &v6);
  v10 = v6 - v7;
  printf("You are %d years old, %s.\n", (unsigned int)(v6 - v7), v8);
  printf("Now, please enter a number between 1 and 100: ");
  scanf("%d", &v5);
  v3 = time(0i64);
  srand(v3);
  v9 = rand() % 5;
  switch ( v9 )
  {
    case 0:
      printf("\nYour destiny awaits...");
      printf("\n\n%s, it is written in the stars that you will meet your soulmate in the near future.\n", v8);
      printf("You must be patient and believe in true love. Remember, good things come to those who wait.\n");
      printf("Your lucky number %d will bring you great fortune in all aspects of your life.\n", v5);
      break;
    case 1:
      printf("\nYour destiny awaits...");
      printf("\n\n%s, you will soon encounter a difficult decision regarding love.\n", v8);
      printf("Remember to listen to your heart and trust your instincts.\n");
      printf("Your lucky number %d will guide you towards making the right choice.\n", v5);
      break;
    case 2:
      printf("\nYour destiny awaits...");
      printf("\n\n%s, you may face some obstacles in your love life in the upcoming days.\n", v8);
      printf("But please don't lose heart. Remember, true love never runs smooth.\n");
      printf("Your lucky number %d will be your guide through the tough times.\n", v5);
      break;
    case 3:
      printf("\nYour destiny awaits...");
      printf("\n\n%s, your romantic life will be filled with passion and excitement in the coming days.\n", v8);
      printf("You will experience things you never thought possible.\n");
      printf("Your lucky number %d will bring you the love and happiness you deserve.\n", v5);
      break;
    case 4:
      printf("\nYour destiny awaits...");
      printf("\n\n%s, your love life will take a surprising turn in the upcoming weeks.\n", v8);
      printf("Be ready for a twist in the plot... this could be just what you need to find your true soulmate.\n");
      printf("Your lucky number %d will play a crucial role in this new chapter of your life.\n", v5);
      break;
    default:
      printf("\nHmmm... something seems off.");
      printf("\nPlease try again later.");
      break;
  }
  return 0;
}
// 1400019A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#define N 20 // number of nodes per side
#define seed 111 // seed for srand function
#define p 0.6 // probability of a node being occupied

// function to randomly occupy nodes
void populate_lattice(int *lattice) {
    int i, j;
    double r;
    srand(seed);

    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            r = ((double)rand() / (double)RAND_MAX);
            if (r <= p) {
                *(lattice + i*N + j) = 1; // occupy node
            }
        }
    }
}

// function to print lattice
void print_lattice(int *lattice) {
    int i, j;
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            if (*(lattice + i*N + j) == 1) {
                printf("X ");
            } else {
                printf("O ");
            }
        }
        printf("\n");
    }
}

// function to calculate number of occupied nodes in cluster
int find_cluster_size(int *lattice, int i, int j) {
    if (i < 0 || i >= N || j < 0 || j >= N) {
        return 0;
    } else if (*(lattice + i*N + j) == 0) {
        return 0;
    } else {
        *(lattice + i*N + j) = 0; // mark node as visited
        return 1 + find_cluster_size(lattice, i+1, j) + find_cluster_size(lattice, i-1, j)
               + find_cluster_size(lattice, i, j+1) + find_cluster_size(lattice, i, j-1);
    }
}

// function to find largest cluster in lattice
int find_largest_cluster(int *lattice) {
    int i, j, size, max_size = 0;
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            if (*(lattice + i*N + j) == 1) {
                size = find_cluster_size(lattice, i, j);
                if (size > max_size) {
                    max_size = size;
                }
            }
        }
    }
    return max_size;
}

int main() {
    int lattice[N][N] = {0};
    int largest_cluster_size;
    populate_lattice((int*)lattice);
    printf("Lattice:\n");
    print_lattice((int*)lattice);
    largest_cluster_size = find_largest_cluster((int*)lattice);
    printf("Largest Cluster Size: %d\n", largest_cluster_size);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall populate_lattice(_QWORD, _QWORD); // weak
__int64 __fastcall print_lattice(_QWORD); // weak
__int64 __fastcall find_largest_cluster(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001863) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[1612]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int largest_cluster; // [rsp+66Ch] [rbp+5ECh]

  _main(argc, argv, envp);
  memset(v4, 0, 0x640ui64);
  populate_lattice(v4, v4);
  printf("Lattice:\n");
  print_lattice(v4);
  largest_cluster = find_largest_cluster(v4);
  printf("Largest Cluster Size: %d\n", largest_cluster);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall populate_lattice(_QWORD, _QWORD);
// 14000162F: using guessed type __int64 __fastcall print_lattice(_QWORD);
// 1400017CE: using guessed type __int64 __fastcall find_largest_cluster(_QWORD);
// 1400019A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Linked list operations ; Style: immersive
#include <stdio.h>
#include <stdlib.h>

// Defining a structure to represent a node in the linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to display the linked list
void displayList(struct Node* head) {
    struct Node* currentNode = head;

    printf("Linked List: ");

    while(currentNode != NULL) {
        printf("%d -> ", currentNode->data);
        currentNode = currentNode->next;
    }

    printf("NULL\n");
}

// Function to add a new node at the beginning of the linked list
void push(struct Node** head, int data) {
    // Allocating memory for the new node
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));

    // Setting the data of the new node
    newNode->data = data;

    // Setting the next pointer of the new node
    newNode->next = (*head);

    // Updating the head of the linked list
    (*head) = newNode;

    printf("New node with data %d added at the beginning of the linked list.\n", data);
}

// Function to add a new node at the end of the linked list
void append(struct Node** head, int data) {
    // Allocating memory for the new node
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));

    // Setting the data of the new node
    newNode->data = data;

    // Setting the next pointer of the new node to NULL
    newNode->next = NULL;

    // Checking if the linked list is empty
    if(*head == NULL) {
        // If linked list is empty, set the new node as the head of the linked list
        *head = newNode;

        printf("New node with data %d added at the end of the linked list.\n", data);
        return;
    }

    // Traverse to the last node of the linked list
    struct Node* lastNode = *head;
    while(lastNode->next != NULL) {
        lastNode = lastNode->next;
    }

    // Attach the new node to the end of the linked list
    lastNode->next = newNode;

    printf("New node with data %d added at the end of the linked list.\n", data);
}

// Function to insert a new node at a specific position in the linked list
void insert(struct Node** head, int data, int position) {
    // Allocating memory for the new node
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));

    // Setting the data of the new node
    newNode->data = data;

    // Setting a pointer to the previous node
    struct Node* previousNode = NULL;

    // Setting a pointer to the current node
    struct Node* currentNode = *head;

    // Checking if the linked list is empty
    if(*head == NULL) {
        // If the linked list is empty, set the new node as the head of the linked list
        *head = newNode;

        printf("New node with data %d added at position %d of the linked list.\n", data, position);
        return;
    }

    // Traverse to the position where the new node needs to be inserted
    int currentPosition = 0;
    while(currentPosition != position && currentNode != NULL) {
        previousNode = currentNode;
        currentNode = currentNode->next;
        currentPosition++;
    }

    // If the position is greater than the length of the linked list, insert the new node at the end of the linked list
    if(currentPosition < position) {
        previousNode->next = newNode;
        newNode->next = NULL;

        printf("New node with data %d added at position %d of the linked list.\n", data, currentPosition + 1);
        return;
    }

    // If the position is at the beginning of the linked list, set the new node as the head of the linked list
    if(previousNode == NULL) {
        *head = newNode;
    }
    // Otherwise, insert the new node in between two nodes
    else {
        previousNode->next = newNode;
    }

    newNode->next = currentNode;

    printf("New node with data %d added at position %d of the linked list.\n", data, currentPosition + 1);
}

// Function to delete a node at a specific position in the linked list
void deleteNode(struct Node** head, int position) {
    // Setting a pointer to the previous node
    struct Node* previousNode = NULL;

    // Setting a pointer to the current node
    struct Node* currentNode = *head;

    // Checking if the linked list is empty
    if(*head == NULL) {
        printf("Linked list is empty.\n");
        return;
    }

    // Traverse to the position of the node to be deleted
    int currentPosition = 0;
    while(currentPosition != position && currentNode != NULL) {
        previousNode = currentNode;
        currentNode = currentNode->next;
        currentPosition++;
    }

    // If the position is greater than or equal to the length of the linked list, display an error message
    if(currentNode == NULL) {
        printf("Invalid position.\n");
        return;
    }

    // If the node to be deleted is the head of the linked list, set the next node as the new head
    if(previousNode == NULL) {
        *head = currentNode->next;
    }
    // Otherwise, connect the previous node to the next node, skipping the current node
    else {
        previousNode->next = currentNode->next;
    }

    printf("Node at position %d deleted from the linked list.\n", currentPosition + 1);

    // Freeing memory occupied by the deleted node
    free(currentNode);
}

int main() {
    struct Node* head = NULL;

    // Adding nodes to the linked list
    append(&head, 1);
    append(&head, 2);
    push(&head, 0);
    insert(&head, 3, 3);
    displayList(head);

    // Deleting nodes from the linked list
    deleteNode(&head, 2);
    deleteNode(&head, 3);
    displayList(head);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall displayList(_QWORD); // weak
__int64 __fastcall push(_QWORD, _QWORD); // weak
__int64 __fastcall append(_QWORD, _QWORD); // weak
__int64 __fastcall insert(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall deleteNode(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000190B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v4 = 0i64;
  append(&v4, 1i64);
  append(&v4, 2i64);
  push(&v4, 0i64);
  insert(&v4, 3i64, 3i64);
  displayList(v4);
  deleteNode(&v4, 2i64);
  deleteNode(&v4, 3i64);
  displayList(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall displayList(_QWORD);
// 1400015F6: using guessed type __int64 __fastcall push(_QWORD, _QWORD);
// 140001651: using guessed type __int64 __fastcall append(_QWORD, _QWORD);
// 1400016FD: using guessed type __int64 __fastcall insert(_QWORD, _QWORD, _QWORD);
// 14000182F: using guessed type __int64 __fastcall deleteNode(_QWORD, _QWORD);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: unmistakable
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

bool isPrime(int num);

int main()
{
    int num, i;

    printf("Enter a positive integer: ");
    scanf("%d", &num);

    printf("Prime numbers up to %d are: ", num);

    for (i = 2; i <= num; i++)
    {
        if (isPrime(i))
        {
            printf("%d ", i);
        }
    }

    return 0;
}

bool isPrime(int num)
{
    int i;

    if (num == 2)
    {
        return true;
    }

    if (num % 2 == 0 || num == 1)
    {
        return false;
    }

    for (i = 3; i * i <= num; i += 2)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall isPrime(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-8h] BYREF
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter a positive integer: ");
  scanf("%d", &v4);
  printf("Prime numbers up to %d are: ", v4);
  for ( i = 2; (int)i <= (int)v4; ++i )
  {
    if ( (unsigned __int8)isPrime(i) )
      printf("%d ", i);
  }
  return 0;
}
// 14000166A: using guessed type __int64 __fastcall isPrime(_QWORD);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Auction System ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct BidderInfo{
    char name[50];
    int bid;
} BidderInfo;

typedef struct Auction{
    int highestBid;
    BidderInfo *highestBidder;
} Auction;

int main(){
    Auction auction;
    auction.highestBid = 0;
    auction.highestBidder = NULL;

    int numBidders;
    printf("Enter number of bidders: ");
    scanf("%d", &numBidders);

    BidderInfo *bidders = (BidderInfo*) malloc(numBidders * sizeof(BidderInfo));
    for(int i=0; i<numBidders; i++){
        printf("Enter name of bidder %d: ", i+1);
        scanf("%s", bidders[i].name);

        printf("Enter bid of bidder %d: ", i+1);
        scanf("%d", &bidders[i].bid);
    }

    for(int i=0; i<numBidders; i++){
        if(bidders[i].bid > auction.highestBid){
            auction.highestBid = bidders[i].bid;
            auction.highestBidder = &bidders[i];
        }
    }

    printf("Auction winner is %s with a bid of %d\n", 
            auction.highestBidder->name, auction.highestBid);

    free(bidders);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-24h] BYREF
  unsigned int v5; // [rsp+30h] [rbp-20h]
  const char *v6; // [rsp+38h] [rbp-18h]
  void *Block; // [rsp+40h] [rbp-10h]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5 = 0;
  v6 = 0i64;
  printf("Enter number of bidders: ");
  scanf("%d", &v4);
  Block = malloc(56i64 * v4);
  for ( i = 0; i < v4; ++i )
  {
    printf("Enter name of bidder %d: ", (unsigned int)(i + 1));
    scanf("%s", (char *)Block + 56 * i);
    printf("Enter bid of bidder %d: ", (unsigned int)(i + 1));
    scanf("%d", (char *)Block + 56 * i + 52);
  }
  for ( j = 0; j < v4; ++j )
  {
    if ( *((_DWORD *)Block + 14 * j + 13) > (signed int)v5 )
    {
      v5 = *((_DWORD *)Block + 14 * j + 13);
      v6 = (char *)Block + 56 * j;
    }
  }
  printf("Auction winner is %s with a bid of %d\n", v6, v5);
  free(Block);
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mortgage Calculator ; Style: energetic
#include <stdio.h>

int main() {
    float loan_amount, interest_rate, monthly_payment;
    int loan_period;
    printf("Welcome to the Mortgage Calculator!\n");
    printf("Please enter your loan amount: $");
    scanf("%f", &loan_amount);
    printf("Please enter your interest rate: ");
    scanf("%f", &interest_rate);
    printf("Please enter your loan period in years: ");
    scanf("%d", &loan_period);
    interest_rate /= 1200;  // convert annual interest rate to monthly interest rate
    monthly_payment = loan_amount * interest_rate / (1 - 1 / pow(1 + interest_rate, loan_period * 12));
    printf("\nYour monthly payment for a $%.2f loan at %.2f%% interest rate for %d years is: $%.2f\n", 
           loan_amount, interest_rate * 1200, loan_period, monthly_payment);
    printf("\nThank you for using the Mortgage Calculator!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm6_8
  int v4; // xmm0_4
  unsigned int v6; // [rsp+30h] [rbp-10h] BYREF
  float v7; // [rsp+34h] [rbp-Ch] BYREF
  int v8[2]; // [rsp+38h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Mortgage Calculator!\n");
  printf("Please enter your loan amount: $");
  scanf("%f", v8);
  printf("Please enter your interest rate: ");
  scanf("%f", &v7);
  printf("Please enter your loan period in years: ");
  scanf("%d", &v6);
  v7 = v7 / 1200.0;
  v3 = (float)(v7 * *(float *)v8);
  *(float *)&v4 = v3 / (1.0 - 1.0 / pow((float)(v7 + 1.0), (double)(int)(12 * v6)));
  v8[1] = v4;
  printf(
    "\nYour monthly payment for a $%.2f loan at %.2f%% interest rate for %d years is: $%.2f\n",
    *(float *)v8,
    (float)(1200.0 * v7),
    v6,
    *(float *)&v4);
  printf("\nThank you for using the Mortgage Calculator!\n");
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: detailed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structures
typedef struct {
    int id;
    char name[50];
    float price;
} Product;

typedef struct {
    Product *product;
    int quantity;
} Order;

typedef struct {
    int id;
    char name[50];
    float total;
    Order *orders;
    int ordersCount;
} Table;

// Functions
void printMenu(Product *products, int size) {
    printf("Menu\n");
    printf("----\n");
    for(int i = 0; i < size; i++) {
        printf("%d. %-20s - $%.2f\n", products[i].id, products[i].name, products[i].price);
    }
}

int selectProduct(Product *products, int size) {
    int choice;
    do {
        printf("Enter product ID: ");
        scanf("%d", &choice);
        // Check if choice is valid
        for(int i = 0; i < size; i++) {
            if(products[i].id == choice) {
                return i; // Return index
            }
        }
        printf("Invalid choice, please try again.\n");
    } while(1);
}

int selectTable(Table *tables, int size) {
    int choice;
    do {
        printf("Enter table ID: ");
        scanf("%d", &choice);
        // Check if choice is valid
        for(int i = 0; i < size; i++) {
            if(tables[i].id == choice) {
                return i; // Return index
            }
        }
        printf("Invalid choice, please try again.\n");
    } while(1);
}

void addToOrder(Order *order, Product *product) {
    order->product = product;
    order->quantity++;
}

void printOrder(Order *orders, int size) {
    float total = 0;
    printf("Order\n");
    printf("-----\n");
    for(int i = 0; i < size; i++) {
        printf("%d x %-20s - $%.2f\n", orders[i].quantity, orders[i].product->name, orders[i].product->price * orders[i].quantity);
        total += orders[i].product->price * orders[i].quantity;
    }
    printf("Total: $%.2f\n", total);
}

void printTables(Table *tables, int size) {
    printf("Tables\n");
    printf("------\n");
    for(int i = 0; i < size; i++) {
        printf("%d. %-20s - $%.2f\n", tables[i].id, tables[i].name, tables[i].total);
    }
}

int main() {
    // Initialize products
    Product products[5] = {
        {1, "Coffee", 2.50},
        {2, "Tea", 2.00},
        {3, "Juice", 3.00},
        {4, "Sandwich", 5.00},
        {5, "Cake", 4.00}
    };
    int productsSize = sizeof(products) / sizeof(Product);

    // Initialize tables
    Table tables[3] = {
        {1, "Table 1", 0, NULL, 0},
        {2, "Table 2", 0, NULL, 0},
        {3, "Table 3", 0, NULL, 0}
    };
    int tablesSize = sizeof(tables) / sizeof(Table);

    int choice;
    int tableIndex;
    int productIndex;

    while(1) {
        // Print main menu
        printf("\nMain Menu\n");
        printf("---------\n");
        printf("1. View menu\n");
        printf("2. Take order\n");
        printf("3. View tables\n");
        printf("4. Exit\n");

        printf("Enter choice: ");
        scanf("%d", &choice);

        switch(choice) {
            case 1:
                // View menu
                printMenu(products, productsSize);
                break;
            case 2:
                // Take order
                tableIndex = selectTable(tables, tablesSize);
                productIndex = selectProduct(products, productsSize);
                addToOrder(&tables[tableIndex].orders[tables[tableIndex].ordersCount], &products[productIndex]);
                tables[tableIndex].ordersCount++;
                printf("Order added to table %d.\n", tables[tableIndex].id);
                break;
            case 3:
                // View tables
                printTables(tables, tablesSize);
                tableIndex = selectTable(tables, tablesSize);
                printOrder(tables[tableIndex].orders, tables[tableIndex].ordersCount);
                break;
            case 4:
                // Exit
                printf("Goodbye!\n");
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
                break;
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall printMenu(_QWORD, _QWORD); // weak
__int64 __fastcall selectProduct(_QWORD, _QWORD); // weak
__int64 __fastcall selectTable(_QWORD, _QWORD); // weak
__int64 __fastcall addToOrder(_QWORD, _QWORD); // weak
__int64 __fastcall printOrder(_QWORD, _QWORD); // weak
__int64 __fastcall printTables(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_140014020; // weak


//----- (0000000140001A52) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+2Ch] [rbp-54h] BYREF
  int v4; // [rsp+30h] [rbp-50h] BYREF
  __int64 v5; // [rsp+34h] [rbp-4Ch]
  __int64 v6; // [rsp+3Ch] [rbp-44h]
  __int64 v7; // [rsp+44h] [rbp-3Ch]
  __int64 v8; // [rsp+4Ch] [rbp-34h]
  __int64 v9; // [rsp+54h] [rbp-2Ch]
  __int64 v10; // [rsp+5Ch] [rbp-24h]
  __int16 v11; // [rsp+64h] [rbp-1Ch]
  int v12; // [rsp+68h] [rbp-18h]
  __int64 v13; // [rsp+70h] [rbp-10h]
  int v14; // [rsp+78h] [rbp-8h]
  int v15; // [rsp+80h] [rbp+0h] BYREF
  __int64 v16; // [rsp+84h] [rbp+4h]
  __int64 v17; // [rsp+8Ch] [rbp+Ch]
  __int64 v18; // [rsp+94h] [rbp+14h]
  __int64 v19; // [rsp+9Ch] [rbp+1Ch]
  __int64 v20; // [rsp+A4h] [rbp+24h]
  __int64 v21; // [rsp+ACh] [rbp+2Ch]
  __int16 v22; // [rsp+B4h] [rbp+34h]
  int v23; // [rsp+B8h] [rbp+38h]
  __int64 v24; // [rsp+C0h] [rbp+40h]
  int v25; // [rsp+C8h] [rbp+48h]
  int v26; // [rsp+D0h] [rbp+50h]
  __int64 v27; // [rsp+D4h] [rbp+54h]
  __int64 v28; // [rsp+DCh] [rbp+5Ch]
  __int64 v29; // [rsp+E4h] [rbp+64h]
  __int64 v30; // [rsp+ECh] [rbp+6Ch]
  __int64 v31; // [rsp+F4h] [rbp+74h]
  __int64 v32; // [rsp+FCh] [rbp+7Ch]
  __int16 v33; // [rsp+104h] [rbp+84h]
  int v34; // [rsp+108h] [rbp+88h]
  __int64 v35; // [rsp+110h] [rbp+90h]
  int v36; // [rsp+118h] [rbp+98h]
  _DWORD v37[76]; // [rsp+120h] [rbp+A0h] BYREF
  int v38; // [rsp+250h] [rbp+1D0h]
  int v39; // [rsp+254h] [rbp+1D4h]
  unsigned int v40; // [rsp+258h] [rbp+1D8h]
  unsigned int v41; // [rsp+25Ch] [rbp+1DCh]

  _main(argc, argv, envp);
  qmemcpy(v37, &unk_140014020, 0x12Cui64);
  v41 = 5;
  v4 = 1;
  v5 = 0x3120656C626154i64;
  v6 = 0i64;
  v7 = 0i64;
  v8 = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0;
  v12 = 0;
  v13 = 0i64;
  v14 = 0;
  v15 = 2;
  v16 = 0x3220656C626154i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0;
  v23 = 0;
  v24 = 0i64;
  v25 = 0;
  v26 = 3;
  v27 = 0x3320656C626154i64;
  v28 = 0i64;
  v29 = 0i64;
  v30 = 0i64;
  v31 = 0i64;
  v32 = 0i64;
  v33 = 0;
  v34 = 0;
  v35 = 0i64;
  v36 = 0;
  v40 = 3;
  while ( 1 )
  {
    printf("\nMain Menu\n");
    printf("---------\n");
    printf("1. View menu\n");
    printf("2. Take order\n");
    printf("3. View tables\n");
    printf("4. Exit\n");
    printf("Enter choice: ");
    scanf("%d", &v3);
    if ( v3 == 4 )
    {
      printf("Goodbye!\n");
      exit(0);
    }
    if ( v3 > 4 )
    {
LABEL_12:
      printf("Invalid choice, please try again.\n");
    }
    else
    {
      switch ( v3 )
      {
        case 3:
          printTables(&v4, v40);
          v39 = selectTable(&v4, v40);
          printOrder(*((_QWORD *)&v15 + 10 * v39 - 2), (unsigned int)*(&v15 + 20 * v39 - 2));
          break;
        case 1:
          printMenu(v37, v41);
          break;
        case 2:
          v39 = selectTable(&v4, v40);
          v38 = selectProduct(v37, v41);
          addToOrder(*((_QWORD *)&v15 + 10 * v39 - 2) + 16i64 * *(&v15 + 20 * v39 - 2), &v37[15 * v38]);
          ++*(&v15 + 20 * v39 - 2);
          printf("Order added to table %d.\n", (unsigned int)*(&v15 + 20 * v39 - 20));
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 140001C63: conditional instruction was optimized away because %var_244.4<3
// 1400015E2: using guessed type __int64 __fastcall printMenu(_QWORD, _QWORD);
// 1400016C4: using guessed type __int64 __fastcall selectProduct(_QWORD, _QWORD);
// 140001750: using guessed type __int64 __fastcall selectTable(_QWORD, _QWORD);
// 1400017DC: using guessed type __int64 __fastcall addToOrder(_QWORD, _QWORD);
// 140001807: using guessed type __int64 __fastcall printOrder(_QWORD, _QWORD);
// 140001970: using guessed type __int64 __fastcall printTables(_QWORD, _QWORD);
// 140001F50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: intelligent
#include <stdio.h>

int main() {
    int coins[4] = {25, 10, 5, 1}; // types of coins available
    int amount, numCoins = 0;

    printf("Enter amount in cents: ");
    scanf("%d", &amount);

    for(int i = 0; i < 4; i++) {
        while(amount >= coins[i]) {
            amount -= coins[i];
            numCoins++;
            printf("Used a %d cent coin\n", coins[i]);
        }
    }

    printf("Minimum number of coins: %d\n", numCoins);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-24h] BYREF
  int v5[6]; // [rsp+30h] [rbp-20h]
  int i; // [rsp+48h] [rbp-8h]
  unsigned int v7; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v5[0] = 25;
  v5[1] = 10;
  v5[2] = 5;
  v5[3] = 1;
  v7 = 0;
  printf("Enter amount in cents: ");
  scanf("%d", &v4);
  for ( i = 0; i <= 3; ++i )
  {
    while ( v5[i] <= v4 )
    {
      v4 -= v5[i];
      ++v7;
      printf("Used a %d cent coin\n", (unsigned int)v5[i]);
    }
  }
  printf("Minimum number of coins: %d\n", v7);
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fractal Generation ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>

#define WIDTH 1000
#define HEIGHT 1000
#define MAX_ITERATIONS 50

typedef struct ComplexNumber {
    double real;
    double imaginary;
} ComplexNumber;

ComplexNumber add(ComplexNumber c1, ComplexNumber c2) {
    ComplexNumber result;
    result.real = c1.real + c2.real;
    result.imaginary = c1.imaginary + c2.imaginary;
    return result;
}

ComplexNumber multiply(ComplexNumber c1, ComplexNumber c2) {
    ComplexNumber result;
    result.real = (c1.real * c2.real) - (c1.imaginary * c2.imaginary);
    result.imaginary = (c1.real * c2.imaginary) + (c1.imaginary * c2.real);
    return result;
}

bool isInside(ComplexNumber c) {
    ComplexNumber z = {0, 0};
    for (int i = 0; i < MAX_ITERATIONS; i++) {
        z = add(multiply(z, z), c);
        if (sqrt(pow(z.real, 2) + pow(z.imaginary, 2)) > 2) {
            return false;
        }
    }
    return true;
}

int main() {
    unsigned char image[WIDTH][HEIGHT][3];
    for (int i = 0; i < WIDTH; i++) {
        for (int j = 0; j < HEIGHT; j++) {
            ComplexNumber c = {
                (4.0 * i / WIDTH) - 2,
                (4.0 * j / HEIGHT) - 2
            };
            if (isInside(c)) {
                image[i][j][0] = 255;
                image[i][j][1] = 255;
                image[i][j][2] = 255;
            }
            else {
                image[i][j][0] = 0;
                image[i][j][1] = 0;
                image[i][j][2] = 0;
            }
        }
    }
    FILE *file = fopen("fractal.bmp", "wb");
    fprintf(file, "P6 %d %d %d\n", WIDTH, HEIGHT, 255);
    for (int i = 0; i < WIDTH; i++) {
        for (int j = 0; j < HEIGHT; j++) {
            fwrite(image[i][j], sizeof(unsigned char), 3, file);
        }
    }
    fclose(file);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (00000001400017CF) ----------------------------------------------------
#error "1400017CF: stack frame is too big (funcsize=0)"

// nfuncs=148 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: File system simulation ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BLOCK_SIZE 1024 // Block size is set to 1 KB
#define NUM_BLOCKS 1000 // Number of blocks available in the file system
#define FILE_NAME_SIZE 20 // Maximum length of a file name

// Struct for a file
typedef struct {
    char name[FILE_NAME_SIZE];
    int start_block;
    int num_blocks;
} file;

// Struct for a block
typedef struct {
    int next_block;
    char data[BLOCK_SIZE];
} block;

// Global variables
file file_table[NUM_BLOCKS];
block disk[NUM_BLOCKS];
int next_block = 0;

// Function to initialize the file system
void init_file_system() {
    int i;
    for (i = 0; i < NUM_BLOCKS; i++) {
        disk[i].next_block = -1;
        memset(disk[i].data, '\0', BLOCK_SIZE);
        memset(file_table[i].name, '\0', FILE_NAME_SIZE);
        file_table[i].start_block = -1;
        file_table[i].num_blocks = 0;
    }
}

// Function to create a file
void create_file(char* file_name, int size) {
    if (next_block + size > NUM_BLOCKS) {
        printf("Error: Not enough space to create file.\n");
        return;
    }
    int i;
    for (i = 0; i < NUM_BLOCKS; i++) {
        if (file_table[i].name[0] == '\0') { // Found an empty slot in file table
            int j;
            int start_block = next_block;
            for (j = 0; j < size; j++) { // Reserve blocks for the file
                disk[next_block].next_block = (next_block + 1) % NUM_BLOCKS;
                next_block++;
            }
            disk[next_block - 1].next_block = -1; // Mark the last block as the end of the file
            strcpy(file_table[i].name, file_name);
            file_table[i].start_block = start_block;
            file_table[i].num_blocks = size;
            return;
        }
    }
    printf("Error: Too many files already exist.\n");
}

// Function to delete a file
void delete_file(char* file_name) {
    int i;
    for (i = 0; i < NUM_BLOCKS; i++) {
        if (strcmp(file_table[i].name, file_name) == 0) { // Found the file in file table
            int j;
            for (j = file_table[i].start_block; j != -1; j = disk[j].next_block) { // Free blocks occupied by the file
                disk[j].next_block = -1;
                memset(disk[j].data, '\0', BLOCK_SIZE);
            }
            memset(file_table[i].name, '\0', FILE_NAME_SIZE);
            file_table[i].start_block = -1;
            file_table[i].num_blocks = 0;
            return;
        }
    }
    printf("Error: File does not exist.\n");
}

// Function to write data to a file
void write_to_file(char* file_name, char* data, int size) {
    int i;
    for (i = 0; i < NUM_BLOCKS; i++) {
        if (strcmp(file_table[i].name, file_name) == 0) { // Found the file in file table
            if (file_table[i].num_blocks * BLOCK_SIZE < size) { // Check if file has enough space
                printf("Error: Not enough space in file.\n");
                return;
            }
            int block = file_table[i].start_block;
            int j = 0;
            while (j < size) { // Write data to blocks
                strncpy(disk[block].data, data + j, BLOCK_SIZE);
                j += BLOCK_SIZE;
                block = disk[block].next_block;
            }
            return;
        }
    }
    printf("Error: File does not exist.\n");
}

// Function to read data from a file
void read_from_file(char* file_name, char* data, int size) {
    int i;
    for (i = 0; i < NUM_BLOCKS; i++) {
        if (strcmp(file_table[i].name, file_name) == 0) { // Found the file in file table
            int block = file_table[i].start_block;
            int j = 0;
            while (j < size && block != -1) { // Read data from blocks
                strncat(data, disk[block].data, BLOCK_SIZE);
                j += BLOCK_SIZE;
                block = disk[block].next_block;
            }
            return;
        }
    }
    printf("Error: File does not exist.\n");
}

int main() {
    init_file_system();
    create_file("test.txt", 10);
    write_to_file("test.txt", "hello world", 11);
    char buffer[100];
    memset(buffer, '\0', 100);
    read_from_file("test.txt", buffer, 11);
    printf("%s\n", buffer);
    delete_file("test.txt");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 init_file_system(void); // weak
__int64 __fastcall create_file(_QWORD, _QWORD); // weak
__int64 __fastcall delete_file(_QWORD); // weak
__int64 __fastcall write_to_file(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall read_from_file(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memset(void *, int Val, size_t Size);


//----- (0000000140001C4D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[112]; // [rsp+20h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  init_file_system();
  create_file("test.txt", 10i64);
  write_to_file("test.txt", "hello world", 11i64);
  memset(v4, 0, 0x64ui64);
  read_from_file("test.txt", v4, 11i64);
  printf("%s\n", v4);
  delete_file("test.txt");
  return 0;
}
// 140001591: using guessed type __int64 init_file_system(void);
// 140001693: using guessed type __int64 __fastcall create_file(_QWORD, _QWORD);
// 140001845: using guessed type __int64 __fastcall delete_file(_QWORD);
// 1400019E1: using guessed type __int64 __fastcall write_to_file(_QWORD, _QWORD, _QWORD);
// 140001B36: using guessed type __int64 __fastcall read_from_file(_QWORD, _QWORD, _QWORD);
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Browser Plugin ; Style: innovative
#include <stdio.h>

// Define the function prototypes
void incrementCounter();
void displayCounter();

// Global variable to track counter
int counter = 0;

// Implementation of incrementCounter function
void incrementCounter() {
    counter++;
}

// Implementation of displayCounter function
void displayCounter() {
    printf("The current counter value is: %d\n", counter);
}

int main() {
    int choice;
    // Display the options to the user
    printf("Choose an option:\n");
    printf("1. Increment counter\n");
    printf("2. Display counter\n");
    printf("3. Exit\n");

    while (1) {
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                // Call incrementCounter function to increment the counter variable
                incrementCounter();
                printf("Counter incremented!\n");
                break;

            case 2:
                // Call displayCounter function to display the current counter value
                displayCounter();
                break;

            case 3:
                // Exit the program
                printf("Exiting program...\n");
                return 0;

            default:
                printf("Invalid choice! Please try again.\n");
                break;
        }

        // Display the options again
        printf("\nChoose an option:\n");
        printf("1. Increment counter\n");
        printf("2. Display counter\n");
        printf("3. Exit\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 incrementCounter(void); // weak
__int64 displayCounter(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000161E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Choose an option:\n");
  printf("1. Increment counter\n");
  printf("2. Display counter\n");
  printf("3. Exit\n");
  while ( 1 )
  {
    scanf("%d", &v4);
    if ( v4 == 3 )
      break;
    if ( v4 > 3 )
      goto LABEL_10;
    if ( v4 == 1 )
    {
      incrementCounter();
      printf("Counter incremented!\n");
      goto LABEL_11;
    }
    if ( v4 == 2 )
      displayCounter();
    else
LABEL_10:
      printf("Invalid choice! Please try again.\n");
LABEL_11:
    printf("\nChoose an option:\n");
    printf("1. Increment counter\n");
    printf("2. Display counter\n");
    printf("3. Exit\n");
  }
  printf("Exiting program...\n");
  return 0;
}
// 1400015E2: using guessed type __int64 incrementCounter(void);
// 1400015F8: using guessed type __int64 displayCounter(void);
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Graph representation ; Style: artistic
#include <stdio.h>

int main() {
    printf("   * * * * * * * * * * * * * *\n");
    printf(" *                             *\n");
    printf("*                               *\n");
    printf("*             ******            *\n");
    printf("*            *      *           *\n");
    printf("*           *        *          *\n");
    printf("*          *   **     *         *\n");
    printf("*         *     *      *        *\n");
    printf("*        *      *       *       *\n");
    printf("*        *      *        *      *\n");
    printf("*         *     *         *     *\n");
    printf("*          *   *           *    *\n");
    printf("*           * *             *   *\n");
    printf("*            *               *  *\n");
    printf(" *                             *\n");
    printf("   * * * * * * * * * * * * * *\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("   * * * * * * * * * * * * * *\n");
  printf(" *                             *\n");
  printf("*                               *\n");
  printf("*             ******            *\n");
  printf("*            *      *           *\n");
  printf("*           *        *          *\n");
  printf("*          *   **     *         *\n");
  printf("*         *     *      *        *\n");
  printf("*        *      *       *       *\n");
  printf("*        *      *        *      *\n");
  printf("*         *     *         *     *\n");
  printf("*          *   *           *    *\n");
  printf("*           * *             *   *\n");
  printf("*            *               *  *\n");
  printf(" *                             *\n");
  printf("   * * * * * * * * * * * * * *\n");
  return 0;
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: funny
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main()
{
    int n,i,j;    
    printf("Hey, wanna do some greedy stuff?\n");
    printf("How about we find the minimum sum that can be formed by combining two numbers repeatedly.\n");
    printf("Sounds great, doesn't it?\n");
    printf("Enter the number of elements you want in the array:\n");
    scanf("%d",&n);
    int arr[n];
    srand(time(0));   //for randomizing the array contents
    for(i=0;i<n;i++){
        arr[i]=rand()%100; //random numbers from 0-99
    }
    printf("The array contents are: ");
    for(i=0;i<n;i++){
        printf("%d ",arr[i]);
    }
    printf("\n");
    int sum=0;  //our greedy work starts here
    i=0;
    j=n-1;
    while(i<j){
        if(arr[i]<arr[j]){
            sum+=arr[i];
            i++;
        }
        else{
            sum+=arr[j];
            j--;
        }
    }
    if(i==j){
        sum+=arr[i];
    }
    printf("The minimum sum is: %d\n",sum);
    printf("Aren't we the smart Greedy ones?\n");
    printf("Bye bye\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  unsigned int v4; // eax
  char v6; // [rsp+20h] [rbp-30h] BYREF
  int v7; // [rsp+2Ch] [rbp-24h] BYREF
  char *v8; // [rsp+30h] [rbp-20h]
  __int64 v9; // [rsp+38h] [rbp-18h]
  unsigned int v10; // [rsp+44h] [rbp-Ch]
  int v11; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Hey, wanna do some greedy stuff?\n");
  printf("How about we find the minimum sum that can be formed by combining two numbers repeatedly.\n");
  printf("Sounds great, doesn't it?\n");
  printf("Enter the number of elements you want in the array:\n");
  scanf("%d", &v7);
  v9 = v7 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(4i64 * v7 + 15) >> 4));
  v8 = &v6;
  v4 = time(0i64);
  srand(v4);
  for ( i = 0; i < v7; ++i )
    *(_DWORD *)&v8[4 * i] = rand() % 100;
  printf("The array contents are: ");
  for ( i = 0; i < v7; ++i )
    printf("%d ", *(unsigned int *)&v8[4 * i]);
  printf("\n");
  v10 = 0;
  i = 0;
  v11 = v7 - 1;
  while ( i < v11 )
  {
    if ( *(_DWORD *)&v8[4 * i] >= *(_DWORD *)&v8[4 * v11] )
      v10 += *(_DWORD *)&v8[4 * v11--];
    else
      v10 += *(_DWORD *)&v8[4 * i++];
  }
  if ( i == v11 )
    v10 += *(_DWORD *)&v8[4 * i];
  printf("The minimum sum is: %d\n", v10);
  printf("Aren't we the smart Greedy ones?\n");
  printf("Bye bye\n");
  return 0;
}
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Resume Parsing System ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct resume {
    char name[50];
    char email[50];
    char skillset1[20];
    char skillset2[20];
    char skillset3[20];
    char education[30];
    char experience[100];
};

int main() {
    struct resume employee;
    char input[500];
    char *token;

    printf("Enter employee details in the following format:\n{Name},{Email},{Skillset 1},{Skillset 2},{Skillset 3},{Education},{Experience}\n");
    fgets(input, 500, stdin);

    token = strtok(input, ",");
    strcpy(employee.name, token);

    token = strtok(NULL, ",");
    strcpy(employee.email, token);

    token = strtok(NULL, ",");
    strcpy(employee.skillset1, token);

    token = strtok(NULL, ",");
    strcpy(employee.skillset2, token);

    token = strtok(NULL, ",");
    strcpy(employee.skillset3, token);

    token = strtok(NULL, ",");
    strcpy(employee.education, token);

    token = strtok(NULL, ",");
    strcpy(employee.experience, token);

    printf("\nEmployee details: \n");
    printf("Name: %s\n", employee.name);
    printf("Email: %s\n", employee.email);
    printf("Skillset 1: %s\n", employee.skillset1);
    printf("Skillset 2: %s\n", employee.skillset2);
    printf("Skillset 3: %s\n", employee.skillset3);
    printf("Education: %s\n", employee.education);
    printf("Experience: %s\n", employee.experience);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[512]; // [rsp+20h] [rbp-60h] BYREF
  char Destination[50]; // [rsp+220h] [rbp+1A0h] BYREF
  char v7[50]; // [rsp+252h] [rbp+1D2h] BYREF
  char v8[20]; // [rsp+284h] [rbp+204h] BYREF
  char v9[20]; // [rsp+298h] [rbp+218h] BYREF
  char v10[20]; // [rsp+2ACh] [rbp+22Ch] BYREF
  char v11[30]; // [rsp+2C0h] [rbp+240h] BYREF
  char v12[106]; // [rsp+2DEh] [rbp+25Eh] BYREF
  char *Source; // [rsp+348h] [rbp+2C8h]

  _main(argc, argv, envp);
  printf(
    "Enter employee details in the following format:\n"
    "{Name},{Email},{Skillset 1},{Skillset 2},{Skillset 3},{Education},{Experience}\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 500, v3);
  Source = strtok(Buffer, ",");
  strcpy(Destination, Source);
  Source = strtok(0i64, ",");
  strcpy(v7, Source);
  Source = strtok(0i64, ",");
  strcpy(v8, Source);
  Source = strtok(0i64, ",");
  strcpy(v9, Source);
  Source = strtok(0i64, ",");
  strcpy(v10, Source);
  Source = strtok(0i64, ",");
  strcpy(v11, Source);
  Source = strtok(0i64, ",");
  strcpy(v12, Source);
  printf("\nEmployee details: \n");
  printf("Name: %s\n", Destination);
  printf("Email: %s\n", v7);
  printf("Skillset 1: %s\n", v8);
  printf("Skillset 2: %s\n", v9);
  printf("Skillset 3: %s\n", v10);
  printf("Education: %s\n", v11);
  printf("Experience: %s\n", v12);
  return 0;
}
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: romantic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TAG_NAME 50
#define MAX_TAG_VALUE 100

typedef struct xml_tag {
    char *name;
    char *value;
} xml_tag;

void parse_tag(char *tag, xml_tag *xml_tag) {
    char *start_ptr, *end_ptr;
    char tag_name[MAX_TAG_NAME];
    char tag_value[MAX_TAG_VALUE];
    int tag_len, name_len, value_len;

    start_ptr = strchr(tag, '<');
    end_ptr = strchr(tag, '>');

    tag_len = end_ptr - start_ptr - 1;

    strncpy(tag_name, start_ptr + 1, tag_len);

    name_len = strchr(tag_name, ' ') - tag_name;

    strncpy(xml_tag->name, tag_name, name_len);

    tag_value[0] = '\0';

    if (strchr(tag, '"') != NULL) {
        start_ptr = strchr(tag, '"') + 1;
        end_ptr = strchr(start_ptr, '"');
        value_len = end_ptr - start_ptr;
        strncpy(tag_value, start_ptr, value_len);
        tag_value[value_len] = '\0';
        strncpy(xml_tag->value, tag_value, value_len);
    }
}

int main() {
    char tag[100];
    xml_tag *xml_tag;
    int tag_count = 0;

    while (fgets(tag, MAX_TAG_VALUE, stdin) != NULL) {
        xml_tag = malloc(sizeof(xml_tag));
        xml_tag->name = malloc(MAX_TAG_NAME);
        xml_tag->value = malloc(MAX_TAG_VALUE);

        parse_tag(tag, xml_tag);
        printf("Tag %d: %s = '%s'\n", ++tag_count, xml_tag->name, xml_tag->value);

        free(xml_tag->name);
        free(xml_tag->value);
        free(xml_tag);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall parse_tag(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016CD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rcx
  const char *v4; // rdx
  FILE *v5; // rax
  char Buffer[112]; // [rsp+20h] [rbp-80h] BYREF
  void *Block; // [rsp+90h] [rbp-10h]
  int v9; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 0;
  while ( 1 )
  {
    v5 = __acrt_iob_func(0);
    if ( !fgets(Buffer, 100, v5) )
      break;
    Block = malloc(8ui64);
    *(_QWORD *)Block = malloc(0x32ui64);
    *((_QWORD *)Block + 1) = malloc(0x64ui64);
    parse_tag(Buffer, Block);
    v3 = (const char *)*((_QWORD *)Block + 1);
    v4 = *(const char **)Block;
    printf("Tag %d: %s = '%s'\n", (unsigned int)++v9, v4, v3);
    free(*(void **)Block);
    free(*((void **)Block + 1));
    free(Block);
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall parse_tag(_QWORD, _QWORD);
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pac-Man Game Clone ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Constants for game board and game character
#define ROWS 20
#define COLS 30
#define PACMAN 'C'
#define WALL '#'
#define FOOD '.'
#define EMPTY ' '

// Struct to hold game board
typedef struct board {
    int rows;
    int cols;
    char **grid;
} Board;

// Struct to hold game character
typedef struct character {
    int x;
    int y;
} Character;

// Function to create game board
Board *create_board() {
    Board *new_board = malloc(sizeof(Board));
    new_board->rows = ROWS;
    new_board->cols = COLS;
    new_board->grid = malloc(ROWS * sizeof(char *));
    for (int i = 0; i < ROWS; i++) {
        new_board->grid[i] = malloc(COLS * sizeof(char));
        for (int j = 0; j < COLS; j++) {
            if (i == 0 || i == ROWS - 1 || j == 0 || j == COLS - 1) {
                new_board->grid[i][j] = WALL;
            } else {
                new_board->grid[i][j] = FOOD;
            }
        }
    }
    return new_board;
}

// Function to print game board
void print_board(Board *board) {
    for (int i = 0; i < board->rows; i++) {
        for (int j = 0; j < board->cols; j++) {
            printf("%c", board->grid[i][j]);
        }
        printf("\n");
    }
}

// Function to create game character
Character *create_character() {
    Character *new_character = malloc(sizeof(Character));
    new_character->x = ROWS / 2;
    new_character->y = COLS / 2;
    return new_character;
}

// Function to move game character
void move_character(Board *board, Character *character, char direction) {
    int new_x = character->x;
    int new_y = character->y;
    switch(direction) {
        case 'U':
            new_x--;
            break;
        case 'D':
            new_x++;
            break;
        case 'L':
            new_y--;
            break;
        case 'R':
            new_y++;
            break;
    }
    if (board->grid[new_x][new_y] != WALL) {
        character->x = new_x;
        character->y = new_y;
        if (board->grid[new_x][new_y] == FOOD) {
            board->grid[new_x][new_y] = EMPTY;
        }
    }
}

int main() {
    srand(time(NULL));
    Board *board = create_board();
    Character *character = create_character();
    char direction;
    while (1) {
        system("clear");
        print_board(board);
        printf("Enter direction (U/D/L/R): ");
        scanf("%c", &direction);
        move_character(board, character, direction);
        if (board->grid[character->x][character->y] == EMPTY) {
            printf("You win!\n");
            break;
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 create_board(void); // weak
__int64 __fastcall print_board(_QWORD); // weak
__int64 create_character(void); // weak
__int64 __fastcall move_character(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl system(const char *Command);
// void __cdecl srand(unsigned int Seed);


//----- (00000001400018A7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5; // [rsp+2Fh] [rbp-11h] BYREF
  int *character; // [rsp+30h] [rbp-10h]
  __int64 board; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  board = create_board();
  character = (int *)create_character();
  do
  {
    system("clear");
    print_board(board);
    printf("Enter direction (U/D/L/R): ");
    scanf("%c", &v5);
    move_character(board, character, (unsigned int)v5);
  }
  while ( *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(board + 8) + 8i64 * *character) + character[1]) != 32 );
  printf("You win!\n");
  return 0;
}
// 140001601: using guessed type __int64 create_board(void);
// 1400016FC: using guessed type __int64 __fastcall print_board(_QWORD);
// 140001786: using guessed type __int64 create_character(void);
// 1400017BB: using guessed type __int64 __fastcall move_character(_QWORD, _QWORD, _QWORD);
// 140001A30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Error handling ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

int main() {
    FILE *fp;
    char *filename = "example.txt";
    char *message = "Hello World!";

    fp = fopen(filename, "r");

    if(fp == NULL) {
        fprintf(stderr, "Error %d: %s\n", errno, strerror(errno));
        printf("Initiating Data Recovery Protocol....\n");
        printf("Scanning for corrupted files...\n");

        FILE *recovery_fp;
        char *recovery_filename = "recovered.txt";

        recovery_fp = fopen(recovery_filename, "w");

        if(recovery_fp == NULL) {
            fprintf(stderr, "Error %d: %s\n", errno, strerror(errno));
            printf("Initiating Ultimate Data Recovery Protocol....\n");
            printf("Analyzing corrupted network connections...\n");
            printf("Resuming recovery process...\n");

            FILE *ultimate_recovery_fp;
            char *ultimate_recovery_filename = "ultimate_recovered.txt";

            ultimate_recovery_fp = fopen(ultimate_recovery_filename, "w");

            if(ultimate_recovery_fp == NULL) {
                fprintf(stderr, "Error %d: %s\n", errno, strerror(errno));
                printf("Initiating Emergency Data Recovery Protocol....\n");
                printf("Calling top-level engineers...\n");
                printf("Establishing secure communication channel....\n");
                printf("Initiating emergency data transfer....\n");

                char *emergency_data = "Recovered data!!";
                printf("%s\n", emergency_data);

                exit(1);
            } else {
                fprintf(ultimate_recovery_fp, "%s\n", message);
                printf("Data successfully recovered using Ultimate Data Recovery Protocol.\n");
            }

            fclose(ultimate_recovery_fp);
            exit(1);
        } else {
            fprintf(recovery_fp, "%s\n", message);
            printf("Data successfully recovered using Data Recovery Protocol.\n");
        }

        fclose(recovery_fp);
        exit(1);
    } else {
        char data[100];
        fgets(data, 100, fp);
        printf("Data successfully read: %s\n", data);
    }

    fclose(fp);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strerror(int ErrorMessage);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

// extern int *(__cdecl *_errno)();


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int *v3; // rax
  char *v4; // rbx
  unsigned int v5; // esi
  FILE *v6; // rax
  int *v7; // rax
  char *v8; // rbx
  unsigned int v9; // esi
  FILE *v10; // rax
  int *v11; // rax
  char *v12; // rbx
  unsigned int v13; // esi
  FILE *v14; // rax
  char Buffer[112]; // [rsp+20h] [rbp-B0h] BYREF
  const char *v17; // [rsp+90h] [rbp-40h]
  FILE *Stream; // [rsp+98h] [rbp-38h]
  char *v19; // [rsp+A0h] [rbp-30h]
  FILE *v20; // [rsp+A8h] [rbp-28h]
  char *v21; // [rsp+B0h] [rbp-20h]
  FILE *v22; // [rsp+B8h] [rbp-18h]
  const char *v23; // [rsp+C0h] [rbp-10h]
  char *FileName; // [rsp+C8h] [rbp-8h]

  _main(argc, argv, envp);
  FileName = "example.txt";
  v23 = "Hello World!";
  v22 = fopen("example.txt", "r");
  if ( !v22 )
  {
    v3 = _errno();
    v4 = strerror(*v3);
    v5 = *_errno();
    v6 = __acrt_iob_func(2u);
    fprintf_0(v6, "Error %d: %s\n", v5, v4);
    printf("Initiating Data Recovery Protocol....\n");
    printf("Scanning for corrupted files...\n");
    v21 = "recovered.txt";
    v20 = fopen("recovered.txt", "w");
    if ( !v20 )
    {
      v7 = _errno();
      v8 = strerror(*v7);
      v9 = *_errno();
      v10 = __acrt_iob_func(2u);
      fprintf_0(v10, "Error %d: %s\n", v9, v8);
      printf("Initiating Ultimate Data Recovery Protocol....\n");
      printf("Analyzing corrupted network connections...\n");
      printf("Resuming recovery process...\n");
      v19 = "ultimate_recovered.txt";
      Stream = fopen("ultimate_recovered.txt", "w");
      if ( !Stream )
      {
        v11 = _errno();
        v12 = strerror(*v11);
        v13 = *_errno();
        v14 = __acrt_iob_func(2u);
        fprintf_0(v14, "Error %d: %s\n", v13, v12);
        printf("Initiating Emergency Data Recovery Protocol....\n");
        printf("Calling top-level engineers...\n");
        printf("Establishing secure communication channel....\n");
        printf("Initiating emergency data transfer....\n");
        v17 = "Recovered data!!";
        printf("%s\n", "Recovered data!!");
        exit(1);
      }
      fprintf_0(Stream, "%s\n", v23);
      printf("Data successfully recovered using Ultimate Data Recovery Protocol.\n");
      fclose(Stream);
      exit(1);
    }
    fprintf_0(v20, "%s\n", v23);
    printf("Data successfully recovered using Data Recovery Protocol.\n");
    fclose(v20);
    exit(1);
  }
  fgets(Buffer, 100, v22);
  printf("Data successfully read: %s\n", Buffer);
  fclose(v22);
  return 0;
}
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Error handling ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>

int main() {
  int dividend, divisor, result;
  
  printf("Enter the dividend: ");
  if(scanf("%d", &dividend) != 1) { // check if input is valid
    printf("Invalid input for dividend!");
    return 1; // terminate program with error code 1
  }
  
  printf("Enter the divisor: ");
  if(scanf("%d", &divisor) != 1) { // check if input is valid
    printf("Invalid input for divisor!");
    return 1; // terminate program with error code 1
  }
  
  if(divisor == 0) { // check for division by zero
    printf("Cannot divide by zero!");
    return 1; // terminate program with error code 1
  }
  
  result = dividend / divisor; // perform division
  
  printf("%d divided by %d is %d\n", dividend, divisor, result);
  
  return 0; // terminate program
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  int v5[2]; // [rsp+28h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  printf("Enter the dividend: ");
  if ( scanf("%d", v5) == 1 )
  {
    printf("Enter the divisor: ");
    if ( scanf("%d", &v4) == 1 )
    {
      if ( v4 )
      {
        v5[1] = v5[0] / v4;
        printf("%d divided by %d is %d\n", (unsigned int)v5[0], (unsigned int)v4, (unsigned int)(v5[0] / v4));
        return 0;
      }
      else
      {
        printf("Cannot divide by zero!");
        return 1;
      }
    }
    else
    {
      printf("Invalid input for divisor!");
      return 1;
    }
  }
  else
  {
    printf("Invalid input for dividend!");
    return 1;
  }
}
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Spam Detection System ; Style: configurable
#include <stdio.h>  
#include <stdlib.h> 
#include <string.h>

const int SPAM_THRESHOLD = 10;

int count_occurrences(char* str, char* substr) {
    int count = 0;
    while ((str = strstr(str, substr))) {
        count++;
        str++;
    }
    return count;
}

int main()
{
    char input[1000];
    printf("Enter message: ");
    fgets(input, 1000, stdin);

    // Check for excessive uppercase letters
    int message_len = strlen(input);
    int uppercase_count = 0;
    for (int i = 0; i < message_len; i++) {
        if (input[i] >= 'A' && input[i] <= 'Z') {
            uppercase_count++;
        }
    }

    if (uppercase_count > message_len / 4) {
        printf("This message contains too many uppercase letters. Possible spam detected.\n");
        return 1;
    }

    // Check for excessive punctuation marks
    int punctuation_count = 0;
    char* punctuation_list = "!@#$%^&*()_+-=[]\\{}|;':\",./<>?";
    for (int i = 0; i < message_len; i++) {
        if (strchr(punctuation_list, input[i])) {
            punctuation_count++;
        }
    }
    if (punctuation_count > message_len / 4) {
        printf("This message contains too many punctuation marks. Possible spam detected.\n");
        return 1;
    }

    // Check for repeated words
    char* words[1000];
    int words_count = 0;
    char* token = strtok(input, " \t\n");
    while (token != NULL) {
        words[words_count] = token;
        words_count++;
        token = strtok(NULL, " \t\n");
    }
    for (int i = 0; i < words_count; i++) {
        int count = 0;
        for (int j = i+1; j < words_count; j++) {
            if (strcmp(words[i], words[j]) == 0) {
                count++;
            }
        }
        if (count > 2) {
            printf("This message contains too many repeated words. Possible spam detected.\n");
            return 1;
        }
    }

    // Check for specific spam keywords
    char* spam_keywords[] = {"money", "sale", "free", "deal", "click", "subscribe", "sex", "win", "prize", "cash", "urgent", "offer", "now", "limited"};
    for (int i = 0; i < sizeof(spam_keywords) / sizeof(char*); i++) {
        char* keyword = spam_keywords[i];
        int count = count_occurrences(input, keyword);
        if (count >= SPAM_THRESHOLD) {
            printf("This message contains spam keywords. Possible spam detected.\n");
            return 1;
        }
    }

    printf("This message appears to be legitimate.\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall count_occurrences(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl strchr(const char *Str, int Val);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015D7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  __int64 v5[1014]; // [rsp+20h] [rbp-60h]
  char Buffer[1012]; // [rsp+1FD0h] [rbp+1F50h] BYREF
  int v7; // [rsp+23C4h] [rbp+2344h]
  __int64 v8; // [rsp+23C8h] [rbp+2348h]
  char *Str; // [rsp+23D0h] [rbp+2350h]
  int v10; // [rsp+23DCh] [rbp+235Ch]
  unsigned int ii; // [rsp+23E0h] [rbp+2360h]
  int n; // [rsp+23E4h] [rbp+2364h]
  int v13; // [rsp+23E8h] [rbp+2368h]
  int m; // [rsp+23ECh] [rbp+236Ch]
  char *k; // [rsp+23F0h] [rbp+2370h]
  int v16; // [rsp+23FCh] [rbp+237Ch]
  int j; // [rsp+2400h] [rbp+2380h]
  int v18; // [rsp+2404h] [rbp+2384h]
  int i; // [rsp+2408h] [rbp+2388h]
  int v20; // [rsp+240Ch] [rbp+238Ch]

  _main(argc, argv, envp);
  printf("Enter message: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v10 = strlen(Buffer);
  v20 = 0;
  for ( i = 0; i < v10; ++i )
  {
    if ( Buffer[i] > 64 && Buffer[i] <= 90 )
      ++v20;
  }
  if ( v20 <= v10 / 4 )
  {
    v18 = 0;
    Str = "!@#$%^&*()_+-=[]\\{}|;':\",./<>?";
    for ( j = 0; j < v10; ++j )
    {
      if ( strchr(Str, Buffer[j]) )
        ++v18;
    }
    if ( v18 <= v10 / 4 )
    {
      v16 = 0;
      for ( k = strtok(Buffer, " \t\n"); k; k = strtok(0i64, " \t\n") )
        v5[v16++ + 14] = (__int64)k;
      for ( m = 0; m < v16; ++m )
      {
        v13 = 0;
        for ( n = m + 1; n < v16; ++n )
        {
          if ( !strcmp((const char *)v5[m + 14], (const char *)v5[n + 14]) )
            ++v13;
        }
        if ( v13 > 2 )
        {
          printf("This message contains too many repeated words. Possible spam detected.\n");
          return 1;
        }
      }
      v5[0] = (__int64)"money";
      v5[1] = (__int64)"sale";
      v5[2] = (__int64)"free";
      v5[3] = (__int64)"deal";
      v5[4] = (__int64)"click";
      v5[5] = (__int64)"subscribe";
      v5[6] = (__int64)"sex";
      v5[7] = (__int64)"win";
      v5[8] = (__int64)"prize";
      v5[9] = (__int64)"cash";
      v5[10] = (__int64)"urgent";
      v5[11] = (__int64)"offer";
      v5[12] = (__int64)"now";
      v5[13] = (__int64)"limited";
      for ( ii = 0; ii <= 0xD; ++ii )
      {
        v8 = v5[ii];
        v7 = count_occurrences(Buffer, v8);
        if ( v7 >= 10 )
        {
          printf("This message contains spam keywords. Possible spam detected.\n");
          return 1;
        }
      }
      printf("This message appears to be legitimate.\n");
      return 0;
    }
    else
    {
      printf("This message contains too many punctuation marks. Possible spam detected.\n");
      return 1;
    }
  }
  else
  {
    printf("This message contains too many uppercase letters. Possible spam detected.\n");
    return 1;
  }
}
// 140001591: using guessed type __int64 __fastcall count_occurrences(_QWORD, _QWORD);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015D7: using guessed type char Buffer[1012];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Secure Password Generator ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

// Function to generate a random password
void generatePassword(char *password, int length) {
    srand(time(NULL));
    char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=";
    int maxChar = strlen(charset);
    
    for(int i = 0; i < length; i++) {
        password[i] = charset[rand() % maxChar];
    }
    password[length] = '\0';
}

int main() {
    int length = 0;
    char password[50];
    
    // Prompt user for password length
    printf("Enter desired length of password (between 8 and 50): ");
    scanf("%d", &length);
    
    // Check if length is within valid range
    if(length < 8 || length > 50) {
        printf("Invalid length. Password must be between 8 and 50 characters long.\n");
        return 1;
    }
    
    // Generate password and display to user
    generatePassword(password, length);
    printf("Your secure password is: %s\n", password);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generatePassword(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001707) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[60]; // [rsp+20h] [rbp-40h] BYREF
  int v5; // [rsp+5Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  printf("Enter desired length of password (between 8 and 50): ");
  scanf("%d", &v5);
  if ( v5 > 7 && v5 <= 50 )
  {
    generatePassword(v4, (unsigned int)v5);
    printf("Your secure password is: %s\n", v4);
    return 0;
  }
  else
  {
    printf("Invalid length. Password must be between 8 and 50 characters long.\n");
    return 1;
  }
}
// 140001601: using guessed type __int64 __fastcall generatePassword(_QWORD, _QWORD);
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image compression ; Style: brave
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define BLOCK_SIZE 8
#define MAX_PIXEL_VAL 255

void compress_image(unsigned char **image, int num_rows, int num_cols);

void main(){
    // Load image into 2D array
    unsigned char **image;
    int num_rows, num_cols;

    // Read image and initialize image array

    // Compress image
    compress_image(image, num_rows, num_cols);

    // Display compressed image
}

void compress_image(unsigned char **image, int num_rows, int num_cols){
    // Calculate number of blocks in rows and columns
    int num_blocks_rows = ceil(num_rows / (double) BLOCK_SIZE);
    int num_blocks_cols = ceil(num_cols / (double) BLOCK_SIZE);

    // Allocate space for compressed image blocks
    int **blocks = (int **)malloc(num_blocks_rows * sizeof(int *));
    for(int i = 0; i < num_blocks_rows; i++){
        blocks[i] = (int *)malloc(num_blocks_cols * sizeof(int));
    }

    // Iterate through image blocks and calculate average value
    for(int i = 0; i < num_blocks_rows; i++){
        for(int j = 0; j < num_blocks_cols; j++){
            int sum = 0;

            // Calculate block pixels average
            for(int k = 0; k < BLOCK_SIZE; k++){
                for(int l = 0; l < BLOCK_SIZE; l++){
                    // If pixel in block boundary, pad with the last pixel value
                    int row = i * BLOCK_SIZE + k;
                    int col = j * BLOCK_SIZE + l;

                    if(row >= num_rows){
                        row = num_rows - 1;
                    }

                    if(col >= num_cols){
                        col = num_cols - 1;
                    }

                    sum += image[row][col];
                }
            }

            // Store average block value
            int avg = round(sum / (double) (BLOCK_SIZE * BLOCK_SIZE));
            blocks[i][j] = avg;
        }
    }

    // Save compressed image blocks to file
    FILE *f = fopen("compressed_image.txt", "w");
    fprintf(f, "%d, %d\n", num_blocks_rows, num_blocks_cols);
    for(int i = 0; i < num_blocks_rows; i++){
        for(int j = 0; j < num_blocks_cols; j++){
            fprintf(f, "%d ", blocks[i][j]);
        }
        fprintf(f, "\n");
    }

    fclose(f);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall compress_image(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001583) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-10h]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  __int64 v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  return compress_image(v6, v5, v4);
}
// 1400015A0: variable 'v6' is possibly undefined
// 140001593: variable 'v5' is possibly undefined
// 14000159A: variable 'v4' is possibly undefined
// 1400015AC: using guessed type __int64 __fastcall compress_image(_QWORD, _QWORD, _QWORD);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific Calculator Implementation ; Style: detailed
#include <stdio.h>
#include <math.h>

int main() {
    char operator;
    double num1, num2, result;

    printf("Welcome to the C Scientific Calculator!\n");
    printf("Enter an operator (+, -, *, /, ^, s, c, t, l): ");
    scanf("%c", &operator);

    switch (operator) {
        case '+':
            printf("Enter two numbers to add: \n");
            scanf("%lf %lf", &num1, &num2);
            result = num1 + num2;
            printf("%.2lf + %.2lf = %.2lf\n", num1, num2, result);
            break;

        case '-':
            printf("Enter two numbers to subtract: \n");
            scanf("%lf %lf", &num1, &num2);
            result = num1 - num2;
            printf("%.2lf - %.2lf = %.2lf\n", num1, num2, result);
            break;

        case '*':
            printf("Enter two numbers to multiply: \n");
            scanf("%lf %lf", &num1, &num2);
            result = num1 * num2;
            printf("%.2lf * %.2lf = %.2lf\n", num1, num2, result);
            break;

        case '/':
            printf("Enter two numbers to divide: \n");
            scanf("%lf %lf", &num1, &num2);
            if (num2 == 0) {
                printf("Error: Cannot divide by zero.");
            } else {
                result = num1 / num2;
                printf("%.2lf / %.2lf = %.2lf\n", num1, num2, result);
            }
            break;

        case '^':
            printf("Enter two numbers to calculate power: \n");
            scanf("%lf %lf", &num1, &num2);
            result = pow(num1, num2);
            printf("%.2lf ^ %.2lf = %.2lf\n", num1, num2, result);
            break;

        case 's':
            printf("Enter a number to calculate the sine: \n");
            scanf("%lf", &num1);
            result = sin(num1);
            printf("sin(%.2lf) = %.2lf\n", num1, result);
            break;

        case 'c':
            printf("Enter a number to calculate the cosine: \n");
            scanf("%lf", &num1);
            result = cos(num1);
            printf("cos(%.2lf) = %.2lf\n", num1, result);
            break;

        case 't':
            printf("Enter a number to calculate the tangent: \n");
            scanf("%lf", &num1);
            result = tan(num1);
            printf("tan(%.2lf) = %.2lf\n", num1, result);
            break;

        case 'l':
            printf("Enter a number to calculate the natural logarithm: \n");
            scanf("%lf", &num1);
            result = log(num1);
            printf("ln(%.2lf) = %.2lf\n", num1, result);
            break;

        default:
            printf("Error: Invalid operator entered. Please enter a valid operator.");
            break;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl cos(double X);
double __cdecl log(double X);
double __cdecl pow(double X, double Y);
double __cdecl sin(double X);
// double __cdecl tan(double X);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double Y; // [rsp+20h] [rbp-20h] BYREF
  double X; // [rsp+28h] [rbp-18h] BYREF
  char v6; // [rsp+37h] [rbp-9h] BYREF
  double v7; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to the C Scientific Calculator!\n");
  printf("Enter an operator (+, -, *, /, ^, s, c, t, l): ");
  scanf("%c", &v6);
  if ( v6 > 116 )
    goto LABEL_22;
  if ( v6 >= 94 )
  {
    switch ( v6 )
    {
      case '^':
        printf("Enter two numbers to calculate power: \n");
        scanf("%lf %lf", &X, &Y);
        v7 = pow(X, Y);
        printf("%.2lf ^ %.2lf = %.2lf\n", X, Y, v7);
        break;
      case 'c':
        printf("Enter a number to calculate the cosine: \n");
        scanf("%lf", &X);
        v7 = cos(X);
        printf("cos(%.2lf) = %.2lf\n", X, v7);
        break;
      case 'l':
        printf("Enter a number to calculate the natural logarithm: \n");
        scanf("%lf", &X);
        v7 = log(X);
        printf("ln(%.2lf) = %.2lf\n", X, v7);
        break;
      case 's':
        printf("Enter a number to calculate the sine: \n");
        scanf("%lf", &X);
        v7 = sin(X);
        printf("sin(%.2lf) = %.2lf\n", X, v7);
        break;
      case 't':
        printf("Enter a number to calculate the tangent: \n");
        scanf("%lf", &X);
        v7 = tan(X);
        printf("tan(%.2lf) = %.2lf\n", X, v7);
        break;
      default:
        goto LABEL_22;
    }
  }
  else if ( v6 == 47 )
  {
    printf("Enter two numbers to divide: \n");
    scanf("%lf %lf", &X, &Y);
    if ( Y == 0.0 )
    {
      printf("Error: Cannot divide by zero.");
    }
    else
    {
      v7 = X / Y;
      printf("%.2lf / %.2lf = %.2lf\n", X, Y, X / Y);
    }
  }
  else
  {
    if ( v6 > 47 )
      goto LABEL_22;
    if ( v6 == 45 )
    {
      printf("Enter two numbers to subtract: \n");
      scanf("%lf %lf", &X, &Y);
      v7 = X - Y;
      printf("%.2lf - %.2lf = %.2lf\n", X, Y, X - Y);
      return 0;
    }
    if ( v6 > 45 )
    {
LABEL_22:
      printf("Error: Invalid operator entered. Please enter a valid operator.");
      return 0;
    }
    if ( v6 == 42 )
    {
      printf("Enter two numbers to multiply: \n");
      scanf("%lf %lf", &X, &Y);
      v7 = Y * X;
      printf("%.2lf * %.2lf = %.2lf\n", X, Y, Y * X);
    }
    else
    {
      if ( v6 != 43 )
        goto LABEL_22;
      printf("Enter two numbers to add: \n");
      scanf("%lf %lf", &X, &Y);
      v7 = Y + X;
      printf("%.2lf + %.2lf = %.2lf\n", X, Y, Y + X);
    }
  }
  return 0;
}
// 140001C50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: standalone
#include <stdio.h>

int main() {
    int n, i, flag, count = 0;

    printf("Enter the number of prime numbers to generate: ");
    scanf("%d", &n);

    printf("The first %d prime numbers are:\n", n);

    for (i = 2; count < n; i++) {
        flag = 1;

        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                flag = 0;
                break;
            }
        }

        if (flag == 1) {
            printf("%d ", i);
            count++;
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-14h] BYREF
  int i; // [rsp+30h] [rbp-10h]
  int v6; // [rsp+34h] [rbp-Ch]
  int v7; // [rsp+38h] [rbp-8h]
  int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  printf("Enter the number of prime numbers to generate: ");
  scanf("%d", &v4);
  printf("The first %d prime numbers are:\n", v4);
  v8 = 2;
  while ( v6 < (int)v4 )
  {
    v7 = 1;
    for ( i = 2; i < v8; ++i )
    {
      if ( !(v8 % i) )
      {
        v7 = 0;
        break;
      }
    }
    if ( v7 == 1 )
    {
      printf("%d ", (unsigned int)v8);
      ++v6;
    }
    ++v8;
  }
  return 0;
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Arithmetic ; Style: cheerful
#include <stdio.h>

int main() {
  printf("Hello friend! I'm a cheerful C arithmetic program!\n");
  printf("Let's calculate something fun together!\n");

  int num1, num2;
  printf("Enter two numbers to add: ");
  scanf("%d %d", &num1, &num2);
    
  int sum = num1 + num2;
  printf("The sum of %d and %d is: %d\n", num1, num2, sum);

  int num3, num4;
  printf("Enter two numbers to subtract: ");
  scanf("%d %d", &num3, &num4);

  int diff = num3 - num4;
  printf("The difference between %d and %d is: %d\n", num3, num4, diff);

  int num5, num6;
  printf("Enter two numbers to multiply: ");
  scanf("%d %d", &num5, &num6);

  int prod = num5 * num6;
  printf("The product of %d and %d is: %d\n", num5, num6, prod);

  int num7, num8;
  printf("Enter two numbers to divide: ");
  scanf("%d %d", &num7, &num8);

  if (num8 == 0) {
    printf("Oops! Division by zero is undefined!\n");
  } else {
      float quotient = (float) num7 / num8;
      printf("The quotient of %d and %d is: %.2f\n", num7, num8, quotient);
  }

  printf("Thanks for using this program! Have a great day!\n");
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-30h] BYREF
  unsigned int v5; // [rsp+24h] [rbp-2Ch] BYREF
  unsigned int v6; // [rsp+28h] [rbp-28h] BYREF
  unsigned int v7; // [rsp+2Ch] [rbp-24h] BYREF
  unsigned int v8; // [rsp+30h] [rbp-20h] BYREF
  unsigned int v9; // [rsp+34h] [rbp-1Ch] BYREF
  unsigned int v10; // [rsp+38h] [rbp-18h] BYREF
  unsigned int v11; // [rsp+3Ch] [rbp-14h] BYREF
  float v12; // [rsp+40h] [rbp-10h]
  unsigned int v13; // [rsp+44h] [rbp-Ch]
  unsigned int v14; // [rsp+48h] [rbp-8h]
  unsigned int v15; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Hello friend! I'm a cheerful C arithmetic program!\n");
  printf("Let's calculate something fun together!\n");
  printf("Enter two numbers to add: ");
  scanf("%d %d", &v11, &v10);
  v15 = v11 + v10;
  printf("The sum of %d and %d is: %d\n", v11, v10, v11 + v10);
  printf("Enter two numbers to subtract: ");
  scanf("%d %d", &v9, &v8);
  v14 = v9 - v8;
  printf("The difference between %d and %d is: %d\n", v9, v8, v9 - v8);
  printf("Enter two numbers to multiply: ");
  scanf("%d %d", &v7, &v6);
  v13 = v7 * v6;
  printf("The product of %d and %d is: %d\n", v7, v6, v7 * v6);
  printf("Enter two numbers to divide: ");
  scanf("%d %d", &v5, &v4);
  if ( v4 )
  {
    v12 = (float)(int)v5 / (float)(int)v4;
    printf("The quotient of %d and %d is: %.2f\n", v5, v4, v12);
  }
  else
  {
    printf("Oops! Division by zero is undefined!\n");
  }
  printf("Thanks for using this program! Have a great day!\n");
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text-Based Adventure Game ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  char player_name[30];
  int player_health = 100;
  int enemy_health = 75;
  int player_attack;
  int enemy_attack;
  int dice_roll;
  int potion_count = 3;
  
  printf("Welcome, traveler! What is your name?\n");
  scanf("%s", player_name);
  printf("Greetings, %s! Your journey begins...\n\n", player_name);
  
  while (player_health > 0 && enemy_health > 0) {
    printf("Your health: %d | Enemy health: %d\n", player_health, enemy_health);
    printf("What would you like to do? (1) Attack (2) Drink potion\n");
    int choice;
    scanf("%d", &choice);
    
    switch (choice) {
      case 1:
        printf("Roll the dice to see how much damage you do!\n");
        printf("Press enter to roll...\n\n");
        getchar();
        getchar();
        srand(time(NULL));
        dice_roll = rand() % 6 + 1;
        player_attack = dice_roll * 10;
        printf("You rolled a %d! You did %d damage!\n", dice_roll, player_attack);
        enemy_health -= player_attack;
        break;
        
      case 2:
        if (potion_count > 0) {
          printf("You drank a potion! You gained 25 health!\n");
          player_health += 25;
          potion_count--;
        } else {
          printf("You don't have any potions left!\n");
        }
        break;
        
      default:
        printf("I'm sorry, I didn't understand that.\n");
    }
    
    if (enemy_health <= 0) {
      printf("Congratulations, you defeated the enemy!\n");
      break;
    }
    
    printf("The enemy attacks!\n");
    srand(time(NULL));
    dice_roll = rand() % 6 + 1;
    enemy_attack = dice_roll * 8;
    printf("The enemy rolled a %d! You took %d damage!\n", dice_roll, enemy_attack);
    player_health -= enemy_attack;
    
    if (player_health <= 0) {
      printf("Game over! You have been defeated.\n");
      break;
    }
  }
  
  printf("Thanks for playing!\n");
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  int v6; // [rsp+2Ch] [rbp-44h] BYREF
  char v7[40]; // [rsp+30h] [rbp-40h] BYREF
  unsigned int v8; // [rsp+58h] [rbp-18h]
  unsigned int v9; // [rsp+5Ch] [rbp-14h]
  unsigned int v10; // [rsp+60h] [rbp-10h]
  int v11; // [rsp+64h] [rbp-Ch]
  int v12; // [rsp+68h] [rbp-8h]
  int v13; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  v13 = 100;
  v12 = 75;
  v11 = 3;
  printf("Welcome, traveler! What is your name?\n");
  scanf("%s", v7);
  printf("Greetings, %s! Your journey begins...\n\n", v7);
  while ( v13 > 0 && v12 > 0 )
  {
    printf("Your health: %d | Enemy health: %d\n", (unsigned int)v13, (unsigned int)v12);
    printf("What would you like to do? (1) Attack (2) Drink potion\n");
    scanf("%d", &v6);
    if ( v6 == 1 )
    {
      printf("Roll the dice to see how much damage you do!\n");
      printf("Press enter to roll...\n\n");
      getchar();
      getchar();
      v3 = time(0i64);
      srand(v3);
      v10 = rand() % 6 + 1;
      v9 = 10 * v10;
      printf("You rolled a %d! You did %d damage!\n", v10, 10 * v10);
      v12 -= v9;
    }
    else if ( v6 == 2 )
    {
      if ( v11 <= 0 )
      {
        printf("You don't have any potions left!\n");
      }
      else
      {
        printf("You drank a potion! You gained 25 health!\n");
        v13 += 25;
        --v11;
      }
    }
    else
    {
      printf("I'm sorry, I didn't understand that.\n");
    }
    if ( v12 <= 0 )
    {
      printf("Congratulations, you defeated the enemy!\n");
      break;
    }
    printf("The enemy attacks!\n");
    v4 = time(0i64);
    srand(v4);
    v10 = rand() % 6 + 1;
    v8 = 8 * v10;
    printf("The enemy rolled a %d! You took %d damage!\n", v10, 8 * v10);
    v13 -= v8;
    if ( v13 <= 0 )
    {
      printf("Game over! You have been defeated.\n");
      break;
    }
  }
  printf("Thanks for playing!\n");
  return 0;
}
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: lively
#include <stdio.h>

int main() {

    printf("Welcome to the C Pattern printing program!\n");
    printf("Let's get started with creating some fun patterns.\n");

    // First pattern - Triangle
    printf("\nTriangle:\n");
    int rows = 5;
    for (int i = 1; i <= rows; ++i) {
        for (int j = 1; j <= i; ++j) {
            printf("* ");
        }
        printf("\n");
    }

    // Second pattern - Diamond
    printf("\nDiamond:\n");
    rows = 5;
    int k = 0;
    for (int i = 1; i <= rows; ++i, k = 0) {
        for (int j = 1; j <= rows - i; ++j) {
            printf("  ");
        }
        while (k != 2 * i - 1) {
            printf("* ");
            ++k;
        }
        printf("\n");
    }
    for (int i = rows - 1; i >= 1; --i, k = 0) {
        for (int j = 1; j <= rows - i; ++j) {
            printf("  ");
        }
        while (k != 2 * i - 1) {
            printf("* ");
            ++k;
        }
        printf("\n");
    }

    // Third pattern - Hourglass
    printf("\nHourglass:\n");
    rows = 4;
    k = 0;
    for (int i = rows; i >= 1; --i, k = 0) {
        for (int j = 0; j < rows - i; ++j) {
            printf(" ");
        }
        while (k != 2 * i - 1) {
            printf("*");
            ++k;
        }
        printf("\n");
    }
    k = 2;
    for (int i = 2; i <= rows; ++i, k = 0) {
        for (int j = 0; j < rows - i; ++j) {
            printf(" ");
        }
        while (k != 2 * i - 1) {
            printf("*");
            ++k;
        }
        printf("\n");
    }

    printf("\nHope you enjoyed creating these beautiful patterns with C programming!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int nn; // [rsp+24h] [rbp-2Ch]
  int mm; // [rsp+28h] [rbp-28h]
  int kk; // [rsp+2Ch] [rbp-24h]
  int jj; // [rsp+30h] [rbp-20h]
  int ii; // [rsp+34h] [rbp-1Ch]
  int n; // [rsp+38h] [rbp-18h]
  int m; // [rsp+3Ch] [rbp-14h]
  int k; // [rsp+40h] [rbp-10h]
  int v12; // [rsp+44h] [rbp-Ch]
  int v13; // [rsp+44h] [rbp-Ch]
  int v14; // [rsp+44h] [rbp-Ch]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the C Pattern printing program!\n");
  printf("Let's get started with creating some fun patterns.\n");
  printf("\nTriangle:\n");
  for ( i = 1; i <= 5; ++i )
  {
    for ( j = 1; j <= i; ++j )
      printf("* ");
    printf("\n");
  }
  printf("\nDiamond:\n");
  v12 = 0;
  for ( k = 1; k <= 5; ++k )
  {
    for ( m = 1; m <= 5 - k; ++m )
      printf("  ");
    while ( v12 != 2 * k - 1 )
    {
      printf("* ");
      ++v12;
    }
    printf("\n");
    v12 = 0;
  }
  for ( n = 4; n > 0; --n )
  {
    for ( ii = 1; ii <= 5 - n; ++ii )
      printf("  ");
    while ( v12 != 2 * n - 1 )
    {
      printf("* ");
      ++v12;
    }
    printf("\n");
    v12 = 0;
  }
  printf("\nHourglass:\n");
  v13 = 0;
  for ( jj = 4; jj > 0; --jj )
  {
    for ( kk = 0; kk < 4 - jj; ++kk )
      printf(L" *");
    while ( v13 != 2 * jj - 1 )
    {
      printf(L"*");
      ++v13;
    }
    printf("\n");
    v13 = 0;
  }
  v14 = 2;
  for ( mm = 2; mm <= 4; ++mm )
  {
    for ( nn = 0; nn < 4 - mm; ++nn )
      printf(L" *");
    while ( v14 != 2 * mm - 1 )
    {
      printf(L"*");
      ++v14;
    }
    printf("\n");
    v14 = 0;
  }
  printf("\nHope you enjoyed creating these beautiful patterns with C programming!\n");
  return 0;
}
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Recursive ; Style: excited
#include <stdio.h>

int fibonacci(int n) {
  if (n <= 1) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
  int n;
  printf("Enter the n-th term of the Fibonacci series: ");
  scanf("%d", &n);
  printf("The %d-th term of the Fibonacci series is: %d\n", n, fibonacci(n));
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall fibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001620) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the n-th term of the Fibonacci series: ");
  scanf("%d", &v5);
  v3 = fibonacci(v5);
  printf("The %d-th term of the Fibonacci series is: %d\n", v5, v3);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001730: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: URL Sanitizer ; Style: light-weight
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

/* Function declarations */
bool checkForIllegalChars(char c);
char* sanitizeURL(char* url);

/* Main function */
int main() {
    char url[100] = "https://www.example.com/search?q=c++";
    printf("Original URL: %s\n", url);
    printf("Sanitized URL: %s\n", sanitizeURL(url));
    return 0;
}

/* Function to check for illegal characters */
bool checkForIllegalChars(char c) {
    if (c == '<' || c == '>' || c == '\"' ||
        c == '#' || c == '%' || c == '{' ||
        c == '}' || c == '|' || c == '\\' ||
        c == '^' || c == '~' || c == '[' ||
        c == ']' || c == '``' || c == ';' ||
        c == '/' || c == '?') {
        return true;
    }
    return false;
}

/* Function to sanitize a URL */
char* sanitizeURL(char* url) {
    int i, j = 0;
    int len = strlen(url);
    char* sanitizedURL = (char*)malloc(len * sizeof(char));
    for (i = 0; i < len; i++) {
        if (!checkForIllegalChars(url[i])) {
            sanitizedURL[j] = url[i];
            j++;
        }
    }
    sanitizedURL[j] = '\0';
    return sanitizedURL;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall sanitizeURL(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rax
  _WORD v5[20]; // [rsp+20h] [rbp-70h] BYREF
  __int64 v6; // [rsp+48h] [rbp-48h]
  __int64 v7; // [rsp+50h] [rbp-40h]
  __int64 v8; // [rsp+58h] [rbp-38h]
  __int64 v9; // [rsp+60h] [rbp-30h]
  __int64 v10; // [rsp+68h] [rbp-28h]
  __int64 v11; // [rsp+70h] [rbp-20h]
  __int64 v12; // [rsp+78h] [rbp-18h]
  int v13; // [rsp+80h] [rbp-10h]

  _main(argc, argv, envp);
  strcpy((char *)v5, "https://www.example.com/search?q=c++");
  HIBYTE(v5[18]) = 0;
  v5[19] = 0;
  v6 = 0i64;
  v7 = 0i64;
  v8 = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0;
  printf("Original URL: %s\n", (const char *)v5);
  v3 = (const char *)sanitizeURL(v5);
  printf("Sanitized URL: %s\n", v3);
  return 0;
}
// 1400016DF: using guessed type __int64 __fastcall sanitizeURL(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Appointment Scheduler ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>

// Define global variables
#define MAX_LENGTH 256
#define MAX_APPOINTMENTS 50

// Define struct for appointment
typedef struct Appointment {
    char date[MAX_LENGTH];
    char time[MAX_LENGTH];
    char name[MAX_LENGTH];
    char type[MAX_LENGTH];
} Appointment;

// Define function to display appointments
void display_appointments(Appointment* appointments, int num_appointments) {
    printf("\n%-15s%-15s%-15s%-15s\n", "Date", "Time", "Name", "Type");
    for(int i=0; i<num_appointments; i++) {
        printf("%-15s%-15s%-15s%-15s\n", 
            appointments[i].date, 
            appointments[i].time, 
            appointments[i].name, 
            appointments[i].type);
    }
}

// Define function to add new appointment
void add_appointment(Appointment* appointments, int* num_appointments) {
    // Check if there is already maximum number of appointments
    if(*num_appointments >= MAX_APPOINTMENTS) {
        printf("\nMaximum number of appointments reached. Cannot add more appointments.\n");
        return;
    }
    
    // Create new appointment
    Appointment new_appointment;
    printf("\nEnter date of appointment (MM/DD/YYYY format): ");
    scanf("%s", new_appointment.date);
    printf("Enter time of appointment (HH:MM format): ");
    scanf("%s", new_appointment.time);
    printf("Enter name of person for appointment: ");
    scanf("%s", new_appointment.name);
    printf("Enter type of appointment: ");
    scanf("%s", new_appointment.type);
    
    // Add new appointment to array
    appointments[*num_appointments] = new_appointment;
    *num_appointments += 1;
    
    printf("\nAppointment added!\n");
}

// Define function to remove existing appointment
void remove_appointment(Appointment* appointments, int* num_appointments) {
    // Check if there are any appointments
    if(*num_appointments == 0) {
        printf("\nNo appointments to remove.\n");
        return;
    }
    
    // Get user input for appointment to remove
    char name[MAX_LENGTH];
    printf("\nEnter name of person for appointment to remove: ");
    scanf("%s", name);
    
    // Find index of appointment with matching name
    int index = -1;
    for(int i=0; i<*num_appointments; i++) {
        if(strcmp(appointments[i].name, name) == 0) {
            index = i;
            break;
        }
    }
    
    // Check if appointment was found
    if(index == -1) {
        printf("\nNo appointment found with that name.\n");
        return;
    }
    
    // Remove appointment from array
    for(int i=index; i<*num_appointments-1; i++) {
        appointments[i] = appointments[i+1];
    }
    *num_appointments -= 1;
    
    printf("\nAppointment removed!\n");
}

// Define function to find appointments on given date
void find_appointments(Appointment* appointments, int num_appointments) {
    // Get user input for date to search
    char date[MAX_LENGTH];
    printf("\nEnter date to find appointments (MM/DD/YYYY format): ");
    scanf("%s", date);
    
    // Print appointment(s) with matching date
    printf("\nAppointments on %s:\n", date);
    bool found = false;
    for(int i=0; i<num_appointments; i++) {
        if(strcmp(appointments[i].date, date) == 0) {
            printf("%s: %s with %s (%s)\n", 
                appointments[i].time, 
                appointments[i].type, 
                appointments[i].name, 
                appointments[i].date);
            found = true;
        }
    }
    if(!found) {
        printf("No appointments found on that date.\n");
    }
}

int main() {
    // Define variables
    int num_appointments = 0;
    Appointment appointments[MAX_APPOINTMENTS];
    bool running = true;
    char command[MAX_LENGTH];
    
    // Loop until user quits
    while(running) {
        // Display menu
        printf("\n---Appointment Scheduler---\n");
        printf("1. Display appointments\n");
        printf("2. Add appointment\n");
        printf("3. Remove appointment\n");
        printf("4. Find appointments\n");
        printf("5. Quit\n");
        printf("---------------------------\n");
        printf("Enter command: ");
        scanf("%s", command);
        
        // Choose action based on command
        if(strcmp(command, "1") == 0) {
            display_appointments(appointments, num_appointments);
        } else if(strcmp(command, "2") == 0) {
            add_appointment(appointments, &num_appointments);
        } else if(strcmp(command, "3") == 0) {
            remove_appointment(appointments, &num_appointments);
        } else if(strcmp(command, "4") == 0) {
            find_appointments(appointments, num_appointments);
        } else if(strcmp(command, "5") == 0) {
            running = false;
            printf("\nGoodbye!\n");
        } else {
            printf("\nInvalid command.\n");
        }
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall display_appointments(_QWORD, _QWORD); // weak
__int64 __fastcall add_appointment(_QWORD, _QWORD); // weak
__int64 __fastcall remove_appointment(_QWORD, _QWORD); // weak
__int64 __fastcall find_appointments(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (0000000140001BA3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[256]; // [rsp+20h] [rbp-60h] BYREF
  char v5[51208]; // [rsp+120h] [rbp+A0h] BYREF
  unsigned int v6; // [rsp+C928h] [rbp+C8A8h] BYREF
  char v7; // [rsp+C92Fh] [rbp+C8AFh]

  _main(argc, argv, envp);
  v6 = 0;
  v7 = 1;
  while ( v7 )
  {
    printf("\n---Appointment Scheduler---\n");
    printf("1. Display appointments\n");
    printf("2. Add appointment\n");
    printf("3. Remove appointment\n");
    printf("4. Find appointments\n");
    printf("5. Quit\n");
    printf("---------------------------\n");
    printf("Enter command: ");
    scanf("%s", Str1);
    if ( !strcmp(Str1, "1") )
    {
      display_appointments(v5, v6);
    }
    else if ( !strcmp(Str1, "2") )
    {
      add_appointment(v5, &v6);
    }
    else if ( !strcmp(Str1, "3") )
    {
      remove_appointment(v5, &v6);
    }
    else if ( !strcmp(Str1, "4") )
    {
      find_appointments(v5, v6);
    }
    else if ( !strcmp(Str1, "5") )
    {
      v7 = 0;
      printf("\nGoodbye!\n");
    }
    else
    {
      printf("\nInvalid command.\n");
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall display_appointments(_QWORD, _QWORD);
// 1400016C5: using guessed type __int64 __fastcall add_appointment(_QWORD, _QWORD);
// 14000184D: using guessed type __int64 __fastcall remove_appointment(_QWORD, _QWORD);
// 140001A26: using guessed type __int64 __fastcall find_appointments(_QWORD, _QWORD);
// 140001E30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001BA3: using guessed type unsigned int var_8;

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Tower of Hanoi Problem ; Style: Cryptic
#include <stdio.h>

// Recursive function to solve the Tower of Hanoi problem
void towerOfHanoi(int n, char fromRod, char toRod, char auxRod) {
    if (n == 1) {
        printf("\n Move disk 1 from rod %c to rod %c", fromRod, toRod);
        return;
    }
    towerOfHanoi(n - 1, fromRod, auxRod, toRod);
    printf("\n Move disk %d from rod %c to rod %c", n, fromRod, toRod);
    towerOfHanoi(n - 1, auxRod, toRod, fromRod);
}

int main() {
    int n = 4;  // Number of disks
    towerOfHanoi(n, 'A', 'C', 'B');  // A, B and C are the rods
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall towerOfHanoi(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001632) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  towerOfHanoi(4i64, 65i64, 67i64, 66i64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall towerOfHanoi(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Movie Rating System ; Style: futuristic
#include <stdio.h>

// Struct for movie rating data
typedef struct {
    char title[50];
    char genre[20];
    int year;
    float rating;
} movie;

int main() {
    int numMovies;
    printf("Welcome to the Movie Rating System!\n");
    printf("Please enter the number of movies you want to rate: ");
    scanf("%d", &numMovies);

    // Allocating memory for movies
    movie *movies = malloc(numMovies * sizeof(movie));

    // Getting data for each movie
    for (int i = 0; i < numMovies; i++) {
        printf("\nPlease enter the details for Movie #%d:\n", i+1);
        printf("Title: ");
        scanf("%s", movies[i].title);
        printf("Genre: ");
        scanf("%s", movies[i].genre);
        printf("Year: ");
        scanf("%d", &movies[i].year);
        printf("Rating (out of 10): ");
        scanf("%f", &movies[i].rating);
    }

    // Displaying all movie ratings
    printf("\n\nHere are the ratings for all movies entered:\n");
    for (int i = 0; i < numMovies; i++) {
        printf("\nMovie #%d\n", i+1);
        printf("Title: %s\n", movies[i].title);
        printf("Genre: %s\n", movies[i].genre);
        printf("Year: %d\n", movies[i].year);
        printf("Rating: %0.1f/10\n", movies[i].rating);
    }

    // Finding highest rated movie
    float highestRating = 0;
    int highestIndex = 0;
    for (int i = 0; i < numMovies; i++) {
        if (movies[i].rating > highestRating) {
            highestRating = movies[i].rating;
            highestIndex = i;
        }
    }
    printf("\n\nThe highest rated movie is:\n");
    printf("Title: %s\n", movies[highestIndex].title);
    printf("Genre: %s\n", movies[highestIndex].genre);
    printf("Year: %d\n", movies[highestIndex].year);
    printf("Rating: %0.1f/10\n", movies[highestIndex].rating);

    // Finding average rating for all movies
    float totalRating = 0;
    for (int i = 0; i < numMovies; i++) {
        totalRating += movies[i].rating;
    }
    float averageRating = totalRating / numMovies;
    printf("\n\nThe average rating for all movies is: %0.1f/10\n", averageRating);

    // Freeing memory allocated for movies
    free(movies);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-30h] BYREF
  float v5; // [rsp+24h] [rbp-2Ch]
  void *Block; // [rsp+28h] [rbp-28h]
  int m; // [rsp+34h] [rbp-1Ch]
  float v8; // [rsp+38h] [rbp-18h]
  int k; // [rsp+3Ch] [rbp-14h]
  int v10; // [rsp+40h] [rbp-10h]
  float v11; // [rsp+44h] [rbp-Ch]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Movie Rating System!\n");
  printf("Please enter the number of movies you want to rate: ");
  scanf("%d", &v4);
  Block = malloc(80i64 * v4);
  for ( i = 0; i < v4; ++i )
  {
    printf("\nPlease enter the details for Movie #%d:\n", (unsigned int)(i + 1));
    printf("Title: ");
    scanf("%s", (char *)Block + 80 * i);
    printf("Genre: ");
    scanf("%s", (char *)Block + 80 * i + 50);
    printf("Year: ");
    scanf("%d", (char *)Block + 80 * i + 72);
    printf("Rating (out of 10): ");
    scanf("%f", (char *)Block + 80 * i + 76);
  }
  printf("\n\nHere are the ratings for all movies entered:\n");
  for ( j = 0; j < v4; ++j )
  {
    printf("\nMovie #%d\n", (unsigned int)(j + 1));
    printf("Title: %s\n", (const char *)Block + 80 * j);
    printf("Genre: %s\n", (const char *)Block + 80 * j + 50);
    printf("Year: %d\n", *((unsigned int *)Block + 20 * j + 18));
    printf("Rating: %0.1f/10\n", *((float *)Block + 20 * j + 19));
  }
  v11 = 0.0;
  v10 = 0;
  for ( k = 0; k < v4; ++k )
  {
    if ( *((float *)Block + 20 * k + 19) > v11 )
    {
      v11 = *((float *)Block + 20 * k + 19);
      v10 = k;
    }
  }
  printf("\n\nThe highest rated movie is:\n");
  printf("Title: %s\n", (const char *)Block + 80 * v10);
  printf("Genre: %s\n", (const char *)Block + 80 * v10 + 50);
  printf("Year: %d\n", *((unsigned int *)Block + 20 * v10 + 18));
  printf("Rating: %0.1f/10\n", *((float *)Block + 20 * v10 + 19));
  v8 = 0.0;
  for ( m = 0; m < v4; ++m )
    v8 = *((float *)Block + 20 * m + 19) + v8;
  v5 = v8 / (float)v4;
  printf("\n\nThe average rating for all movies is: %0.1f/10\n", v5);
  free(Block);
  return 0;
}
// 140001B70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Terminal Based Game ; Style: high level of detail
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int player_health = 100, enemy_health = 100, player_attack, enemy_attack, round_count = 1;
    
    // set random seed for generating random numbers
    srand(time(NULL));
    
    // game loop
    while (player_health > 0 && enemy_health > 0) {
        printf("Round %d:\n", round_count);
        
        // player attack
        printf("Player's turn\n");
        printf("Enter attack strength (1-10): ");
        scanf("%d", &player_attack);
        if (player_attack < 1 || player_attack > 10) {
            printf("Invalid attack strength. Please enter a number between 1 and 10.\n");
            continue;
        }
        enemy_health -= player_attack;
        printf("Enemy's health decreased to %d\n", enemy_health);
        if (enemy_health <= 0) {
            printf("Player wins!\n");
            break;
        }
        
        // enemy attack
        printf("Enemy's turn\n");
        enemy_attack = rand() % 10 + 1;
        player_health -= enemy_attack;
        printf("Player's health decreased to %d\n", player_health);
        if (player_health <= 0) {
            printf("Enemy wins!\n");
            break;
        }
        
        round_count++;
    }
    
    printf("Game over.\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+2Ch] [rbp-14h] BYREF
  int v6; // [rsp+30h] [rbp-10h]
  unsigned int v7; // [rsp+34h] [rbp-Ch]
  int v8; // [rsp+38h] [rbp-8h]
  int v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 100;
  v8 = 100;
  v7 = 1;
  v3 = time(0i64);
  srand(v3);
  while ( v9 > 0 && v8 > 0 )
  {
    printf("Round %d:\n", v7);
    printf("Player's turn\n");
    printf("Enter attack strength (1-10): ");
    scanf("%d", &v5);
    if ( v5 > 0 && v5 <= 10 )
    {
      v8 -= v5;
      printf("Enemy's health decreased to %d\n", (unsigned int)v8);
      if ( v8 <= 0 )
      {
        printf("Player wins!\n");
        break;
      }
      printf("Enemy's turn\n");
      v6 = rand() % 10 + 1;
      v9 -= v6;
      printf("Player's health decreased to %d\n", (unsigned int)v9);
      if ( v9 <= 0 )
      {
        printf("Enemy wins!\n");
        break;
      }
      ++v7;
    }
    else
    {
      printf("Invalid attack strength. Please enter a number between 1 and 10.\n");
    }
  }
  printf("Game over.\n");
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Audio processing ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define PI 3.14159265358979323846

typedef struct complex {
    double r;   // real part
    double i;   // imaginary part
} Complex;

int main() {
    // generate an input signal
    const int N = 1024;
    double x[N];
    for (int i = 0; i < N; i++) {
        x[i] = sin(2 * PI * i / N * 10) + 0.5 * sin(2 * PI * i / N * 20);
    }

    // perform a DFT on the input signal
    Complex* X = (Complex*) malloc(N * sizeof(Complex));
    for (int k = 0; k < N; k++) {
        X[k].r = 0;
        X[k].i = 0;
        for (int n = 0; n < N; n++) {
            double phi = -2 * PI * k * n / N;
            Complex c = {cos(phi), sin(phi)};
            X[k].r += x[n] * c.r;
            X[k].i += x[n] * c.i;
        }
    }

    // apply a shape-shifting filter on the frequency domain signal
    for (int k = 0; k < N / 2; k++) {
        double r = sqrt(X[k].r * X[k].r + X[k].i * X[k].i);
        double phi = atan2(X[k].i, X[k].r);
        r = r * pow(sin(2 * PI * k / N), 2);   // shape-shifting filter
        X[k].r = r * cos(phi);
        X[k].i = r * sin(phi);
    }
    for (int k = N / 2; k < N; k++) {
        X[k].r = X[N - k].r;
        X[k].i = -X[N - k].i;
    }

    // perform an inverse DFT to get the output signal
    double y[N];
    for (int n = 0; n < N; n++) {
        y[n] = 0;
        for (int k = 0; k < N; k++) {
            double phi = 2 * PI * k * n / N;
            Complex c = {cos(phi), sin(phi)};
            y[n] += X[k].r * c.r - X[k].i * c.i;
        }
        y[n] /= N;
    }

    // print out the input and output signals
    for (int n = 0; n < N; n++) {
        printf("%f -> %f\n", x[n], y[n]);
    }

    // free up memory
    free(X);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl atan2(double Y, double X);
double __cdecl cos(double X);
double __cdecl pow(double X, double Y);
double __cdecl sin(double X);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  double v4; // xmm6_8
  double v5; // xmm0_8
  double v6; // xmm0_8
  double v7; // xmm0_8
  double v8; // xmm0_8
  double v9; // xmm0_8
  void *v10; // rsp
  __int64 v12[2]; // [rsp+20h] [rbp-A0h] BYREF
  double v13; // [rsp+30h] [rbp-90h]
  double v14; // [rsp+38h] [rbp-88h]
  double v15; // [rsp+40h] [rbp-80h]
  double v16; // [rsp+48h] [rbp-78h]
  double X; // [rsp+50h] [rbp-70h]
  double v18; // [rsp+58h] [rbp-68h]
  double v19; // [rsp+60h] [rbp-60h]
  double v20; // [rsp+68h] [rbp-58h]
  __int64 *v21; // [rsp+70h] [rbp-50h]
  __int64 v22; // [rsp+78h] [rbp-48h]
  void *Block; // [rsp+80h] [rbp-40h]
  __int64 *v24; // [rsp+88h] [rbp-38h]
  __int64 v25; // [rsp+90h] [rbp-30h]
  int v26; // [rsp+9Ch] [rbp-24h]
  int kk; // [rsp+A0h] [rbp-20h]
  int jj; // [rsp+A4h] [rbp-1Ch]
  int ii; // [rsp+A8h] [rbp-18h]
  int n; // [rsp+ACh] [rbp-14h]
  int m; // [rsp+B0h] [rbp-10h]
  int k; // [rsp+B4h] [rbp-Ch]
  int j; // [rsp+B8h] [rbp-8h]
  int i; // [rsp+BCh] [rbp-4h]

  _main(argc, argv, envp);
  v26 = 1024;
  v25 = 1023i64;
  v12[0] = 1024i64;
  v12[1] = 0i64;
  v3 = alloca(0x2000i64);
  v24 = v12;
  for ( i = 0; i < v26; ++i )
  {
    v4 = sin(6.283185307179586 * (double)i / (double)v26 * 10.0);
    v5 = sin(6.283185307179586 * (double)i / (double)v26 * 20.0);
    *(double *)&v24[i] = v5 * 0.5 + v4;
  }
  Block = malloc(16i64 * v26);
  for ( j = 0; j < v26; ++j )
  {
    *((_QWORD *)Block + 2 * j) = 0i64;
    *((_QWORD *)Block + 2 * j + 1) = 0i64;
    for ( k = 0; k < v26; ++k )
    {
      X = (double)k * ((double)j * -6.283185307179586) / (double)v26;
      v15 = cos(X);
      v16 = sin(X);
      *((double *)Block + 2 * j) = v15 * *(double *)&v24[k] + *((double *)Block + 2 * j);
      *((double *)Block + 2 * j + 1) = v16 * *(double *)&v24[k] + *((double *)Block + 2 * j + 1);
    }
  }
  for ( m = 0; m < v26 / 2; ++m )
  {
    v19 = sqrt(
            *((double *)Block + 2 * m) * *((double *)Block + 2 * m)
          + *((double *)Block + 2 * m + 1) * *((double *)Block + 2 * m + 1));
    v18 = atan2(*((double *)Block + 2 * m + 1), *((double *)Block + 2 * m));
    v6 = sin(6.283185307179586 * (double)m / (double)v26);
    v7 = pow(v6, 2.0);
    v19 = v7 * v19;
    v8 = cos(v18);
    *((double *)Block + 2 * m) = v8 * v19;
    v9 = sin(v18);
    *((double *)Block + 2 * m + 1) = v9 * v19;
  }
  for ( n = v26 / 2; n < v26; ++n )
  {
    *((_QWORD *)Block + 2 * n) = *((_QWORD *)Block + 2 * (v26 - n));
    *((double *)Block + 2 * n + 1) = -*((double *)Block + 2 * (v26 - n) + 1);
  }
  v22 = v26 - 1i64;
  v10 = alloca(16 * ((unsigned __int64)(8i64 * v26 + 15) >> 4));
  v21 = v12;
  for ( ii = 0; ii < v26; ++ii )
  {
    v21[ii] = 0i64;
    for ( jj = 0; jj < v26; ++jj )
    {
      v20 = (double)ii * ((double)jj * 6.283185307179586) / (double)v26;
      v13 = cos(v20);
      v14 = sin(v20);
      *(double *)&v21[ii] = v13 * *((double *)Block + 2 * jj)
                          - v14 * *((double *)Block + 2 * jj + 1)
                          + *(double *)&v21[ii];
    }
    *(double *)&v21[ii] = *(double *)&v21[ii] / (double)v26;
  }
  for ( kk = 0; kk < v26; ++kk )
    printf("%f -> %f\n", *(double *)&v24[kk], *(double *)&v21[kk]);
  free(Block);
  return 0;
}
// 140001D90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=148 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Robot movement control ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int x = 0;
    int y = 0;
    srand(time(NULL));
    printf("Welcome to the Immersive C Robot Movement Control Program!\n\n");
    printf("Starting position: x = %d, y = %d\n\n", x, y);
    printf("Please input the number of steps you would like the robot to take: ");
    int steps;
    scanf("%d", &steps);
    printf("\n");

    for (int i = 0; i < steps; i++) {
        int direction = rand() % 4 + 1;
        switch (direction) {
            case 1: // move up
                y++;
                printf("Move #%d: Moved up! New position: x = %d, y = %d\n", i+1, x, y);
                break;
            case 2: // move down
                y--;
                printf("Move #%d: Moved down! New position: x = %d, y = %d\n", i+1, x, y);
                break;
            case 3: // move right
                x++;
                printf("Move #%d: Moved right! New position: x = %d, y = %d\n", i+1, x, y);
                break;
            case 4: // move left
                x--;
                printf("Move #%d: Moved left! New position: x = %d, y = %d\n", i+1, x, y);
                break;
        }
    }

    printf("\nRobot has completed its movements!\n");
    printf("Final position: x = %d, y = %d\n", x, y);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax
  int v6; // [rsp+2Ch] [rbp-14h] BYREF
  int v7; // [rsp+30h] [rbp-10h]
  int i; // [rsp+34h] [rbp-Ch]
  unsigned int v9; // [rsp+38h] [rbp-8h]
  unsigned int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 0;
  v9 = 0;
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Immersive C Robot Movement Control Program!\n\n");
  printf("Starting position: x = %d, y = %d\n\n", 0i64, 0i64);
  printf("Please input the number of steps you would like the robot to take: ");
  scanf("%d", &v6);
  printf("\n");
  for ( i = 0; i < v6; ++i )
  {
    v4 = rand();
    v7 = v4 % 4 + 1;
    if ( v4 % 4 == 3 )
    {
      printf("Move #%d: Moved left! New position: x = %d, y = %d\n", (unsigned int)(i + 1), --v10, v9);
    }
    else if ( v7 <= 4 )
    {
      if ( v7 == 3 )
      {
        printf("Move #%d: Moved right! New position: x = %d, y = %d\n", (unsigned int)(i + 1), ++v10, v9);
      }
      else if ( v7 <= 3 )
      {
        if ( v7 == 1 )
        {
          printf("Move #%d: Moved up! New position: x = %d, y = %d\n", (unsigned int)(i + 1), v10, ++v9);
        }
        else if ( v7 == 2 )
        {
          printf("Move #%d: Moved down! New position: x = %d, y = %d\n", (unsigned int)(i + 1), v10, --v9);
        }
      }
    }
  }
  printf("\nRobot has completed its movements!\n");
  printf("Final position: x = %d, y = %d\n", v10, v9);
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Error handling ; Style: cheerful
#include <stdio.h>
#include <stdlib.h>

int main()
{
    printf("Welcome to my error handling program! Let's make sure everything runs smoothly!\n");
    
    int num1, num2, result;
    
    printf("Enter the first number: ");
    if (scanf("%d",&num1) != 1) //Checking if user enters a number or not
    {
        printf("Oops! That wasn't a number. Please try again.\n");
        exit(EXIT_FAILURE); //Exiting the program with an error code
    }
    
    printf("Enter the second number: ");
    if (scanf("%d",&num2) != 1)
    {
        printf("Oops! That wasn't a number. Please try again.\n");
        exit(EXIT_FAILURE);
    }
    
    if(num2 == 0) //Checking if second number is zero for division operation
    {
        printf("Oops! Cannot divide by zero. Please try again.\n");
        exit(EXIT_FAILURE);
    }
    
    result = num1/num2; //Performing division operation
    
    printf("The result of division is: %d\n",result);
    
    printf("Yay! We made it through without any errors. Thank you for using my program!\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  int v5[2]; // [rsp+28h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to my error handling program! Let's make sure everything runs smoothly!\n");
  printf("Enter the first number: ");
  if ( scanf("%d", v5) != 1 )
  {
    printf("Oops! That wasn't a number. Please try again.\n");
    exit(1);
  }
  printf("Enter the second number: ");
  if ( scanf("%d", &v4) != 1 )
  {
    printf("Oops! That wasn't a number. Please try again.\n");
    exit(1);
  }
  if ( !v4 )
  {
    printf("Oops! Cannot divide by zero. Please try again.\n");
    exit(1);
  }
  v5[1] = v5[0] / v4;
  printf("The result of division is: %d\n", (unsigned int)(v5[0] / v4));
  printf("Yay! We made it through without any errors. Thank you for using my program!\n");
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Benchmarking ; Style: recursive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int fibonacci(int n)
{
    if(n == 0)
        return 0;
    else if(n == 1)
        return 1;
    else
        return (fibonacci(n-1) + fibonacci(n-2));
}

int main()
{
    clock_t start, end;
    double cpu_time_used;
    start = clock();
    
    int n = 30; // change the value to change fibonacci term to be calculated
    
    printf("Fibonacci term %d is %d\n", n, fibonacci(n));
    
    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
    
    printf("Time taken: %f seconds\n", cpu_time_used);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall fibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// clock_t __cdecl clock();


//----- (00000001400015DE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  double v5; // [rsp+28h] [rbp-18h]
  clock_t v6; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = clock();
  v3 = fibonacci(30i64);
  printf("Fibonacci term %d is %d\n", 30i64, v3);
  v5 = (double)(clock() - v6) / 1000.0;
  printf("Time taken: %f seconds\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Alien Invasion Probability Calculator ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    printf("********** ALIEN INVASION PROBABILITY CALCULATOR **********\n\n");

    srand(time(0));
    
    int num_aliens = rand() % 100; // Generating the number of aliens between 0 and 100
    float alien_strength = (float) (rand() % 1000) / 1000; // Generating the alien strength between 0 and 1
    
    printf("Generating random numbers...\n\n");
    printf("Number of Aliens: %d\nAlien Strength: %.2f\n\n", num_aliens, alien_strength);
    
    float battle_strength; // To store the battle strength of humans
    
    printf("Enter the battle strength of humans (between 0 and 1): ");
    scanf("%f", &battle_strength);
    
    if (battle_strength < 0 || battle_strength > 1) {
        printf("Invalid input. Please enter a number between 0 and 1.\n");
        return 0;
    }
    
    float probability = (1 - alien_strength) * num_aliens * battle_strength; // Calculating the probability of alien invasion
    
    printf("\nALIEN INVASION PROBABILITY: %.2f%%\n", probability * 100);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  float v5; // [rsp+20h] [rbp-10h] BYREF
  float v6; // [rsp+24h] [rbp-Ch]
  float v7; // [rsp+28h] [rbp-8h]
  unsigned int v8; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("********** ALIEN INVASION PROBABILITY CALCULATOR **********\n\n");
  v3 = time(0i64);
  srand(v3);
  v8 = rand() % 100;
  v7 = (float)(rand() % 1000) / 1000.0;
  printf("Generating random numbers...\n\n");
  printf("Number of Aliens: %d\nAlien Strength: %.2f\n\n", v8, v7);
  printf("Enter the battle strength of humans (between 0 and 1): ");
  scanf("%f", &v5);
  if ( v5 >= 0.0 && v5 <= 1.0 )
  {
    v6 = v5 * (float)((float)(1.0 - v7) * (float)(int)v8);
    printf("\nALIEN INVASION PROBABILITY: %.2f%%\n", (float)(100.0 * v6));
    return 0;
  }
  else
  {
    printf("Invalid input. Please enter a number between 0 and 1.\n");
    return 0;
  }
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Terminal Based Game ; Style: scalable
#include<stdio.h>
#include<time.h>
#include<stdlib.h>

//Function for generating random numbers
int generateRandom(int n)
{
    srand(time(NULL));
    return rand()%n;
}

int main()
{
    int number, guess, nguesses=1;
    number = generateRandom(100);
    printf("Guess the number between 1 and 100\n");
    //Loop for receiving guesses from user
    do
    {
        scanf("%d",&guess);
        if(guess < number)
        {
            printf("Enter a higher number!\n");
            nguesses++;
        }
        else if(guess > number)
        {
            printf("Enter a lower number!\n");
            nguesses++;
        }
        else
        {
            printf("Congratulations! You guessed the number in %d attempts!\n",nguesses);
        }
    } while (guess!=number);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generateRandom(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000162E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  int Random; // [rsp+28h] [rbp-8h]
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 1;
  Random = generateRandom(100i64);
  printf("Guess the number between 1 and 100\n");
  do
  {
    scanf("%d", &v4);
    if ( Random <= v4 )
    {
      if ( Random >= v4 )
      {
        printf("Congratulations! You guessed the number in %d attempts!\n", v6);
      }
      else
      {
        printf("Enter a lower number!\n");
        ++v6;
      }
    }
    else
    {
      printf("Enter a higher number!\n");
      ++v6;
    }
  }
  while ( Random != v4 );
  return 0;
}
// 140001601: using guessed type __int64 __fastcall generateRandom(_QWORD);
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: scientific
#include <stdio.h> 
#include <stdlib.h>
#include <time.h>

// define the grid size
#define N 10

// define probability for the site to open
#define P 0.6

// Define a structure for the site coordinates
typedef struct {
    int row;
    int col;
} site;

// The grid to store the open state of the sites
int grid[N][N];

// Function to check if the site is open
int is_open(site s) {
    
    return grid[s.row][s.col] == 1;
}

// Function to open a site
void open(site s) {
    
    grid[s.row][s.col] = 1;
}

// Function to check if a system percolates using depth-first search
int dfs(site s) {
    
    // If the site is in the last row, it is connected to the top
    if (s.row == N - 1) {
        return 1;
    }
    
    // Mark the current site as open
    open(s);
    
    // Check neighboring sites for openness
    site neighbors[] = {{s.row + 1, s.col}, {s.row, s.col + 1}, 
                        {s.row - 1, s.col}, {s.row, s.col - 1}};
    
    for (int i = 0; i < 4; i++) {
        site neighbor = neighbors[i];
        if (neighbor.row >= 0 && neighbor.row < N && neighbor.col >= 0 && neighbor.col < N) {
            if (is_open(neighbor)) {
                if (dfs(neighbor)) {
                    return 1;
                }
            }
        }
    }
    
    return 0;
}

// Function to simulate percolation
int percolate() {
    
    // Initialize the grid to be all closed sites
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            grid[i][j] = 0;
        }
    }
    
    // Open the sites with probability P
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if ((double)rand() / (double)RAND_MAX < P) {
                open((site){i, j});
            }
        }
    }
    
    // Check if the system percolates
    for (int j = 0; j < N; j++) {
        if (dfs((site){0, j})) {
            return 1;
        }
    }
    
    return 0;
}

int main() {
    
    srand(time(NULL));
    
    printf("Percolation simulation...\n");
    printf("Grid size: %d x %d\n", N, N);
    printf("Site percolation probability: %f\n", P);
    
    int num_simulations = 100;
    int num_percolations = 0;
    
    // Perform multiple simulations to get an average percolation probability
    for (int i = 0; i < num_simulations; i++) {
        if (percolate()) {
            num_percolations++;
        }
    }
    
    double percolation_probability = (double)num_percolations / (double)num_simulations;
    
    printf("Percolation probability: %f\n", percolation_probability);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 percolate(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001836) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int i; // [rsp+38h] [rbp-8h]
  int v6; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Percolation simulation...\n");
  printf("Grid size: %d x %d\n", 10i64, 10i64);
  printf("Site percolation probability: %f\n", 0.6);
  v6 = 0;
  for ( i = 0; i < 100; ++i )
  {
    if ( (unsigned int)percolate() )
      ++v6;
  }
  printf("Percolation probability: %f\n", (double)v6 / (double)100);
  return 0;
}
// 140001702: using guessed type __int64 percolate(void);
// 1400019D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Appointment Scheduler ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// declaring global variables
int day = 0, hour = 0;

// declaring function to schedule an appointment
void scheduleAppointment(char* name, int chosenDay, int chosenHour) {
    // if day and hour is already taken, display error message
    if (chosenDay == day && chosenHour == hour) {
        printf("Sorry, that appointment slot has already been taken. Please select a different day and time.\n");
    } 
    else {
        // update global variables
        day = chosenDay;
        hour = chosenHour;
        // display success message
        printf("%s, your appointment has been scheduled for day %d at hour %d.\n", name, day, hour);
    }
}

int main() {
    // declaring variables
    char name[50], choice[10];
    int chosenDay, chosenHour;
    // loop until user decides to quit
    while (1) {
        // display menu options
        printf("\nAppointment Scheduler Menu:\n");
        printf("1. Schedule Appointment\n");
        printf("2. View Appointment\n");
        printf("3. Quit\n");
        printf("Enter your choice (1, 2 or 3): ");
        // read user's choice
        scanf("%s", choice);
        // perform corresponding action based on user's choice
        if (strcmp(choice, "1") == 0) {
            // read user's name, day and hour to schedule an appointment
            printf("Enter your name: ");
            scanf("%s", name);
            printf("Enter the day you want to schedule the appointment (1-7): ");
            scanf("%d", &chosenDay);
            printf("Enter the hour you want to schedule the appointment (8-17): ");
            scanf("%d", &chosenHour);
            // schedule the appointment
            scheduleAppointment(name, chosenDay, chosenHour);
        } 
        else if (strcmp(choice, "2") == 0) {
            // if no appointment has been scheduled yet, display message
            if (day == 0 && hour == 0) {
                printf("No appointment has been scheduled yet.\n");
            } 
            else {
                // display appointment details
                printf("Appointment for day %d at hour %d has been scheduled.\n", day, hour);
            }
        }
        else if (strcmp(choice, "3") == 0) {
            // quit the program
            printf("Thank you for using the Appointment Scheduler. Goodbye.\n");
            exit(0);
        } 
        else {
            // if user enters an invalid choice, display error message
            printf("Invalid choice. Please enter 1, 2 or 3.\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall scheduleAppointment(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

int day; // weak
int hour; // weak


//----- (000000014000165B) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // [rsp+2Ch] [rbp-54h] BYREF
  unsigned int v4; // [rsp+30h] [rbp-50h] BYREF
  char Str1[10]; // [rsp+36h] [rbp-4Ah] BYREF
  char v6[64]; // [rsp+40h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        printf("\nAppointment Scheduler Menu:\n");
        printf("1. Schedule Appointment\n");
        printf("2. View Appointment\n");
        printf("3. Quit\n");
        printf("Enter your choice (1, 2 or 3): ");
        scanf("%s", Str1);
        if ( strcmp(Str1, "1") )
          break;
        printf("Enter your name: ");
        scanf("%s", v6);
        printf("Enter the day you want to schedule the appointment (1-7): ");
        scanf("%d", &v4);
        printf("Enter the hour you want to schedule the appointment (8-17): ");
        scanf("%d", &v3);
        scheduleAppointment(v6, v4, v3);
      }
      if ( strcmp(Str1, "2") )
        break;
      if ( day || hour )
        printf("Appointment for day %d at hour %d has been scheduled.\n", (unsigned int)day, (unsigned int)hour);
      else
        printf("No appointment has been scheduled yet.\n");
    }
    if ( !strcmp(Str1, "3") )
    {
      printf("Thank you for using the Appointment Scheduler. Goodbye.\n");
      exit(0);
    }
    printf("Invalid choice. Please enter 1, 2 or 3.\n");
  }
}
// 1400015E2: using guessed type __int64 __fastcall scheduleAppointment(_QWORD, _QWORD, _QWORD);
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140018040: using guessed type int day;
// 140018044: using guessed type int hour;
// 14000165B: using guessed type unsigned int var_50;

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: introspective
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int min(int a, int b, int c)
{
    if (a < b && a < c)
        return a;
    else if (b < c)
        return b;
    else
        return c;
}

int levenshtein_distance(char *s1, char *s2)
{
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    int **dp = (int **)malloc(sizeof(int *) * (len1 + 1));
    for (int i = 0; i <= len1; i++)
    {
        dp[i] = (int *)malloc(sizeof(int) * (len2 + 1));
    }

    for (int i = 0; i <= len1; i++)
        dp[i][0] = i;

    for (int j = 0; j <= len2; j++)
        dp[0][j] = j;

    for (int i = 1; i <= len1; i++)
    {
        for (int j = 1; j <= len2; j++)
        {
            int cost = s1[i - 1] == s2[j - 1] ? 0 : 1;
            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
        }
    }

    int result = dp[len1][len2];

    for (int i = 0; i <= len1; i++)
    {
        free(dp[i]);
    }

    free(dp);

    return result;
}

int main()
{
    char s1[100], s2[100];

    printf("Enter string 1: ");
    fgets(s1, 100, stdin);
    s1[strlen(s1) - 1] = '\0';

    printf("Enter string 2: ");
    fgets(s2, 100, stdin);
    s2[strlen(s2) - 1] = '\0';

    int result = levenshtein_distance(s1, s2);

    printf("Levenshtein distance between '%s' and '%s' is %d", s1, s2, result);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall levenshtein_distance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000183A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Str[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[108]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v8; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter string 1: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strlen(Buffer) - 1] = 0;
  printf("Enter string 2: ");
  v4 = __acrt_iob_func(0);
  fgets(Str, 100, v4);
  Str[strlen(Str) - 1] = 0;
  v8 = levenshtein_distance(Buffer, Str);
  printf("Levenshtein distance between '%s' and '%s' is %d", Buffer, Str, v8);
  return 0;
}
// 1400015C6: using guessed type __int64 __fastcall levenshtein_distance(_QWORD, _QWORD);
// 1400019E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000183A: using guessed type char Buffer[108];
// 14000183A: using guessed type char Str[112];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: multiplayer
#include<stdio.h>

int main() {
   int players, rounds;
   printf("Enter the number of players: ");
   scanf("%d", &players);
   printf("Enter the number of rounds to simulate: ");
   scanf("%d", &rounds);

   int scores[players][rounds]; // 2D array to store scores of players per round.

   printf("Enter the initial scores of players:\n");
   for (int i = 0; i < players; i++) {
      for (int j = 0; j < rounds; j++) {
         scanf("%d", &scores[i][j]);
      }
   }

   printf("Simulation starting...\n");

   for (int j = 0; j < rounds; j++) {
      printf("Round %d\n", j+1);
      for (int i = 0; i < players; i++) {
         int score;
         printf("Player %d, enter your score for this round: ", i+1);
         scanf("%d", &score);
         scores[i][j] += score;
      }
   }

   printf("Simulation complete!\n");

   for (int i = 0; i < players; i++) {
      int total_score = 0;
      for (int j = 0; j < rounds; j++) {
         total_score += scores[i][j];
      }
      printf("Player %d total score: %d\n", i+1, total_score);
   }

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned __int64 v3; // rbx
  void *v4; // rsp
  __int64 v6; // [rsp+0h] [rbp-A0h] BYREF
  char v7; // [rsp+20h] [rbp-80h] BYREF
  __int64 *v8; // [rsp+28h] [rbp-78h]
  __int64 v9; // [rsp+30h] [rbp-70h]
  __int64 v10; // [rsp+38h] [rbp-68h]
  __int64 v11; // [rsp+40h] [rbp-60h]
  __int64 v12; // [rsp+48h] [rbp-58h]
  int v13; // [rsp+5Ch] [rbp-44h] BYREF
  int v14; // [rsp+60h] [rbp-40h] BYREF
  int v15; // [rsp+64h] [rbp-3Ch] BYREF
  char *v16; // [rsp+68h] [rbp-38h]
  __int64 v17; // [rsp+70h] [rbp-30h]
  __int64 v18; // [rsp+78h] [rbp-28h]
  int ii; // [rsp+84h] [rbp-1Ch]
  unsigned int v20; // [rsp+88h] [rbp-18h]
  int n; // [rsp+8Ch] [rbp-14h]
  int m; // [rsp+90h] [rbp-10h]
  int k; // [rsp+94h] [rbp-Ch]
  int j; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = &v6;
  printf("Enter the number of players: ");
  scanf("%d", &v15);
  printf("Enter the number of rounds to simulate: ");
  scanf("%d", &v14);
  v18 = v14 - 1i64;
  v9 = v14;
  v10 = 0i64;
  v3 = 4i64 * v14;
  v17 = v15 - 1i64;
  v11 = v14;
  v12 = 0i64;
  v4 = alloca(16 * ((unsigned __int64)(4 * v14 * (__int64)v15 + 15) >> 4));
  v16 = &v7;
  printf("Enter the initial scores of players:\n");
  for ( i = 0; i < v15; ++i )
  {
    for ( j = 0; j < v14; ++j )
      scanf("%d", &v16[4 * j + 4 * (v3 >> 2) * i]);
  }
  printf("Simulation starting...\n");
  for ( k = 0; k < v14; ++k )
  {
    printf("Round %d\n", (unsigned int)(k + 1));
    for ( m = 0; m < v15; ++m )
    {
      printf("Player %d, enter your score for this round: ", (unsigned int)(m + 1));
      scanf("%d", &v13);
      *(_DWORD *)&v16[4 * k + 4 * (v3 >> 2) * m] += v13;
    }
  }
  printf("Simulation complete!\n");
  for ( n = 0; n < v15; ++n )
  {
    v20 = 0;
    for ( ii = 0; ii < v14; ++ii )
      v20 += *(_DWORD *)&v16[4 * ii + 4 * (v3 >> 2) * n];
    printf("Player %d total score: %d\n", (unsigned int)(n + 1), v20);
  }
  return 0;
}
// 1400019D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Syntax parsing ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>

#define MAX_LENGTH 100

char* removeWhitespace(char* str) {
    int i, j;
    char* output = malloc(sizeof(char) * MAX_LENGTH);

    for (i = 0, j = 0; str[i] != '\0'; i++) {
        if (str[i] != ' ' && str[i] != '\t' && str[i] != '\n') {
            output[j] = str[i];
            j++;
        }
    }

    output[j] = '\0';
    return output;  
}

int main() {
    char input[MAX_LENGTH];
    char* noWhitespace;
    int i;

    printf("Enter C syntax: ");
    fgets(input, MAX_LENGTH, stdin);

    noWhitespace = removeWhitespace(input);

    printf("The syntax without whitespace: %s\n", noWhitespace);
    free(noWhitespace);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall removeWhitespace(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000164C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[104]; // [rsp+20h] [rbp-70h] BYREF
  void *Block; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter C syntax: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Block = (void *)removeWhitespace(Buffer);
  printf("The syntax without whitespace: %s\n", (const char *)Block);
  free(Block);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall removeWhitespace(_QWORD);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: cheerful
#include <stdio.h>

int main() {
    int numTerms;
    
    printf("Welcome to the Fibonacci Sequence Visualizer! Let's brighten up your day with some joyful numbers :)\n");
    
    printf("Please enter the number of terms you would like to see: ");
    scanf("%d", &numTerms);
    
    int n1 = 0, n2 = 1, nextTerm;
    
    printf("\n");
    printf("Here's your Fibonacci Sequence visualized with smileys:\n");
    
    printf(":) ");
    for (int i = 1; i <= numTerms; ++i) {
        printf("%d", n1);
        
        for (int j = 0; j < n1; ++j) {
            printf(" :)");
        }
        
        nextTerm = n1 + n2;
        n1 = n2;
        n2 = nextTerm;
        
        printf("\n");
        printf(":) ");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-18h] BYREF
  int v5; // [rsp+2Ch] [rbp-14h]
  int j; // [rsp+30h] [rbp-10h]
  int i; // [rsp+34h] [rbp-Ch]
  int v8; // [rsp+38h] [rbp-8h]
  unsigned int v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Fibonacci Sequence Visualizer! Let's brighten up your day with some joyful numbers :)\n");
  printf("Please enter the number of terms you would like to see: ");
  scanf("%d", &v4);
  v9 = 0;
  v8 = 1;
  printf("\n");
  printf("Here's your Fibonacci Sequence visualized with smileys:\n");
  printf(":) ");
  for ( i = 1; i <= v4; ++i )
  {
    printf("%d", v9);
    for ( j = 0; j < (int)v9; ++j )
      printf(" :)");
    v5 = v9 + v8;
    v9 = v8;
    v8 = v5;
    printf("\n");
    printf(":) ");
  }
  return 0;
}
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Performance-Critical Component ; Style: optimized
#include <stdio.h>
#include <stdlib.h>

#define SIZE 100000

void multiply(int *a, int *b, int *c, int n) {
    int i, j;
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            c[i * n + j] = a[i * n + j] * b[i * n + j];
        }
    }
}

int main() {
    int *a, *b, *c;
    int i, n;

    a = (int *)malloc(SIZE * SIZE * sizeof(int));
    b = (int *)malloc(SIZE * SIZE * sizeof(int));
    c = (int *)malloc(SIZE * SIZE * sizeof(int));

    n = SIZE;

    // initialize matrices
    for (i = 0; i < n * n; i++) {
        a[i] = i % n;
        b[i] = (i + 1) % n;
    }

    multiply(a, b, c, n);

    // print matrix
    for (i = 0; i < n * n; i++) {
        if (i % n == 0) {
            printf("\n");
        }
        printf("%d ", c[i]);
    }

    free(a);
    free(b);
    free(c);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall multiply(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (000000014000164C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int *v4; // [rsp+30h] [rbp-20h]
  _DWORD *v5; // [rsp+38h] [rbp-18h]
  _DWORD *Block; // [rsp+40h] [rbp-10h]
  int i; // [rsp+4Ch] [rbp-4h]
  int j; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  Block = malloc(0x1502F9000ui64);
  v5 = malloc(0x1502F9000ui64);
  v4 = (unsigned int *)malloc(0x1502F9000ui64);
  for ( i = 0; i < 1410065408; ++i )
  {
    Block[i] = i % 100000;
    v5[i] = (i + 1) % 100000;
  }
  multiply(Block, v5, v4, 100000i64);
  for ( j = 0; j < 1410065408; ++j )
  {
    if ( !(j % 100000) )
      printf("\n");
    printf("%d ", v4[j]);
  }
  free(Block);
  free(v5);
  free(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall multiply(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game of Life ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>

#define ROWS 20
#define COLS 30

void printGrid(bool grid[ROWS][COLS]) {
    system("clear");
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (grid[i][j]) {
                printf("O");
            } else {
                printf(".");
            }
        }
        printf("\n");
    }
}

bool applyRules(bool currentGrid[ROWS][COLS], int row, int col) {
    int liveNeighbors = 0;

    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            if (i == 0 && j == 0) {
                continue;
            }

            int currentRow = row + i;
            int currentCol = col + j;

            if (currentRow < 0 || currentRow >= ROWS || currentCol < 0 || currentCol >= COLS) {
                continue;
            }

            if (currentGrid[currentRow][currentCol]) {
                liveNeighbors++;
            }
        }
    }

    if (currentGrid[row][col] && liveNeighbors < 2) {
        // underpopulation
        return false;
    } else if (currentGrid[row][col] && (liveNeighbors == 2 || liveNeighbors == 3)) {
        // live on to next generation
        return true;
    } else if (currentGrid[row][col] && liveNeighbors > 3) {
        // overpopulation
        return false;
    } else if (!currentGrid[row][col] && liveNeighbors == 3) {
        // reproduction
        return true;
    }

    return false;
}

int main() {
    bool grid[ROWS][COLS] = { false };

    // initial grid setup
    grid[5][5] = true;
    grid[5][6] = true;
    grid[6][5] = true;
    grid[6][7] = true;
    grid[7][6] = true;

    while (true) {
        printGrid(grid);

        bool newGrid[ROWS][COLS] = { false };

        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                newGrid[i][j] = applyRules(grid, i, j);
            }
        }

        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                grid[i][j] = newGrid[i][j];
            }
        }

        usleep(100000);
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall printGrid(_QWORD, _QWORD); // weak
__int64 __fastcall applyRules(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall usleep(_QWORD); // weak


//----- (00000001400017DB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v3; // rdx
  char v4; // al
  char v6[608]; // [rsp+20h] [rbp-60h] BYREF
  char v7[608]; // [rsp+280h] [rbp+200h] BYREF
  int m; // [rsp+4E0h] [rbp+460h]
  int k; // [rsp+4E4h] [rbp+464h]
  unsigned int j; // [rsp+4E8h] [rbp+468h]
  unsigned int i; // [rsp+4ECh] [rbp+46Ch]

  _main(argc, argv, envp);
  v3 = v7;
  memset(v7, 0, 0x258ui64);
  v7[155] = 1;
  v7[156] = 1;
  v7[185] = 1;
  v7[187] = 1;
  v7[216] = 1;
  while ( 1 )
  {
    printGrid(v7, v3);
    memset(v6, 0, 0x258ui64);
    for ( i = 0; (int)i <= 19; ++i )
    {
      for ( j = 0; (int)j <= 29; ++j )
      {
        v4 = applyRules(v7, i, j);
        v6[30 * i + j] = v4;
      }
    }
    for ( k = 0; k <= 19; ++k )
    {
      for ( m = 0; m <= 29; ++m )
        v6[30 * k + 608 + m] = v6[30 * k + m];
    }
    usleep(100000i64);
  }
}
// 140001835: variable 'v3' is possibly undefined
// 140001591: using guessed type __int64 __fastcall printGrid(_QWORD, _QWORD);
// 140001633: using guessed type __int64 __fastcall applyRules(_QWORD, _QWORD, _QWORD);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002AB0: using guessed type __int64 __fastcall usleep(_QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Rogue-like Game with Procedural Generation ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAP_SIZE 100
#define MAX_ROOMS 20
#define MAX_ROOM_SIZE 10

typedef struct {
    int x, y, w, h;
} room_t;

char map[MAP_SIZE][MAP_SIZE];
room_t rooms[MAX_ROOMS];

void init_map() {
    int i, j;
    for (i = 0; i < MAP_SIZE; i++) {
        for (j = 0; j < MAP_SIZE; j++) {
            map[i][j] = '#';
        }
    }
}

int is_overlap(room_t r1, room_t r2) {
    int r1_x1 = r1.x;
    int r1_x2 = r1.x + r1.w - 1;
    int r1_y1 = r1.y;
    int r1_y2 = r1.y + r1.h - 1;

    int r2_x1 = r2.x;
    int r2_x2 = r2.x + r2.w - 1;
    int r2_y1 = r2.y;
    int r2_y2 = r2.y + r2.h - 1;

    if (r1_x1 <= r2_x2 && r1_x2 >= r2_x1 && r1_y1 <= r2_y2 && r1_y2 >= r2_y1) {
        return 1;
    } else {
        return 0;
    }
}

void place_room(int i) {
    int x, y, w, h, j;
    room_t room;

    do {
        x = rand() % (MAP_SIZE - MAX_ROOM_SIZE);
        y = rand() % (MAP_SIZE - MAX_ROOM_SIZE);
        w = rand() % MAX_ROOM_SIZE + 1;
        h = rand() % MAX_ROOM_SIZE + 1;

        room.x = x;
        room.y = y;
        room.w = w;
        room.h = h;

        for (j = 0; j < i; j++) {
            if (is_overlap(room, rooms[j])) {
                break;
            }
        }

    } while (j < i);

    rooms[i] = room;

    for (x = room.x + 1; x < room.x + room.w - 1; x++) {
        for (y = room.y + 1; y < room.y + room.h - 1; y++) {
            map[x][y] = '.';
        }
    }
}

void connect_rooms() {
    int i, x, y;
    room_t r1, r2;

    for (i = 1; i < MAX_ROOMS; i++) {
        r1 = rooms[i - 1];
        r2 = rooms[i];

        x = rand() % (r1.w - 2) + r1.x + 1;
        y = rand() % (r1.h - 2) + r1.y + 1;

        while (x != r2.x + r2.w / 2) {
            if (x < r2.x + r2.w / 2) {
                x++;
            } else {
                x--;
            }

            if (map[x][y] != '.') {
                map[x][y] = '.';
            }
        }

        while (y != r2.y + r2.h / 2) {
            if (y < r2.y + r2.h / 2) {
                y++;
            } else {
                y--;
            }

            if (map[x][y] != '.') {
                map[x][y] = '.';
            }
        }
    }
}

void print_map() {
    int i, j;

    for (i = 0; i < MAP_SIZE; i++) {
        for (j = 0; j < MAP_SIZE; j++) {
            putchar(map[i][j]);
        }
        putchar('\n');
    }
}

int main() {

    srand(time(NULL));

    init_map();

    int i;
    for (i = 0; i < MAX_ROOMS; i++) {
        place_room(i);
    }

    connect_rooms();

    print_map();

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 init_map(void); // weak
__int64 __fastcall place_room(_QWORD); // weak
__int64 connect_rooms(void); // weak
__int64 print_map(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001AFF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  init_map();
  for ( i = 0; i <= 19; ++i )
    place_room((unsigned int)i);
  connect_rooms();
  print_map();
  return 0;
}
// 14000155F: using guessed type __int64 init_map(void);
// 14000167D: using guessed type __int64 __fastcall place_room(_QWORD);
// 140001876: using guessed type __int64 connect_rooms(void);
// 140001A7F: using guessed type __int64 print_map(void);
// 140001C10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=88 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Huffman Coding Implementation ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE 256

struct node {
  int freq;
  char symbol;
  struct node *left;
  struct node *right;
};

struct queue {
  int size;
  int front;
  int rear;
  struct node **array;
};

struct node *new_node(int freq, char symbol) {
  struct node *node = malloc(sizeof(struct node));

  node->freq = freq;
  node->symbol = symbol;
  node->left = NULL;
  node->right = NULL;

  return node;
}

struct queue *create_queue(int size) {
  struct queue *queue = malloc(sizeof(struct queue));

  queue->size = size;
  queue->front = 0;
  queue->rear = -1;
  queue->array = malloc(size * sizeof(struct node *));

  return queue;
}

int is_full(struct queue *queue){
  return queue->rear == queue->size - 1;
}

int is_empty(struct queue *queue) {
  return queue->front == queue->rear + 1;
}

void enqueue(struct queue *queue, struct node *node) {
  if (is_full(queue)) {
    return;
  }

  queue->rear++;
  queue->array[queue->rear] = node;
}

struct node *dequeue(struct queue *queue) {
  if (is_empty(queue)) {
    return NULL;
  }

  struct node *node = queue->array[queue->front];
  queue->front++;

  return node;
}

void print_array(int *array, int n) {
  for (int i = 0; i < n; i++) {
    printf("%d", array[i]);
  }
  printf("\n");
}

void print_codes(struct node *root, int *array, int top) {
  if (root->left) {
    array[top] = 0;
    print_codes(root->left, array, top + 1);
  }

  if (root->right) {
    array[top] = 1;
    print_codes(root->right, array, top + 1);
  }

  if (!root->left && !root->right) {
    printf("%c:", root->symbol);
    print_array(array, top);
  }
}

void huffman_coding(int *freq, char *symbols, int size) {
  struct node *left;
  struct node *right;
  struct node *top;
  struct queue *queue = create_queue(size);

  for (int i = 0; i < size; i++) {
    enqueue(queue, new_node(freq[i], symbols[i]));
  }

  while (!is_empty(queue)) {
    left = dequeue(queue);
    right = dequeue(queue);

    top = new_node(left->freq + right->freq, '-');
    top->left = left;
    top->right = right;

    enqueue(queue, top);
  }

  int array[SIZE] = { 0 };
  print_codes(top, array, 0);
}

int main() {
  int freq[SIZE] = { 6, 13, 7, 21, 14, 1, 2, 5, 12, 3 };
  char symbols[SIZE] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' };

  huffman_coding(freq, symbols, SIZE);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall huffman_coding(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A0B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[32]; // [rsp+20h] [rbp-60h] BYREF
  int v5[260]; // [rsp+120h] [rbp+A0h] BYREF

  _main(argc, argv, envp);
  memset(v5, 0, 0x400ui64);
  v5[0] = 6;
  v5[1] = 13;
  v5[2] = 7;
  v5[3] = 21;
  v5[4] = 14;
  v5[5] = 1;
  v5[6] = 2;
  v5[7] = 5;
  v5[8] = 12;
  v5[9] = 3;
  v4[0] = 0x6867666564636261i64;
  v4[1] = 27241i64;
  memset(&v4[2], 0, 240);
  huffman_coding(v5, v4, 256i64);
  return 0;
}
// 140001881: using guessed type __int64 __fastcall huffman_coding(_QWORD, _QWORD, _QWORD);
// 140001C90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: inquisitive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct pixel {
    int red;
    int green;
    int blue;
} Pixel;

int main() {
    int width, height;
    printf("Enter the width of the image: ");
    scanf("%d", &width);
    printf("Enter the height of the image: ");
    scanf("%d", &height);

    Pixel image[width][height];
    srand(time(NULL)); // seed the random number generator

    // loop through each pixel in the image
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            // generate a random color for the pixel
            image[x][y].red = rand() % 256;
            image[x][y].green = rand() % 256;
            image[x][y].blue = rand() % 256;
        }
    }

    // print the image as ASCII art
    printf("\n");
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            // choose a character to represent each pixel based on its brightness
            int brightness = (image[x][y].red + image[x][y].green + image[x][y].blue) / 3;
            char c;
            if (brightness < 64) {
                c = ' ';
            } else if (brightness < 128) {
                c = '.';
            } else if (brightness < 192) {
                c = '*';
            } else {
                c = '#';
            }
            // print the character in the appropriate color
            printf("\033[38;2;%d;%d;%dm%c\033[0m", image[x][y].red, image[x][y].green, image[x][y].blue, c);
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned __int64 v3; // rbx
  void *v4; // rsp
  unsigned int v5; // eax
  __int64 v6; // r9
  unsigned int v7; // r10d
  unsigned int v8; // eax
  __int64 v10; // [rsp+0h] [rbp-A0h] BYREF
  __int64 v11; // [rsp+20h] [rbp-80h]
  char v12; // [rsp+30h] [rbp-70h] BYREF
  __int64 *v13; // [rsp+38h] [rbp-68h]
  __int64 v14; // [rsp+40h] [rbp-60h]
  __int64 v15; // [rsp+48h] [rbp-58h]
  __int64 v16; // [rsp+50h] [rbp-50h]
  __int64 v17; // [rsp+58h] [rbp-48h]
  int v18; // [rsp+64h] [rbp-3Ch] BYREF
  int v19; // [rsp+68h] [rbp-38h] BYREF
  int v20; // [rsp+6Ch] [rbp-34h]
  char *v21; // [rsp+70h] [rbp-30h]
  __int64 v22; // [rsp+78h] [rbp-28h]
  __int64 v23; // [rsp+80h] [rbp-20h]
  char v24; // [rsp+8Fh] [rbp-11h]
  int m; // [rsp+90h] [rbp-10h]
  int k; // [rsp+94h] [rbp-Ch]
  int j; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v13 = &v10;
  printf("Enter the width of the image: ");
  scanf("%d", &v19);
  printf("Enter the height of the image: ");
  scanf("%d", &v18);
  v23 = v18 - 1i64;
  v16 = v18;
  v17 = 0i64;
  v3 = 12i64 * v18;
  v22 = v19 - 1i64;
  v14 = v18;
  v15 = 0i64;
  v4 = alloca(16 * ((unsigned __int64)(12 * v19 * (__int64)v18 + 15) >> 4));
  v21 = &v12;
  v5 = time(0i64);
  srand(v5);
  for ( i = 0; i < v19; ++i )
  {
    for ( j = 0; j < v18; ++j )
    {
      *(_DWORD *)&v21[12 * j + 4 * i * (v3 >> 2)] = rand() % 256;
      *(_DWORD *)&v21[12 * j + 4 + 4 * i * (v3 >> 2)] = rand() % 256;
      *(_DWORD *)&v21[12 * j + 8 + 4 * i * (v3 >> 2)] = rand() % 256;
    }
  }
  printf("\n");
  for ( k = 0; k < v18; ++k )
  {
    for ( m = 0; m < v19; ++m )
    {
      v20 = (*(_DWORD *)&v21[12 * k + 4 + 4 * m * (v3 >> 2)]
           + *(_DWORD *)&v21[12 * k + 4 * m * (v3 >> 2)]
           + *(_DWORD *)&v21[12 * k + 8 + 4 * m * (v3 >> 2)])
          / 3;
      if ( v20 > 63 )
      {
        if ( v20 > 127 )
        {
          if ( v20 > 191 )
            v24 = 35;
          else
            v24 = 42;
        }
        else
        {
          v24 = 46;
        }
      }
      else
      {
        v24 = 32;
      }
      v6 = *(unsigned int *)&v21[12 * k + 8 + 4 * m * (v3 >> 2)];
      v7 = *(_DWORD *)&v21[12 * k + 4 + 4 * m * (v3 >> 2)];
      v8 = *(_DWORD *)&v21[12 * k + 4 * m * (v3 >> 2)];
      LODWORD(v11) = v24;
      printf("\x1B[38;2;%d;%d;%dm%c\x1B[0m", v8, v7, v6, v11);
    }
    printf("\n");
  }
  return 0;
}
// 140001B60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mortgage Calculator ; Style: Romeo and Juliet
// Romeo and Juliet Mortgage Calculator

#include <stdio.h>
#include <math.h>

int main() {
    double principal, interest_rate, monthly_payment, total_interest, total_cost;
    int months;
    
    // Romeo enters the principal amount
    printf("Oh Juliet, what is the principal amount? ");
    scanf("%lf", &principal);
    
    // Juliet wants to know the interest rate
    printf("Romeo, what is the interest rate (in percentage)? ");
    scanf("%lf", &interest_rate);
    interest_rate /= 100.0; // Convert to decimal
    
    // Romeo has to calculate the monthly payment
    printf("Juliet, how long (in years) is the mortgage? ");
    int years;
    scanf("%d", &years);
    months = years * 12;
    double monthly_interest_rate = interest_rate / 12.0;
    monthly_payment = (principal * monthly_interest_rate) / (1 - pow(1 + monthly_interest_rate, -months));
    
    // Juliet wants to know the total cost and interest
    total_cost = monthly_payment * months;
    total_interest = total_cost - principal;
    
    // Romeo and Juliet display the results
    printf("\nAh, Juliet, the monthly payment is: %.2lf\n", monthly_payment);
    printf("And the total cost of the mortgage is: %.2lf\n", total_cost);
    printf("The total interest paid will be: %.2lf\n", total_interest);
    
    // Romeo and Juliet may live happily ever after
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm6_8
  int v5; // [rsp+24h] [rbp-3Ch] BYREF
  double v6; // [rsp+28h] [rbp-38h] BYREF
  double v7; // [rsp+30h] [rbp-30h] BYREF
  double v8; // [rsp+38h] [rbp-28h]
  double v9; // [rsp+40h] [rbp-20h]
  double v10; // [rsp+48h] [rbp-18h]
  double v11; // [rsp+50h] [rbp-10h]
  int v12; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Oh Juliet, what is the principal amount? ");
  scanf("%lf", &v7);
  printf("Romeo, what is the interest rate (in percentage)? ");
  scanf("%lf", &v6);
  v6 = v6 / 100.0;
  printf("Juliet, how long (in years) is the mortgage? ");
  scanf("%d", &v5);
  v12 = 12 * v5;
  v11 = v6 / 12.0;
  v3 = v7 * (v6 / 12.0);
  v10 = v3 / (1.0 - pow(v6 / 12.0 + 1.0, (double)(-12 * v5)));
  v9 = (double)v12 * v10;
  v8 = v9 - v7;
  printf("\nAh, Juliet, the monthly payment is: %.2lf\n", v10);
  printf("And the total cost of the mortgage is: %.2lf\n", v9);
  printf("The total interest paid will be: %.2lf\n", v8);
  return 0;
}
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text-Based Adventure Game ; Style: careful
#include <stdio.h>
#include <string.h>

void clearInputBuffer() {
    int c = 0;
    while ((c = getchar()) != '\n' && c != EOF) {}
}

int main() {
    printf("Welcome to The Dungeon!\n");
    printf("Enter your name: ");

    char playerName[20] = "";
    fgets(playerName, 20, stdin);
    playerName[strcspn(playerName, "\n")] = 0; // Remove trailing newline

    printf("Welcome, %s, to the dungeon!\n", playerName);
    printf("You find yourself in a dark and damp room. You can see two doors.\n");
    printf("One to your left and one to your right.\n");

    char choice[10] = "";
    while (strcmp(choice, "left") != 0 && strcmp(choice, "right") != 0) {
        printf("Which door do you choose? (left/right)\n");
        fgets(choice, 10, stdin);
        choice[strcspn(choice, "\n")] = 0; // Remove trailing newline
        if (strcmp(choice, "left") != 0 && strcmp(choice, "right") != 0) {
            printf("Invalid choice. Please try again.\n");
        }
    }

    printf("You open the %s door and enter the next room.\n", choice);
    printf("This room is filled with treasure, but there is also a monster guarding it.\n");
    printf("You have a sword to defend yourself.\n");

    int hasSword = 1;

    while (1) {
        if (hasSword) {
            printf("Do you want to attack the monster? (y/n)\n");
        } else {
            printf("You have already defeated the monster.\n");
            printf("Do you want to search the treasure? (y/n)\n");
        }

        char answer[2] = "";
        fgets(answer, 2, stdin);
        clearInputBuffer();

        if (strcmp(answer, "y") == 0) {
            if (hasSword) {
                printf("You attack the monster and defeat it!\n");
                printf("You have earned the treasure. Congratulations!\n");
                hasSword = 0;
            } else {
                printf("You search the treasure and find a map to the exit!\n");
                printf("You use the map to escape the dungeon. Congratulation!\n");
                break;
            }
        } else if (strcmp(answer, "n") == 0) {
            printf("You decide to not take any risks and go back to the previous room.\n");
            strcpy(choice, ""); // Reset the choice variable to trigger the door selection loop again
            break;
        } else {
            printf("Invalid input. Please try again.\n");
        }
    }

    if (strlen(choice) > 0) {
        printf("You open the %s door and enter the next room.\n", choice);
        printf("This room is filled with poison gas! You start to feel dizzy...\n");
        printf("You need to find a way out before it's too late.\n");

        while (1) {
            printf("What do you want to do?\n");
            printf("1. Look for an exit.\n");
            printf("2. Cover your mouth and wait for the gas to clear.\n");

            int option = 0;
            scanf("%d", &option);
            clearInputBuffer();

            if (option == 1) {
                printf("You search the room and find a hidden passage in the wall.\n");
                printf("You crawl through it and finally see daylight!\n");
                printf("You have escaped the dungeon. Congratulations!\n");
                break;
            } else if (option == 2) {
                printf("You cover your mouth with your shirt and wait for the gas to clear.\n");
                printf("A few minutes later, the gas dissipates and you can breathe normally again.\n");
                printf("You start to feel weak, but you manage to get out of the dungeon.\n");
                printf("You survived, but barely. Better luck next time!\n");
                break;
            } else {
                printf("Invalid option. Please try again.\n");
            }
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 clearInputBuffer(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000160D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  int v7; // [rsp+20h] [rbp-30h] BYREF
  char Str1[2]; // [rsp+24h] [rbp-2Ch] BYREF
  char Str[8]; // [rsp+26h] [rbp-2Ah] BYREF
  __int16 v10; // [rsp+2Eh] [rbp-22h]
  char Buffer[8]; // [rsp+30h] [rbp-20h] BYREF
  __int64 v12; // [rsp+38h] [rbp-18h]
  int v13; // [rsp+40h] [rbp-10h]
  int v14; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to The Dungeon!\n");
  printf("Enter your name: ");
  *(_QWORD *)Buffer = 0i64;
  v12 = 0i64;
  v13 = 0;
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 20, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  printf("Welcome, %s, to the dungeon!\n", Buffer);
  printf("You find yourself in a dark and damp room. You can see two doors.\n");
  printf("One to your left and one to your right.\n");
  *(_QWORD *)Str = 0i64;
  v10 = 0;
  while ( strcmp(Str, "left") && strcmp(Str, "right") )
  {
    printf("Which door do you choose? (left/right)\n");
    v4 = __acrt_iob_func(0);
    fgets(Str, 10, v4);
    Str[strcspn(Str, "\n")] = 0;
    if ( strcmp(Str, "left") && strcmp(Str, "right") )
      printf("Invalid choice. Please try again.\n");
  }
  printf("You open the %s door and enter the next room.\n", Str);
  printf("This room is filled with treasure, but there is also a monster guarding it.\n");
  printf("You have a sword to defend yourself.\n");
  v14 = 1;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v14 )
      {
        printf("Do you want to attack the monster? (y/n)\n");
      }
      else
      {
        printf("You have already defeated the monster.\n");
        printf("Do you want to search the treasure? (y/n)\n");
      }
      *(_WORD *)Str1 = 0;
      v5 = __acrt_iob_func(0);
      fgets(Str1, 2, v5);
      clearInputBuffer();
      if ( strcmp(Str1, "y") )
        break;
      if ( !v14 )
      {
        printf("You search the treasure and find a map to the exit!\n");
        printf("You use the map to escape the dungeon. Congratulation!\n");
        goto LABEL_18;
      }
      printf("You attack the monster and defeat it!\n");
      printf("You have earned the treasure. Congratulations!\n");
      v14 = 0;
    }
    if ( !strcmp(Str1, "n") )
      break;
    printf("Invalid input. Please try again.\n");
  }
  printf("You decide to not take any risks and go back to the previous room.\n");
  Str[0] = 0;
LABEL_18:
  if ( Str[0] )
  {
    printf("You open the %s door and enter the next room.\n", Str);
    printf("This room is filled with poison gas! You start to feel dizzy...\n");
    printf("You need to find a way out before it's too late.\n");
    while ( 1 )
    {
      printf("What do you want to do?\n");
      printf("1. Look for an exit.\n");
      printf("2. Cover your mouth and wait for the gas to clear.\n");
      v7 = 0;
      scanf("%d", &v7);
      clearInputBuffer();
      if ( v7 == 1 )
      {
        printf("You search the room and find a hidden passage in the wall.\n");
        printf("You crawl through it and finally see daylight!\n");
        printf("You have escaped the dungeon. Congratulations!\n");
        return 0;
      }
      if ( v7 == 2 )
        break;
      printf("Invalid option. Please try again.\n");
    }
    printf("You cover your mouth with your shirt and wait for the gas to clear.\n");
    printf("A few minutes later, the gas dissipates and you can breathe normally again.\n");
    printf("You start to feel weak, but you manage to get out of the dungeon.\n");
    printf("You survived, but barely. Better luck next time!\n");
  }
  return 0;
}
// 1400015E2: using guessed type __int64 clearInputBuffer(void);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sudoku solver ; Style: irregular
#include <stdio.h>

// This solver uses a randomized approach,
// traversing through the rows and columns of the
// Sudoku board one by one, seeking a solution.

void printBoard(int board[9][9]) {
    // Print the Sudoku board in a readable format.
    printf("Sudoku board:\n");
    for (int i = 0; i < 9; i++) {
        if (i % 3 == 0 && i != 0) {
            printf("-------------------\n");
        }
        for (int j = 0; j < 9; j++) {
            if (j % 3 == 0 && j != 0) {
                printf("| ");
            }
            printf("%d ", board[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

int isValid(int board[9][9], int row, int col, int num) {
    // Check if placing the number 'num' in the given row and column
    // is valid according to the Sudoku rules.
    for (int i = 0; i < 9; i++) {
        // Check the row and column
        if (board[row][i] == num || board[i][col] == num) {
            return 0;
        }
        // Check the 3x3 square
        int squareRow = 3 * (row / 3) + (i / 3);
        int squareCol = 3 * (col / 3) + (i % 3);
        if (board[squareRow][squareCol] == num) {
            return 0;
        }
    }
    return 1;
}

int solve(int board[9][9], int row, int col) {
    // The recursive Sudoku solver. The variable 'row'
    // represents the current row being visited, and 'col'
    // represents the current column.
    if (row == 9) {
        // Base case: the solver has reached the end of the board,
        // meaning the Sudoku has been solved successfully.
        return 1;
    }
    int nextRow = row;
    int nextCol = col + 1;
    if (nextCol == 9) {
        nextRow++;
        nextCol = 0;
    }
    if (board[row][col] != 0) {
        // If the current cell is already filled in, move on to the next one.
        return solve(board, nextRow, nextCol);
    }
    // Otherwise, try out all the numbers from 1 to 9.
    for (int i = 1; i <= 9; i++) {
        if (isValid(board, row, col, i)) {
            // If the current number is valid, place it in the current cell
            // and move on to the next cell.
            board[row][col] = i;
            if (solve(board, nextRow, nextCol)) {
                return 1;
            }
        }
    }
    // If none of the numbers are valid, reset the current cell and return 0 to backtrack.
    board[row][col] = 0;
    return 0;
}

void shuffleArray(int arr[], int n) {
    // Shuffle an array of integers using the Fisher-Yates algorithm.
    for (int i = n - 1; i >= 1; i--) {
        int j = rand() % (i + 1);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

void generateBoard(int board[9][9]) {
    // Generate a Sudoku board with a randomized solution, using a backtracking algorithm.
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            board[i][j] = 0;
        }
    }
    int nums[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    shuffleArray(nums, 9);
    solve(board, 0, 0);
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (rand() % 2 == 0) {
                int temp = board[i][j];
                board[i][j] = 0;
                int temp2 = solve(board, 0, 0);
                if (temp2 != 1) {
                    board[i][j] = temp;
                }
            }
        }
    }
}

int main() {
    // Create a Sudoku board and solve it.
    int board[9][9];
    generateBoard(board);
    printBoard(board);
    solve(board, 0, 0);
    printf("Solved Sudoku board:\n");
    printBoard(board);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printBoard(_QWORD); // weak
__int64 __fastcall solve(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall generateBoard(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001B7A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[336]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  generateBoard(v4);
  printBoard(v4);
  solve(v4, 0i64, 0i64);
  printf("Solved Sudoku board:\n");
  printBoard(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printBoard(_QWORD);
// 140001803: using guessed type __int64 __fastcall solve(_QWORD, _QWORD, _QWORD);
// 1400019D4: using guessed type __int64 __fastcall generateBoard(_QWORD);
// 140001CA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: imaginative
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

//Function declarations
void printArray(int arr[], int size);
void selectionSort(int arr[], int size);

int main()
{
    printf("Welcome to the Magical Sorting program!\n\n");
    printf("In this program, we will demonstrate the magical power of selection sorting.\n");
    printf("We will use a magical array of randomly generated numbers to demonstrate how selection sorting works.\n\n");

    //Generate the magical array of numbers
    srand(time(0)); //Seed the random number generator
    int size = 10; //Size of the array
    int arr[size];
    printf("The magical array of numbers is: \n");
    for(int i=0; i<size; i++)
    {
        arr[i] = rand()%100; //Generate a random number between 0 and 99
        printf("%d ", arr[i]);
    }
    printf("\n\n");

    //Call the selection sort function to sort the array
    selectionSort(arr, size);

    printf("The magical array of numbers has been sorted using selection sorting.\n");
    printf("The sorted array is: \n");
    printArray(arr, size);

    return 0;
}

//Function to print the array
void printArray(int arr[], int size)
{
    for(int i=0; i<size; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n\n");
}

//Function to perform selection sorting on the array
void selectionSort(int arr[], int size)
{
    printf("The magical powers of selection sorting are now at work...\n\n");
    int min, temp;
    for(int i=0; i<size-1; i++)
    {
        min = i;
        for(int j=i+1; j<size; j++)
        {
            if(arr[j] < arr[min])
            {
                min = j;
            }
        }
        temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;
        printf("The magical sorting wand has waved, and the array has been transformed:\n");
        printArray(arr, size);
    }
    printf("The magical powers of selection sorting have been fully utilized.\n\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall printArray(_QWORD, _QWORD); // weak
__int64 __fastcall selectionSort(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  void *v4; // rsp
  char v6; // [rsp+20h] [rbp-20h] BYREF
  char *v7; // [rsp+28h] [rbp-18h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  unsigned int v9; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Magical Sorting program!\n\n");
  printf("In this program, we will demonstrate the magical power of selection sorting.\n");
  printf("We will use a magical array of randomly generated numbers to demonstrate how selection sorting works.\n\n");
  v3 = time(0i64);
  srand(v3);
  v9 = 10;
  v8 = 9i64;
  v4 = alloca(48i64);
  v7 = &v6;
  printf("The magical array of numbers is: \n");
  for ( i = 0; i < (int)v9; ++i )
  {
    *(_DWORD *)&v7[4 * i] = rand() % 100;
    printf("%d ", *(unsigned int *)&v7[4 * i]);
  }
  printf("\n\n");
  selectionSort(v7, v9);
  printf("The magical array of numbers has been sorted using selection sorting.\n");
  printf("The sorted array is: \n");
  printArray(v7, v9);
  return 0;
}
// 140001738: using guessed type __int64 __fastcall printArray(_QWORD, _QWORD);
// 140001799: using guessed type __int64 __fastcall selectionSort(_QWORD, _QWORD);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: funny
/*
Welcome to our newest project – our very own Elevator Simulation Program!
Instead of the usual dull and boring program, we present to you a simulator
that will make you roll on the floor laughing. This program is designed to simulate
a fantasy world where our elevator is not just a simple machine, but it can talk,
dance, sing or even fly. Time to let your imagination run wild, folks!

We are proud to introduce you to Elevator “Crazy Fun-time”!
*/

#include <stdio.h>
#include <stdlib.h>

// Defining our variables
int currentFloor = 1;

// Function for taking user input
int getUserInput() {
    printf("\n\nWhich floor would you like to go to? (1 to 10)\n");
    int floorChoice;
    scanf("%d", &floorChoice);

    // Validation
    if(floorChoice < 1 || floorChoice > 10) {
        printf("Invalid floor choice! Try again.\n");
        return getUserInput();
    }

    return floorChoice;
}

int main()
{
    printf("Welcome to Elevator Crazy Fun-time!\n\n");

    // Greeting
    printf("Elevator: Hey there, fancy meeting you here. Where would you like to go today?\n");

    while(1) {
        // Taking the user's input
        int floorChoice = getUserInput();

        // Elevator moves
        while(currentFloor != floorChoice) {
            if(currentFloor < floorChoice) {
                currentFloor++;
                printf("Elevator: Going up to floor %d...\n", currentFloor);
            }
            else {
                currentFloor--;
                printf("Elevator: Going down to floor %d...\n", currentFloor);
            }

            // Random actions by the elevator
            int actionChance = rand() % 10;
            if(actionChance == 0) {
                printf("Elevator: Whoopie, let's do a little dance.\n");
            }
            else if(actionChance == 1) {
                printf("Elevator: Hold on tight, we're about to fly!\n");
            }
            else if(actionChance == 2) {
                printf("Elevator: Oh my, would you look at that view!\n");
            }
            else if(actionChance == 3) {
                printf("Elevator: Let's sing a song together. ♫ Laa la laa la laa ♫\n");
            }
            else if(actionChance == 4) {
                printf("Elevator: So, what's your favourite joke?\n");
            }
            else if(actionChance == 5) {
                printf("Elevator: Up, up and awaaayyy!!\n");
            }
        }

        // Arrival message
        printf("\n\nElevator: You have arrived at floor %d! Have a great day ahead!\n", currentFloor);

        // Farewell message
        printf("Elevator: Thanks for riding with us. Don't forget to rate us five stars! *wink*\n");

        // Taking prompt
        printf("\n\nDo you want to go to another floor? (y/n)\n");
        char choice;
        scanf("%s", &choice);

        if(choice == 'n' || choice == 'N') {
            printf("Elevator: Alright, bye for now!\n");
            break;
        }
        else if(choice == 'y' || choice == 'Y') {
            printf("Elevator: Great! Let's continue our journey. Buckle up, folks!\n\n");
        }
        else {
            printf("Elevator: Sorry, I didn't quite catch that. *confused*\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 getUserInput(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();

//-------------------------------------------------------------------------
// Data declarations

int currentFloor = 1; // weak
const char aElevatorLetSSi[38] = "Elevator: Let's sing a song together. "; // idb


//----- (000000014000163D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+27h] [rbp-9h] BYREF
  int v5; // [rsp+28h] [rbp-8h]
  int UserInput; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to Elevator Crazy Fun-time!\n\n");
  printf("Elevator: Hey there, fancy meeting you here. Where would you like to go today?\n");
  while ( 1 )
  {
    UserInput = getUserInput();
    while ( UserInput != currentFloor )
    {
      if ( UserInput <= currentFloor )
        printf("Elevator: Going down to floor %d...\n", (unsigned int)--currentFloor);
      else
        printf("Elevator: Going up to floor %d...\n", (unsigned int)++currentFloor);
      v5 = rand() % 10;
      if ( v5 )
      {
        switch ( v5 )
        {
          case 1:
            printf("Elevator: Hold on tight, we're about to fly!\n");
            break;
          case 2:
            printf("Elevator: Oh my, would you look at that view!\n");
            break;
          case 3:
            printf(aElevatorLetSSi);
            break;
          case 4:
            printf("Elevator: So, what's your favourite joke?\n");
            break;
          case 5:
            printf("Elevator: Up, up and awaaayyy!!\n");
            break;
        }
      }
      else
      {
        printf("Elevator: Whoopie, let's do a little dance.\n");
      }
    }
    printf("\n\nElevator: You have arrived at floor %d! Have a great day ahead!\n", (unsigned int)currentFloor);
    printf("Elevator: Thanks for riding with us. Don't forget to rate us five stars! *wink*\n");
    printf("\n\nDo you want to go to another floor? (y/n)\n");
    scanf("%s", &v4);
    if ( v4 == 110 || v4 == 78 )
      break;
    if ( v4 == 121 || v4 == 89 )
      printf("Elevator: Great! Let's continue our journey. Buckle up, folks!\n\n");
    else
      printf("Elevator: Sorry, I didn't quite catch that. *confused*\n");
  }
  printf("Elevator: Alright, bye for now!\n");
  return 0;
}
// 1400015E2: using guessed type __int64 getUserInput(void);
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140013010: using guessed type int currentFloor;

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: scientific
/*
Classical Circuit Simulator

This program simulates the behavior of classical electronic circuits consisting of resistors, capacitors and inductors. The circuit is represented using a matrix where each element corresponds to a circuit component. The simulation is performed using numerical integration.

Author: [Your Name]

Date: [Date]

*/

#include <stdio.h>
#include <math.h>

#define N 3 // Size of the matrix

double components[N][N]; // Matrix representing the circuit components
double V[N]; // Vector representing the voltages at each node
double I[N]; // Vector representing the current across each component
double dt = 0.01; // Time step size
double t = 0.0; // Current time
double T = 1.0; // Total time of simulation

double R = 1000; // Resistance in ohms
double C = 1e-6; // Capacitance in farads
double L = 1; // Inductance in henrys

// Function to initialize the circuit matrix
void initialize_circuit() {
    // Set all elements to zero
    for(int i=0; i<N; i++) {
        for(int j=0; j<N; j++) {
            components[i][j] = 0;
        }
    }

    // Set the circuit components
    components[0][0] = R;
    components[1][0] = -R;
    components[1][1] = L;
    components[2][1] = -1/C;
}

// Function to perform numerical integration
void numerical_integration() {
    double y[N];
    double k1[N], k2[N], k3[N], k4[N];

    // Compute k1
    for(int i=0; i<N; i++) {
        k1[i] = I[i]/C;
        for(int j=0; j<N; j++) {
            k1[i] += (V[j] - V[i]) * components[i][j];
        }
    }

    // Compute k2
    for(int i=0; i<N; i++) {
        y[i] = V[i] + dt/2 * k1[i];
    }
    for(int i=0; i<N; i++) {
        k2[i] = I[i]/C;
        for(int j=0; j<N; j++) {
            k2[i] += (y[j] - y[i]) * components[i][j];
        }
    }

    // Compute k3
    for(int i=0; i<N; i++) {
        y[i] = V[i] + dt/2 * k2[i];
    }
    for(int i=0; i<N; i++) {
        k3[i] = I[i]/C;
        for(int j=0; j<N; j++) {
            k3[i] += (y[j] - y[i]) * components[i][j];
        }
    }

    // Compute k4
    for(int i=0; i<N; i++) {
        y[i] = V[i] + dt * k3[i];
    }
    for(int i=0; i<N; i++) {
        k4[i] = I[i]/C;
        for(int j=0; j<N; j++) {
            k4[i] += (y[j] - y[i]) * components[i][j];
        }
    }

    // Compute the new values of V and I
    for(int i=0; i<N; i++) {
        V[i] += dt/6 * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i]);
        I[i] = (V[i] - y[i])/dt * C;
    }

    // Update the time
    t += dt;
}

int main() {
    // Initialize the circuit
    initialize_circuit();

    // Set the initial voltages and currents
    V[0] = 10;
    V[1] = 0;
    V[2] = 0;
    I[0] = -V[0]/R;

    // Simulate the circuit
    while(t < T) {
        numerical_integration();

        // Print the voltages and currents
        printf("Time: %f, Voltage at node 1: %f, Voltage at node 2: %f, Voltage at node 3: %f, Current through resistor: %f\n",
            t, V[0], V[1], V[2], I[0]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 initialize_circuit(void); // weak
__int64 numerical_integration(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

__int64 T = 4607182418800017408i64; // weak
__int64 R = 4652007308841189376i64; // weak
__int64 V; // weak
__int64 qword_14000F098; // weak
__int64 qword_14000F0A0; // weak
__int64 I; // weak
__int64 t; // weak


//----- (0000000140001BFF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  initialize_circuit();
  V = 0x4024000000000000i64;
  qword_14000F098 = 0i64;
  qword_14000F0A0 = 0i64;
  *(double *)&I = -10.0 / *(double *)&R;
  while ( *(double *)&T > *(double *)&t )
  {
    numerical_integration();
    printf(
      "Time: %f, Voltage at node 1: %f, Voltage at node 2: %f, Voltage at node 3: %f, Current through resistor: %f\n",
      *(double *)&t,
      *(double *)&V,
      *(double *)&qword_14000F098,
      *(double *)&qword_14000F0A0,
      *(double *)&I);
  }
  return 0;
}
// 140001591: using guessed type __int64 initialize_circuit(void);
// 14000164E: using guessed type __int64 numerical_integration(void);
// 140001DD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A018: using guessed type __int64 T;
// 14000A020: using guessed type __int64 R;
// 14000F090: using guessed type __int64 V;
// 14000F098: using guessed type __int64 qword_14000F098;
// 14000F0A0: using guessed type __int64 qword_14000F0A0;
// 14000F0B0: using guessed type __int64 I;
// 14000F0C8: using guessed type __int64 t;

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Ebook reader ; Style: Claude Shannon
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the Ebook structure
typedef struct {
    char title[100];
    char author[100];
    char filepath[100];
} Ebook;

// Define the Ebook reader function
void ebookReader(Ebook ebook) {
    FILE *file = fopen(ebook.filepath, "r");
    if (file) {
        char line[100];
        while (fgets(line, sizeof(line), file) != NULL) {
            printf("%s", line);
        }
        fclose(file);
    } else {
        printf("Error: Could not open file.\n");
    }
}

int main() {
    // Define an array of Ebook structures
    Ebook ebooks[3];
    strcpy(ebooks[0].title, "The Hitchhiker's Guide to the Galaxy");
    strcpy(ebooks[0].author, "Douglas Adams");
    strcpy(ebooks[0].filepath, "hitchhikers-guide.txt");

    strcpy(ebooks[1].title, "1984");
    strcpy(ebooks[1].author, "George Orwell");
    strcpy(ebooks[1].filepath, "1984.txt");

    strcpy(ebooks[2].title, "Brave New World");
    strcpy(ebooks[2].author, "Aldous Huxley");
    strcpy(ebooks[2].filepath, "brave-new-world.txt");

    // Prompt the user to select an Ebook
    printf("Select an Ebook:\n");
    for (int i = 0; i < 3; i++) {
        printf("%d. %s by %s\n", i + 1, ebooks[i].title, ebooks[i].author);
    }

    // Read the user's choice
    int choice;
    scanf("%d", &choice);

    // Display the chosen Ebook
    ebookReader(ebooks[choice-1]);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall ebookReader(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001674) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[316]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+15Ch] [rbp+DCh] BYREF
  _DWORD v6[25]; // [rsp+160h] [rbp+E0h] BYREF
  char v7[16]; // [rsp+1C4h] [rbp+144h] BYREF
  char v8[24]; // [rsp+228h] [rbp+1A8h] BYREF
  char v9[8]; // [rsp+28Ch] [rbp+20Ch] BYREF
  char v10[16]; // [rsp+2F0h] [rbp+270h] BYREF
  char v11[16]; // [rsp+354h] [rbp+2D4h] BYREF
  char v12[16]; // [rsp+3B8h] [rbp+338h] BYREF
  char v13[16]; // [rsp+41Ch] [rbp+39Ch] BYREF
  char v14[24]; // [rsp+480h] [rbp+400h] BYREF
  int i; // [rsp+4ECh] [rbp+46Ch]

  _main(argc, argv, envp);
  strcpy((char *)v6, "The Hitchhiker's Guide to the Galaxy");
  strcpy(v7, "Douglas Adams");
  strcpy(v8, "hitchhikers-guide.txt");
  strcpy(v9, "1984");
  strcpy(v10, "George Orwell");
  strcpy(v11, "1984.txt");
  strcpy(v12, "Brave New World");
  strcpy(v13, "Aldous Huxley");
  strcpy(v14, "brave-new-world.txt");
  printf("Select an Ebook:\n");
  for ( i = 0; i <= 2; ++i )
    printf("%d. %s by %s\n", (unsigned int)(i + 1), (const char *)&v6[75 * i], (const char *)&v6[75 * i + 25]);
  scanf("%d", &v5);
  qmemcpy(v4, &v4[300 * v5 + 20], 0x12Cui64);
  ebookReader(v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall ebookReader(_QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bingo Simulator ; Style: light-weight
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 5
#define COLS 5

void printCard(int card[][COLS]);
void generateCard(int card[][COLS]);
int callNumber(int numbers[]);
int checkForBingo(int card[][COLS], int numbers[]);

int main() {
    srand(time(NULL));
    int card[ROWS][COLS];
    int numbers[76] = {0}; // 75 possible numbers
    int numCalled, result;

    generateCard(card);
    printCard(card);

    while (1) {
        numCalled = callNumber(numbers);
        if (numCalled == -1) {
            printf("All numbers called, ending game.\n");
            break;
        }

        printf("Number called: %d\n", numCalled);
        result = checkForBingo(card, numbers);
        if (result == 1) {
            printf("Bingo! You won!\n");
            break;
        }
    }

    return 0;
}

void generateCard(int card[][COLS]) {
    int nums[5][5] = {{0}};
    int row, col, randNum;

    for (col = 0; col < COLS; col++) {
        randNum = (col * 15) + (rand() % 15) + 1;
        nums[2][col] = randNum;
    }

    for (col = 0; col < COLS; col++) {
        if (col == 2) {
            continue;
        }

        randNum = (col * 15) + (rand() % 15) + 1;
        nums[0][col] = randNum;

        while (1) {
            randNum = (col * 15) + (rand() % 15) + 1;
            if (randNum != nums[0][col]) {
                break;
            }
        }

        nums[4][col] = randNum;
    }

    for (row = 0; row < ROWS; row++) {
        for (col = 0; col < COLS; col++) {
            if (nums[row][col] != 0) {
                card[row][col] = nums[row][col];
            }
        }
    }
}

void printCard(int card[][COLS]) {
    int row, col;

    printf("\n==============\n");
    printf(" B  I  N  G  O\n");
    printf("==============\n");

    for (row = 0; row < ROWS; row++) {
        for (col = 0; col < COLS; col++) {
            if (card[row][col] != 0) {
                printf("%2d ", card[row][col]);
            } else {
                printf("   ");
            }
        }
        printf("\n");
    }

    printf("\n");
}

int callNumber(int numbers[]) {
    int numCalled;

    while (1) {
        numCalled = (rand() % 75) + 1;
        if (numbers[numCalled] == 0) {
            numbers[numCalled] = 1;
            return numCalled;
        }
    }

    if (numbers[75] == 1) {
        return -1; // all numbers called
    }
}

int checkForBingo(int card[][COLS], int numbers[]) {
    int row, col, diag1, diag2, bingo;

    // check rows
    for (row = 0; row < ROWS; row++) {
        bingo = 1;
        for (col = 0; col < COLS; col++) {
            if (numbers[card[row][col]] == 0) {
                bingo = 0;
                break;
            }
        }

        if (bingo == 1) {
            return 1;
        }
    }

    // check columns
    for (col = 0; col < COLS; col++) {
        bingo = 1;
        for (row = 0; row < ROWS; row++) {
            if (numbers[card[row][col]] == 0) {
                bingo = 0;
                break;
            }
        }

        if (bingo == 1) {
            return 1;
        }
    }

    // check diagonal (top left to bottom right)
    bingo = 1;
    diag1 = 0;
    for (row = 0, col = 0; row < ROWS && col < COLS; row++, col++) {
        if (numbers[card[row][col]] == 0) {
            bingo = 0;
            break;
        }

        diag1 += numbers[card[row][col]];
    }

    if (bingo == 1) {
        return 1;
    }

    // check diagonal (top right to bottom left)
    bingo = 1;
    diag2 = 0;
    for (row = 0, col = COLS - 1; row < ROWS && col >= 0; row++, col--) {
        if (numbers[card[row][col]] == 0) {
            bingo = 0;
            break;
        }

        diag2 += numbers[card[row][col]];
    }

    if (bingo == 1) {
        return 1;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall generateCard(_QWORD, _QWORD); // weak
__int64 __fastcall printCard(_QWORD); // weak
__int64 __fastcall callNumber(_QWORD); // weak
__int64 __fastcall checkForBingo(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[304]; // [rsp+20h] [rbp-60h] BYREF
  char v6[104]; // [rsp+150h] [rbp+D0h] BYREF
  int v7; // [rsp+1B8h] [rbp+138h]
  unsigned int v8; // [rsp+1BCh] [rbp+13Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  memset(v5, 0, sizeof(v5));
  generateCard(v6, v5);
  printCard(v6);
  do
  {
    v8 = callNumber(v5);
    if ( v8 == -1 )
    {
      printf("All numbers called, ending game.\n");
      return 0;
    }
    printf("Number called: %d\n", v8);
    v7 = checkForBingo(v6, v5);
  }
  while ( v7 != 1 );
  printf("Bingo! You won!\n");
  return 0;
}
// 14000168C: using guessed type __int64 __fastcall generateCard(_QWORD, _QWORD);
// 14000189E: using guessed type __int64 __fastcall printCard(_QWORD);
// 14000199B: using guessed type __int64 __fastcall callNumber(_QWORD);
// 140001A0E: using guessed type __int64 __fastcall checkForBingo(_QWORD, _QWORD);
// 140001D80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature monitor ; Style: all-encompassing
#include <stdio.h>

int main() {
  float temperature;
  printf("Enter the current temperature in Celsius: ");
  scanf("%f", &temperature);

  if (temperature < -273.15) {
    printf("Invalid temperature! Temperature can't be below absolute zero.\n");
    return 1;
  }

  printf("Temperature entered: %.2fC\n", temperature);
  
  if (temperature <= 0) {
    printf("Warning: Temperature is below freezing point.\n");
  }
  else if (temperature >= 100) {
    printf("Warning: Temperature is above boiling point.\n");
  }
  else {
    printf("Normal temperature range.\n");
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the current temperature in Celsius: ");
  scanf("%f", &v4);
  if ( v4 >= -273.15 )
  {
    printf("Temperature entered: %.2fC\n", v4);
    if ( v4 > 0.0 )
    {
      if ( v4 < 100.0 )
        printf("Normal temperature range.\n");
      else
        printf("Warning: Temperature is above boiling point.\n");
    }
    else
    {
      printf("Warning: Temperature is below freezing point.\n");
    }
    return 0;
  }
  else
  {
    printf("Invalid temperature! Temperature can't be below absolute zero.\n");
    return 1;
  }
}
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Network Topology Mapper ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int vertices, edges, source;
    printf("Please enter the number of vertices: ");
    scanf("%d", &vertices);
    printf("Please enter the number of edges: ");
    scanf("%d", &edges);
    int** matrix = (int**) malloc(vertices * sizeof(int*));
    for(int i=0; i<vertices; i++){
        matrix[i] = (int*) calloc(vertices, sizeof(int));
    }
    for(int i=0; i<edges; i++){
        int x, y;
        printf("Enter edge %d: ", i+1);
        scanf("%d %d", &x, &y);
        matrix[x-1][y-1] = 1;
        matrix[y-1][x-1] = 1;
    }
    printf("Matrix representation of the network topology:\n");
    for(int i=0; i<vertices; i++){
        for(int j=0; j<vertices; j++){
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
    printf("Please enter the source vertex to find its neighbors: ");
    scanf("%d", &source);
    printf("Neighbors of vertex %d:\n", source);
    for(int i=0; i<vertices; i++){
        if(matrix[source-1][i] == 1){
            printf("%d ", i+1);
        }
    }
    free(matrix);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void *__cdecl calloc(size_t Count, size_t Size);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void **v3; // rbx
  int v5; // [rsp+2Ch] [rbp-34h] BYREF
  int v6; // [rsp+30h] [rbp-30h] BYREF
  unsigned int v7; // [rsp+34h] [rbp-2Ch] BYREF
  int v8; // [rsp+38h] [rbp-28h] BYREF
  int v9; // [rsp+3Ch] [rbp-24h] BYREF
  void *Block; // [rsp+40h] [rbp-20h]
  int n; // [rsp+4Ch] [rbp-14h]
  int m; // [rsp+50h] [rbp-10h]
  int k; // [rsp+54h] [rbp-Ch]
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Please enter the number of vertices: ");
  scanf("%d", &v9);
  printf("Please enter the number of edges: ");
  scanf("%d", &v8);
  Block = malloc(8i64 * v9);
  for ( i = 0; i < v9; ++i )
  {
    v3 = (void **)((char *)Block + 8 * i);
    *v3 = calloc(v9, 4ui64);
  }
  for ( j = 0; j < v8; ++j )
  {
    printf("Enter edge %d: ", (unsigned int)(j + 1));
    scanf("%d %d", &v6, &v5);
    *(_DWORD *)(*((_QWORD *)Block + v6 - 1) + 4i64 * v5 - 4) = 1;
    *(_DWORD *)(*((_QWORD *)Block + v5 - 1) + 4i64 * v6 - 4) = 1;
  }
  printf("Matrix representation of the network topology:\n");
  for ( k = 0; k < v9; ++k )
  {
    for ( m = 0; m < v9; ++m )
      printf("%d ", *(unsigned int *)(*((_QWORD *)Block + k) + 4i64 * m));
    printf("\n");
  }
  printf("Please enter the source vertex to find its neighbors: ");
  scanf("%d", &v7);
  printf("Neighbors of vertex %d:\n", v7);
  for ( n = 0; n < v9; ++n )
  {
    if ( *(_DWORD *)(*((_QWORD *)Block + (int)v7 - 1) + 4i64 * n) == 1 )
      printf("%d ", (unsigned int)(n + 1));
  }
  free(Block);
  return 0;
}
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Electronic Voting System ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure to represent a candidate
typedef struct candidate {
    char name[100];
    int votes;
} Candidate;

// Function to add a new candidate to the candidate list
void addCandidate(Candidate* candidates, int* numCandidates) {
    printf("Enter candidate name: ");
    scanf("%s", candidates[*numCandidates].name);
    candidates[*numCandidates].votes = 0;
    (*numCandidates)++;
}

// Function to print the names and votes of all candidates
void displayCandidates(Candidate* candidates, int numCandidates) {
    printf("Candidate\tVotes\n");
    for (int i = 0; i < numCandidates; i++) {
        printf("%s\t\t%d\n", candidates[i].name, candidates[i].votes);
    }
}

// Function to cast a vote for a given candidate
void castVote(Candidate* candidates, int numCandidates) {
    char name[100];
    printf("Enter candidate name: ");
    scanf("%s", name);
    for (int i = 0; i < numCandidates; i++) {
        if (strcmp(name, candidates[i].name) == 0) {
            candidates[i].votes++;
            printf("Vote cast for %s\n", candidates[i].name);
            return;
        }
    }
    printf("Candidate not found\n");
}

// Function to display the winner of the election
void displayWinner(Candidate* candidates, int numCandidates) {
    Candidate winner = candidates[0];
    for (int i = 1; i < numCandidates; i++) {
        if (candidates[i].votes > winner.votes) {
            winner = candidates[i];
        }
    }
    printf("Winner is %s with %d votes\n", winner.name, winner.votes);
}

// Main function to run the voting system
int main() {
    int numCandidates = 0;
    Candidate candidates[100];
    int choice;
    do {
        printf("\n1. Add Candidate\n");
        printf("2. Display Candidates\n");
        printf("3. Cast Vote\n");
        printf("4. Display Winner\n");
        printf("5. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch(choice) {
            case 1:
                addCandidate(candidates, &numCandidates);
                break;
            case 2:
                displayCandidates(candidates, numCandidates);
                break;
            case 3:
                castVote(candidates, numCandidates);
                break;
            case 4:
                displayWinner(candidates, numCandidates);
                break;
            case 5:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice\n");
        }
    } while (choice != 5);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addCandidate(_QWORD, _QWORD); // weak
__int64 __fastcall displayCandidates(_QWORD, _QWORD); // weak
__int64 __fastcall castVote(_QWORD, _QWORD); // weak
__int64 __fastcall displayWinner(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400019A4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-54h] BYREF
  char v5[10412]; // [rsp+30h] [rbp-50h] BYREF
  unsigned int v6; // [rsp+28DCh] [rbp+285Ch] BYREF

  _main(argc, argv, envp);
  v6 = 0;
  do
  {
    printf("\n1. Add Candidate\n");
    printf("2. Display Candidates\n");
    printf("3. Cast Vote\n");
    printf("4. Display Winner\n");
    printf("5. Exit\n");
    printf("Enter choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        addCandidate(v5, &v6);
        break;
      case 2:
        displayCandidates(v5, v6);
        break;
      case 3:
        castVote(v5, v6);
        break;
      case 4:
        displayWinner(v5, v6);
        break;
      case 5:
        printf("Exiting...\n");
        break;
      default:
        printf("Invalid choice\n");
        break;
    }
  }
  while ( v4 != 5 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall addCandidate(_QWORD, _QWORD);
// 14000167E: using guessed type __int64 __fastcall displayCandidates(_QWORD, _QWORD);
// 140001719: using guessed type __int64 __fastcall castVote(_QWORD, _QWORD);
// 140001821: using guessed type __int64 __fastcall displayWinner(_QWORD, _QWORD);
// 140001BB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: interoperable
#include <stdlib.h>
#include <stdio.h>

// Define linked list structure
typedef struct node {
    int data;
    struct node *next;
} Node;

// Declare global variables
Node *head = NULL;
Node *tail = NULL;

// Function to add a new node to the end of the linked list
void addNode(int data) {
    Node *newNode = malloc(sizeof(Node)); // Allocate memory for new node
    newNode->data = data;
    newNode->next = NULL;

    // If head is null, set new node as head and tail
    if (head == NULL) {
        head = newNode;
        tail = newNode;
    } 
    // Otherwise, add new node to end of list
    else {
        tail->next = newNode;
        tail = newNode;
    }
}

// Function to remove a node from the linked list
void removeNode(int data) {
    Node *curNode = head;
    Node *prevNode = NULL;

    while (curNode != NULL && curNode->data != data) {
        prevNode = curNode;
        curNode = curNode->next;
    }

    // If node is found, remove it from list
    if (curNode != NULL) {
        if (curNode == head) {
            head = curNode->next;
        } else if (curNode == tail) {
            prevNode->next = NULL;
            tail = prevNode;
        } else {
            prevNode->next = curNode->next;
        }

        free(curNode); // Free memory for removed node
    }
}

// Function to display the linked list
void displayList() {
    Node *curNode = head;

    printf("Linked List: ");

    while (curNode != NULL) {
        printf("%d ", curNode->data);
        curNode = curNode->next;
    }

    printf("\n");
}

int main() {
    // Add some nodes to the list
    addNode(1);
    addNode(2);
    addNode(3);
    addNode(4);
    addNode(5);

    // Display the list
    displayList();

    // Remove some nodes from the list
    removeNode(3);
    removeNode(5);

    // Display the list again
    displayList();
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall addNode(_QWORD); // weak
__int64 __fastcall removeNode(_QWORD); // weak
__int64 displayList(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000171C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  addNode(1i64);
  addNode(2i64);
  addNode(3i64);
  addNode(4i64);
  addNode(5i64);
  displayList();
  removeNode(3i64);
  removeNode(5i64);
  displayList();
  return 0;
}
// 140001591: using guessed type __int64 __fastcall addNode(_QWORD);
// 140001604: using guessed type __int64 __fastcall removeNode(_QWORD);
// 1400016B8: using guessed type __int64 displayList(void);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Periodic Table Quiz ; Style: medieval
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// function to check if an element is in the array of answered questions
int inArray(int arr[], int size, int value) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == value) {
            return 1;
        }
    }
    return 0;
}

int main() {
    srand(time(0)); // seed random number generator with current time

    // array of element symbols
    char *elements[] = {"H", "He", "Li", "Be", "B", "C", "N", "O", "F", "Ne", "Na", "Mg", "Al", "Si", "P", "S", "Cl", "Ar", "K", 
                        "Ca", "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr",
                        "Rb", "Sr", "Y", "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb", "Te", "I", "Xe"};

    // array of element names
    char *names[] = {"Hydrogen", "Helium", "Lithium", "Beryllium", "Boron", "Carbon", "Nitrogen", "Oxygen", "Fluorine", "Neon", "Sodium",
                     "Magnesium", "Aluminum", "Silicon", "Phosphorus", "Sulfur", "Chlorine", "Argon", "Potassium", "Calcium", "Scandium",
                     "Titanium", "Vanadium", "Chromium", "Manganese", "Iron", "Cobalt", "Nickel", "Copper", "Zinc", "Gallium", "Germanium",
                     "Arsenic", "Selenium", "Bromine", "Krypton", "Rubidium", "Strontium", "Yttrium", "Zirconium", "Niobium", "Molybdenum",
                     "Technetium", "Ruthenium", "Rhodium", "Palladium", "Silver", "Cadmium", "Indium", "Tin", "Antimony", "Tellurium",
                     "Iodine", "Xenon"};

    // array of medieval-style questions
    char *questions[] = {"What be the symbol for the element that turnseth sand into glass?",
                         "Which element be named after a radiant light that shineth from within?",
                         "What powerful element be used in the construction of castles and fortresses?",
                         "Which element maketh ye sword sharp and strong?",
                         "What element doth fuel the roaring flames of ye furnace?",
                         "Which element doth giveth life to ye potion?",
                         "What be the element that twinkles like a star in ye nighttime sky?",
                         "Which element doth make ye poison deadly and deadly poison?",
                         "What be the element that doth preserve ye food for many a moon?",
                         "Which element hath ye power to heal wounds and mend bones?",
                         "What be the element that doth cause thunder and lightning on ye stormy eve?"};

    // array of answers to the questions
    int answers[] = {5, 2, 13, 4, 6, 7, 18, 9, 30, 20, 17};

    // initialize variables
    int score = 0;
    int answered[11];
    memset(answered, 0, sizeof(int) * 11);

    // print introduction
    printf("Welcome to the Medieval Periodic Table Quiz!\n");
    printf("Answer 10 questions about the elements and earn ye rightful place among the noble scientists of the realm.\n\n");

    // loop through 10 questions
    for (int i = 0; i < 10; i++) {
        int questionNum;
        do {
            questionNum = rand() % 11;
        } while (inArray(answered, i, questionNum));

        // print question
        printf("%d. %s\n", i+1, questions[questionNum]);

        // print answer options
        int answerOptions[4];
        for (int j = 0; j < 4; j++) {
            do {
                answerOptions[j] = rand() % 60;
            } while (answerOptions[j] == answers[questionNum] || inArray(answerOptions, j, answerOptions[j]));
            printf("%d. %s\t\t", j+1, elements[answerOptions[j]]);
        }
        printf("\n");

        // read and validate answer
        int choice;
        printf("Enter your answer: ");
        scanf("%d", &choice);
        while (choice < 1 || choice > 4) {
            printf("Invalid input. Please enter a number between 1 and 4: ");
            scanf("%d", &choice);
        }

        if (answerOptions[choice-1] == answers[questionNum]) {
            printf("Well done! Ye have answered correctly!\n\n");
            score++;
        } else {
            printf("Alas, ye have answered incorrectly. The correct answer wast: %s.\n\n", elements[answers[questionNum]]);
        }

        answered[i] = questionNum;
    }

    // print final score
    printf("Ye have completed the quiz! Ye score be %d out of 10.\n", score);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall inArray(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// void *__cdecl memset(void *, int Val, size_t Size);

//-------------------------------------------------------------------------
// Data declarations

char *off_140014020[5] = { "H", "He", "Li", "Be", "B" }; // weak
char *off_1400141E0[54] =
{
  "Hydrogen",
  "Helium",
  "Lithium",
  "Beryllium",
  "Boron",
  "Carbon",
  "Nitrogen",
  "Oxygen",
  "Fluorine",
  "Neon",
  "Sodium",
  "Magnesium",
  "Aluminum",
  "Silicon",
  "Phosphorus",
  "Sulfur",
  "Chlorine",
  "Argon",
  "Potassium",
  "Calcium",
  "Scandium",
  "Titanium",
  "Vanadium",
  "Chromium",
  "Manganese",
  "Iron",
  "Cobalt",
  "Nickel",
  "Copper",
  "Zinc",
  "Gallium",
  "Germanium",
  "Arsenic",
  "Selenium",
  "Bromine",
  "Krypton",
  "Rubidium",
  "Strontium",
  "Yttrium",
  "Zirconium",
  "Niobium",
  "Molybdenum",
  "Technetium",
  "Ruthenium",
  "Rhodium",
  "Palladium",
  "Silver",
  "Cadmium",
  "Indium",
  "Tin",
  "Antimony",
  "Tellurium",
  "Iodine",
  "Xenon"
}; // weak


//----- (0000000140001656) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+2Ch] [rbp-54h] BYREF
  int v6[4]; // [rsp+30h] [rbp-50h] BYREF
  int v7[12]; // [rsp+40h] [rbp-40h] BYREF
  int v8[12]; // [rsp+70h] [rbp-10h]
  __int64 v9[12]; // [rsp+A0h] [rbp+20h]
  char v10[432]; // [rsp+100h] [rbp+80h] BYREF
  __int64 v11[54]; // [rsp+2B0h] [rbp+230h] BYREF
  unsigned int v12; // [rsp+460h] [rbp+3E0h]
  unsigned int j; // [rsp+464h] [rbp+3E4h]
  unsigned int i; // [rsp+468h] [rbp+3E8h]
  unsigned int v15; // [rsp+46Ch] [rbp+3ECh]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  qmemcpy(v11, off_140014020, sizeof(v11));
  qmemcpy(v10, off_1400141E0, sizeof(v10));
  v9[0] = (__int64)"What be the symbol for the element that turnseth sand into glass?";
  v9[1] = (__int64)"Which element be named after a radiant light that shineth from within?";
  v9[2] = (__int64)"What powerful element be used in the construction of castles and fortresses?";
  v9[3] = (__int64)"Which element maketh ye sword sharp and strong?";
  v9[4] = (__int64)"What element doth fuel the roaring flames of ye furnace?";
  v9[5] = (__int64)"Which element doth giveth life to ye potion?";
  v9[6] = (__int64)"What be the element that twinkles like a star in ye nighttime sky?";
  v9[7] = (__int64)"Which element doth make ye poison deadly and deadly poison?";
  v9[8] = (__int64)"What be the element that doth preserve ye food for many a moon?";
  v9[9] = (__int64)"Which element hath ye power to heal wounds and mend bones?";
  v9[10] = (__int64)"What be the element that doth cause thunder and lightning on ye stormy eve?";
  v8[0] = 5;
  v8[1] = 2;
  v8[2] = 13;
  v8[3] = 4;
  v8[4] = 6;
  v8[5] = 7;
  v8[6] = 18;
  v8[7] = 9;
  v8[8] = 30;
  v8[9] = 20;
  v8[10] = 17;
  v15 = 0;
  memset(v7, 0, 0x2Cui64);
  printf("Welcome to the Medieval Periodic Table Quiz!\n");
  printf("Answer 10 questions about the elements and earn ye rightful place among the noble scientists of the realm.\n\n");
  for ( i = 0; (int)i <= 9; ++i )
  {
    do
      v12 = rand() % 11;
    while ( (unsigned int)inArray(v7, i, v12) );
    printf("%d. %s\n", i + 1, (const char *)v9[v12]);
    for ( j = 0; (int)j <= 3; ++j )
    {
      do
      {
        do
          v6[j] = rand() % 60;
        while ( v6[j] == v8[v12] );
      }
      while ( (unsigned int)inArray(v6, j, (unsigned int)v6[j]) );
      printf("%d. %s\t\t", j + 1, (const char *)v11[v6[j]]);
    }
    printf("\n");
    printf("Enter your answer: ");
    scanf("%d", &v5);
    while ( v5 <= 0 || v5 > 4 )
    {
      printf("Invalid input. Please enter a number between 1 and 4: ");
      scanf("%d", &v5);
    }
    if ( v6[v5 - 1] == v8[v12] )
    {
      printf("Well done! Ye have answered correctly!\n\n");
      ++v15;
    }
    else
    {
      printf("Alas, ye have answered incorrectly. The correct answer wast: %s.\n\n", (const char *)v11[v8[v12]]);
    }
    v7[i] = v12;
  }
  printf("Ye have completed the quiz! Ye score be %d out of 10.\n", v15);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall inArray(_QWORD, _QWORD, _QWORD);
// 140001AE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140014020: using guessed type char *off_140014020[5];
// 1400141E0: using guessed type char *off_1400141E0[54];
// 140001656: using guessed type __int64 var_1D0[54];
// 140001656: using guessed type int var_440[12];
// 140001656: using guessed type int var_450[4];

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Typing Speed Test ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ctype.h>

int main()
{
    printf("Welcome to the Typing Speed Test!\n\n");

    printf("You will be given a random sentence to type. Once you have typed the entire sentence, your typing speed will be calculated and displayed.\n\n");

    printf("Please press enter to begin the test.\n");
    getchar();

    // Array of random sentences
    char sentences[10][100] = {"The quick brown fox jumps over the lazy dog",
                               "Sphinx of black quartz, judge my vow",
                               "How vexingly quick daft zebras jump",
                               "Jaded zombies acted quaintly but kept driving their oxen forward",
                               "Pack my box with five dozen liquor jugs",
                               "The five boxing wizards jump quickly",
                               "The quick onyx goblin jumps over the lazy dwarf",
                               "Waltz, bad nymph, for quick jigs vex",
                               "Quick zephyrs blow, vexing daft Jim",
                               "The quick brown fox jumps over a lazy dog"};

    // Set random seed
    srand(time(NULL));

    // Select random sentence
    int random_index = rand() % 10;
    char random_sentence[100];
    strcpy(random_sentence, sentences[random_index]);

    printf("\n%s\n", random_sentence);

    // Start timer
    clock_t start = clock();

    // Take user input
    char user_input[100];
    fgets(user_input, 100, stdin);

    // Remove newline character from user_input
    user_input[strcspn(user_input, "\n")] = 0;

    // Convert all characters to uppercase for comparison
    for (int i = 0; i < strlen(user_input); i++)
    {
        user_input[i] = toupper(user_input[i]);
    }

    // Calculate time taken
    clock_t end = clock();
    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC;

    // Calculate typing speed
    int words_typed = 1;
    for (int i = 0; i < strlen(user_input); i++)
    {
        if (user_input[i] == ' ')
        {
            words_typed++;
        }
    }

    double typing_speed = ((double)words_typed) / time_taken;
    printf("\nCongratulations! You typed %d words in %.2f seconds. Your typing speed is %.2f words per second.\n", words_typed, time_taken, typing_speed);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl strcpy(char *Destination, const char *Source);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// clock_t __cdecl clock();
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

char aTheQuickBrownF[44] = "The quick brown fox jumps over the lazy dog"; // weak
// extern int (__cdecl *toupper)(int C);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  FILE *v4; // rax
  char Buffer[112]; // [rsp+20h] [rbp-60h] BYREF
  char Destination[112]; // [rsp+90h] [rbp+10h] BYREF
  char v8[1000]; // [rsp+100h] [rbp+80h] BYREF
  double v9; // [rsp+4F0h] [rbp+470h]
  clock_t v10; // [rsp+4F8h] [rbp+478h]
  clock_t v11; // [rsp+4FCh] [rbp+47Ch]
  int v12; // [rsp+500h] [rbp+480h]
  int j; // [rsp+504h] [rbp+484h]
  unsigned int v14; // [rsp+508h] [rbp+488h]
  int i; // [rsp+50Ch] [rbp+48Ch]

  _main(argc, argv, envp);
  printf("Welcome to the Typing Speed Test!\n\n");
  printf(
    "You will be given a random sentence to type. Once you have typed the entire sentence, your typing speed will be calc"
    "ulated and displayed.\n"
    "\n");
  printf("Please press enter to begin the test.\n");
  getchar();
  qmemcpy(v8, aTheQuickBrownF, sizeof(v8));
  v3 = time(0i64);
  srand(v3);
  v12 = rand() % 10;
  strcpy(Destination, &v8[100 * v12]);
  printf("\n%s\n", Destination);
  v11 = clock();
  v4 = __acrt_iob_func(0);
  fgets(Buffer, 100, v4);
  Buffer[strcspn(Buffer, "\n")] = 0;
  for ( i = 0; i < strlen(Buffer); ++i )
    Buffer[i] = toupper(Buffer[i]);
  v10 = clock();
  v9 = (double)(v10 - v11) / 1000.0;
  v14 = 1;
  for ( j = 0; j < strlen(Buffer); ++j )
  {
    if ( Buffer[j] == 32 )
      ++v14;
  }
  printf(
    "\nCongratulations! You typed %d words in %.2f seconds. Your typing speed is %.2f words per second.\n",
    v14,
    v9,
    (double)(int)v14 / v9);
  return 0;
}
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type char var_430[1000];
// 1400015B0: using guessed type char Buffer[112];

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System boot optimizer ; Style: configurable
#include <stdio.h>
#include <stdlib.h>

#define MAX_SPEED 100
#define MIN_SPEED 10
#define MAX_MEMORY 50000
#define MIN_MEMORY 1000

int main() {
    int boot_speed = 50;
    int memory_size = 20000;
    
    printf("Current boot speed: %d\n", boot_speed);
    printf("Current memory size: %d\n", memory_size);
    
    // Configure the boot speed
    printf("Enter the desired boot speed (between %d and %d): ", MIN_SPEED, MAX_SPEED);
    scanf("%d", &boot_speed);
    if (boot_speed < MIN_SPEED) {
        printf("Invalid input. Boot speed set to minimum of %d.\n", MIN_SPEED);
        boot_speed = MIN_SPEED;
    } else if (boot_speed > MAX_SPEED) {
        printf("Invalid input. Boot speed set to maximum of %d.\n", MAX_SPEED);
        boot_speed = MAX_SPEED;
    }
    
    // Configure the memory size
    printf("Enter the desired memory size (between %d and %d): ", MIN_MEMORY, MAX_MEMORY);
    scanf("%d", &memory_size);
    if (memory_size < MIN_MEMORY) {
        printf("Invalid input. Memory size set to minimum of %d.\n", MIN_MEMORY);
        memory_size = MIN_MEMORY;
    } else if (memory_size > MAX_MEMORY) {
        printf("Invalid input. Memory size set to maximum of %d.\n", MAX_MEMORY);
        memory_size = MAX_MEMORY;
    }
    
    // Optimize the system boot
    printf("Optimizing system boot with the following configuration:\n");
    printf("Boot speed: %d\n", boot_speed);
    printf("Memory size: %d\n", memory_size);
    printf("Please wait...\n");
    // Code for optimizing system boot goes here
    printf("System boot optimized successfully!\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-8h] BYREF
  int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  v5 = 50;
  v4 = 20000;
  printf("Current boot speed: %d\n", 50i64);
  printf("Current memory size: %d\n", 20000i64);
  printf("Enter the desired boot speed (between %d and %d): ", 10i64, 100i64);
  scanf("%d", &v5);
  if ( v5 > 9 )
  {
    if ( v5 > 100 )
    {
      printf("Invalid input. Boot speed set to maximum of %d.\n", 100i64);
      v5 = 100;
    }
  }
  else
  {
    printf("Invalid input. Boot speed set to minimum of %d.\n", 10i64);
    v5 = 10;
  }
  printf("Enter the desired memory size (between %d and %d): ", 1000i64, 50000i64);
  scanf("%d", &v4);
  if ( v4 > 999 )
  {
    if ( v4 > 50000 )
    {
      printf("Invalid input. Memory size set to maximum of %d.\n", 50000i64);
      v4 = 50000;
    }
  }
  else
  {
    printf("Invalid input. Memory size set to minimum of %d.\n", 1000i64);
    v4 = 1000;
  }
  printf("Optimizing system boot with the following configuration:\n");
  printf("Boot speed: %d\n", (unsigned int)v5);
  printf("Memory size: %d\n", (unsigned int)v4);
  printf("Please wait...\n");
  printf("System boot optimized successfully!\n");
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Medical Store Management System ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STOCK 100 // maximum items that can be stored in the stock

struct medicine {
    char name[50];
    int quantity;
    float price;
};

int num_medicines = 0;
struct medicine stock[MAX_STOCK];

void add_medicine() {
    if (num_medicines == MAX_STOCK) {
        printf("Stock is full. Cannot add more medicines.\n");
        return;
    }

    struct medicine med;

    printf("Enter medicine name: ");
    scanf("%s", med.name);

    printf("Enter quantity: ");
    scanf("%d", &med.quantity);

    printf("Enter price: ");
    scanf("%f", &med.price);

    stock[num_medicines++] = med;

    printf("Medicine added successfully.\n");
}

void sell_medicine() {
    char med_name[50];
    int quantity_to_sell;

    printf("Enter medicine name to sell: ");
    scanf("%s", med_name);

    for (int i = 0; i < num_medicines; i++) {
        if (strcmp(stock[i].name, med_name) == 0) {
            printf("Enter quantity to sell: ");
            scanf("%d", &quantity_to_sell);

            if (quantity_to_sell > stock[i].quantity) {
                printf("Insufficient stock. Cannot sell %d %s.\n", quantity_to_sell, med_name);
                return;
            }

            stock[i].quantity -= quantity_to_sell;
            printf("%d %s sold successfully for Rs. %.2f\n", quantity_to_sell, med_name, quantity_to_sell * stock[i].price);
            return;
        }
    }

    printf("Medicine not found in the stock.\n");
}

void display_medicines() {
    if (num_medicines == 0) {
        printf("No medicines in the stock.\n");
        return;
    }

    printf("Name\t\tQuantity\t\tPrice\n");

    for (int i = 0; i < num_medicines; i++) {
        printf("%s\t\t%d\t\t\t%.2f\n", stock[i].name, stock[i].quantity, stock[i].price);
    }
}

int main() {
    while (1) {
        printf("\n1. Add medicine\n2. Sell medicine\n3. Display medicines\n4. Exit\n\n");

        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                add_medicine();
                break;
            case 2:
                sell_medicine();
                break;
            case 3:
                display_medicines();
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice. Try again.\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_medicine(void); // weak
__int64 sell_medicine(void); // weak
__int64 display_medicines(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400019A7) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    printf("\n1. Add medicine\n2. Sell medicine\n3. Display medicines\n4. Exit\n\n");
    scanf("%d", &v3);
    if ( v3 == 4 )
      exit(0);
    if ( v3 > 4 )
    {
LABEL_12:
      printf("Invalid choice. Try again.\n");
    }
    else
    {
      switch ( v3 )
      {
        case 3:
          display_medicines();
          break;
        case 1:
          add_medicine();
          break;
        case 2:
          sell_medicine();
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 1400019EE: conditional instruction was optimized away because %var_4.4<3
// 1400015E2: using guessed type __int64 add_medicine(void);
// 140001709: using guessed type __int64 sell_medicine(void);
// 1400018BE: using guessed type __int64 display_medicines(void);
// 140001AE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Tower of Hanoi Problem ; Style: immersive
#include <stdio.h>

void moveDisk(char from, char to, int disk){
    printf("Move disk %d from %c to %c\n", disk, from, to);
}

void TOH(int disk, char A, char C, char B){
    if (disk == 1){
        moveDisk(A, C, disk);
    }
    else{
        TOH(disk-1, A, B, C);
        moveDisk(A, C, disk);
        TOH(disk-1, B, C, A);
    }
}

int main(){
    int disk;
    char A = 'A';
    char B = 'B';
    char C = 'C';

    printf("Welcome to the Tower of Hanoi Immersive Experience!\n");
    printf("Rules: You have to transfer all the disks from rod A to rod C.\n");
    printf("But remember, there are 3 rules that you must follow:\n");
    printf("1. Only one disk can be moved at a time.\n");
    printf("2. You can only move the top disk of a stack.\n");
    printf("3. A larger disk cannot be placed on top of a smaller disk.\n");
    printf("Enter the number of disks you want to start with: ");
    scanf("%d", &disk);

    TOH(disk, A, C, B);

    printf("Well done! You have completed the Tower of Hanoi challenge.\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall TOH(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016AC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-8h] BYREF
  char v5[3]; // [rsp+2Dh] [rbp-3h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v5, "CBA", sizeof(v5));
  printf("Welcome to the Tower of Hanoi Immersive Experience!\n");
  printf("Rules: You have to transfer all the disks from rod A to rod C.\n");
  printf("But remember, there are 3 rules that you must follow:\n");
  printf("1. Only one disk can be moved at a time.\n");
  printf("2. You can only move the top disk of a stack.\n");
  printf("3. A larger disk cannot be placed on top of a smaller disk.\n");
  printf("Enter the number of disks you want to start with: ");
  scanf("%d", &v4);
  TOH(v4, (unsigned int)v5[2], (unsigned int)v5[0], (unsigned int)v5[1]);
  printf("Well done! You have completed the Tower of Hanoi challenge.\n");
  return 0;
}
// 140001621: using guessed type __int64 __fastcall TOH(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016AC: using guessed type unsigned int var_8;

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Poker Game ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DECK_SIZE 52
#define NUM_CARDS 2

int random_card();
int get_card_value(int card);
int determine_hand_value(int hand[], int num_cards);

int main() {
    int deck[DECK_SIZE]; // Array to represent the deck of cards
    int player_hand[NUM_CARDS]; // Array to hold the cards in the player's hand
    int dealer_hand[NUM_CARDS]; // Array to hold the cards in the dealer's hand
    int player_total, dealer_total;
    int player_score = 0, dealer_score = 0;
    int num_games = 1;
    char input;

    srand(time(NULL)); // Seed the random number generator

    while (1) { // Loop to play multiple games
        printf("Game %d:\n", num_games);
        num_games++;

        // Initialize the deck of cards
        for (int i = 0; i < DECK_SIZE; i++) {
            deck[i] = i;
        }

        // Shuffle the deck
        for (int i = 0; i < DECK_SIZE; i++) {
            int j = rand() % DECK_SIZE;
            int temp = deck[i];
            deck[i] = deck[j];
            deck[j] = temp;
        }

        // Deal the cards
        player_hand[0] = deck[0];
        dealer_hand[0] = deck[1];
        player_hand[1] = deck[2];
        dealer_hand[1] = deck[3];

        // Print the dealer's face up card
        printf("Dealer's face up card: %d\n", get_card_value(dealer_hand[0]));

        // Ask the player for their move
        printf("Your hand: %d, %d\n", get_card_value(player_hand[0]), get_card_value(player_hand[1]));
        printf("What do you want to do? (h)it or (s)tand? ");

        // Get the player's move
        input = getchar();
        while (input != 'h' && input != 's') {
            input = getchar();
        }
        while (getchar() != '\n'); // Clear any extra input

        // Player hits
        if (input == 'h') {
            player_hand[2] = deck[4];

            // Determine the value of the player's hand
            player_total = determine_hand_value(player_hand, 3);

            // Print the player's hand and total
            printf("Your hand: %d, %d, %d\n", get_card_value(player_hand[0]), get_card_value(player_hand[1]), get_card_value(player_hand[2]));
            printf("Your total: %d\n", player_total);

            // Determine the value of the dealer's hand
            dealer_total = determine_hand_value(dealer_hand, 2);

            // Dealer hits until they have a total of at least 17
            while (dealer_total < 17) {
                dealer_hand[2] = deck[5];
                dealer_total = determine_hand_value(dealer_hand, 3);
            }

            // Print the dealer's hand and total
            printf("Dealer's hand: %d, %d, %d\n", get_card_value(dealer_hand[0]), get_card_value(dealer_hand[1]), get_card_value(dealer_hand[2]));
            printf("Dealer's total: %d\n", dealer_total);

            // Determine the winner
            if ((player_total > dealer_total && player_total <= 21) || (dealer_total > 21 && player_total <= 21)) {
                printf("You win!\n");
                player_score++;
            }
            else if ((dealer_total > player_total && dealer_total <= 21) || (player_total > 21 && dealer_total <= 21)) {
                printf("Dealer wins!\n");
                dealer_score++;
            }
            else {
                printf("Draw!\n");
            }
        }
        // Player stands
        else if (input == 's') {
            // Determine the value of the player's hand
            player_total = determine_hand_value(player_hand, 2);

            // Determine the value of the dealer's hand
            dealer_total = determine_hand_value(dealer_hand, 2);

            // Dealer hits until they have a total of at least 17
            while (dealer_total < 17) {
                dealer_hand[2] = deck[4];
                dealer_total = determine_hand_value(dealer_hand, 3);
            }

            // Print the dealer's hand and total
            printf("Dealer's hand: %d, %d, %d\n", get_card_value(dealer_hand[0]), get_card_value(dealer_hand[1]), get_card_value(dealer_hand[2]));
            printf("Dealer's total: %d\n", dealer_total);

            // Determine the winner
            if ((player_total > dealer_total && player_total <= 21) || (dealer_total > 21 && player_total <= 21)) {
                printf("You win!\n");
                player_score++;
            }
            else if ((dealer_total > player_total && dealer_total <= 21) || (player_total > 21 && dealer_total <= 21)) {
                printf("Dealer wins!\n");
                dealer_score++;
            }
            else {
                printf("Draw!\n");
            }
        }

        // Print the current score
        printf("Score: You %d, Dealer %d\n", player_score, dealer_score);

        // Ask the player if they want to play again
        printf("Play again? (y/n) ");
        input = getchar();
        while (input != 'y' && input != 'n') {
            input = getchar();
        }
        while (getchar() != '\n'); // Clear any extra input

        if (input == 'n') {
            break;
        }

        printf("\n");
    }

    return 0;
}

// Function to get a random card from the deck
int random_card() {
    static int card_index = 0;
    return card_index++;
}

// Function to get the value of a card
int get_card_value(int card) {
    int value = (card % 13) + 1;
    if (value > 10) {
        value = 10;
    }
    return value;
}

// Function to determine the total value of a hand
int determine_hand_value(int hand[], int num_cards) {
    int total = 0;
    int num_aces = 0;

    for (int i = 0; i < num_cards; i++) {
        int card_value = get_card_value(hand[i]);
        if (card_value == 1) {
            num_aces++;
        }
        total += card_value;
    }

    // If there are aces in the hand, adjust the total for the highest possible value
    while (num_aces > 0 && total + 10 <= 21) {
        total += 10;
        num_aces--;
    }

    return total;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall get_card_value(_QWORD); // weak
__int64 __fastcall determine_hand_value(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int card_value; // eax
  unsigned int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // esi
  unsigned int v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // esi
  unsigned int v11; // ebx
  unsigned int v12; // eax
  unsigned int v13; // esi
  unsigned int v14; // ebx
  unsigned int v15; // eax
  unsigned int v17; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v18; // [rsp+24h] [rbp-5Ch]
  unsigned int v19; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v20; // [rsp+2Ch] [rbp-54h]
  unsigned int v21; // [rsp+30h] [rbp-50h]
  unsigned int v22; // [rsp+34h] [rbp-4Ch]
  unsigned int v23; // [rsp+38h] [rbp-48h]
  unsigned int v24; // [rsp+3Ch] [rbp-44h]
  unsigned int v25; // [rsp+40h] [rbp-40h]
  unsigned int v26; // [rsp+44h] [rbp-3Ch]
  unsigned int v27; // [rsp+108h] [rbp+88h]
  int v28; // [rsp+10Ch] [rbp+8Ch]
  int v29; // [rsp+110h] [rbp+90h]
  int j; // [rsp+114h] [rbp+94h]
  int i; // [rsp+118h] [rbp+98h]
  char k; // [rsp+11Fh] [rbp+9Fh]
  unsigned int v33; // [rsp+120h] [rbp+A0h]
  unsigned int v34; // [rsp+124h] [rbp+A4h]
  unsigned int v35; // [rsp+128h] [rbp+A8h]
  int m; // [rsp+12Ch] [rbp+ACh]

  _main(argc, argv, envp);
  v35 = 0;
  v34 = 0;
  v33 = 1;
  v3 = time(0i64);
  srand(v3);
  while ( 1 )
  {
    printf("Game %d:\n", v33++);
    for ( i = 0; i <= 51; ++i )
      *(&v21 + i) = i;
    for ( j = 0; j <= 51; ++j )
    {
      v28 = rand() % 52;
      v27 = *(&v21 + j);
      *(&v21 + j) = *(&v21 + v28);
      *(&v21 + v28) = v27;
    }
    v19 = v21;
    v17 = v22;
    v20 = v23;
    v18 = v24;
    card_value = get_card_value(v22);
    printf("Dealer's face up card: %d\n", card_value);
    v5 = get_card_value(v20);
    v6 = get_card_value(v19);
    printf("Your hand: %d, %d\n", v6, v5);
    printf("What do you want to do? (h)it or (s)tand? ");
    for ( k = getchar(); k != 104 && k != 115; k = getchar() )
      ;
    while ( getchar() != 10 )
      ;
    if ( k != 104 )
    {
      if ( k != 115 )
        goto LABEL_43;
      v29 = determine_hand_value(&v19, 2i64);
      for ( m = determine_hand_value(&v17, 2i64); m <= 16; m = determine_hand_value(&v17, 3i64) )
        v19 = v25;
      v13 = get_card_value(v19);
      v14 = get_card_value(v18);
      v15 = get_card_value(v17);
      printf("Dealer's hand: %d, %d, %d\n", v15, v14, v13);
      printf("Dealer's total: %d\n", (unsigned int)m);
      if ( v29 > m && v29 <= 21 || m > 21 && v29 <= 21 )
        goto LABEL_21;
      if ( (m <= v29 || m > 21) && (v29 <= 21 || m > 21) )
      {
LABEL_42:
        printf("Draw!\n");
        goto LABEL_43;
      }
LABEL_26:
      printf("Dealer wins!\n");
      ++v34;
      goto LABEL_43;
    }
    v21 = v25;
    v29 = determine_hand_value(&v19, 3i64);
    v7 = get_card_value(v21);
    v8 = get_card_value(v20);
    v9 = get_card_value(v19);
    printf("Your hand: %d, %d, %d\n", v9, v8, v7);
    printf("Your total: %d\n", (unsigned int)v29);
    for ( m = determine_hand_value(&v17, 2i64); m <= 16; m = determine_hand_value(&v17, 3i64) )
      v19 = v26;
    v10 = get_card_value(v19);
    v11 = get_card_value(v18);
    v12 = get_card_value(v17);
    printf("Dealer's hand: %d, %d, %d\n", v12, v11, v10);
    printf("Dealer's total: %d\n", (unsigned int)m);
    if ( (v29 <= m || v29 > 21) && (m <= 21 || v29 > 21) )
    {
      if ( (m <= v29 || m > 21) && (v29 <= 21 || m > 21) )
        goto LABEL_42;
      goto LABEL_26;
    }
LABEL_21:
    printf("You win!\n");
    ++v35;
LABEL_43:
    printf("Score: You %d, Dealer %d\n", v35, v34);
    printf("Play again? (y/n) ");
    for ( k = getchar(); k != 121 && k != 110; k = getchar() )
      ;
    while ( getchar() != 10 )
      ;
    if ( k == 110 )
      return 0;
    printf("\n");
  }
}
// 140001AFF: using guessed type __int64 __fastcall get_card_value(_QWORD);
// 140001B55: using guessed type __int64 __fastcall determine_hand_value(_QWORD, _QWORD);
// 140001C90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: QR code reader ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_LENGTH 100

// Function to check if a string is a valid QR code format
bool isValidQRCode(char* qrCode) {
    if (strlen(qrCode) != 11) {
        return false;
    }
    if (qrCode[0] != 'C' || qrCode[1] != '-') {
        return false;
    }
    for (int i = 2; i < 11; i++) {
        if (qrCode[i] < '0' || qrCode[i] > '9') {
            return false;
        }
    }
    return true;
}

// Function to read QR code and return the numeric value
int readQRCode(char* qrCode) {
    if (!isValidQRCode(qrCode)) {
        return -1;
    }
    int value = 0;
    for (int i = 2; i < 11; i++) {
        value = value * 10 + (qrCode[i] - '0');
    }
    return value;
}

// Main function
int main() {
    char qrCode[MAX_LENGTH];
    printf("Enter the QR code: ");
    fgets(qrCode, MAX_LENGTH, stdin);
    // Remove newline character if present
    if (qrCode[strlen(qrCode) - 1] == '\n') {
        qrCode[strlen(qrCode) - 1] = '\0';
    }
    int value = readQRCode(qrCode);
    if (value == -1) {
        printf("Invalid QR code!\n");
        return -1;
    }
    printf("QR code value: %d\n", value);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall readQRCode(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001690) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[108]; // [rsp+20h] [rbp-70h] BYREF
  unsigned int QRCode; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the QR code: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  if ( Buffer[strlen(Buffer) - 1] == 10 )
    Buffer[strlen(Buffer) - 1] = 0;
  QRCode = readQRCode(Buffer);
  if ( QRCode == -1 )
  {
    printf("Invalid QR code!\n");
    return -1;
  }
  else
  {
    printf("QR code value: %d\n", QRCode);
    return 0;
  }
}
// 140001621: using guessed type __int64 __fastcall readQRCode(_QWORD);
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001690: using guessed type char Buffer[108];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sentiment analysis tool ; Style: imaginative
#include <stdio.h>
#include <string.h>

void main() {
    char text[1000];
    int positiveCount = 0, negativeCount = 0, neutralCount = 0;

    printf("Enter some text to analyze the sentiment: ");
    fgets(text, 1000, stdin);

    // Splitting words
    char *token = strtok(text, " ");

    while (token != NULL) {
        // Matching words with sentiment keywords
        if (strcmp(token, "good") == 0 || strcmp(token, "great") == 0 || strcmp(token, "excellent") == 0) {
            positiveCount++;
        } else if (strcmp(token, "bad") == 0 || strcmp(token, "poor") == 0 || strcmp(token, "terrible") == 0) {
            negativeCount++;
        } else {
            neutralCount++;
        }

        token = strtok(NULL, " ");
    }

    printf("Analysis Result:\n");
    printf("Positive Keywords count: %d\n", positiveCount);
    printf("Negative Keywords count: %d\n", negativeCount);
    printf("Neutral Keywords count: %d\n", neutralCount);

    if (positiveCount > negativeCount) {
        printf("Overall Sentiment: Positive");
    } else if (positiveCount < negativeCount) {
        printf("Overall Sentiment: Negative");
    } else {
        printf("Overall Sentiment: Neutral");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1000]; // [rsp+20h] [rbp-60h] BYREF
  char *Str1; // [rsp+408h] [rbp+388h]
  unsigned int v7; // [rsp+414h] [rbp+394h]
  int v8; // [rsp+418h] [rbp+398h]
  int v9; // [rsp+41Ch] [rbp+39Ch]

  _main(argc, argv, envp);
  v9 = 0;
  v8 = 0;
  v7 = 0;
  printf("Enter some text to analyze the sentiment: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  for ( Str1 = strtok(Buffer, " "); Str1; Str1 = strtok(0i64, " ") )
  {
    if ( !strcmp(Str1, "good") || !strcmp(Str1, "great") || !strcmp(Str1, "excellent") )
    {
      ++v9;
    }
    else if ( !strcmp(Str1, "bad") || !strcmp(Str1, "poor") || !strcmp(Str1, "terrible") )
    {
      ++v8;
    }
    else
    {
      ++v7;
    }
  }
  printf("Analysis Result:\n");
  printf("Positive Keywords count: %d\n", (unsigned int)v9);
  printf("Negative Keywords count: %d\n", (unsigned int)v8);
  printf("Neutral Keywords count: %d\n", v7);
  if ( v9 > v8 )
    return printf("Overall Sentiment: Positive");
  if ( v9 >= v8 )
    return printf("Overall Sentiment: Neutral");
  return printf("Overall Sentiment: Negative");
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Remote control Vehicle Simulation ; Style: visionary
// C Remote Control Vehicle Simulation
// by [insert your name here]

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int battery_level = 100;
    int position_x = 0;
    int position_y = 0;
    int speed = 0;
    int direction = 0;
    int distance_traveled = 0;

    srand(time(NULL));

    printf("Welcome to the Remote Control Vehicle Simulation!\n");
    printf("Battery level: %d%%\n", battery_level);

    while (battery_level > 0) {
        int action = rand() % 3; // randomly choose an action: 0 = move forward, 1 = move backward, 2 = change direction

        switch (action) {
            case 0: // move forward
                speed = rand() % 10; // randomly set speed between 0 and 9 mph
                distance_traveled += speed;
                position_x += speed * sin(direction);
                position_y += speed * cos(direction);
                printf("Moving forward at %d mph\n", speed);
                break;

            case 1: // move backward
                if (distance_traveled > 0) {
                    speed = rand() % 5; // randomly set speed between 0 and 4 mph
                    distance_traveled -= speed;
                    position_x -= speed * sin(direction);
                    position_y -= speed * cos(direction);
                    printf("Moving backward at %d mph\n", speed);
                } else {
                    printf("Cannot move backward - already at starting position\n");
                }
                break;

            case 2: // change direction
                direction = rand() % 360; // randomly set direction between 0 and 359 degrees
                printf("Changing direction to %d degrees\n", direction);
                break;
        }

        battery_level -= distance_traveled / 10; // decrease battery level in proportion to distance traveled
        printf("Battery level: %d%%\n", battery_level);
        printf("Position: (%d, %d)\n", position_x, position_y);
    }

    printf("Battery depleted - simulation ended\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl cos(double X);
double __cdecl sin(double X);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-1Ch]
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+28h] [rbp-18h]
  int v8; // [rsp+2Ch] [rbp-14h]
  int v9; // [rsp+30h] [rbp-10h]
  int v10; // [rsp+34h] [rbp-Ch]
  int v11; // [rsp+38h] [rbp-8h]
  int v12; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v12 = 100;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Remote Control Vehicle Simulation!\n");
  printf("Battery level: %d%%\n", 100i64);
  while ( v12 > 0 )
  {
    v5 = rand() % 3;
    if ( v5 == 2 )
    {
      v9 = rand() % 360;
      printf("Changing direction to %d degrees\n", (unsigned int)v9);
    }
    else if ( v5 <= 2 )
    {
      if ( v5 )
      {
        if ( v5 == 1 )
        {
          if ( v8 <= 0 )
          {
            printf("Cannot move backward - already at starting position\n");
          }
          else
          {
            v7 = rand() % 5;
            v8 -= v7;
            v11 = (int)((double)v11 - sin((double)v9) * (double)v7);
            v10 = (int)((double)v10 - cos((double)v9) * (double)v7);
            printf("Moving backward at %d mph\n", (unsigned int)v7);
          }
        }
      }
      else
      {
        v6 = rand() % 10;
        v8 += v6;
        v11 = (int)(sin((double)v9) * (double)v6 + (double)v11);
        v10 = (int)(cos((double)v9) * (double)v6 + (double)v10);
        printf("Moving forward at %d mph\n", (unsigned int)v6);
      }
    }
    v12 += v8 / -10;
    printf("Battery level: %d%%\n", (unsigned int)v12);
    printf("Position: (%d, %d)\n", (unsigned int)v11, (unsigned int)v10);
  }
  printf("Battery depleted - simulation ended\n");
  return 0;
}
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: realistic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  // Seeding the random number generator
  srand(time(NULL));
  
  // Initializing variables
  char name[20];
  int age, luckyNum, randomNum, fortuneNum;
  
  // Asking for user's input
  printf("Welcome to the Automated Fortune Teller!\n");
  printf("Please enter your name: ");
  scanf("%s", name);
  
  printf("Please enter your age: ");
  scanf("%d", &age);
  
  printf("Please enter your lucky number between 1 and 10: ");
  scanf("%d", &luckyNum);
  
  // Generating random number
  randomNum = rand() % 10 + 1;
  
  // Calculating fortune number
  fortuneNum = age * luckyNum * randomNum % 100;
  
  // Displaying fortune message
  printf("\nHello %s, your fortune for today is:\n", name);
  
  switch(fortuneNum) {
    case 0:
      printf("You will have a day full of surprises!\n");
      break;
    case 10:
      printf("A special someone will enter your life today.\n");
      break;
    case 20:
      printf("Your hard work will pay off soon.\n");
      break;
    case 30:
      printf("You will receive unexpected news that will change your life.\n");
      break;
    case 40:
      printf("You will travel to a distant land soon.\n");
      break;
    case 50:
      printf("A new career path is coming your way.\n");
      break;
    case 60:
      printf("Be cautious of someone close to you who might betray you.\n");
      break;
    case 70:
      printf("Great success will come to you in the near future.\n");
      break;
    case 80:
      printf("You will meet someone who will become very important to you.\n");
      break;
    case 90:
      printf("Your financial situation will drastically improve.\n");
      break;
    case 100:
      printf("Today is a lucky day for you!\n");
      break;
    default:
      printf("Something unexpected will happen today.\n");
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+28h] [rbp-28h] BYREF
  int v6; // [rsp+2Ch] [rbp-24h] BYREF
  char v7[24]; // [rsp+30h] [rbp-20h] BYREF
  int v8; // [rsp+48h] [rbp-8h]
  int v9; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Automated Fortune Teller!\n");
  printf("Please enter your name: ");
  scanf("%s", v7);
  printf("Please enter your age: ");
  scanf("%d", &v6);
  printf("Please enter your lucky number between 1 and 10: ");
  scanf("%d", &v5);
  v9 = rand() % 10 + 1;
  v8 = v9 * v6 * v5 % 100;
  printf("\nHello %s, your fortune for today is:\n", v7);
  if ( v8 == 100 )
  {
    printf("Today is a lucky day for you!\n");
    return 0;
  }
  if ( v8 > 100 )
    goto LABEL_33;
  if ( v8 == 90 )
  {
    printf("Your financial situation will drastically improve.\n");
    return 0;
  }
  if ( v8 > 90 )
    goto LABEL_33;
  if ( v8 == 80 )
  {
    printf("You will meet someone who will become very important to you.\n");
    return 0;
  }
  if ( v8 > 80 )
    goto LABEL_33;
  if ( v8 == 70 )
  {
    printf("Great success will come to you in the near future.\n");
    return 0;
  }
  if ( v8 > 70 )
    goto LABEL_33;
  if ( v8 == 60 )
  {
    printf("Be cautious of someone close to you who might betray you.\n");
    return 0;
  }
  if ( v8 > 60 )
    goto LABEL_33;
  if ( v8 == 50 )
  {
    printf("A new career path is coming your way.\n");
    return 0;
  }
  if ( v8 > 50 )
    goto LABEL_33;
  if ( v8 == 40 )
  {
    printf("You will travel to a distant land soon.\n");
    return 0;
  }
  if ( v8 > 40 )
    goto LABEL_33;
  if ( v8 == 30 )
  {
    printf("You will receive unexpected news that will change your life.\n");
    return 0;
  }
  if ( v8 > 30 )
    goto LABEL_33;
  if ( v8 == 20 )
  {
    printf("Your hard work will pay off soon.\n");
    return 0;
  }
  if ( v8 > 20 )
  {
LABEL_33:
    printf("Something unexpected will happen today.\n");
    return 0;
  }
  if ( v8 )
  {
    if ( v8 != 10 )
      goto LABEL_33;
    printf("A special someone will enter your life today.\n");
  }
  else
  {
    printf("You will have a day full of surprises!\n");
  }
  return 0;
}
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: Linus Torvalds
#include <stdio.h>

#define ARRAY_SIZE 10

void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) {
        L[i] = arr[left + i];
    }
    for (int j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j];
    }

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;

        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        merge(arr, left, mid, right);
    }
}

int main() {
    int arr[ARRAY_SIZE] = {5, 6, 3, 2, 9, 10, 1, 4, 8, 7};

    printf("Before sorting:\n");
    for (int i = 0; i < ARRAY_SIZE; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    mergeSort(arr, 0, ARRAY_SIZE - 1);

    printf("After sorting:\n");
    for (int i = 0; i < ARRAY_SIZE; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall mergeSort(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000188E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[10]; // [rsp+20h] [rbp-30h] BYREF
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 5;
  v4[1] = 6;
  v4[2] = 3;
  v4[3] = 2;
  v4[4] = 9;
  v4[5] = 10;
  v4[6] = 1;
  v4[7] = 4;
  v4[8] = 8;
  v4[9] = 7;
  printf("Before sorting:\n");
  for ( i = 0; i <= 9; ++i )
    printf("%d ", (unsigned int)v4[i]);
  printf("\n");
  mergeSort(v4, 0i64, 9i64);
  printf("After sorting:\n");
  for ( j = 0; j <= 9; ++j )
    printf("%d ", (unsigned int)v4[j]);
  printf("\n");
  return 0;
}
// 14000180E: using guessed type __int64 __fastcall mergeSort(_QWORD, _QWORD, _QWORD);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cat Language Translator ; Style: portable
#include <stdio.h>
#include <string.h>

int main() {
    char cat_sentence[100];
    int choice;

    printf("Welcome to the C Cat Language Translator!\n");
    printf("Enter a sentence in C Cat Language:\n");
    fgets(cat_sentence, 100, stdin);

    printf("Choose an option:\n");
    printf("1. Translate to English\n");
    printf("2. Translate to Meow\n");
    scanf("%d", &choice);

    if (choice == 1) {
        printf("Translation to English:\n");
        if (strcmp(cat_sentence, "meow") == 0) {
            printf("Hello\n");
        } else if (strcmp(cat_sentence, "meow meow") == 0) {
            printf("How are you?\n");
        } else if (strcmp(cat_sentence, "meow meow meow") == 0) {
            printf("I am doing well, thank you\n");
        } else {
            printf("Sorry, I do not understand the sentence\n");
        }
    } else if (choice == 2) {
        printf("Translation to Meow:\n");
        if (strcmp(cat_sentence, "Hello\n") == 0) {
            printf("meow\n");
        } else if (strcmp(cat_sentence, "How are you?\n") == 0) {
            printf("meow meow\n");
        } else if (strcmp(cat_sentence, "I am doing well, thank you\n") == 0) {
            printf("meow meow meow\n");
        } else {
            printf("Sorry, I do not understand the sentence\n");
        }
    } else {
        printf("Invalid choice\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v5; // [rsp+2Ch] [rbp-74h] BYREF
  char Buffer[112]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the C Cat Language Translator!\n");
  printf("Enter a sentence in C Cat Language:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  printf("Choose an option:\n");
  printf("1. Translate to English\n");
  printf("2. Translate to Meow\n");
  scanf("%d", &v5);
  if ( v5 != 1 )
  {
    if ( v5 != 2 )
    {
      printf("Invalid choice\n");
      return 0;
    }
    printf("Translation to Meow:\n");
    if ( !strcmp(Buffer, "Hello\n") )
    {
      printf("meow\n");
      return 0;
    }
    if ( !strcmp(Buffer, "How are you?\n") )
    {
      printf("meow meow\n");
      return 0;
    }
    if ( !strcmp(Buffer, "I am doing well, thank you\n") )
    {
      printf("meow meow meow\n");
      return 0;
    }
    goto LABEL_8;
  }
  printf("Translation to English:\n");
  if ( strcmp(Buffer, "meow") )
  {
    if ( !strcmp(Buffer, "meow meow") )
    {
      printf("How are you?\n");
      return 0;
    }
    if ( !strcmp(Buffer, "meow meow meow") )
    {
      printf("I am doing well, thank you\n");
      return 0;
    }
LABEL_8:
    printf("Sorry, I do not understand the sentence\n");
    return 0;
  }
  printf("Hello\n");
  return 0;
}
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Physics simulation ; Style: recursive
#include <stdio.h>

void simulate(int time, float velocity, float position){
    float acceleration = -9.8; // acceleration due to gravity
    float time_elapsed = 0.01; // small time step for more accurate simulation
    float new_position = position + velocity * time_elapsed; 
    float new_velocity = velocity + acceleration * time_elapsed;
    
    printf("Time: %d seconds, Position: %.2f meters, Velocity: %.2f m/s\n", time, position, velocity);
    
    if(time >= 10){ // simulation ends after 10 seconds
        return;
    }
    else{
        simulate(time+1, new_velocity, new_position);
    }
}

int main(){
    printf("C Physics Simulation: Object Falling Under Gravity\n");
    printf("Initial Conditions: Position = 50 meters, Velocity = 0 m/s\n");
    simulate(0, 0, 50); // simulate from time = 0, initial velocity = 0, initial position = 50
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall simulate(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000166B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("C Physics Simulation: Object Falling Under Gravity\n");
  printf("Initial Conditions: Position = 50 meters, Velocity = 0 m/s\n");
  simulate(0i64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall simulate(_QWORD);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Rogue-like Game with Procedural Generation ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAP_SIZE_X 50
#define MAP_SIZE_Y 20
#define MAX_ROOMS 10
#define ROOM_MIN_SIZE 3
#define ROOM_MAX_SIZE 6

typedef struct {
    int x, y, w, h;
} room_t;

typedef struct {
    char tile;
    int x, y;
} map_t;

void generate_map(map_t *map, room_t *rooms, int num_rooms) {
    // Set all tiles to wall
    for (int y = 0; y < MAP_SIZE_Y; y++) {
        for (int x = 0; x < MAP_SIZE_X; x++) {
            map[y * MAP_SIZE_X + x].tile = '#';
            map[y * MAP_SIZE_X + x].x = x;
            map[y * MAP_SIZE_X + x].y = y;
        }
    }
    // Generate rooms
    for (int r = 0; r < num_rooms; r++) {
        int w = rand() % (ROOM_MAX_SIZE - ROOM_MIN_SIZE + 1) + ROOM_MIN_SIZE;
        int h = rand() % (ROOM_MAX_SIZE - ROOM_MIN_SIZE + 1) + ROOM_MIN_SIZE;
        int x = rand() % (MAP_SIZE_X - w - 1) + 1;
        int y = rand() % (MAP_SIZE_Y - h - 1) + 1;
        rooms[r].x = x;
        rooms[r].y = y;
        rooms[r].w = w;
        rooms[r].h = h;
        // Set room tiles to floor
        for (int j = y; j < y + h; j++) {
            for (int i = x; i < x + w; i++) {
                map[j * MAP_SIZE_X + i].tile = '.';
            }
        }
    }
    // Generate corridors
    for (int r = 0; r < num_rooms - 1; r++) {
        int x1 = rooms[r].x + rooms[r].w / 2;
        int y1 = rooms[r].y + rooms[r].h / 2;
        int x2 = rooms[r + 1].x + rooms[r + 1].w / 2;
        int y2 = rooms[r + 1].y + rooms[r + 1].h / 2;
        while (x1 != x2 || y1 != y2) {
            if (x1 < x2) {
                x1++;
            } else if (x1 > x2) {
                x1--;
            }
            if (y1 < y2) {
                y1++;
            } else if (y1 > y2) {
                y1--;
            }
            // Set corridor tiles to floor
            map[y1 * MAP_SIZE_X + x1].tile = '.';
        }
    }
}

void print_map(map_t *map) {
    for (int y = 0; y < MAP_SIZE_Y; y++) {
        for (int x = 0; x < MAP_SIZE_X; x++) {
            printf("%c", map[y * MAP_SIZE_X + x].tile);
        }
        printf("\n");
    }
}

int main(void) {
    srand(time(NULL));
    map_t *map = malloc(sizeof(map_t) * MAP_SIZE_X * MAP_SIZE_Y);
    room_t rooms[MAX_ROOMS];
    const int num_rooms = rand() % (MAX_ROOMS - 2 + 1) + 2; // Generate random number of rooms (at least 2)
    generate_map(map, rooms, num_rooms);
    print_map(map);
    free(map);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 __fastcall generate_map(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall print_map(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400019BF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[164]; // [rsp+20h] [rbp-B0h] BYREF
  unsigned int v6; // [rsp+C4h] [rbp-Ch]
  void *Block; // [rsp+C8h] [rbp-8h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  Block = malloc(0x2EE0ui64);
  v6 = rand() % 9 + 2;
  generate_map(Block, v5, v6);
  print_map(Block);
  free(Block);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall generate_map(_QWORD, _QWORD, _QWORD);
// 14000193A: using guessed type __int64 __fastcall print_map(_QWORD);
// 140001B10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400019BF: using guessed type char var_B0[164];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>

int main() {
  float total_amount = 0.0, discount = 0.0, net_amount = 0.0, service_tax = 0.0, vat = 0.0, grand_total = 0.0;
  int num_items = 0, i = 0;
  char choice;

  printf("=============================================================\n");
  printf("                  WELCOME TO C CAFE BILLING SYSTEM            \n");
  printf("=============================================================\n");

  do {
    float price = 0.0;
    printf("\nEnter the price of item %d: ", i+1);
    scanf("%f", &price);
    
    // Add the price to the total amount
    total_amount += price;

    // Increment the number of items
    num_items++;

    printf("Do you want to add another item (Y/N)? ");
    scanf(" %c", &choice);
    i++;
  } while (choice == 'y' || choice == 'Y');

  printf("\nTotal amount of the items purchased: %.2f\n", total_amount);

  // Determine the discount based on the total amount
  if (total_amount >= 1000) {
    discount = 0.1 * total_amount;
  } else if (total_amount >= 500) {
    discount = 0.05 * total_amount;
  }

  printf("Discount applied: %.2f\n", discount);

  // Calculate the net amount
  net_amount = total_amount - discount;

  printf("Net amount: %.2f\n", net_amount);

  // Calculate the service tax
  service_tax = 0.14 * net_amount;

  printf("Service tax (14%% of net amount): %.2f\n", service_tax);

  // Calculate the VAT
  vat = 0.05 * net_amount;

  printf("VAT (5%% of net amount): %.2f\n", vat);

  // Calculate the grand total
  grand_total = net_amount + service_tax + vat;

  printf("Grand total: %.2f\n", grand_total);

  printf("\nThank you for dining with us. Please come again!\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  float v8; // [rsp+28h] [rbp-28h] BYREF
  char v9; // [rsp+2Fh] [rbp-21h] BYREF
  float v10; // [rsp+30h] [rbp-20h]
  float v11; // [rsp+34h] [rbp-1Ch]
  float v12; // [rsp+38h] [rbp-18h]
  float v13; // [rsp+3Ch] [rbp-14h]
  int v14; // [rsp+40h] [rbp-10h]
  int v15; // [rsp+44h] [rbp-Ch]
  float v16; // [rsp+48h] [rbp-8h]
  float v17; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v17 = 0.0;
  v16 = 0.0;
  v13 = 0.0;
  v12 = 0.0;
  v11 = 0.0;
  v10 = 0.0;
  v15 = 0;
  v14 = 0;
  printf("=============================================================\n");
  printf("                  WELCOME TO C CAFE BILLING SYSTEM            \n");
  printf("=============================================================\n");
  do
  {
    do
    {
      v8 = 0.0;
      printf("\nEnter the price of item %d: ", (unsigned int)(v14 + 1));
      scanf("%f", &v8);
      v17 = v8 + v17;
      ++v15;
      printf("Do you want to add another item (Y/N)? ");
      scanf(" %c", &v9);
      ++v14;
    }
    while ( v9 == 121 );
  }
  while ( v9 == 89 );
  printf("\nTotal amount of the items purchased: %.2f\n", v17);
  if ( v17 < 1000.0 )
  {
    if ( v17 >= 500.0 )
    {
      v4 = 0.05 * v17;
      v16 = v4;
    }
  }
  else
  {
    v3 = 0.1 * v17;
    v16 = v3;
  }
  printf("Discount applied: %.2f\n", v16);
  v13 = v17 - v16;
  printf("Net amount: %.2f\n", (float)(v17 - v16));
  v5 = 0.14 * v13;
  v12 = v5;
  printf("Service tax (14%% of net amount): %.2f\n", v5);
  v6 = 0.05 * v13;
  v11 = v6;
  printf("VAT (5%% of net amount): %.2f\n", v6);
  v10 = (float)(v13 + v12) + v11;
  printf("Grand total: %.2f\n", v10);
  printf("\nThank you for dining with us. Please come again!\n");
  return 0;
}
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type float var_28;

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System process viewer ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <ctype.h>

void printProcessInfo(int pid, char* state, char* name, char* command) {
    printf("%d  %s  %s\n", pid, state, name);
    printf("%s\n", command);
    printf("------------------------\n");
}

void viewProcesses() {
    DIR* proc = opendir("/proc");
    struct dirent* entry;
    int pid;
    char name[1024], state, command[1024], path[1024], ch;
    FILE* file;

    printf("\nProcess Viewer\n\n");
    printf("PID  STATE  NAME\n");
    printf("------------------------\n");

    while ((entry = readdir(proc)) != NULL) {
        if (isdigit(*entry->d_name)) {
            pid = atoi(entry->d_name);

            sprintf(path, "/proc/%d/stat", pid);
            file = fopen(path, "r");
            fscanf(file, "%d %s %c", &pid, name, &state);
            fclose(file);

            sprintf(path, "/proc/%d/cmdline", pid);
            file = fopen(path, "r");
            ch = getc(file);
            int i = 0;
            while (ch != EOF) {
                if (ch == '\0') {
                    command[i] = ' ';
                }
                else {
                    command[i] = ch;
                }
                ch = getc(file);
                i++;
            }
            command[i] = '\0';
            fclose(file);
            printProcessInfo(pid, &state, name, command);
        }
    }
    closedir(proc);
}

int main() {
    viewProcesses();
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 viewProcesses(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018B1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  viewProcesses();
  return 0;
}
// 14000167A: using guessed type __int64 viewProcesses(void);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=196 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Audio processing ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char input[100];
    int length, choice;

    printf("Welcome to the Voice Modulator!\nPlease enter your input: ");
    fgets(input, sizeof(input), stdin);
    length = strlen(input);
    input[length - 1] = '\0'; // remove newline character

    printf("\nChoose an effect:\n1. Robot\n2. Alien\n3. Echo\n4. Reverse\n\nEnter your choice: ");
    scanf("%d", &choice);

    switch(choice) {
        case 1: // Robot effect
            for(int i=0; i<length; i++) {
                if(input[i] == ' ') {
                    printf(" ");
                } else {
                    printf("%c%d", input[i], rand()%10);
                }
            }
            break;

        case 2: // Alien effect
            for(int i=0; i<length; i++) {
                if(input[i] == ' ') {
                    printf(" ");
                } else {
                    printf("%c*", input[i]+3);
                }
            }
            break;

        case 3: // Echo effect
            for(int i=0; i<length; i++) {
                printf("%c", input[i]);
                if(input[i] != ' ') {
                    for(int j=0; j<5; j++) {
                        printf("%c", input[i]);
                    }
                }
            }
            break;

        case 4: // Reverse effect
            for(int i=length-1; i>=0; i--) {
                printf("%c", input[i]);
            }
            break;

        default: // Invalid choice
            printf("\nInvalid choice!");
    }

    printf("\n\nThank you for using the Voice Modulator!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl rand();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v4; // eax
  int v6; // [rsp+2Ch] [rbp-84h] BYREF
  char Buffer[104]; // [rsp+30h] [rbp-80h] BYREF
  int v8; // [rsp+98h] [rbp-18h]
  int i; // [rsp+9Ch] [rbp-14h]
  int k; // [rsp+A0h] [rbp-10h]
  int j; // [rsp+A4h] [rbp-Ch]
  int n; // [rsp+A8h] [rbp-8h]
  int m; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Voice Modulator!\nPlease enter your input: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  v8 = strlen(Buffer);
  Buffer[v8 - 1] = 0;
  printf("\nChoose an effect:\n1. Robot\n2. Alien\n3. Echo\n4. Reverse\n\nEnter your choice: ");
  scanf("%d", &v6);
  if ( v6 == 4 )
  {
    for ( i = v8 - 1; i >= 0; --i )
      printf("%c", (unsigned int)Buffer[i]);
  }
  else
  {
    if ( v6 > 4 )
    {
LABEL_33:
      printf("\nInvalid choice!");
      goto LABEL_34;
    }
    switch ( v6 )
    {
      case 3:
        for ( j = 0; j < v8; ++j )
        {
          printf("%c", (unsigned int)Buffer[j]);
          if ( Buffer[j] != 32 )
          {
            for ( k = 0; k <= 4; ++k )
              printf("%c", (unsigned int)Buffer[j]);
          }
        }
        break;
      case 1:
        for ( m = 0; m < v8; ++m )
        {
          if ( Buffer[m] == 32 )
          {
            printf(" ");
          }
          else
          {
            v4 = rand();
            printf("%c%d", (unsigned int)Buffer[m], (unsigned int)(v4 % 10));
          }
        }
        break;
      case 2:
        for ( n = 0; n < v8; ++n )
        {
          if ( Buffer[n] == 32 )
            printf(" ");
          else
            printf("%c*", (unsigned int)(Buffer[n] + 3));
        }
        break;
      default:
        goto LABEL_33;
    }
  }
LABEL_34:
  printf("\n\nThank you for using the Voice Modulator!\n");
  return 0;
}
// 14000168E: conditional instruction was optimized away because %var_84.4<3
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Buffer[104];

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: statistical
#include<stdio.h>

int main()
{
   int rows, i, j, k, l;
   printf("Enter the number of rows: ");
   scanf("%d",&rows);
   
   if(rows < 5){
      printf("Error! Please enter a value greater than or equal to 5.");
      return 0;
   }
   
   int A = rows/2 + 1, B = rows/2;
   
   for(i=1;i<=rows;i++){
        
        if(i==A){
            for(j=1;j<=i;j++){
                printf("* ");
            }
        }
        else if(i>=1 && i<A){
            for(j=1;j<=i;j++){
                printf("* ");
            }
            for(k=1;k<=((rows-2*i)/2);k++){
                printf("C ");
            }
            for(l=1;l<=i;l++){
                printf("* ");
            }
        }
        else{
            for(j=i;j<=rows;j++){
                printf("* ");
            }
            for(k=1;k<=((2*B-rows+2*i)/2);k++){
                printf("C ");
            }
            for(l=i;l<=rows;l++){
                printf("* ");
            }
        }
        
        printf("\n");
   }

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-1Ch] BYREF
  int v5; // [rsp+28h] [rbp-18h]
  int v6; // [rsp+2Ch] [rbp-14h]
  int m; // [rsp+30h] [rbp-10h]
  int k; // [rsp+34h] [rbp-Ch]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of rows: ");
  scanf("%d", &v4);
  if ( v4 > 4 )
  {
    v6 = v4 / 2 + 1;
    v5 = v4 / 2;
    for ( i = 1; i <= v4; ++i )
    {
      if ( i == v6 )
      {
        for ( j = 1; j <= i; ++j )
          printf("* ");
      }
      else if ( i <= 0 || i >= v6 )
      {
        for ( j = i; j <= v4; ++j )
          printf("* ");
        for ( k = 1; k <= (2 * v5 - v4 + 2 * i) / 2; ++k )
          printf("C ");
        for ( m = i; m <= v4; ++m )
          printf("* ");
      }
      else
      {
        for ( j = 1; j <= i; ++j )
          printf("* ");
        for ( k = 1; k <= (v4 - 2 * i) / 2; ++k )
          printf("C ");
        for ( m = 1; m <= i; ++m )
          printf("* ");
      }
      printf("\n");
    }
    return 0;
  }
  else
  {
    printf("Error! Please enter a value greater than or equal to 5.");
    return 0;
  }
}
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to Morse code conversion ; Style: scientific
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

void text_to_morse(char [], char []);

int main() {
    char text[MAX_SIZE];
    char morse[MAX_SIZE];

    printf("Enter text to convert to Morse code:\n");
    fgets(text, MAX_SIZE, stdin);
    text[strcspn(text, "\n")] = '\0'; // remove trailing newline character

    text_to_morse(text, morse);
    
    printf("\nMorse code: %s\n", morse);
    return 0;
}

void text_to_morse(char text[], char morse[]) {
    const char *morse_code[] = {".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....",
                                "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.",
                                "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-",
                                "-.--", "--..", "/", ".----", "..---", "...--", "....-",
                                ".....", "-....", "--...", "---..", "----.", "-----"};

    for(int i = 0, j = 0; i < strlen(text); i++) {
        if(isalpha(text[i])) {
            char c = tolower(text[i]);
            morse[j++] = morse_code[c-'a'][0];
            morse[j++] = morse_code[c-'a'][1];
            morse[j++] = morse_code[c-'a'][2];
        } else if(isdigit(text[i])) {
            morse[j++] = morse_code[text[i]-'0'+25][0];
            morse[j++] = morse_code[text[i]-'0'+25][1];
            morse[j++] = morse_code[text[i]-'0'+25][2];
        } else if(text[i] == ' ') {
            morse[j++] = '/';
        }
    }
    morse[strlen(morse)] = '\0';
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall text_to_morse(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char v5[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[112]; // [rsp+90h] [rbp+10h] BYREF

  _main(argc, argv, envp);
  printf("Enter text to convert to Morse code:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  text_to_morse(Buffer, v5);
  printf("\nMorse code: %s\n", v5);
  return 0;
}
// 140001626: using guessed type __int64 __fastcall text_to_morse(_QWORD, _QWORD);
// 1400019B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[112];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mortgage Calculator ; Style: enthusiastic
#include <stdio.h>

int main() {
  double principle, rate, time, interest, total;
  
  printf("Welcome to the Mortgage Calculator!\n");
  printf("Let's calculate your monthly mortgage payment.\n\n");

  // Get user input
  printf("Enter the principle (in dollars): ");
  scanf("%lf", &principle);

  printf("Enter the interest rate (in percentage): ");
  scanf("%lf", &rate);

  printf("Enter the time period (in years): ");
  scanf("%lf", &time);

  // Calculate the monthly interest rate
  rate /= 1200;

  // Calculate the monthly mortgage payment
  interest = principle * rate * time;
  total = interest + principle;
  double monthly_payment = total / (time * 12);

  // Display the results
  printf("\nYour monthly mortgage payment is: $%.2lf\n", monthly_payment);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+20h] [rbp-30h] BYREF
  double v5; // [rsp+28h] [rbp-28h] BYREF
  double v6; // [rsp+30h] [rbp-20h] BYREF
  double v7; // [rsp+38h] [rbp-18h]
  double v8; // [rsp+40h] [rbp-10h]
  double v9; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to the Mortgage Calculator!\n");
  printf("Let's calculate your monthly mortgage payment.\n\n");
  printf("Enter the principle (in dollars): ");
  scanf("%lf", &v6);
  printf("Enter the interest rate (in percentage): ");
  scanf("%lf", &v5);
  printf("Enter the time period (in years): ");
  scanf("%lf", &v4);
  v5 = v5 / 1200.0;
  v9 = v4 * (v6 * v5);
  v8 = v6 + v9;
  v7 = (v6 + v9) / (v4 * 12.0);
  printf("\nYour monthly mortgage payment is: $%.2lf\n", v7);
  return 0;
}
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File system simulation ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILENAME_LENGTH 16
#define MAX_FILE_SIZE 1024

struct file {
    char name[MAX_FILENAME_LENGTH];
    char data[MAX_FILE_SIZE];
    int size;
    int deleted;
};

struct directory {
    char name[MAX_FILENAME_LENGTH];
    struct file files[10];
    int num_files;
};

struct filesystem {
    struct directory root;
    int num_directories;
};

void create_directory(struct filesystem *fs, char *name) {
    if (fs->num_directories == 10) {
        printf("The filesystem is full.\n");
        return;
    }

    struct directory d = {0};
    strcpy(d.name, name);
    fs->root.num_files++;
    fs->num_directories++;
}

void create_file(struct directory *d, char *name, char *data, int size) {
    if (d->num_files == 10) {
        printf("The directory is full.\n");
        return;
    }

    struct file f = {0};
    strcpy(f.name, name);
    memcpy(f.data, data, size);
    f.size = size;
    d->files[d->num_files] = f;
    d->num_files++;
}

void delete_file(struct directory *d, char *name) {
    for (int i = 0; i < d->num_files; i++) {
        if (strcmp(d->files[i].name, name) == 0) {
            d->files[i].deleted = 1;
            printf("File %s deleted.\n", name);
            return;
        }
    }

    printf("File %s not found.\n", name);
}

void list_files(struct directory *d) {
    printf("Listing files in directory %s:\n", d->name);
    for (int i = 0; i < d->num_files; i++) {
        if (!d->files[i].deleted) {
            printf("%s\n", d->files[i].name);
        }
    }
}

void list_directories(struct filesystem *fs) {
    printf("Listing directories:\n");
    printf("%s\n", fs->root.name);
    for (int i = 0; i < fs->num_directories; i++) {
        printf("%s\n", fs->root.name);
    }
}

int main() {
    struct filesystem fs = {0};
    strcpy(fs.root.name, "root");

    create_directory(&fs, "home");
    create_directory(&fs, "var");

    struct directory *home = &fs.root;
    while (strcmp(home->name, "home") != 0) {
        home++;
    }

    create_file(home, "hello.txt", "Hello, world!", 13);

    list_files(home);

    delete_file(home, "hello.txt");

    list_files(home);

    list_directories(&fs);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall create_directory(_QWORD, _QWORD); // weak
__int64 __fastcall create_file(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall delete_file(_QWORD, _QWORD); // weak
__int64 __fastcall list_files(_QWORD); // weak
__int64 __fastcall list_directories(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl memset(void *, int Val, size_t Size);


//----- (000000014000192F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[10504]; // [rsp+20h] [rbp-60h] BYREF
  char *Str1; // [rsp+2928h] [rbp+28A8h]

  _main(argc, argv, envp);
  memset(v4, 0, sizeof(v4));
  strcpy(v4, "root");
  create_directory(v4, "home");
  create_directory(v4, "var");
  for ( Str1 = v4; strcmp(Str1, "home"); Str1 += 10500 )
    ;
  create_file(Str1, "hello.txt", "Hello, world!", 13i64);
  list_files(Str1);
  delete_file(Str1, "hello.txt");
  list_files(Str1);
  list_directories(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall create_directory(_QWORD, _QWORD);
// 140001647: using guessed type __int64 __fastcall create_file(_QWORD, _QWORD, _QWORD, _QWORD);
// 14000178E: using guessed type __int64 __fastcall delete_file(_QWORD, _QWORD);
// 140001836: using guessed type __int64 __fastcall list_files(_QWORD);
// 1400018C4: using guessed type __int64 __fastcall list_directories(_QWORD);
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Subnet Calculator ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MAX_BITS 32

typedef struct {
    unsigned long address;
    unsigned int prefix_length;
    unsigned long subnet_mask;
    unsigned long network_address;
    unsigned long broadcast_address;
} subnet_t;

int main() {
    subnet_t subnet;

    printf("Enter IP address: ");
    scanf("%lu", &subnet.address);

    printf("Enter prefix length: ");
    scanf("%u", &subnet.prefix_length);

    subnet.subnet_mask = pow(2, subnet.prefix_length) - 1;
    subnet.subnet_mask <<= (MAX_BITS - subnet.prefix_length);

    subnet.network_address = subnet.address & subnet.subnet_mask;
    subnet.broadcast_address = subnet.network_address | ~subnet.subnet_mask;

    printf("\n\nSubnet mask: %lu.%lu.%lu.%lu\n",
           (subnet.subnet_mask >> 24) & 0xFF,
           (subnet.subnet_mask >> 16) & 0xFF,
           (subnet.subnet_mask >> 8) & 0xFF,
           (subnet.subnet_mask) & 0xFF);
    
    printf("Network Address: %lu.%lu.%lu.%lu\n",
           (subnet.network_address >> 24) & 0xFF,
           (subnet.network_address >> 16) & 0xFF,
           (subnet.network_address >> 8) & 0xFF,
           (subnet.network_address) & 0xFF);

    printf("Broadcast Address: %lu.%lu.%lu.%lu\n",
           (subnet.broadcast_address >> 24) & 0xFF,
           (subnet.broadcast_address >> 16) & 0xFF,
           (subnet.broadcast_address >> 8) & 0xFF,
           (subnet.broadcast_address) & 0xFF);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // rax
  __int64 v5; // [rsp+20h] [rbp-30h]
  __int64 v6; // [rsp+20h] [rbp-30h]
  int v7; // [rsp+30h] [rbp-20h] BYREF
  int v8; // [rsp+34h] [rbp-1Ch] BYREF
  unsigned int v9; // [rsp+38h] [rbp-18h]
  unsigned int v10; // [rsp+3Ch] [rbp-14h]
  unsigned int v11; // [rsp+40h] [rbp-10h]

  _main(argc, argv, envp);
  printf("Enter IP address: ");
  scanf("%lu", &v7);
  printf("Enter prefix length: ");
  scanf("%u", &v8);
  v3 = pow(2.0, (double)v8);
  v9 = (int)(v3 - 1.0) << (32 - v8);
  v10 = v7 & v9;
  v11 = v7 & v9 | ~v9;
  printf("\n\nSubnet mask: %lu.%lu.%lu.%lu\n", HIBYTE(v9), BYTE2(v9), BYTE1(v9), (unsigned __int8)v9);
  LODWORD(v5) = (unsigned __int8)v10;
  printf("Network Address: %lu.%lu.%lu.%lu\n", HIBYTE(v10), BYTE2(v10), BYTE1(v10), v5);
  LODWORD(v6) = (unsigned __int8)v11;
  printf("Broadcast Address: %lu.%lu.%lu.%lu\n", HIBYTE(v11), BYTE2(v11), BYTE1(v11), v6);
  return 0;
}
// 14000173B: variable 'v5' is possibly undefined
// 140001775: variable 'v6' is possibly undefined
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <omp.h>

// Parameters
#define L 100   // Road length
#define V_MAX 5 // Maximum car speed
#define P 0.3   // Probability of a car being present
#define T 100   // Number of simulation time steps

// Global variables
int x[L];       // Road cells
int v[L];       // Car speeds
int t = 0;      // Simulation time
int total_cars = 0; // Total number of cars in the simulation

// Initializes the road with cars and empty spaces
void init_road() {
    srand(time(NULL));
    for(int i=0; i<L; i++) {
        if((double)rand()/(double)RAND_MAX < P) {
            x[i] = 1;
            total_cars++;
            v[i] = rand() % V_MAX + 1;
        } else {
            x[i] = 0;
            v[i] = 0;
        }
    }
}

// Prints the current state of the road
void print_road() {
    for(int i=0; i<L; i++) {
        if(x[i] == 0) {
            putchar('.');
        } else {
            putchar('*');
        }
    }
    putchar('\n');
}

// Advances the simulation by one time step
void advance() {
    // Acceleration
    #pragma omp parallel for
    for(int i=0; i<L; i++) {
        if(x[i] == 1 && v[i] < V_MAX) {
            v[i]++;
        }
    }

    // Deceleration
    #pragma omp parallel for
    for(int i=0; i<L; i++) {
        int d = 1;
        while(d <= v[i]) {
            if(x[(i + d) % L] != 0) {
                if(d - 1 < v[i]) {
                    v[i] = d - 1;
                }
                break;
            }
            d++;
        }
    }

    // Randomization
    #pragma omp parallel for
    for(int i=0; i<L; i++) {
        if(x[i] == 1 && v[i] > 0 && (double)rand()/(double)RAND_MAX < 0.5) {
            v[i]--;
        }
    }

    // Movement
    #pragma omp parallel for
    for(int i=0; i<L; i++) {
        if(x[i] == 1) {
            x[i] = 0;
            x[(i + v[i]) % L] = 1;
        }
    }

    t++; // Increase simulation time
}

int main() {
    init_road(); // Initialize road

    // Run simulation
    while(t < T) {
        printf("Time: %d\n", t);
        print_road();
        advance();
    }

    printf("Simulation complete\n");
    printf("Total number of cars: %d\n", total_cars);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 init_road(void); // weak
__int64 print_road(void); // weak
__int64 advance(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

int t; // weak
int total_cars; // weak


//----- (00000001400019C5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  init_road();
  while ( t <= 99 )
  {
    printf("Time: %d\n", (unsigned int)t);
    print_road();
    advance();
  }
  printf("Simulation complete\n");
  printf("Total number of cars: %d\n", (unsigned int)total_cars);
  return 0;
}
// 1400015B0: using guessed type __int64 init_road(void);
// 1400016B9: using guessed type __int64 print_road(void);
// 140001716: using guessed type __int64 advance(void);
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F370: using guessed type int t;
// 14000F374: using guessed type int total_cars;

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
