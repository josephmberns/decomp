`#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <stdbool.h>

typedef double Fp;
typedef struct { Fp x, y, r; } Circle;

Circle circles[] = {
    { 1.6417233788,  1.6121789534, 0.0848270516},
    {-1.4944608174,  1.2077959613, 1.1039549836},
    { 0.6110294452, -0.6907087527, 0.9089162485},
    { 0.3844862411,  0.2923344616, 0.2375743054},
    {-0.2495892950, -0.3832854473, 1.0845181219},
    { 1.7813504266,  1.6178237031, 0.8162655711},
    {-0.1985249206, -0.8343333301, 0.0538864941},
    {-1.7011985145, -0.1263820964, 0.4776976918},
    {-0.4319462812,  1.4104420482, 0.7886291537},
    { 0.2178372997, -0.9499557344, 0.0357871187},
    {-0.6294854565, -1.3078893852, 0.7653357688},
    { 1.7952608455,  0.6281269104, 0.2727652452},
    { 1.4168575317,  1.0683357171, 1.1016025378},
    { 1.4637371396,  0.9463877418, 1.1846214562},
    {-0.5263668798,  1.7315156631, 1.4428514068},
    {-1.2197352481,  0.9144146579, 1.0727263474},
    {-0.1389358881,  0.1092805780, 0.7350208828},
    { 1.5293954595,  0.0030278255, 1.2472867347},
    {-0.5258728625,  1.3782633069, 1.3495508831},
    {-0.1403562064,  0.2437382535, 1.3804956588},
    { 0.8055826339, -0.0482092025, 0.3327165165},
    {-0.6311979224,  0.7184578971, 0.2491045282},
    { 1.4685857879, -0.8347049536, 1.3670667538},
    {-0.6855727502,  1.6465021616, 1.0593087096},
    { 0.0152957411,  0.0638919221, 0.9771215985}};

const size_t n_circles = sizeof(circles) / sizeof(Circle);

static inline Fp min(const Fp a, const Fp b) { return a <= b ? a : b; }

static inline Fp max(const Fp a, const Fp b) { return a >= b ? a : b; }

static inline Fp sq(const Fp a) { return a * a; }

// Return an uniform random value in [a, b).
static inline double uniform(const double a, const double b) {
    const double r01 = rand() / (double)RAND_MAX;
    return a + (b - a) * r01;
}

static inline bool is_inside_circles(const Fp x, const Fp y) {
    for (size_t i = 0; i < n_circles; i++)
        if (sq(x - circles[i].x) + sq(y - circles[i].y) < circles[i].r)
            return true;
    return false;
}

int main() {
    // Initialize the bounding box (bbox) of the circles.
    Fp x_min = INFINITY, x_max = -INFINITY;
    Fp y_min = x_min, y_max = x_max;

    // Compute the bounding box of the circles.
    for (size_t i = 0; i < n_circles; i++) {
        Circle *c = &circles[i];
        x_min = min(x_min, c->x - c->r);
        x_max = max(x_max, c->x + c->r);
        y_min = min(y_min, c->y - c->r);
        y_max = max(y_max, c->y + c->r);

        c->r *= c->r; // Square the radii to speed up testing.
    }

    const Fp bbox_area = (x_max - x_min) * (y_max - y_min);

    // Montecarlo sampling.
    srand(time(0));
    size_t to_try = 1U << 16;
    size_t n_tries = 0;
    size_t n_hits = 0;

    while (true) {
        n_hits += is_inside_circles(uniform(x_min, x_max),
                                    uniform(y_min, y_max));
        n_tries++;

        if (n_tries == to_try) {
            const Fp area = bbox_area * n_hits / n_tries;
            const Fp r = (Fp)n_hits / n_tries;
            const Fp s = area * sqrt(r * (1 - r) / n_tries);
            printf("%.4f +/- %.4f (%zd samples)\n", area, s, n_tries);
            if (s * 3 <= 1e-3) // Stop at 3 sigmas.
                break;
            to_try *= 2;
        }
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d1c(void);
int64_t function_100003d64(void);
int64_t function_100003dac(void);
int64_t function_100003eb4(int64_t a1);
int64_t function_100003f04(void);
int32_t function_100003f20(char * format, ...);
int32_t function_100003f2c(void);
void function_100003f38(int32_t seed);
int32_t function_100003f44(int32_t * timer);

// --------------------- Global Variables ---------------------

float64_t g1 = 0.001; // 0x100003f50
float64_t g2 = -INFINITY; // 0x100003f58
float64_t g3 = INFINITY; // 0x100003f60
float64_t * g4 = (float64_t *)0x3ffa447fbbd064d8; // 0x100008000
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003a84 - 0x100003d1c
int64_t entry_point(void) {
    // 0x100003a84
    function_100003d1c();
    function_100003d64();
    function_100003d1c();
    function_100003d64();
    float64_t v1 = *(float64_t *)((int64_t)&g4 + 16); // 0x100003b78
    *(float64_t *)((int64_t)&g4 + 16) = v1 * v1;
    int64_t v2 = 1; // 0x100003b94
    function_100003d1c();
    float64_t v3 = (int64_t)g3;
    function_100003d64();
    float64_t v4 = (int64_t)g2;
    function_100003d1c();
    float64_t v5 = (int64_t)g3;
    function_100003d64();
    float64_t v6 = (int64_t)g2;
    float64_t * v7 = (float64_t *)(24 * v2 + (int64_t)&g4 + 16); // 0x100003b78
    float64_t v8 = *v7; // 0x100003b78
    *v7 = v8 * v8;
    v2++;
    while (v2 != 25) {
        // 0x100003ad8
        function_100003d1c();
        v3 = (int64_t)v3;
        function_100003d64();
        v4 = (int64_t)v4;
        function_100003d1c();
        v5 = (int64_t)v5;
        function_100003d64();
        v6 = (int64_t)v6;
        v7 = (float64_t *)(24 * v2 + (int64_t)&g4 + 16);
        v8 = *v7;
        *v7 = v8 * v8;
        v2++;
    }
    float64_t v9 = (v4 - v3) * (v6 - v5); // 0x100003bb8
    _srand(_time(NULL));
    float64_t v10 = 0.0; // 0x100003bdc
    float64_t v11 = 0.0; // 0x100003bdc
    int64_t v12 = 0x10000; // 0x100003bdc
    int64_t v13 = &g5; // 0x100003bdc
    while (true) {
        int64_t v14 = v12;
        float64_t v15 = v11;
        function_100003eb4(function_100003eb4(v13));
        uint64_t v16 = function_100003dac(); // 0x100003c04
        int64_t v17 = (int64_t)v10 + 1; // 0x100003c20
        v12 = v14;
        v13 = v16;
        if (v17 == v14) {
            float64_t v18 = (float64_t)(v16 % 2 + (int64_t)v15) / (float64_t)v17; // 0x100003c70
            float64_t v19 = sqrt(v18 * (1.0 - v18) / (float64_t)v17); // 0x100003c9c
            int64_t v20; // 0x100003a84
            int128_t v21; // 0x100003a84
            int32_t v22 = _printf("%.4f +/- %.4f (%zd samples)\n", (float64_t)(int64_t)v21, (float64_t)(int64_t)v21, v20); // 0x100003ccc
            float64_t v23 = 3.0 * v9 * (float64_t)(v16 % 2 + (int64_t)v15) / (float64_t)v17 * v19; // 0x100003cd8
            float64_t v24 = g1; // 0x100003ce0
            if (v23 <= v24 != v23 != v24) {
                // break -> 0x100003d0c
                break;
            }
            // 0x100003cf8
            v12 = 2 * v14;
            v13 = v22;
        }
        // 0x100003d08
        v10 = v17;
        v11 = v16 % 2 + (int64_t)v15;
    }
    // 0x100003d0c
    return 0;
}

// Address range: 0x100003d1c - 0x100003d64
int64_t function_100003d1c(void) {
    // 0x100003d1c
    int64_t result; // 0x100003d1c
    return result;
}

// Address range: 0x100003d64 - 0x100003dac
int64_t function_100003d64(void) {
    // 0x100003d64
    int64_t result; // 0x100003d64
    return result;
}

// Address range: 0x100003dac - 0x100003eb4
int64_t function_100003dac(void) {
    int64_t v1 = 0; // 0x100003e80
    int64_t v2 = 24 * v1; // 0x100003dec
    float64_t v3 = *(float64_t *)(v2 + (int64_t)&g4); // 0x100003dfc
    function_100003f04();
    float64_t v4 = *(float64_t *)(v2 + (int64_t)&g4 + 8); // 0x100003e24
    function_100003f04();
    float64_t v5 = *(float64_t *)(v2 + (int64_t)&g4 + 16); // 0x100003e50
    int64_t result = 1; // 0x100003e54
    float64_t v6; // 0x100003dac
    while (v6 - v3 + v6 - v4 <= v5) {
        // 0x100003dc8
        v1++;
        result = 0;
        if (v1 >= 25) {
            // break -> 0x100003ea0
            break;
        }
        v2 = 24 * v1;
        v3 = *(float64_t *)(v2 + (int64_t)&g4);
        function_100003f04();
        v4 = *(float64_t *)(v2 + (int64_t)&g4 + 8);
        function_100003f04();
        v5 = *(float64_t *)(v2 + (int64_t)&g4 + 16);
        result = 1;
    }
    // 0x100003ea0
    return result;
}

// Address range: 0x100003eb4 - 0x100003f04
int64_t function_100003eb4(int64_t a1) {
    // 0x100003eb4
    return _rand();
}

// Address range: 0x100003f04 - 0x100003f20
int64_t function_100003f04(void) {
    // 0x100003f04
    int64_t result; // 0x100003f04
    return result;
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(char * format, ...) {
    // 0x100003f20
    return _printf(format);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(void) {
    // 0x100003f2c
    return _rand();
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int32_t seed) {
    // 0x100003f38
    _srand(seed);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(int32_t * timer) {
    // 0x100003f44
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

typedef struct {
    uint16_t year;
    uint8_t month;
    uint8_t day;
} Date;

bool leap(uint16_t year) {
    return year%4==0 && (year%100!=0 || year%400==0);
}

const char *weekday(Date date) {
    static const uint8_t leapdoom[] = {4,1,7,4,2,6,4,1,5,3,7,5};
    static const uint8_t normdoom[] = {3,7,7,4,2,6,4,1,5,3,7,5};
    static const char *days[] = {
        "Sunday", "Monday", "Tuesday", "Wednesday",
        "Thursday", "Friday", "Saturday"
    };

    unsigned c = date.year/100, r = date.year%100;
    unsigned s = r/12, t = r%12;

    unsigned c_anchor = (5 * (c%4) + 2) % 7;
    unsigned doom = (s + t + (t/4) + c_anchor) % 7;
    unsigned anchor = (leap(date.year) ? leapdoom : normdoom)[date.month-1];
    return days[(doom+date.day-anchor+7)%7];
}

int main(void) {
    const char *past = "was", *future = "will be";
    const char *months[] = { "",
        "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    };

    const Date dates[] = {
        {1800,1,6}, {1875,3,29}, {1915,12,7}, {1970,12,23}, {2043,5,14},
        {2077,2,12}, {2101,4,2}
    };

    int i;
    for (i=0; i < sizeof(dates)/sizeof(Date); i++) {
        printf("%s %d, %d %s on a %s.\n",
            months[dates[i].month], dates[i].day, dates[i].year,
            dates[i].year > 2021 ? future : past,
            weekday(dates[i]));
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b04(void);
int64_t function_100003ba4(int32_t a1);
int64_t function_100003e8c(int64_t a1);
int64_t * function_100003e98(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003ea4(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x104060204070104; // 0x100003eb0
int64_t g2 = 0x104060204070703; // 0x100003ebc
float128_t g3 = 6.30259672903973202393650155816711604e-169L; // 0x100003ec8
int64_t g4 = 0x10000000003ee4; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b04 - 0x100003ba4
int64_t function_100003b04(void) {
    // 0x100003b04
    int64_t v1; // 0x100003b04
    uint16_t v2 = (int16_t)v1;
    if (4 * v2 / 4 != v2) {
        // 0x100003b94
        return 0;
    }
    int64_t result = 1; // 0x100003b5c
    if (v2 % 100 == 0) {
        // 0x100003b64
        result = v2 % 400 == 0;
    }
    // 0x100003b94
    return result;
}

// Address range: 0x100003ba4 - 0x100003ce0
int64_t function_100003ba4(int32_t a1) {
    uint16_t v1 = (int16_t)a1;
    uint16_t v2 = v1 % 100;
    uint16_t v3 = v2 % 12;
    uint64_t v4 = function_100003b04(); // 0x100003c70
    int64_t v5 = v4 % 2 == 0 ? (int64_t)&g2 : (int64_t)&g1; // 0x100003c90
    int32_t v6; // 0x100003ba4
    unsigned char v7 = *(char *)(v5 + (int64_t)(v6 % 256 - 1)); // 0x100003c9c
    int64_t result = *(int64_t *)((int64_t)(8 * ((((5 * ((int32_t)(v1 / 100) - (int32_t)(4 * v1 / 400)) + 2) % 7 + (int32_t)(v2 / 12 + v3 + v3 / 4)) % 7 + 7 + (uint32_t)v6 % 256 - (int32_t)v7) % 7)) + (int64_t)&g4); // 0x100003cd0
    return result;
}

// Address range: 0x100003ce0 - 0x100003e8c
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003cf8
    int64_t v2; // bp-144, 0x100003ce0
    _memcpy(&v2, (int64_t *)")?", 104);
    int64_t v3 = (float64_t)g3; // bp-176, 0x100003d40
    int32_t v4; // 0x100003e3c
    for (int64_t i = 0; i < 7; i++) {
        // 0x100003d68
        function_100003ba4(*(int32_t *)(4 * i + (int64_t)&v3));
        int64_t v5; // 0x100003ce0
        v4 = _printf("%s %d, %d %s on a %s.\n", ")?", 104, v5, (char *)v5, (char *)v5);
    }
    // 0x100003e54
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e74
        ___stack_chk_fail((int64_t)v4);
    }
    // 0x100003e78
    return 0;
}

// Address range: 0x100003e8c - 0x100003e98
int64_t function_100003e8c(int64_t a1) {
    // 0x100003e8c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e98
    return _memcpy(dest, src, n);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(char * format, ...) {
    // 0x100003ea4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include<string.h>
#include<stdio.h>

int main(int argc,char** argv)
{
    int i,len;
    char reference;

    if(argc>2){
        printf("Usage : %s <Test String>\n",argv[0]);
        return 0;
    }

    if(argc==1||strlen(argv[1])==1){
        printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n",argc==1?"":argv[1],argc==1?0:(int)strlen(argv[1]));
        return 0;
    }

    reference = argv[1][0];
    len = strlen(argv[1]);

    for(i=1;i<len;i++){
        if(argv[1][i]!=reference){
            printf("Input string : \"%s\"\nLength : %d\nFirst different character : \"%c\"(0x%x) at position : %d\n",argv[1],len,argv[1][i],argv[1][i],i+1);
            return 0;
        }
    }

    printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n",argv[1],len);

    return 0;

}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003edc(char * format, ...);
int32_t function_100003ee8(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c8c - 0x100003edc
int64_t entry_point(void) {
    // 0x100003c8c
    int64_t v1; // 0x100003c8c
    int32_t v2 = v1; // 0x100003c9c
    int32_t v3 = v2 - 2; // 0x100003ca8
    if (v3 != 0 && v3 < 0 == (1 - v2 & v2) < 0) {
        // 0x100003cb8
        _printf("Usage : %s <Test String>\n", (char *)v1);
        // 0x100003ecc
        return 0;
    }
    if (v2 == 1) {
        // 0x100003d80
        _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n", (char *)v1, v1);
        // 0x100003ecc
        return 0;
    }
    int64_t * v4 = (int64_t *)(v1 + 8); // 0x100003cf4
    int32_t v5 = _strlen((char *)*v4); // 0x100003cf8
    char * v6 = (char *)*v4;
    if (v5 == 1) {
        // 0x100003d68
        _strlen(v6);
        // 0x100003d80
        _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n", (char *)v1, v1);
        // 0x100003ecc
        return 0;
    }
    int32_t v7 = _strlen(v6); // 0x100003dc4
    int32_t v8 = 1 - v7; // 0x100003de4
    if (v8 < 0 == (v8 & v7) < 0) {
        // 0x100003e9c
        _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n", (char *)v1, v1);
        // 0x100003ecc
        return 0;
    }
    int32_t v9 = 1; // 0x100003e90
    while (*v6 == *(char *)(*v4 + (int64_t)v9)) {
        // 0x100003ddc
        v9++;
        int32_t v10 = v9 - v7; // 0x100003de4
        if (v10 < 0 == ((v10 ^ v9) & (v9 ^ v7)) < 0) {
            // 0x100003e9c
            _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n", (char *)v1, v1);
            // 0x100003ecc
            return 0;
        }
    }
    // 0x100003e18
    _printf("Input string : \"%s\"\nLength : %d\nFirst different character : \"%c\"(0x%x) at position : %d\n", (char *)v1, v1, (char)v1, (int32_t)v1, v1);
    // 0x100003ecc
    return 0;
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(char * format, ...) {
    // 0x100003edc
    return _printf(format);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * s) {
    // 0x100003ee8
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>

#define BUF_SIZE ( 256 )

char *get_nth_line( FILE *f, int line_no )
{
    char   buf[ BUF_SIZE ];
    size_t curr_alloc = BUF_SIZE, curr_ofs = 0;
    char   *line      = malloc( BUF_SIZE );
    int    in_line    = line_no == 1;
    size_t bytes_read;

    /* Illegal to ask for a line before the first one. */
    if ( line_no < 1 )
        return NULL;

    /* Handle out-of-memory by returning NULL */
    if ( !line )
        return NULL;

    /* Scan the file looking for newlines */
    while ( line_no &&
            ( bytes_read = fread( buf, 1, BUF_SIZE, f ) ) > 0 )
    {
        int i;

        for ( i = 0 ; i < bytes_read ; i++ )
        {
            if ( in_line )
            {
                if ( curr_ofs >= curr_alloc )
                {
                    curr_alloc <<= 1;
                    line = realloc( line, curr_alloc );

                    if ( !line )    /* out of memory? */
                        return NULL;
                }
                line[ curr_ofs++ ] = buf[i];
            }

            if ( buf[i] == '\n' )
            {
                line_no--;

                if ( line_no == 1 )
                    in_line = 1;

                if ( line_no == 0 )
                    break;
            }
        }
    }

    /* Didn't find the line? */
    if ( line_no != 0 )
    {
        free( line );
        return NULL;
    }

    /* Resize allocated buffer to what's exactly needed by the string
       and the terminating NUL character.  Note that this code *keeps*
       the terminating newline as part of the string.
     */
    line = realloc( line, curr_ofs + 1 );

    if ( !line ) /* out of memory? */
        return NULL;

    /* Add the terminating NUL. */
    line[ curr_ofs ] = '\0';

    /* Return the line.  Caller is responsible for freeing it. */
    return line;
}


/* Test program.  Prints out the 7th line of input from stdin, if any */
int main( int argc, char *argv[] )
{
    char *line7 = get_nth_line( stdin, 7 );

    if ( line7 )
    {
        printf("The 7th line of input was:\n%s\n", line7 );
        free( line7 );
    } else
    {
        printf("Did not find the 7th line of input.  Reason:  ");
        if ( feof( stdin ) )
            puts("End of file reached.");
        else if ( ferror( stdin ) )
            puts("Error reading input.");
        else
            puts("Out of memory.");
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003af4(void);
int64_t function_100003eac(void);
int32_t function_100003eb8(struct _IO_FILE * stream);
int32_t function_100003ec4(struct _IO_FILE * stream);
int32_t function_100003ed0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void function_100003edc(int64_t * ptr);
int64_t * function_100003ee8(int32_t size);
int32_t function_100003ef4(char * format, ...);
int32_t function_100003f00(char * s);
int64_t * function_100003f0c(int64_t * ptr, int32_t size);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _feof(struct _IO_FILE * a1);
int32_t _ferror(struct _IO_FILE * a1);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003af4 - 0x100003db0
int64_t function_100003af4(void) {
    // 0x100003af4
    int64_t v1; // 0x100003af4
    int32_t v2 = v1; // 0x100003b18
    int64_t * v3 = _malloc(256); // 0x100003b28
    int64_t result = 0; // 0x100003b50
    if (v2 < 1 == (v2 & -v2) < 0) {
        // 0x100003b60
        result = 0;
        if (v3 != NULL) {
            int64_t v4 = (int64_t)v3; // 0x100003b28
            int64_t v5 = 0; // 0x100003b94
            int64_t v6 = v4; // 0x100003b94
            if (v2 == 0) {
              lab_0x100003d24_2:;
                int64_t * v7 = _realloc((int64_t *)v6, (int32_t)v5 + 1); // 0x100003d30
                result = 0;
                if (v7 != NULL) {
                    int64_t v8 = (int64_t)v7; // 0x100003d30
                    *(char *)(v5 + v8) = 0;
                    result = v8;
                }
            } else {
                // 0x100003bc4
                int64_t v9; // bp-296, 0x100003af4
                int64_t v10 = &v9;
                int32_t v11 = v2 == 1;
                int64_t v12 = 0;
                int64_t v13 = 256;
                int32_t v14 = v2;
                int64_t v15 = v4;
                uint32_t v16 = _fread(&v9, 1, 256, (struct _IO_FILE *)v1); // 0x100003bac
                while (v16 != 0) {
                    int32_t v17 = v11; // 0x100003be8
                    int64_t v18 = v15; // 0x100003be8
                    int64_t v19 = v12; // 0x100003be8
                    int64_t v20 = v13; // 0x100003be8
                    int32_t v21 = v14; // 0x100003be8
                    int32_t v22 = v14; // 0x100003be8
                    int64_t v23 = v13; // 0x100003be8
                    int64_t v24 = v12; // 0x100003be8
                    int64_t v25 = v15; // 0x100003be8
                    int32_t v26 = v11; // 0x100003be8
                    if (v16 != 0) {
                        int32_t v27 = v21;
                        int64_t v28 = v20;
                        int64_t v29 = v19;
                        int64_t v30 = v18;
                        int32_t v31 = v17;
                        int64_t v32 = 0;
                        char * v33; // 0x100003af4
                        int64_t v34; // 0x100003af4
                        int64_t v35; // 0x100003af4
                        int64_t v36; // 0x100003af4
                        int64_t v37; // 0x100003af4
                        char * v38; // 0x100003af4
                        int64_t v39; // 0x100003c20
                        int64_t * v40; // 0x100003c30
                        if (v31 == 0) {
                            // 0x100003bf0
                            v33 = (char *)(v32 + v10);
                            v34 = v28;
                            v35 = v29;
                            v37 = v30;
                        } else {
                            // 0x100003c04
                            v39 = v28;
                            v36 = v30;
                            if (v29 >= v28) {
                                // 0x100003c1c
                                v39 = 2 * v28;
                                v40 = _realloc((int64_t *)v30, (int32_t)v39);
                                v36 = (int64_t)v40;
                                result = 0;
                                if (v40 == NULL) {
                                    goto lab_0x100003d70;
                                }
                            }
                            // 0x100003c58
                            v38 = (char *)(v32 + v10);
                            *(char *)(v36 + v29) = *v38;
                            v33 = v38;
                            v34 = v39;
                            v35 = v29 + 1;
                            v37 = v36;
                        }
                        int64_t v41 = v37;
                        int64_t v42 = v35;
                        int32_t v43 = v27; // 0x100003c98
                        int32_t v44 = v31; // 0x100003c98
                        if (*v33 == 10) {
                            // 0x100003ca0
                            v43 = v27 - 1;
                            v44 = v27 == 2 ? 1 : v31;
                            v5 = v42;
                            v6 = v41;
                            if (v43 == 0) {
                                goto lab_0x100003d24_2;
                            }
                        }
                        int32_t v45 = 1; // 0x100003cf0
                        int32_t v46 = v45; // 0x100003be8
                        v22 = v43;
                        v23 = v34;
                        v24 = v42;
                        v25 = v41;
                        v26 = v44;
                        while (v16 > v45) {
                            // 0x100003bf0
                            v27 = v43;
                            v28 = v34;
                            v29 = v42;
                            v30 = v41;
                            v31 = v44;
                            v32 = v45;
                            if (v31 == 0) {
                                // 0x100003bf0
                                v33 = (char *)(v32 + v10);
                                v34 = v28;
                                v35 = v29;
                                v37 = v30;
                            } else {
                                // 0x100003c04
                                v39 = v28;
                                v36 = v30;
                                if (v29 >= v28) {
                                    // 0x100003c1c
                                    v39 = 2 * v28;
                                    v40 = _realloc((int64_t *)v30, (int32_t)v39);
                                    v36 = (int64_t)v40;
                                    result = 0;
                                    if (v40 == NULL) {
                                        goto lab_0x100003d70;
                                    }
                                }
                                // 0x100003c58
                                v38 = (char *)(v32 + v10);
                                *(char *)(v36 + v29) = *v38;
                                v33 = v38;
                                v34 = v39;
                                v35 = v29 + 1;
                                v37 = v36;
                            }
                            // 0x100003c84
                            v41 = v37;
                            v42 = v35;
                            v43 = v27;
                            v44 = v31;
                            if (*v33 == 10) {
                                // 0x100003ca0
                                v43 = v27 - 1;
                                v44 = v27 == 2 ? 1 : v31;
                                v5 = v42;
                                v6 = v41;
                                if (v43 == 0) {
                                    goto lab_0x100003d24_2;
                                }
                            }
                            // 0x100003cec
                            v45 = v46 + 1;
                            v46 = v45;
                            v22 = v43;
                            v23 = v34;
                            v24 = v42;
                            v25 = v41;
                            v26 = v44;
                        }
                    }
                    // 0x100003cfc
                    v11 = v26;
                    v12 = v24;
                    v13 = v23;
                    v14 = v22;
                    v5 = v12;
                    v6 = v25;
                    if (v14 == 0) {
                        goto lab_0x100003d24_2;
                    }
                    v15 = v25;
                    v16 = _fread(&v9, 1, 256, (struct _IO_FILE *)v1);
                }
                // 0x100003d14
                _free((int64_t *)v15);
                result = 0;
            }
        }
    }
  lab_0x100003d70:;
    int64_t v47 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003d84
    if (v47 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003d98
        ___stack_chk_fail();
    }
    // 0x100003d9c
    return result;
}

// Address range: 0x100003db0 - 0x100003eac
int64_t entry_point(void) {
    int64_t v1 = function_100003af4(); // 0x100003dd8
    if (v1 != 0) {
        // 0x100003df4
        _printf("The 7th line of input was:\n%s\n", (char *)7);
        _free((int64_t *)v1);
        // 0x100003e9c
        return 0;
    }
    // 0x100003e18
    _printf("Did not find the 7th line of input.  Reason:  ");
    if (_feof((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010) != 0) {
        // 0x100003e44
        _puts("End of file reached.");
        // 0x100003e9c
        return 0;
    }
    // 0x100003e54
    if (_ferror((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010) == 0) {
        // 0x100003e84
        _puts("Out of memory.");
    } else {
        // 0x100003e74
        _puts("Error reading input.");
    }
    // 0x100003e9c
    return 0;
}

// Address range: 0x100003eac - 0x100003eb8
int64_t function_100003eac(void) {
    // 0x100003eac
    return ___stack_chk_fail();
}

// Address range: 0x100003eb8 - 0x100003ec4
int32_t function_100003eb8(struct _IO_FILE * stream) {
    // 0x100003eb8
    return _feof(stream);
}

// Address range: 0x100003ec4 - 0x100003ed0
int32_t function_100003ec4(struct _IO_FILE * stream) {
    // 0x100003ec4
    return _ferror(stream);
}

// Address range: 0x100003ed0 - 0x100003edc
int32_t function_100003ed0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003ed0
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003edc - 0x100003ee8
void function_100003edc(int64_t * ptr) {
    // 0x100003edc
    _free(ptr);
}

// Address range: 0x100003ee8 - 0x100003ef4
int64_t * function_100003ee8(int32_t size) {
    // 0x100003ee8
    return _malloc(size);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * format, ...) {
    // 0x100003ef4
    return _printf(format);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * s) {
    // 0x100003f00
    return _puts(s);
}

// Address range: 0x100003f0c - 0x100003f18
int64_t * function_100003f0c(int64_t * ptr, int32_t size) {
    // 0x100003f0c
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <stdio.h>

/* Type marker stick: using bits to indicate what's chosen.  The stick can't
 * handle more than 32 items, but the idea is there; at worst, use array instead */
typedef unsigned long marker;
marker one = 1;

void comb(int pool, int need, marker chosen, int at)
{
	if (pool < need + at) return; /* not enough bits left */

	if (!need) {
		/* got all we needed; print the thing.  if other actions are
		 * desired, we could have passed in a callback function. */
		for (at = 0; at < pool; at++)
			if (chosen & (one << at)) printf("%d ", at);
		printf("\n");
		return;
	}
	/* if we choose the current item, "or" (|) the bit to mark it so. */
	comb(pool, need - 1, chosen | (one << at), at + 1);
	comb(pool, need, chosen, at + 1);  /* or don't choose it, go to next */
}

int main()
{
	comb(5, 3, 0, 0);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e28(void);
int32_t function_100003f94(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e28 - 0x100003f5c
int64_t function_100003e28(void) {
    // 0x100003e28
    int64_t v1; // 0x100003e28
    int32_t v2 = v1; // 0x100003e34
    int32_t v3 = v1; // 0x100003e38
    int32_t v4 = v3 + (int32_t)v1; // 0x100003e50
    int32_t v5 = v2 - v4; // 0x100003e54
    if (v5 < 0 != ((v5 ^ v2) & (v4 ^ v2)) < 0) {
        // 0x100003f50
        int64_t result; // 0x100003e28
        return result;
    }
    if (v3 != 0) {
        // 0x100003f04
        function_100003e28();
        // 0x100003f50
        return function_100003e28();
    }
    int32_t v6 = -v2; // 0x100003e8c
    int32_t v7 = 0; // 0x100003e94
    if (v6 < 0 != (v6 & v2) < 0) {
        if ((g1 << (int64_t)v7 & v1) != 0) {
            // 0x100003ec0
            _printf("%d ", v1);
        }
        // 0x100003ee4
        v7++;
        while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
            // 0x100003e9c
            if ((g1 << (int64_t)v7 & v1) != 0) {
                // 0x100003ec0
                _printf("%d ", v1);
            }
            // 0x100003ee4
            v7++;
        }
    }
    // 0x100003f50
    return _printf((char *)0x100003fa4);
}

// Address range: 0x100003f5c - 0x100003f94
int64_t entry_point(void) {
    // 0x100003f5c
    function_100003e28();
    return 0;
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(char * format, ...) {
    // 0x100003f94
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

char *rtrim(const char *s)
{
  while( isspace(*s) || !isprint(*s) ) ++s;
  return strdup(s);
}

char *ltrim(const char *s)
{
  char *r = strdup(s);
  if (r != NULL)
  {
    char *fr = r + strlen(s) - 1;
    while( (isspace(*fr) || !isprint(*fr) || *fr == 0) && fr >= r) --fr;
    *++fr = 0;
  }
  return r;
}

char *trim(const char *s)
{
  char *r = rtrim(s);
  char *f = ltrim(r);
  free(r);
  return f;
}

const char *a = "     this is a string      ";

int main()
{
  char *b = rtrim(a);
  char *c = ltrim(a);
  char *d = trim(a);

  printf("'%s'\n'%s'\n'%s'\n", b, c, d);

  free(b);
  free(c);
  free(d);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cd0(void);
int64_t function_100003d54(void);
int64_t function_100003e58(void);
void function_100003f34(int64_t * ptr);
int32_t function_100003f40(int32_t c);
int32_t function_100003f4c(int32_t c);
int32_t function_100003f58(char * format, ...);
char * function_100003f64(char * s);
int32_t function_100003f70(char * s);

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int32_t _isprint(int32_t a1);
int32_t _isspace(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003cd0 - 0x100003d54
int64_t function_100003cd0(void) {
    char * v1; // 0x100003cd0
    while (true) {
        // 0x100003ce4
        int64_t v2; // 0x100003cd0
        v1 = (char *)v2;
        if (_isspace((int32_t)*v1) == 0) {
            // 0x100003d24
            if (_isprint((int32_t)*v1) != 0) {
                // break -> 0x100003d40
                break;
            }
        }
        // 0x100003d30
        v2++;
    }
    // 0x100003d40
    return (int64_t)_strdup(v1);
}

// Address range: 0x100003d54 - 0x100003e58
int64_t function_100003d54(void) {
    // 0x100003d54
    int64_t v1; // 0x100003d54
    char * v2 = (char *)v1; // 0x100003d60
    char * v3 = _strdup(v2); // 0x100003d68
    uint64_t result = (int64_t)v3; // 0x100003d68
    if (v3 == NULL) {
        // 0x100003e48
        return result;
    }
    int64_t v4 = (int64_t)_strlen(v2) + result;
    int64_t v5 = v4 - 1;
    char * v6 = (char *)v5;
    if (_isspace((int32_t)*v6) == 0) {
        // 0x100003dc4
        if (_isprint((int32_t)*v6) != 0) {
            // 0x100003de0
            if (*v6 != 0) {
                // break -> 0x100003e34
                break;
            }
        }
    }
    while (v5 >= result) {
        // 0x100003da8
        v4 = v5;
        v5 = v4 - 1;
        v6 = (char *)v5;
        if (_isspace((int32_t)*v6) == 0) {
            // 0x100003dc4
            if (_isprint((int32_t)*v6) != 0) {
                // 0x100003de0
                if (*v6 != 0) {
                    // break -> 0x100003e34
                    break;
                }
            }
        }
    }
    // 0x100003e34
    *(char *)v4 = 0;
    // 0x100003e48
    return result;
}

// Address range: 0x100003e58 - 0x100003e98
int64_t function_100003e58(void) {
    int64_t v1 = function_100003cd0(); // 0x100003e6c
    int64_t result = function_100003d54(); // 0x100003e78
    _free((int64_t *)v1);
    return result;
}

// Address range: 0x100003e98 - 0x100003f34
int64_t entry_point(void) {
    int64_t v1 = function_100003cd0(); // 0x100003ebc
    int64_t v2 = function_100003d54(); // 0x100003ecc
    int64_t v3 = function_100003e58(); // 0x100003edc
    int64_t v4; // 0x100003e98
    _printf("'%s'\n'%s'\n'%s'\n", (char *)v4, (char *)v4, (char *)v4);
    _free((int64_t *)v1);
    _free((int64_t *)v2);
    _free((int64_t *)v3);
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int64_t * ptr) {
    // 0x100003f34
    _free(ptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(int32_t c) {
    // 0x100003f40
    return _isprint(c);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(int32_t c) {
    // 0x100003f4c
    return _isspace(c);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(char * format, ...) {
    // 0x100003f58
    return _printf(format);
}

// Address range: 0x100003f64 - 0x100003f70
char * function_100003f64(char * s) {
    // 0x100003f64
    return _strdup(s);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * s) {
    // 0x100003f70
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include<string.h>
#include<stdio.h>
#include<stdlib.h>

int main(void)
{
	char *a[5];
	const char *s="Hello,How,Are,You,Today";
	int n=0, nn;

	char *ds=strdup(s);

	a[n]=strtok(ds, ",");
	while(a[n] && n<4) a[++n]=strtok(NULL, ",");

	for(nn=0; nn<=n; ++nn) printf("%s.", a[nn]);
	putchar('\n');

	free(ds);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f40(int64_t a1);
void function_100003f4c(int64_t * ptr);
int32_t function_100003f58(char * format, ...);
int32_t function_100003f64(int32_t c);
char * function_100003f70(char * s);
char * function_100003f7c(char * s, char * delim);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
char * _strtok(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003de0 - 0x100003f40
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003df4
    char * v2 = _strdup("Hello,How,Are,You,Today"); // 0x100003e14
    char * v3 = _strtok(v2, (char *)0x100003fa0); // 0x100003e28
    int64_t v4 = (int64_t)v3; // bp-64, 0x100003e34
    int64_t v5 = &v4; // 0x100003e40
    int64_t v6 = 0; // 0x100003e58
    int32_t v7 = 0; // 0x100003e58
    int32_t v8 = 0; // 0x100003e58
    char * v9 = (char *)0x100003fa0; // 0x100003e58
    if (v3 != NULL) {
        int32_t v10 = v6;
        v8 = v10;
        v9 = (char *)0x100003fa0;
        while (v6 < 4 != (3 - v7 & v10) < 0) {
            char * v11 = _strtok(NULL, ","); // 0x100003e8c
            v6++;
            *(int64_t *)(8 * v6 + v5) = (int64_t)v11;
            char * v12 = ","; // 0x100003e58
            v7++;
            if (v11 == NULL) {
                // 0x100003e3c
                v8 = v6;
                v9 = ",";
                goto lab_0x100003eb0;
            }
            v10 = v6;
            v8 = v10;
            v9 = v12;
        }
    }
    goto lab_0x100003eb0;
  lab_0x100003eb0:;
    int32_t v13 = v8;
    int32_t v14 = -v13; // 0x100003eb8
    if (v13 == 0 || v14 < 0 != (v13 & v14) < 0) {
        _printf("%s.", v9);
        int32_t v15 = 1; // 0x100003ef0
        int32_t v16 = v15 - v13; // 0x100003eb8
        int32_t v17 = v15; // 0x100003ec0
        while (v16 == 0 || v16 < 0 != ((v16 ^ v15) & (v15 ^ v13)) < 0) {
            // 0x100003ec8
            _printf("%s.", v9);
            v15 = v17 + 1;
            v16 = v15 - v13;
            v17 = v15;
        }
    }
    // 0x100003efc
    _putchar(10);
    _free((int64_t *)v2);
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f2c
        ___stack_chk_fail((int64_t)&g1);
    }
    // 0x100003f30
    return 0;
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t function_100003f40(int64_t a1) {
    // 0x100003f40
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(int64_t * ptr) {
    // 0x100003f4c
    _free(ptr);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(char * format, ...) {
    // 0x100003f58
    return _printf(format);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(int32_t c) {
    // 0x100003f64
    return _putchar(c);
}

// Address range: 0x100003f70 - 0x100003f7c
char * function_100003f70(char * s) {
    // 0x100003f70
    return _strdup(s);
}

// Address range: 0x100003f7c - 0x100003f88
char * function_100003f7c(char * s, char * delim) {
    // 0x100003f7c
    return _strtok(s, delim);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

int binomial(int n, int k) {
    int num, denom, i;

    if (n < 0 || k < 0 || n < k) return -1;
    if (n == 0 || k == 0) return 1;

    num = 1;
    for (i = k + 1; i <= n; ++i) {
        num = num * i;
    }

    denom = 1;
    for (i = 2; i <= n - k; ++i) {
        denom *= i;
    }

    return num / denom;
}

int gcd(int a, int b) {
    int temp;
    while (b != 0) {
        temp = a % b;
        a = b;
        b = temp;
    }
    return a;
}

typedef struct tFrac {
    int num, denom;
} Frac;

Frac makeFrac(int n, int d) {
    Frac result;
    int g;

    if (d == 0) {
        result.num = 0;
        result.denom = 0;
        return result;
    }

    if (n == 0) {
        d = 1;
    } else if (d < 0) {
        n = -n;
        d = -d;
    }

    g = abs(gcd(n, d));
    if (g > 1) {
        n = n / g;
        d = d / g;
    }

    result.num = n;
    result.denom = d;
    return result;
}

Frac negateFrac(Frac f) {
    return makeFrac(-f.num, f.denom);
}

Frac subFrac(Frac lhs, Frac rhs) {
    return makeFrac(lhs.num * rhs.denom - lhs.denom * rhs.num, rhs.denom * lhs.denom);
}

Frac multFrac(Frac lhs, Frac rhs) {
    return makeFrac(lhs.num * rhs.num, lhs.denom * rhs.denom);
}

bool equalFrac(Frac lhs, Frac rhs) {
    return (lhs.num == rhs.num) && (lhs.denom == rhs.denom);
}

bool lessFrac(Frac lhs, Frac rhs) {
    return (lhs.num * rhs.denom) < (rhs.num * lhs.denom);
}

void printFrac(Frac f) {
    printf("%d", f.num);
    if (f.denom != 1) {
        printf("/%d", f.denom);
    }
}

Frac bernoulli(int n) {
    Frac a[16];
    int j, m;

    if (n < 0) {
        a[0].num = 0;
        a[0].denom = 0;
        return a[0];
    }

    for (m = 0; m <= n; ++m) {
        a[m] = makeFrac(1, m + 1);
        for (j = m; j >= 1; --j) {
            a[j - 1] = multFrac(subFrac(a[j - 1], a[j]), makeFrac(j, 1));
        }
    }

    if (n != 1) {
        return a[0];
    }

    return negateFrac(a[0]);
}

void faulhaber(int p) {
    Frac coeff, q;
    int j, pwr, sign;

    printf("%d : ", p);
    q = makeFrac(1, p + 1);
    sign = -1;
    for (j = 0; j <= p; ++j) {
        sign = -1 * sign;
        coeff = multFrac(multFrac(multFrac(q, makeFrac(sign, 1)), makeFrac(binomial(p + 1, j), 1)), bernoulli(j));
        if (equalFrac(coeff, makeFrac(0, 1))) {
            continue;
        }
        if (j == 0) {
            if (!equalFrac(coeff, makeFrac(1, 1))) {
                if (equalFrac(coeff, makeFrac(-1, 1))) {
                    printf("-");
                } else {
                    printFrac(coeff);
                }
            }
        } else {
            if (equalFrac(coeff, makeFrac(1, 1))) {
                printf(" + ");
            } else if (equalFrac(coeff, makeFrac(-1, 1))) {
                printf(" - ");
            } else if (lessFrac(makeFrac(0, 1), coeff)) {
                printf(" + ");
                printFrac(coeff);
            } else {
                printf(" - ");
                printFrac(negateFrac(coeff));
            }
        }
        pwr = p + 1 - j;
        if (pwr > 1) {
            printf("n^%d", pwr);
        } else {
            printf("n");
        }
    }
    printf("\n");
}

int main() {
    int i;

    for (i = 0; i < 10; ++i) {
        faulhaber(i);
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003588(void);
int64_t function_1000036e0(void);
int64_t function_10000373c(void);
int64_t function_100003838(int32_t a1);
int64_t function_100003870(int64_t a1, int64_t a2);
int64_t function_1000038c4(int64_t a1, int64_t a2);
int64_t function_100003908(void);
int64_t function_10000395c(void);
int64_t function_100003994(void);
int64_t function_100003a00(void);
int64_t function_100003bc0(void);
int64_t function_100003f3c(void);
int32_t function_100003f48(int32_t x);
int32_t function_100003f54(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _abs(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003588 - 0x1000036e0
int64_t function_100003588(void) {
    // 0x100003588
    int64_t v1; // 0x100003588
    int32_t v2 = v1; // 0x10000358c
    int32_t v3 = v1; // 0x100003590
    if (v3 < 0 || v2 < 0) {
        // 0x1000036d4
        return 0xffffffff;
    }
    int32_t v4 = v2 - v3; // 0x1000035c4
    if (v4 < 0 != ((v4 ^ v2) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x1000036d4
        return 0xffffffff;
    }
    // 0x1000035e0
    if (v3 == 0 || v2 == 0) {
        // 0x1000036d4
        return 1;
    }
    int32_t v5 = v3 + 1;
    int32_t v6 = v5 - v2; // 0x100003634
    int32_t v7 = 1; // 0x10000363c
    int32_t v8 = v5; // 0x10000363c
    int32_t v9 = 1; // 0x10000363c
    if (v6 == 0 || v6 < 0 != ((v6 ^ v5) & (v5 ^ v2)) < 0) {
        v9 *= v8;
        v8++;
        int32_t v10 = v8 - v2; // 0x100003634
        v7 = v9;
        while (v10 == 0 || v10 < 0 != ((v10 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x100003644
            v9 *= v8;
            v8++;
            v10 = v8 - v2;
            v7 = v9;
        }
    }
    int32_t v11 = 2 - v4; // 0x10000368c
    int32_t v12 = 2; // 0x100003694
    int32_t v13 = 1; // 0x100003694
    int32_t v14 = 1; // 0x100003694
    if (v11 == 0 || v11 < 0 != (v11 & v4) < 0) {
        v13 *= v12;
        v12++;
        int32_t v15 = v12 - v4; // 0x10000368c
        v14 = v13;
        while (v15 == 0 || v15 < 0 != ((v15 ^ v12) & (v12 ^ v4)) < 0) {
            // 0x10000369c
            v13 *= v12;
            v12++;
            v15 = v12 - v4;
            v14 = v13;
        }
    }
    // 0x1000036d4
    return v7 / v14;
}

// Address range: 0x1000036e0 - 0x10000373c
int64_t function_1000036e0(void) {
    // 0x1000036e0
    int64_t v1; // 0x1000036e0
    int32_t result = v1; // 0x1000036e4
    int32_t v2 = v1; // 0x1000036e8
    if (v2 == 0) {
        // 0x100003730
        return result;
    }
    int32_t result2 = v2;
    int32_t v3 = result % result2;
    while (v3 != 0) {
        int32_t v4 = result2;
        result2 = v3;
        v3 = v4 % result2;
    }
    // 0x100003730
    return result2;
}

// Address range: 0x10000373c - 0x100003838
int64_t function_10000373c(void) {
    // 0x10000373c
    int64_t v1; // 0x10000373c
    int32_t v2 = v1; // 0x10000374c
    if (v2 == 0) {
        // 0x100003828
        return 0;
    }
    int32_t v3 = v1; // 0x100003748
    int32_t v4 = v2 < 0 == (v3 != 0) ? -v3 : v3;
    int32_t v5 = _abs((int32_t)function_1000036e0()); // 0x1000037d4
    int32_t v6 = v5 - 1; // 0x1000037e0
    int32_t result = v4; // 0x1000037e8
    if (v6 != 0 && v6 < 0 == (v5 & -v5) < 0) {
        // 0x1000037f0
        result = v4 / v5;
    }
    // 0x100003828
    return result;
}

// Address range: 0x100003838 - 0x100003870
int64_t function_100003838(int32_t a1) {
    // 0x100003838
    return function_10000373c();
}

// Address range: 0x100003870 - 0x1000038c4
int64_t function_100003870(int64_t a1, int64_t a2) {
    // 0x100003870
    return function_10000373c();
}

// Address range: 0x1000038c4 - 0x100003908
int64_t function_1000038c4(int64_t a1, int64_t a2) {
    // 0x1000038c4
    return function_10000373c();
}

// Address range: 0x100003908 - 0x10000395c
int64_t function_100003908(void) {
    // 0x100003908
    int64_t v1; // 0x100003908
    return (int32_t)v1 == (int32_t)v1;
}

// Address range: 0x10000395c - 0x100003994
int64_t function_10000395c(void) {
    // 0x10000395c
    int64_t v1; // 0x10000395c
    int32_t v2; // 0x10000395c
    int32_t v3 = v2 * (int32_t)v1; // 0x100003970
    int32_t v4 = v2 * (int32_t)v1; // 0x10000397c
    int32_t v5 = v3 - v4; // 0x100003980
    return v5 < 0 != ((v5 ^ v3) & (v3 ^ v4)) < 0;
}

// Address range: 0x100003994 - 0x100003a00
int64_t function_100003994(void) {
    // 0x100003994
    int64_t v1; // 0x100003994
    int32_t result = _printf("%d", v1); // 0x1000039cc
    int32_t v2; // 0x100003994
    if (v2 != 1) {
        // 0x1000039d4
        result = _printf("/%d", v1);
    }
    // 0x1000039f4
    return result;
}

// Address range: 0x100003a00 - 0x100003bc0
int64_t function_100003a00(void) {
    // 0x100003a00
    int64_t v1; // 0x100003a00
    int32_t v2 = v1; // 0x100003a20
    int32_t v3; // bp-168, 0x100003a00
    int64_t result; // 0x100003a00
    if (v2 < 0) {
        // 0x100003a38
        v3 = 0;
        result = 0;
    } else {
        int32_t v4 = -v2; // 0x100003a5c
        int32_t v5; // 0x100003a00
        if (v2 == 0 || v4 < 0 != (v4 & v2) < 0) {
            int64_t v6 = &v3; // 0x100003a78
            int32_t v7 = 0;
            *(int64_t *)(8 * (int64_t)v7 + v6) = function_10000373c();
            int32_t v8 = v7 - 1; // 0x100003ab0
            int32_t v9 = v8; // 0x100003ab8
            int32_t v10 = v7; // 0x100003ab8
            int32_t v11; // 0x100003a00
            int64_t * v12; // 0x100003ae8
            int64_t v13; // 0x100003af0
            int32_t v14; // 0x100003ab0
            if (v8 < 0 == (v7 & -v7) < 0) {
                v11 = v9;
                v12 = (int64_t *)((int64_t)(8 * v10 - 8) + v6);
                v13 = function_100003870(*v12, *(int64_t *)(8 * (int64_t)v10 + v6));
                *v12 = function_1000038c4(v13, function_10000373c());
                v14 = v11 - 1;
                v10 = v11;
                while (v14 < 0 == (v11 & -v11) < 0) {
                    // 0x100003ac0
                    v11 = v14;
                    v12 = (int64_t *)((int64_t)(8 * v10 - 8) + v6);
                    v13 = function_100003870(*v12, *(int64_t *)(8 * (int64_t)v10 + v6));
                    *v12 = function_1000038c4(v13, function_10000373c());
                    v14 = v11 - 1;
                    v10 = v11;
                }
            }
            int32_t v15 = v7 + 1; // 0x100003b44
            while (v15 - v2 == 0 || v15 - v2 < 0 != ((v15 - v2 ^ v15) & (v15 ^ v2)) < 0) {
                // 0x100003a6c
                v7 = v15;
                *(int64_t *)(8 * (int64_t)v7 + v6) = function_10000373c();
                v8 = v7 - 1;
                v9 = v8;
                v10 = v7;
                if (v8 < 0 == (v7 & -v7) < 0) {
                    v11 = v9;
                    v12 = (int64_t *)((int64_t)(8 * v10 - 8) + v6);
                    v13 = function_100003870(*v12, *(int64_t *)(8 * (int64_t)v10 + v6));
                    *v12 = function_1000038c4(v13, function_10000373c());
                    v14 = v11 - 1;
                    v10 = v11;
                    while (v14 < 0 == (v11 & -v11) < 0) {
                        // 0x100003ac0
                        v11 = v14;
                        v12 = (int64_t *)((int64_t)(8 * v10 - 8) + v6);
                        v13 = function_100003870(*v12, *(int64_t *)(8 * (int64_t)v10 + v6));
                        *v12 = function_1000038c4(v13, function_10000373c());
                        v14 = v11 - 1;
                        v10 = v11;
                    }
                }
                // 0x100003b40
                v15 = v7 + 1;
            }
            // 0x100003a54
            v5 = v3;
        }
        // 0x100003b50
        if (v2 == 1) {
            // 0x100003b70
            result = function_100003838(v5);
        } else {
            // 0x100003b64
            result = v5;
        }
    }
    int64_t v16 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b94
    if (v16 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003ba8
        ___stack_chk_fail();
    }
    // 0x100003bac
    return result;
}

// Address range: 0x100003bc0 - 0x100003ee4
int64_t function_100003bc0(void) {
    // 0x100003bc0
    int64_t v1; // 0x100003bc0
    int32_t v2 = v1; // 0x100003bd4
    _printf("%d : ", v1);
    int64_t v3 = function_10000373c(); // 0x100003c00
    int32_t v4 = -v2; // 0x100003c28
    if (v2 != 0 && v4 < 0 == (v4 & v2) < 0) {
        // 0x100003ecc
        return _printf((char *)0x100003f7e);
    }
    int32_t v5 = 0;
    int64_t v6 = function_1000038c4(v3, function_10000373c()); // 0x100003c64
    function_100003588();
    int64_t v7 = function_1000038c4(v6, function_10000373c()); // 0x100003c90
    int64_t v8 = function_1000038c4(v7, function_100003a00()); // 0x100003cac
    function_10000373c();
    int64_t v9; // 0x100003bc0
    uint64_t v10; // 0x100003bc0
    int64_t v11; // 0x100003d30
    int32_t v12; // 0x100003e6c
    int32_t v13; // 0x100003e78
    int64_t v14; // 0x100003db8
    int64_t v15; // 0x100003bc0
    if (function_100003908() % 2 == 0) {
        // 0x100003cec
        v9 = function_10000373c();
        v10 = function_100003908();
        if (v5 == 0) {
            // 0x100003d00
            v15 = v9;
            if (v10 % 2 == 0) {
                // 0x100003d28
                v11 = function_10000373c();
                if (function_100003908() % 2 == 0) {
                    // 0x100003d60
                    function_100003994();
                    v15 = v11;
                } else {
                    // 0x100003d50
                    _printf("-");
                    v15 = v11;
                }
            }
        } else {
            if (v10 % 2 == 0) {
                // 0x100003db0
                v14 = function_10000373c();
                if (function_100003908() % 2 == 0) {
                    // 0x100003de8
                    function_10000373c();
                    if (function_10000395c() % 2 == 0) {
                        // 0x100003e2c
                        _printf(" - ");
                        function_100003838((int32_t)v8);
                        function_100003994();
                        v15 = v8;
                    } else {
                        // 0x100003e10
                        _printf(" + ");
                        function_100003994();
                        v15 = v8;
                    }
                } else {
                    // 0x100003dd8
                    _printf(" - ");
                    v15 = v14;
                }
            } else {
                // 0x100003da0
                _printf(" + ");
                v15 = v9;
            }
        }
        // 0x100003e60
        v12 = v2 + 1 - v5;
        v13 = v12 - 1;
        if (v13 == 0 || v13 < 0 != (v12 & -v12) < 0) {
            // 0x100003ea8
            _printf((char *)0x100003f7c);
        } else {
            // 0x100003e88
            _printf("n^%d", v15);
        }
    }
    int32_t v16 = v5 + 1; // 0x100003ec0
    while (v16 - v2 == 0 || v16 - v2 < 0 != ((v16 - v2 ^ v16) & (v16 ^ v2)) < 0) {
        // 0x100003c38
        v5 = v16;
        v6 = function_1000038c4(v3, function_10000373c());
        function_100003588();
        v7 = function_1000038c4(v6, function_10000373c());
        v8 = function_1000038c4(v7, function_100003a00());
        function_10000373c();
        if (function_100003908() % 2 == 0) {
            // 0x100003cec
            v9 = function_10000373c();
            v10 = function_100003908();
            if (v5 == 0) {
                // 0x100003d00
                v15 = v9;
                if (v10 % 2 == 0) {
                    // 0x100003d28
                    v11 = function_10000373c();
                    if (function_100003908() % 2 == 0) {
                        // 0x100003d60
                        function_100003994();
                        v15 = v11;
                    } else {
                        // 0x100003d50
                        _printf("-");
                        v15 = v11;
                    }
                }
            } else {
                if (v10 % 2 == 0) {
                    // 0x100003db0
                    v14 = function_10000373c();
                    if (function_100003908() % 2 == 0) {
                        // 0x100003de8
                        function_10000373c();
                        if (function_10000395c() % 2 == 0) {
                            // 0x100003e2c
                            _printf(" - ");
                            function_100003838((int32_t)v8);
                            function_100003994();
                            v15 = v8;
                        } else {
                            // 0x100003e10
                            _printf(" + ");
                            function_100003994();
                            v15 = v8;
                        }
                    } else {
                        // 0x100003dd8
                        _printf(" - ");
                        v15 = v14;
                    }
                } else {
                    // 0x100003da0
                    _printf(" + ");
                    v15 = v9;
                }
            }
            // 0x100003e60
            v12 = v2 + 1 - v5;
            v13 = v12 - 1;
            if (v13 == 0 || v13 < 0 != (v12 & -v12) < 0) {
                // 0x100003ea8
                _printf((char *)0x100003f7c);
            } else {
                // 0x100003e88
                _printf("n^%d", v15);
            }
        }
        // 0x100003ebc
        v16 = v5 + 1;
    }
    // 0x100003ecc
    return _printf((char *)0x100003f7e);
}

// Address range: 0x100003ee4 - 0x100003f3c
int64_t entry_point(void) {
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003f10
        function_100003bc0();
    }
    // 0x100003f2c
    return 0;
}

// Address range: 0x100003f3c - 0x100003f48
int64_t function_100003f3c(void) {
    // 0x100003f3c
    return ___stack_chk_fail();
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(int32_t x) {
    // 0x100003f48
    return _abs(x);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>

bool damm(unsigned char *input, size_t length) {
    static const unsigned char table[10][10] = {
        {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},
        {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},
        {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},
        {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},
        {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},
        {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},
        {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},
        {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},
        {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},
        {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},
    };

    unsigned char interim = 0;
    for (size_t i = 0; i < length; i++) {
        interim = table[interim][input[i]];
    }
    return interim == 0;
}

int main() {
    unsigned char input[4] = {5, 7, 2, 4};
    puts(damm(input, 4) ? "Checksum correct" : "Checksum incorrect");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e18(void);
int32_t function_100003f08(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x608090507010300; // 0x100003f14

// ------- Dynamically Linked Functions Without Header --------

int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e18 - 0x100003ea4
int64_t function_100003e18(void) {
    // 0x100003e18
    int64_t v1; // 0x100003e18
    if (v1 == 0) {
        // 0x100003e8c
        return 1;
    }
    int64_t v2 = 0; // 0x100003e40
    unsigned char v3 = *(char *)(v2 + v1); // 0x100003e68
    unsigned char v4 = *(char *)((int64_t)&g1 + (int64_t)v3); // 0x100003e70
    v2++;
    int64_t v5 = v4; // 0x100003e40
    while (v2 != v1) {
        // 0x100003e48
        v3 = *(char *)(v2 + v1);
        v4 = *(char *)(10 * v5 + (int64_t)&g1 + (int64_t)v3);
        v2++;
        v5 = v4;
    }
    // 0x100003e8c
    return v4 == 0;
}

// Address range: 0x100003ea4 - 0x100003f08
int64_t entry_point(void) {
    uint64_t v1 = function_100003e18(); // 0x100003ed4
    int64_t v2 = v1 % 2 == 0 ? (int64_t)"Checksum incorrect" : (int64_t)"Checksum correct"; // 0x100003ef0
    _puts((char *)v2);
    return 0;
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * s) {
    // 0x100003f08
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <math.h>
#include <stdio.h>

int p(int l, int n) {
    int test = 0;
    double logv = log(2.0) / log(10.0);
    int factor = 1;
    int loop = l;
    while (loop > 10) {
        factor *= 10;
        loop /= 10;
    }
    while (n > 0) {
        int val;

        test++;
        val = (int)(factor * pow(10.0, fmod(test * logv, 1)));
        if (val == l) {
            n--;
        }
    }
    return test;
}

void runTest(int l, int n) {
    printf("p(%d, %d) = %d\n", l, n, p(l, n));
}

int main() {
    runTest(12, 1);
    runTest(12, 2);
    runTest(123, 45);
    runTest(123, 12345);
    runTest(123, 678910);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d54(void);
int64_t function_100003e8c(void);
float64_t function_100003f68(float64_t a1, float64_t a2);
float64_t function_100003f74(float64_t a1);
float64_t function_100003f80(float64_t a1, float64_t a2);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

float64_t _fmod(float64_t a1, float64_t a2);
float64_t _log(float64_t a1);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d54 - 0x100003e8c
int64_t function_100003d54(void) {
    // 0x100003d54
    int128_t v1; // 0x100003d54
    int128_t v2 = v1;
    int64_t v3; // 0x100003d54
    int32_t v4 = v3; // 0x100003d60
    _log(_log((float64_t)(int64_t)v1));
    int32_t v5 = v4 - 10; // 0x100003da8
    int32_t v6 = v4; // 0x100003db0
    if (v5 != 0 && v5 < 0 == (9 - v4 & v4) < 0) {
        v6 /= 10;
        while (v6 != 10 && v6 < 10 == (9 - v6 & v6) < 0) {
            // 0x100003db8
            v6 /= 10;
        }
    }
    int32_t v7 = v3; // 0x100003d64
    if (v7 < 1) {
        // 0x100003e7c
        return 0;
    }
    float64_t v8 = 0.2; // 0x100003e44
    int32_t result = 0; // 0x100003df4
    for (int32_t i = v7; i >= 1; i += (int32_t)(v4 == (int32_t)v8)) {
        // 0x100003df0
        result++;
        __asm_sshll(0.0f, 0);
        int128_t v9 = __asm_sshll(0.0f, 0); // 0x100003e18
        _pow(_fmod((float64_t)(int64_t)v9, (float64_t)(int64_t)v2), (float64_t)(int64_t)v2);
        v8 *= 10.0;
    }
    // 0x100003e7c
    return result;
}

// Address range: 0x100003e8c - 0x100003ef8
int64_t function_100003e8c(void) {
    // 0x100003e8c
    function_100003d54();
    int64_t v1; // 0x100003e8c
    return _printf("p(%d, %d) = %d\n", v1 & 0xffffffff, v1, v1);
}

// Address range: 0x100003ef8 - 0x100003f68
int64_t entry_point(void) {
    // 0x100003ef8
    function_100003e8c();
    function_100003e8c();
    function_100003e8c();
    function_100003e8c();
    function_100003e8c();
    return 0;
}

// Address range: 0x100003f68 - 0x100003f74
float64_t function_100003f68(float64_t a1, float64_t a2) {
    // 0x100003f68
    return _fmod(a1, a2);
}

// Address range: 0x100003f74 - 0x100003f80
float64_t function_100003f74(float64_t a1) {
    // 0x100003f74
    return _log(a1);
}

// Address range: 0x100003f80 - 0x100003f8c
float64_t function_100003f80(float64_t a1, float64_t a2) {
    // 0x100003f80
    return _pow(a1, a2);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>

int common_len(const char *const *names, int n, char sep)
{
	int i, pos;
	for (pos = 0; ; pos++) {
		for (i = 0; i < n; i++) {
			if (names[i][pos] != '\0' &&
					names[i][pos] == names[0][pos])
				continue;

			/* backtrack */
			while (pos > 0 && names[0][--pos] != sep);
			return pos;
		}
	}

	return 0;
}

int main()
{
	const char *names[] = {
		"/home/user1/tmp/coverage/test",
		"/home/user1/tmp/covert/operator",
		"/home/user1/tmp/coven/members",
	};
	int len = common_len(names, sizeof(names) / sizeof(const char*), '/');

	if (!len) printf("No common path\n");
	else      printf("Common path: %.*s\n", len, names[0]);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d1c(void);
int64_t function_100003f08(int64_t a1);
int32_t function_100003f14(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d1c - 0x100003e3c
int64_t function_100003d1c(void) {
    // 0x100003d1c
    int64_t v1; // 0x100003d1c
    int32_t v2 = v1; // 0x100003d24
    int32_t v3 = -v2; // 0x100003d44
    int32_t v4 = 0; // 0x100003d30
    int32_t v5; // 0x100003d1c
    while (true) {
        // 0x100003d34
        v5 = v4;
        if (v3 < 0 != (v3 & v2) < 0) {
            int64_t v6 = v5; // 0x100003d60
            int32_t v7 = 0; // 0x100003e1c
            char v8 = *(char *)(*(int64_t *)(8 * (int64_t)v7 + v1) + v6); // 0x100003d64
            if (v8 == 0) {
                // break (via goto) -> 0x100003db0
                goto lab_0x100003db0_2;
            }
            // 0x100003d78
            if (v8 != *(char *)(v1 + v6)) {
                // break (via goto) -> 0x100003db0
                goto lab_0x100003db0_2;
            }
            // 0x100003d3c
            v7++;
            while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
                // 0x100003d54
                v8 = *(char *)(*(int64_t *)(8 * (int64_t)v7 + v1) + v6);
                if (v8 == 0) {
                    // break (via goto) -> 0x100003db0
                    goto lab_0x100003db0_2;
                }
                // 0x100003d78
                if (v8 != *(char *)(v1 + v6)) {
                    // break (via goto) -> 0x100003db0
                    goto lab_0x100003db0_2;
                }
                // 0x100003d3c
                v7++;
            }
        }
        // 0x100003e2c
        v4 = v5 + 1;
    }
  lab_0x100003db0_2:;
    int64_t v9 = v5;
    while ((int32_t)v9 >= 1) {
        int64_t v10 = v9 + 0xffffffff & 0xffffffff;
        int64_t result = v10; // 0x100003e00
        if (0x1000000 * (int32_t)v1 >> 24 == (int32_t)*(char *)(v10 + v1)) {
            // 0x100003e0c
            return result;
        }
        v9--;
    }
    // 0x100003e0c
    return v9 & 0xffffffff;
}

// Address range: 0x100003e3c - 0x100003f08
int64_t entry_point(void) {
    // 0x100003e3c
    int32_t v1; // 0x100003e3c
    if ((int32_t)function_100003d1c() == 0) {
        // 0x100003e9c
        v1 = _printf("No common path\n");
    } else {
        // 0x100003eac
        v1 = _printf("Common path: %.*s\n", 3, (char *)47);
    }
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ee0
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003ef4
        ___stack_chk_fail((int64_t)v1);
    }
    // 0x100003ef8
    return 0;
}

// Address range: 0x100003f08 - 0x100003f14
int64_t function_100003f08(int64_t a1) {
    // 0x100003f08
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * format, ...) {
    // 0x100003f14
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>

int is_leap_year(unsigned year)
{
    return !(year & (year % 100 ? 3 : 15));
}

int main(void)
{
    const unsigned test_case[] = {
        1900, 1994, 1996, 1997, 2000, 2024, 2025, 2026, 2100
    };
    const unsigned n = sizeof test_case / sizeof test_case[0];

    for (unsigned i = 0; i != n; ++i) {
        unsigned year = test_case[i];
        printf("%u is %sa leap year.\n", year, is_leap_year(year) ? "" : "not ");
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003de4(void);
int64_t function_100003f3c(int64_t a1);
int64_t * function_100003f48(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f54(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x7ca0000076c; // 0x100003f60

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003de4 - 0x100003e34
int64_t function_100003de4(void) {
    // 0x100003de4
    int64_t v1; // 0x100003de4
    uint32_t v2 = (int32_t)v1; // 0x100003de8
    return ((v2 % 100 == 0 ? 15 : 3) & v2) == 0;
}

// Address range: 0x100003e34 - 0x100003f3c
int64_t entry_point(void) {
    // 0x100003e34
    int64_t v1; // bp-60, 0x100003e34
    _memcpy(&v1, &g1, 36);
    int32_t v2; // 0x100003ef0
    for (int32_t i = 0; i < 9; i++) {
        // 0x100003e8c
        function_100003de4();
        v2 = _printf("%u is %sa leap year.\n", (int32_t)&g1, (char *)36);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f14
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f28
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f2c
    return 0;
}

// Address range: 0x100003f3c - 0x100003f48
int64_t function_100003f3c(int64_t a1) {
    // 0x100003f3c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f48 - 0x100003f54
int64_t * function_100003f48(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f48
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>

typedef uint64_t integer;

integer reverse(integer n) {
    integer rev = 0;
    while (n > 0) {
        rev = rev * 10 + (n % 10);
        n /= 10;
    }
    return rev;
}

typedef struct palgen_tag {
    integer power;
    integer next;
    int digit;
    bool even;
} palgen_t;

void init_palgen(palgen_t* palgen, int digit) {
    palgen->power = 10;
    palgen->next = digit * palgen->power - 1;
    palgen->digit = digit;
    palgen->even = false;
}

integer next_palindrome(palgen_t* p) {
    ++p->next;
    if (p->next == p->power * (p->digit + 1)) {
        if (p->even)
            p->power *= 10;
        p->next = p->digit * p->power;
        p->even = !p->even;
    }
    return p->next * (p->even ? 10 * p->power : p->power)
        + reverse(p->even ? p->next : p->next/10);
}

bool gapful(integer n) {
    integer m = n;
    while (m >= 10)
        m /= 10;
    return n % (n % 10 + 10 * m) == 0;
}

void print(int len, integer array[][len]) {
    for (int digit = 1; digit < 10; ++digit) {
        printf("%d: ", digit);
        for (int i = 0; i < len; ++i)
            printf(" %llu", array[digit - 1][i]);
        printf("\n");
    }
}

int main() {
    const int n1 = 20, n2 = 15, n3 = 10;
    const int m1 = 100, m2 = 1000;

    integer pg1[9][n1];
    integer pg2[9][n2];
    integer pg3[9][n3];

    for (int digit = 1; digit < 10; ++digit) {
        palgen_t pgen;
        init_palgen(&pgen, digit);
        for (int i = 0; i < m2; ) {
            integer n = next_palindrome(&pgen);
            if (!gapful(n))
                continue;
            if (i < n1)
                pg1[digit - 1][i] = n;
            else if (i < m1 && i >= m1 - n2)
                pg2[digit - 1][i - (m1 - n2)] = n;
            else if (i >= m2 - n3)
                pg3[digit - 1][i - (m2 - n3)] = n;
            ++i;
        }
    }

    printf("First %d palindromic gapful numbers ending in:\n", n1);
    print(n1, pg1);

    printf("\nLast %d of first %d palindromic gapful numbers ending in:\n", n2, m1);
    print(n2, pg2);

    printf("\nLast %d of first %d palindromic gapful numbers ending in:\n", n3, m2);
    print(n3, pg3);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003900(void);
int64_t function_100003964(void);
int64_t function_1000039b4(void);
int64_t function_100003b18(void);
int64_t function_100003b98(void);
int64_t function_100003efc(int64_t a1);
int32_t function_100003f08(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003900 - 0x100003964
int64_t function_100003900(void) {
    // 0x100003900
    int64_t v1; // 0x100003900
    if (v1 == 0) {
        // 0x100003958
        return 0;
    }
    int64_t result = 0; // 0x10000391c
    int64_t v2; // 0x100003900
    uint64_t v3 = v2;
    result = v3 % 10 + 10 * result;
    v2 = v3 / 10;
    while (v3 >= 10) {
        // 0x100003924
        v3 = v2;
        result = v3 % 10 + 10 * result;
        v2 = v3 / 10;
    }
    // 0x100003958
    return result;
}

// Address range: 0x100003964 - 0x1000039b4
int64_t function_100003964(void) {
    // 0x100003964
    int64_t v1; // 0x100003964
    int64_t result = v1;
    *(int64_t *)result = 10;
    *(int64_t *)(result + 8) = (0x100000000 * v1 >> 32) * result - 1;
    *(int32_t *)(result + 16) = (int32_t)v1;
    *(char *)(result + 20) = 0;
    return result;
}

// Address range: 0x1000039b4 - 0x100003b18
int64_t function_1000039b4(void) {
    // 0x1000039b4
    int64_t v1; // 0x1000039b4
    int64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 + 8); // 0x1000039c8
    int64_t v4 = *v3 + 1; // 0x1000039cc
    *v3 = v4;
    int32_t * v5 = (int32_t *)(v2 + 16); // 0x1000039e8
    int32_t v6 = *v5; // 0x1000039e8
    char * v7 = (char *)(v2 + 20);
    unsigned char v8 = *v7;
    if (v4 != v2 * (int64_t)(v6 + 1)) {
        // 0x100003a70
        return (v8 % 2 == 0 ? v2 : 10 * v2) * v4 + function_100003900();
    }
    int32_t v9 = v6; // 0x100003a14
    if (v8 % 2 != 0) {
        // 0x100003a1c
        *(int64_t *)v2 = 10 * v2;
        v9 = *v5;
    }
    // 0x100003a34
    *v3 = v2 * (int64_t)v9;
    char v10 = *v7 % 2 ^ 1;
    *v7 = v10;
    // 0x100003a70
    return (v10 % 2 == 0 ? v2 : 10 * v2) * *v3 + function_100003900();
}

// Address range: 0x100003b18 - 0x100003b98
int64_t function_100003b18(void) {
    // 0x100003b18
    int64_t v1; // 0x100003b18
    uint64_t v2 = v1;
    if (v2 < 10) {
        // 0x100003b54
        int64_t v3; // 0x100003b18
        return v2 % (10 * v3 + v2 % 10) == 0;
    }
    int64_t v4; // 0x100003b18
    uint64_t v5 = v4;
    int64_t v6 = v5 / 10; // 0x100003b48
    while (v5 >= 100) {
        // 0x100003b40
        v5 = v6;
        v6 = v5 / 10;
    }
    // 0x100003b54
    return v2 % (10 * v6 + v2 % 10) == 0;
}

// Address range: 0x100003b98 - 0x100003c8c
int64_t function_100003b98(void) {
    // 0x100003b98
    int64_t v1; // 0x100003b98
    int32_t v2 = v1; // 0x100003ba4
    int32_t v3 = -v2;
    int32_t result; // 0x100003c68
    for (int32_t i = 1; i < 10; i++) {
        // 0x100003bd4
        _printf("%d: ", v1);
        if (v3 < 0 != (v3 & v2) < 0) {
            _printf(" %llu", v1);
            int32_t v4 = 1; // 0x100003c54
            int32_t v5 = v4 - v2; // 0x100003c00
            int32_t v6 = v4; // 0x100003c08
            while (v5 < 0 != ((v5 ^ v4) & (v4 ^ v2)) < 0) {
                // 0x100003c10
                _printf(" %llu", v1);
                v4 = v6 + 1;
                v5 = v4 - v2;
                v6 = v4;
            }
        }
        // 0x100003c60
        result = _printf("\n");
    }
    // 0x100003c80
    return result;
}

// Address range: 0x100003c8c - 0x100003efc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ca4
    int64_t v2; // bp-1472, 0x100003c8c
    int64_t v3 = &v2;
    int64_t v4; // bp-2552, 0x100003c8c
    int64_t v5 = &v4;
    int64_t v6 = 1;
    int32_t v7; // 0x100003c8c
    int32_t v8; // 0x100003c8c
    int64_t v9; // 0x100003c8c
    int64_t v10; // 0x100003d24
    while (true) {
        // 0x100003cf8
        function_100003964();
        int64_t v11 = v6 - 1;
        int64_t v12 = 160 * v11 + v3;
        int64_t v13 = 120 * v11 + v5;
        int64_t v14; // bp-3272, 0x100003c8c
        v9 = 80 * v11 + (int64_t)&v14;
        v7 = 0;
        while (true) {
          lab_0x100003d0c:
            // 0x100003d0c
            v8 = v7;
            if (v8 < 1000 == (999 - v8 & v8) < 0) {
                // break (via goto) -> 0x100003e20
                goto lab_0x100003e20;
            }
            // 0x100003d20
            v10 = function_1000039b4();
            while (function_100003b18() % 2 == 0) {
                if (v8 < 1000 == (999 - v8 & v8) < 0) {
                    // break (via goto) -> 0x100003e20
                    goto lab_0x100003e20;
                }
                // 0x100003d20
                v10 = function_1000039b4();
            }
            if (v8 < 20 == (19 - v8 & v8) < 0) {
                if (v8 < 100 == (99 - v8 & v8) < 0) {
                    goto lab_0x100003dc8;
                } else {
                    if (v8 < 85 == (84 - v8 & v8) < 0) {
                        // 0x100003da0
                        *(int64_t *)(v13 + (int64_t)(8 * v8 - 680)) = v10;
                        // 0x100003e0c
                        v7 = v8 + 1;
                        goto lab_0x100003d0c;
                    } else {
                        goto lab_0x100003dc8;
                    }
                }
            } else {
                // 0x100003d54
                *(int64_t *)(v12 + 8 * (int64_t)v8) = v10;
                // 0x100003e0c
                v7 = v8 + 1;
                goto lab_0x100003d0c;
            }
        }
      lab_0x100003e20:
        // 0x100003e20
        v6++;
        if (v6 == 10) {
            // break -> 0x100003e30
            break;
        }
    }
    // 0x100003e30
    _printf("First %d palindromic gapful numbers ending in:\n", 9);
    function_100003b98();
    int64_t v15; // 0x100003c8c
    _printf("\nLast %d of first %d palindromic gapful numbers ending in:\n", v3, v15);
    function_100003b98();
    _printf("\nLast %d of first %d palindromic gapful numbers ending in:\n", v5, v15);
    int64_t v16 = function_100003b98(); // 0x100003ec0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ee4
        ___stack_chk_fail(v16);
    }
    // 0x100003ee8
    return 0;
  lab_0x100003dc8:
    if (v8 < 990 == (989 - v8 & v8) < 0) {
        // 0x100003ddc
        *(int64_t *)(v9 + (int64_t)(8 * v8 - 0x1ef0)) = v10;
    }
    // 0x100003e0c
    v7 = v8 + 1;
    goto lab_0x100003d0c;
}

// Address range: 0x100003efc - 0x100003f08
int64_t function_100003efc(int64_t a1) {
    // 0x100003efc
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <limits.h>	/* INT_MIN */
#include <setjmp.h>	/* siglongjmp(), sigsetjmp() */
#include <stdio.h>	/* perror(), printf() */
#include <stdlib.h>	/* exit() */
#include <signal.h>	/* sigaction(), sigemptyset() */

static sigjmp_buf fpe_env;

/*
 * This SIGFPE handler jumps to fpe_env.
 *
 * A SIGFPE handler must not return, because the program might retry
 * the division, which might cause an infinite loop. The only safe
 * options are to _exit() the program or to siglongjmp() out.
 */
static void
fpe_handler(int signal, siginfo_t *w, void *a)
{
	siglongjmp(fpe_env, w->si_code);
	/* NOTREACHED */
}

/*
 * Try to do x / y, but catch attempts to divide by zero.
 */
void
try_division(int x, int y)
{
	struct sigaction act, old;
	int code;
	/*
	 * The result must be volatile, else C compiler might delay
	 * division until after sigaction() restores old handler.
	 */
	volatile int result;

	/*
	 * Save fpe_env so that fpe_handler() can jump back here.
	 * sigsetjmp() returns zero.
	 */
	code = sigsetjmp(fpe_env, 1);
	if (code == 0) {
		/* Install fpe_handler() to trap SIGFPE. */
		act.sa_sigaction = fpe_handler;
		sigemptyset(&act.sa_mask);
		act.sa_flags = SA_SIGINFO;
		if (sigaction(SIGFPE, &act, &old) < 0) {
			perror("sigaction");
			exit(1);
		}

		/* Do division. */
		result = x / y;

		/*
		 * Restore old hander, so that SIGFPE cannot jump out
		 * of a call to printf(), which might cause trouble.
		 */
		if (sigaction(SIGFPE, &old, NULL) < 0) {
			perror("sigaction");
			exit(1);
		}

		printf("%d / %d is %d\n", x, y, result);
	} else {
		/*
		 * We caught SIGFPE. Our fpe_handler() jumped to our
		 * sigsetjmp() and passes a nonzero code.
		 *
		 * But first, restore old handler.
		 */
		if (sigaction(SIGFPE, &old, NULL) < 0) {
			perror("sigaction");
			exit(1);
		}

		/* FPE_FLTDIV should never happen with integers. */
		switch (code) {
		case FPE_INTDIV: /* integer division by zero */
		case FPE_FLTDIV: /* float division by zero */
			printf("%d / %d: caught division by zero!\n", x, y);
			break;
		default:
			printf("%d / %d: caught mysterious error!\n", x, y);
			break;
		}
	}
}

/* Try some division. */
int
main()
{
	try_division(-44, 0);
	try_division(-44, 5);
	try_division(0, 5);
	try_division(0, 0);
	try_division(INT_MIN, -1);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _TYPEDEF___sigset_t {
    int32_t e0[1];
};

struct _TYPEDEF_sigset_t {
    int32_t e0[1];
};

struct __jmp_buf_tag {
    int32_t e0[8];
    int32_t e1;
    struct _TYPEDEF___sigset_t e2;
};

struct sigaction {
    void (*e0)(int32_t);
    int32_t e1;
    void (*e2)();
    struct _TYPEDEF_sigset_t e3;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ca0(void);
int64_t function_100003e6c(void);
void function_100003f00(int32_t status);
void function_100003f0c(char * s);
int32_t function_100003f18(char * format, ...);
int32_t function_100003f24(int32_t sig, struct sigaction * act, struct sigaction * oact);
void function_100003f30(struct __jmp_buf_tag env[1], int32_t val);
int64_t function_100003f3c(int64_t a1, int64_t a2);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x100008000
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void _perror(char * a1);
int32_t _printf(char * a1, ...);
int32_t _sigaction(int32_t a1, struct sigaction * a2, struct sigaction * a3);
void _siglongjmp(struct __jmp_buf_tag a1[1], int32_t a2);
int64_t _sigsetjmp(int64_t a1, int64_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003ca0 - 0x100003e6c
int64_t function_100003ca0(void) {
    int32_t v1 = _sigsetjmp((int64_t)&g1, 1); // 0x100003cc4
    int64_t v2; // bp-56, 0x100003ca0
    if (v1 == 0) {
        int64_t v3 = 0x100003e6c; // bp-40, 0x100003ce8
        if (_sigaction(8, (struct sigaction *)&v3, (struct sigaction *)&v2) < 0) {
            // 0x100003d14
            _perror("sigaction");
            _exit(1);
            // UNREACHABLE
        }
        // 0x100003d28
        if (_sigaction(8, (struct sigaction *)&v2, NULL) >= 0) {
            // 0x100003e60
            int64_t v4; // 0x100003ca0
            return _printf("%d / %d is %d\n", (int64_t)&v2, 0, v4);
        }
        // 0x100003d58
        _perror("sigaction");
        _exit(1);
        // UNREACHABLE
    }
    // 0x100003da4
    if (_sigaction(8, (struct sigaction *)&v2, NULL) < 0) {
        // 0x100003dc4
        _perror("sigaction");
        _exit(1);
        // UNREACHABLE
    }
    int64_t v5 = &v2; // 0x100003da8
    int32_t result; // 0x100003ca0
    switch (v1) {
        case 7: {
        }
        case 1: {
            // 0x100003e04
            result = _printf("%d / %d: caught division by zero!\n", v5, 0);
            // break -> 0x100003e60
            break;
        }
        default: {
            // 0x100003e30
            result = _printf("%d / %d: caught mysterious error!\n", v5, 0);
            // break -> 0x100003e60
            break;
        }
    }
    // 0x100003e60
    return result;
}

// Address range: 0x100003e6c - 0x100003e98
int64_t function_100003e6c(void) {
    // 0x100003e6c
    int64_t v1; // 0x100003e6c
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x100003e88
    _siglongjmp({(struct {int32_t e0[8]; int32_t e1; struct _TYPEDEF___sigset_t e2;}){.e0 = {(int32_t)&g1, 0, 0, 0, 0, 0, 0, 0}, .e1 = 0, .e2 = (struct {int32_t e0[1];}){.e0 = {0}}}}, v2);
    return &g2;
}

// Address range: 0x100003e98 - 0x100003f00
int64_t entry_point(void) {
    // 0x100003e98
    function_100003ca0();
    function_100003ca0();
    function_100003ca0();
    function_100003ca0();
    function_100003ca0();
    return 0;
}

// Address range: 0x100003f00 - 0x100003f0c
void function_100003f00(int32_t status) {
    // 0x100003f00
    _exit(status);
}

// Address range: 0x100003f0c - 0x100003f18
void function_100003f0c(char * s) {
    // 0x100003f0c
    _perror(s);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(char * format, ...) {
    // 0x100003f18
    return _printf(format);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(int32_t sig, struct sigaction * act, struct sigaction * oact) {
    // 0x100003f24
    return _sigaction(sig, act, oact);
}

// Address range: 0x100003f30 - 0x100003f3c
void function_100003f30(struct __jmp_buf_tag env[1], int32_t val) {
    // 0x100003f30
    _siglongjmp(env, val);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t function_100003f3c(int64_t a1, int64_t a2) {
    // 0x100003f3c
    return _sigsetjmp(a1, a2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <stdlib.h>
#define FMT "%lld"
typedef long long int fr_int_t;
typedef struct { fr_int_t num, den; } frac;

fr_int_t gcd(fr_int_t m, fr_int_t n)
{
	fr_int_t t;
	while (n) { t = n; n = m % n; m = t; }
	return m;
}

frac frac_new(fr_int_t num, fr_int_t den)
{
	frac a;
	if (!den) {
		printf("divide by zero: "FMT"/"FMT"\n", num, den);
		abort();
	}

	int g = gcd(num, den);

	if (g)	{ num /= g; den /= g; }
	else	{ num = 0; den = 1;   }

	if (den < 0) {
		den = -den;
		num = -num;
	}
	a.num = num; a.den = den;
	return a;
}

#define BINOP(op, n, d) frac frac_##op(frac a, frac b) { return frac_new(n,d); }
BINOP(add, a.num * b.den + b.num * a.den, a.den * b.den);
BINOP(sub, a.num * b.den - b.num + a.den, a.den * b.den);
BINOP(mul, a.num * b.num, a.den * b.den);
BINOP(div, a.num * b.den, a.den * b.num);

int frac_cmp(frac a, frac b) {
	int l = a.num * b.den, r = a.den * b.num;
	return l < r ? -1 : l > r;
}
#define frac_cmp_int(a, b) frac_cmp(a, frac_new(b, 1))
int frtoi(frac a) { return a.den / a.num; }
double frtod(frac a) { return (double)a.den / a.num; }

int main()
{
	int n, k;
	frac sum, kf;

	for (n = 2; n < 1<<19; n++) {
		sum = frac_new(1, n);

		for (k = 2; k * k < n; k++) {
			if (n % k) continue;
			kf = frac_new(1, k);
			sum = frac_add(sum, kf);

			kf = frac_new(1, n / k);
			sum = frac_add(sum, kf);
		}
		if (frac_cmp_int(sum, 1) == 0) printf("%d\n", n);
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039f8(void);
int64_t function_100003a54(void);
int64_t function_100003b54(float128_t a1, int64_t a2, float128_t a3, int64_t a4);
int64_t function_100003bb8(void);
int64_t function_100003c1c(void);
int64_t function_100003c70(void);
int64_t function_100003cc4(void);
int64_t function_100003d44(void);
int64_t function_100003d68(void);
void function_100003f58(void);
int32_t function_100003f64(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

void _abort(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000039f8 - 0x100003a54
int64_t function_1000039f8(void) {
    // 0x1000039f8
    int64_t v1; // 0x1000039f8
    if (v1 == 0) {
        // 0x100003a48
        int64_t result; // 0x1000039f8
        return result;
    }
    int64_t v2; // 0x1000039f8
    int64_t result2 = v2;
    int64_t v3; // 0x1000039f8
    int64_t v4 = v3 % result2;
    v3 = result2;
    while (v4 != 0) {
        // 0x100003a1c
        result2 = v4;
        v4 = v3 % result2;
        v3 = result2;
    }
    // 0x100003a48
    return result2;
}

// Address range: 0x100003a54 - 0x100003b54
int64_t function_100003a54(void) {
    // 0x100003a54
    int64_t v1; // 0x100003a54
    if (v1 == 0) {
        // 0x100003a7c
        _printf("divide by zero: %lld/%lld\n", 0, v1);
        _abort();
    }
    int64_t v2 = function_1000039f8(); // 0x100003aa8
    if ((int32_t)v2 == 0) {
        // 0x100003afc
        return 0;
    }
    int64_t v3 = 0x100000000 * v2 >> 32; // 0x100003ac8
    int64_t v4 = v1 / v3; // 0x100003ad0
    return v1 / v3 < 0 ? -v4 : v4;
}

// Address range: 0x100003b54 - 0x100003bb8
int64_t function_100003b54(float128_t a1, int64_t a2, float128_t a3, int64_t a4) {
    // 0x100003b54
    return function_100003a54();
}

// Address range: 0x100003bb8 - 0x100003c1c
int64_t function_100003bb8(void) {
    // 0x100003bb8
    return function_100003a54();
}

// Address range: 0x100003c1c - 0x100003c70
int64_t function_100003c1c(void) {
    // 0x100003c1c
    return function_100003a54();
}

// Address range: 0x100003c70 - 0x100003cc4
int64_t function_100003c70(void) {
    // 0x100003c70
    return function_100003a54();
}

// Address range: 0x100003cc4 - 0x100003d44
int64_t function_100003cc4(void) {
    // 0x100003cc4
    int64_t v1; // 0x100003cc4
    int64_t v2 = v1 * v1; // 0x100003ce0
    int32_t v3 = v2; // 0x100003ce4
    int64_t v4 = v1 * v1; // 0x100003cf0
    int32_t v5 = v3 - (int32_t)v4; // 0x100003d00
    int64_t result = v5 < 0 == ((v5 ^ v3) & (int32_t)(v2 ^ v4)) < 0 ? (int64_t)(v5 != 0) : 0xffffffff;
    return result;
}

// Address range: 0x100003d44 - 0x100003d68
int64_t function_100003d44(void) {
    // 0x100003d44
    return 1;
}

// Address range: 0x100003d68 - 0x100003d90
int64_t function_100003d68(void) {
    // 0x100003d68
    int64_t result; // 0x100003d68
    return result;
}

// Address range: 0x100003d90 - 0x100003f58
int64_t entry_point(void) {
    int32_t v1 = 2;
    int64_t v2 = function_100003a54(); // 0x100003dc8
    int32_t v3 = 4 - v1; // 0x100003df8
    float128_t v4; // 0x100003d90
    float128_t v5; // 0x100003d90
    int64_t v6; // 0x100003e90
    int32_t v7; // 0x100003ed0
    int32_t v8; // 0x100003df0
    int64_t v9; // 0x100003d90
    int64_t v10; // 0x100003e60
    if (v3 < 0 != (v3 & v1) < 0) {
        // 0x100003e08
        v7 = 2;
        v4 = (int128_t)v2;
        v5 = v4;
        if (v1 % v7 == 0) {
            // 0x100003e30
            v10 = function_100003b54(v4, v9, (float128_t)(int128_t)function_100003a54(), v9);
            v6 = function_100003a54();
            v5 = (int128_t)function_100003b54((float128_t)(int128_t)v10, v9, (float128_t)(int128_t)v6, v9);
        }
        // 0x100003ecc
        v7++;
        v8 = v7 * v7;
        while (v8 - v1 < 0 != ((v8 - v1 ^ v8) & (v8 ^ v1)) < 0) {
            // 0x100003e08
            v4 = v5;
            v5 = v4;
            if (v1 % v7 == 0) {
                // 0x100003e30
                v10 = function_100003b54(v4, v9, (float128_t)(int128_t)function_100003a54(), v9);
                v6 = function_100003a54();
                v5 = (int128_t)function_100003b54((float128_t)(int128_t)v10, v9, (float128_t)(int128_t)v6, v9);
            }
            // 0x100003ecc
            v7++;
            v8 = v7 * v7;
        }
    }
    // 0x100003edc
    function_100003a54();
    if ((int32_t)function_100003cc4() == 0) {
        // 0x100003f14
        _printf("%d\n", v9);
    }
    int32_t v11 = v1 + 1; // 0x100003f3c
    while (v1 < 0x7ffff != (0x7fffe - v1 & v11) < 0) {
        // 0x100003dc0
        v1 = v11;
        v2 = function_100003a54();
        v3 = 4 - v1;
        if (v3 < 0 != (v3 & v1) < 0) {
            // 0x100003e08
            v7 = 2;
            v4 = (int128_t)v2;
            v5 = v4;
            if (v1 % v7 == 0) {
                // 0x100003e30
                v10 = function_100003b54(v4, v9, (float128_t)(int128_t)function_100003a54(), v9);
                v6 = function_100003a54();
                v5 = (int128_t)function_100003b54((float128_t)(int128_t)v10, v9, (float128_t)(int128_t)v6, v9);
            }
            // 0x100003ecc
            v7++;
            v8 = v7 * v7;
            while (v8 - v1 < 0 != ((v8 - v1 ^ v8) & (v8 ^ v1)) < 0) {
                // 0x100003e08
                v4 = v5;
                v5 = v4;
                if (v1 % v7 == 0) {
                    // 0x100003e30
                    v10 = function_100003b54(v4, v9, (float128_t)(int128_t)function_100003a54(), v9);
                    v6 = function_100003a54();
                    v5 = (int128_t)function_100003b54((float128_t)(int128_t)v10, v9, (float128_t)(int128_t)v6, v9);
                }
                // 0x100003ecc
                v7++;
                v8 = v7 * v7;
            }
        }
        // 0x100003edc
        function_100003a54();
        if ((int32_t)function_100003cc4() == 0) {
            // 0x100003f14
            _printf("%d\n", v9);
        }
        // 0x100003f38
        v11 = v1 + 1;
    }
    // 0x100003f48
    return 0;
}

// Address range: 0x100003f58 - 0x100003f64
void function_100003f58(void) {
    // 0x100003f58
    _abort();
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#define lower_limit 0
#define upper_limit 100

int main(){
  int number, guess;

  srand( time( 0 ) );
  number = lower_limit + rand() % (upper_limit - lower_limit + 1);

  printf( "Guess the number between %d and %d: ", lower_limit, upper_limit );
  fflush(stdout);  // Flush the output buffer

  while( scanf( "%d", &guess ) == 1 ){
    if( number == guess ){
      printf( "You guessed correctly!\n" );
      break;
    }
    printf( "Your guess was too %s.\nTry again: ", number < guess ? "high" : "low" );
  }

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003ef4(struct _IO_FILE * stream);
int32_t function_100003f00(char * format, ...);
int32_t function_100003f0c(void);
int32_t function_100003f18(char * format, ...);
void function_100003f24(int32_t seed);
int32_t function_100003f30(int32_t * timer);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fflush(struct _IO_FILE * a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
int32_t _scanf(char * a1, ...);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003de8 - 0x100003ef4
int64_t entry_point(void) {
    // 0x100003de8
    _srand(_time(NULL));
    int32_t v1 = _rand(); // 0x100003e04
    int64_t v2; // 0x100003de8
    _printf("Guess the number between %d and %d: ", v2, v2);
    _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
    if (_scanf("%d", (int64_t *)v2) != 1) {
        // 0x100003ee4
        return 0;
    }
    // 0x100003e78
    int32_t v3; // 0x100003de8
    while (v1 % 101 != v3) {
        // 0x100003ea0
        _printf("Your guess was too %s.\nTry again: ", (char *)v2);
        if (_scanf("%d", (int64_t *)v2) != 1) {
            // 0x100003ee4
            return 0;
        }
    }
    // 0x100003e90
    _printf("You guessed correctly!\n");
    // 0x100003ee4
    return 0;
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(struct _IO_FILE * stream) {
    // 0x100003ef4
    return _fflush(stream);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * format, ...) {
    // 0x100003f00
    return _printf(format);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(void) {
    // 0x100003f0c
    return _rand();
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(char * format, ...) {
    // 0x100003f18
    return _scanf(format);
}

// Address range: 0x100003f24 - 0x100003f30
void function_100003f24(int32_t seed) {
    // 0x100003f24
    _srand(seed);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(int32_t * timer) {
    // 0x100003f30
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <math.h>

typedef uint32_t bitsieve;

unsigned sieve_check(bitsieve *b, const unsigned v)
{
    if ((v != 2 && !(v & 1)) || (v < 2))
        return 0;
    else
        return !(b[v >> 6] & (1 << (v >> 1 & 31)));
}

bitsieve* sieve(const unsigned v)
{
    unsigned i, j;
    bitsieve *b = calloc((v >> 6) + 1, sizeof(uint32_t));

    for (i = 3; i <= sqrt(v); i += 2)
        if (!(b[i >> 6] & (1 << (i >> 1 & 31))))
            for (j = i*i; j < v; j += (i << 1))
                b[j >> 6] |= (1 << (j >> 1 & 31));

    return b;
}

#define max(x,y) ((x) > (y) ? (x) : (y))

/* This mapping taken from python solution */
int ulam_get_map(int x, int y, int n)
{
    x -= (n - 1) / 2;
    y -= n / 2;

    int mx = abs(x), my = abs(y);
    int l = 2 * max(mx, my);
    int d = y >= x ? l * 3 + x + y : l - x - y;

    return pow(l - 1, 2) + d;
}

/* Passing a value of 0 as glyph will print numbers */
void output_ulam_spiral(int n, const char glyph)
{
    /* An even side length does not make sense, use greatest odd value < n */
    n -= n % 2 == 0 ? 1 : 0;

    const char *spaces = ".................";
    int mwidth = log10(n * n) + 1;

    bitsieve *b = sieve(n * n + 1);
    int x, y;

    for (x = 0; x < n; ++x) {
        for (y = 0; y < n; ++y) {
            int z = ulam_get_map(y, x, n);

            if (glyph == 0) {
                if (sieve_check(b, z))
                    printf("%*d ", mwidth, z);
                else
                    printf("%.*s ", mwidth, spaces);
            }
            else {
                printf("%c", sieve_check(b, z) ? glyph : spaces[0]);
            }
        }
        printf("\n");
    }

    free(b);
}

int main(int argc, char *argv[])
{
    const int n = argc < 2 ? 9 : atoi(argv[1]);

    output_ulam_spiral(n, 0);
    printf("\n");

    output_ulam_spiral(n, '#');
    printf("\n");

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000397c(void);
int64_t function_100003a10(void);
int64_t function_100003b48(void);
int64_t function_100003c80(void);
int32_t function_100003f28(int32_t x);
int32_t function_100003f34(char * nptr);
int64_t * function_100003f40(int32_t nmemb, int32_t size);
void function_100003f4c(int64_t * ptr);
float64_t function_100003f58(float64_t a1);
float64_t function_100003f64(float64_t a1, float64_t a2);
int32_t function_100003f70(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int32_t _abs(int32_t a1);
int32_t _atoi(char * a1);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
float64_t _log10(float64_t a1);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000397c - 0x100003a10
int64_t function_10000397c(void) {
    // 0x10000397c
    int64_t v1; // 0x10000397c
    uint64_t v2 = v1;
    uint32_t v3 = (int32_t)v2; // 0x100003984
    int64_t result = 0; // 0x100003994
    if (v3 >= 2 && v3 != 2 != (v3 % 2 == 0)) {
        int32_t v4 = *(int32_t *)((v2 / 16 & 0xffffffc) + v1); // 0x1000039d8
        result = (v4 & 1 << v3 / 2 % 32) == 0;
    }
    // 0x100003a04
    return result;
}

// Address range: 0x100003a10 - 0x100003b48
int64_t function_100003a10(void) {
    // 0x100003a10
    float64_t v1; // 0x100003a10
    float64_t v2 = v1;
    int64_t v3; // 0x100003a10
    uint32_t v4 = (int32_t)v3; // 0x100003a1c
    int64_t result = (int64_t)_calloc(v4 / 64 + 1, 4); // 0x100003a38
    float64_t v5 = sqrt(v1); // 0x100003a64
    float64_t v6 = v5; // 0x100003a70
    if (v2 <= v5 == (v2 != v5)) {
        // 0x100003b38
        return result;
    }
    uint32_t v7 = 3;
    int32_t v8 = *(int32_t *)((int64_t)(4 * v7 / 64) + result); // 0x100003a84
    int32_t v9; // 0x100003ab4
    int32_t * v10; // 0x100003afc
    if ((1 << v7 / 2 % 32 & v8) == 0) {
        // 0x100003aac
        v9 = v7 * v7;
        if (v9 < v4) {
            for (int32_t i = v9; i < v4; i += 2 * v7) {
                // 0x100003ad8
                v10 = (int32_t *)((int64_t)(4 * i / 64) + result);
                *v10 = 1 << i / 2 % 32 | *v10;
            }
        }
    }
    // 0x100003b28
    v6 = sqrt(v6);
    int32_t v11 = v7 + 2; // 0x100003a70
    while (v2 <= v6 != v2 != v6) {
        // 0x100003a78
        v7 = v11;
        v8 = *(int32_t *)((int64_t)(4 * v7 / 64) + result);
        if ((1 << v7 / 2 % 32 & v8) == 0) {
            // 0x100003aac
            v9 = v7 * v7;
            if (v9 < v4) {
                for (int32_t i = v9; i < v4; i += 2 * v7) {
                    // 0x100003ad8
                    v10 = (int32_t *)((int64_t)(4 * i / 64) + result);
                    *v10 = 1 << i / 2 % 32 | *v10;
                }
            }
        }
        // 0x100003b28
        v6 = sqrt(v6);
        v11 = v7 + 2;
    }
    // 0x100003b38
    return result;
}

// Address range: 0x100003b48 - 0x100003c80
int64_t function_100003b48(void) {
    // 0x100003b48
    int64_t v1; // 0x100003b48
    int32_t v2 = v1; // 0x100003b5c
    int32_t v3 = _abs((int32_t)v1 - (v2 - 1) / 2); // 0x100003b94
    int32_t v4 = _abs((int32_t)v1 - v2 / 2); // 0x100003ba0
    int32_t v5 = v3 - v4; // 0x100003bb0
    int32_t v6 = v5 == 0 | v5 < 0 != ((v5 ^ v3) & (v4 ^ v3)) < 0 ? v4 : v3;
    int128_t v7; // 0x100003b48
    _pow((float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
    __asm_sshll(0.0f, 0);
    return (float64_t)(2 * v6 - 1) + 2.0;
}

// Address range: 0x100003c80 - 0x100003e90
int64_t function_100003c80(void) {
    // 0x100003c80
    int64_t v1; // 0x100003c80
    int32_t v2 = v1; // 0x100003c9c
    int64_t v3 = v1 - (int64_t)(2 * v2 / 2 == v2); // 0x100003cc4
    int128_t v4; // 0x100003c80
    _log10((float64_t)(int64_t)v4);
    int64_t v5 = function_100003a10(); // 0x100003d0c
    int32_t v6 = v3; // 0x100003d20
    int32_t v7 = -v6;
    if (v7 < 0 == (v7 & v6) < 0) {
        // 0x100003e7c
        _free((int64_t *)v5);
        return &g1;
    }
    int64_t v8 = v3 & 0xffffffff;
    int32_t v9 = 0; // 0x100003e70
    int32_t v10 = 0; // 0x100003e50
    int64_t v11 = 0x100000000000000 * function_100003b48() >> 56;
    int64_t v12 = function_10000397c();
    int64_t v13; // 0x100003c80
    if ((uint64_t)v1 % 256 == 0) {
        // 0x100003d7c
        v13 = v11 & 0xffffffff;
        if ((int32_t)v12 == 0) {
            // 0x100003dc4
            _printf("%.*s ", v13, (char *)v8);
        } else {
            // 0x100003d98
            _printf("%*d ", v13, v8);
        }
    } else {
        // 0x100003df0
        _printf("%c", (char)v11);
    }
    // 0x100003e4c
    v10++;
    while (v10 - v6 < 0 != ((v10 - v6 ^ v10) & (v10 ^ v6)) < 0) {
        // 0x100003d54
        v11 = 0x100000000000000 * function_100003b48() >> 56;
        v12 = function_10000397c();
        if ((uint64_t)v1 % 256 == 0) {
            // 0x100003d7c
            v13 = v11 & 0xffffffff;
            if ((int32_t)v12 == 0) {
                // 0x100003dc4
                _printf("%.*s ", v13, (char *)v8);
            } else {
                // 0x100003d98
                _printf("%*d ", v13, v8);
            }
        } else {
            // 0x100003df0
            _printf("%c", (char)v11);
        }
        // 0x100003e4c
        v10++;
    }
    // 0x100003e5c
    _printf((char *)0x100003f9c);
    v9++;
    while (v9 - v6 < 0 != ((v9 - v6 ^ v9) & (v9 ^ v6)) < 0) {
        // 0x100003d54
        v10 = 0;
        v11 = 0x100000000000000 * function_100003b48() >> 56;
        v12 = function_10000397c();
        if ((uint64_t)v1 % 256 == 0) {
            // 0x100003d7c
            v13 = v11 & 0xffffffff;
            if ((int32_t)v12 == 0) {
                // 0x100003dc4
                _printf("%.*s ", v13, (char *)v8);
            } else {
                // 0x100003d98
                _printf("%*d ", v13, v8);
            }
        } else {
            // 0x100003df0
            _printf("%c", (char)v11);
        }
        // 0x100003e4c
        v10++;
        while (v10 - v6 < 0 != ((v10 - v6 ^ v10) & (v10 ^ v6)) < 0) {
            // 0x100003d54
            v11 = 0x100000000000000 * function_100003b48() >> 56;
            v12 = function_10000397c();
            if ((uint64_t)v1 % 256 == 0) {
                // 0x100003d7c
                v13 = v11 & 0xffffffff;
                if ((int32_t)v12 == 0) {
                    // 0x100003dc4
                    _printf("%.*s ", v13, (char *)v8);
                } else {
                    // 0x100003d98
                    _printf("%*d ", v13, v8);
                }
            } else {
                // 0x100003df0
                _printf("%c", (char)v11);
            }
            // 0x100003e4c
            v10++;
        }
        // 0x100003e5c
        _printf((char *)0x100003f9c);
        v9++;
    }
    // 0x100003e7c
    _free((int64_t *)v5);
    return &g1;
}

// Address range: 0x100003e90 - 0x100003f28
int64_t entry_point(void) {
    // 0x100003e90
    int64_t v1; // 0x100003e90
    int32_t v2 = v1; // 0x100003ea0
    if (v2 < 2 == (1 - v2 & v2) < 0) {
        // 0x100003ec8
        _atoi((char *)*(int64_t *)(v1 + 8));
    }
    // 0x100003edc
    function_100003c80();
    _printf("\n");
    function_100003c80();
    _printf("\n");
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(int32_t x) {
    // 0x100003f28
    return _abs(x);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * nptr) {
    // 0x100003f34
    return _atoi(nptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t nmemb, int32_t size) {
    // 0x100003f40
    return _calloc(nmemb, size);
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(int64_t * ptr) {
    // 0x100003f4c
    _free(ptr);
}

// Address range: 0x100003f58 - 0x100003f64
float64_t function_100003f58(float64_t a1) {
    // 0x100003f58
    return _log10(a1);
}

// Address range: 0x100003f64 - 0x100003f70
float64_t function_100003f64(float64_t a1, float64_t a2) {
    // 0x100003f64
    return _pow(a1, a2);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *strip(const char * str, const char *pat)
{
	/*  char replacement is typically done with lookup tables if
	 *  the replacement set can be large: it turns O(m n) into
	 *  O(m + n).
	 *  If same replacement pattern is going to be applied to many
	 *  strings, it's better to build a table beforehand and reuse it.
	 *  If charset is big like unicode, table needs to be implemented
	 *  more efficiently, say using bit field or hash table -- it
	 *  all depends on the application.
	 */
	int i = 0, tbl[128] = {0};
	while (*pat != '\0') tbl[(int)*(pat++)] = 1;

	char *ret = malloc(strlen(str) + 1);
	do {
		if (!tbl[(int)*str])
			ret[i++] = *str;
	} while (*(str++) != '\0');

	/*  assuming realloc is efficient and succeeds; if not, we could
	 *  do a two-pass, count first, alloc and strip second
	 */
	return realloc(ret, i);
}

int main()
{
	char * x = strip("She was a soul stripper. She took my heart!", "aei");
	printf(x);
	free(x);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d8c(void);
int64_t function_100003f1c(void);
void function_100003f28(int64_t * s, int32_t n);
void function_100003f34(int64_t * ptr);
int64_t * function_100003f40(int32_t size);
int32_t function_100003f4c(char * format, ...);
int64_t * function_100003f58(int64_t * ptr, int32_t size);
int32_t function_100003f64(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
void _bzero(int64_t * a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d8c - 0x100003ecc
int64_t function_100003d8c(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003da4
    int64_t v2; // bp-544, 0x100003d8c
    _bzero(&v2, 512);
    int64_t v3; // 0x100003d8c
    char v4 = *(char *)v3; // 0x100003dcc
    int64_t v5 = &v2;
    if (v4 != 0) {
        int64_t v6; // 0x100003d8c
        int64_t v7 = v6 + 1; // 0x100003de4
        *(int32_t *)(4 * (int64_t)v4 + v5) = 1;
        char v8 = *(char *)v7; // 0x100003dcc
        v6 = v7;
        while (v8 != 0) {
            // 0x100003de0
            v7 = v6 + 1;
            *(int32_t *)(4 * (int64_t)v8 + v5) = 1;
            v8 = *(char *)v7;
            v6 = v7;
        }
    }
    char * v9 = (char *)v3; // 0x100003dac
    int64_t * v10 = _malloc(_strlen(v9) + 1); // 0x100003e0c
    int32_t v11 = 0;
    char v12 = *v9; // 0x100003e1c
    char v13 = v12; // 0x100003e30
    int32_t v14 = v11; // 0x100003e30
    if (*(int32_t *)(4 * (int64_t)v12 + v5) == 0) {
        // 0x100003e38
        *(char *)((int64_t)v11 + (int64_t)v10) = v12;
        v13 = *v9;
        v14 = v11 + 1;
    }
    int32_t v15 = v14;
    char * v16 = (char *)((int64_t)v9 + 1); // 0x100003e7c
    while (v13 != 0) {
        // 0x100003e18
        v11 = v15;
        char * v17 = v16;
        v12 = *v17;
        v13 = v12;
        v14 = v11;
        if (*(int32_t *)(4 * (int64_t)v12 + v5) == 0) {
            // 0x100003e38
            *(char *)((int64_t)v11 + (int64_t)v10) = v12;
            v13 = *v17;
            v14 = v11 + 1;
        }
        // 0x100003e64
        v15 = v14;
        v16 = (char *)((int64_t)v17 + 1);
    }
    int64_t * v18 = _realloc(v10, v15); // 0x100003e8c
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003eb4
        ___stack_chk_fail();
    }
    // 0x100003eb8
    return (int64_t)v18;
}

// Address range: 0x100003ecc - 0x100003f1c
int64_t entry_point(void) {
    int64_t v1 = function_100003d8c(); // 0x100003ef4
    _printf((char *)v1);
    _free((int64_t *)v1);
    return 0;
}

// Address range: 0x100003f1c - 0x100003f28
int64_t function_100003f1c(void) {
    // 0x100003f1c
    return ___stack_chk_fail();
}

// Address range: 0x100003f28 - 0x100003f34
void function_100003f28(int64_t * s, int32_t n) {
    // 0x100003f28
    _bzero(s, n);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int64_t * ptr) {
    // 0x100003f34
    _free(ptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t size) {
    // 0x100003f40
    return _malloc(size);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t * function_100003f58(int64_t * ptr, int32_t size) {
    // 0x100003f58
    return _realloc(ptr, size);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * s) {
    // 0x100003f64
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <sys/types.h>
#include <regex.h>
#include <stdio.h>

typedef struct {
	const char *s;
	int len, prec, assoc;
} str_tok_t;

typedef struct {
	const char * str;
	int assoc, prec;
	regex_t re;
} pat_t;

enum assoc { A_NONE, A_L, A_R };
pat_t pat_eos = {"", A_NONE, 0};

pat_t pat_ops[] = {
	{"^\\)",	A_NONE, -1},
	{"^\\*\\*",	A_R, 3},
	{"^\\^",	A_R, 3},
	{"^\\*",	A_L, 2},
	{"^/",		A_L, 2},
	{"^\\+",	A_L, 1},
	{"^-",		A_L, 1},
	{0}
};

pat_t pat_arg[] = {
	{"^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?"},
	{"^[a-zA-Z_][a-zA-Z_0-9]*"},
	{"^\\(", A_L, -1},
	{0}
};

str_tok_t stack[256]; /* assume these are big enough */
str_tok_t queue[256];
int l_queue, l_stack;
#define qpush(x) queue[l_queue++] = x
#define spush(x) stack[l_stack++] = x
#define spop()   stack[--l_stack]

void display(const char *s)
{
	int i;
	printf("\033[1;1H\033[JText | %s", s);
	printf("\nStack| ");
	for (i = 0; i < l_stack; i++)
		printf("%.*s ", stack[i].len, stack[i].s); // uses C99 format strings
	printf("\nQueue| ");
	for (i = 0; i < l_queue; i++)
		printf("%.*s ", queue[i].len, queue[i].s);
	puts("\n\n<press enter>");
	getchar();
}

int prec_booster;

#define fail(s1, s2) {fprintf(stderr, "[Error %s] %s\n", s1, s2); return 0;}

int init(void)
{
	int i;
	pat_t *p;

	for (i = 0, p = pat_ops; p[i].str; i++)
		if (regcomp(&(p[i].re), p[i].str, REG_NEWLINE|REG_EXTENDED))
			fail("comp", p[i].str);

	for (i = 0, p = pat_arg; p[i].str; i++)
		if (regcomp(&(p[i].re), p[i].str, REG_NEWLINE|REG_EXTENDED))
			fail("comp", p[i].str);

	return 1;
}

pat_t* match(const char *s, pat_t *p, str_tok_t * t, const char **e)
{
	int i;
	regmatch_t m;

	while (*s == ' ') s++;
	*e = s;

	if (!*s) return &pat_eos;

	for (i = 0; p[i].str; i++) {
		if (regexec(&(p[i].re), s, 1, &m, REG_NOTEOL))
			continue;
		t->s = s;
		*e = s + (t->len = m.rm_eo - m.rm_so);
		return p + i;
	}
	return 0;
}

int parse(const char *s) {
	pat_t *p;
	str_tok_t *t, tok;

	prec_booster = l_queue = l_stack = 0;
	display(s);
	while (*s) {
		p = match(s, pat_arg, &tok, &s);
		if (!p || p == &pat_eos) fail("parse arg", s);

		/* Odd logic here. Don't actually stack the parens: don't need to. */
		if (p->prec == -1) {
			prec_booster += 100;
			continue;
		}
		qpush(tok);
		display(s);

re_op:		p = match(s, pat_ops, &tok, &s);
		if (!p) fail("parse op", s);

		tok.assoc = p->assoc;
		tok.prec = p->prec;

		if (p->prec > 0)
			tok.prec = p->prec + prec_booster;
		else if (p->prec == -1) {
			if (prec_booster < 100)
				fail("unmatched )", s);
			tok.prec = prec_booster;
		}

		while (l_stack) {
			t = stack + l_stack - 1;
			if (!(t->prec == tok.prec && t->assoc == A_L)
					&& t->prec <= tok.prec)
				break;
			qpush(spop());
			display(s);
		}

		if (p->prec == -1) {
			prec_booster -= 100;
			goto re_op;
		}

		if (!p->prec) {
			display(s);
			if (prec_booster)
				fail("unmatched (", s);
			return 1;
		}

		spush(tok);
		display(s);
	}

	if (p->prec > 0)
		fail("unexpected eol", s);

	return 1;
}

int main()
{
	int i;
	const char *tests[] = {
		"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3",	/* RC mandated: OK */
		"123",					/* OK */
		"3+4 * 2 / ( 1 - 5 ) ^ 2 ^ 3.14",	/* OK */
		"(((((((1+2+3**(4 + 5))))))",		/* bad parens */
		"a^(b + c/d * .1e5)!",			/* unknown op */
		"(1**2)**3",				/* OK */
		"2 + 2 *",				/* unexpected eol */
		0
	};

	if (!init()) return 1;
	for (i = 0; tests[i]; i++) {
		printf("Testing string %s'   <enter>\n", tests[i]);
		getchar();

		printf("string %s': %s\n\n", tests[i],
			parse(tests[i]) ? "Ok" : "Error");
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_regmatch_t {
    int32_t e0;
    int32_t e1;
};

struct re_pattern_buffer {
    char * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    int64_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000032bc(void);
int64_t function_100003420(void);
int64_t function_1000035f0(void);
int64_t function_100003750(void);
int64_t function_100003da0(int64_t a1);
int32_t function_100003dac(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003db8(void);
int64_t * function_100003dc4(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003dd0(char * format, ...);
int32_t function_100003ddc(char * s);
int32_t function_100003de8(struct re_pattern_buffer * preg, char * pattern, int32_t cflags);
int32_t function_100003df4(struct re_pattern_buffer * preg, char * string, int32_t nmatch, struct _TYPEDEF_regmatch_t pmatch[1], int32_t eflags);

// --------------------- Global Variables ---------------------

char * g1 = "\x1b[1;1H\x1b[JText | %s"; // 0x100003e61
char * g2 = "\xea>"; // 0x100004050
int64_t g3 = 0x60000000003e00; // 0x100008000
int64_t g4 = 0x60000000003e01; // 0x100008030
int64_t g5 = 0x60000000003e1d; // 0x1000081b0
int32_t * g6 = (int32_t *)0x100000cfeedfacf; // 0x100008270
int32_t * g7 = (int32_t *)0x100000c; // 0x100008274
int32_t * g8 = (int32_t *)0x200000000; // 0x100008278
float128_t * g9 = (float128_t *)0x55800000012; // 0x100008280
float128_t * g10 = NULL; // 0x100009a80

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _getchar(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);
int32_t _regcomp(struct re_pattern_buffer * a1, char * a2, int32_t a3);
int32_t _regexec(struct re_pattern_buffer * a1, char * a2, int32_t a3, struct _TYPEDEF_regmatch_t a4[1], int32_t a5);

// ------------------------ Functions -------------------------

// Address range: 0x1000032bc - 0x100003420
int64_t function_1000032bc(void) {
    // 0x1000032bc
    _printf((char *)&g1);
    _printf("\nStack| ");
    int32_t v1 = *(int32_t *)&g7; // 0x100003304
    int32_t v2 = -v1; // 0x100003308
    int64_t v3; // 0x1000032bc
    if (v2 < 0 != (v1 & v2) < 0) {
        int32_t v4 = 0; // 0x100003368
        _printf("%.*s ", v3, (char *)v3);
        v4++;
        int32_t v5 = *(int32_t *)&g7; // 0x100003304
        while (v4 - v5 < 0 != ((v4 - v5 ^ v4) & (v5 ^ v4)) < 0) {
            // 0x100003318
            _printf("%.*s ", v3, (char *)v3);
            v4++;
            v5 = *(int32_t *)&g7;
        }
    }
    // 0x100003374
    _printf("\nQueue| ");
    int32_t v6 = *(int32_t *)&g6; // 0x100003394
    int32_t v7 = -v6; // 0x100003398
    if (v7 < 0 == (v6 & v7) < 0) {
        // 0x100003404
        _puts("\n\n<press enter>");
        return _getchar();
    }
    int32_t v8 = 0; // 0x1000033f8
    _printf("%.*s ", v3, (char *)v3);
    v8++;
    int32_t v9 = *(int32_t *)&g6; // 0x100003394
    while (v8 - v9 < 0 != ((v8 - v9 ^ v8) & (v9 ^ v8)) < 0) {
        // 0x1000033a8
        _printf("%.*s ", v3, (char *)v3);
        v8++;
        v9 = *(int32_t *)&g6;
    }
    // 0x100003404
    _puts("\n\n<press enter>");
    return _getchar();
}

// Address range: 0x100003420 - 0x1000035f0
int64_t function_100003420(void) {
    int64_t v1 = g4; // 0x10000345c
    int64_t v2 = 0; // 0x10000345c
    int32_t v3 = 0; // 0x10000345c
    int64_t v4; // 0x100003420
    if (g4 != 0) {
        while (_regcomp((struct re_pattern_buffer *)(v2 + (int64_t)&g4 + 16), (char *)v1, 9) == 0) {
            // 0x100003440
            v3++;
            v2 = 48 * (int64_t)v3;
            v1 = *(int64_t *)(v2 + (int64_t)&g4);
            if (v1 == 0) {
                goto lab_0x100003514;
            }
        }
        int64_t v5 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000034ac
        _fprintf((struct _IO_FILE *)v5, "[Error %s] %s\n", (char *)9, (char *)v4);
        // 0x1000035e0
        return 0;
    }
  lab_0x100003514:;
    int64_t v6 = g5; // 0x100003530
    int64_t v7 = 0; // 0x100003530
    if (g5 == 0) {
        // 0x1000035e0
        return 1;
    }
    int32_t v8 = 0; // 0x100003530
    while (_regcomp((struct re_pattern_buffer *)(v7 + (int64_t)&g5 + 16), (char *)v6, 9) == 0) {
        int32_t v9 = v8 + 1; // 0x1000035c8
        int64_t v10 = 48 * (int64_t)v9; // 0x100003520
        int64_t v11 = *(int64_t *)(v10 + (int64_t)&g5); // 0x100003524
        v6 = v11;
        v7 = v10;
        v8 = v9;
        if (v11 == 0) {
            // 0x1000035e0
            return 1;
        }
    }
    int64_t v12 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003580
    _fprintf((struct _IO_FILE *)v12, "[Error %s] %s\n", (char *)9, (char *)v4);
    // 0x1000035e0
    return 0;
}

// Address range: 0x1000035f0 - 0x100003750
int64_t function_1000035f0(void) {
    struct _TYPEDEF_regmatch_t v1; // 0x1000036c0
    struct _TYPEDEF_regmatch_t v2[1]; // 0x1000036c0
    int64_t v3; // 0x1000035f0
    int64_t v4 = v3;
    char * v5 = (char *)v4;
    v3 = v4 + 1;
    // 0x1000035f0
    while (*v5 == 32) {
        // 0x100003610
        v4 = v3;
        v5 = (char *)v4;
        v3 = v4 + 1;
    }
    // 0x100003638
    int64_t v6; // 0x1000035f0
    int64_t * v7 = (int64_t *)v6; // 0x100003640
    *v7 = v4;
    if (*v5 == 0) {
        // 0x100003740
        return &g3;
    }
    // 0x100003674
    if (*(int64_t *)v6 == 0) {
        // 0x100003740
        return 0;
    }
    // 0x100003698
    v1 = (struct {int32_t e0; int32_t e1;}){
        .e0 = 0,
        .e1 = 0
    };
    int64_t v8; // bp-80, 0x1000035f0
    v1.e0 = &v8;
    v2[0] = v1;
    int32_t v9 = 0; // 0x10000372c
    int64_t v10; // 0x1000035f0
    int64_t result = v10;
    while (_regexec((struct re_pattern_buffer *)(result + 16), v5, 1, v2, 2) != 0) {
        // 0x100003674
        v9++;
        int64_t v11 = 48 * (int64_t)v9 + v6; // 0x100003684
        if (*(int64_t *)v11 == 0) {
            // 0x100003740
            return 0;
        }
        result = v11;
    }
    // 0x1000036d8
    *(int64_t *)v6 = v4;
    int64_t v12 = v6 - v8; // 0x1000036f0
    *(int32_t *)(v6 + 8) = (int32_t)v12;
    *v7 = (0x100000000 * v12 >> 32) + v4;
    // 0x100003740
    return result;
}

// Address range: 0x100003750 - 0x100003c4c
int64_t function_100003750(void) {
    // 0x100003750
    *(int32_t *)&g7 = 0;
    *(int32_t *)&g6 = 0;
    *(int32_t *)&g8 = 0;
    function_1000032bc();
    int32_t * v1; // 0x100003750
    int32_t v2; // 0x100003750
    int64_t result; // 0x100003750
    int64_t v3; // bp-32, 0x100003750
    int32_t v4; // 0x100003750
    float128_t v5; // bp-72, 0x100003750
    int64_t v6; // 0x100003750
    int32_t v7; // 0x100003a2c
    int64_t v8; // 0x100003750
    int64_t v9; // 0x100003750
    if ((char)v6 == 0) {
        // 0x100003750
        v1 = (int32_t *)(v6 + 12);
        goto lab_0x100003be0;
      lab_0x1000038d4_2:;
        int64_t v11 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000038dc
        _fprintf((struct _IO_FILE *)v11, "[Error %s] %s\n", &v5, &v3);
        result = 0;
        goto lab_0x100003c3c;
      lab_0x100003a5c:;
        int32_t v12 = v7 - v4; // 0x100003a68
        if (v12 == 0 || v12 < 0 != ((v12 ^ v7) & (v7 ^ v4)) < 0) {
            // break -> 0x100003ae8
            goto lab_0x100003ae8_2;
        }
        goto lab_0x100003a7c;
      lab_0x100003a7c:;
        int32_t v13 = *(int32_t *)&g6; // 0x100003a84
        *(int32_t *)&g6 = v13 + 1;
        int64_t v14 = 24 * (int64_t)v13; // 0x100003a98
        int32_t v15 = v2 - 1; // 0x100003ab4
        *(int32_t *)&g7 = v15;
        int64_t v16 = 24 * (int64_t)v15; // 0x100003ac8
        float128_t v17 = *(float128_t *)(v16 + (int64_t)&g10); // 0x100003acc
        *(float128_t *)(v14 + (int64_t)&g9) = v17;
        int64_t v18 = *(int64_t *)(v16 + (int64_t)&g10 + 16); // 0x100003ad4
        *(int64_t *)(v14 + (int64_t)&g9 + 16) = v18;
        function_1000032bc();
        int32_t v19 = *(int32_t *)&g7; // 0x1000039ec
        v2 = v19;
        if (v19 == 0) {
            // break -> 0x100003ae8
            goto lab_0x100003ae8_2;
        }
        goto lab_0x100003a00;
      lab_0x100003be0:
        // 0x100003be0
        result = 1;
        if (*v1 >= 1) {
            int64_t v10 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c00
            _fprintf((struct _IO_FILE *)v10, "[Error %s] %s\n", (char *)v8, (char *)v9);
            result = 0;
        }
      lab_0x100003c3c:
        // 0x100003c3c
        return result;
    }
    while (true) {
        int64_t v21 = function_1000035f0(); // 0x1000037bc
        int64_t v22 = v21; // 0x1000037d0
        if (v21 == 0 || v21 == (int64_t)&g3) {
            // break -> 0x1000037f4
            break;
        }
        while (*(int32_t *)(v22 + 12) == -1) {
            // 0x100003844
            *(int32_t *)&g8 = *(int32_t *)&g8 + 100;
            v22 = function_1000035f0();
            if (v22 == 0 || v22 == (int64_t)&g3) {
                // break (via goto) -> 0x1000037f4
                goto lab_0x1000037f4;
            }
        }
        int32_t v23 = *(int32_t *)&g6; // 0x100003864
        *(int32_t *)&g6 = v23 + 1;
        int64_t v24 = 24 * (int64_t)v23; // 0x100003878
        *(float128_t *)(v24 + (int64_t)&g9) = v5;
        int64_t v25; // 0x100003750
        *(int64_t *)(v24 + (int64_t)&g9 + 16) = v25;
        function_1000032bc();
        int64_t v26 = function_1000035f0(); // 0x1000038b8
        int64_t v27 = v26; // 0x1000038cc
        if (v26 == 0) {
            goto lab_0x1000038d4_2;
        }
        int32_t v28; // 0x100003750
        int32_t v29; // 0x100003910
        int32_t * v30; // 0x100003750
        while (true) {
          lab_0x10000390c:
            // 0x10000390c
            v29 = *(int32_t *)(v27 + 8);
            v30 = (int32_t *)(v27 + 12);
            int32_t v31 = *v30; // 0x100003928
            int32_t v32; // 0x100003750
            if (v31 < 1) {
                // 0x10000395c
                v32 = v31;
                if (v31 == -1) {
                    int32_t v33 = *(int32_t *)&g8; // 0x10000397c
                    v32 = v33;
                    if (v33 < 100 != (99 - v33 & v33) < 0) {
                        int64_t v34 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003998
                        _fprintf((struct _IO_FILE *)v34, "[Error %s] %s\n", &v5, &v3);
                        result = 0;
                        return result;
                    }
                }
            } else {
                // 0x10000393c
                v32 = *(int32_t *)&g8 + v31;
            }
            // 0x1000039e0
            v4 = v32;
            int32_t v35 = *(int32_t *)&g7; // 0x1000039ec
            v2 = v35;
            int32_t v36 = v31; // 0x1000039f8
            v28 = 0;
            if (v35 != 0) {
                while (true) {
                  lab_0x100003a00:;
                    int64_t v20 = 24 * (int64_t)v2; // 0x100003a10
                    v7 = *(int32_t *)(v20 + (int64_t)&g10 - 12);
                    if (v7 == v4) {
                        // 0x100003a44
                        if (*(int32_t *)(v20 + (int64_t)&g10 - 8) == 1) {
                            goto lab_0x100003a7c;
                        } else {
                            goto lab_0x100003a5c;
                        }
                    } else {
                        goto lab_0x100003a5c;
                    }
                }
              lab_0x100003ae8_2:
                // 0x100003ae8
                v36 = *v30;
                v28 = 0;
            }
            // 0x100003ae8
            switch (v36) {
                case -1: {
                    // 0x100003b00
                    *(int32_t *)&g8 = *(int32_t *)&g8 - 100;
                    int64_t v37 = function_1000035f0(); // 0x1000038b8
                    v27 = v37;
                    if (v37 == 0) {
                        goto lab_0x1000038d4_2;
                    }
                    goto lab_0x10000390c;
                }
                case 0: {
                    // 0x100003b30
                    function_1000032bc();
                    result = 1;
                    if (*(int32_t *)&g8 != 0) {
                        int64_t v38 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003b5c
                        _fprintf((struct _IO_FILE *)v38, "[Error %s] %s\n", &v5, &v3);
                        result = 0;
                    }
                    // 0x100003c3c
                    return result;
                }
                default: {
                    goto lab_0x100003b98;
                }
            }
        }
      lab_0x100003b98:;
        int64_t v39 = v29; // 0x100003914
        *(int32_t *)&g7 = v28 + 1;
        int64_t v40 = 24 * (int64_t)v28; // 0x100003bb4
        *(float128_t *)(v40 + (int64_t)&g10) = v5;
        *(int64_t *)(v40 + (int64_t)&g10 + 16) = v39;
        function_1000032bc();
        v25 = v39;
        int64_t v41; // 0x100003750
        if (*(char *)&v41 == 0) {
            // 0x100003790
            v1 = v30;
            v8 = &v5;
            v9 = &v3;
            goto lab_0x100003be0;
        }
    }
  lab_0x1000037f4:;
    int64_t v42 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000037fc
    _fprintf((struct _IO_FILE *)v42, "[Error %s] %s\n", &v5, &v3);
    // 0x100003c3c
    return 0;
}

// Address range: 0x100003c4c - 0x100003da0
int64_t entry_point(void) {
    // 0x100003c4c
    int64_t v1; // bp-88, 0x100003c4c
    _memcpy(&v1, (int64_t *)&g2, 64);
    int64_t v2 = function_100003420(); // 0x100003c80
    int64_t v3 = v2; // 0x100003c8c
    int64_t result = 1; // 0x100003c8c
    if ((int32_t)v2 != 0) {
        // 0x100003ca8
        v3 = v2;
        result = 0;
        if (v1 != 0) {
            _printf("Testing string %s'   <enter>\n", (char *)&g2);
            _getchar();
            function_100003750();
            int32_t v4 = _printf("string %s': %s\n\n", (char *)&g2, (char *)64); // 0x100003d44
            int32_t v5 = 1; // 0x100003d50
            int32_t v6 = v5; // 0x100003cbc
            while (*(int64_t *)(8 * (int64_t)v5 + (int64_t)&v1) != 0) {
                // 0x100003cc4
                _printf("Testing string %s'   <enter>\n", (char *)&g2);
                _getchar();
                function_100003750();
                v4 = _printf("string %s': %s\n\n", (char *)&g2, (char *)64);
                v5 = v6 + 1;
                v6 = v5;
            }
            // 0x100003ca8
            v3 = v4;
            result = 0;
        }
    }
    int64_t v7 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003d78
    if (v7 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003d8c
        ___stack_chk_fail(v3);
    }
    // 0x100003d90
    return result;
}

// Address range: 0x100003da0 - 0x100003dac
int64_t function_100003da0(int64_t a1) {
    // 0x100003da0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003dac - 0x100003db8
int32_t function_100003dac(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003dac
    return _fprintf(stream, format);
}

// Address range: 0x100003db8 - 0x100003dc4
int32_t function_100003db8(void) {
    // 0x100003db8
    return _getchar();
}

// Address range: 0x100003dc4 - 0x100003dd0
int64_t * function_100003dc4(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003dc4
    return _memcpy(dest, src, n);
}

// Address range: 0x100003dd0 - 0x100003ddc
int32_t function_100003dd0(char * format, ...) {
    // 0x100003dd0
    return _printf(format);
}

// Address range: 0x100003ddc - 0x100003de8
int32_t function_100003ddc(char * s) {
    // 0x100003ddc
    return _puts(s);
}

// Address range: 0x100003de8 - 0x100003df4
int32_t function_100003de8(struct re_pattern_buffer * preg, char * pattern, int32_t cflags) {
    // 0x100003de8
    return _regcomp(preg, pattern, cflags);
}

// Address range: 0x100003df4 - 0x100003e00
int32_t function_100003df4(struct re_pattern_buffer * preg, char * string, int32_t nmatch, struct _TYPEDEF_regmatch_t pmatch[1], int32_t eflags) {
    // 0x100003df4
    return _regexec(preg, string, nmatch, pmatch, eflags);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>

int main() {
  {
    unsigned long long n = 1;
    for (int i = 0; i < 30; i++) {
      // __builtin_popcount() for unsigned int
      // __builtin_popcountl() for unsigned long
      // __builtin_popcountll() for unsigned long long
      printf("%d ", __builtin_popcountll(n));
      n *= 3;
    }
    printf("\n");
  }

  int od[30];
  int ne = 0, no = 0;
  printf("evil  : ");
  for (int n = 0; ne+no < 60; n++) {
    if ((__builtin_popcount(n) & 1) == 0) {
      if (ne < 30) {
	printf("%d ", n);
	ne++;
      }
    } else {
      if (no < 30) {
	od[no++] = n;
      }
    }
  }
  printf("\n");
  printf("odious: ");
  for (int i = 0; i < 30; i++) {
    printf("%d ", od[i]);
  }
  printf("\n");

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f78(int64_t a1);
int32_t function_100003f84(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d38 - 0x100003f78
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003d4c
    int64_t v2; // 0x100003d38
    for (int32_t i = 0; i < 30; i++) {
        // 0x100003d7c
        __asm_cnt(0);
        __asm_uaddlv(0);
        _printf("%d ", v2);
    }
    // 0x100003dd0
    _printf("\n");
    _printf("evil  : ");
    int64_t v3; // bp-144, 0x100003d38
    int64_t v4 = &v3;
    int32_t v5 = 0;
    int32_t v6 = 0;
    int32_t v7 = 0;
    __asm_cnt(0);
    __asm_uaddlv(0);
    int32_t v8; // 0x100003d38
    int32_t v9; // 0x100003d38
    float32_t v10; // 0x100003d38
    if ((int32_t)v10 % 2 == 0) {
        // 0x100003e3c
        v8 = v5;
        v9 = v6;
        if (v5 < 30 != (29 - v5 & v5) < 0) {
            // 0x100003e50
            _printf("%d ", v2);
            v8 = v5 + 1;
            v9 = v6;
        }
    } else {
        // 0x100003e80
        v8 = v5;
        v9 = v6;
        if (v6 < 30 != (29 - v6 & v6) < 0) {
            // 0x100003e94
            *(int32_t *)(4 * (int64_t)v6 + v4) = v7;
            v8 = v5;
            v9 = v6 + 1;
        }
    }
    int32_t v11 = v9;
    int32_t v12 = v8;
    int32_t v13 = v11 + v12; // 0x100003e00
    int32_t v14 = v7 + 1; // 0x100003e0c
    while (v13 < 60 != (59 - v13 & v13) < 0) {
        // 0x100003e14
        v5 = v12;
        v6 = v11;
        v7 = v14;
        __asm_cnt(0);
        __asm_uaddlv(0);
        if ((int32_t)v10 % 2 == 0) {
            // 0x100003e3c
            v8 = v5;
            v9 = v6;
            if (v5 < 30 != (29 - v5 & v5) < 0) {
                // 0x100003e50
                _printf("%d ", v2);
                v8 = v5 + 1;
                v9 = v6;
            }
        } else {
            // 0x100003e80
            v8 = v5;
            v9 = v6;
            if (v6 < 30 != (29 - v6 & v6) < 0) {
                // 0x100003e94
                *(int32_t *)(4 * (int64_t)v6 + v4) = v7;
                v8 = v5;
                v9 = v6 + 1;
            }
        }
        // 0x100003ebc
        v11 = v9;
        v12 = v8;
        v13 = v11 + v12;
        v14 = v7 + 1;
    }
    // 0x100003ecc
    _printf("\n");
    _printf("odious: ");
    for (int32_t i = 0; i < 30; i++) {
        // 0x100003f00
        _printf("%d ", v2);
    }
    int32_t v15 = _printf("\n"); // 0x100003f40
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f64
        ___stack_chk_fail((int64_t)v15);
    }
    // 0x100003f68
    return 0;
}

// Address range: 0x100003f78 - 0x100003f84
int64_t function_100003f78(int64_t a1) {
    // 0x100003f78
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <wchar.h>
#include <stdlib.h>
#include <locale.h>

int main(void)
{
    /* If your native locale doesn't use UTF-8 encoding
     * you need to replace the empty string with a
     * locale like "en_US.utf8"
     */
    char *locale = setlocale(LC_ALL, "");
    FILE *in = fopen("input.txt", "r");

    wint_t c;
    while ((c = fgetwc(in)) != WEOF)
        putwchar(c);
    fclose(in);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f5c(struct _IO_FILE * stream);
int32_t function_100003f68(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f74(char * filename, char * modes);
int32_t function_100003f80(int16_t wc);
char * function_100003f8c(int32_t category, char * locale);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f98

// ------- Dynamically Linked Functions Without Header --------

int32_t _fclose(struct _IO_FILE * a1);
int32_t _fgetwc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _putwchar(int16_t a1);
char * _setlocale(int32_t a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003edc - 0x100003f5c
int64_t entry_point(void) {
    // 0x100003edc
    _setlocale(0, (char *)&g1);
    struct _IO_FILE * v1 = _fopen("input.txt", (char *)0x100003fa3); // 0x100003f10
    int32_t v2 = _fgetwc(v1); // 0x100003f20
    if (v2 == -1) {
        // 0x100003f44
        _fclose(v1);
        return 0;
    }
    _putwchar((int16_t)v2);
    int32_t v3 = _fgetwc(v1); // 0x100003f20
    while (v3 != -1) {
        // 0x100003f38
        _putwchar((int16_t)v3);
        v3 = _fgetwc(v1);
    }
    // 0x100003f44
    _fclose(v1);
    return 0;
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(struct _IO_FILE * stream) {
    // 0x100003f5c
    return _fclose(stream);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(struct _IO_FILE * stream) {
    // 0x100003f68
    return _fgetwc(stream);
}

// Address range: 0x100003f74 - 0x100003f80
struct _IO_FILE * function_100003f74(char * filename, char * modes) {
    // 0x100003f74
    return _fopen(filename, modes);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(int16_t wc) {
    // 0x100003f80
    return _putwchar(wc);
}

// Address range: 0x100003f8c - 0x100003f98
char * function_100003f8c(int32_t category, char * locale) {
    // 0x100003f8c
    return _setlocale(category, locale);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

struct ModularArithmetic {
    int value;
    int modulus;
};

struct ModularArithmetic make(const int value, const int modulus) {
    struct ModularArithmetic r = { value % modulus, modulus };
    return r;
}

struct ModularArithmetic add(const struct ModularArithmetic a, const struct ModularArithmetic b) {
    return make(a.value + b.value, a.modulus);
}

struct ModularArithmetic addi(const struct ModularArithmetic a, const int v) {
    return make(a.value + v, a.modulus);
}

struct ModularArithmetic mul(const struct ModularArithmetic a, const struct ModularArithmetic b) {
    return make(a.value * b.value, a.modulus);
}

struct ModularArithmetic pow(const struct ModularArithmetic b, int pow) {
    struct ModularArithmetic r = make(1, b.modulus);
    while (pow-- > 0) {
        r = mul(r, b);
    }
    return r;
}

void print(const struct ModularArithmetic v) {
    printf("ModularArithmetic(%d, %d)", v.value, v.modulus);
}

struct ModularArithmetic f(const struct ModularArithmetic x) {
    return addi(add(pow(x, 100), x), 1);
}

int main() {
    struct ModularArithmetic input = make(10, 13);
    struct ModularArithmetic output = f(input);

    printf("f(");
    print(input);
    printf(") = ");
    print(output);
    printf("\n");

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d08(void);
int64_t function_100003d40(int64_t a1, int64_t a2);
int64_t function_100003d7c(int64_t a1, int64_t a2);
int64_t function_100003db8(int64_t a1, int64_t a2);
int64_t function_100003df4(void);
int64_t function_100003e64(int64_t a1);
int64_t function_100003ea8(void);
int32_t function_100003f70(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d08 - 0x100003d40
int64_t function_100003d08(void) {
    // 0x100003d08
    int64_t v1; // 0x100003d08
    return (int32_t)v1 % (int32_t)v1;
}

// Address range: 0x100003d40 - 0x100003d7c
int64_t function_100003d40(int64_t a1, int64_t a2) {
    // 0x100003d40
    return function_100003d08();
}

// Address range: 0x100003d7c - 0x100003db8
int64_t function_100003d7c(int64_t a1, int64_t a2) {
    // 0x100003d7c
    return function_100003d08();
}

// Address range: 0x100003db8 - 0x100003df4
int64_t function_100003db8(int64_t a1, int64_t a2) {
    // 0x100003db8
    return function_100003d08();
}

// Address range: 0x100003df4 - 0x100003e64
int64_t function_100003df4(void) {
    // 0x100003df4
    int64_t v1; // 0x100003df4
    int32_t v2 = v1; // 0x100003e04
    int64_t result = function_100003d08(); // 0x100003e10
    int64_t result2 = result; // 0x100003e30
    if (v2 < 1) {
        // 0x100003e54
        return result;
    }
    int32_t v3 = v2;
    result2 = function_100003db8(result2, v1);
    int32_t v4 = v3 - 1; // 0x100003e30
    while (v3 >= 2) {
        // 0x100003e38
        v3 = v4;
        result2 = function_100003db8(result2, v1);
        v4 = v3 - 1;
    }
    // 0x100003e54
    return result2;
}

// Address range: 0x100003e64 - 0x100003ea8
int64_t function_100003e64(int64_t a1) {
    // 0x100003e64
    int64_t v1; // 0x100003e64
    return _printf("ModularArithmetic(%d, %d)", v1, v1);
}

// Address range: 0x100003ea8 - 0x100003ef8
int64_t function_100003ea8(void) {
    // 0x100003ea8
    int64_t v1; // 0x100003ea8
    return function_100003d7c(function_100003d40(function_100003df4(), v1), 1);
}

// Address range: 0x100003ef8 - 0x100003f70
int64_t entry_point(void) {
    int64_t v1 = function_100003d08(); // 0x100003f18
    int64_t v2 = function_100003ea8(); // 0x100003f24
    _printf("f(");
    function_100003e64(v1);
    _printf(") = ");
    function_100003e64(v2);
    _printf((char *)0x100003f9e);
    return 0;
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>

#define MAX_N 33	/* max number of tree nodes */
#define BRANCH 4	/* max number of edges a single node can have */

/* The basic idea: a paraffin molecule can be thought as a simple tree
   with each node being a carbon atom.  Counting molecules is thus the
   problem of counting free (unrooted) trees of given number of nodes.

   An unrooted tree needs to be uniquely represented, so we need a way
   to cannonicalize equivalent free trees.  For that, we need to first
   define the cannonical form of rooted trees.  Since rooted trees can
   be constructed by a root node and up to BRANCH rooted subtrees that
   are arranged in some definite order, we can define it thusly:
     * Given the root of a tree, the weight of each of its branches is
       the number of nodes contained in that branch;
     * A cannonical rooted tree would have its direct subtrees ordered
       in descending order by weight;
     * In case multiple subtrees are the same weight, they are ordered
       by some unstated, but definite, order (this code doesn't really
       care what the ordering is; it only counts the number of choices
       in such a case, not enumerating individual trees.)

   A rooted tree of N nodes can then be constructed by adding smaller,
   cannonical rooted trees to a root node, such that:
     * Each subtree has fewer than BRANCH branches (since it must have
       an empty slot for an edge to connect to the new root);
     * Weight of those subtrees added later are no higher than earlier
       ones;
     * Their weight total N-1.
   A rooted tree so constructed would be itself cannonical.

   For an unrooted tree, we can define the radius of any of its nodes:
   it's the maximum weight of any of the subtrees if this node is used
   as the root.  A node is the center of a tree if it has the smallest
   radius among all the nodes.  A tree can have either one or two such
   centers; if two, they must be adjacent (cf. Knuth, tAoCP 2.3.4.4).

   An important fact is that, a node in a tree is its sole center, IFF
   its radius times 2 is no greater than the sum of the weights of all
   branches (ibid).  While we are making rooted trees, we can add such
   trees encountered to the count of cannonical unrooted trees.

   A bi-centered unrooted tree with N nodes can be made by joining two
   trees, each with N/2 nodes and fewer than BRANCH subtrees, at root.
   The pair must be ordered in aforementioned implicit way so that the
   product is cannonical. */

typedef unsigned long long xint;
#define FMT "llu"

xint rooted[MAX_N] = {1, 1, 0};
xint unrooted[MAX_N] = {1, 1, 0};

/* choose k out of m possible values; chosen values may repeat, but the
   ordering of them does not matter.  It's binomial(m + k - 1, k) */
xint choose(xint m, xint k)
{
	xint i, r;

	if (k == 1) return m;
	for (r = m, i = 1; i < k; i++)
		r = r * (m + i) / (i + 1);
	return r;
}

/* constructing rooted trees of BR branches at root, with at most
   N radius, and SUM nodes in the partial tree already built. It's
   recursive, and CNT and L carry down the number of combinations
   and the tree radius already encountered. */
void tree(xint br, xint n, xint cnt, xint sum, xint l)
{
	xint b, c, m, s;

	for (b = br + 1; b <= BRANCH; b++) {
		s = sum + (b - br) * n;
		if (s >= MAX_N) return;

		/* First B of BR branches are all of weight n; the
		   rest are at most of weight N-1 */
		c = choose(rooted[n], b - br) * cnt;

		/* This partial tree is singly centered as is */
		if (l * 2 < s) unrooted[s] += c;

		/* Trees saturate at root can't be used as building
		   blocks for larger trees, so forget them */
		if (b == BRANCH) return;
		rooted[s] += c;

		/* Build the rest of the branches */
		for (m = n; --m; ) tree(b, m, c, s, l);
	}
}

void bicenter(int s)
{
	if (s & 1) return;

	/* Pick two of the half-size building blocks, allowing
	   repetition. */
	unrooted[s] += rooted[s/2] * (rooted[s/2] + 1) / 2;
}

int main()
{
	xint n;
	for (n = 1; n < MAX_N; n++) {
		tree(0, n, 1, 1, n);
		bicenter(n);
		printf("%"FMT": %"FMT"\n", n, unrooted[n]);
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c38(void);
int64_t function_100003ce0(void);
int64_t function_100003e60(void);
int32_t function_100003f80(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 1; // 0x100008000
int64_t g2 = 1; // 0x100008108

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c38 - 0x100003ce0
int64_t function_100003c38(void) {
    // 0x100003c38
    int64_t v1; // 0x100003c38
    uint64_t v2 = v1;
    if (v2 < 2) {
        // 0x100003cd4
        int64_t result; // 0x100003c38
        return result;
    }
    int64_t v3 = 1;
    int64_t v4 = v3 + 1; // 0x100003ca8
    int64_t v5; // 0x100003c38
    int64_t result2 = (v3 + v1) * v5 / v4; // 0x100003cac
    while (v4 != v2) {
        // 0x100003c90
        v3 = v4;
        v4 = v3 + 1;
        result2 = (v3 + v1) * result2 / v4;
    }
    // 0x100003cd4
    return result2;
}

// Address range: 0x100003ce0 - 0x100003e60
int64_t function_100003ce0(void) {
    // 0x100003ce0
    int64_t v1; // 0x100003ce0
    int64_t v2 = v1 + 1;
    int64_t result; // 0x100003ce0
    if (v2 >= 4 == (v2 != 4)) {
        // 0x100003e54
        return result;
    }
    uint64_t v3 = 2 * v1;
    int64_t v4 = v1 - 1;
    int64_t v5 = 2 * v1; // 0x100003d3c
    int64_t v6 = v2; // 0x100003d50
    if (v5 >= 33) {
        // 0x100003e54
        return result;
    }
    bool v7 = v2 == 4; // 0x100003d50
    uint64_t v8 = v5;
    int64_t v9 = function_100003c38(); // 0x100003d78
    int64_t v10 = v9 * v1; // 0x100003d80
    int64_t * v11; // 0x100003db4
    if (v8 != v3 && v8 >= v3) {
        // 0x100003da0
        v11 = (int64_t *)(8 * v8 + (int64_t)&g2);
        *v11 = *v11 + v10;
    }
    // 0x100003dc4
    result = v9;
    while (!v7) {
        int64_t * v12 = (int64_t *)(8 * v8 + (int64_t)&g1); // 0x100003df0
        *v12 = *v12 + v10;
        int64_t v13 = v9; // 0x100003e1c
        if (v4 != 0) {
            int64_t v14 = v4 - 1; // 0x100003e0c
            v13 = function_100003ce0();
            int64_t v15 = v14; // 0x100003e1c
            while (v14 != 0) {
                // 0x100003e24
                v14 = v15 - 1;
                v13 = function_100003ce0();
                v15 = v14;
            }
        }
        // 0x100003d10
        v6++;
        result = v13;
        if (v6 >= 4 == (v6 != 4)) {
            // break -> 0x100003e54
            break;
        }
        int64_t v16 = (v6 - v1) * v1 + v1; // 0x100003d3c
        v7 = v6 == 4;
        result = v13;
        if (v16 >= 33) {
            // break -> 0x100003e54
            break;
        }
        v8 = v16;
        v9 = function_100003c38();
        v10 = v9 * v1;
        if (v8 != v3 && v8 >= v3) {
            // 0x100003da0
            v11 = (int64_t *)(8 * v8 + (int64_t)&g2);
            *v11 = *v11 + v10;
        }
        // 0x100003dc4
        result = v9;
    }
    // 0x100003e54
    return result;
}

// Address range: 0x100003e60 - 0x100003edc
int64_t function_100003e60(void) {
    // 0x100003e60
    int64_t result; // 0x100003e60
    int32_t v1 = result; // 0x100003e64
    if (v1 % 2 == 0) {
        int64_t v2 = *(int64_t *)((int64_t)(8 * v1 / 2) + (int64_t)&g1); // 0x100003e94
        int64_t * v3 = (int64_t *)((0x100000000 * result >> 29) + (int64_t)&g2); // 0x100003ec4
        *v3 = (v2 + 1) * v2 / 2 + *v3;
    }
    // 0x100003ed4
    return result;
}

// Address range: 0x100003edc - 0x100003f80
int64_t entry_point(void) {
    for (int64_t i = 1; i < 33; i++) {
        // 0x100003f0c
        function_100003ce0();
        function_100003e60();
        _printf("%llu: %llu\n", i, 1);
    }
    // 0x100003f70
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>


#define MAXLEN 100
typedef char TWord[MAXLEN];


typedef struct WordsArray {
    TWord *words;
    size_t len;
} WordsArray;


int is_ordered_word(const TWord word) {
    assert(word != NULL);
    int i;

    for (i = 0; word[i] != '\0'; i++)
        if (word[i] > word[i + 1] && word[i + 1] != '\0')
            return 0;

    return 1;
}


void array_append(WordsArray *words_array, const TWord new_word) {
    assert(words_array != NULL);
    assert(new_word != NULL);
    assert((words_array->len == 0) == (words_array->words == NULL));

    words_array->len++;
    words_array->words = realloc(words_array->words,
                                 words_array->len * sizeof(words_array->words[0]));
    if (words_array->words == NULL)
        exit(EXIT_FAILURE);
    strcpy(words_array->words[words_array->len-1], new_word);
}


void array_free(WordsArray *words_array) {
    assert(words_array != NULL);
    free(words_array->words);
    words_array->words = NULL;
    words_array->len = 0;
}


void list_print(WordsArray *words_array) {
    assert(words_array != NULL);
    size_t i;
    for (i = 0; i < words_array->len; i++)
        printf("\n%s", words_array->words[i]);
}


int main() {
    FILE *fp = fopen("unixdict.txt", "r");
    if (fp == NULL)
        return EXIT_FAILURE;

    WordsArray words;
    words.len = 0;
    words.words = NULL;

    TWord line;
    line[0] = '\0';
    unsigned int max_len = 0;

    while (fscanf(fp, "%99s\n", line) != EOF) { // 99 = MAXLEN - 1
        if (strlen(line) > max_len && is_ordered_word(line)) {
            max_len = strlen(line);
            array_free(&words);
            array_append(&words, line);
        } else if (strlen(line) == max_len && is_ordered_word(line)) {
            array_append(&words, line);
        }
    }

    fclose(fp);
    list_print(&words);
    array_free(&words);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038e8(void);
int64_t function_1000039e4(void);
int64_t function_100003b74(void);
int64_t function_100003bf0(void);
int64_t function_100003e5c(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003e68(void);
int64_t function_100003e74(int64_t a1, int64_t a2, int64_t a3);
void function_100003e80(int32_t status);
int32_t function_100003e8c(struct _IO_FILE * stream);
struct _IO_FILE * function_100003e98(char * filename, char * modes);
void function_100003ea4(int64_t * ptr);
int32_t function_100003eb0(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003ebc(char * format, ...);
int64_t * function_100003ec8(int64_t * ptr, int32_t size);
int32_t function_100003ed4(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(void);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000038e8 - 0x1000039e4
int64_t function_1000038e8(void) {
    // 0x1000038e8
    int64_t v1; // 0x1000038e8
    if (v1 == 0) {
        // 0x100003918
        ___assert_rtn("is_ordered_word", "ordered-words-2.c", 18, "word != NULL");
    }
    int32_t v2 = 0; // 0x100003940
    char v3 = *(char *)(v1 + (int64_t)v2); // 0x10000394c
    int64_t result = 1; // 0x100003958
    while (v3 != 0) {
        int32_t v4 = v3; // 0x100003968
        v2++;
        char v5 = *(char *)(v1 + (int64_t)v2); // 0x100003978
        int32_t v6 = v4 - (int32_t)v5; // 0x10000397c
        result = 0;
        if (v5 != 0 && v6 != 0 && v6 < 0 == ((v6 ^ v4) & (int32_t)(v5 ^ v3)) < 0) {
            // break -> 0x1000039d4
            break;
        }
        v3 = *(char *)(v1 + (int64_t)v2);
        result = 1;
    }
    // 0x1000039d4
    return result;
}

// Address range: 0x1000039e4 - 0x100003b74
int64_t function_1000039e4(void) {
    // 0x1000039e4
    int64_t v1; // 0x1000039e4
    int64_t v2; // 0x1000039e4
    if (v1 == 0) {
        // 0x100003a18
        v2 = ___assert_rtn("array_append", "ordered-words-2.c", 30, "words_array != NULL");
    }
    int64_t v3 = v2; // 0x100003a54
    if (v1 == 0) {
        // 0x100003a5c
        v3 = ___assert_rtn("array_append", "ordered-words-2.c", 31, "new_word != NULL");
    }
    int64_t * v4 = (int64_t *)(v1 + 8); // 0x100003a84
    int64_t v5 = *v4; // 0x100003a84
    int64_t v6 = v5; // 0x100003abc
    int64_t v7 = v3; // 0x100003abc
    if (v5 == 0 != (v3 == 0)) {
        // 0x100003ac4
        v7 = ___assert_rtn("array_append", "ordered-words-2.c", 32, "(words_array->len == 0) == (words_array->words == NULL)");
        v6 = *v4;
    }
    int64_t v8 = v6 + 1; // 0x100003af0
    *v4 = v8;
    int64_t * v9 = _realloc((int64_t *)v7, 100 * (int32_t)v8); // 0x100003b10
    int64_t v10 = (int64_t)v9; // 0x100003b10
    *(int64_t *)v1 = v10;
    if (v9 != NULL) {
        // 0x100003b3c
        return ___strcpy_chk(v10 - 100 + 100 * *v4, v1, -1);
    }
    // 0x100003b34
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100003b74 - 0x100003bf0
int64_t function_100003b74(void) {
    // 0x100003b74
    int64_t v1; // 0x100003b74
    int64_t v2; // 0x100003b74
    if (v1 == 0) {
        // 0x100003ba4
        v2 = ___assert_rtn("array_free", "ordered-words-2.c", 44, "words_array != NULL");
    }
    // 0x100003bc8
    _free((int64_t *)v2);
    *(int64_t *)v1 = 0;
    *(int64_t *)(v1 + 8) = 0;
    return &g1;
}

// Address range: 0x100003bf0 - 0x100003cb4
int64_t function_100003bf0(void) {
    // 0x100003bf0
    int64_t v1; // 0x100003bf0
    int64_t v2; // 0x100003bf0
    if (v1 == 0) {
        // 0x100003c20
        ___assert_rtn("list_print", "ordered-words-2.c", 52, "words_array != NULL");
        v2 = (int64_t)"ordered-words-2.c";
    }
    // 0x100003c44
    int32_t result; // 0x100003c90
    for (int64_t i = 0; i < *(int64_t *)(v1 + 8); i++) {
        // 0x100003c68
        result = _printf("\n%s", (char *)v2);
    }
    // 0x100003ca8
    return result;
}

// Address range: 0x100003cb4 - 0x100003e5c
int64_t entry_point(void) {
    struct _IO_FILE * v1 = _fopen("unixdict.txt", "r"); // 0x100003ce4
    int64_t result = 1; // 0x100003cf8
    char v2; // bp-124, 0x100003cb4
    int32_t v3; // 0x100003cb4
    int32_t v4; // 0x100003cb4
    int32_t v5; // 0x100003cb4
    uint64_t v6; // 0x100003d54
    char ** v7; // 0x100003d38
    if (v1 != NULL) {
        // 0x100003d0c
        v2 = 0;
        int64_t v8; // 0x100003cb4
        v7 = (char **)v8;
        v3 = 0;
        if (_fscanf(v1, "%99s\n", v7) != -1) {
            while (true) {
              lab_0x100003d4c:
                // 0x100003d4c
                v4 = v3;
                uint64_t v9 = (int64_t)_strlen(&v2); // 0x100003d50
                v6 = (int64_t)v4;
                if (v9 == v6 || v9 < v6) {
                    goto lab_0x100003db0;
                } else {
                    // 0x100003d68
                    if ((int32_t)function_1000038e8() == 0) {
                        goto lab_0x100003db0;
                    } else {
                        int32_t v10 = _strlen(&v2); // 0x100003d88
                        function_100003b74();
                        function_1000039e4();
                        v5 = v10;
                        goto lab_0x100003df8;
                    }
                }
            }
        }
      lab_0x100003dfc:
        // 0x100003dfc
        _fclose(v1);
        function_100003bf0();
        function_100003b74();
        result = 0;
    }
    int64_t v11 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003e34
    if (v11 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003e48
        ___stack_chk_fail();
    }
    // 0x100003e4c
    return result;
  lab_0x100003db0:;
    int32_t v12 = _strlen(&v2); // 0x100003db4
    v5 = v4;
    if ((int64_t)v12 == v6) {
        // 0x100003dcc
        v5 = v4;
        if ((int32_t)function_1000038e8() != 0) {
            // 0x100003de4
            function_1000039e4();
            v5 = v4;
        }
    }
    goto lab_0x100003df8;
  lab_0x100003df8:
    // 0x100003df8
    v3 = v5;
    if (_fscanf(v1, "%99s\n", v7) == -1) {
        // break -> 0x100003dfc
        goto lab_0x100003dfc;
    }
    goto lab_0x100003d4c;
}

// Address range: 0x100003e5c - 0x100003e68
int64_t function_100003e5c(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003e5c
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003e68 - 0x100003e74
int64_t function_100003e68(void) {
    // 0x100003e68
    return ___stack_chk_fail();
}

// Address range: 0x100003e74 - 0x100003e80
int64_t function_100003e74(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003e74
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003e80 - 0x100003e8c
void function_100003e80(int32_t status) {
    // 0x100003e80
    _exit(status);
}

// Address range: 0x100003e8c - 0x100003e98
int32_t function_100003e8c(struct _IO_FILE * stream) {
    // 0x100003e8c
    return _fclose(stream);
}

// Address range: 0x100003e98 - 0x100003ea4
struct _IO_FILE * function_100003e98(char * filename, char * modes) {
    // 0x100003e98
    return _fopen(filename, modes);
}

// Address range: 0x100003ea4 - 0x100003eb0
void function_100003ea4(int64_t * ptr) {
    // 0x100003ea4
    _free(ptr);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003eb0
    return _fscanf(stream, format);
}

// Address range: 0x100003ebc - 0x100003ec8
int32_t function_100003ebc(char * format, ...) {
    // 0x100003ebc
    return _printf(format);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t * function_100003ec8(int64_t * ptr, int32_t size) {
    // 0x100003ec8
    return _realloc(ptr, size);
}

// Address range: 0x100003ed4 - 0x100003ee0
int32_t function_100003ed4(char * s) {
    // 0x100003ed4
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`#include <stdio.h>

int main()
{
        unsigned int i = 0;
        do { printf("%o\n", i++); } while(i);
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f98(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f30 - 0x100003f98
int64_t entry_point(void) {
    int32_t v1 = 0; // 0x100003f44
    v1++;
    int64_t v2; // 0x100003f30
    _printf("%o\n", (int32_t)v2);
    while (v1 != 0) {
        // 0x100003f48
        v1++;
        _printf("%o\n", (int32_t)v2);
    }
    // 0x100003f88
    return 0;
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * format, ...) {
    // 0x100003f98
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>

typedef unsigned uint;
int is_prime(uint n)
{
        if (!(n%2) || !(n%3)) return 0;
        uint p = 1;
        while(p*p < n)
                if (n%(p += 4) == 0 || n%(p += 2) == 0)
                        return 0;
        return 1;
}

uint reverse(uint n)
{
        uint r;
        for (r = 0; n; n /= 10)
                r = r*10 + (n%10);
        return r;
}

int is_emirp(uint n)
{
        uint r = reverse(n);
        return r != n && is_prime(n) && is_prime(r);
}

int main(int argc, char **argv)
{
        uint x, c = 0;
        switch(argc) { // advanced args parsing
        case 1: for (x = 11; c < 20; x += 2)
                        if (is_emirp(x))
                                printf(" %u", x), ++c;
                break;

        case 2: for (x = 7701; x < 8000; x += 2)
                        if (is_emirp(x))
                                printf(" %u", x);
                break;

        default:
                for (x = 11; ; x += 2)
                        if (is_emirp(x) && ++c == 10000) {
                                printf("%u", x);
                                break;
                        }
        }

        putchar('\n');
        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bc0(void);
int64_t function_100003cc0(void);
int64_t function_100003d2c(void);
int32_t function_100003f80(char * format, ...);
int32_t function_100003f8c(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003bc0 - 0x100003cc0
int64_t function_100003bc0(void) {
    // 0x100003bc0
    int64_t v1; // 0x100003bc0
    uint32_t v2 = (int32_t)v1; // 0x100003bc4
    if (v2 % 3 == 0 || 2 * v2 / 2 == v2) {
        // 0x100003cb4
        return 0;
    }
    int32_t v3 = 1; // 0x100003c78
    int64_t result = 1; // 0x100003c3c
    while (v3 * v3 < v2) {
        // 0x100003c44
        result = 0;
        if (v2 % (v3 + 4) == 0) {
            // break -> 0x100003cb4
            break;
        }
        // 0x100003c70
        v3 += 6;
        result = 0;
        if (v2 % v3 == 0) {
            // break -> 0x100003cb4
            break;
        }
        result = 1;
    }
    // 0x100003cb4
    return result;
}

// Address range: 0x100003cc0 - 0x100003d2c
int64_t function_100003cc0(void) {
    // 0x100003cc0
    int64_t v1; // 0x100003cc0
    int32_t v2 = v1; // 0x100003cc4
    uint32_t v3 = v2; // 0x100003cdc
    if (v2 == 0) {
        // 0x100003d20
        return 0;
    }
    int32_t result = 0; // 0x100003cdc
    result = 10 * result + v3 % 10;
    while (v3 >= 10) {
        // 0x100003ce4
        v3 /= 10;
        result = 10 * result + v3 % 10;
    }
    // 0x100003d20
    return result;
}

// Address range: 0x100003d2c - 0x100003db4
int64_t function_100003d2c(void) {
    // 0x100003d2c
    int64_t v1; // 0x100003d2c
    if ((int32_t)function_100003cc0() == (int32_t)v1) {
        // 0x100003da0
        return 0;
    }
    int64_t result = 0; // 0x100003d80
    if ((int32_t)function_100003bc0() != 0) {
        // 0x100003d88
        result = (int32_t)function_100003bc0() != 0;
    }
    // 0x100003da0
    return result;
}

// Address range: 0x100003db4 - 0x100003f80
int64_t entry_point(void) {
    int32_t v1 = 0; // 0x100003db4
    int64_t v2; // 0x100003db4
    int64_t v3; // 0x100003db4
    switch ((int32_t)v3) {
        case 1: {
            int32_t v4 = 0;
            int32_t v5 = v4; // 0x100003e2c
            if ((int32_t)function_100003d2c() != 0) {
                // 0x100003e34
                _printf(" %u", (int32_t)v2);
                v5 = v4 + 1;
            }
            int32_t v6 = v5;
            while (v6 < 20) {
                // 0x100003e1c
                v4 = v6;
                v5 = v4;
                if ((int32_t)function_100003d2c() != 0) {
                    // 0x100003e34
                    _printf(" %u", (int32_t)v2);
                    v5 = v4 + 1;
                }
                // 0x100003e64
                v6 = v5;
            }
            // break -> 0x100003f68
            break;
        }
        case 2: {
            for (int32_t i = 0x1e15; i < 0x1f3f; i += 2) {
                // 0x100003e9c
                if ((int32_t)function_100003d2c() != 0) {
                    // 0x100003eb4
                    _printf(" %u", (int32_t)v2);
                }
            }
            // break -> 0x100003f68
            break;
        }
        default: {
            while (true) {
                int32_t v7 = v1;
                v1 = v7;
                if ((int32_t)function_100003d2c() != 0) {
                    // 0x100003f10
                    v1 = v7 + 1;
                    if (v7 == 0x270f) {
                        // break -> 0x100003f30
                        break;
                    }
                }
            }
            // 0x100003f30
            _printf("%u", (int32_t)v2);
            // 0x100003f68
            _putchar(10);
            return 0;
        }
    }
    // 0x100003f68
    _putchar(10);
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(int32_t c) {
    // 0x100003f8c
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int myopenimage(const char *in)
{
  static int handle=0;
  fprintf(stderr, "internal openimage opens %s...\n", in);
  return handle++;
}

int main()
{
  void *imglib;
  int (*extopenimage)(const char *);
  int imghandle;

  imglib = dlopen("./fakeimglib.so", RTLD_LAZY);
  if ( imglib != NULL ) {
    /* extopenimage = (int (*)(const char *))dlsym(imglib,...)
       "man dlopen" says that C99 standard leaves casting from
       "void *" to a function pointer undefined. The following is the
       POSIX.1-2003 workaround found in man */
    *(void **)(&extopenimage) = dlsym(imglib, "openimage");
    /* the following works with gcc, gives no warning even with
       -Wall -std=c99 -pedantic options... :D */
    /* extopenimage = dlsym(imglib, "openimage"); */
    imghandle = extopenimage("fake.img");
  } else {
    imghandle = myopenimage("fake.img");
  }
  printf("opened with handle %d\n", imghandle);
  /* ... */
  if (imglib != NULL ) dlclose(imglib);
  return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003dfc(char * a1);
int32_t function_100003f10(int64_t * handle);
int64_t * function_100003f1c(char * file, int32_t mode);
int64_t * function_100003f28(int64_t * handle, char * name);
int32_t function_100003f34(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f40(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _dlclose(int64_t * a1);
int64_t * _dlopen(char * a1, int32_t a2);
int64_t * _dlsym(int64_t * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dfc - 0x100003e4c
int64_t function_100003dfc(char * a1) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003e14
    int64_t v2; // 0x100003dfc
    _fprintf((struct _IO_FILE *)v1, "internal openimage opens %s...\n", (char *)v2);
    uint32_t result = g1; // 0x100003e34
    g1 = result + 1;
    return result;
}

// Address range: 0x100003e4c - 0x100003f10
int64_t entry_point(void) {
    int64_t * v1 = _dlopen("./fakeimglib.so", 1); // 0x100003e68
    if (v1 != NULL) {
        // 0x100003e84
        _dlsym(v1, "openimage");
        return (int64_t)"fake.img";
    }
    // 0x100003eb0
    function_100003dfc("fake.img");
    _printf("opened with handle %d\n", 1);
    return 0;
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(int64_t * handle) {
    // 0x100003f10
    return _dlclose(handle);
}

// Address range: 0x100003f1c - 0x100003f28
int64_t * function_100003f1c(char * file, int32_t mode) {
    // 0x100003f1c
    return _dlopen(file, mode);
}

// Address range: 0x100003f28 - 0x100003f34
int64_t * function_100003f28(int64_t * handle, char * name) {
    // 0x100003f28
    return _dlsym(handle, name);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f34
    return _fprintf(stream, format);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(char * format, ...) {
    // 0x100003f40
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`/*------------------------------------------------------------------*/
/* For C23 without need of a garbage collector. */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/*------------------------------------------------------------------*/

/* We need consistent definitions of division and remainder. Let us
   set those here. For convenience (because C provides it), we will
   use truncation towards zero. */
#define DIV(a, b) ((a) / (b))
#define REM(a, b) ((a) % (b))

/* Choose a memory allocator. (Ideally one should check for NULL
   return values, but for this pedagogical example let us skip
   that.) */
#define MALLOC_INIT() do { } while (0) /* A no-op. */
#define MALLOC malloc
#define REALLOC realloc
#define FREE free

/*------------------------------------------------------------------*/
/* The basics. */

/* The integer type. */
typedef long long int integer;

/* A generator is a recursive type that forms a tree. */
typedef struct generator *generator_t;
typedef struct generator_list *generator_list_t;
struct generator_list
{
  generator_t car;
  generator_list_t cdr;
};
typedef void generator_func_t (integer *workspace,
                               generator_list_t sources,
                               bool *term_exists,
                               integer *term);
struct generator
{
  generator_func_t *run;     /* What does the work. */
  size_t worksize;           /* The size of the workspace. */
  integer *initial;          /* The initial value of the workspace. */
  integer *workspace;        /* The workspace itself. */
  generator_list_t sources;  /* The sources of input terms. */
};

/* Reinitializes a generator. (Needed because there is no
   memoization.) */
void generator_t_initialize (generator_t);

/* Frees a generator. */
void generator_t_free (generator_t);

/*------------------------------------------------------------------*/
/* A function to print the output of a generator in a form suitable
   for eqn/troff. */

void ftroff_generator_output (FILE *, generator_t, int max_terms);

/*------------------------------------------------------------------*/
/* Some functions to make generators. */

/* For a rational number. */
generator_t r2cf_make (integer n, integer d);

/* For the square root of 2. */
generator_t sqrt2_make (void);

/* For a homographic function. */
generator_t hfunc_make (integer a1, integer a, integer b1, integer b,
                        generator_t source);

/*------------------------------------------------------------------*/
/* Implementations. */

void
generator_t_initialize (generator_t gen)
{
  if (gen != NULL)
    {
      memcpy (gen->workspace, gen->initial,
              gen->worksize * sizeof (integer));
      for (generator_list_t p = gen->sources; p != NULL; p = p->cdr)
        generator_t_initialize (p->car);
    }
}

void
generator_t_free (generator_t gen)
{
  if (gen != NULL)
    {
      FREE (gen->initial);
      FREE (gen->workspace);

      generator_list_t p = gen->sources;
      while (p != NULL)
        {
          generator_list_t q = p->cdr;
          generator_t_free (p->car);
          FREE (p);
          p = q;
        }

      FREE (gen);
    }
}

/*  -    -    -    -    -    -    -    -    -    -    -    -    -   */

void
ftroff_generator_output (FILE *outf, generator_t gen, int max_terms)
{
  assert (1 <= max_terms);

  generator_t_initialize (gen);

  int terms_count = 0;
  int sep = 0;
  bool done = false;
  while (!done)
    {
      if (terms_count == max_terms)
        {
          fprintf (outf, ", ~ ... ~ ]");
          done = true;
        }
      else
        {
          bool term_exists;
          integer term;
          gen->run (gen->workspace, gen->sources, &term_exists,
                    &term);
          if (term_exists)
            {
              switch (sep)
                {
                case 0:
                  fprintf (outf, "[ ^ ");
                  sep = 1;
                  break;
                case 1:
                  fprintf (outf, "; ^ ");
                  sep = 2;
                  break;
                default:
                  fprintf (outf, " , ");
                  break;
                }
              fprintf (outf, "%jd", (intmax_t) term);
              terms_count += 1;
            }
          else
            {
              fprintf (outf, "^ ] ");
              done = true;
            }
        }
    }

  generator_t_initialize (gen);
}

/*  -    -    -    -    -    -    -    -    -    -    -    -    -   */

static void
r2cf_run (integer *workspace,
          [[maybe_unused]] generator_list_t sources,
          bool *term_exists, integer *term)
{
  integer d = workspace[1];
  *term_exists = (d != 0);
  if (*term_exists)
    {
      integer n = workspace[0];
      integer q = DIV (n, d);
      integer r = REM (n, d);
      workspace[0] = d;
      workspace[1] = r;
      *term = q;
    }
}

generator_t
r2cf_make (integer n, integer d)
{
  generator_t gen = MALLOC (sizeof (*gen));
  gen->run = r2cf_run;
  gen->worksize = 2;
  gen->initial = MALLOC (gen->worksize * sizeof (integer));
  gen->workspace = MALLOC (gen->worksize * sizeof (integer));
  gen->initial[0] = n;
  gen->initial[1] = d;
  memcpy (gen->workspace, gen->initial,
          gen->worksize * sizeof (integer));
  gen->sources = NULL;
  return gen;
}

/*  -    -    -    -    -    -    -    -    -    -    -    -    -   */

static void
sqrt2_run (integer *workspace,
           [[maybe_unused]] generator_list_t sources,
           bool *term_exists, integer *term)
{
  *term_exists = true;
  *term = workspace[0];
  workspace[0] = 2;
}

generator_t
sqrt2_make (void)
{
  generator_t gen = MALLOC (sizeof (*gen));
  gen->run = sqrt2_run;
  gen->worksize = 1;
  gen->initial = MALLOC (gen->worksize * sizeof (integer));
  gen->workspace = MALLOC (gen->worksize * sizeof (integer));
  gen->initial[0] = 1;
  memcpy (gen->workspace, gen->initial,
          gen->worksize * sizeof (integer));
  gen->sources = NULL;
  return gen;
}

/*  -    -    -    -    -    -    -    -    -    -    -    -    -   */

static void
hfunc_take_term (integer *workspace, generator_list_t sources)
{
  generator_t src = sources->car;
  bool term_exists1;
  integer term1;
  src->run (src->workspace, src->sources, &term_exists1, &term1);
  integer a1 = workspace[0];
  integer b1 = workspace[2];
  if (term_exists1)
    {
      integer a = workspace[1];
      integer b = workspace[3];
      workspace[0] = a + (a1 * term1);
      workspace[1] = a1;
      workspace[2] = b + (b1 * term1);
      workspace[3] = b1;
    }
  else
    {
      workspace[1] = a1;
      workspace[3] = b1;
    }
}

static void
hfunc_run (integer *workspace, generator_list_t sources,
           bool *term_exists, integer *term)
{
  bool done = false;
  while (!done)
    {
      integer b1 = workspace[2];
      integer b = workspace[3];
      if (b1 == 0 && b == 0)
        {
          *term_exists = false;
          done = true;
        }
      else
        {
          integer a1 = workspace[0];
          integer a = workspace[1];
          if (b1 != 0 && b != 0)
            {
              integer q1 = DIV (a1, b1);
              integer q = DIV (a, b);
              if (q1 == q)
                {
                  workspace[0] = b1;
                  workspace[1] = b;
                  workspace[2] = a1 - (b1 * q);
                  workspace[3] = a - (b * q);
                  *term_exists = true;
                  *term = q;
                  done = true;
                }
              else
                hfunc_take_term (workspace, sources);
            }
          else
            hfunc_take_term (workspace, sources);
        }
    }
}

generator_t
hfunc_make (integer a1, integer a, integer b1, integer b,
            generator_t source)
{
  generator_t gen = MALLOC (sizeof (*gen));
  gen->run = hfunc_run;
  gen->worksize = 4;
  gen->initial = MALLOC (gen->worksize * sizeof (integer));
  gen->workspace = MALLOC (gen->worksize * sizeof (integer));
  gen->initial[0] = a1;
  gen->initial[1] = a;
  gen->initial[2] = b1;
  gen->initial[3] = b;
  memcpy (gen->workspace, gen->initial,
          gen->worksize * sizeof (integer));
  gen->sources = MALLOC (sizeof (struct generator_list));
  gen->sources->car = source;
  gen->sources->cdr = NULL;
  return gen;
}

/*------------------------------------------------------------------*/
/* Components of the demonstration. */

#define MAX_TERMS 20
#define GOES_TO " ~ -> ~ "
#define START_EQ ".EQ\n"
#define STOP_EQ "\n.EN\n"
#define NEW_LINE "\n"

void
ftroff_rational_number (FILE *outf, integer n, integer d)
{
  generator_t gen = r2cf_make (n, d);
  fprintf (outf, "%s %jd over %jd %s",
           START_EQ, (intmax_t) n, (intmax_t) d, GOES_TO);
  ftroff_generator_output (outf, gen, MAX_TERMS);
  fprintf (outf, "%s%s", STOP_EQ, NEW_LINE);
  generator_t_free (gen);
}

void
ftroff_sqrt2 (FILE *outf)
{
  generator_t gen = sqrt2_make ();
  fprintf (outf, "%s sqrt 2 %s", START_EQ, GOES_TO);
  ftroff_generator_output (outf, gen, MAX_TERMS);
  fprintf (outf, "%s%s", STOP_EQ, NEW_LINE);
  generator_t_free (gen);
}

void
ftroff_hfunc_of_rational_number (FILE *outf,
                                 const char *expr,
                                 integer a1, integer a,
                                 integer b1, integer b,
                                 integer n, integer d)
{
  generator_t gen = hfunc_make (a1, a, b1, b, r2cf_make (n, d));
  fprintf (outf, "%s %s %s", START_EQ, expr, GOES_TO);
  ftroff_generator_output (outf, gen, MAX_TERMS);
  fprintf (outf, "%s%s", STOP_EQ, NEW_LINE);
  generator_t_free (gen);
}

void
ftroff_hfunc_of_sqrt2 (FILE *outf, const char *expr,
                       integer a1, integer a, integer b1, integer b)
{
  generator_t gen = hfunc_make (a1, a, b1, b, sqrt2_make ());
  fprintf (outf, "%s %s %s", START_EQ, expr, GOES_TO);
  ftroff_generator_output (outf, gen, MAX_TERMS);
  fprintf (outf, "%s%s", STOP_EQ, NEW_LINE);
  generator_t_free (gen);
}

void
ftroff_complicated (FILE *outf)
{
  /* This function demonstrates a more complicated nesting of
     generators. */

  /* gen1 = 1/sqrt(2) */
  generator_t gen1 = hfunc_make (0, 1, 1, 0, sqrt2_make ());

  /* gen2 = 1 + gen1 */
  generator_t gen2 = hfunc_make (1, 1, 0, 1, gen1);

  /* gen = gen2 / 2 */
  generator_t gen = hfunc_make (1, 0, 0, 2, gen2);

  fprintf (outf, "%s {1 ~ + ~ { 1 over { sqrt 2 } }} over 2 %s",
           START_EQ, GOES_TO);
  ftroff_generator_output (outf, gen, MAX_TERMS);
  fprintf (outf, "%s%s", STOP_EQ, NEW_LINE);

  generator_t_free (gen);
}

/*------------------------------------------------------------------*/

int
main (void)
{
  MALLOC_INIT ();

  FILE *outf = stdout;

  /* Output is for "eqn -Tpdf | groff -Tpdf -P-p6i,5.5i -ms" */

  fprintf (outf, ".nr PO 0.25i\n");
  fprintf (outf, ".nr HM 0.25i\n");
  fprintf (outf, ".ps 14\n");

  ftroff_rational_number (outf, 13, 11);
  ftroff_rational_number (outf, 22, 7);
  ftroff_sqrt2 (outf);
  ftroff_hfunc_of_rational_number
    (outf, "{ 13 over 11 } ~ + ~ { 1 over 2 }",
     2, 1, 0, 2, 13, 11);
  ftroff_hfunc_of_rational_number
    (outf, "{ 22 over 7 } ~ + ~ { 1 over 2 }",
     2, 1, 0, 2, 22, 7);
  ftroff_hfunc_of_rational_number
    (outf, "{ ^ {\"\\s-3\" 22 over 7 \"\\s+3\"}} over 4",
     1, 0, 0, 4, 22, 7);
  ftroff_hfunc_of_sqrt2
    (outf, "{ sqrt 2 } over 2", 1, 0, 0, 2);
  ftroff_hfunc_of_sqrt2
    (outf, "1 over { sqrt 2 }", 0, 1, 1, 0);
  ftroff_hfunc_of_sqrt2
    (outf, "{ 2 ~ + ~ { sqrt 2 }} over 4", 1, 2, 0, 4);
  ftroff_complicated (outf);

  return 0;
}

/*------------------------------------------------------------------*/
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002eb0(void);
int64_t function_100002f4c(void);
int64_t function_100002ff0(int64_t a1, int64_t a2);
int64_t function_1000031b4(void);
int64_t function_10000327c(void);
int64_t function_10000332c(void);
int64_t function_1000033e0(void);
int64_t function_100003424(void);
int64_t function_10000353c(void);
int64_t function_1000036e0(void);
int64_t function_100003794(void);
int64_t function_100003828(void);
int64_t function_100003920(void);
int64_t function_100003a08(void);
int64_t function_100003c88(void);
int64_t function_100003ccc(int64_t a1);
int64_t function_100003d84(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003d90(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003d9c(struct _IO_FILE * stream, char * format, ...);
void function_100003da8(int64_t * ptr);
int64_t * function_100003db4(int32_t size);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100002eb0 - 0x100002f4c
int64_t function_100002eb0(void) {
    // 0x100002eb0
    int64_t v1; // 0x100002eb0
    int64_t v2 = v1;
    if (v2 == 0) {
        // 0x100002f40
        return 0;
    }
    int64_t v3 = *(int64_t *)(v2 + 8); // 0x100002ee8
    int64_t result = ___memcpy_chk(*(int64_t *)(v2 + 24), *(int64_t *)(v2 + 16), 8 * v3, -1); // 0x100002ef4
    int64_t v4 = *(int64_t *)(v2 + 32);
    if (v4 == 0) {
        // 0x100002f40
        return result;
    }
    int64_t v5 = v4; // 0x100002f14
    int64_t result2 = function_100002eb0(); // 0x100002f24
    v5 += 8;
    while (v5 != 0) {
        // 0x100002f1c
        result2 = function_100002eb0();
        v5 += 8;
    }
    // 0x100002f40
    return result2;
}

// Address range: 0x100002f4c - 0x100002ff0
int64_t function_100002f4c(void) {
    // 0x100002f4c
    int64_t v1; // 0x100002f4c
    if (v1 == 0) {
        // 0x100002fe4
        return 0;
    }
    // 0x100002f70
    _free((int64_t *)*(int64_t *)(v1 + 16));
    _free((int64_t *)*(int64_t *)(v1 + 24));
    int64_t v2 = *(int64_t *)(v1 + 32); // 0x100002f8c
    if (v2 == 0) {
        // 0x100002fd8
        _free((int64_t *)v1);
        // 0x100002fe4
        return &g1;
    }
    int64_t v3 = *(int64_t *)(v2 + 8); // 0x100002fb0
    function_100002f4c();
    _free((int64_t *)v2);
    while (v3 != 0) {
        int64_t v4 = v3;
        v3 = *(int64_t *)(v4 + 8);
        function_100002f4c();
        _free((int64_t *)v4);
    }
    // 0x100002fd8
    _free((int64_t *)v1);
    // 0x100002fe4
    return &g1;
}

// Address range: 0x100002ff0 - 0x1000031b4
int64_t function_100002ff0(int64_t a1, int64_t a2) {
    // 0x100002ff0
    int64_t v1; // 0x100002ff0
    int32_t v2 = v1; // 0x100003004
    int32_t v3 = 1 - v2; // 0x100003010
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x10000302c
        ___assert_rtn("ftroff_generator_output", "continued-fraction-arithmetic-g-matrix-ng-continued-fraction-n--2.c", 121, "1 <= max_terms");
    }
    // 0x100003050
    function_100002eb0();
    if (v2 != 0) {
        // 0x1000030a8
        return *(int64_t *)(v1 + 24);
    }
    // 0x10000308c
    _fprintf((struct _IO_FILE *)v1, ", ~ ... ~ ]");
    return function_100002eb0();
}

// Address range: 0x1000031b4 - 0x10000327c
int64_t function_1000031b4(void) {
    int64_t * v1 = _malloc(40); // 0x1000031cc
    int64_t result = (int64_t)v1; // 0x1000031cc
    *v1 = 0x10000327c;
    int64_t * v2 = (int64_t *)(result + 8); // 0x1000031ec
    *v2 = 2;
    int64_t * v3 = _malloc(16); // 0x1000031fc
    int64_t * v4 = (int64_t *)(result + 16); // 0x100003204
    *v4 = (int64_t)v3;
    int64_t * v5 = _malloc(8 * (int32_t)*v2); // 0x100003214
    int64_t * v6 = (int64_t *)(result + 24); // 0x10000321c
    *v6 = (int64_t)v5;
    ___memcpy_chk(*v6, *v4, 8 * *v2, -1);
    *(int64_t *)(result + 32) = 0;
    return result;
}

// Address range: 0x10000327c - 0x10000332c
int64_t function_10000327c(void) {
    // 0x10000327c
    int64_t result; // 0x10000327c
    int64_t * v1 = (int64_t *)(result + 8); // 0x100003294
    int64_t v2 = *v1; // 0x100003294
    *(char *)result = (char)(v2 != 0);
    int64_t v3; // 0x10000327c
    if (*(char *)&v3 % 2 != 0) {
        // 0x1000032c8
        *(int64_t *)result = v2;
        *v1 = result % v2;
        *(int64_t *)result = result / v2;
    }
    // 0x100003324
    return result;
}

// Address range: 0x10000332c - 0x1000033e0
int64_t function_10000332c(void) {
    int64_t * v1 = _malloc(40); // 0x10000333c
    int64_t result = (int64_t)v1; // 0x10000333c
    *v1 = 0x1000033e0;
    int64_t * v2 = (int64_t *)(result + 8); // 0x100003360
    *v2 = 1;
    int64_t * v3 = _malloc(8); // 0x100003370
    int64_t * v4 = (int64_t *)(result + 16); // 0x100003378
    *v4 = (int64_t)v3;
    int64_t * v5 = _malloc(8 * (int32_t)*v2); // 0x100003388
    int64_t * v6 = (int64_t *)(result + 24); // 0x100003394
    *v6 = (int64_t)v5;
    *(int64_t *)*v4 = 1;
    ___memcpy_chk(*v6, *v4, 8 * *v2, -1);
    *(int64_t *)(result + 32) = 0;
    return result;
}

// Address range: 0x1000033e0 - 0x100003424
int64_t function_1000033e0(void) {
    // 0x1000033e0
    int64_t result; // 0x1000033e0
    *(char *)result = 1;
    *(int64_t *)result = 2;
    return result;
}

// Address range: 0x100003424 - 0x10000353c
int64_t function_100003424(void) {
    int64_t * v1 = _malloc(40); // 0x100003448
    int64_t result = (int64_t)v1; // 0x100003448
    *v1 = 0x10000353c;
    int64_t * v2 = (int64_t *)(result + 8); // 0x100003468
    *v2 = 4;
    int64_t * v3 = _malloc(32); // 0x100003478
    int64_t * v4 = (int64_t *)(result + 16); // 0x100003480
    *v4 = (int64_t)v3;
    int64_t * v5 = _malloc(8 * (int32_t)*v2); // 0x100003490
    int64_t * v6 = (int64_t *)(result + 24); // 0x100003498
    *v6 = (int64_t)v5;
    ___memcpy_chk(*v6, *v4, 8 * *v2, -1);
    int64_t * v7 = _malloc(16); // 0x100003504
    int64_t * v8 = (int64_t *)(result + 32); // 0x10000350c
    *v8 = (int64_t)v7;
    *(int64_t *)(*v8 + 8) = 0;
    return result;
}

// Address range: 0x10000353c - 0x1000036e0
int64_t function_10000353c(void) {
    // 0x10000353c
    int64_t v1; // 0x10000353c
    char * v2 = (char *)v1; // 0x100003550
    int64_t * v3 = (int64_t *)(v1 + 16); // 0x100003570
    int64_t * v4 = (int64_t *)(v1 + 24); // 0x10000357c
    int64_t * v5 = (int64_t *)(v1 + 8);
    int64_t v6 = *v3; // 0x100003570
    int64_t v7 = *v4; // 0x10000357c
    int64_t v8 = v7; // 0x100003590
    int64_t v9 = v6; // 0x100003590
    int64_t result; // 0x10000353c
    if ((v7 || v6) == 0) {
        // 0x1000035ac
        *v2 = 0;
        // 0x1000036d4
        return result;
    }
    int64_t v10; // 0x10000353c
    int64_t v11; // 0x10000353c
    int64_t v12; // 0x1000035d0
    int64_t v13; // 0x100003608
    int64_t result2; // 0x10000353c
    while (true) {
        // 0x1000035c0
        v11 = v9;
        v10 = v8;
        int64_t v14; // 0x10000353c
        int64_t v15; // 0x10000353c
        if (v11 == 0 || v10 == 0) {
            // 0x1000036bc
            v15 = function_100003c88();
        } else {
            // 0x100003600
            result2 = v14;
            v12 = *v5;
            v13 = result2 / v11;
            if (v13 == v12 / v10) {
                // break -> 0x100003638
                break;
            }
            // 0x1000036a8
            v15 = function_100003c88();
        }
        // 0x1000036d0
        v9 = *v3;
        v8 = *v4;
        result = v15;
        v14 = v15;
        if ((v8 || v9) == 0) {
            // 0x1000035ac
            *v2 = 0;
            // 0x1000036d4
            return result;
        }
    }
    // 0x100003638
    *(int64_t *)v1 = v11;
    *v5 = v10;
    *v3 = result2 - v13 * v11;
    *v4 = v12 - v13 * v10;
    *v2 = 1;
    *(int64_t *)v1 = v13;
    // 0x1000036d4
    return result2;
}

// Address range: 0x1000036e0 - 0x100003794
int64_t function_1000036e0(void) {
    // 0x1000036e0
    function_1000031b4();
    int64_t v1; // 0x1000036e0
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x100003740
    _fprintf(v2, "%s %jd over %jd %s", (char *)v1, v1, v1, (char *)v1);
    function_100002ff0((int64_t)&g1, (int64_t)&g1);
    _fprintf(v2, "%s%s", (char *)20, (char *)v1);
    return function_100002f4c();
}

// Address range: 0x100003794 - 0x100003828
int64_t function_100003794(void) {
    // 0x100003794
    function_10000332c();
    int64_t v1; // 0x100003794
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x1000037d4
    char * v3 = (char *)v1; // 0x1000037d4
    _fprintf(v2, "%s sqrt 2 %s", (char *)v1, v3);
    function_100002ff0((int64_t)&g1, (int64_t)&g1);
    _fprintf(v2, "%s%s", (char *)20, v3);
    return function_100002f4c();
}

// Address range: 0x100003828 - 0x100003920
int64_t function_100003828(void) {
    int64_t v1 = function_1000031b4(); // 0x10000387c
    function_100003424();
    int64_t v2; // 0x100003828
    struct _IO_FILE * v3 = (struct _IO_FILE *)v2; // 0x1000038cc
    char * v4 = (char *)v2; // 0x1000038cc
    _fprintf(v3, "%s %s %s", (char *)v2, v4, (char *)v1);
    function_100002ff0((int64_t)&g1, (int64_t)&g1);
    _fprintf(v3, "%s%s", (char *)20, v4);
    return function_100002f4c();
}

// Address range: 0x100003920 - 0x100003a08
int64_t function_100003920(void) {
    int64_t v1 = function_10000332c(); // 0x100003964
    function_100003424();
    int64_t v2; // 0x100003920
    struct _IO_FILE * v3 = (struct _IO_FILE *)v2; // 0x1000039b4
    char * v4 = (char *)v2; // 0x1000039b4
    _fprintf(v3, "%s %s %s", (char *)v2, v4, (char *)v1);
    function_100002ff0((int64_t)&g1, (int64_t)&g1);
    _fprintf(v3, "%s%s", (char *)20, v4);
    return function_100002f4c();
}

// Address range: 0x100003a08 - 0x100003af8
int64_t function_100003a08(void) {
    // 0x100003a08
    function_10000332c();
    function_100003424();
    function_100003424();
    function_100003424();
    int64_t v1; // 0x100003a08
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x100003aa4
    _fprintf(v2, "%s {1 ~ + ~ { 1 over { sqrt 2 } }} over 2 %s", NULL, (char *)2);
    function_100002ff0((int64_t)&g1, (int64_t)&g1);
    _fprintf(v2, "%s%s", (char *)20, (char *)2);
    return function_100002f4c();
}

// Address range: 0x100003af8 - 0x100003c88
int64_t entry_point(void) {
    struct _IO_FILE * v1 = (struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010; // 0x100003b2c
    _fprintf(v1, ".nr PO 0.25i\n");
    _fprintf(v1, ".nr HM 0.25i\n");
    _fprintf(v1, ".ps 14\n");
    function_1000036e0();
    function_1000036e0();
    function_100003794();
    function_100003828();
    function_100003828();
    function_100003828();
    function_100003920();
    function_100003920();
    function_100003920();
    function_100003a08();
    return 0;
}

// Address range: 0x100003c88 - 0x100003ccc
int64_t function_100003c88(void) {
    // 0x100003c88
    int64_t v1; // 0x100003c88
    return *(int64_t *)(v1 + 24);
}

// Address range: 0x100003ccc - 0x100003d84
int64_t function_100003ccc(int64_t a1) {
    // 0x100003ccc
    int64_t result; // 0x100003ccc
    int64_t * v1 = (int64_t *)(result - 8); // 0x100003ccc
    int64_t v2 = *v1; // 0x100003ccc
    int64_t * v3 = (int64_t *)v2; // 0x100003cd0
    int64_t v4 = *v3; // 0x100003cd0
    int64_t v5 = *(int64_t *)(v2 + 16); // 0x100003cdc
    int64_t * v6 = (int64_t *)(v2 + 8);
    if (*(char *)(result - 25) % 2 == 0) {
        // 0x100003d5c
        *v6 = v4;
        *(int64_t *)(*v1 + 24) = v5;
    } else {
        // 0x100003cf0
        *v3 = *v6 + v4 * a1;
        *(int64_t *)(*v1 + 8) = v4;
        *(int64_t *)(*v1 + 16) = *(int64_t *)(v2 + 24) + v5 * a1;
        *(int64_t *)(*v1 + 24) = v5;
    }
    // 0x100003d78
    return result;
}

// Address range: 0x100003d84 - 0x100003d90
int64_t function_100003d84(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003d84
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003d90 - 0x100003d9c
int64_t function_100003d90(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003d90
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003d9c - 0x100003da8
int32_t function_100003d9c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003d9c
    return _fprintf(stream, format);
}

// Address range: 0x100003da8 - 0x100003db4
void function_100003da8(int64_t * ptr) {
    // 0x100003da8
    _free(ptr);
}

// Address range: 0x100003db4 - 0x100003dc0
int64_t * function_100003db4(int32_t size) {
    // 0x100003db4
    return _malloc(size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 22

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <locale.h>

bool *primeSieve(int limit) {
    int i, p;
    limit++;
    // True denotes composite, false denotes prime.
    bool *c = calloc(limit, sizeof(bool)); // all false by default
    c[0] = true;
    c[1] = true;
    for (i = 4; i < limit; i += 2) c[i] = true;
    p = 3; // Start from 3.
    while (true) {
        int p2 = p * p;
        if (p2 >= limit) break;
        for (i = p2; i < limit; i += 2 * p) c[i] = true;
        while (true) {
            p += 2;
            if (!c[p]) break;
        }
    }
    return c;
}

int main() {
    const int limit = 1000000;
    int i, j, n, uc = 2, p = 10, m = 63, ul = 151000;
    bool *c = primeSieve(limit);
    n = m * limit + 1;
    int *sumDivs = (int *)calloc(n, sizeof(int));
    for (i = 1; i < n; ++i) {
        for (j = i; j < n; j += i) sumDivs[j] += i;
    }
    bool *s = (bool *)calloc(n, sizeof(bool)); // all false
    for (i = 1; i < n; ++i) {
        int sum = sumDivs[i] - i; // proper divs sum
        if (sum <= n) s[sum] = true;
    }
    free(sumDivs);
    int *untouchable = (int *)malloc(ul * sizeof(int));
    untouchable[0] = 2;
    untouchable[1] = 5;
    for (n = 6; n <= limit; n += 2) {
        if (!s[n] && c[n-1] && c[n-3]) untouchable[uc++] = n;
    }
    setlocale(LC_NUMERIC, "");
    printf("List of untouchable numbers <= 2,000:\n");
    for (i = 0; i < uc; ++i) {
        j = untouchable[i];
        if (j > 2000) break;
        printf("%'6d ", j);
        if (!((i+1) % 10)) printf("\n");
    }
    printf("\n\n%'7d untouchable numbers were found  <=     2,000\n", i);
    for (i = 0; i < uc; ++i) {
        j = untouchable[i];
        if (j > p) {
            printf("%'7d untouchable numbers were found  <= %'9d\n", i, p);
            p *= 10;
            if (p == limit) break;
        }
    }
    printf("%'7d untouchable numbers were found  <= %'d\n", uc, limit);
    free(c);
    free(s);
    free(untouchable);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038f0(void);
int64_t * function_100003eac(int32_t nmemb, int32_t size);
void function_100003eb8(int64_t * ptr);
int64_t * function_100003ec4(int32_t size);
int32_t function_100003ed0(char * format, ...);
char * function_100003edc(int32_t category, char * locale);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003ee8

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
char * _setlocale(int32_t a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x1000038f0 - 0x100003a50
int64_t function_1000038f0(void) {
    // 0x1000038f0
    int64_t v1; // 0x1000038f0
    int32_t v2 = v1; // 0x1000038fc
    int32_t v3 = v2 + 1; // 0x100003904
    int64_t * v4 = _calloc(v3, 1); // 0x100003914
    int64_t result = (int64_t)v4; // 0x100003914
    *(char *)v4 = 1;
    *(char *)(result + 1) = 1;
    int32_t v5 = 3 - v2; // 0x100003944
    int32_t v6 = 4; // 0x10000394c
    if (v5 < 0 != (v5 & v3) < 0) {
        *(char *)((int64_t)v6 + result) = 1;
        v6 += 2;
        while (v6 - v3 < 0 != ((v6 - v3 ^ v6) & (v6 ^ v3)) < 0) {
            // 0x100003954
            *(char *)((int64_t)v6 + result) = 1;
            v6 += 2;
        }
    }
    int32_t v7 = 8 - v2; // 0x1000039a0
    if (v7 < 0 == (v7 & v3) < 0) {
        // 0x100003a40
        return result;
    }
    int32_t v8 = 3;
    int32_t v9 = 9;
    int32_t v10 = v9 - v3; // 0x1000039c8
    int32_t v11; // 0x100003a00
    if (v10 < 0 != ((v10 ^ v9) & (v9 ^ v3)) < 0) {
        // 0x1000039d8
        v11 = v9;
        *(char *)((int64_t)v11 + result) = 1;
        v11 += 2 * v8;
        while (v11 - v3 < 0 != ((v11 - v3 ^ v11) & (v11 ^ v3)) < 0) {
            // 0x1000039d8
            *(char *)((int64_t)v11 + result) = 1;
            v11 += 2 * v8;
        }
    }
    int32_t v12 = v8 + 2; // 0x100003a14
    int32_t v13 = v12; // 0x100003a2c
    while (*(char *)((int64_t)v12 + result) % 2 != 0) {
        // 0x100003a10
        v12 = v13 + 2;
        v13 = v12;
    }
    int32_t v14 = v12 * v12; // 0x100003990
    while (v14 - v3 < 0 != ((v14 - v3 ^ v14) & (v14 ^ v3)) < 0) {
        // 0x1000039c0
        v8 = v12;
        v9 = v14;
        v10 = v9 - v3;
        if (v10 < 0 != ((v10 ^ v9) & (v9 ^ v3)) < 0) {
            // 0x1000039d8
            v11 = v9;
            *(char *)((int64_t)v11 + result) = 1;
            v11 += 2 * v8;
            while (v11 - v3 < 0 != ((v11 - v3 ^ v11) & (v11 ^ v3)) < 0) {
                // 0x1000039d8
                *(char *)((int64_t)v11 + result) = 1;
                v11 += 2 * v8;
            }
        }
        // 0x100003a10
        v12 = v8 + 2;
        v13 = v12;
        while (*(char *)((int64_t)v12 + result) % 2 != 0) {
            // 0x100003a10
            v12 = v13 + 2;
            v13 = v12;
        }
        // 0x100003988
        v14 = v12 * v12;
    }
    // 0x100003a40
    return result;
}

// Address range: 0x100003a50 - 0x100003eac
int64_t entry_point(void) {
    int64_t v1 = function_1000038f0(); // 0x100003a94
    int64_t * v2 = _calloc(0x3c14dc1, 4); // 0x100003ac0
    int64_t v3 = (int64_t)v2; // 0x100003ac0
    int32_t v4 = 1;
    int32_t v5 = v4; // 0x100003b08
    int32_t * v6; // 0x100003b20
    int32_t v7; // 0x100003b38
    if (v4 < 0x3c14dc1 != (0x3c14dc0 - v4 & v4) < 0) {
        v6 = (int32_t *)(4 * (int64_t)v5 + v3);
        *v6 = *v6 + v4;
        v7 = v5 + v4;
        v5 = v7;
        while (v7 < 0x3c14dc1 != (0x3c14dc0 - v7 & v7) < 0) {
            // 0x100003b10
            v6 = (int32_t *)(4 * (int64_t)v5 + v3);
            *v6 = *v6 + v4;
            v7 = v5 + v4;
            v5 = v7;
        }
    }
    int32_t v8 = v4 + 1; // 0x100003b4c
    while (v4 < 0x3c14dc0 != (0x3c14dbf - v4 & v8) < 0) {
        // 0x100003af8
        v4 = v8;
        v5 = v4;
        if (v4 < 0x3c14dc1 != (0x3c14dc0 - v4 & v4) < 0) {
            v6 = (int32_t *)(4 * (int64_t)v5 + v3);
            *v6 = *v6 + v4;
            v7 = v5 + v4;
            v5 = v7;
            while (v7 < 0x3c14dc1 != (0x3c14dc0 - v7 & v7) < 0) {
                // 0x100003b10
                v6 = (int32_t *)(4 * (int64_t)v5 + v3);
                *v6 = *v6 + v4;
                v7 = v5 + v4;
                v5 = v7;
            }
        }
        // 0x100003b48
        v8 = v4 + 1;
    }
    int64_t * v9 = _calloc(0x3c14dc1, 1); // 0x100003b60
    int64_t v10 = (int64_t)v9; // 0x100003b60
    int32_t v11 = 1;
    int32_t v12 = *(int32_t *)(4 * (int64_t)v11 + v3) - v11; // 0x100003b9c
    int32_t v13 = v12 - 0x3c14dc1; // 0x100003bac
    if (v13 == 0 || v13 < 0 != (0x3c14dc0 - v12 & v12) < 0) {
        // 0x100003bbc
        *(char *)((int64_t)v12 + v10) = 1;
    }
    int32_t v14 = v11 + 1; // 0x100003bdc
    while (v11 < 0x3c14dc0 != (0x3c14dbf - v11 & v14) < 0) {
        // 0x100003b8c
        v11 = v14;
        v12 = *(int32_t *)(4 * (int64_t)v11 + v3) - v11;
        v13 = v12 - 0x3c14dc1;
        if (v13 == 0 || v13 < 0 != (0x3c14dc0 - v12 & v12) < 0) {
            // 0x100003bbc
            *(char *)((int64_t)v12 + v10) = 1;
        }
        // 0x100003bd8
        v14 = v11 + 1;
    }
    // 0x100003be8
    _free(v2);
    int64_t * v15 = _malloc(0x93760); // 0x100003bf8
    int64_t v16 = (int64_t)v15; // 0x100003bf8
    *(int32_t *)v15 = 2;
    *(int32_t *)(v16 + 4) = 5;
    int32_t v17 = 2;
    int32_t v18 = 6;
    int32_t v19 = v17; // 0x100003c4c
    if (*(char *)((int64_t)v18 + v10) % 2 == 0) {
        // 0x100003c54
        v19 = v17;
        if (*(char *)(v1 + (int64_t)(v18 - 1)) % 2 != 0) {
            // 0x100003c70
            v19 = v17;
            if (*(char *)(v1 + (int64_t)(v18 - 3)) % 2 != 0) {
                // 0x100003c8c
                *(int32_t *)(4 * (int64_t)v17 + v16) = v18;
                v19 = v17 + 1;
            }
        }
    }
    int32_t v20 = v19;
    int32_t v21 = v18 + 2; // 0x100003cb4
    while (v18 == 0xf423e || v18 < 0xf423e != (0xf423d - v18 & v21) < 0) {
        // 0x100003c3c
        v17 = v20;
        v18 = v21;
        v19 = v17;
        if (*(char *)((int64_t)v18 + v10) % 2 == 0) {
            // 0x100003c54
            v19 = v17;
            if (*(char *)(v1 + (int64_t)(v18 - 1)) % 2 != 0) {
                // 0x100003c70
                v19 = v17;
                if (*(char *)(v1 + (int64_t)(v18 - 3)) % 2 != 0) {
                    // 0x100003c8c
                    *(int32_t *)(4 * (int64_t)v17 + v16) = v18;
                    v19 = v17 + 1;
                }
            }
        }
        // 0x100003cb0
        v20 = v19;
        v21 = v18 + 2;
    }
    // 0x100003cc0
    _setlocale(4, (char *)&g1);
    _printf("List of untouchable numbers <= 2,000:\n");
    int32_t v22 = -v20;
    int32_t v23 = 0; // 0x100003cf4
    int64_t v24; // 0x100003a50
    if (v22 < 0 == (v20 & v22) < 0) {
        // 0x100003d8c
        _printf("\n\n%'7d untouchable numbers were found  <=     2,000\n", (int64_t)&g1);
        // 0x100003e5c
        _printf("%'7d untouchable numbers were found  <= %'d\n", (int64_t)&g1, v24);
        _free((int64_t *)v1);
        _free(v9);
        _free(v15);
        return 0;
    }
    int32_t v25 = *(int32_t *)(4 * (int64_t)v23 + v16); // 0x100003d04
    while (v25 == 2000 || v25 < 2000 != (1999 - v25 & v25) < 0) {
        // 0x100003d24
        _printf("%'6d ", (int64_t)&g1);
        v23++;
        if (v23 % 10 == 0) {
            // 0x100003d68
            _printf("\n");
        }
        int32_t v26 = v23 - v20; // 0x100003cec
        if (v26 < 0 == ((v26 ^ v23) & (v23 ^ v20)) < 0) {
            // break -> 0x100003dc8
            break;
        }
        v25 = *(int32_t *)(4 * (int64_t)v23 + v16);
    }
    // 0x100003dc8
    _printf("\n\n%'7d untouchable numbers were found  <=     2,000\n", (int64_t)&g1);
    int32_t v27 = 0; // 0x100003e50
    int32_t v28 = 10;
    int32_t v29 = *(int32_t *)(4 * (int64_t)v27 + v16); // 0x100003dd0
    int32_t v30 = v29 - v28; // 0x100003de0
    int32_t v31 = v28; // 0x100003de8
    if (v30 != 0 && v30 < 0 == ((v30 ^ v29) & (v29 ^ v28)) < 0) {
        // 0x100003df0
        _printf("%'7d untouchable numbers were found  <= %'9d\n", (int64_t)&g1, v24);
        v31 = 10 * v28;
        if (v31 == 0xf4240) {
            // break -> 0x100003e5c
            break;
        }
    }
    // 0x100003e4c
    v27++;
    while (v27 - v20 < 0 != ((v27 - v20 ^ v27) & (v27 ^ v20)) < 0) {
        // 0x100003dc8
        v28 = v31;
        v29 = *(int32_t *)(4 * (int64_t)v27 + v16);
        v30 = v29 - v28;
        v31 = v28;
        if (v30 != 0 && v30 < 0 == ((v30 ^ v29) & (v29 ^ v28)) < 0) {
            // 0x100003df0
            _printf("%'7d untouchable numbers were found  <= %'9d\n", (int64_t)&g1, v24);
            v31 = 10 * v28;
            if (v31 == 0xf4240) {
                // break -> 0x100003e5c
                break;
            }
        }
        // 0x100003e4c
        v27++;
    }
    // 0x100003e5c
    _printf("%'7d untouchable numbers were found  <= %'d\n", (int64_t)&g1, v24);
    _free((int64_t *)v1);
    _free(v9);
    _free(v15);
    return 0;
}

// Address range: 0x100003eac - 0x100003eb8
int64_t * function_100003eac(int32_t nmemb, int32_t size) {
    // 0x100003eac
    return _calloc(nmemb, size);
}

// Address range: 0x100003eb8 - 0x100003ec4
void function_100003eb8(int64_t * ptr) {
    // 0x100003eb8
    _free(ptr);
}

// Address range: 0x100003ec4 - 0x100003ed0
int64_t * function_100003ec4(int32_t size) {
    // 0x100003ec4
    return _malloc(size);
}

// Address range: 0x100003ed0 - 0x100003edc
int32_t function_100003ed0(char * format, ...) {
    // 0x100003ed0
    return _printf(format);
}

// Address range: 0x100003edc - 0x100003ee8
char * function_100003edc(int32_t category, char * locale) {
    // 0x100003edc
    return _setlocale(category, locale);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

typedef int bool;

int next_in_cycle(int *c, int len, int index) {
    return c[index % len];
}

void kolakoski(int *c, int *s, int clen, int slen) {
    int i = 0, j, k = 0;
    while (TRUE) {
        s[i] = next_in_cycle(c, clen, k);
        if (s[k] > 1) {
            for (j = 1; j < s[k]; ++j) {
                if (++i == slen) return;
                s[i] = s[i - 1];
            }
        }
        if (++i == slen) return;
        k++;
    }
}

bool possible_kolakoski(int *s, int len) {
    int i, j = 0, prev = s[0], count = 1;
    int *rle = calloc(len, sizeof(int));
    bool result = TRUE;
    for (i = 1; i < len; ++i) {
        if (s[i] == prev) {
            count++;
        }
        else {
            rle[j++] = count;
            count = 1;
            prev = s[i];
        }
    }
    /* no point adding final 'count' to rle as we're not going to compare it anyway */
    for (i = 0; i < j; i++) {
        if (rle[i] != s[i]) {
           result = FALSE;
           break;
        }
    }
    free(rle);
    return result;
}

void print_array(int *a, int len) {
    int i;
    printf("[");
    for (i = 0; i < len; ++i) {
       printf("%d", a[i]);
       if (i < len - 1) printf(", ");
    }
    printf("]");
}

int main() {
    int i, clen, slen, *s;
    int c0[2] = {1, 2};
    int c1[2] = {2, 1};
    int c2[4] = {1, 3, 1, 2};
    int c3[4] = {1, 3, 2, 1};
    int *cs[4] = {c0, c1, c2, c3};
    bool p;
    int clens[4] = {2, 2, 4, 4};
    int slens[4] = {20, 20, 30, 30};
    for (i = 0; i < 4; ++i) {
        clen = clens[i];
        slen = slens[i];
        s = calloc(slen, sizeof(int));
        kolakoski(cs[i], s, clen, slen);
        printf("First %d members of the sequence generated by ", slen);
        print_array(cs[i], clen);
        printf(":\n");
        print_array(s, slen);
        printf("\n");
        p = possible_kolakoski(s, slen);
        printf("Possible Kolakoski sequence? %s\n\n", p ? "True" : "False");
        free(s);
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003940(void);
int64_t function_100003974(void);
int64_t function_100003a98(void);
int64_t function_100003bf8(void);
int64_t function_100003eb4(void);
int64_t * function_100003ec0(int32_t nmemb, int32_t size);
void function_100003ecc(int64_t * ptr);
int32_t function_100003ed8(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 4.24399158291867592190525751807955525e-313L; // 0x100003f90

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003940 - 0x100003974
int64_t function_100003940(void) {
    // 0x100003940
    int64_t v1; // 0x100003940
    uint32_t result = *(int32_t *)(v1 + (int64_t)(4 * ((int32_t)v1 % (int32_t)v1))); // 0x100003968
    return result;
}

// Address range: 0x100003974 - 0x100003a98
int64_t function_100003974(void) {
    // 0x100003974
    int64_t v1; // 0x100003974
    int32_t v2 = v1; // 0x10000398c
    int32_t v3 = 0; // 0x100003998
    int32_t v4 = 0;
    int64_t result = function_100003940(); // 0x1000039a8
    *(int32_t *)(4 * (int64_t)v4 + v1) = (int32_t)result;
    int32_t * v5 = (int32_t *)(4 * (int64_t)v3 + v1); // 0x1000039c0
    int32_t v6 = *v5; // 0x1000039c0
    int32_t v7 = v6 - 1; // 0x1000039c4
    int32_t v8; // 0x100003974
    int32_t v9; // 0x100003974
    int32_t v10; // 0x1000039f0
    int32_t v11; // 0x100003a04
    int32_t v12; // 0x100003a30
    int32_t v13; // 0x100003a48
    int32_t v14; // 0x1000039ec
    int32_t v15; // 0x1000039f0
    if (v7 != 0 && v7 < 0 == (v6 & -v6) < 0) {
        // 0x1000039e0
        v10 = 1 - v6;
        v9 = 1;
        v8 = v4;
        if (v10 < 0 != (v10 & v6) < 0) {
            v11 = v8 + 1;
            while (v11 != v2) {
                // 0x100003a24
                v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 - 4));
                *(int32_t *)(4 * (int64_t)v11 + v1) = v12;
                v13 = v9 + 1;
                v14 = *v5;
                v15 = v13 - v14;
                v9 = v13;
                if (v15 < 0 == ((v15 ^ v13) & (v14 ^ v13)) < 0) {
                    // break -> 0x100003a58
                    break;
                }
                v11++;
            }
            return result;
        }
    }
    int32_t v16 = v4 + 1; // 0x100003a5c
    v3++;
    while (v16 != v2) {
        // 0x10000399c
        v4 = v16;
        result = function_100003940();
        *(int32_t *)(4 * (int64_t)v4 + v1) = (int32_t)result;
        v5 = (int32_t *)(4 * (int64_t)v3 + v1);
        v6 = *v5;
        v7 = v6 - 1;
        if (v7 != 0 && v7 < 0 == (v6 & -v6) < 0) {
            // 0x1000039e0
            v10 = 1 - v6;
            v9 = 1;
            v8 = v4;
            if (v10 < 0 != (v10 & v6) < 0) {
                v11 = v8 + 1;
                while (v11 != v2) {
                    // 0x100003a24
                    v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 - 4));
                    *(int32_t *)(4 * (int64_t)v11 + v1) = v12;
                    v13 = v9 + 1;
                    v14 = *v5;
                    v15 = v13 - v14;
                    v9 = v13;
                    if (v15 < 0 == ((v15 ^ v13) & (v14 ^ v13)) < 0) {
                        // break -> 0x100003a58
                        break;
                    }
                    v11++;
                }
                return result;
            }
        }
        // 0x100003a58
        v16 = v4 + 1;
        v3++;
    }
    // 0x100003a8c
    return result;
}

// Address range: 0x100003a98 - 0x100003bf8
int64_t function_100003a98(void) {
    // 0x100003a98
    int64_t v1; // 0x100003a98
    int32_t v2 = v1; // 0x100003aa8
    int64_t * v3 = _calloc(v2, 4); // 0x100003ad0
    int64_t v4 = (int64_t)v3; // 0x100003ad0
    int32_t v5 = 1 - v2; // 0x100003af0
    int32_t v6 = 0; // 0x100003af8
    if (v5 < 0 != (v5 & v2) < 0) {
        int32_t v7 = 1; // 0x100003b70
        int32_t v8 = 0;
        int32_t v9 = v1;
        int32_t v10 = 1;
        int32_t * v11 = (int32_t *)(4 * (int64_t)v7 + v1); // 0x100003b08
        int32_t v12; // 0x100003a98
        int32_t v13; // 0x100003a98
        int32_t v14; // 0x100003a98
        if (*v11 == v9) {
            // 0x100003b20
            v12 = v8;
            v13 = v9;
            v14 = v10 + 1;
        } else {
            // 0x100003b30
            *(int32_t *)(4 * (int64_t)v8 + v4) = v10;
            v12 = v8 + 1;
            v13 = *v11;
            v14 = 1;
        }
        int32_t v15 = v12;
        v7++;
        int32_t v16 = v7 - v2; // 0x100003af0
        v6 = v15;
        while (v16 < 0 != ((v16 ^ v7) & (v7 ^ v2)) < 0) {
            // 0x100003b00
            v8 = v15;
            v9 = v13;
            v10 = v14;
            v11 = (int32_t *)(4 * (int64_t)v7 + v1);
            if (*v11 == v9) {
                // 0x100003b20
                v12 = v8;
                v13 = v9;
                v14 = v10 + 1;
            } else {
                // 0x100003b30
                *(int32_t *)(4 * (int64_t)v8 + v4) = v10;
                v12 = v8 + 1;
                v13 = *v11;
                v14 = 1;
            }
            // 0x100003b6c
            v15 = v12;
            v7++;
            v16 = v7 - v2;
            v6 = v15;
        }
    }
    int32_t v17 = -v6; // 0x100003b8c
    int32_t v18 = 0; // 0x100003b94
    if (v17 < 0 == (v6 & v17) < 0) {
        // 0x100003be0
        _free(v3);
        return 1;
    }
    int64_t v19 = 4 * (int64_t)v18; // 0x100003ba4
    int64_t result = 0; // 0x100003bbc
    while (*(int32_t *)(v19 + v4) == *(int32_t *)(v19 + v1)) {
        // 0x100003b84
        v18++;
        int32_t v20 = v18 - v6; // 0x100003b8c
        result = 1;
        if (v20 < 0 == ((v20 ^ v18) & (v18 ^ v6)) < 0) {
            // break -> 0x100003be0
            break;
        }
        v19 = 4 * (int64_t)v18;
        result = 0;
    }
    // 0x100003be0
    _free(v3);
    return result;
}

// Address range: 0x100003bf8 - 0x100003cb4
int64_t function_100003bf8(void) {
    // 0x100003bf8
    int64_t v1; // 0x100003bf8
    int32_t v2 = v1; // 0x100003c08
    _printf("[");
    int32_t v3 = -v2; // 0x100003c28
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003c9c
        return _printf("]");
    }
    int32_t v4 = v2 - 1;
    int32_t v5 = 0;
    _printf("%d", v1);
    int32_t v6 = v5 - v4; // 0x100003c68
    if (v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0) {
        // 0x100003c78
        _printf(", ");
    }
    int32_t v7 = v5 + 1; // 0x100003c90
    while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x100003c38
        v5 = v7;
        _printf("%d", v1);
        v6 = v5 - v4;
        if (v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0) {
            // 0x100003c78
            _printf(", ");
        }
        // 0x100003c8c
        v7 = v5 + 1;
    }
    // 0x100003c9c
    return _printf("]");
}

// Address range: 0x100003cb4 - 0x100003eb4
int64_t entry_point(void) {
    float128_t v1 = g1; // bp-144, 0x100003d54
    for (int64_t i = 0; i < 4; i++) {
        uint32_t v2 = *(int32_t *)(4 * i + (int64_t)&v1); // 0x100003d8c
        int64_t * v3 = _calloc(v2, 4); // 0x100003d9c
        function_100003974();
        _printf("First %d members of the sequence generated by ", (int64_t)v3);
        function_100003bf8();
        _printf(":\n");
        function_100003bf8();
        _printf("\n");
        function_100003a98();
        _printf("Possible Kolakoski sequence? %s\n\n", (char *)(int64_t)v2);
        _free(v3);
    }
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e8c
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003ea0
        ___stack_chk_fail();
    }
    // 0x100003ea4
    return 0;
}

// Address range: 0x100003eb4 - 0x100003ec0
int64_t function_100003eb4(void) {
    // 0x100003eb4
    return ___stack_chk_fail();
}

// Address range: 0x100003ec0 - 0x100003ecc
int64_t * function_100003ec0(int32_t nmemb, int32_t size) {
    // 0x100003ec0
    return _calloc(nmemb, size);
}

// Address range: 0x100003ecc - 0x100003ed8
void function_100003ecc(int64_t * ptr) {
    // 0x100003ecc
    _free(ptr);
}

// Address range: 0x100003ed8 - 0x100003ee4
int32_t function_100003ed8(char * format, ...) {
    // 0x100003ed8
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>

int main(void)
{
  printf("%s\n",
         ( (727 == 0x2d7) &&
           (727 == 01327)    ) ? "true" : "false");

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f90(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f4c - 0x100003f90
int64_t entry_point(void) {
    // 0x100003f4c
    int64_t v1; // 0x100003f4c
    _printf("%s\n", (char *)v1);
    return 0;
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(char * format, ...) {
    // 0x100003f90
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <stdlib.h>

int isprime(int n)
{
	int p;
	for (p = 2; p*p <= n; p++)
		if (n%p == 0) return 0;
	return n > 2;
}

int spiral(int w, int h, int x, int y)
{
	return y ? w + spiral(h - 1, w, y - 1, w - x - 1) : x;
}

int main(int c, char **v)
{
	int i, j, w = 50, h = 50, s = 1;
	if (c > 1 && (w = atoi(v[1])) <= 0) w = 50;
	if (c > 2 && (h = atoi(v[2])) <= 0) h = w;
	if (c > 3 && (s = atoi(v[3])) <= 0) s = 1;

	for (i = 0; i < h; i++) {
		for (j = 0; j < w; j++)
			putchar(isprime(w*h + s - 1 - spiral(w, h, j, i))[" #"]);
		putchar('\n');
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ca8(void);
int64_t function_100003d40(void);
int32_t function_100003f84(char * nptr);
int32_t function_100003f90(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ca8 - 0x100003d40
int64_t function_100003ca8(void) {
    // 0x100003ca8
    int64_t v1; // 0x100003ca8
    int32_t v2 = v1; // 0x100003cac
    int32_t v3 = 4 - v2; // 0x100003ccc
    int32_t v4 = 2; // 0x100003cd4
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
      lab_0x100003d1c:;
        int32_t v5 = v2 - 2; // 0x100003d20
        // 0x100003d34
        return !((v5 == 0 | v5 < 0 != (1 - v2 & v2) < 0));
    }
    while (v2 % v4 != 0) {
        // 0x100003cbc
        v4++;
        int32_t v6 = v4 * v4; // 0x100003cc4
        int32_t v7 = v6 - v2; // 0x100003ccc
        if (v7 != 0 && v7 < 0 == ((v7 ^ v6) & (v6 ^ v2)) < 0) {
            goto lab_0x100003d1c;
        }
    }
    // 0x100003d34
    return 0;
}

// Address range: 0x100003d40 - 0x100003dcc
int64_t function_100003d40(void) {
    // 0x100003d40
    int64_t v1; // 0x100003d40
    int64_t v2; // 0x100003d40
    if ((int32_t)v2 != 0) {
        // 0x100003d70
        v1 = function_100003d40() + v2;
    }
    // 0x100003dbc
    return v1 & 0xffffffff;
}

// Address range: 0x100003dcc - 0x100003f84
int64_t entry_point(void) {
    // 0x100003dcc
    int64_t v1; // 0x100003dcc
    int32_t v2 = v1; // 0x100003ddc
    int32_t v3 = v2 - 1; // 0x100003dfc
    int32_t v4 = 50; // 0x100003e04
    if (v3 != 0 && v3 < 0 == (v2 & -v2) < 0) {
        int32_t v5 = _atoi((char *)*(int64_t *)(v1 + 8)); // 0x100003e14
        v4 = v5 < 1 ? 50 : v5;
    }
    int32_t v6 = v2 - 2; // 0x100003e3c
    int32_t v7 = 50; // 0x100003e44
    if (v6 != 0 && v6 < 0 == (1 - v2 & v2) < 0) {
        int32_t v8 = _atoi((char *)*(int64_t *)(v1 + 16)); // 0x100003e54
        v7 = v8 < 1 ? v4 : v8;
    }
    int32_t v9 = v2 - 3; // 0x100003e7c
    if (v9 != 0 && v9 < 0 == (2 - v2 & v2) < 0) {
        // 0x100003e8c
        _atoi((char *)*(int64_t *)(v1 + 24));
    }
    int32_t v10 = -v7; // 0x100003ec8
    if (v10 < 0 == (v7 & v10) < 0) {
        // 0x100003f74
        return 0;
    }
    int32_t v11 = -v4; // 0x100003ee8
    int32_t v12 = 0; // 0x100003f68
    int32_t v13; // 0x100003dcc
    char v14; // 0x100003f3c
    int32_t v15; // 0x100003f4c
    int32_t v16; // 0x100003ee8
    if (v11 < 0 != (v4 & v11) < 0) {
        function_100003d40();
        v14 = *(char *)((function_100003ca8() & 0xffffffff) + (int64_t)" #");
        _putchar((int32_t)v14);
        v15 = 1;
        v16 = v15 - v4;
        v13 = v15;
        while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v4)) < 0) {
            // 0x100003ef8
            function_100003d40();
            v14 = *(char *)((function_100003ca8() & 0xffffffff) + (int64_t)" #");
            _putchar((int32_t)v14);
            v15 = v13 + 1;
            v16 = v15 - v4;
            v13 = v15;
        }
    }
    // 0x100003f58
    _putchar(10);
    v12++;
    while (v12 - v7 < 0 != ((v12 - v7 ^ v12) & (v12 ^ v7)) < 0) {
        // 0x100003ee0
        if (v11 < 0 != (v4 & v11) < 0) {
            function_100003d40();
            v14 = *(char *)((function_100003ca8() & 0xffffffff) + (int64_t)" #");
            _putchar((int32_t)v14);
            v15 = 1;
            v16 = v15 - v4;
            v13 = v15;
            while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v4)) < 0) {
                // 0x100003ef8
                function_100003d40();
                v14 = *(char *)((function_100003ca8() & 0xffffffff) + (int64_t)" #");
                _putchar((int32_t)v14);
                v15 = v13 + 1;
                v16 = v15 - v4;
                v13 = v15;
            }
        }
        // 0x100003f58
        _putchar(10);
        v12++;
    }
    // 0x100003f74
    return 0;
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * nptr) {
    // 0x100003f84
    return _atoi(nptr);
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(int32_t c) {
    // 0x100003f90
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <wctype.h>
#include <string.h>
#include <locale.h>

typedef struct wstr {
	wchar_t *s;
	int n, alloc;
} wstr;

#define w_del(w) { free(w->s); free(w); }
#define forchars(i, c, w) for(i = 0, c = w->s[0]; i < w->n && c; c = w->s[++i])
wstr *w_new()
{
	wstr *w = malloc(sizeof(wstr));
	w->alloc = 1;
	w->n = 0;
	w->s = malloc(sizeof(wchar_t));
	w->s[0] = 0;
	return w;
}

void w_append(wstr *w, wchar_t c)
{
	int n = w->n + 1;
	if (n >= w->alloc) {
		w->alloc *= 2;
		w->s = realloc(w->s, w->alloc * sizeof(wchar_t));
	}
	w->s[w->n++] = c;
	w->s[w->n] = 0;
}

wstr *w_make(wchar_t *s)
{
	int i, len = wcslen(s);
	wstr *w = w_new();
	for (i = 0; i < len; i++) w_append(w, s[i]);
	return w;
}

typedef void (*wtrans_func)(wstr *, wstr *);
void w_transform(wstr *in, wtrans_func f)
{
	wstr t, *out = w_new();
	f(in, out);
	t = *in; *in = *out; *out = t;
	w_del(out);
}
#define transfunc(x) void w_##x(wstr *in, wstr *out)

transfunc(nocase) {
	int i;
	wchar_t c;
	forchars(i, c, in) w_append(out, towlower(c));
}

transfunc(despace) {
	int i, gotspace = 0;
	wchar_t c;
	forchars(i, c, in) {
		if (!iswspace(c)) {
			if (gotspace && out->n)
				w_append(out, L' ');
			w_append(out, c);
			gotspace = 0;
		} else	gotspace = 1;
	}
}

static const wchar_t *const tbl_accent[] = { /* copied from Raku code */
	L"Þ", L"TH", L"þ", L"th", L"Ð", L"TH", L"ð", L"th", L"À", L"A",
	L"Á", L"A", L"Â", L"A", L"Ã", L"A", L"Ä", L"A", L"Å", L"A", L"à",
	L"a", L"á", L"a", L"â", L"a", L"ã", L"a", L"ä", L"a", L"å", L"a",
	L"Ç", L"C", L"ç", L"c", L"È", L"E", L"É", L"E", L"Ê", L"E", L"Ë",
	L"E", L"è", L"e", L"é", L"e", L"ê", L"e", L"ë", L"e", L"Ì",
	L"I", L"Í", L"I", L"Î", L"I", L"Ï", L"I", L"ì", L"i", L"í",
	L"i", L"î", L"i", L"ï", L"i", L"Ò", L"O", L"Ó", L"O", L"Ô",
	L"O", L"Õ", L"O", L"Ö", L"O", L"Ø", L"O", L"ò", L"o", L"ó", L"o",
	L"ô", L"o", L"õ", L"o", L"ö", L"o", L"ø", L"o", L"Ñ", L"N", L"ñ", L"n",
	L"Ù", L"U", L"Ú", L"U", L"Û", L"U", L"Ü", L"U", L"ù", L"u", L"ú", L"u",
	L"û", L"u", L"ü", L"u", L"Ý", L"Y", L"ÿ", L"y", L"ý", L"y" };

static const wchar_t *const tbl_ligature[] = {
	L"Æ", L"AE", L"æ", L"ae", L"ß", L"ss",
	L"ﬄ", L"ffl", L"ﬃ", L"ffi", L"ﬁ", L"fi", L"ﬀ", L"ff", L"ﬂ", L"fl",
	L"ſ", L"s", L"ʒ", L"z", L"ﬆ", L"st", /* ... come on ... */
};

void w_char_repl(wstr *in, wstr *out, const wchar_t *const *tbl, int len)
{
	int i, j, k;
	wchar_t c;
	forchars(i, c, in) {
		for (j = k = 0; j < len; j += 2) {
			if (c != tbl[j][0]) continue;
			for (k = 0; tbl[j + 1][k]; k++)
				w_append(out, tbl[j + 1][k]);
			break;
		}
		if (!k) w_append(out, c);
	}
}

transfunc(noaccent) {
	w_char_repl(in, out, tbl_accent, sizeof(tbl_accent)/sizeof(wchar_t*));
}

transfunc(noligature) {
	w_char_repl(in, out, tbl_ligature, sizeof(tbl_ligature)/sizeof(wchar_t*));
}

static const wchar_t *const tbl_article[] = {
	L"the", L"a", L"of", L"to", L"is", L"it" };
#define N_ARTICLES sizeof(tbl_article)/sizeof(tbl_article[0])
transfunc(noarticle) {
	int i, j, n;
	wchar_t c, c0 = 0;
	forchars(i, c, in) {
		if (!c0 || (iswalnum(c) && !iswalnum(c0))) { /* word boundary */
			for (j = N_ARTICLES - 1; j >= 0; j--) {
				n = wcslen(tbl_article[j]);
				if (wcsncasecmp(in->s + i, tbl_article[j], n))
					continue;
				if (iswalnum(in->s[i + n])) continue;
				i += n;
				break;
			}
			if (j < 0) w_append(out, c);
		} else
			w_append(out, c);
		c0 = c;
	}
}

enum { wi_space = 0, wi_case, wi_accent, wi_lig, wi_article, wi_numeric };
#define WS_NOSPACE	(1 << wi_space)
#define WS_NOCASE	(1 << wi_case)
#define WS_ACCENT	(1 << wi_accent)
#define WS_LIGATURE	(1 << wi_lig)
#define WS_NOARTICLE	(1 << wi_article)
#define WS_NUMERIC	(1 << wi_numeric)
const wtrans_func trans_funcs[] = {
	w_despace, w_nocase, w_noaccent, w_noligature, w_noarticle, 0
};
const char *const flagnames[] = {
	"collapse spaces",
	"case insensitive",
	"disregard accent",
	"decompose ligatures",
	"discard common words",
	"numeric",
};

typedef struct { wchar_t* s; wstr *w; } kw_t;
int w_numcmp(const void *a, const void *b)
{
	wchar_t *pa = ((const kw_t*)a)->w->s, *pb = ((const kw_t*)b)->w->s;
	int sa, sb, ea, eb;
	while (*pa && *pb) {
		if (iswdigit(*pa) && iswdigit(*pb)) {
			/* skip leading zeros */
			sa = sb = 0;
			while (pa[sa] == L'0') sa++;
			while (pb[sb] == L'0') sb++;
			/* find end of numbers */
			ea = sa; eb = sb;
			while (iswdigit(pa[ea])) ea++;
			while (iswdigit(pb[eb])) eb++;
			if (eb - sb > ea - sa) return -1;
			if (eb - sb < ea - sa) return 1;
			while (sb < eb) {
				if (pa[sa] > pb[sb]) return 1;
				if (pa[sa] < pb[sb]) return -1;
				sa++; sb++;
			}

			pa += ea; pb += eb;
		}
		else if (iswdigit(*pa)) return 1;
		else if (iswdigit(*pb)) return -1;
		else {
			if (*pa > *pb) return 1;
			if (*pa < *pb) return -1;
			pa++; pb++;
		}
	}
	return (!*pa && !*pb) ? 0 : *pa ?  1 : -1;
}

int w_cmp(const void *a, const void *b)
{
	return wcscmp(((const kw_t*)a)->w->s, ((const kw_t*)b)->w->s);
}

void natural_sort(wchar_t **strings, int len, int flags)
{
	int i, j;
	kw_t *kws = malloc(sizeof(kw_t) * len);

	for (i = 0; i < len; i++) {
		kws[i].s = strings[i];
		kws[i].w = w_make(strings[i]);
		for (j = 0; j < wi_numeric; j++)
			if (flags & (1 << j) && trans_funcs[j])
				w_transform(kws[i].w, trans_funcs[j]);
	}

	qsort(kws, len, sizeof(kw_t), (flags & WS_NUMERIC) ? w_numcmp : w_cmp);
	for (i = 0; i < len; i++) {
		w_del(kws[i].w);
		strings[i] = kws[i].s;
	}
	free(kws);
}

const wchar_t *const test[] = {
	L" 0000098 nina", L"100 niño", L"99 Ninja", L"100 NINA",
	L" The work is so diﬃcult to do it took ſome 100 aeons.  ",
	L"The work is so difficult it took some 100 aeons.",
	L"  The work is so diﬃcult   it took ſome 99 æons.  ",
};
#define N_STRINGS sizeof(test)/sizeof(*test)

void test_sort(int flags)
{
	int i, j;
	const wchar_t *str[N_STRINGS];
	memcpy(str, test, sizeof(test));

	printf("Sort flags: (");
	for (i = 0, j = flags; j; i++, j >>= 1)
		if ((j & 1))
			printf("%s%s", flagnames[i], j > 1 ? ", ":")\n");

	natural_sort((wchar_t **)str, N_STRINGS, flags);

	for (i = 0; i < N_STRINGS; i++)
		printf("%ls\n", str[i]);
	printf("\n");
}

int main()
{
	setlocale(LC_CTYPE, "");

	test_sort(WS_NOSPACE);
	test_sort(WS_NOCASE);
	test_sort(WS_NUMERIC);
	test_sort(WS_NOARTICLE|WS_NOSPACE);
	test_sort(WS_NOCASE|WS_NOSPACE|WS_ACCENT);
	test_sort(WS_LIGATURE|WS_NOCASE|WS_NOSPACE|WS_NUMERIC|WS_ACCENT|WS_NOARTICLE);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000027c4(void);
int64_t function_10000281c(void);
int64_t function_1000028d8(void);
int64_t function_100002958(int64_t result, int64_t a2);
int64_t function_100002984(int64_t a1);
int64_t function_1000029cc(void);
int64_t function_100002a88(void);
int64_t function_100002ba0(void);
int64_t function_100002d30(void);
int64_t function_100002d68(void);
int64_t function_100002da0(void);
int64_t function_100002f94(void);
int64_t function_1000033a4(void);
int64_t function_1000033e0(void);
int64_t function_1000035dc(void);
int64_t function_1000037d0(int64_t a1);
void function_1000037dc(int64_t * ptr);
int32_t function_1000037e8(int32_t wc);
int32_t function_1000037f4(int32_t wc);
int32_t function_100003800(int32_t wc);
int64_t * function_10000380c(int32_t size);
int64_t * function_100003818(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003824(char * format, ...);
void function_100003830(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int64_t * function_10000383c(int64_t * ptr, int32_t size);
char * function_100003848(int32_t category, char * locale);
int32_t function_100003854(int32_t wc);
int32_t function_100003860(int16_t * s1, int16_t * s2);
int32_t function_10000386c(int16_t * s);
int32_t function_100003878(int16_t * s1, int16_t * s2, int32_t n);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x10000000002a88; // 0x100004510
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
void _free(int64_t * a1);
int32_t _iswalnum(int32_t a1);
int32_t _iswdigit(int32_t a1);
int32_t _iswspace(int32_t a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int64_t * _realloc(int64_t * a1, int32_t a2);
char * _setlocale(int32_t a1, char * a2);
int32_t _towlower(int32_t a1);
int32_t _wcscmp(int16_t * a1, int16_t * a2);
int32_t _wcslen(int16_t * a1);
int32_t _wcsncasecmp(int16_t * a1, int16_t * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x1000027c4 - 0x10000281c
int64_t function_1000027c4(void) {
    int64_t * v1 = _malloc(16); // 0x1000027d4
    int64_t result = (int64_t)v1; // 0x1000027d4
    *(int32_t *)(result + 12) = 1;
    *(int32_t *)(result + 8) = 0;
    int64_t * v2 = _malloc(4); // 0x1000027f4
    *v1 = (int64_t)v2;
    *(int32_t *)v2 = 0;
    return result;
}

// Address range: 0x10000281c - 0x1000028d8
int64_t function_10000281c(void) {
    // 0x10000281c
    int64_t v1; // 0x10000281c
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x100002834
    int32_t v3 = *v2; // 0x100002834
    int32_t v4 = v3 + 1;
    int32_t * v5 = (int32_t *)(v1 + 12); // 0x100002848
    int32_t v6 = *v5; // 0x100002848
    int32_t v7 = v4 - v6; // 0x10000284c
    int32_t v8 = v4; // 0x100002854
    int32_t v9 = v3; // 0x100002854
    int64_t result; // 0x10000281c
    if (v7 < 0 == ((v7 ^ v4) & (v4 ^ v6)) < 0) {
        // 0x10000285c
        *v5 = 2 * v6;
        int64_t * v10 = (int64_t *)v1; // 0x100002880
        int64_t v11 = (int64_t)_realloc(v10, 8 * v6); // 0x100002880
        *v10 = v11;
        v9 = *v2;
        v8 = v9 + 1;
        result = v11;
    }
    // 0x100002890
    *v2 = v8;
    *(int32_t *)(4 * (int64_t)v9 + result) = (int32_t)v1;
    *(int32_t *)(4 * (int64_t)*v2 + result) = 0;
    return result;
}

// Address range: 0x1000028d8 - 0x100002958
int64_t function_1000028d8(void) {
    // 0x1000028d8
    int64_t v1; // 0x1000028d8
    int32_t v2 = _wcslen((int16_t *)v1); // 0x1000028ec
    int64_t result = function_1000027c4(); // 0x1000028f8
    int32_t v3 = -v2; // 0x100002910
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100002948
        return result;
    }
    int32_t v4 = 0; // 0x100002918
    function_10000281c();
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100002920
        function_10000281c();
        v4++;
    }
    // 0x100002948
    return result;
}

// Address range: 0x100002958 - 0x100002984
int64_t function_100002958(int64_t result, int64_t a2) {
    // 0x100002958
    function_1000027c4();
    return result;
}

// Address range: 0x100002984 - 0x1000029cc
int64_t function_100002984(int64_t a1) {
    // 0x100002984
    int64_t v1; // 0x100002984
    float128_t * v2 = (float128_t *)*(int64_t *)(v1 - 8); // 0x100002988
    float128_t * v3 = (float128_t *)a1; // 0x100002998
    *v2 = *v3;
    *v3 = *v2;
    int64_t * v4 = (int64_t *)a1; // 0x1000029b0
    _free((int64_t *)*v4);
    _free(v4);
    return &g2;
}

// Address range: 0x1000029cc - 0x100002a88
int64_t function_1000029cc(void) {
    // 0x1000029cc
    int64_t v1; // 0x1000029cc
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x100002a00
    int32_t v4 = *v3; // 0x100002a00
    int32_t v5 = -v4; // 0x100002a04
    if (v2 != 0 != v5 < 0 != (v4 & v5) < 0) {
        // 0x100002a7c
        int64_t result; // 0x1000029cc
        return result;
    }
    int32_t v6 = 0; // 0x100002a34
    _towlower(v2);
    int64_t result2 = function_10000281c(); // 0x100002a54
    v6++;
    int32_t v7 = *(int32_t *)(result2 + (int64_t)(4 * v6));
    int32_t v8 = *v3; // 0x100002a00
    int32_t v9 = v6 - v8; // 0x100002a04
    while (v7 != 0 == (v9 < 0 != ((v9 ^ v6) & (v8 ^ v6)) < 0)) {
        // 0x100002a3c
        _towlower(v7);
        result2 = function_10000281c();
        v6++;
        v7 = *(int32_t *)(result2 + (int64_t)(4 * v6));
        v8 = *v3;
        v9 = v6 - v8;
    }
    // 0x100002a7c
    return result2;
}

// Address range: 0x100002a88 - 0x100002ba0
int64_t function_100002a88(void) {
    // 0x100002a88
    int64_t v1; // 0x100002a88
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x100002ac0
    int32_t v4 = *v3; // 0x100002ac0
    int32_t v5 = -v4; // 0x100002ac4
    if (v2 != 0 != v5 < 0 != (v4 & v5) < 0) {
        // 0x100002b94
        int64_t result; // 0x100002a88
        return result;
    }
    int32_t v6 = 0; // 0x100002b80
    int32_t v7 = _iswspace(v2); // 0x100002b00
    int64_t result2 = v7; // 0x100002b0c
    int32_t v8 = 1; // 0x100002b0c
    if (v7 == 0) {
        // 0x100002b50
        result2 = function_10000281c();
        v8 = 0;
    }
    // 0x100002b70
    v6++;
    int32_t v9 = *(int32_t *)(result2 + (int64_t)(4 * v6));
    int32_t v10 = *v3; // 0x100002ac0
    int32_t v11 = v6 - v10; // 0x100002ac4
    int32_t v12 = v8; // 0x100002af4
    while (v9 != 0 == (v11 < 0 != ((v11 ^ v6) & (v10 ^ v6)) < 0)) {
        // 0x100002afc
        v7 = _iswspace(v9);
        result2 = v7;
        v8 = 1;
        if (v7 == 0) {
            // 0x100002b14
            if (v12 != 0) {
                // 0x100002b28
                if (*(int32_t *)(v1 + 8) != 0) {
                    // 0x100002b40
                    function_10000281c();
                }
            }
            // 0x100002b50
            result2 = function_10000281c();
            v8 = 0;
        }
        // 0x100002b70
        v6++;
        v9 = *(int32_t *)(result2 + (int64_t)(4 * v6));
        v10 = *v3;
        v11 = v6 - v10;
        v12 = v8;
    }
    // 0x100002b94
    return result2;
}

// Address range: 0x100002ba0 - 0x100002d30
int64_t function_100002ba0(void) {
    // 0x100002ba0
    int64_t v1; // 0x100002ba0
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x100002bdc
    int32_t v4 = *v3; // 0x100002bdc
    int32_t v5 = -v4; // 0x100002be0
    int64_t result; // 0x100002ba0
    if (v2 != 0 != v5 < 0 != (v4 & v5) < 0) {
        // 0x100002d24
        return result;
    }
    int32_t v6 = v1; // 0x100002bb8
    int32_t v7 = -v6; // 0x100002c2c
    int32_t v8 = v2;
    int32_t v9 = 0; // 0x100002d10
    int64_t v10; // 0x100002ba0
    while (true) {
      lab_0x100002c24:;
        int32_t v11 = v8;
        if (v7 < 0 == (v7 & v6) < 0) {
            // 0x100002cf0
            v10 = function_10000281c();
            goto lab_0x100002d04;
        } else {
            int32_t v12 = 0;
            int32_t v13 = *(int32_t *)*(int64_t *)(8 * (int64_t)v12 + v1); // 0x100002c4c
            while (v11 != v13) {
                int32_t v14 = v12 + 2; // 0x100002cd0
                int32_t v15 = v14 - v6; // 0x100002c2c
                int32_t v16 = v14; // 0x100002c34
                if (v15 < 0 == ((v15 ^ v14) & (v14 ^ v6)) < 0) {
                    // 0x100002cf0
                    v10 = function_10000281c();
                    goto lab_0x100002d04;
                }
                v12 = v16;
                v13 = *(int32_t *)*(int64_t *)(8 * (int64_t)v12 + v1);
            }
            int64_t * v17 = (int64_t *)(v1 + (int64_t)(8 * v12 | 8)); // 0x100002c78
            if (*(int32_t *)*v17 == 0) {
                // 0x100002cf0
                v10 = function_10000281c();
                goto lab_0x100002d04;
            } else {
                int64_t v18 = function_10000281c(); // 0x100002cb0
                int32_t v19 = 1; // 0x100002cbc
                int32_t v20 = v19; // 0x100002c8c
                while (*(int32_t *)(4 * (int64_t)v19 + *v17) != 0) {
                    // 0x100002c94
                    v18 = function_10000281c();
                    v19 = v20 + 1;
                    v20 = v19;
                }
                // 0x100002cdc
                v10 = v18;
                if (v19 == 0) {
                    // 0x100002cf0
                    v10 = function_10000281c();
                    goto lab_0x100002d04;
                } else {
                    goto lab_0x100002d04;
                }
            }
        }
    }
    // 0x100002d24
    return result;
  lab_0x100002d04:
    // 0x100002d04
    v9++;
    v8 = *(int32_t *)(v10 + (int64_t)(4 * v9));
    int32_t v21 = *v3; // 0x100002bdc
    int32_t v22 = v9 - v21; // 0x100002be0
    result = v10;
    if (v8 != 0 != v22 < 0 != ((v22 ^ v9) & (v21 ^ v9)) < 0) {
        return result;
    }
    goto lab_0x100002c24;
}

// Address range: 0x100002d30 - 0x100002d68
int64_t function_100002d30(void) {
    // 0x100002d30
    return function_100002ba0();
}

// Address range: 0x100002d68 - 0x100002da0
int64_t function_100002d68(void) {
    // 0x100002d68
    return function_100002ba0();
}

// Address range: 0x100002da0 - 0x100002f94
int64_t function_100002da0(void) {
    // 0x100002da0
    int64_t v1; // 0x100002da0
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x100002dd8
    int32_t v4 = *v3; // 0x100002dd8
    int32_t v5 = -v4; // 0x100002ddc
    int32_t v6 = v2; // 0x100002e0c
    int32_t v7 = 0; // 0x100002e0c
    int64_t result; // 0x100002da0
    if (v2 != 0 != v5 < 0 != (v4 & v5) < 0) {
        // 0x100002f88
        return result;
    }
    int32_t v8 = 0; // 0x100002e0c
    int32_t v9; // 0x100002da0
    while (true) {
      lab_0x100002e14:;
        int32_t v10 = v8;
        v9 = v7;
        v8 = v6;
        if (v10 == 0) {
            goto lab_0x100002e58;
        } else {
            // 0x100002e28
            if (_iswalnum(v8) == 0) {
                goto lab_0x100002f4c;
            } else {
                // 0x100002e40
                if (_iswalnum(v10) == 0) {
                    goto lab_0x100002e58;
                } else {
                    goto lab_0x100002f4c;
                }
            }
        }
    }
  lab_0x100002f88:
    // 0x100002f88
    return result;
  lab_0x100002e58:;
    int64_t v11 = 4 * (int64_t)v9;
    int64_t v12 = 5; // 0x100002da0
    int64_t v13; // 0x100002da0
    int32_t v14; // 0x100002da0
    while (true) {
        int64_t v15 = v12;
        int64_t * v16 = (int64_t *)(8 * v15 + (int64_t)"h?"); // 0x100002e88
        int32_t v17 = _wcslen((int16_t *)*v16); // 0x100002e8c
        int64_t v18 = *v16; // 0x100002eb0
        if (_wcsncasecmp((int16_t *)(v11 + (int64_t)v17), (int16_t *)v18, v17) == 0) {
            int32_t v19 = v17 + v9; // 0x100002ee0
            v13 = 0;
            v14 = v19;
            if (_iswalnum(*(int32_t *)(int64_t)(4 * v19)) == 0) {
                // break -> 0x100002f5c
                break;
            }
        }
        // 0x100002f14
        v12 = v15 - 1;
        if (v15 == 0) {
            // 0x100002f38
            v13 = function_10000281c();
            v14 = v9;
            goto lab_0x100002f5c;
        }
    }
    goto lab_0x100002f5c;
  lab_0x100002f5c:
    // 0x100002f5c
    v7 = v14 + 1;
    v6 = *(int32_t *)(v13 + (int64_t)(4 * v7));
    int32_t v20 = *v3; // 0x100002dd8
    int32_t v21 = v7 - v20; // 0x100002ddc
    result = v13;
    if (v6 != 0 != v21 < 0 != ((v21 ^ v7) & (v20 ^ v7)) < 0) {
        // break -> 0x100002f88
        goto lab_0x100002f88;
    }
    goto lab_0x100002e14;
  lab_0x100002f4c:
    // 0x100002f4c
    v13 = function_10000281c();
    v14 = v9;
    goto lab_0x100002f5c;
}

// Address range: 0x100002f94 - 0x1000033a4
int64_t function_100002f94(void) {
    // 0x100002f94
    int64_t v1; // 0x100002f94
    int64_t v2 = *(int64_t *)*(int64_t *)(v1 + 8); // 0x100002fb0
    int64_t v3 = *(int64_t *)*(int64_t *)(v1 + 8); // 0x100002fc0
    int32_t * v4 = (int32_t *)v2;
    int32_t * v5 = (int32_t *)v3;
    int32_t v6 = *v4; // 0x100002fd0
    int32_t v7 = v6; // 0x100002fe4
    int32_t * v8 = v5; // 0x100002fe4
    int32_t * v9 = v4; // 0x100002fe4
    int64_t v10 = v2; // 0x100002fe4
    int64_t v11 = v3; // 0x100002fe4
    int32_t * v12 = v5; // 0x100002fe4
    int64_t result2; // 0x100002f94
    int64_t v13; // 0x100002f94
    int32_t * v14; // 0x100002f94
    int64_t v15; // 0x100002f94
    int32_t v16; // 0x100002f94
    int32_t v17; // 0x100002f94
    if (v6 == 0) {
      lab_0x10000333c:
        // 0x10000333c
        result2 = 0xffffffff;
        if (*v12 == 0) {
            // 0x100003394
            return 0;
        }
    } else {
        while (true) {
          lab_0x100003004:
            // 0x100003004
            v14 = v8;
            result2 = 1;
            if (*v14 == 0) {
                // break -> 0x100003360
                break;
            }
            // 0x100003010
            v15 = v11;
            v13 = v10;
            if (_iswdigit(v7) == 0) {
                goto lab_0x100003254;
            } else {
                int32_t v18 = 0; // 0x100003040
                if (_iswdigit(*v14) == 0) {
                    goto lab_0x100003254;
                } else {
                    while (true) {
                        // 0x100003054
                        v17 = v18;
                        v18 = v17 + 1;
                        v16 = 0;
                        if (*(int32_t *)(4 * (int64_t)v17 + v13) != 48) {
                            goto lab_0x100003084;
                        }
                    }
                    // 0x100003128
                    int32_t v19; // 0x100002f94
                    int32_t v20; // 0x100002f94
                    int32_t v21 = v20 - v19; // 0x100003130
                    int32_t v22; // 0x100002f94
                    int32_t v23 = v22 - v17; // 0x10000313c
                    int32_t v24 = v21 - v23; // 0x100003140
                    int64_t v25 = 0xffffffff; // 0x100003148
                    int64_t result; // 0x100002f94
                    if (v24 != 0 && v24 < 0 == ((v24 ^ v21) & (v21 ^ v23)) < 0) {
                        // 0x100003394
                        result = v25;
                        return result;
                    }
                    // 0x10000315c
                    v25 = 1;
                    if (v24 < 0 != ((v24 ^ v21) & (v21 ^ v23)) < 0) {
                        // 0x100003394
                        result = v25;
                        return result;
                    }
                    int32_t v26 = v19 - v20; // 0x10000319c
                    int32_t v27 = v17; // 0x1000031a4
                    int32_t v28 = v19; // 0x1000031a4
                    if (v26 < 0 != ((v26 ^ v19) & (v20 ^ v19)) < 0) {
                        int32_t v29 = v28;
                        int32_t v30 = v27;
                        int32_t v31 = *(int32_t *)(4 * (int64_t)v30 + v13); // 0x1000031b4
                        int32_t v32 = *(int32_t *)(4 * (int64_t)v29 + v15); // 0x1000031c0
                        int32_t v33 = v31 - v32; // 0x1000031c4
                        v25 = 1;
                        // 0x100003394
                        result = v25;
                        while (v33 == 0 || v33 < 0 != ((v33 ^ v31) & (v32 ^ v31)) < 0) {
                            // 0x1000031e0
                            v25 = 0xffffffff;
                            if (v33 < 0 != ((v33 ^ v31) & (v32 ^ v31)) < 0) {
                                // 0x100003394
                                result = v25;
                                return result;
                            }
                            int32_t v34 = v29 + 1; // 0x100003224
                            int32_t v35 = v34 - v20; // 0x10000319c
                            v27 = v30 + 1;
                            v28 = v34;
                            if (v35 < 0 == ((v35 ^ v34) & (v34 ^ v20)) < 0) {
                                // break -> 0x100003320
                                break;
                            }
                            v29 = v28;
                            v30 = v27;
                            v31 = *(int32_t *)(4 * (int64_t)v30 + v13);
                            v32 = *(int32_t *)(4 * (int64_t)v29 + v15);
                            v33 = v31 - v32;
                            v25 = 1;
                            // 0x100003394
                            result = v25;
                        }
                        return result;
                    }
                    goto lab_0x100003320;
                }
            }
        }
    }
    // 0x100003394
    return result2;
  lab_0x100003084:;
    int32_t v36 = *(int32_t *)(4 * (int64_t)v16 + v15); // 0x10000308c
    v16++;
    if (v36 == 48) {
        goto lab_0x100003084;
    } else {
        // 0x1000030c4
        _iswdigit(*(int32_t *)(4 * (int64_t)v17 + v13));
    }
  lab_0x100003254:
    // 0x100003254
    if (_iswdigit(*v9) != 0) {
        // 0x100003394
        return 1;
    }
    // 0x10000327c
    if (_iswdigit(*v14) != 0) {
        // 0x100003394
        return 0xffffffff;
    }
    int32_t v37 = *v9; // 0x1000032a8
    int32_t v38 = *v14; // 0x1000032b0
    int32_t v39 = v37 - v38; // 0x1000032b4
    if (v39 != 0 && v39 < 0 == ((v39 ^ v37) & (v38 ^ v37)) < 0) {
        // 0x100003394
        return 1;
    }
    // 0x1000032d0
    if (v39 < 0 != ((v39 ^ v37) & (v38 ^ v37)) < 0) {
        // 0x100003394
        return 0xffffffff;
    }
    // 0x1000032fc
    v10 = v13 + 4;
    v11 = v15 + 4;
    goto lab_0x100003320;
  lab_0x100003320:
    // 0x100003320
    v9 = (int32_t *)v10;
    v8 = (int32_t *)v11;
    v7 = *v9;
    v12 = v8;
    if (v7 == 0) {
        goto lab_0x10000333c;
    }
    goto lab_0x100003004;
}

// Address range: 0x1000033a4 - 0x1000033e0
int64_t function_1000033a4(void) {
    // 0x1000033a4
    int64_t v1; // 0x1000033a4
    int64_t v2 = *(int64_t *)(v1 + 8); // 0x1000033bc
    int64_t v3 = *(int64_t *)*(int64_t *)(v1 + 8); // 0x1000033cc
    return _wcscmp((int16_t *)*(int64_t *)v2, (int16_t *)v3);
}

// Address range: 0x1000033e0 - 0x1000035dc
int64_t function_1000033e0(void) {
    // 0x1000033e0
    int64_t v1; // 0x1000033e0
    int32_t v2 = v1; // 0x1000033f0
    int32_t v3 = v1; // 0x1000033f4
    int64_t * v4 = _malloc(16 * v2); // 0x100003404
    int64_t v5 = (int64_t)v4; // 0x100003404
    int32_t v6 = -v2;
    int32_t v7 = 0; // 0x100003424
    if (v6 < 0 == (v6 & v2) < 0) {
        // 0x1000035c8
        _qsort(v4, v2, 16, (v3 & 32) == 0 ? (int32_t (*)(int64_t *, int64_t *))0x1000033a4 : (int32_t (*)(int64_t *, int64_t *))0x100002f94);
        // 0x1000035c8
        _free(v4);
        return &g2;
    }
    int64_t v8 = v7; // 0x100003430
    int64_t v9 = 16 * v8 + v5; // 0x100003444
    *(int64_t *)v9 = *(int64_t *)(8 * v8 + v1);
    int64_t v10 = function_1000028d8(); // 0x100003454
    int64_t * v11 = (int64_t *)(v9 + 8); // 0x100003464
    *v11 = v10;
    int64_t v12 = 0;
    int64_t v13; // 0x1000034b0
    if ((1 << (int32_t)v12 & v3) != 0) {
        // 0x1000034a4
        v13 = *(int64_t *)(8 * v12 + (int64_t)&g1);
        if (v13 != 0) {
            // 0x1000034c4
            function_100002958(*v11, v13);
        }
    }
    int64_t v14 = v12 + 1;
    while (v14 != 5) {
        // 0x100003484
        v12 = v14;
        if ((1 << (int32_t)v12 & v3) != 0) {
            // 0x1000034a4
            v13 = *(int64_t *)(8 * v12 + (int64_t)&g1);
            if (v13 != 0) {
                // 0x1000034c4
                function_100002958(*v11, v13);
            }
        }
        // 0x1000034f0
        v14 = v12 + 1;
    }
    // 0x100003504
    v7++;
    while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x10000342c
        v8 = v7;
        v9 = 16 * v8 + v5;
        *(int64_t *)v9 = *(int64_t *)(8 * v8 + v1);
        v10 = function_1000028d8();
        v11 = (int64_t *)(v9 + 8);
        *v11 = v10;
        v12 = 0;
        if ((1 << (int32_t)v12 & v3) != 0) {
            // 0x1000034a4
            v13 = *(int64_t *)(8 * v12 + (int64_t)&g1);
            if (v13 != 0) {
                // 0x1000034c4
                function_100002958(*v11, v13);
            }
        }
        // 0x1000034f0
        v14 = v12 + 1;
        while (v14 != 5) {
            // 0x100003484
            v12 = v14;
            if ((1 << (int32_t)v12 & v3) != 0) {
                // 0x1000034a4
                v13 = *(int64_t *)(8 * v12 + (int64_t)&g1);
                if (v13 != 0) {
                    // 0x1000034c4
                    function_100002958(*v11, v13);
                }
            }
            // 0x1000034f0
            v14 = v12 + 1;
        }
        // 0x100003504
        v7++;
    }
    // 0x10000356c
    _qsort(v4, v2, 16, (v3 & 32) == 0 ? (int32_t (*)(int64_t *, int64_t *))0x1000033a4 : (int32_t (*)(int64_t *, int64_t *))0x100002f94);
    int32_t v15 = 0; // 0x1000035bc
    int64_t v16 = v15; // 0x100003570
    int64_t v17 = 16 * v16 + v5; // 0x100003574
    int64_t * v18 = (int64_t *)(v17 + 8); // 0x100003578
    _free((int64_t *)*(int64_t *)*v18);
    _free((int64_t *)*v18);
    *(int64_t *)(8 * v16 + v1) = *(int64_t *)v17;
    v15++;
    while (v15 - v2 < 0 != ((v15 - v2 ^ v15) & (v15 ^ v2)) < 0) {
        // 0x10000356c
        v16 = v15;
        v17 = 16 * v16 + v5;
        v18 = (int64_t *)(v17 + 8);
        _free((int64_t *)*(int64_t *)*v18);
        _free((int64_t *)*v18);
        *(int64_t *)(8 * v16 + v1) = *(int64_t *)v17;
        v15++;
    }
    // 0x1000035c8
    _free(v4);
    return &g2;
}

// Address range: 0x1000035dc - 0x100003764
int64_t function_1000035dc(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000035f0
    int64_t v2; // 0x1000035dc
    int32_t v3 = v2; // 0x1000035f8
    int64_t v4; // bp-80, 0x1000035dc
    _memcpy(&v4, (int64_t *)"\b9", 56);
    _printf("Sort flags: (");
    int32_t v5 = v3; // 0x100003638
    if (v3 != 0) {
        if (v5 % 2 != 0) {
            // 0x100003654
            _printf("%s%s", "\b9", (char *)56);
        }
        // 0x1000036ac
        v5 >>= 1;
        while (v5 != 0) {
            // 0x100003640
            if (v5 % 2 != 0) {
                // 0x100003654
                _printf("%s%s", "\b9", (char *)56);
            }
            // 0x1000036ac
            v5 >>= 1;
        }
    }
    // 0x1000036c8
    function_1000033e0();
    for (int32_t i = 0; i < 7; i++) {
        // 0x1000036f4
        _printf("%ls\n", (char *)7);
    }
    int64_t v6 = _printf((char *)0x100003905); // 0x100003730
    int64_t result = v6; // 0x10000374c
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003754
        result = ___stack_chk_fail(v6);
    }
    // 0x100003758
    return result;
}

// Address range: 0x100003764 - 0x1000037d0
int64_t entry_point(void) {
    // 0x100003764
    _setlocale(2, (char *)0x100003907);
    function_1000035dc();
    function_1000035dc();
    function_1000035dc();
    function_1000035dc();
    function_1000035dc();
    function_1000035dc();
    return 0;
}

// Address range: 0x1000037d0 - 0x1000037dc
int64_t function_1000037d0(int64_t a1) {
    // 0x1000037d0
    return ___stack_chk_fail(a1);
}

// Address range: 0x1000037dc - 0x1000037e8
void function_1000037dc(int64_t * ptr) {
    // 0x1000037dc
    _free(ptr);
}

// Address range: 0x1000037e8 - 0x1000037f4
int32_t function_1000037e8(int32_t wc) {
    // 0x1000037e8
    return _iswalnum(wc);
}

// Address range: 0x1000037f4 - 0x100003800
int32_t function_1000037f4(int32_t wc) {
    // 0x1000037f4
    return _iswdigit(wc);
}

// Address range: 0x100003800 - 0x10000380c
int32_t function_100003800(int32_t wc) {
    // 0x100003800
    return _iswspace(wc);
}

// Address range: 0x10000380c - 0x100003818
int64_t * function_10000380c(int32_t size) {
    // 0x10000380c
    return _malloc(size);
}

// Address range: 0x100003818 - 0x100003824
int64_t * function_100003818(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003818
    return _memcpy(dest, src, n);
}

// Address range: 0x100003824 - 0x100003830
int32_t function_100003824(char * format, ...) {
    // 0x100003824
    return _printf(format);
}

// Address range: 0x100003830 - 0x10000383c
void function_100003830(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003830
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x10000383c - 0x100003848
int64_t * function_10000383c(int64_t * ptr, int32_t size) {
    // 0x10000383c
    return _realloc(ptr, size);
}

// Address range: 0x100003848 - 0x100003854
char * function_100003848(int32_t category, char * locale) {
    // 0x100003848
    return _setlocale(category, locale);
}

// Address range: 0x100003854 - 0x100003860
int32_t function_100003854(int32_t wc) {
    // 0x100003854
    return _towlower(wc);
}

// Address range: 0x100003860 - 0x10000386c
int32_t function_100003860(int16_t * s1, int16_t * s2) {
    // 0x100003860
    return _wcscmp(s1, s2);
}

// Address range: 0x10000386c - 0x100003878
int32_t function_10000386c(int16_t * s) {
    // 0x10000386c
    return _wcslen(s);
}

// Address range: 0x100003878 - 0x100003884
int32_t function_100003878(int16_t * s1, int16_t * s2, int32_t n) {
    // 0x100003878
    return _wcsncasecmp(s1, s2, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 31

`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

typedef union uwb {
    unsigned w;
    unsigned char b[4];
} WBunion;

typedef unsigned Digest[4];

unsigned f0( unsigned abcd[] ){
    return ( abcd[1] & abcd[2]) | (~abcd[1] & abcd[3]);}

unsigned f1( unsigned abcd[] ){
    return ( abcd[3] & abcd[1]) | (~abcd[3] & abcd[2]);}

unsigned f2( unsigned abcd[] ){
    return  abcd[1] ^ abcd[2] ^ abcd[3];}

unsigned f3( unsigned abcd[] ){
    return abcd[2] ^ (abcd[1] |~ abcd[3]);}

typedef unsigned (*DgstFctn)(unsigned a[]);

unsigned *calcKs( unsigned *k)
{
    double s, pwr;
    int i;

    pwr = pow( 2, 32);
    for (i=0; i<64; i++) {
        s = fabs(sin(1+i));
        k[i] = (unsigned)( s * pwr );
    }
    return k;
}

// ROtate v Left by amt bits
unsigned rol( unsigned v, short amt )
{
    unsigned  msk1 = (1<<amt) -1;
    return ((v>>(32-amt)) & msk1) | ((v<<amt) & ~msk1);
}

unsigned *md5( const char *msg, int mlen)
{
    static Digest h0 = { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476 };
//    static Digest h0 = { 0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210 };
    static DgstFctn ff[] = { &f0, &f1, &f2, &f3 };
    static short M[] = { 1, 5, 3, 7 };
    static short O[] = { 0, 1, 5, 0 };
    static short rot0[] = { 7,12,17,22};
    static short rot1[] = { 5, 9,14,20};
    static short rot2[] = { 4,11,16,23};
    static short rot3[] = { 6,10,15,21};
    static short *rots[] = {rot0, rot1, rot2, rot3 };
    static unsigned kspace[64];
    static unsigned *k;

    static Digest h;
    Digest abcd;
    DgstFctn fctn;
    short m, o, g;
    unsigned f;
    short *rotn;
    union {
        unsigned w[16];
        char     b[64];
    }mm;
    int os = 0;
    int grp, grps, q, p;
    unsigned char *msg2;

    if (k==NULL) k= calcKs(kspace);

    for (q=0; q<4; q++) h[q] = h0[q];   // initialize

    {
        grps  = 1 + (mlen+8)/64;
        msg2 = malloc( 64*grps);
        memcpy( msg2, msg, mlen);
        msg2[mlen] = (unsigned char)0x80;
        q = mlen + 1;
        while (q < 64*grps){ msg2[q] = 0; q++ ; }
        {
//            unsigned char t;
            WBunion u;
            u.w = 8*mlen;
//            t = u.b[0]; u.b[0] = u.b[3]; u.b[3] = t;
//            t = u.b[1]; u.b[1] = u.b[2]; u.b[2] = t;
            q -= 8;
            memcpy(msg2+q, &u.w, 4 );
        }
    }

    for (grp=0; grp<grps; grp++)
    {
        memcpy( mm.b, msg2+os, 64);
        for(q=0;q<4;q++) abcd[q] = h[q];
        for (p = 0; p<4; p++) {
            fctn = ff[p];
            rotn = rots[p];
            m = M[p]; o= O[p];
            for (q=0; q<16; q++) {
                g = (m*q + o) % 16;
                f = abcd[1] + rol( abcd[0]+ fctn(abcd) + k[q+16*p] + mm.w[g], rotn[q%4]);

                abcd[0] = abcd[3];
                abcd[3] = abcd[2];
                abcd[2] = abcd[1];
                abcd[1] = f;
            }
        }
        for (p=0; p<4; p++)
            h[p] += abcd[p];
        os += 64;
    }

    if( msg2 )
        free( msg2 );

    return h;
}

int main( int argc, char *argv[] )
{
    int j,k;
    const char *msg = "The quick brown fox jumps over the lazy dog.";
    unsigned *d = md5(msg, strlen(msg));
    WBunion u;

    printf("= 0x");
    for (j=0;j<4; j++){
        u.w = d[j];
        for (k=0;k<4;k++) printf("%02x",u.b[k]);
    }
    printf("\n");

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000037a4(void);
int64_t function_1000037e0(void);
int64_t function_10000381c(void);
int64_t function_10000384c(void);
int64_t function_10000387c(void);
int64_t function_100003914(void);
int64_t function_100003970(int64_t a1, int64_t a2, int64_t a3);
int64_t function_100003ee4(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t function_100003ef0(void);
void function_100003efc(int64_t * ptr);
int64_t * function_100003f08(int32_t size);
int64_t * function_100003f14(int64_t * dest, int64_t * src, int32_t n);
float64_t function_100003f20(float64_t a1, float64_t a2);
int32_t function_100003f2c(char * format, ...);
float64_t function_100003f38(float64_t a1);
int32_t function_100003f44(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100008180
int32_t * g2 = NULL; // 0x100008188
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t ___stack_chk_fail(void);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);
float64_t _sin(float64_t a1);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000037a4 - 0x1000037e0
int64_t function_1000037a4(void) {
    // 0x1000037a4
    int64_t v1; // 0x1000037a4
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x1000037b0
    int32_t v3 = *(int32_t *)(v1 + 12); // 0x1000037cc
    return (int64_t)(v3 & -1 - v2 | *(int32_t *)(v1 + 8) & v2);
}

// Address range: 0x1000037e0 - 0x10000381c
int64_t function_1000037e0(void) {
    // 0x1000037e0
    int64_t v1; // 0x1000037e0
    int32_t v2 = *(int32_t *)(v1 + 12); // 0x1000037ec
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x100003808
    return (int64_t)(v3 & -1 - v2 | *(int32_t *)(v1 + 4) & v2);
}

// Address range: 0x10000381c - 0x10000384c
int64_t function_10000381c(void) {
    // 0x10000381c
    int64_t v1; // 0x10000381c
    int64_t v2 = v1;
    int32_t v3 = *(int32_t *)(v2 + 12); // 0x10000383c
    return (int64_t)(*(int32_t *)(v2 + 8) ^ *(int32_t *)(v2 + 4) ^ v3);
}

// Address range: 0x10000384c - 0x10000387c
int64_t function_10000384c(void) {
    // 0x10000384c
    int64_t v1; // 0x10000384c
    int32_t v2 = *(int32_t *)(v1 + 12); // 0x100003868
    return (int64_t)((*(int32_t *)(v1 + 4) | -1 - v2) ^ *(int32_t *)(v1 + 8));
}

// Address range: 0x10000387c - 0x100003914
int64_t function_10000387c(void) {
    // 0x10000387c
    int128_t v1; // 0x10000387c
    float64_t v2 = _pow((float64_t)(int64_t)v1, (float64_t)(int64_t)v1); // 0x1000038c8
    int64_t v3 = 0;
    int64_t v4 = v3 + 1;
    v2 = _sin(v2);
    float64_t v5 = fabs((float64_t)(int32_t)v4); // 0x1000038cc
    int64_t result; // 0x10000387c
    *(int32_t *)(4 * v3 + result) = (int32_t)(2.0 * v5);
    while (v4 != 64) {
        // 0x1000038bc
        v3 = v4;
        v4 = v3 + 1;
        v2 = _sin(v2);
        v5 = fabs((float64_t)(int32_t)v4);
        *(int32_t *)(4 * v3 + result) = (int32_t)(2.0 * v5);
    }
    // 0x100003904
    return result;
}

// Address range: 0x100003914 - 0x100003970
int64_t function_100003914(void) {
    // 0x100003914
    int64_t v1; // 0x100003914
    uint32_t v2 = (int32_t)v1; // 0x100003918
    uint32_t v3 = 0x10000 * (int32_t)v1 >> 16; // 0x100003920
    return v2 >> 32 - v3 & -1 - (-1 << v3) | v2 << v3;
}

// Address range: 0x100003970 - 0x100003de0
// Used cryptographic patterns:
//  - Lucifer__outerbridge__DFLTKY (8-bit)
int64_t function_100003970(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x10000398c
    if (g1 == 0) {
        // 0x1000039b8
        g1 = function_10000387c();
    }
    // 0x1000039d0
    int64_t v2; // 0x100003970
    int32_t v3 = v2; // 0x100003998
    for (int64_t i = 0; i < 4; i++) {
        int64_t v4 = 4 * i; // 0x1000039f8
        int32_t v5 = *(int32_t *)(v4 + (int64_t)"\x01#Eg\x89\xab\xcd\xef\xfe\xdc\xba\x98vT2\x10"); // 0x1000039f8
        *(int32_t *)(v4 + (int64_t)&g2) = v5;
    }
    int32_t v6 = v3 + 8; // 0x100003a24
    int32_t v7 = v6 / 64; // 0x100003a2c
    int32_t v8 = v7 + 1; // 0x100003a30
    int32_t v9 = 64 * v8; // 0x100003a3c
    int64_t * v10 = _malloc(v9); // 0x100003a48
    int64_t v11 = (int64_t)v10; // 0x100003a48
    ___memcpy_chk(v11, v2, v3, -1);
    *(char *)((0x100000000 * v2 >> 32) + v11) = -128;
    int32_t v12 = v3 + 1;
    int32_t v13 = v12 - v9; // 0x100003a9c
    int32_t v14 = v3; // 0x100003aa4
    if (v13 < 0 != ((v13 ^ v12) & (v9 ^ v12)) < 0) {
        *(char *)((int64_t)v12 + v11) = 0;
        int32_t v15 = v12 + 1;
        int32_t v16 = v15 - v9; // 0x100003a9c
        v14 = v12;
        while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v9)) < 0) {
            int32_t v17 = v15;
            *(char *)((int64_t)v17 + v11) = 0;
            v15 = v17 + 1;
            v16 = v15 - v9;
            v14 = v17;
        }
    }
    int64_t v18 = 8 * v3; // bp-188, 0x100003adc
    ___memcpy_chk((int64_t)(v14 - 7) + v11, (int64_t)&v18, 4, -1);
    if (v6 > -64 == (v8 & -v7) < 0) {
        if (v10 != NULL) {
            // 0x100003d9c
            _free(v10);
        }
        // 0x100003da8
        if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
            // 0x100003dc8
            ___stack_chk_fail();
        }
        // 0x100003c18
        return (int64_t)&g2;
    }
    // 0x100003b24
    int64_t v19; // bp-152, 0x100003970
    _memcpy(&v19, v10, 64);
    int64_t v20; // bp-40, 0x100003970
    int64_t result = &v20;
    for (int64_t i = 0; i < 4; i++) {
        int64_t v21 = 4 * i; // 0x100003b64
        int32_t v22 = *(int32_t *)(v21 + (int64_t)&g2); // 0x100003b64
        *(int32_t *)(v21 + result) = v22;
    }
    // 0x100003c18
    return result;
}

// Address range: 0x100003de0 - 0x100003ee4
int64_t entry_point(void) {
    int32_t v1 = _strlen("The quick brown fox jumps over the lazy dog."); // 0x100003e10
    function_100003970((int64_t)&g3, (int64_t)&g3, (int64_t)&g3);
    _printf("= 0x");
    for (int32_t i = 0; i < 4; i++) {
        for (int32_t j = 0; j < 4; j++) {
            // 0x100003e7c
            _printf("%02x", v1);
        }
    }
    // 0x100003ec8
    _printf((char *)0x100003f8f);
    return 0;
}

// Address range: 0x100003ee4 - 0x100003ef0
int64_t function_100003ee4(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    // 0x100003ee4
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ef0 - 0x100003efc
int64_t function_100003ef0(void) {
    // 0x100003ef0
    return ___stack_chk_fail();
}

// Address range: 0x100003efc - 0x100003f08
void function_100003efc(int64_t * ptr) {
    // 0x100003efc
    _free(ptr);
}

// Address range: 0x100003f08 - 0x100003f14
int64_t * function_100003f08(int32_t size) {
    // 0x100003f08
    return _malloc(size);
}

// Address range: 0x100003f14 - 0x100003f20
int64_t * function_100003f14(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f14
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f20 - 0x100003f2c
float64_t function_100003f20(float64_t a1, float64_t a2) {
    // 0x100003f20
    return _pow(a1, a2);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * format, ...) {
    // 0x100003f2c
    return _printf(format);
}

// Address range: 0x100003f38 - 0x100003f44
float64_t function_100003f38(float64_t a1) {
    // 0x100003f38
    return _sin(a1);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * s) {
    // 0x100003f44
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 17

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAXD 8
int g[] = { -1, 1, -1, 1 };
/* Perlin-like noise */
static inline void
hashed(int *data, int *out, int len) {
#	define ror(a, d) ((a << (d)) | (a >> (32 - d)))
	register unsigned int h = 0x12345678, tmp;
	unsigned int *d = (void*)data;
	int i = len;

	while (i--) {
		tmp = *d++;
		h += ror(h, 15) ^ ror(tmp, 5);
	}

	h ^= ror(h, 7);
	h += ror(h, 23);
	h ^= ror(h, 19);
	h += ror(h, 11);
	h ^= ror(h, 13);
	h += ror(h, 17);
#	undef ror
	for (i = len; i--; ) {
		out[i] = g[h & 3];
		h >>= 2;
	}
}

double scale[MAXD], scale_u[MAXD];
void noise_init()
{
	int i;
	for (i = 1; i < MAXD; i++) {
		scale[i] = 1 / (1 + sqrt(i + 1));
		scale_u[i] = scale[i] / sqrt(i + 1);
	}
}

double noise(double *x, int d)
{
#	define sum(s, x) for (s = 0, j = 0; j < d; j++) s += x
	register int i, j;
	int n[MAXD], o[MAXD], g[MAXD], tmp;
	double s, r, t, w, ret, u[MAXD];

	sum(s, x[j]);
	s *= scale[d];

	for (i = 0; i < d; i++) {
		o[i] = i;
		t = x[i] + s;
		u[i] = t - (n[i] = floor(t));
	}
	o[d] = 0;

	for (i = 0; i < d - 1; i++)
		for (j = i; j < d; j++)
			if (u[o[i]] < u[o[j]])
				tmp = o[i], o[i] = o[j], o[j] = tmp;

	ret = w = 0, r = 1;
	for (s = 0, j = 0; j < d; j++) s += n[j];
	s *= scale_u[d];

	for (i = 0; i <= d; i++) {
		for (j = 0; j < d; j++)
			u[j] = x[j] + s - n[j];

		for (t = (d + 1.) / (2 * d), j = 0; j < d; j++) {
			t -= u[j] * u[j];
			if (t <= 0) break;
		}

		if (t >= 0) {
			r = 0;
			hashed(n, g, d);
			for (j = 0; j < d; j++)
				if (g[j]) r += (g[j] == 1 ? u[j] : -u[j]);
			t *= t;
			ret += r * t * t;
		}

		if (i < d) {
			n[o[i]]++;
			s += scale_u[d];
		}
	}
	return ret * (d * d);
}

double get_noise2(double x, double y)
{
	int i, ws;
	double r = 0, v[2];

	for (i = 1, ws = 0; i <= 128; i <<= 1) {
		v[0] = x * i, v[1] = y * i;
		r += noise(v, 2);
		ws ++;
	}
	r /= ws;
	return r;
}

double get_noise3(double x, double y, double z)
{
	int i, ws;
	double r = 0, v[3], w;

	for (i = 1, ws = 0; i <= 32; i <<= 1) {
		v[0] = x * i, v[1] = y * i, v[2] = z * i;
		w = 1./sqrt(i);
		r += noise(v, 3) * w;
		ws += w;
	}
	return r / ws;
}


int main(int c, char** v)
{
	unsigned char pix[256 * 256], *p;
	int i, j;
	double x, y, z, w;
	FILE *fp;

	noise_init();

	for (p = pix, i = 0; i < 256 * 256; i++) *p++ = 0;

	for (p = pix, i = 0; i < 256; i++) {
		y = (i - 128) / 125.;
		for (j = 0; j < 256; j++, p++) {
			x = (j - 128) / 125.;
			*p = (get_noise2(i/256., j/256.) + 1) / 6 * i;

			z = 1- x*x - y*y;
			if (z < 0) continue;

			z = sqrt(z);

			w = get_noise3(x, y, z);

			w = (w + 1) / 2;
			w *= (1 + x - y + z) / 3.5;
			if (w < 0) w = 0;

			*p = w * 255;
		}
	}

	fp = fopen("out.pgm", "w+");
	fprintf(fp, "P5\n256 256\n255\n");
	fwrite(pix, 1, 256 * 256, fp);
	fclose(fp);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000031f0(void);
int64_t function_100003288(void);
int64_t function_100003808(void);
int64_t function_1000039a4(void);
int64_t function_100003ac0(void);
int64_t function_100003c48(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f1c(int64_t a1, int128_t a2, int128_t a3);
int32_t function_100003f28(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f34(char * filename, char * modes);
int32_t function_100003f40(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f4c(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);

// --------------------- Global Variables ---------------------

float64_t g1 = 255.0; // 0x100003f58
float64_t g2 = 256.0; // 0x100003f60
float64_t g3 = 125.0; // 0x100003f68
int32_t * g4 = (int32_t *)0x1ffffffff; // 0x100008000
float64_t * g5 = (float64_t *)0x100000cfeedfacf; // 0x100008010
float64_t * g6 = (float64_t *)0x100000000; // 0x100008050

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1, int128_t a2, int128_t a3);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);

// ------------------------ Functions -------------------------

// Address range: 0x1000031f0 - 0x100003288
int64_t function_1000031f0(void) {
    int64_t v1 = 1;
    int64_t v2 = v1 + 1;
    float64_t v3 = sqrt((float64_t)(int32_t)v2); // 0x100003220
    float64_t v4 = 1.0 / (v3 + 1.0); // 0x10000322c
    int64_t v5 = 8 * v1; // 0x10000323c
    *(float64_t *)(v5 + (int64_t)&g5) = v4;
    *(float64_t *)(v5 + (int64_t)&g6) = v4 / v3;
    while (v2 != 8) {
        // 0x100003214
        v1 = v2;
        v2 = v1 + 1;
        v3 = sqrt((float64_t)(int32_t)v2);
        v4 = 1.0 / (v3 + 1.0);
        v5 = 8 * v1;
        *(float64_t *)(v5 + (int64_t)&g5) = v4;
        *(float64_t *)(v5 + (int64_t)&g6) = v4 / v3;
    }
    // 0x100003280
    int64_t result; // 0x1000031f0
    return result;
}

// Address range: 0x100003288 - 0x100003808
int64_t function_100003288(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000032a0
    int64_t v2; // 0x100003288
    int32_t v3 = v2; // 0x1000032ac
    int32_t v4 = -v3;
    int32_t v5 = 0; // 0x1000032d0
    float64_t v6 = 0.0; // 0x1000032d0
    int64_t v7; // 0x100003288
    int64_t v8; // 0x100003288
    int64_t v9; // 0x100003288
    int64_t v10; // bp-104, 0x100003288
    int64_t v11; // bp-200, 0x100003288
    int64_t v12; // bp-72, 0x100003288
    if (v4 < 0 == (v4 & v3) < 0) {
        int64_t v13 = 0x100000000 * v2;
        v8 = v13 >> 29;
        v9 = v13;
        v7 = &v10;
    } else {
        v6 += *(float64_t *)(8 * (int64_t)v5 + v2);
        v5++;
        while (v5 - v3 < 0 != ((v5 - v3 ^ v5) & (v5 ^ v3)) < 0) {
            // 0x1000032d8
            v6 += *(float64_t *)(8 * (int64_t)v5 + v2);
            v5++;
        }
        int64_t v14 = 0x100000000 * v2;
        int64_t v15 = v14 >> 29; // 0x100003310
        float64_t v16 = v6 * *(float64_t *)(v15 + (int64_t)&g5); // 0x100003318
        int64_t v17 = &v10;
        int64_t v18 = &v11;
        int32_t v19 = 0; // 0x10000339c
        int64_t v20 = v19; // 0x100003344
        int64_t v21 = 4 * v20; // 0x10000334c
        *(int32_t *)(v21 + v17) = v19;
        int64_t v22 = 8 * v20; // 0x100003358
        float64_t v23 = v16 + *(float64_t *)(v22 + v2); // 0x100003360
        int32_t v24 = __asm_fcvtms(v23); // 0x100003370
        *(int32_t *)(v21 + (int64_t)&v12) = v24;
        *(float64_t *)(v22 + v18) = v23 - (float64_t)v24;
        v19++;
        int32_t v25 = v19 - v3; // 0x100003330
        v8 = v15;
        v9 = v14;
        v7 = v17;
        while (v25 < 0 != ((v25 ^ v19) & (v19 ^ v3)) < 0) {
            // 0x100003340
            v20 = v19;
            v21 = 4 * v20;
            *(int32_t *)(v21 + v17) = v19;
            v22 = 8 * v20;
            v23 = v16 + *(float64_t *)(v22 + v2);
            v24 = __asm_fcvtms(v23);
            *(int32_t *)(v21 + (int64_t)&v12) = v24;
            *(float64_t *)(v22 + v18) = v23 - (float64_t)v24;
            v19++;
            v25 = v19 - v3;
            v8 = v15;
            v9 = v14;
            v7 = v17;
        }
    }
    // 0x1000033a8
    *(int32_t *)((v9 >> 30) + v7) = 0;
    int32_t v26 = v3 - 1; // 0x1000033c8
    int32_t v27 = 1 - v3; // 0x1000033cc
    if (v27 < 0 != (v27 & v26) < 0) {
        int64_t v28 = &v11;
        int32_t v29 = 0;
        int32_t v30 = v29 - v3; // 0x1000033f0
        int32_t * v31; // 0x100003408
        int32_t v32; // 0x100003408
        int32_t * v33; // 0x100003418
        int32_t v34; // 0x100003418
        float64_t v35; // 0x10000341c
        int32_t v36; // 0x100003468
        if (v30 < 0 != ((v30 ^ v29) & (v29 ^ v3)) < 0) {
            // 0x100003400
            v31 = (int32_t *)(4 * (int64_t)v29 + v7);
            v36 = v29;
            v32 = *v31;
            v33 = (int32_t *)(4 * (int64_t)v36 + v7);
            v34 = *v33;
            v35 = *(float64_t *)(8 * (int64_t)v34 + v28);
            if (*(float64_t *)(8 * (int64_t)v32 + v28) > v35) {
                // 0x100003430
                *v31 = v34;
                *v33 = v32;
            }
            // 0x100003464
            v36++;
            while (v36 - v3 < 0 != ((v36 - v3 ^ v36) & (v36 ^ v3)) < 0) {
                // 0x100003400
                v32 = *v31;
                v33 = (int32_t *)(4 * (int64_t)v36 + v7);
                v34 = *v33;
                v35 = *(float64_t *)(8 * (int64_t)v34 + v28);
                if (*(float64_t *)(8 * (int64_t)v32 + v28) > v35) {
                    // 0x100003430
                    *v31 = v34;
                    *v33 = v32;
                }
                // 0x100003464
                v36++;
            }
        }
        int32_t v37 = v29 + 1; // 0x10000347c
        while (v37 - v26 < 0 != ((v37 - v26 ^ v37) & (v37 ^ v26)) < 0) {
            // 0x1000033e8
            v29 = v37;
            v30 = v29 - v3;
            if (v30 < 0 != ((v30 ^ v29) & (v29 ^ v3)) < 0) {
                // 0x100003400
                v31 = (int32_t *)(4 * (int64_t)v29 + v7);
                v36 = v29;
                v32 = *v31;
                v33 = (int32_t *)(4 * (int64_t)v36 + v7);
                v34 = *v33;
                v35 = *(float64_t *)(8 * (int64_t)v34 + v28);
                if (*(float64_t *)(8 * (int64_t)v32 + v28) > v35) {
                    // 0x100003430
                    *v31 = v34;
                    *v33 = v32;
                }
                // 0x100003464
                v36++;
                while (v36 - v3 < 0 != ((v36 - v3 ^ v36) & (v36 ^ v3)) < 0) {
                    // 0x100003400
                    v32 = *v31;
                    v33 = (int32_t *)(4 * (int64_t)v36 + v7);
                    v34 = *v33;
                    v35 = *(float64_t *)(8 * (int64_t)v34 + v28);
                    if (*(float64_t *)(8 * (int64_t)v32 + v28) > v35) {
                        // 0x100003430
                        *v31 = v34;
                        *v33 = v32;
                    }
                    // 0x100003464
                    v36++;
                }
            }
            // 0x100003478
            v37 = v29 + 1;
        }
    }
    int32_t v38 = 0; // 0x1000034b8
    int128_t v39; // 0x100003288
    if (v4 < 0 != (v4 & v3) < 0) {
        v38++;
        int32_t v40 = v38 - v3; // 0x1000034b0
        v39 = __asm_sshll(0.0f, 0);
        while (v40 < 0 != ((v40 ^ v38) & (v38 ^ v3)) < 0) {
            // 0x1000034c0
            v38++;
            v40 = v38 - v3;
            v39 = __asm_sshll(0.0f, 0);
        }
    }
    float64_t * v41 = (float64_t *)(v8 + (int64_t)&g6); // 0x100003504
    int128_t v42 = v39; // 0x10000352c
    bool v43; // 0x100003288
    bool v44; // 0x100003288
    int128_t v45; // 0x100003288
    float64_t v46; // 0x100003288
    float64_t v47; // 0x100003288
    float64_t v48; // 0x100003288
    float64_t v49; // 0x100003288
    float64_t v50; // 0x100003288
    float64_t v51; // 0x100003288
    float64_t v52; // 0x100003288
    float64_t v53; // 0x100003288
    int32_t v54; // 0x100003288
    int32_t v55; // 0x100003288
    int128_t v56; // 0x100003288
    int128_t v57; // 0x100003288
    int64_t v58; // 0x100003288
    int64_t v59; // 0x100003288
    int64_t v60; // 0x100003288
    if (v3 == 0 || v4 < 0 != (v4 & v3) < 0) {
        float64_t v61 = 0.0; // 0x10000350c
        v58 = &v11;
        float64_t v62 = 2 * v3;
        v43 = v4 < 0;
        v44 = (v4 & v3) < 0;
        v54 = 0;
        v46 = v61;
        v51 = 0.0;
        v48 = v61;
        while (true) {
          lab_0x10000353c:
            // 0x10000353c
            v49 = v48;
            v52 = v51;
            int64_t v63 = v59;
            v55 = v54;
            int32_t v64 = 0; // 0x10000354c
            float64_t v65; // 0x100003288
            if (v4 < 0 == (v4 & v3) < 0) {
                // 0x1000035a4
                v45 = __asm_sshll(0.0f, 0);
                v57 = v56;
                v65 = (v46 + 1.0) / v62;
            } else {
                int64_t v66 = 8 * (int64_t)v64; // 0x10000355c
                int128_t v67 = __asm_sshll(0.0f, 0); // 0x100003578
                float64_t v68 = v49 + *(float64_t *)(v66 + v2) - v49; // 0x100003580
                *(float64_t *)(v66 + v58) = v68;
                int32_t v69 = v64 + 1; // 0x100003598
                int32_t v70 = v69 - v3; // 0x100003544
                v64 = v69;
                while (v70 < 0 != ((v70 ^ v69) & (v69 ^ v3)) < 0) {
                    // 0x100003554
                    v66 = 8 * (int64_t)v64;
                    v67 = __asm_sshll(0.0f, 0);
                    v68 = v49 + *(float64_t *)(v66 + v2) - v49;
                    *(float64_t *)(v66 + v58) = v68;
                    v69 = v64 + 1;
                    v70 = v69 - v3;
                    v64 = v69;
                }
                int128_t v71 = __asm_sshll(0.0f, 0); // 0x1000035ac
                float64_t v72 = (v68 + 1.0) / v62; // 0x10000360c
                int32_t v73 = 0;
                float64_t v74 = *(float64_t *)(8 * (int64_t)v73 + v58); // 0x1000035fc
                v72 -= v74 * v74;
                v45 = v71;
                v57 = v67;
                v65 = v72;
                while (v72 <= 0.0 == (v72 != 0.0)) {
                    int32_t v75 = v73 + 1; // 0x100003634
                    int32_t v76 = v75 - v3; // 0x1000035e4
                    v45 = v71;
                    v57 = v67;
                    v65 = v72;
                    if (v76 < 0 == ((v76 ^ v75) & (v75 ^ v3)) < 0) {
                        // break -> 0x100003640
                        break;
                    }
                    v73 = v75;
                    v74 = *(float64_t *)(8 * (int64_t)v73 + v58);
                    v72 -= v74 * v74;
                    v45 = v71;
                    v57 = v67;
                    v65 = v72;
                }
            }
            // 0x100003640
            v50 = v65;
            if (v50 == 0.0) {
                goto lab_0x100003654;
            } else {
                v53 = v52;
                v47 = v50;
                v60 = v63;
                if (v50 > 0.0 == v50 >= 0.0 == v50 <= 0.0) {
                    goto lab_0x100003654;
                } else {
                    goto lab_0x100003748;
                }
            }
        }
    }
  lab_0x1000037b4:;
    // 0x1000037b4
    int64_t v77; // 0x100003288
    int64_t result = v77; // 0x1000037e8
    int128_t v78; // 0x100003288
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x1000037f0
        result = ___stack_chk_fail(v77, v42, v78);
    }
    // 0x1000037f4
    return result;
  lab_0x100003654:;
    int64_t v79 = function_100003808(); // 0x100003668
    int32_t v80 = 0; // 0x100003684
    float64_t v81 = 0.0; // 0x100003684
    if (v4 < 0 != (v4 & v3) < 0) {
        float64_t v82 = 0.0;
        int64_t v83 = v80; // 0x10000368c
        int64_t v84; // bp-136, 0x100003288
        int32_t v85 = *(int32_t *)(4 * v83 + (int64_t)&v84); // 0x100003694
        float64_t v86 = v82; // 0x1000036a0
        float64_t v87; // 0x100003288
        int64_t v88; // 0x100003288
        if (v85 != 0) {
            // 0x1000036a8
            v88 = 8 * v83 + v58;
            if (v85 == 1) {
                // 0x1000036c4
                v87 = (float64_t)*(int64_t *)v88;
            } else {
                // 0x1000036d8
                v87 = -*(float64_t *)v88;
            }
            // 0x1000036f0
            v86 = v82 + v87;
        }
        int32_t v89 = v80 + 1; // 0x10000370c
        int32_t v90 = v89 - v3; // 0x10000367c
        v80 = v89;
        v81 = v86;
        while (v90 < 0 != ((v90 ^ v89) & (v89 ^ v3)) < 0) {
            // 0x10000368c
            v82 = v86;
            v83 = v80;
            v85 = *(int32_t *)(4 * v83 + (int64_t)&v84);
            v86 = v82;
            if (v85 != 0) {
                // 0x1000036a8
                v88 = 8 * v83 + v58;
                if (v85 == 1) {
                    // 0x1000036c4
                    v87 = (float64_t)*(int64_t *)v88;
                } else {
                    // 0x1000036d8
                    v87 = -*(float64_t *)v88;
                }
                // 0x1000036f0
                v86 = v82 + v87;
            }
            // 0x100003708
            v89 = v80 + 1;
            v90 = v89 - v3;
            v80 = v89;
            v81 = v86;
        }
    }
    float64_t v91 = v50 * v50; // 0x100003720
    float64_t v92 = v52 + v91 * v91 * v81; // 0x10000373c
    v53 = v92;
    v47 = v92;
    v60 = v79;
    goto lab_0x100003748;
  lab_0x100003748:;
    float64_t v93 = v49; // 0x100003758
    float64_t v94 = v47; // 0x100003758
    if (v43 != v44) {
        int32_t v95 = *(int32_t *)(4 * (int64_t)v55 + v7); // 0x100003768
        int32_t * v96 = (int32_t *)(4 * (int64_t)v95 + (int64_t)&v12); // 0x100003774
        *v96 = *v96 + 1;
        float64_t v97 = v49 + *v41; // 0x100003794
        v93 = v97;
        v94 = v97;
    }
    int32_t v98 = v55 + 1; // 0x1000037a8
    int32_t v99 = v98 - v3; // 0x100003524
    v43 = v99 < 0;
    v44 = ((v99 ^ v98) & (v98 ^ v3)) < 0;
    v54 = v98;
    v59 = v60;
    v46 = v94;
    v56 = v57;
    v51 = v53;
    v48 = v93;
    v42 = v45;
    v78 = v57;
    v77 = v60;
    if (v99 != 0 && v99 < 0 == ((v99 ^ v98) & (v98 ^ v3)) < 0) {
        // break -> 0x1000037b4
        goto lab_0x1000037b4;
    }
    goto lab_0x10000353c;
}

// Address range: 0x100003808 - 0x1000039a4
int64_t function_100003808(void) {
    // 0x100003808
    int64_t result; // 0x100003808
    int32_t v1 = result; // 0x100003814
    int32_t v2 = v1; // 0x10000384c
    int32_t v3 = 0x12345678; // 0x10000384c
    if (v1 != 0) {
        uint32_t v4 = 0x12345678;
        v2--;
        int64_t v5; // 0x100003808
        uint32_t v6 = *(int32_t *)v5; // 0x100003860
        int32_t v7 = ((v6 / 0x8000000 | 32 * v6) ^ (v4 / 0x20000 | 0x8000 * v4)) + v4; // 0x100003890
        v5 += 4;
        v3 = v7;
        while (v2 != 0) {
            // 0x100003854
            v4 = v7;
            v2--;
            v6 = *(int32_t *)v5;
            v7 = ((v6 / 0x8000000 | 32 * v6) ^ (v4 / 0x20000 | 0x8000 * v4)) + v4;
            v5 += 4;
            v3 = v7;
        }
    }
    if (v1 == 0) {
        // 0x10000399c
        return result;
    }
    uint32_t v8 = v3;
    uint32_t v9 = (v8 / 0x2000000 | 128 * v8) ^ v8; // 0x1000038b0
    uint32_t v10 = (v9 / 512 | 0x800000 * v9) + v9; // 0x1000038cc
    uint32_t v11 = (v10 / 0x2000 | 0x80000 * v10) ^ v10; // 0x1000038e8
    uint32_t v12 = (v11 / 0x200000 | 2048 * v11) + v11; // 0x100003904
    uint32_t v13 = (v12 / 0x80000 | 0x2000 * v12) ^ v12; // 0x100003920
    int32_t v14 = v1;
    int32_t v15 = (v13 / 0x8000 | 0x20000 * v13) + v13; // 0x100003808
    v14--;
    int32_t v16 = *(int32_t *)((int64_t)(4 * v15 & 12) + (int64_t)&g4); // 0x10000397c
    *(int32_t *)(4 * (int64_t)v14 + result) = v16;
    v15 /= 4;
    while (v14 != 0) {
        // 0x10000396c
        v14--;
        v16 = *(int32_t *)((int64_t)(4 * v15 & 12) + (int64_t)&g4);
        *(int32_t *)(4 * (int64_t)v14 + result) = v16;
        v15 /= 4;
    }
    // 0x10000399c
    return result;
}

// Address range: 0x1000039a4 - 0x100003ac0
int64_t function_1000039a4(void) {
    // 0x1000039a4
    __asm_sshll(0.0f, 0);
    int32_t v1 = 1; // 0x100003a5c
    int128_t v2 = __asm_sshll(0.0f, 0); // 0x100003a20
    int64_t v3 = function_100003288(); // 0x100003a34
    v1 *= 2;
    int32_t v4 = v1 - 128; // 0x1000039e4
    int128_t v5 = __asm_sshll(0.0f, 0);
    while (v4 == 0 || v4 < 0 != (127 - v1 & v1) < 0) {
        // 0x1000039f4
        v2 = __asm_sshll(0.0f, 0);
        v3 = function_100003288();
        v1 *= 2;
        v4 = v1 - 128;
        v5 = __asm_sshll(0.0f, 0);
    }
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003a98
    int64_t result = v3; // 0x100003aa4
    if (v6 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003aac
        result = ___stack_chk_fail(v3, v5, v2);
    }
    // 0x100003ab0
    return result;
}

// Address range: 0x100003ac0 - 0x100003c28
int64_t function_100003ac0(void) {
    // 0x100003ac0
    __asm_sshll(0.0f, 0);
    int32_t v1 = 1; // 0x100003bcc
    __asm_sshll(0.0f, 0);
    __asm_sshll(0.0f, 0);
    __asm_sshll(0.0f, 0);
    int64_t v2 = function_100003288(); // 0x100003b90
    int128_t v3 = __asm_sshll(0.0f, 0); // 0x100003bb0
    v1 *= 2;
    int32_t v4 = v1 - 32; // 0x100003b04
    int128_t v5 = __asm_sshll(0.0f, 0);
    while (v4 == 0 || v4 < 0 != (31 - v1 & v1) < 0) {
        // 0x100003b14
        __asm_sshll(0.0f, 0);
        __asm_sshll(0.0f, 0);
        __asm_sshll(0.0f, 0);
        v2 = function_100003288();
        v3 = __asm_sshll(0.0f, 0);
        v1 *= 2;
        v4 = v1 - 32;
        v5 = __asm_sshll(0.0f, 0);
    }
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c00
    int64_t result = v2; // 0x100003c0c
    if (v6 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003c14
        result = ___stack_chk_fail(v2, v3, v5);
    }
    // 0x100003c18
    return result;
}

// Address range: 0x100003c28 - 0x100003c48
int64_t entry_point(void) {
    // 0x100003c28
    return ___chkstk_darwin();
}

// Address range: 0x100003c48 - 0x100003f1c
int64_t function_100003c48(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003c48
    int64_t v1; // 0x100003c48
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003c5c
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    function_1000031f0();
    int64_t v3; // bp-65544, 0x100003c48
    char * v4 = (char *)&v3; // 0x100003c48
    int32_t v5 = 0;
    *v4 = 0;
    int32_t v6 = v5 + 1; // 0x100003cac
    v4 = (char *)((int64_t)v4 + 1);
    while (v5 < 0xffff != (0xfffe - v5 & v6) < 0) {
        // 0x100003c94
        v5 = v6;
        *v4 = 0;
        v6 = v5 + 1;
        v4 = (char *)((int64_t)v4 + 1);
    }
    int32_t v7 = 0;
    float64_t v8 = (float64_t)(v7 - 128) / g3; // 0x100003cf0
    int32_t v9 = 0;
    char * v10 = (char *)&v3;
    float64_t v11 = (float64_t)(v9 - 128) / g3; // 0x100003d28
    int128_t v12 = __asm_sshll(0.0f, 0); // 0x100003d38
    __asm_sshll(0.0f, 0);
    function_1000039a4();
    int128_t v13 = __asm_sshll(0.0f, 0); // 0x100003d7c
    *v10 = (char)(int32_t)(6.0 * (v11 / g2 + 1.0) / 6.0);
    float64_t v14 = 1.0 - v11 * v11 - v8 * v8; // 0x100003da8
    float64_t v15; // 0x100003c48
    float64_t v16; // 0x100003dcc
    float64_t v17; // 0x100003df0
    float64_t v18; // 0x100003e24
    if (v14 <= 0.0) {
        // 0x100003dc8
        v16 = sqrt(v14);
        function_100003ac0();
        v17 = v11 + 1.0;
        v18 = 0.5 * v17 * (v17 - v8 + v16) / 3.5;
        v15 = v18 > 0.0 ? 0.0 : v18;
        *v10 = (char)(int32_t)(v15 * g1);
    }
    int32_t v19 = v9 + 1; // 0x100003e70
    char * v20 = (char *)((int64_t)v10 + 1);
    while (v9 < 255 != (254 - v9 & v19) < 0) {
        // 0x100003e6c
        v9 = v19;
        v10 = v20;
        v11 = (float64_t)(v9 - 128) / g3;
        v12 = __asm_sshll(0.0f, 0);
        __asm_sshll(0.0f, 0);
        function_1000039a4();
        v13 = __asm_sshll(0.0f, 0);
        *v10 = (char)(int32_t)(6.0 * (v11 / g2 + 1.0) / 6.0);
        v14 = 1.0 - v11 * v11 - v8 * v8;
        if (v14 <= 0.0) {
            // 0x100003dc8
            v16 = sqrt(v14);
            function_100003ac0();
            v17 = v11 + 1.0;
            v18 = 0.5 * v17 * (v17 - v8 + v16) / 3.5;
            v15 = v18 > 0.0 ? 0.0 : v18;
            *v10 = (char)(int32_t)(v15 * g1);
        }
        // 0x100003e6c
        v19 = v9 + 1;
        v20 = (char *)((int64_t)v10 + 1);
    }
    int32_t v21 = v7 + 1; // 0x100003e90
    while (v7 < 255 != (254 - v7 & v21) < 0) {
        // 0x100003cdc
        v7 = v21;
        v8 = (float64_t)(v7 - 128) / g3;
        v9 = 0;
        v10 = v20;
        v11 = (float64_t)(v9 - 128) / g3;
        v12 = __asm_sshll(0.0f, 0);
        __asm_sshll(0.0f, 0);
        function_1000039a4();
        v13 = __asm_sshll(0.0f, 0);
        *v10 = (char)(int32_t)(6.0 * (v11 / g2 + 1.0) / 6.0);
        v14 = 1.0 - v11 * v11 - v8 * v8;
        if (v14 <= 0.0) {
            // 0x100003dc8
            v16 = sqrt(v14);
            function_100003ac0();
            v17 = v11 + 1.0;
            v18 = 0.5 * v17 * (v17 - v8 + v16) / 3.5;
            v15 = v18 > 0.0 ? 0.0 : v18;
            *v10 = (char)(int32_t)(v15 * g1);
        }
        // 0x100003e6c
        v19 = v9 + 1;
        v20 = (char *)((int64_t)v10 + 1);
        while (v9 < 255 != (254 - v9 & v19) < 0) {
            // 0x100003e6c
            v9 = v19;
            v10 = v20;
            v11 = (float64_t)(v9 - 128) / g3;
            v12 = __asm_sshll(0.0f, 0);
            __asm_sshll(0.0f, 0);
            function_1000039a4();
            v13 = __asm_sshll(0.0f, 0);
            *v10 = (char)(int32_t)(6.0 * (v11 / g2 + 1.0) / 6.0);
            v14 = 1.0 - v11 * v11 - v8 * v8;
            if (v14 <= 0.0) {
                // 0x100003dc8
                v16 = sqrt(v14);
                function_100003ac0();
                v17 = v11 + 1.0;
                v18 = 0.5 * v17 * (v17 - v8 + v16) / 3.5;
                v15 = v18 > 0.0 ? 0.0 : v18;
                *v10 = (char)(int32_t)(v15 * g1);
            }
            // 0x100003e6c
            v19 = v9 + 1;
            v20 = (char *)((int64_t)v10 + 1);
        }
        // 0x100003e8c
        v21 = v7 + 1;
    }
    struct _IO_FILE * v22 = _fopen("out.pgm", "w+"); // 0x100003eac
    _fprintf(v22, "P5\n256 256\n255\n");
    _fwrite(&v3, 1, 0x10000, v22);
    int32_t v23 = _fclose(v22); // 0x100003edc
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003f00
        ___stack_chk_fail((int64_t)v23, v12, v13);
    }
    // 0x100003f04
    return 0;
}

// Address range: 0x100003f1c - 0x100003f28
int64_t function_100003f1c(int64_t a1, int128_t a2, int128_t a3) {
    // 0x100003f1c
    return ___stack_chk_fail(a1, a2, a3);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(struct _IO_FILE * stream) {
    // 0x100003f28
    return _fclose(stream);
}

// Address range: 0x100003f34 - 0x100003f40
struct _IO_FILE * function_100003f34(char * filename, char * modes) {
    // 0x100003f34
    return _fopen(filename, modes);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f40
    return _fprintf(stream, format);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003f4c
    return _fwrite(ptr, size, n, s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>
#include <stdlib.h>

int main()
{
	char *a = malloc(2), *b = 0, *x, c;
	int cnt, len = 1;

	for (sprintf(a, "1"); (b = realloc(b, len * 2 + 1)); a = b, b = x) {
		puts(x = a);
		for (len = 0, cnt = 1; (c = *a); ) {
			if (c == *++a)
				cnt++;
			else if (c) {
				len += sprintf(b + len, "%d%c", cnt, c);
				cnt = 1;
			}
		}
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f70(int64_t a1, int32_t a2, int64_t a3, int64_t a4);
int64_t * function_100003f7c(int32_t size);
int32_t function_100003f88(char * s);
int64_t * function_100003f94(int64_t * ptr, int32_t size);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(int64_t a1, int32_t a2, int64_t a3, int64_t a4);
int64_t * _malloc(int32_t a1);
int32_t _puts(char * a1);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003dec - 0x100003f70
int64_t entry_point(void) {
    int64_t * v1 = _malloc(2); // 0x100003e08
    ___sprintf_chk((int64_t)v1, 0, -1, 0x100003fa0);
    int64_t * v2 = _realloc(NULL, 3); // 0x100003e50
    if (v2 == NULL) {
        // 0x100003f60
        return 0;
    }
    int64_t * v3 = v2;
    _puts((char *)v1);
    char v4 = *(char *)v1; // 0x100003e8c
    int32_t v5 = 0; // 0x100003e9c
    char * v6; // 0x100003dec
    char v7; // 0x100003dec
    char v8; // 0x100003e8c
    int32_t v9; // 0x100003dec
    int32_t v10; // 0x100003dec
    int32_t v11; // 0x100003dec
    int64_t v12; // 0x100003dec
    char * v13; // 0x100003eb0
    int64_t v14; // 0x100003f24
    if (v4 != 0) {
        // 0x100003ea4
        v12 = (int64_t)v3;
        v9 = 0;
        v13 = (char *)((int64_t)(char *)v1 + 1);
        v7 = v4;
        v10 = v9;
        if (v4 != *v13) {
            // 0x100003eec
            v14 = ___sprintf_chk((int64_t)v9 + v12, 0, -1, (int64_t)"%d%c");
            v7 = *v13;
            v10 = v9 + (int32_t)v14;
        }
        // 0x100003f44
        v11 = v10;
        v8 = v7;
        v6 = v13;
        v5 = v11;
        while (v8 != 0) {
            // 0x100003ea4
            v9 = v11;
            v13 = (char *)((int64_t)v6 + 1);
            v7 = v8;
            v10 = v9;
            if (v8 != *v13) {
                // 0x100003eec
                v14 = ___sprintf_chk((int64_t)v9 + v12, 0, -1, (int64_t)"%d%c");
                v7 = *v13;
                v10 = v9 + (int32_t)v14;
            }
            // 0x100003f44
            v11 = v10;
            v8 = v7;
            v6 = v13;
            v5 = v11;
        }
    }
    int64_t * v15 = _realloc(v1, 2 * v5 | 1); // 0x100003e50
    while (v15 != NULL) {
        int64_t * v16 = v3;
        v3 = v15;
        _puts((char *)v16);
        v4 = *(char *)v16;
        v5 = 0;
        if (v4 != 0) {
            // 0x100003ea4
            v12 = (int64_t)v3;
            v9 = 0;
            v13 = (char *)((int64_t)(char *)v16 + 1);
            v7 = v4;
            v10 = v9;
            if (v4 != *v13) {
                // 0x100003eec
                v14 = ___sprintf_chk((int64_t)v9 + v12, 0, -1, (int64_t)"%d%c");
                v7 = *v13;
                v10 = v9 + (int32_t)v14;
            }
            // 0x100003f44
            v11 = v10;
            v8 = v7;
            v6 = v13;
            v5 = v11;
            while (v8 != 0) {
                // 0x100003ea4
                v9 = v11;
                v13 = (char *)((int64_t)v6 + 1);
                v7 = v8;
                v10 = v9;
                if (v8 != *v13) {
                    // 0x100003eec
                    v14 = ___sprintf_chk((int64_t)v9 + v12, 0, -1, (int64_t)"%d%c");
                    v7 = *v13;
                    v10 = v9 + (int32_t)v14;
                }
                // 0x100003f44
                v11 = v10;
                v8 = v7;
                v6 = v13;
                v5 = v11;
            }
        }
        // 0x100003f4c
        v15 = _realloc(v16, 2 * v5 | 1);
    }
    // 0x100003f60
    return 0;
}

// Address range: 0x100003f70 - 0x100003f7c
int64_t function_100003f70(int64_t a1, int32_t a2, int64_t a3, int64_t a4) {
    // 0x100003f70
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f7c - 0x100003f88
int64_t * function_100003f7c(int32_t size) {
    // 0x100003f7c
    return _malloc(size);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * s) {
    // 0x100003f88
    return _puts(s);
}

// Address range: 0x100003f94 - 0x100003fa0
int64_t * function_100003f94(int64_t * ptr, int32_t size) {
    // 0x100003f94
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>

/* C's % operator actually calculates the remainder of a / b so we need a
 * small adjustment so it works as expected for negative values */
#define mod(n,m) ((((n) % (m)) + (m)) % (m))

int is_prime(unsigned int n)
{
    if (n <= 3) {
        return n > 1;
    }
    else if (!(n % 2) || !(n % 3)) {
        return 0;
    }
    else {
        unsigned int i;
        for (i = 5; i*i <= n; i += 6)
            if (!(n % i) || !(n % (i + 2)))
                return 0;
        return 1;
    }
}

void carmichael3(int p1)
{
    if (!is_prime(p1)) return;

    int h3, d, p2, p3;
    for (h3 = 1; h3 < p1; ++h3) {
        for (d = 1; d < h3 + p1; ++d) {
            if ((h3 + p1)*(p1 - 1) % d == 0 && mod(-p1 * p1, h3) == d % h3) {
                p2 = 1 + ((p1 - 1) * (h3 + p1)/d);
                if (!is_prime(p2)) continue;
                p3 = 1 + (p1 * p2 / h3);
                if (!is_prime(p3) || (p2 * p3) % (p1 - 1) != 1) continue;
                printf("%d %d %d\n", p1, p2, p3);
            }
        }
    }
}

int main(void)
{
    int p1;
    for (p1 = 2; p1 < 62; ++p1)
        carmichael3(p1);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bd8(void);
int64_t function_100003d08(void);
int32_t function_100003f88(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bd8 - 0x100003d08
int64_t function_100003bd8(void) {
    // 0x100003bd8
    int64_t v1; // 0x100003bd8
    uint32_t v2 = (int32_t)v1; // 0x100003bdc
    if (v2 >= 3 != v2 != 3) {
        // 0x100003cfc
        return v2 != 0 == (v2 != 1);
    }
    // 0x100003c0c
    if (v2 % 3 == 0 || 2 * v2 / 2 == v2) {
        // 0x100003cfc
        return 0;
    }
    // 0x100003c68
    if (v2 <= 25 == (v2 != 25)) {
        // 0x100003cfc
        return 1;
    }
    int32_t v3 = 5; // 0x100003c80
    int64_t result = 0; // 0x100003ca4
    while (v2 % v3 != 0) {
        // 0x100003cac
        result = 0;
        if (v2 % (v3 + 2) == 0) {
            // break -> 0x100003cfc
            break;
        }
        // 0x100003c68
        v3 += 6;
        uint32_t v4 = v3 * v3; // 0x100003c70
        result = 1;
        if (v4 >= v2 == (v4 != v2)) {
            // break -> 0x100003cfc
            break;
        }
        result = 0;
    }
    // 0x100003cfc
    return result;
}

// Address range: 0x100003d08 - 0x100003f2c
int64_t function_100003d08(void) {
    int64_t result = function_100003bd8(); // 0x100003d1c
    if ((int32_t)result == 0) {
        // 0x100003f20
        return result;
    }
    // 0x100003d40
    int64_t v1; // 0x100003d08
    int32_t v2 = v1; // 0x100003d14
    int32_t v3 = 1 - v2; // 0x100003d48
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003f20
        return result;
    }
    int32_t v4 = v2 - 1;
    int32_t v5 = -1 * v2 * v2;
    int32_t v6 = 1;
    int32_t v7 = v6 + v2; // 0x100003d70
    int32_t v8 = 1 - v7; // 0x100003d74
    int64_t v9 = result; // 0x100003d7c
    int32_t v10; // 0x100003d08
    int32_t v11; // 0x100003d98
    int32_t v12; // 0x100003f00
    int32_t v13; // 0x100003d74
    int64_t v14; // 0x100003e40
    int64_t v15; // 0x100003e78
    int32_t v16; // 0x100003e34
    int64_t v17; // 0x100003d08
    int64_t v18; // 0x100003d08
    int64_t v19; // 0x100003d08
    if (v8 < 0 != (v8 & v7) < 0) {
        // 0x100003d84
        v11 = v7 * v4;
        v10 = 1;
        v18 = result;
        if (v11 % v10 == 0) {
            // 0x100003dbc
            v18 = result;
            if ((v5 % v6 + v6) % v6 == v10 % v6) {
                // 0x100003e14
                v14 = function_100003bd8();
                v18 = v14;
                if ((int32_t)v14 != 0) {
                    // 0x100003e58
                    v15 = function_100003bd8();
                    v18 = v15;
                    if ((int32_t)v15 != 0) {
                        // 0x100003e8c
                        v16 = v11 / v10 + 1;
                        v18 = v15;
                        if ((v16 * v2 / v6 + 1) * v16 % v4 == 1) {
                            // 0x100003ec0
                            v18 = _printf("%d %d %d\n", v1, v1, v1);
                        }
                    }
                }
            }
        }
        // 0x100003efc
        v19 = v18;
        v12 = v10 + 1;
        v13 = v12 - v7;
        v9 = v19;
        while (v13 < 0 != ((v13 ^ v12) & (v12 ^ v7)) < 0) {
            // 0x100003d84
            v17 = v19;
            v10 = v12;
            v18 = v17;
            if (v11 % v10 == 0) {
                // 0x100003dbc
                v18 = v17;
                if ((v5 % v6 + v6) % v6 == v10 % v6) {
                    // 0x100003e14
                    v14 = function_100003bd8();
                    v18 = v14;
                    if ((int32_t)v14 != 0) {
                        // 0x100003e58
                        v15 = function_100003bd8();
                        v18 = v15;
                        if ((int32_t)v15 != 0) {
                            // 0x100003e8c
                            v16 = v11 / v10 + 1;
                            v18 = v15;
                            if ((v16 * v2 / v6 + 1) * v16 % v4 == 1) {
                                // 0x100003ec0
                                v18 = _printf("%d %d %d\n", v1, v1, v1);
                            }
                        }
                    }
                }
            }
            // 0x100003efc
            v19 = v18;
            v12 = v10 + 1;
            v13 = v12 - v7;
            v9 = v19;
        }
    }
    int64_t result2 = v9;
    int32_t v20 = v6 + 1; // 0x100003f14
    int32_t v21 = v20 - v2; // 0x100003d48
    while (v21 < 0 != ((v21 ^ v20) & (v20 ^ v2)) < 0) {
        int64_t v22 = result2;
        v6 = v20;
        v7 = v6 + v2;
        v8 = 1 - v7;
        v9 = v22;
        if (v8 < 0 != (v8 & v7) < 0) {
            // 0x100003d84
            v11 = v7 * v4;
            v17 = v22;
            v10 = 1;
            v18 = v17;
            if (v11 % v10 == 0) {
                // 0x100003dbc
                v18 = v17;
                if ((v5 % v6 + v6) % v6 == v10 % v6) {
                    // 0x100003e14
                    v14 = function_100003bd8();
                    v18 = v14;
                    if ((int32_t)v14 != 0) {
                        // 0x100003e58
                        v15 = function_100003bd8();
                        v18 = v15;
                        if ((int32_t)v15 != 0) {
                            // 0x100003e8c
                            v16 = v11 / v10 + 1;
                            v18 = v15;
                            if ((v16 * v2 / v6 + 1) * v16 % v4 == 1) {
                                // 0x100003ec0
                                v18 = _printf("%d %d %d\n", v1, v1, v1);
                            }
                        }
                    }
                }
            }
            // 0x100003efc
            v19 = v18;
            v12 = v10 + 1;
            v13 = v12 - v7;
            v9 = v19;
            while (v13 < 0 != ((v13 ^ v12) & (v12 ^ v7)) < 0) {
                // 0x100003d84
                v17 = v19;
                v10 = v12;
                v18 = v17;
                if (v11 % v10 == 0) {
                    // 0x100003dbc
                    v18 = v17;
                    if ((v5 % v6 + v6) % v6 == v10 % v6) {
                        // 0x100003e14
                        v14 = function_100003bd8();
                        v18 = v14;
                        if ((int32_t)v14 != 0) {
                            // 0x100003e58
                            v15 = function_100003bd8();
                            v18 = v15;
                            if ((int32_t)v15 != 0) {
                                // 0x100003e8c
                                v16 = v11 / v10 + 1;
                                v18 = v15;
                                if ((v16 * v2 / v6 + 1) * v16 % v4 == 1) {
                                    // 0x100003ec0
                                    v18 = _printf("%d %d %d\n", v1, v1, v1);
                                }
                            }
                        }
                    }
                }
                // 0x100003efc
                v19 = v18;
                v12 = v10 + 1;
                v13 = v12 - v7;
                v9 = v19;
            }
        }
        // 0x100003f10
        result2 = v9;
        v20 = v6 + 1;
        v21 = v20 - v2;
    }
    // 0x100003f20
    return result2;
}

// Address range: 0x100003f2c - 0x100003f88
int64_t entry_point(void) {
    for (int32_t i = 2; i < 62; i++) {
        // 0x100003f5c
        function_100003d08();
    }
    // 0x100003f78
    return 0;
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>

#define S 10
typedef struct { double v; int fixed; } node;

#define each(i, x) for(i = 0; i < x; i++)
node **alloc2(int w, int h)
{
	int i;
	node **a = calloc(1, sizeof(node*)*h + sizeof(node)*w*h);
	each(i, h) a[i] = i ? a[i-1] + w : (node*)(a + h);
	return a;
}

void set_boundary(node **m)
{
	m[1][1].fixed =  1; m[1][1].v =  1;
	m[6][7].fixed = -1; m[6][7].v = -1;
}

double calc_diff(node **m, node **d, int w, int h)
{
	int i, j, n;
	double v, total = 0;
	each(i, h) each(j, w) {
		v = 0; n = 0;
		if (i) v += m[i-1][j].v, n++;
		if (j) v += m[i][j-1].v, n++;
		if (i+1 < h) v += m[i+1][j].v, n++;
		if (j+1 < w) v += m[i][j+1].v, n++;

		d[i][j].v = v = m[i][j].v - v / n;
		if (!m[i][j].fixed) total += v * v;
	}
	return total;
}

double iter(node **m, int w, int h)
{
	node **d = alloc2(w, h);
	int i, j;
	double diff = 1e10;
	double cur[] = {0, 0, 0};

	while (diff > 1e-24) {
		set_boundary(m);
		diff = calc_diff(m, d, w, h);
		each(i,h) each(j, w) m[i][j].v -= d[i][j].v;
	}

	each(i, h) each(j, w)
		cur[ m[i][j].fixed + 1 ] += d[i][j].v *
				(!!i + !!j + (i < h-1) + (j < w -1));

	free(d);
	return (cur[2] - cur[0])/2;
}

int main()
{
	node **mesh = alloc2(S, S);
	printf("R = %g\n", 2 / iter(mesh, S, S));
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038a0(void);
int64_t function_100003980(void);
int64_t function_1000039d0(void);
int64_t function_100003c4c(void);
int64_t function_100003f50(int64_t a1);
int64_t * function_100003f5c(int32_t nmemb, int32_t size);
void function_100003f68(int64_t * ptr);
int32_t function_100003f74(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t g1 = 1.0e-24; // 0x100003f80
float64_t g2 = 1.0e+10; // 0x100003f88
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000038a0 - 0x100003980
int64_t function_1000038a0(void) {
    // 0x1000038a0
    int64_t v1; // 0x1000038a0
    int32_t v2 = v1; // 0x1000038b0
    int64_t v3 = 0x100000000 * v1 >> 28; // 0x1000038c8
    int64_t v4 = 0x100000000 * v1;
    int64_t result = (int64_t)_calloc(1, (int32_t)(v3 * (v4 >> 32) + 8 * v1)); // 0x1000038dc
    int32_t v5 = -v2; // 0x1000038f4
    if (v5 < 0 == (v5 & v2) < 0) {
        // 0x100003970
        return result;
    }
    int32_t v6 = 0;
    int64_t v7 = (v4 >> 29) + result; // 0x100003910
    if (v6 != 0) {
        // 0x100003918
        v7 = *(int64_t *)((int64_t)(8 * v6 - 8) + result) + v3;
    }
    // 0x10000394c
    *(int64_t *)(8 * (int64_t)v6 + result) = v7;
    int32_t v8 = v6 + 1; // 0x100003964
    while (v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
        // 0x100003904
        v6 = v8;
        v7 = (v4 >> 29) + result;
        if (v6 != 0) {
            // 0x100003918
            v7 = *(int64_t *)((int64_t)(8 * v6 - 8) + result) + v3;
        }
        // 0x10000394c
        *(int64_t *)(8 * (int64_t)v6 + result) = v7;
        v8 = v6 + 1;
    }
    // 0x100003970
    return result;
}

// Address range: 0x100003980 - 0x1000039d0
int64_t function_100003980(void) {
    // 0x100003980
    int64_t result; // 0x100003980
    int64_t * v1 = (int64_t *)(result + 8); // 0x10000398c
    *(int32_t *)(*v1 + 24) = 1;
    *(float64_t *)(*v1 + 16) = 1.0;
    int64_t * v2 = (int64_t *)(result + 48); // 0x1000039ac
    *(int32_t *)(*v2 + 120) = -1;
    *(float64_t *)(*v2 + 112) = -1.0;
    return result;
}

// Address range: 0x1000039d0 - 0x100003c4c
int64_t function_1000039d0(void) {
    // 0x1000039d0
    int64_t result; // 0x1000039d0
    int32_t v1 = result; // 0x1000039e0
    int32_t v2 = -v1; // 0x1000039fc
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x100003c40
        return result;
    }
    int32_t v3 = result; // 0x1000039dc
    int32_t v4 = -v3; // 0x100003a1c
    float64_t v5 = 0.0;
    int32_t v6 = 0;
    int64_t v7; // 0x1000039d0
    int32_t v8; // 0x100003c34
    int32_t v9; // 0x1000039fc
    int32_t v10; // 0x1000039d0
    int32_t v11; // 0x1000039d0
    int32_t v12; // 0x1000039d0
    float64_t v13; // 0x1000039d0
    float64_t v14; // 0x1000039d0
    float64_t v15; // 0x1000039d0
    float64_t v16; // 0x1000039d0
    float64_t v17; // 0x1000039d0
    float64_t v18; // 0x1000039d0
    float64_t v19; // 0x1000039d0
    float64_t v20; // 0x1000039d0
    float64_t v21; // 0x1000039d0
    float64_t v22; // 0x1000039d0
    float64_t v23; // 0x1000039d0
    float64_t v24; // 0x1000039d0
    float64_t v25; // 0x1000039d0
    int32_t v26; // 0x1000039d0
    int32_t v27; // 0x1000039d0
    int64_t * v28; // 0x1000039d0
    int64_t v29; // 0x1000039d0
    int64_t * v30; // 0x1000039d0
    int32_t v31; // 0x1000039d0
    int32_t v32; // 0x1000039d0
    int32_t v33; // 0x1000039d0
    int64_t * v34; // 0x1000039d0
    float64_t v35; // 0x100003ab8
    int32_t v36; // 0x100003b30
    int32_t v37; // 0x1000039d0
    float64_t v38; // 0x100003b0c
    int64_t v39; // 0x100003b98
    float64_t v40; // 0x100003bb8
    int32_t v41; // 0x100003bec
    float64_t v42; // 0x100003b68
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x100003a14
        v8 = v6 + 1;
        v9 = v8 - v1;
        v11 = (v9 ^ v8) & (v8 ^ v1);
        v10 = v9;
        v12 = v8;
        v24 = v5;
        v14 = v13;
    } else {
        // 0x100003a2c
        v27 = 8 * v6;
        v28 = (int64_t *)(result + (int64_t)(v27 - 8));
        v29 = 8 * (int64_t)v6;
        v30 = (int64_t *)(v29 + result);
        v31 = v6 + 1;
        v32 = v31 - v1;
        v33 = (v32 ^ v31) & (v31 ^ v1);
        v34 = (int64_t *)(result + (int64_t)(v27 + 8));
        v15 = v13;
        v23 = v5;
        v26 = 0;
        v16 = 0.0;
        if (v6 != 0) {
            // 0x100003a4c
            v16 = *(float64_t *)(*v28 + 16 * (int64_t)v26);
        }
        // 0x100003a84
        v17 = v16;
        v18 = v17;
        if (v26 != 0) {
            // 0x100003a98
            v35 = *(float64_t *)(*v30 + 16 * (int64_t)(v26 - 1));
            v18 = v17 + v35;
        }
        // 0x100003ad8
        v19 = v18;
        v20 = v19;
        if (v32 < 0 != v33 < 0) {
            // 0x100003af4
            v38 = *(float64_t *)(*v34 + 16 * (int64_t)v26);
            v20 = v19 + v38;
        }
        // 0x100003b2c
        v21 = v20;
        v36 = v26 + 1;
        v37 = v36 - v3;
        v7 = *v30;
        v22 = v21;
        if (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
            // 0x100003b48
            v42 = *(float64_t *)(v7 + 16 * (int64_t)v36);
            v22 = v21 + v42;
        }
        // 0x100003b88
        v39 = 16 * (int64_t)v26;
        __asm_sshll(0.0f, 0);
        v40 = *(float64_t *)(v7 + v39) - v22 / v15;
        *(float64_t *)(*(int64_t *)(v29 + result) + v39) = v40;
        v41 = *(int32_t *)(*v30 + (v39 | 8));
        v25 = v41 == 0 ? v23 + v40 * v40 : v23;
        v15 = v41 == 0 ? v23 : v15;
        v11 = v33;
        v10 = v32;
        v12 = v31;
        v24 = v25;
        v14 = v15;
        while (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
            // 0x100003a2c
            v23 = v25;
            v26 = v36;
            v16 = 0.0;
            if (v6 != 0) {
                // 0x100003a4c
                v16 = *(float64_t *)(*v28 + 16 * (int64_t)v26);
            }
            // 0x100003a84
            v17 = v16;
            v18 = v17;
            if (v26 != 0) {
                // 0x100003a98
                v35 = *(float64_t *)(*v30 + 16 * (int64_t)(v26 - 1));
                v18 = v17 + v35;
            }
            // 0x100003ad8
            v19 = v18;
            v20 = v19;
            if (v32 < 0 != v33 < 0) {
                // 0x100003af4
                v38 = *(float64_t *)(*v34 + 16 * (int64_t)v26);
                v20 = v19 + v38;
            }
            // 0x100003b2c
            v21 = v20;
            v36 = v26 + 1;
            v37 = v36 - v3;
            v7 = *v30;
            v22 = v21;
            if (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
                // 0x100003b48
                v42 = *(float64_t *)(v7 + 16 * (int64_t)v36);
                v22 = v21 + v42;
            }
            // 0x100003b88
            v39 = 16 * (int64_t)v26;
            __asm_sshll(0.0f, 0);
            v40 = *(float64_t *)(v7 + v39) - v22 / v15;
            *(float64_t *)(*(int64_t *)(v29 + result) + v39) = v40;
            v41 = *(int32_t *)(*v30 + (v39 | 8));
            v25 = v41 == 0 ? v23 + v40 * v40 : v23;
            v15 = v41 == 0 ? v23 : v15;
            v11 = v33;
            v10 = v32;
            v12 = v31;
            v24 = v25;
            v14 = v15;
        }
    }
    // 0x100003c30
    while (v10 < 0 != v11 < 0) {
        // 0x100003a14
        v5 = v24;
        float64_t v43 = v14;
        v6 = v12;
        if (v4 < 0 == (v4 & v3) < 0) {
            // 0x100003a14
            v8 = v6 + 1;
            v9 = v8 - v1;
            v11 = (v9 ^ v8) & (v8 ^ v1);
            v10 = v9;
            v12 = v8;
            v24 = v5;
            v14 = v43;
        } else {
            // 0x100003a2c
            v27 = 8 * v6;
            v28 = (int64_t *)(result + (int64_t)(v27 - 8));
            v29 = 8 * (int64_t)v6;
            v30 = (int64_t *)(v29 + result);
            v31 = v6 + 1;
            v32 = v31 - v1;
            v33 = (v32 ^ v31) & (v31 ^ v1);
            v34 = (int64_t *)(result + (int64_t)(v27 + 8));
            v15 = v43;
            v23 = v5;
            v26 = 0;
            v16 = 0.0;
            if (v6 != 0) {
                // 0x100003a4c
                v16 = *(float64_t *)(*v28 + 16 * (int64_t)v26);
            }
            // 0x100003a84
            v17 = v16;
            v18 = v17;
            if (v26 != 0) {
                // 0x100003a98
                v35 = *(float64_t *)(*v30 + 16 * (int64_t)(v26 - 1));
                v18 = v17 + v35;
            }
            // 0x100003ad8
            v19 = v18;
            v20 = v19;
            if (v32 < 0 != v33 < 0) {
                // 0x100003af4
                v38 = *(float64_t *)(*v34 + 16 * (int64_t)v26);
                v20 = v19 + v38;
            }
            // 0x100003b2c
            v21 = v20;
            v36 = v26 + 1;
            v37 = v36 - v3;
            v7 = *v30;
            v22 = v21;
            if (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
                // 0x100003b48
                v42 = *(float64_t *)(v7 + 16 * (int64_t)v36);
                v22 = v21 + v42;
            }
            // 0x100003b88
            v39 = 16 * (int64_t)v26;
            __asm_sshll(0.0f, 0);
            v40 = *(float64_t *)(v7 + v39) - v22 / v15;
            *(float64_t *)(*(int64_t *)(v29 + result) + v39) = v40;
            v41 = *(int32_t *)(*v30 + (v39 | 8));
            v25 = v41 == 0 ? v23 + v40 * v40 : v23;
            v15 = v41 == 0 ? v23 : v15;
            v11 = v33;
            v10 = v32;
            v12 = v31;
            v24 = v25;
            v14 = v15;
            while (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
                // 0x100003a2c
                v23 = v25;
                v26 = v36;
                v16 = 0.0;
                if (v6 != 0) {
                    // 0x100003a4c
                    v16 = *(float64_t *)(*v28 + 16 * (int64_t)v26);
                }
                // 0x100003a84
                v17 = v16;
                v18 = v17;
                if (v26 != 0) {
                    // 0x100003a98
                    v35 = *(float64_t *)(*v30 + 16 * (int64_t)(v26 - 1));
                    v18 = v17 + v35;
                }
                // 0x100003ad8
                v19 = v18;
                v20 = v19;
                if (v32 < 0 != v33 < 0) {
                    // 0x100003af4
                    v38 = *(float64_t *)(*v34 + 16 * (int64_t)v26);
                    v20 = v19 + v38;
                }
                // 0x100003b2c
                v21 = v20;
                v36 = v26 + 1;
                v37 = v36 - v3;
                v7 = *v30;
                v22 = v21;
                if (v37 < 0 != ((v37 ^ v36) & (v36 ^ v3)) < 0) {
                    // 0x100003b48
                    v42 = *(float64_t *)(v7 + 16 * (int64_t)v36);
                    v22 = v21 + v42;
                }
                // 0x100003b88
                v39 = 16 * (int64_t)v26;
                __asm_sshll(0.0f, 0);
                v40 = *(float64_t *)(v7 + v39) - v22 / v15;
                *(float64_t *)(*(int64_t *)(v29 + result) + v39) = v40;
                v41 = *(int32_t *)(*v30 + (v39 | 8));
                v25 = v41 == 0 ? v23 + v40 * v40 : v23;
                v15 = v41 == 0 ? v23 : v15;
                v11 = v33;
                v10 = v32;
                v12 = v31;
                v24 = v25;
                v14 = v15;
            }
        }
    }
    // 0x100003c40
    return result;
}

// Address range: 0x100003c4c - 0x100003ee4
int64_t function_100003c4c(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c60
    int64_t v2; // 0x100003c4c
    int32_t v3 = v2; // 0x100003c6c
    int32_t v4 = v2; // 0x100003c70
    int64_t v5 = function_1000038a0(); // 0x100003c7c
    int64_t v6 = 0; // bp-48, 0x100003c90
    int32_t v7 = -v4;
    int32_t v8 = -v3;
    float64_t v9 = g2; // 0x100003cac
    if (g1 != g2) {
        float64_t v10 = v9;
        while (v10 > g1 == v10 >= g1 == v10 <= g1) {
            // 0x100003cbc
            function_100003980();
            function_1000039d0();
            float64_t v11 = v9;
            float64_t v12 = v10; // 0x100003cf4
            if (v7 < 0 != (v7 & v4) < 0) {
                int32_t v13 = 0;
                int64_t v14; // 0x100003d24
                int64_t v15; // 0x100003d2c
                float64_t * v16; // 0x100003d48
                int32_t v17; // 0x100003d5c
                if (v8 < 0 != (v8 & v3) < 0) {
                    // 0x100003d1c
                    v14 = 8 * (int64_t)v13;
                    v17 = 0;
                    v15 = 16 * (int64_t)v17;
                    v16 = (float64_t *)(*(int64_t *)(v14 + v2) + v15);
                    *v16 = *v16 - *(float64_t *)(v15 + *(int64_t *)(v14 + v5));
                    v17++;
                    while (v17 - v3 < 0 != ((v17 - v3 ^ v17) & (v17 ^ v3)) < 0) {
                        // 0x100003d1c
                        v15 = 16 * (int64_t)v17;
                        v16 = (float64_t *)(*(int64_t *)(v14 + v2) + v15);
                        *v16 = *v16 - *(float64_t *)(v15 + *(int64_t *)(v14 + v5));
                        v17++;
                    }
                }
                int32_t v18 = v13 + 1; // 0x100003d70
                int32_t v19 = v18 - v4; // 0x100003cec
                while (v19 < 0 != ((v19 ^ v18) & (v18 ^ v4)) < 0) {
                    // 0x100003d04
                    v13 = v18;
                    if (v8 < 0 != (v8 & v3) < 0) {
                        // 0x100003d1c
                        v14 = 8 * (int64_t)v13;
                        v17 = 0;
                        v15 = 16 * (int64_t)v17;
                        v16 = (float64_t *)(*(int64_t *)(v14 + v2) + v15);
                        *v16 = *v16 - *(float64_t *)(v15 + *(int64_t *)(v14 + v5));
                        v17++;
                        while (v17 - v3 < 0 != ((v17 - v3 ^ v17) & (v17 ^ v3)) < 0) {
                            // 0x100003d1c
                            v15 = 16 * (int64_t)v17;
                            v16 = (float64_t *)(*(int64_t *)(v14 + v2) + v15);
                            *v16 = *v16 - *(float64_t *)(v15 + *(int64_t *)(v14 + v5));
                            v17++;
                        }
                    }
                    // 0x100003d6c
                    v18 = v13 + 1;
                    v19 = v18 - v4;
                }
                // 0x100003ce4
                v12 = v11;
            }
            // 0x100003ca0
            v9 = v12;
            if (v9 == g1) {
                // break -> 0x100003d88
                break;
            }
            v10 = v9;
        }
    }
    if (v7 < 0 != (v7 & v4) < 0) {
        int32_t v20 = v4 - 1;
        int32_t v21 = v3 - 1;
        int32_t v22 = 0;
        int32_t v23; // 0x100003c4c
        int64_t v24; // 0x100003dc8
        int32_t v25; // 0x100003e08
        int32_t v26; // 0x100003df8
        int64_t v27; // 0x100003dd0
        float64_t v28; // 0x100003dd4
        int32_t v29; // 0x100003e24
        int32_t v30; // 0x100003e4c
        float64_t * v31; // 0x100003e5c
        float64_t v32; // 0x100003e5c
        int32_t v33; // 0x100003e70
        if (v8 < 0 != (v8 & v3) < 0) {
            // 0x100003dc0
            v24 = 8 * (int64_t)v22;
            v25 = v22 - v20;
            v26 = (int32_t)(v25 < 0 != ((v25 ^ v22) & (v22 ^ v20)) < 0) + (int32_t)(v22 != 0);
            v23 = 0;
            v27 = 16 * (int64_t)v23;
            v28 = *(float64_t *)(v27 + *(int64_t *)(v24 + v5));
            v29 = v23 - v21;
            v30 = *(int32_t *)((v27 | 8) + *(int64_t *)(v24 + v2));
            v31 = (float64_t *)(8 * (int64_t)(v30 + 1) + (int64_t)&v6);
            v32 = *v31;
            *v31 = v32 + v28 * (float64_t)(v26 + (int32_t)(v23 != 0) + (int32_t)(v29 < 0 != ((v29 ^ v23) & (v23 ^ v21)) < 0));
            v33 = v23 + 1;
            while (v33 - v3 < 0 != ((v33 - v3 ^ v33) & (v33 ^ v3)) < 0) {
                // 0x100003dc0
                v23 = v33;
                v27 = 16 * (int64_t)v23;
                v28 = *(float64_t *)(v27 + *(int64_t *)(v24 + v5));
                v29 = v23 - v21;
                v30 = *(int32_t *)((v27 | 8) + *(int64_t *)(v24 + v2));
                v31 = (float64_t *)(8 * (int64_t)(v30 + 1) + (int64_t)&v6);
                v32 = *v31;
                *v31 = v32 + v28 * (float64_t)(v26 + (int32_t)(v23 != 0) + (int32_t)(v29 < 0 != ((v29 ^ v23) & (v23 ^ v21)) < 0));
                v33 = v23 + 1;
            }
        }
        int32_t v34 = v22 + 1; // 0x100003e84
        while (v34 - v4 < 0 != ((v34 - v4 ^ v34) & (v34 ^ v4)) < 0) {
            // 0x100003da8
            v22 = v34;
            if (v8 < 0 != (v8 & v3) < 0) {
                // 0x100003dc0
                v24 = 8 * (int64_t)v22;
                v25 = v22 - v20;
                v26 = (int32_t)(v25 < 0 != ((v25 ^ v22) & (v22 ^ v20)) < 0) + (int32_t)(v22 != 0);
                v23 = 0;
                v27 = 16 * (int64_t)v23;
                v28 = *(float64_t *)(v27 + *(int64_t *)(v24 + v5));
                v29 = v23 - v21;
                v30 = *(int32_t *)((v27 | 8) + *(int64_t *)(v24 + v2));
                v31 = (float64_t *)(8 * (int64_t)(v30 + 1) + (int64_t)&v6);
                v32 = *v31;
                *v31 = v32 + v28 * (float64_t)(v26 + (int32_t)(v23 != 0) + (int32_t)(v29 < 0 != ((v29 ^ v23) & (v23 ^ v21)) < 0));
                v33 = v23 + 1;
                while (v33 - v3 < 0 != ((v33 - v3 ^ v33) & (v33 ^ v3)) < 0) {
                    // 0x100003dc0
                    v23 = v33;
                    v27 = 16 * (int64_t)v23;
                    v28 = *(float64_t *)(v27 + *(int64_t *)(v24 + v5));
                    v29 = v23 - v21;
                    v30 = *(int32_t *)((v27 | 8) + *(int64_t *)(v24 + v2));
                    v31 = (float64_t *)(8 * (int64_t)(v30 + 1) + (int64_t)&v6);
                    v32 = *v31;
                    *v31 = v32 + v28 * (float64_t)(v26 + (int32_t)(v23 != 0) + (int32_t)(v29 < 0 != ((v29 ^ v23) & (v23 ^ v21)) < 0));
                    v33 = v23 + 1;
                }
            }
            // 0x100003e80
            v34 = v22 + 1;
        }
    }
    // 0x100003e90
    _free((int64_t *)v5);
    int64_t result = &g3; // 0x100003ec8
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ed0
        result = ___stack_chk_fail((int64_t)&g3);
    }
    // 0x100003ed4
    return result;
}

// Address range: 0x100003ee4 - 0x100003f50
int64_t entry_point(void) {
    // 0x100003ee4
    function_1000038a0();
    function_100003c4c();
    int128_t v1; // 0x100003ee4
    _printf("R = %g\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t function_100003f50(int64_t a1) {
    // 0x100003f50
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f5c - 0x100003f68
int64_t * function_100003f5c(int32_t nmemb, int32_t size) {
    // 0x100003f5c
    return _calloc(nmemb, size);
}

// Address range: 0x100003f68 - 0x100003f74
void function_100003f68(int64_t * ptr) {
    // 0x100003f68
    _free(ptr);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>
#include <string.h>
#include <errno.h>
#include <stdbool.h>
#include <limits.h>

#define NELEMS(arr) (sizeof(arr) / sizeof(arr[0]))

#define da_dim(name, type)  type *name = NULL;          \
                            int _qy_ ## name ## _p = 0;  \
                            int _qy_ ## name ## _max = 0
#define da_rewind(name)     _qy_ ## name ## _p = 0
#define da_redim(name)      do {if (_qy_ ## name ## _p >= _qy_ ## name ## _max) \
                                name = realloc(name, (_qy_ ## name ## _max += 32) * sizeof(name[0]));} while (0)
#define da_append(name, x)  do {da_redim(name); name[_qy_ ## name ## _p++] = x;} while (0)
#define da_len(name)        _qy_ ## name ## _p

typedef enum {
    tk_EOI, tk_Mul, tk_Div, tk_Mod, tk_Add, tk_Sub, tk_Negate, tk_Not, tk_Lss, tk_Leq,
    tk_Gtr, tk_Geq, tk_Eq, tk_Neq, tk_Assign, tk_And, tk_Or, tk_If, tk_Else, tk_While,
    tk_Print, tk_Putc, tk_Lparen, tk_Rparen, tk_Lbrace, tk_Rbrace, tk_Semi, tk_Comma,
    tk_Ident, tk_Integer, tk_String
} TokenType;

typedef struct {
    TokenType tok;
    int err_ln, err_col;
    union {
        int n;                  /* value for constants */
        char *text;             /* text for idents */
    };
} tok_s;

static FILE *source_fp, *dest_fp;
static int line = 1, col = 0, the_ch = ' ';
da_dim(text, char);

tok_s gettok(void);

static void error(int err_line, int err_col, const char *fmt, ... ) {
    char buf[1000];
    va_list ap;

    va_start(ap, fmt);
    vsprintf(buf, fmt, ap);
    va_end(ap);
    printf("(%d,%d) error: %s\n", err_line, err_col, buf);
    exit(1);
}

static int next_ch(void) {     /* get next char from input */
    the_ch = getc(source_fp);
    ++col;
    if (the_ch == '\n') {
        ++line;
        col = 0;
    }
    return the_ch;
}

static tok_s char_lit(int n, int err_line, int err_col) {   /* 'x' */
    if (the_ch == '\'')
        error(err_line, err_col, "gettok: empty character constant");
    if (the_ch == '\\') {
        next_ch();
        if (the_ch == 'n')
            n = 10;
        else if (the_ch == '\\')
            n = '\\';
        else error(err_line, err_col, "gettok: unknown escape sequence \\%c", the_ch);
    }
    if (next_ch() != '\'')
        error(err_line, err_col, "multi-character constant");
    next_ch();
    return (tok_s){tk_Integer, err_line, err_col, {n}};
}

static tok_s div_or_cmt(int err_line, int err_col) { /* process divide or comments */
    if (the_ch != '*')
        return (tok_s){tk_Div, err_line, err_col, {0}};

    /* comment found */
    next_ch();
    for (;;) {
        if (the_ch == '*') {
            if (next_ch() == '/') {
                next_ch();
                return gettok();
            }
        } else if (the_ch == EOF)
            error(err_line, err_col, "EOF in comment");
        else
            next_ch();
    }
}

static tok_s string_lit(int start, int err_line, int err_col) { /* "st" */
    da_rewind(text);

    while (next_ch() != start) {
        if (the_ch == '\n') error(err_line, err_col, "EOL in string");
        if (the_ch == EOF)  error(err_line, err_col, "EOF in string");
        da_append(text, (char)the_ch);
    }
    da_append(text, '\0');

    next_ch();
    return (tok_s){tk_String, err_line, err_col, {.text=text}};
}

static int kwd_cmp(const void *p1, const void *p2) {
    return strcmp(*(char **)p1, *(char **)p2);
}

static TokenType get_ident_type(const char *ident) {
    static struct {
        const char *s;
        TokenType sym;
    } kwds[] = {
        {"else",  tk_Else},
        {"if",    tk_If},
        {"print", tk_Print},
        {"putc",  tk_Putc},
        {"while", tk_While},
    }, *kwp;

    return (kwp = bsearch(&ident, kwds, NELEMS(kwds), sizeof(kwds[0]), kwd_cmp)) == NULL ? tk_Ident : kwp->sym;
}

static tok_s ident_or_int(int err_line, int err_col) {
    int n, is_number = true;

    da_rewind(text);
    while (isalnum(the_ch) || the_ch == '_') {
        da_append(text, (char)the_ch);
        if (!isdigit(the_ch))
            is_number = false;
        next_ch();
    }
    if (da_len(text) == 0)
        error(err_line, err_col, "gettok: unrecognized character (%d) '%c'\n", the_ch, the_ch);
    da_append(text, '\0');
    if (isdigit(text[0])) {
        if (!is_number)
            error(err_line, err_col, "invalid number: %s\n", text);
        n = strtol(text, NULL, 0);
        if (n == LONG_MAX && errno == ERANGE)
            error(err_line, err_col, "Number exceeds maximum value");
        return (tok_s){tk_Integer, err_line, err_col, {n}};
    }
    return (tok_s){get_ident_type(text), err_line, err_col, {.text=text}};
}

static tok_s follow(int expect, TokenType ifyes, TokenType ifno, int err_line, int err_col) {   /* look ahead for '>=', etc. */
    if (the_ch == expect) {
        next_ch();
        return (tok_s){ifyes, err_line, err_col, {0}};
    }
    if (ifno == tk_EOI)
        error(err_line, err_col, "follow: unrecognized character '%c' (%d)\n", the_ch, the_ch);
    return (tok_s){ifno, err_line, err_col, {0}};
}

tok_s gettok(void) {            /* return the token type */
    /* skip white space */
    while (isspace(the_ch))
        next_ch();
    int err_line = line;
    int err_col  = col;
    switch (the_ch) {
        case '{':  next_ch(); return (tok_s){tk_Lbrace, err_line, err_col, {0}};
        case '}':  next_ch(); return (tok_s){tk_Rbrace, err_line, err_col, {0}};
        case '(':  next_ch(); return (tok_s){tk_Lparen, err_line, err_col, {0}};
        case ')':  next_ch(); return (tok_s){tk_Rparen, err_line, err_col, {0}};
        case '+':  next_ch(); return (tok_s){tk_Add, err_line, err_col, {0}};
        case '-':  next_ch(); return (tok_s){tk_Sub, err_line, err_col, {0}};
        case '*':  next_ch(); return (tok_s){tk_Mul, err_line, err_col, {0}};
        case '%':  next_ch(); return (tok_s){tk_Mod, err_line, err_col, {0}};
        case ';':  next_ch(); return (tok_s){tk_Semi, err_line, err_col, {0}};
        case ',':  next_ch(); return (tok_s){tk_Comma,err_line, err_col, {0}};
        case '/':  next_ch(); return div_or_cmt(err_line, err_col);
        case '\'': next_ch(); return char_lit(the_ch, err_line, err_col);
        case '<':  next_ch(); return follow('=', tk_Leq, tk_Lss,    err_line, err_col);
        case '>':  next_ch(); return follow('=', tk_Geq, tk_Gtr,    err_line, err_col);
        case '=':  next_ch(); return follow('=', tk_Eq,  tk_Assign, err_line, err_col);
        case '!':  next_ch(); return follow('=', tk_Neq, tk_Not,    err_line, err_col);
        case '&':  next_ch(); return follow('&', tk_And, tk_EOI,    err_line, err_col);
        case '|':  next_ch(); return follow('|', tk_Or,  tk_EOI,    err_line, err_col);
        case '"' : return string_lit(the_ch, err_line, err_col);
        default:   return ident_or_int(err_line, err_col);
        case EOF:  return (tok_s){tk_EOI, err_line, err_col, {0}};
    }
}

void run(void) {    /* tokenize the given input */
    tok_s tok;
    do {
        tok = gettok();
        fprintf(dest_fp, "%5d  %5d %.15s",
            tok.err_ln, tok.err_col,
            &"End_of_input    Op_multiply     Op_divide       Op_mod          Op_add          "
             "Op_subtract     Op_negate       Op_not          Op_less         Op_lessequal    "
             "Op_greater      Op_greaterequal Op_equal        Op_notequal     Op_assign       "
             "Op_and          Op_or           Keyword_if      Keyword_else    Keyword_while   "
             "Keyword_print   Keyword_putc    LeftParen       RightParen      LeftBrace       "
             "RightBrace      Semicolon       Comma           Identifier      Integer         "
             "String          "
            [tok.tok * 16]);
        if (tok.tok == tk_Integer)     fprintf(dest_fp, "  %4d",   tok.n);
        else if (tok.tok == tk_Ident)  fprintf(dest_fp, " %s",     tok.text);
        else if (tok.tok == tk_String) fprintf(dest_fp, " \"%s\"", tok.text);
        fprintf(dest_fp, "\n");
    } while (tok.tok != tk_EOI);
    if (dest_fp != stdout)
        fclose(dest_fp);
}

void init_io(FILE **fp, FILE *std, const char mode[], const char fn[]) {
    if (fn[0] == '\0')
        *fp = std;
    else if ((*fp = fopen(fn, mode)) == NULL)
        error(0, 0, "Can't open %s\n", fn);
}

int main(int argc, char *argv[]) {
    init_io(&source_fp, stdin,  "r",  argc > 1 ? argv[1] : "");
    init_io(&dest_fp,   stdout, "wb", argc > 2 ? argv[2] : "");
    run();
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000028e4(int64_t a1);
int64_t function_100002c40(int64_t a1);
int64_t function_100002c60(int64_t a1, int64_t a2);
int64_t function_100002e68(int64_t a1);
int64_t function_100002ed4(void);
int64_t function_100002fbc(void);
int64_t function_100003100(void);
int64_t function_1000031e4(void);
int64_t function_1000033dc(void);
int64_t function_100003714(void);
int64_t function_1000038ac(void);
int64_t function_10000394c(void);
int64_t function_100003ac4(void);
int64_t function_100003b44(void);
void function_100003b78(int32_t status, int32_t errnum, char * format, ...);
int64_t function_100003b84(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t * function_100003b90(int64_t * key, int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
void function_100003b9c(int32_t status);
int32_t function_100003ba8(struct _IO_FILE * stream);
struct _IO_FILE * function_100003bb4(char * filename, char * modes);
int32_t function_100003bc0(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003bcc(struct _IO_FILE * stream);
int32_t function_100003bd8(int32_t c);
int32_t function_100003be4(int32_t c);
int32_t function_100003bf0(int32_t c);
int32_t function_100003bfc(char * format, ...);
int64_t * function_100003c08(int64_t * ptr, int32_t size);
int32_t function_100003c14(char * s1, char * s2);
int32_t function_100003c20(char * nptr, char ** endptr, int32_t base);

// --------------------- Global Variables ---------------------

int32_t g1 = 32; // 0x100008000
int32_t g2 = 1; // 0x100008004
char * g3 = "\xcf\xfa\xed\xfe\f"; // 0x100008058
int32_t g4 = 0; // 0x100008060
int32_t g5 = 2; // 0x100008064
int32_t g6 = 0; // 0x100008068
struct _IO_FILE * g7 = NULL; // 0x100008070
struct _IO_FILE * g8 = NULL; // 0x100008078
int64_t g9 = 0; // 0x100008080
int32_t g10;

// ------- Dynamically Linked Functions Without Header --------

void ___error(int32_t a1, int32_t a2, char * a3, ...);
int64_t ___vsprintf_chk(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t * _bsearch(int64_t * a1, int64_t * a2, int32_t a3, int32_t a4, int32_t (*a5)(int64_t *, int64_t *));
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _getc(struct _IO_FILE * a1);
int32_t _isalnum(int32_t a1);
int32_t _isdigit(int32_t a1);
int32_t _isspace(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x1000028e4 - 0x100002c40
int64_t function_1000028e4(int64_t a1) {
    // 0x1000028e4
    if (_isspace(g1) != 0) {
        function_100002e68((int64_t)&g10);
        while (_isspace(g1) != 0) {
            // 0x100002914
            function_100002e68((int64_t)&g10);
        }
    }
    uint32_t v1 = g1 + 1; // 0x10000293c
    if (v1 >= 126 != v1 != 126) {
        // 0x100002954
        return 0;
    }
    // 0x100002c2c
    function_1000033dc();
    return function_100002c60((int64_t)&g10, (int64_t)&g10);
}

// Address range: 0x100002c40 - 0x100002c60
int64_t function_100002c40(int64_t a1) {
    // 0x100002c40
    *(int32_t *)a1 = 0;
    int64_t v1; // 0x100002c40
    *(int32_t *)(a1 + 4) = *(int32_t *)(v1 - 4);
    *(int32_t *)(a1 + 8) = *(int32_t *)(v1 - 8);
    *(int32_t *)(a1 + 16) = 0;
    return function_100002c60((int64_t)&g10, (int64_t)&g10);
}

// Address range: 0x100002c60 - 0x100002c6c
int64_t function_100002c60(int64_t a1, int64_t a2) {
    // 0x100002c60
    int64_t result; // 0x100002c60
    return result;
}

// Address range: 0x100002e68 - 0x100002ed4
int64_t function_100002e68(int64_t a1) {
    int32_t result = _getc(g8); // 0x100002e78
    g1 = result;
    g6++;
    if (result == 10) {
        // 0x100002ea8
        g2++;
        g6 = 0;
    }
    // 0x100002ec4
    return result;
}

// Address range: 0x100002ed4 - 0x100002fbc
int64_t function_100002ed4(void) {
    // 0x100002ed4
    int64_t v1; // 0x100002ed4
    int64_t result; // 0x100002ed4
    if (g1 != 42) {
        // 0x100002f04
        *(int32_t *)v1 = 2;
        *(int32_t *)(v1 + 4) = (int32_t)v1;
        *(int32_t *)(v1 + 8) = (int32_t)v1;
        *(int32_t *)(v1 + 16) = 0;
      lab_0x100002fb0:
        // 0x100002fb0
        return result;
    }
    // 0x100002f28
    function_100002e68(v1);
    while (true) {
        // 0x100002f30
        switch (g1) {
            case 42: {
                // 0x100002f48
                if ((int32_t)function_100002e68((int64_t)&g10) == 47) {
                    // 0x100002f5c
                    function_100002e68((int64_t)&g10);
                    result = function_1000028e4((int64_t)&g10);
                    return result;
                }
                // break -> 0x100002fac
                break;
            }
            case -1: {
                // 0x100002f88
                function_10000394c();
                // UNREACHABLE
            }
            default: {
                // 0x100002fa0
                function_100002e68((int64_t)&g10);
                // break -> 0x100002fac
                break;
            }
        }
    }
    // 0x100002f88
    function_10000394c();
    // UNREACHABLE
}

// Address range: 0x100002fbc - 0x100003100
int64_t function_100002fbc(void) {
    // 0x100002fbc
    if (g1 == 39) {
        // 0x100002ff0
        function_10000394c();
        // UNREACHABLE
    }
    // 0x100003008
    int64_t v1; // 0x100002fbc
    int32_t v2 = v1; // 0x100003018
    if (g1 == 92) {
        // 0x100003020
        function_100002e68((int64_t)&g10);
        v2 = 10;
        switch (g1) {
            case 110: {
                goto lab_0x1000030a0;
            }
            case 92: {
                // 0x100003060
                v2 = 92;
                goto lab_0x1000030a0;
            }
            default: {
                // 0x10000306c
                function_10000394c();
                // UNREACHABLE
            }
        }
    } else {
        goto lab_0x1000030a0;
    }
  lab_0x1000030a0:
    // 0x1000030a0
    if ((int32_t)function_100002e68((int64_t)&g10) != 39) {
        // 0x1000030b4
        function_10000394c();
        // UNREACHABLE
    }
    int64_t result = function_100002e68((int64_t)&g10); // 0x1000030cc
    *(int32_t *)v1 = 29;
    *(int32_t *)(v1 + 4) = (int32_t)v1;
    *(int32_t *)(v1 + 8) = (int32_t)v1;
    *(int32_t *)(v1 + 16) = v2;
    return result;
}

// Address range: 0x100003100 - 0x1000031e4
int64_t function_100003100(void) {
    // 0x100003100
    int64_t v1; // 0x100003100
    int32_t * v2 = (int32_t *)v1; // 0x10000310c
    int32_t v3 = v1; // 0x10000311c
    int32_t v4 = v1; // 0x100003120
    if (g1 == (int32_t)v1) {
        int64_t result = function_100002e68(v1); // 0x100003140
        *v2 = (int32_t)v1;
        *(int32_t *)(v1 + 4) = v3;
        *(int32_t *)(v1 + 8) = v4;
        *(int32_t *)(v1 + 16) = 0;
        // 0x1000031d8
        return result;
    }
    int32_t v5 = v1; // 0x100003118
    if (v5 == 0) {
        // 0x10000317c
        function_10000394c();
        // UNREACHABLE
    }
    // 0x1000031b4
    *v2 = v5;
    *(int32_t *)(v1 + 4) = v3;
    *(int32_t *)(v1 + 8) = v4;
    *(int32_t *)(v1 + 16) = 0;
    // 0x1000031d8
    int64_t result2; // 0x100003100
    return result2;
}

// Address range: 0x1000031e4 - 0x1000033dc
int64_t function_1000031e4(void) {
    // 0x1000031e4
    int64_t v1; // 0x1000031e4
    int32_t v2 = v1; // 0x1000031f4
    g4 = 0;
    if (v2 == (int32_t)function_100002e68((int64_t)&g10)) {
      lab_0x100003320:;
        int32_t v3 = g4; // 0x100003324
        int32_t v4 = v3 - g5; // 0x100003330
        int32_t v5 = v3; // 0x100003338
        char * v6 = g3; // 0x100003338
        if (v4 < 0 == ((v4 ^ v3) & (g5 ^ v3)) < 0) {
            int32_t v7 = g5 + 32; // 0x100003354
            g5 = v7;
            int64_t * v8 = _realloc((int64_t *)g3, v7); // 0x100003368
            g3 = (char *)v8;
            v5 = g4;
            v6 = (char *)v8;
        }
        // 0x10000337c
        g4 = v5 + 1;
        *(char *)((int64_t)v6 + (int64_t)v5) = 0;
        int64_t result = function_100002e68((int64_t)&g10); // 0x1000033a4
        *(int32_t *)v1 = 30;
        *(int32_t *)(v1 + 4) = (int32_t)v1;
        *(int32_t *)(v1 + 8) = (int32_t)v1;
        *(int64_t *)(v1 + 16) = (int64_t)g3;
        return result;
    }
    while (true) {
        // 0x100003224
        switch (g1) {
            case 10: {
                // 0x10000323c
                function_10000394c();
                // UNREACHABLE
            }
            case -1: {
                // 0x10000326c
                function_10000394c();
                // UNREACHABLE
            }
        }
        int32_t v9 = g4; // 0x100003290
        int32_t v10 = *(int32_t *)((int64_t)&g1 + 100); // 0x100003298
        int32_t v11 = v9 - v10; // 0x10000329c
        char * v12 = g3;
        int32_t v13 = v9; // 0x1000032a4
        char * v14 = v12; // 0x1000032a4
        if (v11 < 0 == ((v11 ^ v9) & (v10 ^ v9)) < 0) {
            int32_t v15 = g5 + 32; // 0x1000032c0
            g5 = v15;
            int64_t * v16 = _realloc((int64_t *)v12, v15); // 0x1000032d4
            g3 = (char *)v16;
            v13 = g4;
            v14 = (char *)v16;
        }
        // 0x1000032e8
        g4 = v13 + 1;
        *(char *)((int64_t)v14 + (int64_t)v13) = (char)g1;
        if (v2 == (int32_t)function_100002e68((int64_t)&g10)) {
            goto lab_0x100003320;
        }
    }
    // 0x10000323c
    function_10000394c();
    // UNREACHABLE
}

// Address range: 0x1000033dc - 0x100003714
int64_t function_1000033dc(void) {
    // 0x1000033dc
    g4 = 0;
    int32_t v1 = g4; // 0x100003448
    int32_t v2 = 1; // 0x100003448
    int32_t v3 = 1; // 0x100003448
    int32_t v4 = g4; // 0x100003448
    if (_isalnum(g1) != 0 || g1 == 95) {
        int32_t v5 = v1;
        int32_t v6 = g5; // 0x100003464
        int32_t v7 = v5 - v6; // 0x100003468
        char * v8 = g3;
        int32_t v9 = v5; // 0x100003470
        char * v10 = v8; // 0x100003470
        int32_t v11; // 0x10000348c
        int64_t * v12; // 0x1000034a0
        if (v7 < 0 == ((v7 ^ v5) & (v6 ^ v5)) < 0) {
            // 0x100003478
            v11 = v6 + 32;
            g5 = v11;
            v12 = _realloc((int64_t *)v8, v11);
            g3 = (char *)v12;
            v9 = g4;
            v10 = (char *)v12;
        }
        // 0x1000034b4
        g4 = v9 + 1;
        *(char *)((int64_t)v10 + (int64_t)v9) = (char)g1;
        v2 = _isdigit(g1) == 0 ? 0 : v2;
        function_100002e68((int64_t)&g10);
        int32_t v13 = g1;
        v1 = g4;
        v3 = v2;
        v4 = v1;
        while (_isalnum(g1) != 0 || v13 == 95) {
            // 0x100003458
            v5 = v1;
            v6 = g5;
            v7 = v5 - v6;
            v8 = g3;
            v9 = v5;
            v10 = v8;
            int32_t v14 = v13; // 0x100003470
            if (v7 < 0 == ((v7 ^ v5) & (v6 ^ v5)) < 0) {
                // 0x100003478
                v11 = v6 + 32;
                g5 = v11;
                v12 = _realloc((int64_t *)v8, v11);
                g3 = (char *)v12;
                v9 = g4;
                v10 = (char *)v12;
                v14 = g1;
            }
            // 0x1000034b4
            g4 = v9 + 1;
            *(char *)((int64_t)v10 + (int64_t)v9) = (char)v14;
            v2 = _isdigit(g1) == 0 ? 0 : v2;
            function_100002e68((int64_t)&g10);
            v13 = g1;
            v1 = g4;
            v3 = v2;
            v4 = v1;
        }
    }
    int32_t v15 = v4;
    if (v15 == 0) {
        // 0x100003524
        function_10000394c();
        // UNREACHABLE
    }
    int32_t v16 = v15 - g5; // 0x100003574
    int32_t v17 = v15; // 0x10000357c
    char * v18 = g3; // 0x10000357c
    if (v16 < 0 == ((v16 ^ v15) & (g5 ^ v15)) < 0) {
        int32_t v19 = g5 + 32; // 0x100003598
        g5 = v19;
        int64_t * v20 = _realloc((int64_t *)g3, v19); // 0x1000035ac
        g3 = (char *)v20;
        v17 = g4;
        v18 = (char *)v20;
    }
    // 0x1000035c0
    int64_t v21; // 0x1000033dc
    int32_t * v22 = (int32_t *)v21; // 0x1000033e8
    int32_t v23 = v21; // 0x1000033ec
    int32_t v24 = v21; // 0x1000033f0
    g4 = v17 + 1;
    *(char *)((int64_t)v18 + (int64_t)v17) = 0;
    if (_isdigit((int32_t)*g3) == 0) {
        int64_t result = function_100003ac4(); // 0x1000036dc
        *v22 = (int32_t)result;
        *(int32_t *)(v21 + 4) = v23;
        *(int32_t *)(v21 + 8) = v24;
        *(int64_t *)(v21 + 16) = (int64_t)g3;
        // 0x100003708
        return result;
    }
    if (v3 == 0) {
        // 0x10000361c
        function_10000394c();
        // UNREACHABLE
    }
    int32_t result2 = _strtol(g3, NULL, 0); // 0x100003654
    *v22 = 29;
    *(int32_t *)(v21 + 4) = v23;
    *(int32_t *)(v21 + 8) = v24;
    *(int32_t *)(v21 + 16) = result2;
    // 0x100003708
    return result2;
}

// Address range: 0x100003714 - 0x1000038ac
int64_t function_100003714(void) {
    // 0x100003714
    int64_t v1; // 0x100003714
    char * v2 = (char *)v1;
    function_1000028e4((int64_t)&g10);
    _fprintf(g7, "%5d  %5d %.15s", v1, v1, (char *)v1);
    float128_t v3; // 0x100003714
    switch ((int32_t)(float32_t)v3) {
        case 29: {
            // 0x1000037a0
            _fprintf(g7, "  %4d", v1);
            // break -> 0x100003840
            break;
        }
        case 28: {
            // 0x1000037dc
            _fprintf(g7, " %s", v2);
            // break -> 0x100003840
            break;
        }
        case 30: {
            // 0x100003814
            _fprintf(g7, " \"%s\"", v2);
            // break -> 0x100003840
            break;
        }
    }
    int32_t v4 = _fprintf(g7, "\n"); // 0x100003850
    float128_t v5; // 0x100003714
    while ((int32_t)(float32_t)v5 != 0) {
        // 0x100003724
        function_1000028e4((int64_t)&g10);
        _fprintf(g7, "%5d  %5d %.15s", v1, v1, (char *)v1);
        switch ((int32_t)(float32_t)v3) {
            case 29: {
                // 0x1000037a0
                _fprintf(g7, "  %4d", v1);
                // break -> 0x100003840
                break;
            }
            case 28: {
                // 0x1000037dc
                _fprintf(g7, " %s", v2);
                // break -> 0x100003840
                break;
            }
            case 30: {
                // 0x100003814
                _fprintf(g7, " \"%s\"", v2);
                // break -> 0x100003840
                break;
            }
        }
        // 0x100003840
        v4 = _fprintf(g7, "\n");
    }
    int32_t result = v4; // 0x100003888
    if (*(int64_t *)*(int64_t *)0x100004018 != (int64_t)g7) {
        // 0x100003890
        result = _fclose(g7);
    }
    // 0x1000038a0
    return result;
}

// Address range: 0x1000038ac - 0x10000394c
int64_t function_1000038ac(void) {
    // 0x1000038ac
    int64_t v1; // 0x1000038ac
    if ((char)v1 == 0) {
        // 0x100003940
        int64_t result; // 0x1000038ac
        return result;
    }
    struct _IO_FILE * v2 = _fopen((char *)v1, (char *)v1); // 0x1000038f8
    int64_t result2 = (int64_t)v2; // 0x1000038f8
    *(int64_t *)v1 = result2;
    if (v2 != NULL) {
        // 0x100003940
        return result2;
    }
    // 0x100003918
    function_10000394c();
    // UNREACHABLE
}

// Address range: 0x10000394c - 0x1000039d8
int64_t function_10000394c(void) {
    // 0x10000394c
    int64_t v1; // 0x10000394c
    int64_t v2; // bp-1032, 0x10000394c
    int64_t v3; // 0x10000394c
    ___vsprintf_chk(&v2, 0, 1000, v3, (int64_t)&v1);
    _printf("(%d,%d) error: %s\n", 0, 1000, (char *)v3);
    _exit(1);
    return &g10;
}

// Address range: 0x1000039d8 - 0x100003ac4
int64_t entry_point(void) {
    // 0x1000039d8
    function_1000038ac();
    function_1000038ac();
    function_100003714();
    return 0;
}

// Address range: 0x100003ac4 - 0x100003b44
int64_t function_100003ac4(void) {
    // 0x100003ac4
    int64_t v1; // bp-24, 0x100003ac4
    int64_t * v2 = _bsearch(&v1, (int64_t *)"a?", 5, 16, (int32_t (*)(int64_t *, int64_t *))0x100003b44); // 0x100003af4
    int64_t v3 = (int64_t)v2; // 0x100003af4
    g9 = v3;
    int64_t result = 28; // 0x100003b0c
    if (v2 != NULL) {
        // 0x100003b20
        result = (int64_t)*(int32_t *)(v3 + 8);
    }
    // 0x100003b34
    return result;
}

// Address range: 0x100003b44 - 0x100003b78
int64_t function_100003b44(void) {
    // 0x100003b44
    int64_t v1; // 0x100003b44
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003b78 - 0x100003b84
void function_100003b78(int32_t status, int32_t errnum, char * format, ...) {
    // 0x100003b78
    ___error(status, errnum, format);
}

// Address range: 0x100003b84 - 0x100003b90
int64_t function_100003b84(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x100003b84
    return ___vsprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003b90 - 0x100003b9c
int64_t * function_100003b90(int64_t * key, int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003b90
    return _bsearch(key, base, nmemb, size, compar);
}

// Address range: 0x100003b9c - 0x100003ba8
void function_100003b9c(int32_t status) {
    // 0x100003b9c
    _exit(status);
}

// Address range: 0x100003ba8 - 0x100003bb4
int32_t function_100003ba8(struct _IO_FILE * stream) {
    // 0x100003ba8
    return _fclose(stream);
}

// Address range: 0x100003bb4 - 0x100003bc0
struct _IO_FILE * function_100003bb4(char * filename, char * modes) {
    // 0x100003bb4
    return _fopen(filename, modes);
}

// Address range: 0x100003bc0 - 0x100003bcc
int32_t function_100003bc0(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003bc0
    return _fprintf(stream, format);
}

// Address range: 0x100003bcc - 0x100003bd8
int32_t function_100003bcc(struct _IO_FILE * stream) {
    // 0x100003bcc
    return _getc(stream);
}

// Address range: 0x100003bd8 - 0x100003be4
int32_t function_100003bd8(int32_t c) {
    // 0x100003bd8
    return _isalnum(c);
}

// Address range: 0x100003be4 - 0x100003bf0
int32_t function_100003be4(int32_t c) {
    // 0x100003be4
    return _isdigit(c);
}

// Address range: 0x100003bf0 - 0x100003bfc
int32_t function_100003bf0(int32_t c) {
    // 0x100003bf0
    return _isspace(c);
}

// Address range: 0x100003bfc - 0x100003c08
int32_t function_100003bfc(char * format, ...) {
    // 0x100003bfc
    return _printf(format);
}

// Address range: 0x100003c08 - 0x100003c14
int64_t * function_100003c08(int64_t * ptr, int32_t size) {
    // 0x100003c08
    return _realloc(ptr, size);
}

// Address range: 0x100003c14 - 0x100003c20
int32_t function_100003c14(char * s1, char * s2) {
    // 0x100003c14
    return _strcmp(s1, s2);
}

// Address range: 0x100003c20 - 0x100003c2c
int32_t function_100003c20(char * nptr, char ** endptr, int32_t base) {
    // 0x100003c20
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 30

`
`#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*  Constraints: input is in the form of (\+|-)?[0-9]+
 *  and without leading zero (0 itself can be as "0" or "+0", but not "-0");
 *  input pointer is realloc'able and may change;
 *  if input has leading + sign, return may or may not keep it.
 *  The constranits conform to sprintf("%+d") and this function's own output.
 */
char * incr(char *s)
{
	int i, begin, tail, len;
	int neg = (*s == '-');
	char tgt = neg ? '0' : '9';

	/* special case: "-1" */
	if (!strcmp(s, "-1")) {
		s[0] = '0', s[1] = '\0';
		return s;
	}

	len = strlen(s);
	begin = (*s == '-' || *s == '+') ? 1 : 0;

	/* find out how many digits need to be changed */
	for (tail = len - 1; tail >= begin && s[tail] == tgt; tail--);

	if (tail < begin && !neg) {
		/* special case: all 9s, string will grow */
		if (!begin) s = realloc(s, len + 2);
		s[0] = '1';
		for (i = 1; i <= len - begin; i++) s[i] = '0';
		s[len + 1] = '\0';
	} else if (tail == begin && neg && s[1] == '1') {
		/* special case: -1000..., so string will shrink */
		for (i = 1; i < len - begin; i++) s[i] = '9';
		s[len - 1] = '\0';
	} else { /* normal case; change tail to all 0 or 9, change prev digit by 1*/
		for (i = len - 1; i > tail; i--)
			s[i] = neg ? '9' : '0';
		s[tail] += neg ? -1 : 1;
	}

	return s;
}

void string_test(const char *s)
{
	char *ret = malloc(strlen(s));
	strcpy(ret, s);

	printf("text: %s\n", ret);
	printf("  ->: %s\n", ret = incr(ret));
	free(ret);
}

int main()
{
	string_test("+0");
	string_test("-1");
	string_test("-41");
	string_test("+41");
	string_test("999");
	string_test("+999");
	string_test("109999999999999999999999999999999999999999");
	string_test("-100000000000000000000000000000000000000000000");

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a20(void);
int64_t function_100003dc4(void);
int64_t function_100003ecc(int64_t a1, int64_t a2, int64_t a3);
void function_100003ed8(int64_t * ptr);
int64_t * function_100003ee4(int32_t size);
int32_t function_100003ef0(char * format, ...);
int64_t * function_100003efc(int64_t * ptr, int32_t size);
int32_t function_100003f08(char * s1, char * s2);
int32_t function_100003f14(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003a20 - 0x100003dc4
int64_t function_100003a20(void) {
    // 0x100003a20
    int64_t v1; // 0x100003a20
    char * v2 = (char *)v1; // 0x100003a2c
    if (_strcmp(v2, "-1") == 0) {
        // 0x100003a8c
        *v2 = 48;
        *(char *)(v1 + 1) = 0;
        // 0x100003db4
        return (int64_t)v2;
    }
    char v3 = v1;
    int32_t v4 = _strlen(v2); // 0x100003ab0
    bool v5 = v3 == 45 | v3 == 43;
    int32_t v6 = v5;
    int32_t v7 = v4; // 0x100003b18
    v7--;
    while ((v7 - v6) < 0 == (v7 & -((v7 - v6))) < 0) {
        char v8 = *(char *)(v1 + (int64_t)v7); // 0x100003b44
        if ((v3 != 45 ? 57 : 48) != (int32_t)v8) {
            goto lab_0x100003c54;
        }
        v7--;
    }
    if (v3 != 45) {
        char * v9 = v2; // 0x100003bb4
        if (!v5) {
            // 0x100003bbc
            v9 = (char *)_realloc((int64_t *)v1, v4 + 2);
        }
        // 0x100003bdc
        *v9 = 49;
        int32_t v10 = v4 - v6; // 0x100003c00
        int32_t v11 = 1 - v10; // 0x100003c04
        int64_t v12 = (int64_t)v9;
        int32_t v13 = 1; // 0x100003c0c
        if (v11 == 0 || v11 < 0 != (v11 & v10) < 0) {
            *(char *)((int64_t)v13 + v12) = 48;
            int32_t v14 = v13 + 1; // 0x100003c30
            int32_t v15 = v14 - v10; // 0x100003c04
            v13 = v14;
            while (v15 == 0 || v15 < 0 != ((v15 ^ v14) & (v14 ^ v10)) < 0) {
                // 0x100003c14
                *(char *)((int64_t)v13 + v12) = 48;
                v14 = v13 + 1;
                v15 = v14 - v10;
                v13 = v14;
            }
            // 0x100003c3c
            *(char *)(v12 + (int64_t)(v4 + 1)) = 0;
            // 0x100003db4
            return (int64_t)v9;
        }
        // 0x100003c3c
        *(char *)(v12 + (int64_t)(v4 + 1)) = 0;
        // 0x100003db4
        return (int64_t)v9;
    }
  lab_0x100003c54:
    if (v3 == 45 && v7 == v6) {
        // 0x100003c80
        if (*(char *)(v1 + 1) == 49) {
            int32_t v16 = v4 - v6; // 0x100003cb0
            int32_t v17 = 1 - v16; // 0x100003cb4
            int32_t v18 = 1; // 0x100003cbc
            if (v17 < 0 != (v17 & v16) < 0) {
                *(char *)(v1 + (int64_t)v18) = 57;
                int32_t v19 = v18 + 1; // 0x100003ce0
                int32_t v20 = v19 - v16; // 0x100003cb4
                v18 = v19;
                while (v20 < 0 != ((v20 ^ v19) & (v19 ^ v16)) < 0) {
                    // 0x100003cc4
                    *(char *)(v1 + (int64_t)v18) = 57;
                    v19 = v18 + 1;
                    v20 = v19 - v16;
                    v18 = v19;
                }
            }
            // 0x100003cec
            *(char *)(v1 + (int64_t)(v4 - 1)) = 0;
            // 0x100003db4
            return (int64_t)v2;
        }
    }
    int32_t v21 = v4 - 1;
    int32_t v22 = v21 - v7; // 0x100003d1c
    if (v22 != 0 && v22 < 0 == ((v22 ^ v21) & (v7 ^ v21)) < 0) {
        char v23 = v3 != 45 ? 48 : 57; // 0x100003d54
        int32_t v24 = v21;
        *(char *)(v1 + (int64_t)v24) = v23;
        v24--;
        while (v24 - v7 != 0 && v24 - v7 < 0 == ((v24 - v7 ^ v24) & (v24 ^ v7)) < 0) {
            // 0x100003d2c
            *(char *)(v1 + (int64_t)v24) = v23;
            v24--;
        }
    }
    char * v25 = (char *)(v1 + (int64_t)v7); // 0x100003d94
    *v25 = *v25 + (v3 != 45 ? 1 : -1);
    // 0x100003db4
    return (int64_t)v2;
}

// Address range: 0x100003dc4 - 0x100003e44
int64_t function_100003dc4(void) {
    // 0x100003dc4
    int64_t v1; // 0x100003dc4
    char * v2 = (char *)v1; // 0x100003dd8
    ___strcpy_chk((int64_t)_malloc(_strlen(v2)), v1, -1);
    _printf("text: %s\n", v2);
    int64_t v3 = function_100003a20(); // 0x100003e10
    _printf("  ->: %s\n", v2);
    _free((int64_t *)v3);
    return &g1;
}

// Address range: 0x100003e44 - 0x100003ecc
int64_t entry_point(void) {
    // 0x100003e44
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    function_100003dc4();
    return 0;
}

// Address range: 0x100003ecc - 0x100003ed8
int64_t function_100003ecc(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003ecc
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003ed8 - 0x100003ee4
void function_100003ed8(int64_t * ptr) {
    // 0x100003ed8
    _free(ptr);
}

// Address range: 0x100003ee4 - 0x100003ef0
int64_t * function_100003ee4(int32_t size) {
    // 0x100003ee4
    return _malloc(size);
}

// Address range: 0x100003ef0 - 0x100003efc
int32_t function_100003ef0(char * format, ...) {
    // 0x100003ef0
    return _printf(format);
}

// Address range: 0x100003efc - 0x100003f08
int64_t * function_100003efc(int64_t * ptr, int32_t size) {
    // 0x100003efc
    return _realloc(ptr, size);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * s1, char * s2) {
    // 0x100003f08
    return _strcmp(s1, s2);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * s) {
    // 0x100003f14
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`/**
 * Game 21 - an example in C language for Rosseta Code.
 *
 * A simple game program whose rules are described below
 * - see DESCRIPTION string.
 *
 * This program should be compatible with C89 and up.
 */


/*
 * Turn off MS Visual Studio panic warnings which disable to use old gold
 * library functions like printf, scanf etc. This definition should be harmless
 * for non-MS compilers.
 */
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/*
 * Define bool, true and false as needed. The stdbool.h is a standard header
 * in C99, therefore for older compilers we need DIY booleans. BTW, there is
 * no __STDC__VERSION__ predefined macro in MS Visual C, therefore we need
 * check also _MSC_VER.
 */
#if __STDC_VERSION__ >= 199901L || _MSC_VER >= 1800
#include <stdbool.h>
#else
#define bool int
#define true  1
#define false 0
#endif

#define GOAL               21
#define NUMBER_OF_PLAYERS   2
#define MIN_MOVE            1
#define MAX_MOVE            3
#define BUFFER_SIZE       256

#define _(STRING) STRING


/*
 * Spaces are meaningful: on some systems they can be visible.
 */
static char DESCRIPTION[] =
    "21 Game                                                          \n"
    "                                                                 \n"
    "21 is a two player game, the game is played by choosing a number \n"
    "(1, 2, or 3) to be added to the running total. The game is won by\n"
    "the player whose chosen number causes the running total to reach \n"
    "exactly 21. The running total starts at zero.                    \n\n";

static int total;


void update(char* player, int move)
{
    printf("%8s:  %d = %d + %d\n\n", player, total + move, total, move);
    total += move;
    if (total == GOAL)
        printf(_("The winner is %s.\n\n"), player);
}


int ai()
{
/*
 * There is a winning strategy for the first player. The second player can win
 * then and only then the frist player does not use the winning strategy.
 *
 * The winning strategy may be defined as best move for the given running total.
 * The running total is a number from 0 to GOAL. Therefore, for given GOAL, best
 * moves may be precomputed (and stored in a lookup table). Actually (when legal
 * moves are 1 or 2 or 3) the table may be truncated to four first elements.
 */
#if GOAL < 32 && MIN_MOVE == 1 && MAX_MOVE == 3
    static const int precomputed[] = { 1, 1, 3, 2, 1, 1, 3, 2, 1, 1, 3, 2, 1, 1,
        3, 2, 1, 1, 3, 2, 1, 1, 3, 2, 1, 1, 3, 2, 1, 1, 3 };
    update(_("ai"), precomputed[total]);
#elif MIN_MOVE == 1 && MAX_MOVE == 3
    static const int precomputed[] = { 1, 1, 3, 2};
    update(_("ai"), precomputed[total % (MAX_MOVE + 1)]);
#else
    int i;
    int move = 1;
    for (i = MIN_MOVE; i <= MAX_MOVE; i++)
        if ((total + i - 1) % (MAX_MOVE + 1) == 0)
            move = i;
    for (i = MIN_MOVE; i <= MAX_MOVE; i++)
        if (total + i == GOAL)
            move = i;
    update(_("ai"), move);
#endif
}


void human(void)
{
    char buffer[BUFFER_SIZE];
    int move;

    while ( printf(_("enter your move to play (or enter 0 to exit game): ")),
            fgets(buffer, BUFFER_SIZE, stdin),
            sscanf(buffer, "%d", &move) != 1 ||
            (move && (move < MIN_MOVE || move > MAX_MOVE || total+move > GOAL)))
        puts(_("\nYour answer is not a valid choice.\n"));
    putchar('\n');
    if (!move) exit(EXIT_SUCCESS);
    update(_("human"), move);
}


int main(int argc, char* argv[])
{
    srand(time(NULL));
    puts(_(DESCRIPTION));
    while (true)
    {
        puts(_("\n---- NEW GAME ----\n"));
        puts(_("\nThe running total is currently zero.\n"));
        total = 0;

        if (rand() % NUMBER_OF_PLAYERS)
        {
            puts(_("The first move is AI move.\n"));
            ai();
        }
        else
            puts(_("The first move is human move.\n"));

        while (total < GOAL)
        {
            human();
            ai();
        }
    }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a60(void);
int64_t function_100003b10(int64_t a1);
int64_t function_100003b4c(void);
int64_t function_100003da4(int64_t a1);
void function_100003db0(int32_t status);
char * function_100003dbc(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_100003dc8(char * format, ...);
int32_t function_100003dd4(int32_t c);
int32_t function_100003de0(char * s);
int32_t function_100003dec(void);
void function_100003df8(int32_t seed);
int32_t function_100003e04(char * s, char * format, ...);
int32_t function_100003e10(int32_t * timer);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x100008190

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _sscanf(char * a1, char * a2, ...);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003a60 - 0x100003b10
int64_t function_100003a60(void) {
    // 0x100003a60
    int64_t v1; // 0x100003a60
    char * v2 = (char *)v1; // 0x100003abc
    int32_t v3 = g1 + (int32_t)v1; // 0x100003acc
    g1 = v3;
    int32_t result = _printf("%8s:  %d = %d + %d\n\n", v2, v1, v1, v1); // 0x100003ae0
    if (v3 == 21) {
        // 0x100003ae8
        result = _printf("The winner is %s.\n\n", v2);
    }
    // 0x100003b04
    return result;
}

// Address range: 0x100003b10 - 0x100003b4c
int64_t function_100003b10(int64_t a1) {
    // 0x100003b10
    function_100003a60();
    int32_t v1; // 0x100003b10
    return (uint32_t)v1;
}

// Address range: 0x100003b4c - 0x100003cdc
int64_t function_100003b4c(void) {
    // 0x100003b4c
    int32_t v1; // 0x100003b4c
    int32_t v2 = v1;
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b64
    int32_t v4 = v2 - 3;
    while (true) {
        // 0x100003b70
        _printf("enter your move to play (or enter 0 to exit game): ");
        int64_t v5 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003b84
        int64_t v6; // bp-296, 0x100003b4c
        _fgets((char *)&v6, 256, (struct _IO_FILE *)v5);
        if (_sscanf((char *)&v6, "%d", (int64_t *)v5) == 1) {
            if (v2 == 0) {
                // break -> 0x100003c90
                break;
            }
            if (!((v2 < 1 != (v2 & -v2) < 0 | v4 != 0 == v4 < 0 == (2 - v2 & v2) < 0))) {
                int32_t v7 = g1 + v2; // 0x100003c2c
                int32_t v8 = v7 - 21; // 0x100003c30
                if (v8 == 0 || v8 < 0 != (20 - v7 & v7) < 0) {
                    // 0x100003c98
                    _putchar(10);
                    int64_t result = function_100003a60(); // 0x100003ca4
                    if (*(int64_t *)*(int64_t *)0x100004008 == v3) {
                        // 0x100003ccc
                        return result;
                    }
                    // 0x100003ccc
                    return ___stack_chk_fail(result);
                }
            }
        }
        // 0x100003c64
        _puts("\nYour answer is not a valid choice.\n");
    }
    // 0x100003c90
    _putchar(10);
    _exit(0);
    // UNREACHABLE
}

// Address range: 0x100003cdc - 0x100003da4
int64_t entry_point(void) {
    // 0x100003cdc
    _srand(_time(NULL));
    _puts("21 Game                                                          \n                                                                 \n21 is a two player game, the game is played by choosing a number \n(1, 2, or 3) to be added to the running total. The game is won by\nthe player whose chosen number causes the running total to reach \nexactly 21. The running total starts at zero.                    \n\n");
    while (true) {
        // 0x100003d10
        _puts("\n---- NEW GAME ----\n");
        _puts("\nThe running total is currently zero.\n");
        g1 = 0;
        int32_t v1 = _rand(); // 0x100003d30
        if (v1 == 2 * v1 / 2) {
            // 0x100003d68
            _puts("The first move is human move.\n");
        } else {
            // 0x100003d54
            function_100003b10((int64_t)_puts("The first move is AI move.\n"));
        }
        int32_t v2 = g1; // 0x100003d80
        if (v2 < 21 != (20 - v2 & v2) < 0) {
            function_100003b10(function_100003b4c());
            while (g1 < 21 != (20 - g1 & g1) < 0) {
                // 0x100003d94
                function_100003b10(function_100003b4c());
            }
        }
    }
}

// Address range: 0x100003da4 - 0x100003db0
int64_t function_100003da4(int64_t a1) {
    // 0x100003da4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003db0 - 0x100003dbc
void function_100003db0(int32_t status) {
    // 0x100003db0
    _exit(status);
}

// Address range: 0x100003dbc - 0x100003dc8
char * function_100003dbc(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003dbc
    return _fgets(s, n, stream);
}

// Address range: 0x100003dc8 - 0x100003dd4
int32_t function_100003dc8(char * format, ...) {
    // 0x100003dc8
    return _printf(format);
}

// Address range: 0x100003dd4 - 0x100003de0
int32_t function_100003dd4(int32_t c) {
    // 0x100003dd4
    return _putchar(c);
}

// Address range: 0x100003de0 - 0x100003dec
int32_t function_100003de0(char * s) {
    // 0x100003de0
    return _puts(s);
}

// Address range: 0x100003dec - 0x100003df8
int32_t function_100003dec(void) {
    // 0x100003dec
    return _rand();
}

// Address range: 0x100003df8 - 0x100003e04
void function_100003df8(int32_t seed) {
    // 0x100003df8
    _srand(seed);
}

// Address range: 0x100003e04 - 0x100003e10
int32_t function_100003e04(char * s, char * format, ...) {
    // 0x100003e04
    return _sscanf(s, format);
}

// Address range: 0x100003e10 - 0x100003e1c
int32_t function_100003e10(int32_t * timer) {
    // 0x100003e10
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`#include <stdio.h>

/**
 * description : Counts the number of bits set to 1
 *        input: the number to have its bit counted
 *       output: the number of bits set to 1
 */
unsigned count_bits(unsigned v) {
    unsigned c = 0;
    while (v) {
        c += v & 1;
        v >>= 1;
    }

    return c;
}

int main(void) {
    for (unsigned i = 0; i < 256; ++i) {
        putchar('0' + count_bits(i) % 2);
    }
    putchar('\n');

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ec8(void);
int32_t function_100003f94(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ec8 - 0x100003f1c
int64_t function_100003ec8(void) {
    // 0x100003ec8
    int64_t v1; // 0x100003ec8
    int32_t v2 = v1; // 0x100003ecc
    uint32_t v3 = v2; // 0x100003ee4
    if (v2 == 0) {
        // 0x100003f10
        return 0;
    }
    int32_t result = 0; // 0x100003ee4
    result += v3 % 2;
    while (v3 >= 2) {
        // 0x100003eec
        v3 /= 2;
        result += v3 % 2;
    }
    // 0x100003f10
    return result;
}

// Address range: 0x100003f1c - 0x100003f94
int64_t entry_point(void) {
    for (int32_t i = 0; i < 256; i++) {
        uint32_t v1 = (int32_t)function_100003ec8(); // 0x100003f54
        _putchar(v1 + 48 - 2 * v1 / 2);
    }
    // 0x100003f7c
    _putchar(10);
    return 0;
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(int32_t c) {
    // 0x100003f94
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int compareStrings(const void *a, const void *b) {
    const char **aa = (const char **)a;
    const char **bb = (const char **)b;
    return strcmp(*aa, *bb);
}

void lexOrder(int n, int *ints) {
    char **strs;
    int i, first = 1, last = n, k = n, len;
    if (n < 1) {
        first = n; last = 1; k = 2 - n;
    }
    strs = malloc(k * sizeof(char *));
    for (i = first; i <= last; ++i) {
        if (i >= 1) len = (int)log10(i) + 2;
        else if (i == 0) len = 2;
        else len = (int)log10(-i) + 3;
        strs[i-first] = malloc(len);
        sprintf(strs[i-first], "%d", i);
    }
    qsort(strs, k, sizeof(char *), compareStrings);
    for (i = 0; i < k; ++i) {
        ints[i] = atoi(strs[i]);
        free(strs[i]);
    }
    free(strs);
}

int main() {
    int i, j, k, n,  *ints;
    int numbers[5] = {0, 5, 13, 21, -22};
    printf("In lexicographical order:\n\n");
    for (i = 0; i < 5; ++i) {
        k = n = numbers[i];
        if (k < 1) k = 2 - k;
        ints = malloc(k * sizeof(int));
        lexOrder(n, ints);
        printf("%3d: [", n);
        for (j = 0; j < k; ++j) {
            printf("%d ", ints[j]);
        }
        printf("\b]\n");
        free(ints);
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b20(void);
int64_t function_100003b64(void);
int64_t function_100003ef8(int64_t a1, int64_t a2, int64_t a3, char * a4);
int64_t function_100003f04(int64_t a1);
int32_t function_100003f10(char * nptr);
void function_100003f1c(int64_t * ptr);
float64_t function_100003f28(float64_t a1);
int64_t * function_100003f34(int32_t size);
int32_t function_100003f40(char * format, ...);
void function_100003f4c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003f58(char * s1, char * s2);

// --------------------- Global Variables ---------------------

float128_t g1 = 1.06099789548263615755569110743160442e-313L; // 0x100003f94
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(int64_t a1, int64_t a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _atoi(char * a1);
void _free(int64_t * a1);
float64_t _log10(float64_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003b20 - 0x100003b64
int64_t function_100003b20(void) {
    // 0x100003b20
    int64_t v1; // 0x100003b20
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003b64 - 0x100003d70
int64_t function_100003b64(void) {
    // 0x100003b64
    int64_t v1; // 0x100003b64
    int32_t v2 = v1; // 0x100003b70
    int32_t v3 = v2 < 1 == (v2 & -v2) < 0 ? 1 : v2;
    int32_t v4 = v2 < 1 == (v2 & -v2) < 0 ? v2 : 1;
    int32_t v5 = v2 < 1 == (v2 & -v2) < 0 ? v2 : 2 - v2;
    int64_t * v6 = _malloc(8 * v5); // 0x100003bd0
    int64_t v7 = (int64_t)v6; // 0x100003bd0
    int32_t v8 = v3 - v4; // 0x100003bec
    if (v8 == 0 || v8 < 0 != ((v8 ^ v3) & (v3 ^ v4)) < 0) {
        int32_t v9 = v3;
        int32_t v10 = -v9;
        float64_t v11; // 0x100003b64
        float64_t v12; // 0x100003b64
        int32_t v13; // 0x100003b64
        int64_t v14; // 0x100003b64
        int64_t v15; // 0x100003b64
        int128_t v16; // 0x100003c18
        if (v9 < 1 == (v9 & v10) < 0) {
            // 0x100003c10
            v16 = __asm_sshll(0.0f, 0);
            v15 = (float32_t)_log10((float64_t)(int64_t)v16);
            v12 = v11;
            v13 = (int32_t)v11 + 2;
        } else {
            // 0x100003c34
            int128_t v17; // 0x100003b64
            v14 = v17;
            v15 = v14;
            v12 = v11;
            v13 = 2;
            if (v9 != 0) {
                // 0x100003c54
                v15 = (float32_t)_log10((float64_t)v14);
                v12 = v10;
                v13 = 3 - v9;
            }
        }
        int64_t v18 = (int64_t)_malloc(v13); // 0x100003c80
        *(int64_t *)((int64_t)(8 * (v9 - v3)) + v7) = v18;
        ___sprintf_chk(v18, 0, -1, "%d");
        int32_t v19 = v9 + 1; // 0x100003cd8
        int32_t v20 = v19 - v4; // 0x100003bec
        while (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v19 ^ v4)) < 0) {
            float64_t v21 = v12;
            v9 = v19;
            v10 = -v9;
            if (v9 < 1 == (v9 & v10) < 0) {
                // 0x100003c10
                v16 = __asm_sshll(0.0f, 0);
                v15 = (float32_t)_log10((float64_t)(int64_t)v16);
                v12 = v21;
                v13 = (int32_t)v21 + 2;
            } else {
                // 0x100003c34
                v14 = v15;
                v15 = v14;
                v12 = v21;
                v13 = 2;
                if (v9 != 0) {
                    // 0x100003c54
                    v15 = (float32_t)_log10((float64_t)v14);
                    v12 = v10;
                    v13 = 3 - v9;
                }
            }
            // 0x100003c7c
            v18 = (int64_t)_malloc(v13);
            *(int64_t *)((int64_t)(8 * (v9 - v3)) + v7) = v18;
            ___sprintf_chk(v18, 0, -1, "%d");
            v19 = v9 + 1;
            v20 = v19 - v4;
        }
    }
    // 0x100003ce4
    _qsort(v6, v5, 8, (int32_t (*)(int64_t *, int64_t *))0x100003b20);
    int32_t v22 = -v5; // 0x100003d0c
    int32_t v23 = 0; // 0x100003d14
    if (v22 < 0 == (v5 & v22) < 0) {
        // 0x100003d5c
        _free(v6);
        return &g2;
    }
    int64_t v24 = v23; // 0x100003d20
    int64_t * v25 = (int64_t *)(8 * v24 + v7); // 0x100003d24
    *(int32_t *)(4 * v24 + v1) = _atoi((char *)*v25);
    _free((int64_t *)*v25);
    v23++;
    while (v23 - v5 < 0 != ((v23 - v5 ^ v23) & (v23 ^ v5)) < 0) {
        // 0x100003d1c
        v24 = v23;
        v25 = (int64_t *)(8 * v24 + v7);
        *(int32_t *)(4 * v24 + v1) = _atoi((char *)*v25);
        _free((int64_t *)*v25);
        v23++;
    }
    // 0x100003d5c
    _free(v6);
    return &g2;
}

// Address range: 0x100003d70 - 0x100003ef8
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003d84
    float128_t v2 = g1; // bp-48, 0x100003d9c
    _printf("In lexicographical order:\n\n");
    for (int64_t i = 0; i < 5; i++) {
        int32_t v3 = *(int32_t *)(4 * i + (int64_t)&v2); // 0x100003dd8
        int32_t v4 = v3 < 1 == (v3 & -v3) < 0 ? v3 : 2 - v3;
        int64_t * v5 = _malloc(4 * v4); // 0x100003e14
        int64_t v6 = (int64_t)v5; // 0x100003e14
        function_100003b64();
        _printf("%3d: [", v6);
        int32_t v7 = -v4; // 0x100003e54
        if (v7 < 0 != (v4 & v7) < 0) {
            _printf("%d ", v6);
            int32_t v8 = 1; // 0x100003e90
            int32_t v9 = v8 - v4; // 0x100003e54
            int32_t v10 = v8; // 0x100003e5c
            while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v4)) < 0) {
                // 0x100003e64
                _printf("%d ", v6);
                v8 = v10 + 1;
                v9 = v8 - v4;
                v10 = v8;
            }
        }
        // 0x100003e9c
        _printf("\b]\n");
        _free(v5);
    }
    // 0x100003ec4
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003ee4
        ___stack_chk_fail((int64_t)&g2);
    }
    // 0x100003ee8
    return 0;
}

// Address range: 0x100003ef8 - 0x100003f04
int64_t function_100003ef8(int64_t a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003ef8
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f04 - 0x100003f10
int64_t function_100003f04(int64_t a1) {
    // 0x100003f04
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * nptr) {
    // 0x100003f10
    return _atoi(nptr);
}

// Address range: 0x100003f1c - 0x100003f28
void function_100003f1c(int64_t * ptr) {
    // 0x100003f1c
    _free(ptr);
}

// Address range: 0x100003f28 - 0x100003f34
float64_t function_100003f28(float64_t a1) {
    // 0x100003f28
    return _log10(a1);
}

// Address range: 0x100003f34 - 0x100003f40
int64_t * function_100003f34(int32_t size) {
    // 0x100003f34
    return _malloc(size);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(char * format, ...) {
    // 0x100003f40
    return _printf(format);
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f4c
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(char * s1, char * s2) {
    // 0x100003f58
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>

int main() {
    int i, gprev = 0;
    int s[7] = {1, 2, 2, 3, 4, 4, 5};

    /* There is no output as 'prev' is created anew each time
       around the loop and set explicitly to zero. */
    for (i = 0; i < 7; ++i) {
//  for (int i = 0, prev; i < 7; ++i) { // as below, see note
        int curr = s[i];
        int prev = 0;
//      int prev; // produces same output as second loop
        if (i > 0 && curr == prev) printf("%d\n", i);
        prev = curr;
    }

    /*  Now 'gprev' is used and reassigned
        each time around the loop producing the desired output. */
    for (i = 0; i < 7; ++i) {
        int curr = s[i];
        if (i > 0 && curr == gprev) printf("%d\n", i);
        gprev = curr;
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f70(void);
int32_t function_100003f7c(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 4.24399158242461027606401097390298646e-314L; // 0x100003f88

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dd0 - 0x100003f70
int64_t entry_point(void) {
    int64_t v1 = (float64_t)g1; // bp-64, 0x100003e04
    int64_t v2 = &v1;
    int64_t v3 = 0;
    int64_t v4; // 0x100003dd0
    if (v3 != 0) {
        // 0x100003e54
        if (*(int32_t *)(4 * v3 + v2) == 0) {
            // 0x100003e6c
            _printf("%d\n", v4);
        }
    }
    int64_t v5 = v3 + 1;
    int64_t v6 = 0; // 0x100003e24
    while (v5 != 7) {
        // 0x100003e2c
        v3 = v5;
        if (v3 != 0) {
            // 0x100003e54
            if (*(int32_t *)(4 * v3 + v2) == 0) {
                // 0x100003e6c
                _printf("%d\n", v4);
            }
        }
        // 0x100003e98
        v5 = v3 + 1;
        v6 = 0;
    }
    int32_t v7 = *(int32_t *)(4 * v6 + v2); // 0x100003ecc
    if (v6 != 0 == v7 == 0) {
        // 0x100003f00
        _printf("%d\n", v4);
    }
    int64_t v8 = v6 + 1;
    v6 = v8;
    int32_t v9 = v7; // 0x100003ebc
    while (v8 != 7) {
        // 0x100003ec4
        v7 = *(int32_t *)(4 * v6 + v2);
        if (v6 != 0 == v7 == v9) {
            // 0x100003f00
            _printf("%d\n", v4);
        }
        // 0x100003f20
        v8 = v6 + 1;
        v6 = v8;
        v9 = v7;
    }
    int64_t v10 = *(int64_t *)0x100004008; // 0x100003f44
    if (*(int64_t *)v10 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f5c
        ___stack_chk_fail();
    }
    // 0x100003f60
    return 0;
}

// Address range: 0x100003f70 - 0x100003f7c
int64_t function_100003f70(void) {
    // 0x100003f70
    return ___stack_chk_fail();
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdlib.h>
#include <stdio.h>

typedef struct node_s
{
  int value;
  struct node_s* left;
  struct node_s* right;
} *node;

node tree(int v, node l, node r)
{
  node n = malloc(sizeof(struct node_s));
  n->value = v;
  n->left  = l;
  n->right = r;
  return n;
}

void destroy_tree(node n)
{
  if (n->left)
    destroy_tree(n->left);
  if (n->right)
    destroy_tree(n->right);
  free(n);
}

void preorder(node n, void (*f)(int))
{
  f(n->value);
  if (n->left)
    preorder(n->left, f);
  if (n->right)
    preorder(n->right, f);
}

void inorder(node n, void (*f)(int))
{
  if (n->left)
    inorder(n->left, f);
  f(n->value);
  if (n->right)
    inorder(n->right, f);
}

void postorder(node n, void (*f)(int))
{
  if (n->left)
    postorder(n->left, f);
  if (n->right)
    postorder(n->right, f);
  f(n->value);
}

/* helper queue for levelorder */
typedef struct qnode_s
{
  struct qnode_s* next;
  node value;
} *qnode;

typedef struct { qnode begin, end; } queue;

void enqueue(queue* q, node n)
{
  qnode node = malloc(sizeof(struct qnode_s));
  node->value = n;
  node->next = 0;
  if (q->end)
    q->end->next = node;
  else
    q->begin = node;
  q->end = node;
}

node dequeue(queue* q)
{
  node tmp = q->begin->value;
  qnode second = q->begin->next;
  free(q->begin);
  q->begin = second;
  if (!q->begin)
    q->end = 0;
  return tmp;
}

int queue_empty(queue* q)
{
  return !q->begin;
}

void levelorder(node n, void(*f)(int))
{
  queue nodequeue = {};
  enqueue(&nodequeue, n);
  while (!queue_empty(&nodequeue))
  {
    node next = dequeue(&nodequeue);
    f(next->value);
    if (next->left)
      enqueue(&nodequeue, next->left);
    if (next->right)
      enqueue(&nodequeue, next->right);
  }
}

void print(int n)
{
  printf("%d ", n);
}

int main()
{
  node n = tree(1,
                tree(2,
                     tree(4,
                          tree(7, 0, 0),
                          0),
                     tree(5, 0, 0)),
                tree(3,
                     tree(6,
                          tree(8, 0, 0),
                          tree(9, 0, 0)),
                     0));

  printf("preorder:    ");
  preorder(n, print);
  printf("\n");

  printf("inorder:     ");
  inorder(n, print);
  printf("\n");

  printf("postorder:   ");
  postorder(n, print);
  printf("\n");

  printf("level-order: ");
  levelorder(n, print);
  printf("\n");

  destroy_tree(n);

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000394c(int64_t a1, int64_t a2, int64_t a3);
int64_t function_1000039a4(void);
int64_t function_100003a18(void);
int64_t function_100003a3c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003aa0(void);
int64_t function_100003af0(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003b28(void);
int64_t function_100003ba4(int64_t a1, int64_t a2);
int64_t function_100003bb0(void);
int64_t function_100003c38(void);
int64_t function_100003cb4(void);
int64_t function_100003cd8(int64_t a1);
int64_t function_100003da0(void);
void function_100003f3c(int64_t * ptr);
int64_t * function_100003f48(int32_t size);
int32_t function_100003f54(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000394c - 0x1000039a4
int64_t function_10000394c(int64_t a1, int64_t a2, int64_t a3) {
    int64_t * v1 = _malloc(24); // 0x100003968
    *(int32_t *)v1 = (int32_t)a1;
    int64_t result = (int64_t)v1; // 0x100003980
    *(int64_t *)(result + 8) = a2;
    *(int64_t *)(result + 16) = a3;
    return result;
}

// Address range: 0x1000039a4 - 0x100003a18
int64_t function_1000039a4(void) {
    // 0x1000039a4
    int64_t v1; // 0x1000039a4
    if (*(int64_t *)(v1 + 8) != 0) {
        // 0x1000039cc
        function_1000039a4();
    }
    // 0x1000039dc
    if (*(int64_t *)(v1 + 16) != 0) {
        // 0x1000039f4
        function_1000039a4();
    }
    // 0x100003a04
    _free((int64_t *)v1);
    return &g1;
}

// Address range: 0x100003a18 - 0x100003a3c
int64_t function_100003a18(void) {
    // 0x100003a18
    int64_t v1; // 0x100003a18
    return v1 & 0xffffffff;
}

// Address range: 0x100003a3c - 0x100003aa0
int64_t function_100003a3c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003a3c
    int64_t v1; // 0x100003a3c
    if (*(int64_t *)(a2 + 8) != 0) {
        // 0x100003a54
        v1 = function_100003a18();
    }
    int64_t result = v1; // 0x100003a78
    if (*(int64_t *)(a2 + 16) != 0) {
        // 0x100003a80
        result = function_100003a18();
    }
    // 0x100003a94
    return result;
}

// Address range: 0x100003aa0 - 0x100003af0
int64_t function_100003aa0(void) {
    // 0x100003aa0
    int64_t v1; // 0x100003aa0
    if (*(int64_t *)(v1 + 8) != 0) {
        // 0x100003acc
        function_100003aa0();
    }
    // 0x100003ae0
    return v1 & 0xffffffff;
}

// Address range: 0x100003af0 - 0x100003b28
int64_t function_100003af0(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003af0
    int64_t result; // 0x100003af0
    if (*(int64_t *)(a2 + 16) != 0) {
        // 0x100003b08
        result = function_100003aa0();
    }
    // 0x100003b1c
    return result;
}

// Address range: 0x100003b28 - 0x100003ba4
int64_t function_100003b28(void) {
    // 0x100003b28
    int64_t v1; // 0x100003b28
    if (*(int64_t *)(v1 + 8) != 0) {
        // 0x100003b54
        function_100003b28();
    }
    // 0x100003b68
    if (*(int64_t *)(v1 + 16) != 0) {
        // 0x100003b80
        function_100003b28();
    }
    // 0x100003b94
    return v1 & 0xffffffff;
}

// Address range: 0x100003ba4 - 0x100003bb0
int64_t function_100003ba4(int64_t a1, int64_t a2) {
    // 0x100003ba4
    int64_t result; // 0x100003ba4
    return result;
}

// Address range: 0x100003bb0 - 0x100003c38
int64_t function_100003bb0(void) {
    int64_t * v1 = _malloc(16); // 0x100003bc8
    int64_t result = (int64_t)v1; // 0x100003bc8
    *v1 = 0;
    int64_t v2; // 0x100003bb0
    int64_t * v3 = (int64_t *)(v2 + 8); // 0x100003be8
    int64_t v4 = *v3; // 0x100003be8
    if (v4 == 0) {
        // 0x100003c10
        *(int64_t *)v2 = result;
    } else {
        // 0x100003bfc
        *(int64_t *)v4 = result;
    }
    // 0x100003c20
    *v3 = result;
    return result;
}

// Address range: 0x100003c38 - 0x100003cb4
int64_t function_100003c38(void) {
    // 0x100003c38
    int64_t v1; // 0x100003c38
    _free((int64_t *)v1);
    return *(int64_t *)(v1 + 8);
}

// Address range: 0x100003cb4 - 0x100003cd8
int64_t function_100003cb4(void) {
    // 0x100003cb4
    int64_t v1; // 0x100003cb4
    return v1 == 0;
}

// Address range: 0x100003cd8 - 0x100003da0
int64_t function_100003cd8(int64_t a1) {
    // 0x100003cd8
    function_100003bb0();
    int64_t result = function_100003cb4(); // 0x100003d08
    if ((int32_t)result == 0) {
        // 0x100003d1c
        return (int64_t)*(int32_t *)function_100003c38();
    }
    // 0x100003d94
    return result;
}

// Address range: 0x100003da0 - 0x100003dd8
int64_t function_100003da0(void) {
    // 0x100003da0
    int64_t v1; // 0x100003da0
    return _printf("%d ", v1);
}

// Address range: 0x100003dd8 - 0x100003f3c
int64_t entry_point(void) {
    int64_t v1 = function_10000394c(4, function_10000394c(7, 0, 0), 0); // 0x100003e10
    int64_t v2 = function_10000394c(2, v1, function_10000394c(5, 0, 0)); // 0x100003e34
    int64_t v3 = function_10000394c(8, 0, 0); // 0x100003e48
    int64_t v4 = function_10000394c(6, v3, function_10000394c(9, 0, 0)); // 0x100003e6c
    function_10000394c(1, v2, function_10000394c(3, v4, 0));
    _printf("preorder:    ");
    function_100003a18();
    _printf("\n");
    _printf("inorder:     ");
    function_100003aa0();
    _printf("\n");
    _printf("postorder:   ");
    function_100003b28();
    _printf("\n");
    _printf("level-order: ");
    function_100003cd8((int64_t)&g1);
    _printf("\n");
    function_1000039a4();
    return 0;
}

// Address range: 0x100003f3c - 0x100003f48
void function_100003f3c(int64_t * ptr) {
    // 0x100003f3c
    _free(ptr);
}

// Address range: 0x100003f48 - 0x100003f54
int64_t * function_100003f48(int32_t size) {
    // 0x100003f48
    return _malloc(size);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 17

`
`#include <stdio.h>//printf
#include <stdlib.h>//qsort
#include <math.h>//fabs
#include <stdbool.h>//bool data type
#include <strings.h>//strcasecmp
#include <assert.h>//assert, necessary for random integer selection

unsigned int * seq_len(const unsigned int START, const unsigned int END) {
//named after R function of same name, but simpler function
	unsigned start = (unsigned)START;
	unsigned end = (unsigned)END;
	if (START == END) {
		unsigned int *restrict sequence = malloc( (end+1) * sizeof(unsigned int));
		if (sequence == NULL) {
			printf("malloc failed at %s line %u\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
		}
		for (unsigned i = 0; i < end; i++) {
			sequence[i] = i+1;
		}
		return sequence;
	}
	if (START > END) {
		end = (unsigned)START;
		start = (unsigned)END;
	}
	const unsigned LENGTH = end - start ;
	unsigned int *restrict sequence = malloc( (1+LENGTH) * sizeof(unsigned int));
	if (sequence == NULL) {
		printf("malloc failed at %s line %u\n", __FILE__, __LINE__);
		perror("");
		exit(EXIT_FAILURE);
	}
	if (START < END) {
		for (unsigned index = 0; index <= LENGTH; index++) {
			sequence[index] = start + index;
		}
	} else {
		for (unsigned index = 0; index <= LENGTH; index++) {
			sequence[index] = end - index;
		}
	}
	return sequence;
}

//modified from https://phoxis.org/2012/07/12/get-sorted-index-orderting-of-an-array/

double *restrict base_arr = NULL;

static int compar_increase (const void *restrict a, const void *restrict b) {
	int aa = *((int *restrict ) a), bb = *((int *restrict) b);
	if (base_arr[aa] < base_arr[bb]) {
		return 1;
	} else if (base_arr[aa] == base_arr[bb]) {
		return 0;
	} else {
		return -1;
	}
}

static int compar_decrease (const void *restrict a, const void *restrict b) {
	int aa = *((int *restrict ) a), bb = *((int *restrict) b);
	if (base_arr[aa] < base_arr[bb]) {
		return -1;
	} else if (base_arr[aa] == base_arr[bb]) {
		return 0;
	} else {
		return 1;
	}
}

unsigned int * order (const double *restrict ARRAY, const unsigned int SIZE, const bool DECREASING) {
//this has the same name as the same R function
	unsigned int *restrict idx = malloc(SIZE * sizeof(unsigned int));
	if (idx == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
	}
	base_arr = malloc(sizeof(double) * SIZE);
	if (base_arr == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
	}
	for (unsigned int i = 0; i < SIZE; i++) {
		base_arr[i] = ARRAY[i];
		idx[i] = i;
	}
	if (DECREASING == false) {
		qsort(idx, SIZE, sizeof(unsigned int), compar_decrease);
	} else if (DECREASING == true) {
		qsort(idx, SIZE, sizeof(unsigned int), compar_increase);
	}
	free(base_arr); base_arr = NULL;
	return idx;
}

double * cummin(const double *restrict ARRAY, const unsigned int NO_OF_ARRAY_ELEMENTS) {
//this takes the same name of the R function which it copies
//this requires a free() afterward where it is used
	if (NO_OF_ARRAY_ELEMENTS < 1) {
		puts("cummin function requires at least one element.\n");
		printf("Failed at %s line %u\n", __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}
	double *restrict output = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
	if (output == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
	}
	double cumulative_min = ARRAY[0];
	for (unsigned int i = 0; i < NO_OF_ARRAY_ELEMENTS; i++) {
		if (ARRAY[i] < cumulative_min) {
			cumulative_min = ARRAY[i];
		}
		output[i] = cumulative_min;
	}
	return output;
}

double * cummax(const double *restrict ARRAY, const unsigned int NO_OF_ARRAY_ELEMENTS) {
//this takes the same name of the R function which it copies
//this requires a free() afterward where it is used
	if (NO_OF_ARRAY_ELEMENTS < 1) {
		puts("function requires at least one element.\n");
		printf("Failed at %s line %u\n", __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}
	double *restrict output = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
	if (output == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
	}
	double cumulative_max = ARRAY[0];
	for (unsigned int i = 0; i < NO_OF_ARRAY_ELEMENTS; i++) {
		if (ARRAY[i] > cumulative_max) {
			cumulative_max = ARRAY[i];
		}
		output[i] = cumulative_max;
	}
	return output;
}

double * pminx(const double *restrict ARRAY, const unsigned int NO_OF_ARRAY_ELEMENTS, const double X) {
//named after the R function pmin
	if (NO_OF_ARRAY_ELEMENTS < 1) {
		puts("pmin requires at least one element.\n");
		printf("Failed at %s line %u\n", __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}
	double *restrict pmin_array = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
	if (pmin_array == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
	}
	for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
		if (ARRAY[index] < X) {
			pmin_array[index] = ARRAY[index];
		} else {
			pmin_array[index] = X;
		}
	}
	return pmin_array;
}

void double_say (const double *restrict ARRAY, const size_t NO_OF_ARRAY_ELEMENTS) {
	printf("[1] %e", ARRAY[0]);
	for (unsigned int i = 1; i < NO_OF_ARRAY_ELEMENTS; i++) {
		printf(" %.10f", ARRAY[i]);
		if (((i+1) % 5) == 0) {
			printf("\n[%u]", i+1);
		}
	}
	puts("\n");
}

/*void uint_say (const unsigned int *restrict ARRAY, const size_t NO_OF_ARRAY_ELEMENTS) {
//for debugging
	printf("%u", ARRAY[0]);
	for (size_t i = 1; i < NO_OF_ARRAY_ELEMENTS; i++) {
		printf(",%u", ARRAY[i]);
	}
	puts("\n");
}*/

double * uint2double (const unsigned int *restrict ARRAY, const unsigned int NO_OF_ARRAY_ELEMENTS) {
	double *restrict doubleArray = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
	if (doubleArray == NULL) {
		printf("Failure to malloc at %s line %u.\n", __FILE__, __LINE__);
		perror("");
		exit(EXIT_FAILURE);
	}
	for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
		doubleArray[index] = (double)ARRAY[index];
	}
	return doubleArray;
}

double min2 (const double N1, const double N2) {
	if (N1 < N2) {
		return N1;
	} else {
		return N2;
	}
}

double * p_adjust (const double *restrict PVALUES, const unsigned int NO_OF_ARRAY_ELEMENTS, const char *restrict STRING) {
//this function is a translation of R's p.adjust "BH" method
// i is always i[index] = NO_OF_ARRAY_ELEMENTS - index - 1
	if (NO_OF_ARRAY_ELEMENTS < 1) {
		puts("p_adjust requires at least one element.\n");
		printf("Failed at %s line %u\n", __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}
	short int TYPE = -1;
	if (STRING == NULL) {
		TYPE = 0;
	} else if (strcasecmp(STRING, "BH") == 0) {
		TYPE = 0;
	} else if (strcasecmp(STRING, "fdr") == 0) {
		TYPE = 0;
	} else if (strcasecmp(STRING, "by") == 0) {
		TYPE = 1;
	} else if (strcasecmp(STRING, "Bonferroni") == 0) {
		TYPE = 2;
	} else if (strcasecmp(STRING, "hochberg") == 0) {
		TYPE = 3;
	} else if (strcasecmp(STRING, "holm") == 0) {
		TYPE = 4;
	} else if (strcasecmp(STRING, "hommel") == 0) {
		TYPE = 5;
	} else {
		printf("%s doesn't match any accepted FDR methods.\n", STRING);
		printf("Failed at %s line %u\n", __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
	if (TYPE == 2) {//Bonferroni method
		double *restrict bonferroni = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
		if (bonferroni == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
		}
		for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
			const double BONFERRONI = PVALUES[index] * NO_OF_ARRAY_ELEMENTS;
			if (BONFERRONI >= 1.0) {
				bonferroni[index] = 1.0;
			} else if ((0.0 <= BONFERRONI) && (BONFERRONI < 1.0)) {
				bonferroni[index] = BONFERRONI;
			} else {
				printf("%g is outside of the interval I planned.\n", BONFERRONI);
				printf("Failure at %s line %u\n", __FILE__, __LINE__);
				exit(EXIT_FAILURE);
			}
		}
		return bonferroni;
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
	} else if (TYPE == 4) {//Holm method
/*these values are computed separately from BH, BY, and Hochberg because they are
computed differently*/
		unsigned int *restrict o  = order(PVALUES, NO_OF_ARRAY_ELEMENTS, false);
//sorted in reverse of methods 0-3
		double *restrict o2double = uint2double(o, NO_OF_ARRAY_ELEMENTS);
		double *restrict cummax_input = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
		for (unsigned index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
			cummax_input[index] = (NO_OF_ARRAY_ELEMENTS - index ) * (double)PVALUES[o[index]];
//			printf("cummax_input[%zu] = %e\n", index, cummax_input[index]);
		}
		free(o); o = NULL;
		unsigned int *restrict ro = order(o2double, NO_OF_ARRAY_ELEMENTS, false);
		free(o2double); o2double = NULL;

		double *restrict cummax_output = cummax(cummax_input, NO_OF_ARRAY_ELEMENTS);
		free(cummax_input); cummax_input = NULL;

		double *restrict pmin = pminx(cummax_output, NO_OF_ARRAY_ELEMENTS, 1);
		free(cummax_output); cummax_output = NULL;
		double *restrict qvalues = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
		for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
			qvalues[index] = pmin[ro[index]];
		}
		free(pmin); pmin = NULL;
		free(ro); ro = NULL;
		return qvalues;
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
	} else if (TYPE == 5) {//Hommel method
//i <- seq_len(n)
//o <- order(p)
		unsigned int *restrict o = order(PVALUES, NO_OF_ARRAY_ELEMENTS, false);//false is R's default
//p <- p[o]
		double *restrict p = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
		if (p == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
		}
		for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
			p[index] = PVALUES[o[index]];
		}
//ro <- order(o)
		double *restrict o2double = uint2double(o, NO_OF_ARRAY_ELEMENTS);
		free(o); o = NULL;
		unsigned int *restrict ro = order(o2double, NO_OF_ARRAY_ELEMENTS, false);
		free(o2double); o2double = NULL;
//		puts("ro");
//q <- pa <- rep.int(min(n * p/i), n)
		double *restrict q   = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
		if (q == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
		}
		double *restrict pa  = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
		if (pa == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
		}
		double min = (double)NO_OF_ARRAY_ELEMENTS * p[0];
		for (unsigned index = 1; index < NO_OF_ARRAY_ELEMENTS; index++) {
			const double TEMP = (double)NO_OF_ARRAY_ELEMENTS * p[index] / (double)(1+index);
			if (TEMP < min) {
				min = TEMP;
			}
		}
		for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
			pa[index] = min;
			 q[index] = min;
		}
//		puts("q & pa");
//		double_say(q, NO_OF_ARRAY_ELEMENTS);
/*for (j in (n - 1):2) {
            ij <- seq_len(n - j + 1)
            i2 <- (n - j + 2):n
            q1 <- min(j * p[i2]/(2:j))
            q[ij] <- pmin(j * p[ij], q1)
            q[i2] <- q[n - j + 1]
            pa <- pmax(pa, q)
        }
*/
		for (unsigned j = (NO_OF_ARRAY_ELEMENTS-1); j >= 2; j--) {
//			printf("j = %zu\n", j);
			unsigned int *restrict ij = seq_len(0,NO_OF_ARRAY_ELEMENTS - j);
			const size_t I2_LENGTH = j - 1;
			unsigned int *restrict i2 = malloc(I2_LENGTH * sizeof(unsigned int));
			for (unsigned i = 0; i < I2_LENGTH; i++) {
				i2[i] = NO_OF_ARRAY_ELEMENTS-j+2+i-1;
//R's indices are 1-based, C's are 0-based, I added the -1
			}

			double q1 = (double)j * p[i2[0]] / 2.0;
			for (unsigned int i = 1; i < I2_LENGTH; i++) {//loop through 2:j
				const double TEMP_Q1 = (double)j * p[i2[i]] / (double)(2 + i);
				if (TEMP_Q1 < q1) {
					q1 = TEMP_Q1;
				}
			}

			for (unsigned int i = 0; i < (NO_OF_ARRAY_ELEMENTS - j + 1); i++) {//q[ij] <- pmin(j * p[ij], q1)
				q[ij[i]] = min2( (double)j*p[ij[i]], q1);
			}
			free(ij); ij = NULL;

			for (unsigned int i = 0; i < I2_LENGTH; i++) {//q[i2] <- q[n - j + 1]
				q[i2[i]] = q[NO_OF_ARRAY_ELEMENTS - j];//subtract 1 because of starting index difference
			}
			free(i2); i2 = NULL;

			for (unsigned int i = 0; i < NO_OF_ARRAY_ELEMENTS; i++) {//pa <- pmax(pa, q)
				if (pa[i] < q[i]) {
					pa[i] = q[i];
				}
			}
//			printf("j = %zu, pa = \n", j);
//				double_say(pa, N);
		}//end j loop
		free(p); p = NULL;
		for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
			q[index] = pa[ro[index]];//Hommel q-values
		}
//now free memory
		free(ro); ro = NULL;
		free(pa); pa = NULL;
		return q;
	}
//The methods are similarly computed and thus can be combined for clarity
	unsigned int *restrict o = order(PVALUES, NO_OF_ARRAY_ELEMENTS, true);
	if (o == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
	}
	double *restrict o_double = uint2double(o, NO_OF_ARRAY_ELEMENTS);
	for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
		if ((PVALUES[index] < 0) || (PVALUES[index] > 1)) {
			printf("array[%u] = %lf, which is outside the interval [0,1]\n", index, PVALUES[index]);
			printf("died at %s line %u\n", __FILE__, __LINE__);
			exit(EXIT_FAILURE);
		}
	}

	unsigned int *restrict ro = order(o_double, NO_OF_ARRAY_ELEMENTS, false);
	if (ro == NULL) {
			printf("failed to malloc at %s line %u.\n", __FILE__, __LINE__);
			perror("");
			exit(EXIT_FAILURE);
	}
	free(o_double); o_double = NULL;
	double *restrict cummin_input = malloc(sizeof(double) * NO_OF_ARRAY_ELEMENTS);
	if (TYPE == 0) {//BH method
		for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
			const double NI = (double)NO_OF_ARRAY_ELEMENTS / (double)(NO_OF_ARRAY_ELEMENTS - index);// n/i simplified
			cummin_input[index] = NI * PVALUES[o[index]];//PVALUES[o[index]] is p[o]
		}
	} else if (TYPE == 1) {//BY method
		double q = 1.0;
		for (unsigned int index = 2; index < (1+NO_OF_ARRAY_ELEMENTS); index++) {
			q +=  1.0/(double)index;
		}
		for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
			const double NI = (double)NO_OF_ARRAY_ELEMENTS / (double)(NO_OF_ARRAY_ELEMENTS - index);// n/i simplified
			cummin_input[index] = q * NI * PVALUES[o[index]];//PVALUES[o[index]] is p[o]
		}
	} else if (TYPE == 3) {//Hochberg method
		for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
// pmin(1, cummin((n - i + 1L) * p[o]))[ro]
			cummin_input[index] = (double)(index + 1) * PVALUES[o[index]];
		}
	}
	free(o); o = NULL;
	double *restrict cummin_array = NULL;
	cummin_array = cummin(cummin_input, NO_OF_ARRAY_ELEMENTS);
	free(cummin_input); cummin_input = NULL;//I don't need this anymore
	double *restrict pmin = pminx(cummin_array, NO_OF_ARRAY_ELEMENTS, 1);
	free(cummin_array); cummin_array = NULL;
	double *restrict q_array = malloc(NO_OF_ARRAY_ELEMENTS*sizeof(double));
	for (unsigned int index = 0; index < NO_OF_ARRAY_ELEMENTS; index++) {
		q_array[index] = pmin[ro[index]];
	}

	free(ro); ro = NULL;
	free(pmin); pmin = NULL;
	return q_array;
}


int main(void) {
	const double PVALUES[] = {4.533744e-01, 7.296024e-01, 9.936026e-02, 9.079658e-02, 1.801962e-01,
8.752257e-01, 2.922222e-01, 9.115421e-01, 4.355806e-01, 5.324867e-01,
4.926798e-01, 5.802978e-01, 3.485442e-01, 7.883130e-01, 2.729308e-01,
8.502518e-01, 4.268138e-01, 6.442008e-01, 3.030266e-01, 5.001555e-02,
3.194810e-01, 7.892933e-01, 9.991834e-01, 1.745691e-01, 9.037516e-01,
1.198578e-01, 3.966083e-01, 1.403837e-02, 7.328671e-01, 6.793476e-02,
4.040730e-03, 3.033349e-04, 1.125147e-02, 2.375072e-02, 5.818542e-04,
3.075482e-04, 8.251272e-03, 1.356534e-03, 1.360696e-02, 3.764588e-04,
1.801145e-05, 2.504456e-07, 3.310253e-02, 9.427839e-03, 8.791153e-04,
2.177831e-04, 9.693054e-04, 6.610250e-05, 2.900813e-02, 5.735490e-03};//just the pvalues
	const double CORRECT_ANSWERS[6][50] = {//each first index is type
	{6.126681e-01, 8.521710e-01, 1.987205e-01, 1.891595e-01, 3.217789e-01,
9.301450e-01, 4.870370e-01, 9.301450e-01, 6.049731e-01, 6.826753e-01,
6.482629e-01, 7.253722e-01, 5.280973e-01, 8.769926e-01, 4.705703e-01,
9.241867e-01, 6.049731e-01, 7.856107e-01, 4.887526e-01, 1.136717e-01,
4.991891e-01, 8.769926e-01, 9.991834e-01, 3.217789e-01, 9.301450e-01,
2.304958e-01, 5.832475e-01, 3.899547e-02, 8.521710e-01, 1.476843e-01,
1.683638e-02, 2.562902e-03, 3.516084e-02, 6.250189e-02, 3.636589e-03,
2.562902e-03, 2.946883e-02, 6.166064e-03, 3.899547e-02, 2.688991e-03,
4.502862e-04, 1.252228e-05, 7.881555e-02, 3.142613e-02, 4.846527e-03,
2.562902e-03, 4.846527e-03, 1.101708e-03, 7.252032e-02, 2.205958e-02},//Benjamini-Hochberg
	{1.000000e+00, 1.000000e+00, 8.940844e-01, 8.510676e-01, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 5.114323e-01,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.754486e-01, 1.000000e+00, 6.644618e-01,
7.575031e-02, 1.153102e-02, 1.581959e-01, 2.812089e-01, 1.636176e-02,
1.153102e-02, 1.325863e-01, 2.774239e-02, 1.754486e-01, 1.209832e-02,
2.025930e-03, 5.634031e-05, 3.546073e-01, 1.413926e-01, 2.180552e-02,
1.153102e-02, 2.180552e-02, 4.956812e-03, 3.262838e-01, 9.925057e-02},//Benjamini & Yekutieli
	{1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 7.019185e-01, 1.000000e+00, 1.000000e+00,
2.020365e-01, 1.516674e-02, 5.625735e-01, 1.000000e+00, 2.909271e-02,
1.537741e-02, 4.125636e-01, 6.782670e-02, 6.803480e-01, 1.882294e-02,
9.005725e-04, 1.252228e-05, 1.000000e+00, 4.713920e-01, 4.395577e-02,
1.088915e-02, 4.846527e-02, 3.305125e-03, 1.000000e+00, 2.867745e-01},//Bonferroni
{9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
9.991834e-01, 9.991834e-01, 4.632662e-01, 9.991834e-01, 9.991834e-01,
1.575885e-01, 1.383967e-02, 3.938014e-01, 7.600230e-01, 2.501973e-02,
1.383967e-02, 3.052971e-01, 5.426136e-02, 4.626366e-01, 1.656419e-02,
8.825610e-04, 1.252228e-05, 9.930759e-01, 3.394022e-01, 3.692284e-02,
1.023581e-02, 3.974152e-02, 3.172920e-03, 8.992520e-01, 2.179486e-01},//Hochberg
	{1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
1.000000e+00, 1.000000e+00, 4.632662e-01, 1.000000e+00, 1.000000e+00,
1.575885e-01, 1.395341e-02, 3.938014e-01, 7.600230e-01, 2.501973e-02,
1.395341e-02, 3.052971e-01, 5.426136e-02, 4.626366e-01, 1.656419e-02,
8.825610e-04, 1.252228e-05, 9.930759e-01, 3.394022e-01, 3.692284e-02,
1.023581e-02, 3.974152e-02, 3.172920e-03, 8.992520e-01, 2.179486e-01},//Holm
{ 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.987624e-01, 9.991834e-01,
9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.595180e-01,
9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
9.991834e-01, 9.991834e-01, 4.351895e-01, 9.991834e-01, 9.766522e-01,
1.414256e-01, 1.304340e-02, 3.530937e-01, 6.887709e-01, 2.385602e-02,
1.322457e-02, 2.722920e-01, 5.426136e-02, 4.218158e-01, 1.581127e-02,
8.825610e-04, 1.252228e-05, 8.743649e-01, 3.016908e-01, 3.516461e-02,
9.582456e-03, 3.877222e-02, 3.172920e-03, 8.122276e-01, 1.950067e-01}//Hommel
	};
//the following loop checks each type with R's answers
	const char *restrict TYPES[] = {"bh", "by", "bonferroni", "hochberg", "holm", "hommel"};
	for (unsigned short int type = 0; type <= 5; type++) {
		double *restrict q = p_adjust(PVALUES, sizeof(PVALUES) / sizeof(*PVALUES), TYPES[type]);
		double error = fabs(q[0] - CORRECT_ANSWERS[type][0]);
//		printf("%e	-	%e	=	%g\n", q[0], CORRECT_ANSWERS[type][0], error);
	//	puts("p	q");
	//	printf("%g\t%g\n", pvalues[0], q[0]);
		for (unsigned int i = 1; i < sizeof(PVALUES) / sizeof(*PVALUES); i++) {
			const double this_error = fabs(q[i] - CORRECT_ANSWERS[type][i]);
//			printf("%e	-	%e	=	%g\n", q[i], CORRECT_ANSWERS[type][i], error);
			error += this_error;
		}
		double_say(q, sizeof(PVALUES) / sizeof(*PVALUES));
		free(q); q = NULL;
		printf("\ntype %u = '%s' has cumulative error of %g\n", type, TYPES[type], error);
	}
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100001248(void);
int64_t function_1000014b0(void);
int64_t function_10000168c(void);
int64_t function_100001734(void);
int64_t function_1000017dc(void);
int64_t function_100001934(void);
int64_t function_100001a8c(void);
int64_t function_100001be8(void);
int64_t function_100001cd4(void);
int64_t function_100001db0(void);
int64_t function_100001df8(void);
int64_t function_1000031b4(int64_t a1);
void function_1000031c0(int32_t status);
void function_1000031cc(int64_t * ptr);
int64_t * function_1000031d8(int32_t size);
int64_t * function_1000031e4(int64_t * dest, int64_t * src, int32_t n);
void function_1000031f0(char * s);
int32_t function_1000031fc(char * format, ...);
int32_t function_100003208(char * s);
void function_100003214(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003220(char * s1, char * s2);

// --------------------- Global Variables ---------------------

char * g1; // 0x10000326c
int64_t g2 = 0x3fdd04160f35fde9; // 0x1000034a0
int64_t g3 = 0x3fe39afa2199adbc; // 0x100003630
int64_t g4 = 0x100000cfeedfacf; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
void _perror(char * a1);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _strcasecmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100001248 - 0x1000014b0
int64_t function_100001248(void) {
    // 0x100001248
    int64_t v1; // 0x100001248
    uint32_t v2 = (int32_t)v1; // 0x100001254
    uint32_t v3 = (int32_t)v1; // 0x100001258
    int64_t result3; // 0x100001248
    if (v2 == v3) {
        int64_t * v4 = _malloc(4 * v2 + 4); // 0x100001294
        if (v4 == NULL) {
            // 0x1000012b0
            _printf("malloc failed at %s line %u\n", (char *)v1, (int32_t)v1);
            _perror((char *)&g1);
            _exit(1);
            // UNREACHABLE
        }
        int64_t result = (int64_t)v4; // 0x100001294
        if (v2 == 0) {
            // 0x1000014a0
            return result;
        }
        int64_t v5 = 0;
        int64_t v6 = v5 + 1;
        *(int32_t *)(4 * v5 + result) = (int32_t)v6;
        result3 = result;
        while (v6 != (v1 & 0xffffffff)) {
            // 0x100001308
            v5 = v6;
            v6 = v5 + 1;
            *(int32_t *)(4 * v5 + result) = (int32_t)v6;
            result3 = result;
        }
    } else {
        int32_t v7 = v2 < v3 ? v3 : v2;
        int32_t v8 = v2 < v3 ? v2 : v3;
        uint32_t v9 = v7 - v8; // 0x100001370
        int64_t * v10 = _malloc(4 * v9 + 4); // 0x100001388
        if (v10 == NULL) {
            // 0x1000013a4
            _printf("malloc failed at %s line %u\n", (char *)v1, (int32_t)v1);
            _perror((char *)&g1);
            _exit(1);
            // UNREACHABLE
        }
        int64_t result2 = (int64_t)v10; // 0x100001388
        if (v2 < v3) {
            // 0x1000013fc
            if (v9 == 0 == (v9 != 0)) {
                // 0x1000014a0
                return result2;
            }
            uint32_t v11 = 0;
            *(int32_t *)(4 * (int64_t)v11 + result2) = v11 + v8;
            int32_t v12 = v11 + 1; // 0x100001434
            result3 = result2;
            while (v12 >= v9 != v12 != v9) {
                // 0x100001414
                v11 = v12;
                *(int32_t *)(4 * (int64_t)v11 + result2) = v11 + v8;
                v12 = v11 + 1;
                result3 = result2;
            }
        } else {
            // 0x10000144c
            if (v9 == 0 == (v9 != 0)) {
                // 0x1000014a0
                return result2;
            }
            uint32_t v13 = 0;
            *(int32_t *)(4 * (int64_t)v13 + result2) = v7 - v13;
            int32_t v14 = v13 + 1; // 0x100001484
            result3 = result2;
            while (v14 >= v9 != v14 != v9) {
                // 0x100001464
                v13 = v14;
                *(int32_t *)(4 * (int64_t)v13 + result2) = v7 - v13;
                v14 = v13 + 1;
                result3 = result2;
            }
        }
    }
    // 0x1000014a0
    return result3;
}

// Address range: 0x1000014b0 - 0x10000168c
int64_t function_1000014b0(void) {
    // 0x1000014b0
    int64_t v1; // 0x1000014b0
    uint64_t v2 = v1;
    int32_t v3 = v1; // 0x1000014c0
    int64_t * v4 = _malloc(4 * v3); // 0x1000014d8
    if (v4 == NULL) {
        // 0x1000014f4
        _printf("failed to malloc at %s line %u.\n", (char *)v1, (int32_t)v2);
        _perror((char *)&g1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t * v5 = _malloc(8 * v3); // 0x10000153c
    g4 = (int64_t)v5;
    if (v5 == NULL) {
        // 0x10000155c
        _printf("failed to malloc at %s line %u.\n", (char *)v1, (int32_t)v2);
        _perror((char *)&g1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t result = (int64_t)v4; // 0x1000014d8
    if (v3 != 0) {
        // 0x1000015b4
        *v5 = *(int64_t *)v1;
        *(int32_t *)v4 = 0;
        int64_t v6 = v1 & 0xffffffff;
        if (v6 != 1) {
            int64_t v7 = 1;
            int64_t v8 = 8 * v7; // 0x1000015bc
            *(int64_t *)(v8 + g4) = *(int64_t *)(v8 + v1);
            *(int32_t *)(4 * v7 + result) = (int32_t)v7;
            int64_t v9 = v7 + 1;
            while (v9 != v6) {
                // 0x1000015b4
                v7 = v9;
                v8 = 8 * v7;
                *(int64_t *)(v8 + g4) = *(int64_t *)(v8 + v1);
                *(int32_t *)(4 * v7 + result) = (int32_t)v7;
                v9 = v7 + 1;
            }
        }
    }
    if (v2 % 2 == 0) {
        // 0x100001608
        _qsort(v4, v3, 4, (int32_t (*)(int64_t *, int64_t *))0x10000168c);
    } else {
        // 0x100001640
        _qsort(v4, v3, 4, (int32_t (*)(int64_t *, int64_t *))0x100001734);
    }
    // 0x100001664
    _free((int64_t *)g4);
    g4 = 0;
    return result;
}

// Address range: 0x10000168c - 0x100001734
int64_t function_10000168c(void) {
    // 0x10000168c
    int64_t v1; // 0x10000168c
    float64_t v2 = *(float64_t *)(g4 + (0x100000000 * v1 >> 29)); // 0x1000016bc
    float64_t v3 = *(float64_t *)(g4 + (0x100000000 * v1 >> 29)); // 0x1000016c8
    return v2 > v3 ? 0xffffffff : (int64_t)(v2 != v3);
}

// Address range: 0x100001734 - 0x1000017dc
int64_t function_100001734(void) {
    // 0x100001734
    int64_t v1; // 0x100001734
    float64_t v2 = *(float64_t *)(g4 + (0x100000000 * v1 >> 29)); // 0x100001764
    float64_t v3 = *(float64_t *)(g4 + (0x100000000 * v1 >> 29)); // 0x100001770
    return v2 > v3 ? 1 : v2 == v3 ? 0 : 0xffffffff;
}

// Address range: 0x1000017dc - 0x100001934
int64_t function_1000017dc(void) {
    // 0x1000017dc
    int64_t v1; // 0x1000017dc
    int32_t v2 = v1; // 0x1000017ec
    if (v2 == 0) {
        // 0x100001804
        _puts("cummin function requires at least one element.\n");
        _printf("Failed at %s line %u\n", (char *)v1, (int32_t)v1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t * v3 = _malloc(8 * v2); // 0x10000184c
    if (v3 == NULL) {
        // 0x100001868
        _printf("failed to malloc at %s line %u.\n", (char *)v1, (int32_t)v1);
        _perror((char *)&g1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t result = (int64_t)v3; // 0x10000184c
    float64_t v4 = v1; // bp-48, 0x1000018a8
    int64_t v5 = 0;
    int64_t v6 = 8 * v5; // 0x1000018d4
    int64_t v7 = v6 + v1; // 0x1000018d4
    int64_t v8; // 0x1000017dc
    int64_t v9 = v8; // 0x1000018dc
    if (*(float64_t *)v7 > (float64_t)v1) {
        // 0x1000018ec
        v9 = *(int64_t *)v7;
        v4 = v9;
    }
    // 0x100001900
    *(int64_t *)(v6 + result) = v9;
    v5++;
    while (v5 != (v1 & 0xffffffff)) {
        // 0x100001900
        v6 = 8 * v5;
        v7 = v6 + v1;
        v9 = v4;
        if (*(float64_t *)v7 > v4) {
            // 0x1000018ec
            v9 = *(int64_t *)v7;
            v4 = v9;
        }
        // 0x100001900
        *(int64_t *)(v6 + result) = v9;
        v5++;
    }
    // 0x100001924
    return result;
}

// Address range: 0x100001934 - 0x100001a8c
int64_t function_100001934(void) {
    // 0x100001934
    int64_t v1; // 0x100001934
    int32_t v2 = v1; // 0x100001944
    if (v2 == 0) {
        // 0x10000195c
        _puts("function requires at least one element.\n");
        _printf("Failed at %s line %u\n", (char *)v1, (int32_t)v1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t * v3 = _malloc(8 * v2); // 0x1000019a4
    if (v3 == NULL) {
        // 0x1000019c0
        _printf("failed to malloc at %s line %u.\n", (char *)v1, (int32_t)v1);
        _perror((char *)&g1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t result = (int64_t)v3; // 0x1000019a4
    float64_t v4 = v1; // bp-48, 0x100001a00
    int64_t v5 = 0;
    float64_t v6 = v1; // 0x100001a30
    int64_t v7 = 8 * v5; // 0x100001a2c
    int64_t v8 = v7 + v1; // 0x100001a2c
    float64_t v9 = *(float64_t *)v8; // 0x100001a2c
    int64_t v10; // 0x100001934
    int64_t v11 = v10; // 0x100001a34
    int64_t v12; // 0x100001934
    if (v9 != v6) {
        v11 = v10;
        if (v9 > v6 == v9 >= v6 == v9 <= v6) {
            // 0x100001a44
            v12 = *(int64_t *)v8;
            v4 = v12;
            v11 = v12;
        }
    }
    // 0x100001a58
    *(int64_t *)(v7 + result) = v11;
    v5++;
    while (v5 != (v1 & 0xffffffff)) {
        // 0x100001a58
        v6 = v4;
        int64_t v13 = v4;
        v7 = 8 * v5;
        v8 = v7 + v1;
        v9 = *(float64_t *)v8;
        v11 = v13;
        if (v9 != v6) {
            v11 = v13;
            if (v9 > v6 == v9 >= v6 == v9 <= v6) {
                // 0x100001a44
                v12 = *(int64_t *)v8;
                v4 = v12;
                v11 = v12;
            }
        }
        // 0x100001a58
        *(int64_t *)(v7 + result) = v11;
        v5++;
    }
    // 0x100001a7c
    return result;
}

// Address range: 0x100001a8c - 0x100001be8
int64_t function_100001a8c(void) {
    // 0x100001a8c
    int64_t v1; // 0x100001a8c
    int32_t v2 = v1; // 0x100001a9c
    if (v2 == 0) {
        // 0x100001ab8
        _puts("pmin requires at least one element.\n");
        _printf("Failed at %s line %u\n", (char *)v1, (int32_t)v1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t * v3 = _malloc(8 * v2); // 0x100001b00
    if (v3 == NULL) {
        // 0x100001b1c
        _printf("failed to malloc at %s line %u.\n", (char *)v1, (int32_t)v1);
        _perror((char *)&g1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t result = (int64_t)v3; // 0x100001b00
    int64_t v4 = 0;
    int64_t v5 = 8 * v4; // 0x100001b7c
    int64_t v6 = v5 + v1; // 0x100001b7c
    float64_t v7; // 0x100001a8c
    if (*(float64_t *)v6 > v7) {
        // 0x100001b94
        *(int64_t *)(v5 + result) = *(int64_t *)v6;
    } else {
        // 0x100001bb0
        float64_t v8; // 0x100001a8c
        *(int64_t *)(v5 + result) = (int64_t)v8;
    }
    // 0x100001bc8
    v4++;
    while (v4 != (v1 & 0xffffffff)) {
        // 0x100001bc8
        v5 = 8 * v4;
        v6 = v5 + v1;
        float64_t v9; // bp-40, 0x100001a8c
        if (*(float64_t *)v6 > v9) {
            // 0x100001b94
            *(int64_t *)(v5 + result) = *(int64_t *)v6;
        } else {
            // 0x100001bb0
            *(int64_t *)(v5 + result) = (int64_t)v9;
        }
        // 0x100001bc8
        v4++;
    }
    // 0x100001bd8
    return result;
}

// Address range: 0x100001be8 - 0x100001cd4
int64_t function_100001be8(void) {
    // 0x100001be8
    int64_t v1; // 0x100001be8
    uint64_t v2 = v1;
    int128_t v3; // 0x100001be8
    _printf("[1] %e", (float64_t)(int64_t)v3);
    if (v2 <= 1) {
        // 0x100001cbc
        return _puts("\n");
    }
    uint32_t v4 = 1; // 0x100001c60
    _printf(" %.10f", (float64_t)(int64_t)v3);
    v4++;
    if (v4 % 5 == 0) {
        // 0x100001c84
        _printf("\n[%u]", (int32_t)v2);
    }
    while (v2 > (int64_t)v4) {
        // 0x100001c3c
        _printf(" %.10f", (float64_t)(int64_t)v3);
        v4++;
        if (v4 % 5 == 0) {
            // 0x100001c84
            _printf("\n[%u]", (int32_t)v2);
        }
    }
    // 0x100001cbc
    return _puts("\n");
}

// Address range: 0x100001cd4 - 0x100001db0
int64_t function_100001cd4(void) {
    // 0x100001cd4
    int64_t v1; // 0x100001cd4
    int32_t v2 = v1; // 0x100001ce4
    int64_t * v3 = _malloc(8 * v2); // 0x100001cf8
    if (v3 == NULL) {
        // 0x100001d14
        _printf("Failure to malloc at %s line %u.\n", (char *)v1, (int32_t)v1);
        _perror((char *)&g1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t result = (int64_t)v3; // 0x100001cf8
    if (v2 == 0) {
        // 0x100001da0
        return result;
    }
    // 0x100001d6c
    float64_t v4; // 0x100001cd4
    *v3 = (int64_t)v4;
    int64_t v5 = v1 & 0xffffffff;
    if (v5 == 1) {
        // 0x100001da0
        return result;
    }
    int64_t v6 = 1; // 0x100001d64
    *(int64_t *)(8 * v6 + result) = (int64_t)v4;
    v6++;
    while (v6 != v5) {
        // 0x100001d6c
        float64_t v7; // 0x100001cd4
        *(int64_t *)(8 * v6 + result) = (int64_t)v7;
        v6++;
    }
    // 0x100001da0
    return result;
}

// Address range: 0x100001db0 - 0x100001df8
int64_t function_100001db0(void) {
    // 0x100001db0
    int64_t result; // 0x100001db0
    return result;
}

// Address range: 0x100001df8 - 0x100002fe4
int64_t function_100001df8(void) {
    // 0x100001df8
    int64_t v1; // 0x100001df8
    int32_t v2 = v1; // 0x100001e14
    if (v2 == 0) {
        // 0x100001e30
        _puts("p_adjust requires at least one element.\n");
        _printf("Failed at %s line %u\n", (char *)v1, (int32_t)v1);
        _exit(1);
        // UNREACHABLE
    }
    uint64_t v3 = v1 & 0xffffffff;
    int64_t v4; // bp-312, 0x100001df8
    int64_t v5 = &v4; // 0x100001e68
    int64_t * v6 = (int64_t *)(v5 + 248); // 0x100001e74
    int64_t v7 = *v6; // 0x100001e74
    int32_t v8 = 0; // 0x100001e80
    int64_t result3; // 0x100001df8
    float64_t v9; // 0x100001df8
    int64_t v10; // 0x100001df8
    int128_t v11; // 0x100001df8
    if (v7 != 0) {
        // 0x100001e90
        v8 = 0;
        if (_strcasecmp((char *)v7, "BH") != 0) {
            // 0x100001ebc
            v8 = 0;
            if (_strcasecmp((char *)*v6, "fdr") != 0) {
                // 0x100001ee8
                v8 = 1;
                if (_strcasecmp((char *)*v6, "by") != 0) {
                    // 0x100001f18
                    if (_strcasecmp((char *)*v6, "Bonferroni") == 0) {
                        int64_t * v12 = _malloc(8 * v2); // 0x100002060
                        int64_t * v13 = (int64_t *)(v5 + 232); // 0x100002068
                        *v13 = (int64_t)v12;
                        if (v12 == NULL) {
                            // 0x100002080
                            _printf("failed to malloc at %s line %u.\n", "Bonferroni", (int32_t)v1);
                            _perror((char *)&g1);
                            _exit(1);
                            // UNREACHABLE
                        }
                        int64_t v14 = v5 + 216; // 0x1000020f8
                        v10 = 0;
                        while (true) {
                          lab_0x1000020d8:;
                            int64_t v15 = 8 * v10; // 0x1000020e4
                            float64_t v16 = v9 * *(float64_t *)(*(int64_t *)(v5 + 264) + v15); // 0x1000020f4
                            *(float64_t *)v14 = v16;
                            if (v16 == 1.0) {
                                // 0x100002114
                                *(float64_t *)(*v13 + v15) = 1.0;
                                goto lab_0x1000021cc;
                            } else {
                                if (v16 > 1.0 == v16 >= 1.0 == v16 <= 1.0) {
                                    int64_t v17 = *v13; // 0x100002118
                                    *(float64_t *)(v17 + v15) = 1.0;
                                    goto lab_0x1000021cc;
                                } else {
                                    if (v16 > 1.0 != v16 >= 0.0 != v16 != 0.0) {
                                        // 0x10000217c
                                        _printf("%g is outside of the interval I planned.\n", (float64_t)(int64_t)v11);
                                        _printf("Failure at %s line %u\n", "Bonferroni", (int32_t)v1);
                                        _exit(1);
                                        // UNREACHABLE
                                    }
                                    // 0x100002164
                                    *(int64_t *)(*v13 + v15) = *(int64_t *)v14;
                                    goto lab_0x1000021cc;
                                }
                            }
                        }
                      lab_0x1000021dc:;
                        int64_t result = *v13;
                        *(int64_t *)(v5 + 272) = result;
                        // 0x100002fcc
                        return result;
                    }
                    // 0x100001f48
                    v8 = 3;
                    if (_strcasecmp((char *)*v6, "hochberg") != 0) {
                        // 0x100001f78
                        if (_strcasecmp((char *)*v6, "holm") == 0) {
                            int64_t v18 = function_1000014b0(); // 0x100002214
                            int64_t * v19 = (int64_t *)(v5 + 208); // 0x10000221c
                            *v19 = v18;
                            int64_t v20 = function_100001cd4(); // 0x100002228
                            int64_t * v21 = (int64_t *)(v5 + 200); // 0x100002230
                            *v21 = v20;
                            int32_t v22 = 8 * v2; // 0x100002244
                            int64_t v23 = (int64_t)_malloc(v22); // 0x100002244
                            int64_t * v24 = (int64_t *)(v5 + 192); // 0x10000224c
                            *v24 = v23;
                            int64_t v25 = 0;
                            uint32_t v26 = *(int32_t *)(*v19 + 4 * v25); // 0x100002290
                            float64_t v27 = *(float64_t *)(8 * (int64_t)v26 + *(int64_t *)(v5 + 264)); // 0x100002294
                            *(float64_t *)(8 * v25 + v23) = v27 * (float64_t)(v2 - (int32_t)v25);
                            int64_t v28 = v25 + 1;
                            while (v28 != v3) {
                                int64_t v29 = *v24; // 0x100001df8
                                v25 = v28;
                                v26 = *(int32_t *)(*v19 + 4 * v25);
                                v27 = *(float64_t *)(8 * (int64_t)v26 + *(int64_t *)(v5 + 264));
                                *(float64_t *)(8 * v25 + v29) = v27 * (float64_t)(v2 - (int32_t)v25);
                                v28 = v25 + 1;
                            }
                            // 0x100002384
                            _free((int64_t *)*v19);
                            *v19 = 0;
                            int64_t v30 = function_1000014b0(); // 0x1000022e0
                            int64_t * v31 = (int64_t *)(v5 + 176); // 0x1000022e8
                            *v31 = v30;
                            _free((int64_t *)*v21);
                            *v21 = 0;
                            int64_t v32 = function_100001934(); // 0x100002304
                            int64_t * v33 = (int64_t *)(v5 + 168); // 0x10000230c
                            *v33 = v32;
                            _free((int64_t *)*v24);
                            *v24 = 0;
                            int64_t v34 = function_100001a8c(); // 0x10000232c
                            int64_t * v35 = (int64_t *)(v5 + 160); // 0x100002334
                            *v35 = v34;
                            _free((int64_t *)*v33);
                            *v33 = 0;
                            int64_t * v36 = _malloc(v22); // 0x100002358
                            int64_t * v37 = (int64_t *)(v5 + 152); // 0x100002360
                            *v37 = (int64_t)v36;
                            *v36 = *(int64_t *)(8 * (int64_t)*(int32_t *)*v31 + *v35);
                            int64_t v38 = *v35;
                            int64_t v39 = 1; // 0x10000237c
                            int64_t v40 = v38; // 0x10000237c
                            if (v3 != 1) {
                                uint32_t v41 = *(int32_t *)(*v31 + 4 * v39); // 0x100002394
                                int64_t v42 = *(int64_t *)(8 * (int64_t)v41 + v38);
                                *(int64_t *)(8 * v39 + *v37) = v42;
                                int64_t v43 = v39 + 1;
                                int64_t v44 = *v35;
                                v39 = v43;
                                v40 = v44;
                                while (v43 != v3) {
                                    // 0x100002384
                                    v41 = *(int32_t *)(*v31 + 4 * v39);
                                    v42 = *(int64_t *)(8 * (int64_t)v41 + v44);
                                    *(int64_t *)(8 * v39 + *v37) = v42;
                                    v43 = v39 + 1;
                                    v44 = *v35;
                                    v39 = v43;
                                    v40 = v44;
                                }
                            }
                            // 0x1000023bc
                            _free((int64_t *)v40);
                            *v35 = 0;
                            _free((int64_t *)*v31);
                            *v31 = 0;
                            int64_t result2 = *v37; // 0x1000023e0
                            *(int64_t *)(v5 + 272) = result2;
                            // 0x100002fcc
                            return result2;
                        }
                        // 0x100001fa8
                        if (_strcasecmp((char *)*v6, "hommel") != 0) {
                            // 0x100001fd8
                            _printf("%s doesn't match any accepted FDR methods.\n", "hommel");
                            _printf("Failed at %s line %u\n", "hommel", (int32_t)v1);
                            _exit(1);
                            // UNREACHABLE
                        }
                        int64_t v45 = function_1000014b0(); // 0x100002414
                        int64_t * v46 = (int64_t *)(v5 + 136); // 0x10000241c
                        *v46 = v45;
                        int32_t v47 = 8 * v2; // 0x100002430
                        int64_t * v48 = _malloc(v47); // 0x100002430
                        int64_t * v49 = (int64_t *)(v5 + 128); // 0x100002438
                        *v49 = (int64_t)v48;
                        if (v48 == NULL) {
                            // 0x100002450
                            _printf("failed to malloc at %s line %u.\n", (char *)v3, 0);
                            _perror((char *)&g1);
                            _exit(1);
                            // UNREACHABLE
                        }
                        int64_t v50 = 0;
                        uint32_t v51 = *(int32_t *)(*v46 + 4 * v50); // 0x1000024b8
                        int64_t v52 = *(int64_t *)(8 * (int64_t)v51 + *(int64_t *)(v5 + 264));
                        float64_t v53 = v52;
                        *(int64_t *)(*v49 + 8 * v50) = v52;
                        v50++;
                        while (v50 != v3) {
                            // 0x1000024a8
                            v51 = *(int32_t *)(*v46 + 4 * v50);
                            v52 = *(int64_t *)(8 * (int64_t)v51 + *(int64_t *)(v5 + 264));
                            v53 = v52;
                            *(int64_t *)(*v49 + 8 * v50) = v52;
                            v50++;
                        }
                        int64_t v54 = function_100001cd4(); // 0x1000024ec
                        int64_t * v55 = (int64_t *)(v5 + 112); // 0x1000024f4
                        *v55 = v54;
                        _free((int64_t *)*v46);
                        *v46 = 0;
                        int64_t v56 = function_1000014b0(); // 0x100002518
                        int64_t * v57 = (int64_t *)(v5 + 104); // 0x100002520
                        *v57 = v56;
                        _free((int64_t *)*v55);
                        *v55 = 0;
                        int64_t * v58 = _malloc(v47); // 0x100002544
                        int64_t * v59 = (int64_t *)(v5 + 96); // 0x10000254c
                        *v59 = (int64_t)v58;
                        if (v58 == NULL) {
                            // 0x100002564
                            _printf("failed to malloc at %s line %u.\n", (char *)v3, 0);
                            _perror((char *)&g1);
                            _exit(1);
                            // UNREACHABLE
                        }
                        int64_t * v60 = _malloc(v47); // 0x1000025ac
                        int64_t * v61 = (int64_t *)(v5 + 88); // 0x1000025b4
                        *v61 = (int64_t)v60;
                        if (v60 == NULL) {
                            // 0x1000025cc
                            _printf("failed to malloc at %s line %u.\n", (char *)v3, 0);
                            _perror((char *)&g1);
                            _exit(1);
                            // UNREACHABLE
                        }
                        float64_t v62 = v53 * *(float64_t *)*v49; // 0x10000261c
                        int64_t v63 = v5 + 80; // 0x100002620
                        float64_t * v64 = (float64_t *)v63; // 0x100002620
                        *v64 = v62;
                        int64_t * v65; // 0x100001df8
                        if (v2 > 1) {
                            int64_t v66 = v5 + 64; // 0x100002678
                            int64_t * v67 = (int64_t *)v63;
                            int64_t v68 = 1;
                            float64_t v69 = *(float64_t *)(*v49 + 8 * v68); // 0x100002660
                            v68++;
                            float64_t v70 = v62 * v69 / (float64_t)(int32_t)v68; // 0x100002674
                            *(float64_t *)v66 = v70;
                            v53 = v70;
                            int64_t v71; // 0x100001df8
                            if (v70 > *v64) {
                                // 0x100002694
                                v71 = *(int64_t *)v66;
                                v53 = v71;
                                *v67 = v71;
                            }
                            // 0x1000026a8
                            v65 = v67;
                            while (v68 != v3) {
                                // 0x100002648
                                v69 = *(float64_t *)(*v49 + 8 * v68);
                                v68++;
                                v70 = v53 * v69 / (float64_t)(int32_t)v68;
                                *(float64_t *)v66 = v70;
                                v53 = v70;
                                if (v70 > *v64) {
                                    // 0x100002694
                                    v71 = *(int64_t *)v66;
                                    v53 = v71;
                                    *v67 = v71;
                                }
                                // 0x1000026a8
                                v65 = v67;
                            }
                        } else {
                            // 0x100002604
                            v65 = (int64_t *)v63;
                        }
                        int64_t v72 = 0;
                        int64_t v73 = 8 * v72; // 0x1000026e8
                        *(int64_t *)(*v61 + v73) = *v65;
                        int64_t v74 = *v65;
                        v53 = v74;
                        *(int64_t *)(*v59 + v73) = v74;
                        v72++;
                        while (v72 != v3) {
                            // 0x1000026d8
                            v73 = 8 * v72;
                            *(int64_t *)(*v61 + v73) = *v65;
                            v74 = *v65;
                            v53 = v74;
                            *(int64_t *)(*v59 + v73) = v74;
                            v72++;
                        }
                        uint32_t v75 = v2 - 1;
                        if (v75 >= 2) {
                            int64_t * v76 = (int64_t *)(v5 + 48);
                            int64_t * v77 = (int64_t *)(v5 + 40);
                            int64_t * v78 = (int64_t *)(v5 + 32);
                            int64_t v79 = v5 + 16;
                            float64_t * v80 = (float64_t *)v79;
                            uint32_t v81 = 2;
                            int64_t v82 = v75;
                            *v76 = function_100001248();
                            uint32_t v83 = v2 - 2; // 0x100002754
                            *v77 = (int64_t)v83;
                            int64_t v84 = (int64_t)_malloc(4 * v83); // 0x100002768
                            *v78 = v84;
                            int64_t v85 = v84; // 0x100002790
                            int64_t v86; // 0x100001df8
                            int32_t v87; // 0x1000027cc
                            int64_t v88; // 0x100002780
                            if (*v77 != 0) {
                                // 0x100002798
                                v87 = 0;
                                *(int32_t *)v84 = v2 + 1 - (int32_t)v82 + v87;
                                v87++;
                                v88 = v87;
                                v86 = *v78;
                                v85 = v86;
                                while (*v77 > v88) {
                                    // 0x100002798
                                    *(int32_t *)(4 * v88 + v86) = v2 + 1 - (int32_t)v82 + v87;
                                    v87++;
                                    v88 = v87;
                                    v86 = *v78;
                                    v85 = v86;
                                }
                            }
                            float64_t v89 = *(float64_t *)(8 * (int64_t)*(int32_t *)v85 + *v49); // 0x1000027f4
                            float64_t v90 = 0.5 * v53 * v89; // 0x100002800
                            v53 = v90;
                            *v80 = v90;
                            int32_t v91 = 1; // 0x100002828
                            uint32_t v92; // 0x10000284c
                            float64_t v93; // 0x100002850
                            float64_t v94; // 0x100002864
                            int32_t v95; // 0x10000289c
                            int64_t v96; // 0x100002818
                            if (*v77 > 1) {
                                v92 = *(int32_t *)(*v78 + 4);
                                v93 = *(float64_t *)(8 * (int64_t)v92 + *v49);
                                v94 = v53 * v93 / (float64_t)(v91 + 2);
                                v4 = v94;
                                v53 = v94;
                                if (v94 > *v80) {
                                    // 0x100002884
                                    v53 = v94;
                                    *(int64_t *)v79 = (int64_t)v94;
                                }
                                // 0x100002898
                                v95 = v91 + 1;
                                v96 = v95;
                                v91 = v95;
                                while (*v77 > v96) {
                                    // 0x100002830
                                    v92 = *(int32_t *)(*v78 + 4 * v96);
                                    v93 = *(float64_t *)(8 * (int64_t)v92 + *v49);
                                    v94 = v53 * v93 / (float64_t)(v91 + 2);
                                    v4 = v94;
                                    v53 = v94;
                                    if (v94 > *v80) {
                                        // 0x100002884
                                        v53 = v94;
                                        *(int64_t *)v79 = (int64_t)v94;
                                    }
                                    // 0x100002898
                                    v95 = v91 + 1;
                                    v96 = v95;
                                    v91 = v95;
                                }
                            }
                            int32_t v97 = v2 - v75; // 0x1000028bc
                            int64_t v98; // 0x100001df8
                            int64_t v99; // 0x1000028f0
                            float64_t v100; // 0x1000028f4
                            float64_t v101; // 0x1000028f8
                            uint32_t v102; // 0x100002914
                            if (v97 != -1) {
                                // 0x1000028d4
                                v98 = 0;
                                v99 = 4 * v98;
                                v100 = *(float64_t *)(8 * (int64_t)*(int32_t *)(*v76 + v99) + *v49);
                                v101 = v53 * v100;
                                v53 = v101;
                                function_100001db0();
                                v102 = *(int32_t *)(*v76 + v99);
                                *(float64_t *)(8 * (int64_t)v102 + *v59) = v101;
                                v98++;
                                while (v98 != (int64_t)v81) {
                                    // 0x1000028d4
                                    v99 = 4 * v98;
                                    v100 = *(float64_t *)(8 * (int64_t)*(int32_t *)(*v76 + v99) + *v49);
                                    v101 = v53 * v100;
                                    v53 = v101;
                                    function_100001db0();
                                    v102 = *(int32_t *)(*v76 + v99);
                                    *(float64_t *)(8 * (int64_t)v102 + *v59) = v101;
                                    v98++;
                                }
                            }
                            // 0x100002930
                            _free((int64_t *)*v76);
                            *v76 = 0;
                            int64_t v103; // 0x100001df8
                            uint32_t v104; // 0x10000298c
                            int32_t v105; // 0x10000299c
                            int64_t v106; // 0x100002950
                            if (*v77 != 0) {
                                // 0x100002968
                                v105 = 0;
                                v103 = *(int64_t *)(*v59 + (int64_t)(8 * v97));
                                v104 = *(int32_t *)*v78;
                                *(int64_t *)(8 * (int64_t)v104 + *v59) = v103;
                                v105++;
                                v106 = v105;
                                while (*v77 > v106) {
                                    // 0x100002968
                                    v103 = *(int64_t *)(*v59 + (int64_t)(8 * v97));
                                    v104 = *(int32_t *)(*v78 + 4 * v106);
                                    *(int64_t *)(8 * (int64_t)v104 + *v59) = v103;
                                    v105++;
                                    v106 = v105;
                                }
                            }
                            // 0x1000029dc
                            _free((int64_t *)*v78);
                            *v78 = 0;
                            int64_t v107 = 0;
                            int64_t v108 = 8 * v107; // 0x1000029e8
                            float64_t v109 = *(float64_t *)(*v61 + v108); // 0x1000029e8
                            v53 = v109;
                            int64_t v110 = *v59 + v108; // 0x1000029f4
                            int64_t v111; // 0x100001df8
                            if (v109 > *(float64_t *)v110) {
                                // 0x100002a08
                                v111 = *(int64_t *)v110;
                                v53 = v111;
                                *(int64_t *)(*v61 + v108) = v111;
                            }
                            // 0x100002a2c
                            v107++;
                            while (v107 != v3) {
                                // 0x1000029dc
                                v108 = 8 * v107;
                                v109 = *(float64_t *)(*v61 + v108);
                                v53 = v109;
                                v110 = *v59 + v108;
                                if (v109 > *(float64_t *)v110) {
                                    // 0x100002a08
                                    v111 = *(int64_t *)v110;
                                    v53 = v111;
                                    *(int64_t *)(*v61 + v108) = v111;
                                }
                                // 0x100002a2c
                                v107++;
                            }
                            int32_t v112 = v82;
                            int32_t v113 = v81 + 1;
                            int64_t v114 = v82 - 1; // 0x10000272c
                            int32_t v115 = v112 - 1; // 0x10000272c
                            while (v113 != v2) {
                                // 0x100002734
                                v81 = v113;
                                v82 = v114;
                                *v76 = function_100001248();
                                v83 = v112 - 2;
                                *v77 = (int64_t)v83;
                                v84 = (int64_t)_malloc(4 * v83);
                                *v78 = v84;
                                v85 = v84;
                                if (*v77 != 0) {
                                    // 0x100002798
                                    v87 = 0;
                                    *(int32_t *)v84 = v2 + 1 - (int32_t)v82 + v87;
                                    v87++;
                                    v88 = v87;
                                    v86 = *v78;
                                    v85 = v86;
                                    while (*v77 > v88) {
                                        // 0x100002798
                                        *(int32_t *)(4 * v88 + v86) = v2 + 1 - (int32_t)v82 + v87;
                                        v87++;
                                        v88 = v87;
                                        v86 = *v78;
                                        v85 = v86;
                                    }
                                }
                                // 0x1000027d8
                                v89 = *(float64_t *)(8 * (int64_t)*(int32_t *)v85 + *v49);
                                v90 = 0.5 * v53 * v89;
                                v53 = v90;
                                *v80 = v90;
                                v91 = 1;
                                if (*v77 > 1) {
                                    v92 = *(int32_t *)(*v78 + 4);
                                    v93 = *(float64_t *)(8 * (int64_t)v92 + *v49);
                                    v94 = v53 * v93 / (float64_t)(v91 + 2);
                                    v4 = v94;
                                    v53 = v94;
                                    if (v94 > *v80) {
                                        // 0x100002884
                                        v53 = v94;
                                        *(int64_t *)v79 = (int64_t)v94;
                                    }
                                    // 0x100002898
                                    v95 = v91 + 1;
                                    v96 = v95;
                                    v91 = v95;
                                    while (*v77 > v96) {
                                        // 0x100002830
                                        v92 = *(int32_t *)(*v78 + 4 * v96);
                                        v93 = *(float64_t *)(8 * (int64_t)v92 + *v49);
                                        v94 = v53 * v93 / (float64_t)(v91 + 2);
                                        v4 = v94;
                                        v53 = v94;
                                        if (v94 > *v80) {
                                            // 0x100002884
                                            v53 = v94;
                                            *(int64_t *)v79 = (int64_t)v94;
                                        }
                                        // 0x100002898
                                        v95 = v91 + 1;
                                        v96 = v95;
                                        v91 = v95;
                                    }
                                }
                                // 0x1000028b0
                                v97 = v2 - v115;
                                if (v97 != -1) {
                                    // 0x1000028d4
                                    v98 = 0;
                                    v99 = 4 * v98;
                                    v100 = *(float64_t *)(8 * (int64_t)*(int32_t *)(*v76 + v99) + *v49);
                                    v101 = v53 * v100;
                                    v53 = v101;
                                    function_100001db0();
                                    v102 = *(int32_t *)(*v76 + v99);
                                    *(float64_t *)(8 * (int64_t)v102 + *v59) = v101;
                                    v98++;
                                    while (v98 != (int64_t)v81) {
                                        // 0x1000028d4
                                        v99 = 4 * v98;
                                        v100 = *(float64_t *)(8 * (int64_t)*(int32_t *)(*v76 + v99) + *v49);
                                        v101 = v53 * v100;
                                        v53 = v101;
                                        function_100001db0();
                                        v102 = *(int32_t *)(*v76 + v99);
                                        *(float64_t *)(8 * (int64_t)v102 + *v59) = v101;
                                        v98++;
                                    }
                                }
                                // 0x100002930
                                _free((int64_t *)*v76);
                                *v76 = 0;
                                if (*v77 != 0) {
                                    // 0x100002968
                                    v105 = 0;
                                    v103 = *(int64_t *)(*v59 + (int64_t)(8 * v97));
                                    v104 = *(int32_t *)*v78;
                                    *(int64_t *)(8 * (int64_t)v104 + *v59) = v103;
                                    v105++;
                                    v106 = v105;
                                    while (*v77 > v106) {
                                        // 0x100002968
                                        v103 = *(int64_t *)(*v59 + (int64_t)(8 * v97));
                                        v104 = *(int32_t *)(*v78 + 4 * v106);
                                        *(int64_t *)(8 * (int64_t)v104 + *v59) = v103;
                                        v105++;
                                        v106 = v105;
                                    }
                                }
                                // 0x1000029dc
                                _free((int64_t *)*v78);
                                *v78 = 0;
                                v107 = 0;
                                v108 = 8 * v107;
                                v109 = *(float64_t *)(*v61 + v108);
                                v53 = v109;
                                v110 = *v59 + v108;
                                if (v109 > *(float64_t *)v110) {
                                    // 0x100002a08
                                    v111 = *(int64_t *)v110;
                                    v53 = v111;
                                    *(int64_t *)(*v61 + v108) = v111;
                                }
                                // 0x100002a2c
                                v107++;
                                while (v107 != v3) {
                                    // 0x1000029dc
                                    v108 = 8 * v107;
                                    v109 = *(float64_t *)(*v61 + v108);
                                    v53 = v109;
                                    v110 = *v59 + v108;
                                    if (v109 > *(float64_t *)v110) {
                                        // 0x100002a08
                                        v111 = *(int64_t *)v110;
                                        v53 = v111;
                                        *(int64_t *)(*v61 + v108) = v111;
                                    }
                                    // 0x100002a2c
                                    v107++;
                                }
                                // 0x100002720
                                v112 = v82;
                                v113 = v81 + 1;
                                v114 = v82 - 1;
                                v115 = v112 - 1;
                            }
                        }
                        // 0x100002a84
                        _free((int64_t *)*v49);
                        *v49 = 0;
                        int64_t v116 = 0;
                        uint32_t v117 = *(int32_t *)(*v57 + 4 * v116); // 0x100002a94
                        int64_t v118 = *(int64_t *)(8 * (int64_t)v117 + *v61);
                        *(int64_t *)(*v59 + 8 * v116) = v118;
                        v116++;
                        while (v116 != v3) {
                            // 0x100002a84
                            v117 = *(int32_t *)(*v57 + 4 * v116);
                            v118 = *(int64_t *)(8 * (int64_t)v117 + *v61);
                            *(int64_t *)(*v59 + 8 * v116) = v118;
                            v116++;
                        }
                        // 0x100002abc
                        _free((int64_t *)*v57);
                        *v57 = 0;
                        _free((int64_t *)*v61);
                        *v61 = 0;
                        int64_t v119 = *v59; // 0x100002ae0
                        *(int64_t *)(v5 + 272) = v119;
                        result3 = v119;
                      lab_0x100002fcc:
                        // 0x100002fcc
                        return result3;
                    }
                }
            }
        }
    }
    int64_t v120 = function_1000014b0(); // 0x100002b08
    if (v120 == 0) {
        // 0x100002b24
        _printf("failed to malloc at %s line %u.\n", (char *)v3, 1);
        _perror((char *)&g1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t v121 = function_100001cd4(); // 0x100002b64
    int64_t * v122 = (int64_t *)(v5 + 264); // 0x100002b90
    int64_t v123 = 0;
    float64_t v124 = *(float64_t *)(*v122 + 8 * v123); // 0x100002b98
    float64_t v125; // 0x100001df8
    float64_t v126; // 0x100001df8
    int64_t v127; // 0x100001df8
    int64_t v128; // 0x100001df8
    float64_t v129; // 0x100001df8
    int32_t v130; // 0x100001df8
    int64_t v131; // 0x100002c50
    int32_t v132; // 0x100002cc0
    int64_t * v133; // 0x100002cc0
    int64_t v134; // 0x100002cc0
    uint32_t v135; // 0x100002d94
    while (v124 <= 0.0) {
        // 0x100002bac
        if (v124 != 1.0) {
            if (v124 > 1.0 == v124 >= 1.0 == v124 <= 1.0) {
                // break -> 0x100002bd0
                break;
            }
        }
        // 0x100002c30
        v123++;
        if (v123 >= v3) {
            // 0x100002c40
            v131 = function_1000014b0();
            if (v131 == 0) {
                // 0x100002c6c
                _printf("failed to malloc at %s line %u.\n", (char *)v3, 0);
                _perror((char *)&g1);
                _exit(1);
                // UNREACHABLE
            }
            // 0x100002ca4
            _free((int64_t *)v121);
            v132 = 8 * v2;
            v133 = _malloc(v132);
            v134 = (int64_t)v133;
            v125 = v124;
            v127 = 0;
            v128 = 0;
            switch (v8) {
                case 0: {
                    goto lab_0x100002cfc;
                }
                case 1: {
                    // 0x100002d78
                    v135 = v2 + 1;
                    v129 = 1.0;
                    v126 = 1.0;
                    v130 = 2;
                    if (v135 > 2) {
                        goto lab_0x100002da8;
                    } else {
                        goto lab_0x100002dfc;
                    }
                }
                case 3: {
                    goto lab_0x100002ea0;
                }
                default: {
                    goto lab_0x100002f70;
                }
            }
        }
        v124 = *(float64_t *)(*v122 + 8 * v123);
    }
    // 0x100002bd0
    _printf("array[%u] = %lf, which is outside the interval [0,1]\n", v2, (float64_t)(int64_t)v11);
    _printf("died at %s line %u\n", (char *)v3, 1);
    _exit(1);
    // UNREACHABLE
  lab_0x1000021cc:;
    int64_t v136 = v10 + 1;
    v10 = v136;
    v9 = 1.0;
    if (v136 >= v3) {
        // break -> 0x1000021dc
        goto lab_0x1000021dc;
    }
    goto lab_0x1000020d8;
  lab_0x100002cfc:;
    uint32_t v137 = *(int32_t *)(4 * v127 + v120); // 0x100002d34
    float64_t v138 = *(float64_t *)(8 * (int64_t)v137 + *v122); // 0x100002d38
    float64_t v139 = v125 / (float64_t)(v2 - (int32_t)v127) * v138; // 0x100002d3c
    *(float64_t *)(8 * v127 + v134) = v139;
    int64_t v140 = v127 + 1;
    if (v140 == v3) {
        goto lab_0x100002f70;
    } else {
        // 0x100002cfc
        v125 = v139;
        v127 = v140;
        goto lab_0x100002cfc;
    }
  lab_0x100002ea0:;
    int64_t v141 = v128 + 1;
    uint32_t v142 = *(int32_t *)(4 * v128 + v120); // 0x100002ebc
    float64_t v143 = *(float64_t *)(8 * (int64_t)v142 + *v122); // 0x100002ec0
    *(float64_t *)(8 * v128 + v134) = v143 * (float64_t)(int32_t)v141;
    v128 = v141;
    if (v141 == v3) {
        goto lab_0x100002f70;
    } else {
        goto lab_0x100002ea0;
    }
  lab_0x100002f70:
    // 0x100002f70
    _free((int64_t *)v120);
    int64_t v144 = function_1000017dc(); // 0x100002f0c
    _free(v133);
    int64_t v145 = function_100001a8c(); // 0x100002f2c
    _free((int64_t *)v144);
    int64_t v146 = (int64_t)_malloc(v132); // 0x100002f48
    int64_t v147 = 0; // 0x100001df8
    goto lab_0x100002f70_2;
  lab_0x100002f70_2:;
    uint32_t v148 = *(int32_t *)(4 * v147 + v131); // 0x100002f7c
    int64_t v149 = *(int64_t *)(8 * (int64_t)v148 + v145);
    *(int64_t *)(8 * v147 + v146) = v149;
    int64_t v150 = v147 + 1;
    v147 = v150;
    if (v150 == v3) {
        // 0x100002fa4
        _free((int64_t *)v131);
        _free((int64_t *)v145);
        *(int64_t *)(v5 + 272) = v146;
        result3 = v146;
        goto lab_0x100002fcc;
    } else {
        goto lab_0x100002f70_2;
    }
  lab_0x100002da8:;
    float64_t v151 = v126;
    float64_t v152 = v151 + 1.0 / v151; // 0x100002dc0
    int32_t v153 = v130 + 1; // 0x100002dd0
    v126 = v152;
    v130 = v153;
    if (v153 == v135) {
        // 0x100002d8c
        v129 = v152;
        goto lab_0x100002dfc;
    } else {
        goto lab_0x100002da8;
    }
  lab_0x100002dfc:;
    float64_t v154 = v129; // 0x100001df8
    int64_t v155 = 0; // 0x100001df8
    goto lab_0x100002dfc_2;
  lab_0x100002dfc_2:;
    uint32_t v156 = *(int32_t *)(4 * v155 + v120); // 0x100002e3c
    float64_t v157 = *(float64_t *)(8 * (int64_t)v156 + *v122); // 0x100002e40
    float64_t v158 = v157 * v129 * v154 / (float64_t)(v2 - (int32_t)v155); // 0x100002e44
    *(float64_t *)(8 * v155 + v134) = v158;
    int64_t v159 = v155 + 1;
    if (v159 == v3) {
        goto lab_0x100002f70;
    } else {
        // 0x100002dfc
        v154 = v158;
        v155 = v159;
        goto lab_0x100002dfc_2;
    }
}

// Address range: 0x100002fe4 - 0x1000031b4
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100002ffc
    int64_t v2; // bp-432, 0x100002fe4
    _memcpy(&v2, &g2, 400);
    int64_t v3; // bp-2832, 0x100002fe4
    _memcpy(&v3, &g3, 2400);
    int64_t v4; // bp-2880, 0x100002fe4
    _memcpy(&v4, (int64_t *)"d4", 48);
    int64_t v5 = &v4; // 0x100003068
    int32_t v6 = 0; // 0x100002fe4
    int64_t v7 = *(int64_t *)((int64_t)(8 * v6 & 0x7fff8) + v5); // 0x10000306c
    int64_t v8 = function_100001df8(); // 0x100003078
    int64_t v9 = (int64_t)(400 * (v6 % 0x10000)) + (int64_t)&v3; // 0x100003098
    __asm_fabd(*(float64_t *)v8, *(float64_t *)v9);
    int64_t v10; // 0x1000030cc
    for (int64_t i = 1; i < 50; i++) {
        // 0x1000030c4
        v10 = 8 * i;
        __asm_fabd(*(float64_t *)(v10 + v8), *(float64_t *)(v10 + v9));
    }
    // 0x100003118
    function_100001be8();
    _free((int64_t *)v8);
    int128_t v11; // 0x100002fe4
    int32_t v12 = _printf("\ntype %u = '%s' has cumulative error of %g\n", 50, (char *)v7, (float64_t)(int64_t)v11); // 0x100003164
    int32_t v13 = 0x10000 * v6 + 0x10000;
    v6 = v13 >> 16;
    while (v13 < 0x60000) {
        // 0x100003060
        v7 = *(int64_t *)((int64_t)(8 * v6 & 0x7fff8) + v5);
        v8 = function_100001df8();
        v9 = (int64_t)(400 * (v6 % 0x10000)) + (int64_t)&v3;
        __asm_fabd(*(float64_t *)v8, *(float64_t *)v9);
        for (int64_t i = 1; i < 50; i++) {
            // 0x1000030c4
            v10 = 8 * i;
            __asm_fabd(*(float64_t *)(v10 + v8), *(float64_t *)(v10 + v9));
        }
        // 0x100003118
        function_100001be8();
        _free((int64_t *)v8);
        v12 = _printf("\ntype %u = '%s' has cumulative error of %g\n", 50, (char *)v7, (float64_t)(int64_t)v11);
        v13 = 0x10000 * v6 + 0x10000;
        v6 = v13 >> 16;
    }
    // 0x10000317c
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x10000319c
        ___stack_chk_fail((int64_t)v12);
    }
    // 0x1000031a0
    return 0;
}

// Address range: 0x1000031b4 - 0x1000031c0
int64_t function_1000031b4(int64_t a1) {
    // 0x1000031b4
    return ___stack_chk_fail(a1);
}

// Address range: 0x1000031c0 - 0x1000031cc
void function_1000031c0(int32_t status) {
    // 0x1000031c0
    _exit(status);
}

// Address range: 0x1000031cc - 0x1000031d8
void function_1000031cc(int64_t * ptr) {
    // 0x1000031cc
    _free(ptr);
}

// Address range: 0x1000031d8 - 0x1000031e4
int64_t * function_1000031d8(int32_t size) {
    // 0x1000031d8
    return _malloc(size);
}

// Address range: 0x1000031e4 - 0x1000031f0
int64_t * function_1000031e4(int64_t * dest, int64_t * src, int32_t n) {
    // 0x1000031e4
    return _memcpy(dest, src, n);
}

// Address range: 0x1000031f0 - 0x1000031fc
void function_1000031f0(char * s) {
    // 0x1000031f0
    _perror(s);
}

// Address range: 0x1000031fc - 0x100003208
int32_t function_1000031fc(char * format, ...) {
    // 0x1000031fc
    return _printf(format);
}

// Address range: 0x100003208 - 0x100003214
int32_t function_100003208(char * s) {
    // 0x100003208
    return _puts(s);
}

// Address range: 0x100003214 - 0x100003220
void function_100003214(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003214
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003220 - 0x10000322c
int32_t function_100003220(char * s1, char * s2) {
    // 0x100003220
    return _strcasecmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 22

`
`#include <stdio.h>

int droot(long long int x, int base, int *pers)
{
	int d = 0;
	if (pers)
		for (*pers = 0; x >= base; x = d, (*pers)++)
			for (d = 0; x; d += x % base, x /= base);
	else if (x && !(d = x % (base - 1)))
			d = base - 1;

	return d;
}

int main(void)
{
	int i, d, pers;
	long long x[] = {627615, 39390, 588225, 393900588225LL};

	for (i = 0; i < 4; i++) {
		d = droot(x[i], 10, &pers);
		printf("%lld: pers %d, root %d\n", x[i], pers, d);
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d2c(void);
int64_t function_100003f50(void);
int32_t function_100003f5c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d2c - 0x100003e5c
int64_t function_100003d2c(void) {
    // 0x100003d2c
    int64_t v1; // 0x100003d2c
    int32_t v2 = v1; // 0x100003d30
    int32_t v3 = v1; // 0x100003d34
    if (v1 == 0) {
        int32_t result = 0; // 0x100003dfc
        if (v2 != 0) {
            int32_t v4 = (0x100000000 * v1 >> 32) % (0x100000000 * v1 - 0x100000000 >> 32); // 0x100003e28
            result = v4 == 0 ? v3 - 1 : v4;
        }
        // 0x100003e50
        return result;
    }
    int32_t * v5 = (int32_t *)v1; // 0x100003d38
    *v5 = 0;
    int64_t v6 = 0x100000000 * v1 >> 32; // 0x100003d60
    int64_t v7 = 0x100000000 * v1 >> 32; // 0x100003d64
    int64_t v8 = v6 - v7; // 0x100003d68
    if (v8 < 0 != ((v8 ^ v6) & 0x100000000 * (v1 ^ v1)) < 0) {
        // 0x100003e50
        return 0;
    }
    int32_t v9 = 0; // 0x100003d8c
    int32_t v10; // 0x100003d2c
    int64_t v11; // 0x100003d98
    int32_t v12; // 0x100003db4
    int32_t v13; // 0x100003dc4
    if (v2 != 0) {
        v11 = v2;
        v12 = v11 % v7;
        v13 = v11 / v7;
        v10 = v12;
        v9 = v12;
        while (v13 != 0) {
            // 0x100003d98
            v11 = v13;
            v12 = v10 + (int32_t)(v11 % v7);
            v13 = v11 / v7;
            v10 = v12;
            v9 = v12;
        }
    }
    int32_t result2 = v9;
    int64_t v14; // 0x100003d2c
    *v5 = *(int32_t *)&v14 + 1;
    int64_t v15 = result2; // 0x100003d60
    int64_t v16 = v15 - v7; // 0x100003d68
    while (v16 < 0 == ((v16 ^ v15) & (int64_t)(result2 ^ v3)) < 0) {
        int32_t v17 = result2; // 0x100003d8c
        v9 = 0;
        if (result2 != 0) {
            v11 = v17;
            v12 = v11 % v7;
            v13 = v11 / v7;
            v10 = v12;
            v9 = v12;
            while (v13 != 0) {
                // 0x100003d98
                v11 = v13;
                v12 = v10 + (int32_t)(v11 % v7);
                v13 = v11 / v7;
                v10 = v12;
                v9 = v12;
            }
        }
        // 0x100003dd0
        result2 = v9;
        *v5 = *(int32_t *)&v14 + 1;
        v15 = result2;
        v16 = v15 - v7;
    }
    // 0x100003e50
    return result2;
}

// Address range: 0x100003e5c - 0x100003f50
int64_t entry_point(void) {
    for (int32_t i = 0; i < 4; i++) {
        // 0x100003eb0
        function_100003d2c();
        int64_t v1; // bp-80, 0x100003e5c
        int64_t v2; // 0x100003e5c
        _printf("%lld: pers %d, root %d\n", 10, (int64_t)&v1, v2);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f28
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f3c
        ___stack_chk_fail();
    }
    // 0x100003f40
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t function_100003f50(void) {
    // 0x100003f50
    return ___stack_chk_fail();
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdlib.h>
#include <stdio.h>

#define STR_DEMO "one^|uno||three^^^^|four^^^|^cuatro|"
#define SEP '|'
#define ESC '^'

typedef char* Str; /* just for an easier reading */

/* ===> FUNCTION PROTOTYPES <================================================ */
unsigned int ElQ( const char *s, char sep, char esc );
Str *Tokenize( char *s, char sep, char esc, unsigned int *q );

/*==============================================================================
Main function.
Just passes a copy of the STR_DEMO string to the tokenization function and shows
the results.
==============================================================================*/

int main() {
    char s[] = STR_DEMO;
    unsigned int i, q;

    Str *list = Tokenize( s, SEP, ESC, &q );

    if( list != NULL ) {
        printf( "\n Original string: %s\n\n", STR_DEMO );
        printf( " %d tokens:\n\n", q );

        for( i=0; i<q; ++i )
            printf( " %4d. %s\n", i+1, list[i] );

        free( list );
    }

    return 0;
}

/*==============================================================================
"ElQ" stands for "Elements Quantity". Counts the amount of valid element in the
string s, according to the separator character provided in sep and the escape
character provided in esc.
==============================================================================*/

unsigned int ElQ( const char *s, char sep, char esc ) {
    unsigned int q, e;
    const char *p;

    for( e=0, q=1, p=s; *p; ++p ) {
        if( *p == esc )
            e = !e;
        else if( *p == sep )
            q += !e;
        else e = 0;
    }

    return q;
}

/*==============================================================================
The actual tokenization function.
Allocates as much dynamic memory as needed to contain the pointers to the
tokenized portions of the string passed as the "s" parameter, then looks for the
separators characters sep, paying attention to the occurrences of the escape
character provided in esc. When a valid separator is found, the function swaps
it with a '\0' terminator character and stores the pointer to the next string
into the array of pointers in dynamic memory. On output, the value of *q is the
number of pointers in the array. The caller is responsible for deallocating with
free() the returned array of pointers when it is no longer needed.
In case of failure, NULL is returned.
==============================================================================*/

Str *Tokenize( char *s, char sep, char esc, unsigned int *q ) {
    Str *list = NULL;

    *q = ElQ( s, sep, esc );
    list = malloc( *q * sizeof(Str) );

    if( list != NULL ) {
        unsigned int e, i;
        char *p;

        i = 0;
        list[i++] = s;

        for( e=0, p=s; *p; ++p ) {
            if( *p == esc ) {
                e = !e;
            }
            else if( *p == sep && !e ) {
                list[i++] = p+1;
                *p = '\0';
            }
            else {
                e = 0;
            }
        }
    }

    return list;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cc4(void);
int64_t function_100003e30(void);
int64_t function_100003f0c(void);
void function_100003f18(int64_t * ptr);
int64_t * function_100003f24(int32_t size);
int64_t * function_100003f30(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f3c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b84 - 0x100003cc4
int64_t entry_point(void) {
    // 0x100003b84
    int64_t v1; // bp-61, 0x100003b84
    _memcpy(&v1, (int64_t *)"one^|uno||three^^^^|four^^^|^cuatro|", 37);
    int64_t v2 = function_100003cc4(); // 0x100003bcc
    if (v2 != 0) {
        // 0x100003be8
        _printf("\n Original string: %s\n\n", (char *)124);
        _printf(" %d tokens:\n\n", 124);
        int32_t v3; // 0x100003b84
        if (v3 != 0) {
            _printf(" %4d. %s\n", 124, (char *)94);
            int32_t v4 = 1; // 0x100003c78
            int32_t v5 = v4; // 0x100003c38
            while (v4 != v3) {
                // 0x100003c40
                _printf(" %4d. %s\n", 124, (char *)94);
                v4 = v5 + 1;
                v5 = v4;
            }
        }
        // 0x100003c84
        _free((int64_t *)v2);
    }
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c9c
    if (v6 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003cb0
        ___stack_chk_fail();
    }
    // 0x100003cb4
    return 0;
}

// Address range: 0x100003cc4 - 0x100003e30
int64_t function_100003cc4(void) {
    // 0x100003cc4
    int64_t v1; // 0x100003cc4
    *(int32_t *)v1 = (int32_t)function_100003e30();
    int64_t v2; // 0x100003cc4
    int64_t * v3 = _malloc(8 * *(int32_t *)&v2); // 0x100003d08
    int64_t result = (int64_t)v3; // 0x100003d08
    if (v3 == NULL) {
        // 0x100003e20
        return result;
    }
    char * v4 = (char *)v1; // 0x100003cd0
    char v5 = *v4; // 0x100003d58
    if (v5 == 0) {
        // 0x100003e20
        return result;
    }
    int32_t v6 = 1;
    int32_t v7 = 0;
    int32_t v8 = v5; // 0x100003d70
    char * v9; // 0x100003cc4
    int32_t v10; // 0x100003cc4
    int32_t v11; // 0x100003cc4
    char * v12; // bp-64, 0x100003cc4
    if (0x1000000 * (int32_t)v1 >> 24 == v8) {
        // 0x100003d88
        v9 = v4;
        v11 = v6;
        v10 = v7 == 0;
    } else {
        // 0x100003da0
        v9 = v4;
        v11 = v6;
        v10 = 0;
        if (v7 == 0 == 0x1000000 * (int32_t)v1 >> 24 == v8) {
            // 0x100003dd0
            *(int64_t *)(8 * (int64_t)v6 + result) = (int64_t)v4 + 1;
            *v12 = 0;
            v9 = v12;
            v11 = v6 + 1;
            v10 = 0;
        }
    }
    char * v13 = (char *)((int64_t)v9 + 1); // 0x100003e14
    v12 = v13;
    char v14 = *v13; // 0x100003d58
    while (v14 != 0) {
        // 0x100003d6c
        v6 = v11;
        v7 = v10;
        char * v15 = v13;
        v8 = v14;
        if (0x1000000 * (int32_t)v1 >> 24 == v8) {
            // 0x100003d88
            v9 = v15;
            v11 = v6;
            v10 = v7 == 0;
        } else {
            // 0x100003da0
            v9 = v15;
            v11 = v6;
            v10 = 0;
            if (v7 == 0 == 0x1000000 * (int32_t)v1 >> 24 == v8) {
                // 0x100003dd0
                *(int64_t *)(8 * (int64_t)v6 + result) = (int64_t)v15 + 1;
                *v12 = 0;
                v9 = v12;
                v11 = v6 + 1;
                v10 = 0;
            }
        }
        // 0x100003e0c
        v13 = (char *)((int64_t)v9 + 1);
        v12 = v13;
        v14 = *v13;
    }
    // 0x100003e20
    return result;
}

// Address range: 0x100003e30 - 0x100003f0c
int64_t function_100003e30(void) {
    // 0x100003e30
    int64_t v1; // 0x100003e30
    char v2 = *(char *)v1; // 0x100003e5c
    if (v2 == 0) {
        // 0x100003f00
        return 1;
    }
    int32_t v3 = 0;
    int32_t v4 = 1;
    int32_t v5 = v2; // 0x100003e74
    int32_t v6; // 0x100003e30
    int32_t v7; // 0x100003e30
    if (0x1000000 * (int32_t)v1 >> 24 == v5) {
        // 0x100003e8c
        v7 = v3 == 0;
        v6 = v4;
    } else {
        // 0x100003ea4
        v7 = 0;
        v6 = v4;
        if (0x1000000 * (int32_t)v1 >> 24 == v5) {
            // 0x100003ec0
            v7 = v3;
            v6 = v4 + (int32_t)(v3 == 0);
        }
    }
    int32_t result = v6;
    int64_t v8; // 0x100003e30
    int64_t v9 = v8 + 1; // 0x100003ef4
    char v10 = *(char *)v9; // 0x100003e5c
    while (v10 != 0) {
        // 0x100003e70
        v3 = v7;
        v4 = result;
        v5 = v10;
        if (0x1000000 * (int32_t)v1 >> 24 == v5) {
            // 0x100003e8c
            v7 = v3 == 0;
            v6 = v4;
        } else {
            // 0x100003ea4
            v7 = 0;
            v6 = v4;
            if (0x1000000 * (int32_t)v1 >> 24 == v5) {
                // 0x100003ec0
                v7 = v3;
                v6 = v4 + (int32_t)(v3 == 0);
            }
        }
        // 0x100003ef0
        result = v6;
        v9++;
        v10 = *(char *)v9;
    }
    // 0x100003f00
    return result;
}

// Address range: 0x100003f0c - 0x100003f18
int64_t function_100003f0c(void) {
    // 0x100003f0c
    return ___stack_chk_fail();
}

// Address range: 0x100003f18 - 0x100003f24
void function_100003f18(int64_t * ptr) {
    // 0x100003f18
    _free(ptr);
}

// Address range: 0x100003f24 - 0x100003f30
int64_t * function_100003f24(int32_t size) {
    // 0x100003f24
    return _malloc(size);
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t * function_100003f30(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f30
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>

int main() {
  for (int i=1; i<=105; i++) if (i%3 && i%5) printf("%3d ", i); else printf("%s%s%s", i%3?"":"Fizz", i%5?"":"Buzz", i%15?" ":"\n");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f80(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e04 - 0x100003f80
int64_t entry_point(void) {
    int32_t v1 = 1;
    int64_t v2; // 0x100003e04
    if (v1 % 3 == 0 || v1 % 5 == 0) {
        // 0x100003e9c
        _printf("%s%s%s", (char *)v2, (char *)v2, (char *)v2);
    } else {
        // 0x100003e7c
        _printf("%3d ", v2);
    }
    int32_t v3 = v1 + 1; // 0x100003f64
    while (v1 == 104 || v1 < 104 != (103 - v1 & v3) < 0) {
        // 0x100003e34
        v1 = v3;
        if (v1 % 3 == 0 || v1 % 5 == 0) {
            // 0x100003e9c
            _printf("%s%s%s", (char *)v2, (char *)v2, (char *)v2);
        } else {
            // 0x100003e7c
            _printf("%3d ", v2);
        }
        // 0x100003f60
        v3 = v1 + 1;
    }
    // 0x100003f70
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`/**
 * @file
 * @brief Function to convert a Cartesian co-ordinate to polar form.
 */
#define _USE_MATH_DEFINES /**< required for MS Visual C */
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * @brief Function to convert cartesian coordinates to polar.
 *\f{eqnarray*}{
 r &=& \sqrt{x^2+y^2}\\
 \theta &=& \atan\frac{y}{x}
 \f}
 * @param [in] x absicca value
 * @param [in] y ordinate value
 * @param [out] r pointer to store polar radius
 * @param [out] theta pointer to store polar angle (in radian)
 */
void to_polar(double x, double y, double *r, double *theta)
{
    double thetaFinal = 0.f;

    *r = sqrt(x * x + y * y);

    if (x != 0)
    {
        if (y != 0)
        {
            *theta = atan(y / x);
            if ((x > 0 && y > 0) || (x == -y))
            {  // Q1
                thetaFinal = *theta;
            }
            else if (x < 0 && y > 0)
            {  // Q2
                thetaFinal = *theta + M_PI;
            }
            else if (x < 0 && y < 0)
            {  // Q3
                thetaFinal = *theta - M_PI;
            }
            else if (x > 0 && y < 0)
            {  // Q4
                thetaFinal = 2 * M_PI - *theta;
            }
            else
            {
                fprintf(stderr, "Should not reach here!\n");
            }
        }
    }
    else
    {  // exceptions when no actual angle is present
        if (y > 0)
        {
            thetaFinal = M_PI / 2;
        }
        else
        {
            thetaFinal = -(M_PI / 2);
        }
    }
    if (y == 0)
    {
        if (x > 0)
        {
            thetaFinal = 0;
        }
        else
        {
            thetaFinal = -M_PI;
        }
    }

    *theta = thetaFinal;
}

/**
 * @brief Generate a random number in the given limits
 *
 * @param lim1 lower limit
 * @param lim2 upper limit
 * @return random number in the given range
 */
double get_rand(double lim1, double lim2)
{
    double r = (double)rand() / RAND_MAX;  // value in [0,1)
    return (lim2 - lim1) * r + lim1;       // scale to range
}

/**
 * @brief Test implementation
 *
 */
void test()
{
    srand(10);
    int NUM_TESTS = 5;

    for (int i = 0; i < NUM_TESTS; i++)
    {
        double r, theta;
        printf("Test %d.... ", i);
        double x = get_rand(-5, 5);
        double y = get_rand(-5, 5);
        printf("(%.2g, %.2g).... ", x, y);
        to_polar(x, y, &r, &theta);
        assert(fabs(r - hypot(x, y)) < 0.01);
        assert(fabs(theta - atan2(y, x)) < 0.01);
        printf("passed\n");
    }
}

/** Main function */
int main()
{
    test();

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039d8(void);
int64_t function_100003c48(int64_t a1);
int64_t function_100003c98(void);
int64_t function_100003e78(char * a1, char * a2, int64_t a3, char * a4);
float64_t function_100003e84(float64_t a1);
float64_t function_100003e90(float64_t a1, float64_t a2);
int32_t function_100003e9c(struct _IO_FILE * stream, char * format, ...);
float64_t function_100003ea8(float64_t a1, float64_t a2);
int32_t function_100003eb4(char * format, ...);
int32_t function_100003ec0(void);
void function_100003ecc(int32_t seed);

// --------------------- Global Variables ---------------------

float64_t g1 = -3.1415926535897931; // 0x100003ed8
float64_t g2 = 3.1415926535897931; // 0x100003ee0
float64_t g3 = 6.2831853071795862; // 0x100003ee8
float64_t g4 = 1.5707963267948966; // 0x100003ef0
float64_t g5 = -1.5707963267948966; // 0x100003ef8
float64_t g6 = 0.01; // 0x100003f08

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
float64_t _atan(float64_t a1);
float64_t _atan2(float64_t a1, float64_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
float64_t _hypot(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000039d8 - 0x100003c48
int64_t function_1000039d8(void) {
    // 0x1000039d8
    int64_t v1; // 0x1000039d8
    int64_t v2 = v1;
    float64_t v3; // 0x1000039d8
    float64_t v4 = v3;
    float64_t v5 = v3;
    *(float64_t *)v1 = sqrt(v4 * v4 + v5 * v5);
    int64_t v6; // 0x1000039d8
    float64_t result2; // 0x100003a54
    int64_t result; // 0x1000039d8
    if (v5 == 0.0) {
        if (v4 != 0.0) {
            if (v4 > 0.0 == v4 >= 0.0 == v4 <= 0.0) {
                // 0x100003bc4
                v6 = g4;
            } else {
                // 0x100003be8
                v6 = g5;
            }
            // 0x100003c30
            *(int64_t *)v2 = v6;
            return result;
        }
        // .thread77
        goto lab_0x100003c1c;
    } else {
        if (v4 == 0.0) {
            if (v5 > 0.0 == v5 >= 0.0 == v5 <= 0.0) {
                // 0x100003c30
                *(int64_t *)v2 = 0;
                return result;
            }
            goto lab_0x100003c1c;
        } else {
            int128_t v7; // 0x1000039d8
            result2 = _atan((float64_t)(int64_t)v7);
            *(float64_t *)v2 = v4 / v5;
            if (v5 > 0.0 == v5 >= 0.0 == v5 <= 0.0) {
                if (v4 > 0.0 == v4 >= 0.0 == v4 <= 0.0) {
                    goto lab_0x100003aa4;
                } else {
                    goto lab_0x100003a88;
                }
            } else {
                goto lab_0x100003a88;
            }
        }
    }
  lab_0x100003c1c:
    // 0x100003c30
    *(int64_t *)v2 = (int64_t)g1;
    return result;
  lab_0x100003a88:
    if (v5 == -v4) {
        goto lab_0x100003aa4;
      lab_0x100003aa4:
        // 0x100003c30
        *(int64_t *)v2 = v6;
        return result2;
    }
    if (v5 > 0.0) {
        if (v4 > 0.0 == v4 >= 0.0 == v4 <= 0.0) {
            // 0x100003c30
            *(int64_t *)v2 = (int64_t)(g2 + (float64_t)v2);
            return result2;
        }
        if (v4 > 0.0) {
            // 0x100003c30
            *(int64_t *)v2 = (int64_t)((float64_t)v2 - g2);
            return result2;
        }
    } else {
        if (v4 > 0.0 == v5 > 0.0 == v5 >= 0.0 == v5 <= 0.0) {
            // 0x100003c30
            *(int64_t *)v2 = (int64_t)(g3 - (float64_t)v2);
            return result2;
        }
    }
    int64_t v8 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b88
    int64_t result3 = _fprintf((struct _IO_FILE *)v8, "Should not reach here!\n");
    *(int64_t *)v2 = (int64_t)0.0;
    return result3;
}

// Address range: 0x100003c48 - 0x100003c98
int64_t function_100003c48(int64_t a1) {
    // 0x100003c48
    return _rand();
}

// Address range: 0x100003c98 - 0x100003e4c
int64_t function_100003c98(void) {
    // 0x100003c98
    _srand(10);
    int32_t v1 = 0; // 0x100003e34
    int128_t v2; // 0x100003c98
    int64_t v3 = v2; // 0x100003c98
    int64_t v4; // 0x100003c98
    int32_t v5 = _printf("Test %d.... ", v4); // 0x100003cec
    function_100003c48(function_100003c48((int64_t)v5));
    _printf("(%.2g, %.2g).... ", (float64_t)v3, (float64_t)(int64_t)v2);
    function_1000039d8();
    float64_t v6 = _hypot((float64_t)v3, (float64_t)(int64_t)v2); // 0x100003d60
    float64_t v7; // bp-40, 0x100003c98
    int64_t v8 = &v7; // 0x100003d8c
    float64_t v9; // 0x100003c98
    if (__asm_fabd(v9, -5.0) <= g6) {
        // 0x100003d94
        ___assert_rtn("test", "cartesian_to_polar.c", 111, "fabs(r - hypot(x, y)) < 0.01");
        v8 = (int64_t)"cartesian_to_polar.c";
    }
    float64_t v10 = _atan2(v6, (float64_t)(int64_t)v2); // 0x100003dc8
    int64_t v11 = v8; // 0x100003df4
    if (__asm_fabd(v7, -5.0) <= g6) {
        // 0x100003dfc
        ___assert_rtn("test", "cartesian_to_polar.c", 112, "fabs(theta - atan2(y, x)) < 0.01");
        v11 = (int64_t)"cartesian_to_polar.c";
    }
    int32_t result = _printf("passed\n"); // 0x100003e28
    v1++;
    v3 = (float32_t)v10;
    while (v1 != 5) {
        // 0x100003cd4
        v5 = _printf("Test %d.... ", v11);
        function_100003c48(function_100003c48((int64_t)v5));
        _printf("(%.2g, %.2g).... ", (float64_t)v3, (float64_t)(int64_t)v2);
        function_1000039d8();
        v6 = _hypot((float64_t)v3, (float64_t)(int64_t)v2);
        v8 = &v7;
        if (__asm_fabd(v9, -5.0) <= g6) {
            // 0x100003d94
            ___assert_rtn("test", "cartesian_to_polar.c", 111, "fabs(r - hypot(x, y)) < 0.01");
            v8 = (int64_t)"cartesian_to_polar.c";
        }
        // 0x100003db8
        v10 = _atan2(v6, (float64_t)(int64_t)v2);
        v11 = v8;
        if (__asm_fabd(v7, -5.0) <= g6) {
            // 0x100003dfc
            ___assert_rtn("test", "cartesian_to_polar.c", 112, "fabs(theta - atan2(y, x)) < 0.01");
            v11 = (int64_t)"cartesian_to_polar.c";
        }
        // 0x100003e20
        result = _printf("passed\n");
        v1++;
        v3 = (float32_t)v10;
    }
    // 0x100003e40
    return result;
}

// Address range: 0x100003e4c - 0x100003e78
int64_t entry_point(void) {
    // 0x100003e4c
    function_100003c98();
    return 0;
}

// Address range: 0x100003e78 - 0x100003e84
int64_t function_100003e78(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003e78
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003e84 - 0x100003e90
float64_t function_100003e84(float64_t a1) {
    // 0x100003e84
    return _atan(a1);
}

// Address range: 0x100003e90 - 0x100003e9c
float64_t function_100003e90(float64_t a1, float64_t a2) {
    // 0x100003e90
    return _atan2(a1, a2);
}

// Address range: 0x100003e9c - 0x100003ea8
int32_t function_100003e9c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e9c
    return _fprintf(stream, format);
}

// Address range: 0x100003ea8 - 0x100003eb4
float64_t function_100003ea8(float64_t a1, float64_t a2) {
    // 0x100003ea8
    return _hypot(a1, a2);
}

// Address range: 0x100003eb4 - 0x100003ec0
int32_t function_100003eb4(char * format, ...) {
    // 0x100003eb4
    return _printf(format);
}

// Address range: 0x100003ec0 - 0x100003ecc
int32_t function_100003ec0(void) {
    // 0x100003ec0
    return _rand();
}

// Address range: 0x100003ecc - 0x100003ed8
void function_100003ecc(int32_t seed) {
    // 0x100003ecc
    _srand(seed);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

int locale_ok = 0;

wchar_t s_suits[] = L"♠♥♦♣";
/* if your file can't contain unicode, use the next line instead */
//wchar_t s_suits[] = L"\x2660\x2665\x2666\x2663";

const char *s_suits_ascii[] = { "S", "H", "D", "C" };
const char *s_nums[] = { "WHAT",
	"A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K",
	"OVERFLOW"
};

typedef struct { int suit, number, _s; } card_t, *card;
typedef struct { int n; card_t cards[52]; } deck_t, *deck;

void show_card(card c)
{
	if (locale_ok)
		printf(" %lc%s", s_suits[c->suit], s_nums[c->number]);
	else
		printf(" %s%s", s_suits_ascii[c->suit], s_nums[c->number]);
}

deck new_deck()
{
	int i, j, k;
	deck d = malloc(sizeof(deck_t));
	d->n = 52;
	for (i = k = 0; i < 4; i++)
		for (j = 1; j <= 13; j++, k++) {
			d->cards[k].suit = i;
			d->cards[k].number = j;
		}
	return d;
}

void show_deck(deck d)
{
	int i;
	printf("%d cards:", d->n);
	for (i = 0; i < d->n; i++)
		show_card(d->cards + i);
	printf("\n");
}

int cmp_card(const void *a, const void *b)
{
	int x = ((card)a)->_s, y = ((card)b)->_s;
	return x < y ? -1 : x > y;
}

card deal_card(deck d)
{
	if (!d->n) return 0;
	return d->cards + --d->n;
}

void shuffle_deck(deck d)
{
	int i;
	for (i = 0; i < d->n; i++)
		d->cards[i]._s = rand();
	qsort(d->cards, d->n, sizeof(card_t), cmp_card);
}

int main()
{
	int i, j;
	deck d = new_deck();

	locale_ok = (0 != setlocale(LC_CTYPE, ""));

	printf("New deck, "); show_deck(d);

	printf("\nShuffle and deal to three players:\n");
	shuffle_deck(d);
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 5; j++)
			show_card(deal_card(d));
		printf("\n");
	}
	printf("Left in deck "); show_deck(d);

	/* freeing the data struct requires just free(), but it depends on the
	 * situation: there might be cards dealt out somewhere, which is not
	 * in the scope of this task.
	 */
	//free(d);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a30(void);
int64_t function_100003af0(void);
int64_t function_100003bd0(void);
int64_t function_100003c6c(void);
int64_t function_100003cdc(void);
int64_t function_100003d38(void);
int64_t * function_100003ed0(int32_t size);
int32_t function_100003edc(char * format, ...);
void function_100003ee8(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003ef4(void);
char * function_100003f00(int32_t category, char * locale);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f56
int64_t g2; // 0x1000080b0
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _rand(void);
char * _setlocale(int32_t a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003a30 - 0x100003af0
int64_t function_100003a30(void) {
    // 0x100003a30
    int32_t result; // 0x100003a30
    int64_t v1; // 0x100003a30
    if (*(int32_t *)((int64_t)"&" + 176) == 0) {
        // 0x100003aa0
        result = _printf(" %s%s", (char *)v1, (char *)v1);
    } else {
        // 0x100003a58
        result = _printf(" %lc%s", (char)v1, (char *)v1);
    }
    // 0x100003ae4
    return result;
}

// Address range: 0x100003af0 - 0x100003bd0
int64_t function_100003af0(void) {
    int64_t * v1 = _malloc(628); // 0x100003b00
    int64_t result = (int64_t)v1; // 0x100003b00
    *(int32_t *)v1 = 52;
    int32_t v2 = 0; // 0x100003ba0
    for (int32_t i = 0; i < 4; i++) {
        int32_t v3 = 1;
        int64_t v4 = result + 4 + 12 * (int64_t)v2; // 0x100003b6c
        *(int32_t *)v4 = i;
        *(int32_t *)(v4 + 4) = v3;
        int32_t v5 = v3 + 1; // 0x100003b94
        v2++;
        while (v3 == 12 || v3 < 12 != (11 - v3 & v5) < 0) {
            // 0x100003b54
            v3 = v5;
            v4 = result + 4 + 12 * (int64_t)v2;
            *(int32_t *)v4 = i;
            *(int32_t *)(v4 + 4) = v3;
            v5 = v3 + 1;
            v2++;
        }
    }
    // 0x100003bc0
    return result;
}

// Address range: 0x100003bd0 - 0x100003c6c
int64_t function_100003bd0(void) {
    // 0x100003bd0
    int64_t v1; // 0x100003bd0
    _printf("%d cards:", v1);
    int32_t v2 = v1;
    int32_t v3 = -v2; // 0x100003c14
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100003c54
        return _printf("\n");
    }
    int32_t v4 = 0; // 0x100003c1c
    function_100003a30();
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003c24
        function_100003a30();
        v4++;
    }
    // 0x100003c54
    return _printf("\n");
}

// Address range: 0x100003c6c - 0x100003cdc
int64_t function_100003c6c(void) {
    // 0x100003c6c
    int64_t v1; // 0x100003c6c
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x100003c7c
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x100003c88
    int32_t v4 = v2 - v3; // 0x100003c98
    return v4 < 0 == ((v4 ^ v2) & (v3 ^ v2)) < 0 ? (int64_t)(v4 != 0) : 0xffffffff;
}

// Address range: 0x100003cdc - 0x100003d38
int64_t function_100003cdc(void) {
    // 0x100003cdc
    int64_t v1; // 0x100003cdc
    int32_t v2 = v1;
    int64_t result = 0; // 0x100003cf4
    if (v2 != 0) {
        int32_t v3 = v2 - 1; // 0x100003d14
        *(int32_t *)v1 = v3;
        result = v1 + 4 + 12 * (int64_t)v3;
    }
    // 0x100003d2c
    return result;
}

// Address range: 0x100003d38 - 0x100003dcc
int64_t function_100003d38(void) {
    // 0x100003d38
    int64_t v1; // 0x100003d38
    int32_t v2 = v1;
    int32_t v3 = -v2; // 0x100003d5c
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100003da0
        _qsort((int64_t *)(v1 + 4), v2, 12, (int32_t (*)(int64_t *, int64_t *))0x100003c6c);
        return &g3;
    }
    int32_t v4 = 0; // 0x100003d94
    *(int32_t *)(v1 + 12 + 12 * (int64_t)v4) = _rand();
    v4++;
    int64_t v5; // 0x100003d38
    int32_t v6 = *(int32_t *)&v5; // 0x100003d58
    int32_t v7 = v4 - v6; // 0x100003d5c
    int32_t v8 = v6; // 0x100003d64
    while (v7 < 0 != ((v7 ^ v4) & (v6 ^ v4)) < 0) {
        // 0x100003d6c
        *(int32_t *)(v1 + 12 + 12 * (int64_t)v4) = _rand();
        v4++;
        v6 = *(int32_t *)&v5;
        v7 = v4 - v6;
        v8 = v6;
    }
    // 0x100003da0
    _qsort((int64_t *)(v1 + 4), v8, 12, (int32_t (*)(int64_t *, int64_t *))0x100003c6c);
    return &g3;
}

// Address range: 0x100003dcc - 0x100003ed0
int64_t entry_point(void) {
    // 0x100003dcc
    function_100003af0();
    char * v1 = _setlocale(2, (char *)&g1); // 0x100003df0
    *(int32_t *)&g2 = (int32_t)(v1 != NULL);
    _printf("New deck, ");
    function_100003bd0();
    _printf("\nShuffle and deal to three players:\n");
    function_100003d38();
    for (int32_t i = 0; i < 3; i++) {
        for (int32_t j = 0; j < 5; j++) {
            // 0x100003e6c
            function_100003cdc();
            function_100003a30();
        }
        // 0x100003e8c
        _printf("\n");
    }
    // 0x100003eac
    _printf("Left in deck ");
    function_100003bd0();
    return 0;
}

// Address range: 0x100003ed0 - 0x100003edc
int64_t * function_100003ed0(int32_t size) {
    // 0x100003ed0
    return _malloc(size);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(char * format, ...) {
    // 0x100003edc
    return _printf(format);
}

// Address range: 0x100003ee8 - 0x100003ef4
void function_100003ee8(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003ee8
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(void) {
    // 0x100003ef4
    return _rand();
}

// Address range: 0x100003f00 - 0x100003f0c
char * function_100003f00(int32_t category, char * locale) {
    // 0x100003f00
    return _setlocale(category, locale);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>
#include <string.h>

const char *A[] = { "John", "Serena", "Bob", "Mary", "Serena" };
const char *B[] = { "Jim", "Mary", "John", "Jim", "Bob" };

#define LEN(x) sizeof(x)/sizeof(x[0])

/* null duplicate items */
void uniq(const char *x[], int len)
{
	int i, j;
	for (i = 0; i < len; i++)
		for (j = i + 1; j < len; j++)
			if (x[j] && x[i] && !strcmp(x[i], x[j])) x[j] = 0;
}

int in_set(const char *const x[], int len, const char *match)
{
	int i;
	for (i = 0; i < len; i++)
		if (x[i] && !strcmp(x[i], match))
			return 1;
	return 0;
}

/* x - y */
void show_diff(const char *const x[], int lenx, const char *const y[], int leny)
{
	int i;
	for (i = 0; i < lenx; i++)
		if (x[i] && !in_set(y, leny, x[i]))
			printf("  %s\n", x[i]);
}

/* X ^ Y */
void show_sym_diff(const char *const x[], int lenx, const char *const y[], int leny)
{
	show_diff(x, lenx, y, leny);
	show_diff(y, leny, x, lenx);
}

int main()
{
	uniq(A, LEN(A));
	uniq(B, LEN(B));
	printf("A \\ B:\n"); show_diff(A, LEN(A), B, LEN(B));
	printf("\nB \\ A:\n"); show_diff(B, LEN(B), A, LEN(A));
	printf("\nA ^ B:\n");  show_sym_diff(A, LEN(A), B, LEN(B));

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bd4(void);
int64_t function_100003cdc(void);
int64_t function_100003d8c(void);
int64_t function_100003e50(void);
int32_t function_100003f54(char * format, ...);
int32_t function_100003f60(char * s1, char * s2);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003bd4 - 0x100003cdc
int64_t function_100003bd4(void) {
    // 0x100003bd4
    int64_t v1; // 0x100003bd4
    int32_t v2 = v1; // 0x100003be4
    int32_t v3 = -v2; // 0x100003bf8
    int64_t result; // 0x100003bd4
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003cd0
        return result;
    }
    int32_t v4 = 1 - v2;
    if (v4 < 0 == (v4 & v2) < 0) {
        // 0x100003cd0
        return result;
    }
    int32_t v5 = 1;
    int64_t * v6 = (int64_t *)v1;
    int32_t v7 = v5;
    int64_t * v8 = (int64_t *)(8 * (int64_t)v7 + v1); // 0x100003c38
    int64_t v9 = *v8; // 0x100003c38
    int64_t v10; // 0x100003bd4
    int64_t v11 = v10; // 0x100003c44
    int64_t v12; // 0x100003c54
    int32_t v13; // 0x100003c80
    if (v9 != 0) {
        // 0x100003c4c
        v12 = *v6;
        v11 = v10;
        if (v12 != 0) {
            // 0x100003c68
            v13 = _strcmp((char *)v12, (char *)v9);
            v11 = v13;
            if (v13 == 0) {
                // 0x100003c94
                *v8 = 0;
                v11 = 0;
            }
        }
    }
    int64_t result2 = v11;
    v7++;
    int32_t v14 = v7 - v2; // 0x100003c20
    int64_t v15; // 0x100003bd4
    while (v14 < 0 != ((v14 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x100003c30
        v15 = result2;
        v8 = (int64_t *)(8 * (int64_t)v7 + v1);
        v9 = *v8;
        v11 = v15;
        if (v9 != 0) {
            // 0x100003c4c
            v12 = *v6;
            v11 = v15;
            if (v12 != 0) {
                // 0x100003c68
                v13 = _strcmp((char *)v12, (char *)v9);
                v11 = v13;
                if (v13 == 0) {
                    // 0x100003c94
                    *v8 = 0;
                    v11 = 0;
                }
            }
        }
        // 0x100003cac
        result2 = v11;
        v7++;
        v14 = v7 - v2;
    }
    int32_t v16 = v5 + 1;
    int32_t v17 = v16 - v2;
    while (v17 < 0 != ((v17 ^ v16) & (v16 ^ v2)) < 0) {
        int32_t v18 = v5;
        v5 = v16;
        v6 = (int64_t *)(8 * (int64_t)v18 + v1);
        v7 = v5;
        v15 = result2;
        v8 = (int64_t *)(8 * (int64_t)v7 + v1);
        v9 = *v8;
        v11 = v15;
        if (v9 != 0) {
            // 0x100003c4c
            v12 = *v6;
            v11 = v15;
            if (v12 != 0) {
                // 0x100003c68
                v13 = _strcmp((char *)v12, (char *)v9);
                v11 = v13;
                if (v13 == 0) {
                    // 0x100003c94
                    *v8 = 0;
                    v11 = 0;
                }
            }
        }
        // 0x100003cac
        result2 = v11;
        v7++;
        v14 = v7 - v2;
        while (v14 < 0 != ((v14 ^ v7) & (v7 ^ v2)) < 0) {
            // 0x100003c30
            v15 = result2;
            v8 = (int64_t *)(8 * (int64_t)v7 + v1);
            v9 = *v8;
            v11 = v15;
            if (v9 != 0) {
                // 0x100003c4c
                v12 = *v6;
                v11 = v15;
                if (v12 != 0) {
                    // 0x100003c68
                    v13 = _strcmp((char *)v12, (char *)v9);
                    v11 = v13;
                    if (v13 == 0) {
                        // 0x100003c94
                        *v8 = 0;
                        v11 = 0;
                    }
                }
            }
            // 0x100003cac
            result2 = v11;
            v7++;
            v14 = v7 - v2;
        }
        // 0x100003c18
        v16 = v5 + 1;
        v17 = v16 - v2;
    }
    // 0x100003cd0
    return result2;
}

// Address range: 0x100003cdc - 0x100003d8c
int64_t function_100003cdc(void) {
    // 0x100003cdc
    int64_t v1; // 0x100003cdc
    int32_t v2 = v1; // 0x100003cec
    int32_t v3 = -v2; // 0x100003d04
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003d7c
        return 0;
    }
    int32_t v4 = 0; // 0x100003d0c
    int64_t v5 = *(int64_t *)(8 * (int64_t)v4 + v1); // 0x100003d1c
    if (v5 != 0) {
        // 0x100003d30
        if (_strcmp((char *)v5, (char *)v1) == 0) {
            // break -> 0x100003d7c
            break;
        }
    }
    // 0x100003d64
    v4++;
    int32_t v6 = v4 - v2; // 0x100003d04
    int64_t result = 0; // 0x100003d0c
    while (v6 < 0 != ((v6 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003d14
        v5 = *(int64_t *)(8 * (int64_t)v4 + v1);
        if (v5 != 0) {
            // 0x100003d30
            result = 1;
            if (_strcmp((char *)v5, (char *)v1) == 0) {
                // break -> 0x100003d7c
                break;
            }
        }
        // 0x100003d64
        v4++;
        v6 = v4 - v2;
        result = 0;
    }
    // 0x100003d7c
    return result;
}

// Address range: 0x100003d8c - 0x100003e50
int64_t function_100003d8c(void) {
    // 0x100003d8c
    int64_t v1; // 0x100003d8c
    int32_t v2 = v1; // 0x100003d9c
    int32_t v3 = -v2; // 0x100003db8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e44
        int64_t result; // 0x100003d8c
        return result;
    }
    int32_t v4 = 0; // 0x100003e38
    int64_t v5; // 0x100003d8c
    int64_t result2 = v5; // 0x100003ddc
    int64_t v6; // 0x100003df8
    if (*(int64_t *)(8 * (int64_t)v4 + v1) != 0) {
        // 0x100003de4
        v6 = function_100003cdc();
        result2 = v6;
        if ((int32_t)v6 == 0) {
            // 0x100003e0c
            result2 = _printf("  %s\n", (char *)(v1 & 0xffffffff));
        }
    }
    // 0x100003e34
    v4++;
    int32_t v7 = v4 - v2; // 0x100003db8
    while (v7 < 0 != ((v7 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003dc8
        if (*(int64_t *)(8 * (int64_t)v4 + v1) != 0) {
            // 0x100003de4
            v6 = function_100003cdc();
            result2 = v6;
            if ((int32_t)v6 == 0) {
                // 0x100003e0c
                result2 = _printf("  %s\n", (char *)(v1 & 0xffffffff));
            }
        }
        // 0x100003e34
        v4++;
        v7 = v4 - v2;
    }
    // 0x100003e44
    return result2;
}

// Address range: 0x100003e50 - 0x100003ea0
int64_t function_100003e50(void) {
    // 0x100003e50
    function_100003d8c();
    return function_100003d8c();
}

// Address range: 0x100003ea0 - 0x100003f54
int64_t entry_point(void) {
    // 0x100003ea0
    function_100003bd4();
    function_100003bd4();
    _printf("A \\ B:\n");
    function_100003d8c();
    _printf("\nB \\ A:\n");
    function_100003d8c();
    _printf("\nA ^ B:\n");
    function_100003e50();
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * s1, char * s2) {
    // 0x100003f60
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include<stdio.h>

typedef struct{
	double x,y,z;
}vector;

vector addVectors(vector a,vector b){
	return (vector){a.x+b.x,a.y+b.y,a.z+b.z};
}

vector subVectors(vector a,vector b){
	return (vector){a.x-b.x,a.y-b.y,a.z-b.z};
}

double dotProduct(vector a,vector b){
	return a.x*b.x + a.y*b.y + a.z*b.z;
}

vector scaleVector(double l,vector a){
	return (vector){l*a.x,l*a.y,l*a.z};
}

vector intersectionPoint(vector lineVector, vector linePoint, vector planeNormal, vector planePoint){
	vector diff = subVectors(linePoint,planePoint);
	
	return addVectors(addVectors(diff,planePoint),scaleVector(-dotProduct(diff,planeNormal)/dotProduct(lineVector,planeNormal),lineVector));
}

int main(int argC,char* argV[])
{
	vector lV,lP,pN,pP,iP;
	
	if(argC!=5)
		printf("Usage : %s <line direction, point on line, normal to plane and point on plane given as (x,y,z) tuples separated by space>");
	else{
		sscanf(argV[1],"(%lf,%lf,%lf)",&lV.x,&lV.y,&lV.z);
		sscanf(argV[3],"(%lf,%lf,%lf)",&pN.x,&pN.y,&pN.z);
		
		if(dotProduct(lV,pN)==0)
			printf("Line and Plane do not intersect, either parallel or line is on the plane");
		else{
			sscanf(argV[2],"(%lf,%lf,%lf)",&lP.x,&lP.y,&lP.z);
			sscanf(argV[4],"(%lf,%lf,%lf)",&pP.x,&pP.y,&pP.z);
			
			iP = intersectionPoint(lV,lP,pN,pP);
			
			printf("Intersection point is (%lf,%lf,%lf)",iP.x,iP.y,iP.z);
		}
	}
		
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039e0(void);
int64_t function_100003a40(void);
int64_t function_100003aa0(void);
int64_t function_100003ae8(void);
int64_t function_100003b40(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int32_t function_100003e80(char * format, ...);
int32_t function_100003e8c(char * s, char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _sscanf(char * a1, char * a2, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000039e0 - 0x100003a40
int64_t function_1000039e0(void) {
    // 0x1000039e0
    int64_t result; // 0x1000039e0
    return result;
}

// Address range: 0x100003a40 - 0x100003aa0
int64_t function_100003a40(void) {
    // 0x100003a40
    int64_t result; // 0x100003a40
    return result;
}

// Address range: 0x100003aa0 - 0x100003ae8
int64_t function_100003aa0(void) {
    // 0x100003aa0
    int64_t result; // 0x100003aa0
    return result;
}

// Address range: 0x100003ae8 - 0x100003b40
int64_t function_100003ae8(void) {
    // 0x100003ae8
    int64_t result; // 0x100003ae8
    return result;
}

// Address range: 0x100003b40 - 0x100003c94
int64_t function_100003b40(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x100003b40
    function_100003a40();
    function_1000039e0();
    function_100003aa0();
    function_100003aa0();
    function_100003ae8();
    return function_1000039e0();
}

// Address range: 0x100003c94 - 0x100003e80
int64_t entry_point(void) {
    // 0x100003c94
    int64_t v1; // 0x100003c94
    if ((int32_t)v1 != 5) {
        // 0x100003cc4
        _printf("Usage : %s <line direction, point on line, normal to plane and point on plane given as (x,y,z) tuples separated by space>", (char *)v1);
        // 0x100003e6c
        return 0;
    }
    float64_t * v2 = (float64_t *)v1; // 0x100003d04
    float64_t * v3 = (float64_t *)v1; // 0x100003d04
    float64_t * v4 = (float64_t *)v1; // 0x100003d04
    _sscanf((char *)*(int64_t *)(v1 + 8), "(%lf,%lf,%lf)", v2, v3, v4);
    _sscanf((char *)*(int64_t *)(v1 + 24), "(%lf,%lf,%lf)", v2, v3, v4);
    function_100003aa0();
    float64_t v5; // 0x100003c94
    if (v5 == 0.0) {
        // 0x100003d60
        _printf("Line and Plane do not intersect, either parallel or line is on the plane");
    } else {
        // 0x100003d70
        _sscanf((char *)*(int64_t *)(v1 + 16), "(%lf,%lf,%lf)", v2, v3, v4);
        _sscanf((char *)*(int64_t *)(v1 + 32), "(%lf,%lf,%lf)", v2, v3, v4);
        function_100003b40(v1, v1, v1, v1, v1, v1);
        int128_t v6; // 0x100003c94
        _printf("Intersection point is (%lf,%lf,%lf)", (float64_t)(int64_t)v6, (float64_t)(int64_t)v6, (float64_t)(int64_t)v6);
    }
    // 0x100003e6c
    return 0;
}

// Address range: 0x100003e80 - 0x100003e8c
int32_t function_100003e80(char * format, ...) {
    // 0x100003e80
    return _printf(format);
}

// Address range: 0x100003e8c - 0x100003e98
int32_t function_100003e8c(char * s, char * format, ...) {
    // 0x100003e8c
    return _sscanf(s, format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

typedef uint8_t byte;
typedef struct {
    FILE *fp;
    uint32_t accu;
    int bits;
} bit_io_t, *bit_filter;

bit_filter b_attach(FILE *f)
{
    bit_filter b = malloc(sizeof(bit_io_t));
    b->bits = b->accu = 0;
    b->fp = f;
    return b;
}

void b_write(byte *buf, size_t n_bits, size_t shift, bit_filter bf)
{
    uint32_t accu = bf->accu;
    int bits = bf->bits;

    buf += shift / 8;
    shift %= 8;

    while (n_bits || bits >= 8) {
        while (bits >= 8) {
            bits -= 8;
            fputc(accu >> bits, bf->fp);
            accu &= (1 << bits) - 1;
        }
        while (bits < 8 && n_bits) {
            accu = (accu << 1) | (((128 >> shift) & *buf) >> (7 - shift));
            --n_bits;
            bits++;
            if (++shift == 8) {
                shift = 0;
                buf++;
            }
        }
    }
    bf->accu = accu;
    bf->bits = bits;
}

size_t b_read(byte *buf, size_t n_bits, size_t shift, bit_filter bf)
{
    uint32_t accu = bf->accu;
    int bits = bf->bits;
    int mask, i = 0;

    buf += shift / 8;
    shift %= 8;

    while (n_bits) {
        while (bits && n_bits) {
            mask = 128 >> shift;
            if (accu & (1 << (bits - 1))) *buf |= mask;
            else *buf &= ~mask;

            n_bits--;
            bits--;

            if (++shift >= 8) {
                shift = 0;
                buf++;
            }
        }
        if (!n_bits) break;
        accu = (accu << 8) | fgetc(bf->fp);
        bits += 8;
    }
    bf->accu = accu;
    bf->bits = bits;

    return i;
}

void b_detach(bit_filter bf)
{
    if (bf->bits) {
        bf->accu <<= 8 - bf->bits;
        fputc(bf->accu, bf->fp);
    }
    free(bf);
}

int main()
{
    unsigned char s[] = "abcdefghijk";
    unsigned char s2[11] = {0};
    int i;

    FILE *f = fopen("test.bin", "wb");
    bit_filter b = b_attach(f);
    /* for each byte in s, write 7 bits skipping 1 */
    for (i = 0; i < 10; i++) b_write(s + i, 7, 1, b);
    b_detach(b);
    fclose(f);

    /* read 7 bits and expand to each byte of s2 skipping 1 bit */
    f = fopen("test.bin", "rb");
    b = b_attach(f);
    for (i = 0; i < 10; i++) b_read(s2 + i, 7, 1, b);
    b_detach(b);
    fclose(f);

    printf("%10s\n", s2); /* should be the same first 10 bytes as in s */

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003910(int64_t a1);
int64_t function_100003958(void);
int64_t function_100003b40(void);
int64_t function_100003d20(void);
int64_t function_100003f24(int64_t a1);
int32_t function_100003f30(struct _IO_FILE * stream);
int32_t function_100003f3c(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f48(char * filename, char * modes);
int32_t function_100003f54(int32_t c, struct _IO_FILE * stream);
void function_100003f60(int64_t * ptr);
int64_t * function_100003f6c(int32_t size);
int32_t function_100003f78(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fputc(int32_t a1, struct _IO_FILE * a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003910 - 0x100003958
int64_t function_100003910(int64_t a1) {
    int64_t * v1 = _malloc(16); // 0x100003924
    int64_t result = (int64_t)v1; // 0x100003924
    *(int32_t *)(result + 8) = 0;
    *(int32_t *)(result + 12) = 0;
    *v1 = a1;
    return result;
}

// Address range: 0x100003958 - 0x100003b40
int64_t function_100003958(void) {
    // 0x100003958
    int64_t v1; // 0x100003958
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x100003978
    int32_t * v3 = (int32_t *)(v1 + 12); // 0x100003984
    uint64_t v4 = v1 / 8; // 0x100003994
    int32_t v5 = v1 - 8 * v4; // 0x1000039b8
    int32_t v6 = *v2; // 0x1000039b8
    int32_t v7 = *v3; // 0x1000039b8
    char * v8 = (char *)(v1 + v4); // 0x1000039b8
    int32_t v9; // 0x100003958
    int32_t v10; // 0x100003958
    int64_t result; // 0x100003958
    while (true) {
        char * v11 = v8;
        int64_t v12; // 0x100003958
        result = v12;
        v10 = v7;
        v9 = v6;
        int32_t v13 = v5;
        int32_t v14 = v10 - 8;
        int32_t v15 = 7 - v10 & v10;
        int64_t v16; // 0x100003958
        if (v16 == 0) {
            if (v14 < 0 != v15 < 0) {
                // break -> 0x100003b1c
                break;
            }
        }
        int32_t v17 = v15; // 0x100003a08
        int32_t v18 = v14; // 0x100003a08
        int32_t v19 = v9; // 0x100003a08
        int32_t v20 = v10; // 0x100003a08
        int64_t v21 = result; // 0x100003a08
        int32_t v22 = v14; // 0x100003a08
        int32_t v23 = v9; // 0x100003a08
        if (v14 < 0 == v15 < 0) {
            uint32_t v24 = v22;
            int32_t v25 = _fputc(v23 >> v24, (struct _IO_FILE *)v1); // 0x100003a30
            int32_t v26 = v23 & -1 - (-1 << v24); // 0x100003a48
            int32_t v27 = v24 - 8;
            int32_t v28 = 7 - v24 & v24;
            v23 = v26;
            while (v27 < 0 == v28 < 0) {
                // 0x100003a10
                v24 = v27;
                v25 = _fputc(v23 >> v24, (struct _IO_FILE *)v1);
                v26 = v23 & -1 - (-1 << v24);
                v27 = v24 - 8;
                v28 = 7 - v24 & v24;
                v23 = v26;
            }
            // 0x1000039fc
            v17 = v28;
            v18 = v27;
            v19 = v26;
            v20 = v24;
            v21 = v25;
        }
        // 0x100003a58
        v5 = v13;
        v6 = v19;
        v7 = v20;
        int64_t v29 = v16; // 0x100003a8c
        v8 = v11;
        char * v30 = v11; // 0x100003a8c
        int64_t v31 = v16; // 0x100003a8c
        int32_t v32 = v20; // 0x100003a8c
        int32_t v33 = v19; // 0x100003a8c
        int32_t v34 = v13; // 0x100003a8c
        if (v16 != 0 == (v18 < 0 != v17 < 0)) {
            uint32_t v35 = v34;
            int32_t v36 = v32;
            char * v37 = v30;
            unsigned char v38 = *v37; // 0x100003aac
            int32_t v39 = (128 >> v35 & (int32_t)v38) >> 7 - v35 | 2 * v33; // 0x100003ac4
            int64_t v40 = v31 - 1; // 0x100003ad0
            int32_t v41 = v36 + 1; // 0x100003adc
            int32_t v42 = v35 == 7 ? 0 : v35 + 1;
            char * v43 = v35 == 7 ? (char *)((int64_t)v37 + 1) : v37;
            v5 = v42;
            v6 = v39;
            v7 = v41;
            v29 = v40;
            v8 = v43;
            v31 = v40;
            v33 = v39;
            while (v40 != 0 == (v36 < 7 != (6 - v36 & v41) < 0)) {
                // 0x100003a94
                v35 = v42;
                v36 = v41;
                v37 = v43;
                v38 = *v37;
                v39 = (128 >> v35 & (int32_t)v38) >> 7 - v35 | 2 * v33;
                v40 = v31 - 1;
                v41 = v36 + 1;
                v42 = v35 == 7 ? 0 : v35 + 1;
                v43 = v35 == 7 ? (char *)((int64_t)v37 + 1) : v37;
                v5 = v42;
                v6 = v39;
                v7 = v41;
                v29 = v40;
                v8 = v43;
                v31 = v40;
                v33 = v39;
            }
        }
        // 0x1000039bc
        v12 = v21;
        v16 = v29;
    }
    // 0x100003b1c
    *v2 = v9;
    *v3 = v10;
    return result;
}

// Address range: 0x100003b40 - 0x100003d20
int64_t function_100003b40(void) {
    // 0x100003b40
    int64_t v1; // 0x100003b40
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x100003b60
    int32_t v3 = *v2; // 0x100003b60
    int32_t * v4 = (int32_t *)(v1 + 12); // 0x100003b6c
    int32_t v5 = *v4; // 0x100003b6c
    if (v1 == 0) {
        // 0x100003cf8
        *v2 = v3;
        *v4 = v5;
        return 0;
    }
    uint64_t v6 = v1 / 8; // 0x100003b80
    char * v7 = (char *)(v1 + v6); // 0x100003b40
    int32_t v8 = v1 - 8 * v6; // 0x100003b40
    int32_t v9 = v3;
    char * v10 = v7; // 0x100003bf4
    int64_t v11; // 0x100003b40
    int64_t v12 = v11; // 0x100003bf4
    int32_t v13 = v8; // 0x100003bf4
    int32_t v14 = v5; // 0x100003bf4
    int64_t v15 = v11; // 0x100003bf4
    bool v16 = v11 == 0; // 0x100003bf4
    char * v17; // 0x100003b40
    char * v18; // 0x100003b40
    int32_t v19; // 0x100003b40
    int32_t v20; // 0x100003b40
    char v21; // 0x100003b40
    int32_t v22; // 0x100003c1c
    char v23; // 0x100003b40
    char v24; // 0x100003b40
    int64_t v25; // 0x100003c68
    uint64_t v26; // 0x100003c80
    if (v11 != 0 == (v5 != 0)) {
        v17 = v10;
        v22 = v5 - 1;
        v23 = *v17;
        v24 = 128 >> v13;
        v21 = (1 << v22 & v9) == 0 ? v23 & -1 - v24 : v23 | v24;
        *v17 = v21;
        v25 = v12 - 1;
        v26 = (int64_t)v13 + 1;
        v19 = v26 < 8 ? (int32_t)v26 : 0;
        v18 = v26 < 8 ? v17 : (char *)((int64_t)v17 + 1);
        v12 = v25;
        v13 = v19;
        v20 = v22;
        v14 = v22;
        v8 = v19;
        v15 = v25;
        v7 = v18;
        v16 = v25 == 0;
        while (v25 != 0 == (v22 != 0)) {
            // 0x100003bfc
            v17 = v18;
            v22 = v20 - 1;
            v23 = *v17;
            v24 = 128 >> v13;
            v21 = (1 << v22 & v9) == 0 ? v23 & -1 - v24 : v23 | v24;
            *v17 = v21;
            v25 = v12 - 1;
            v26 = (int64_t)v13 + 1;
            v19 = v26 < 8 ? (int32_t)v26 : 0;
            v18 = v26 < 8 ? v17 : (char *)((int64_t)v17 + 1);
            v12 = v25;
            v13 = v19;
            v20 = v22;
            v14 = v22;
            v8 = v19;
            v15 = v25;
            v7 = v18;
            v16 = v25 == 0;
        }
    }
    int32_t v27 = v9; // 0x100003cbc
    int32_t v28 = v14; // 0x100003cbc
    while (!v16) {
        int32_t v29 = _fgetc((struct _IO_FILE *)v1) | 256 * v9; // 0x100003ce0
        int32_t v30 = v14 + 8; // 0x100003cec
        v11 = v15;
        v27 = v29;
        v28 = v30;
        if (v15 == 0) {
            // break -> 0x100003cf8
            break;
        }
        v9 = v29;
        v10 = v7;
        v12 = v11;
        v13 = v8;
        v20 = v30;
        v14 = v30;
        v15 = v11;
        v16 = v11 == 0;
        if (v11 != 0 == (v30 != 0)) {
            v17 = v10;
            v22 = v20 - 1;
            v23 = *v17;
            v24 = 128 >> v13;
            v21 = (1 << v22 & v9) == 0 ? v23 & -1 - v24 : v23 | v24;
            *v17 = v21;
            v25 = v12 - 1;
            v26 = (int64_t)v13 + 1;
            v19 = v26 < 8 ? (int32_t)v26 : 0;
            v18 = v26 < 8 ? v17 : (char *)((int64_t)v17 + 1);
            v12 = v25;
            v13 = v19;
            v20 = v22;
            v14 = v22;
            v8 = v19;
            v15 = v25;
            v7 = v18;
            v16 = v25 == 0;
            while (v25 != 0 == (v22 != 0)) {
                // 0x100003bfc
                v17 = v18;
                v22 = v20 - 1;
                v23 = *v17;
                v24 = 128 >> v13;
                v21 = (1 << v22 & v9) == 0 ? v23 & -1 - v24 : v23 | v24;
                *v17 = v21;
                v25 = v12 - 1;
                v26 = (int64_t)v13 + 1;
                v19 = v26 < 8 ? (int32_t)v26 : 0;
                v18 = v26 < 8 ? v17 : (char *)((int64_t)v17 + 1);
                v12 = v25;
                v13 = v19;
                v20 = v22;
                v14 = v22;
                v8 = v19;
                v15 = v25;
                v7 = v18;
                v16 = v25 == 0;
            }
        }
        // 0x100003cb0
        v27 = v9;
        v28 = v14;
    }
    // 0x100003cf8
    *v2 = v27;
    *v4 = v28;
    return 0;
}

// Address range: 0x100003d20 - 0x100003d94
int64_t function_100003d20(void) {
    // 0x100003d20
    int64_t v1; // 0x100003d20
    int32_t v2 = *(int32_t *)(v1 + 12); // 0x100003d34
    if (v2 != 0) {
        int32_t * v3 = (int32_t *)(v1 + 8); // 0x100003d5c
        uint32_t v4 = *v3 << 8 - v2; // 0x100003d60
        *v3 = v4;
        _fputc(v4, (struct _IO_FILE *)(int64_t)v4);
    }
    // 0x100003d80
    _free((int64_t *)v1);
    return &g1;
}

// Address range: 0x100003d94 - 0x100003f24
int64_t entry_point(void) {
    struct _IO_FILE * v1 = _fopen("test.bin", "wb"); // 0x100003de8
    function_100003910((int64_t)v1);
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003e18
        function_100003958();
    }
    // 0x100003e48
    function_100003d20();
    _fclose(v1);
    struct _IO_FILE * v2 = _fopen("test.bin", "rb"); // 0x100003e68
    function_100003910((int64_t)v2);
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003e98
        function_100003b40();
    }
    // 0x100003ec8
    function_100003d20();
    _fclose(v2);
    int32_t v3 = _printf("%10s\n", (char *)7); // 0x100003eec
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003efc
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f10
        ___stack_chk_fail((int64_t)v3);
    }
    // 0x100003f14
    return 0;
}

// Address range: 0x100003f24 - 0x100003f30
int64_t function_100003f24(int64_t a1) {
    // 0x100003f24
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(struct _IO_FILE * stream) {
    // 0x100003f30
    return _fclose(stream);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(struct _IO_FILE * stream) {
    // 0x100003f3c
    return _fgetc(stream);
}

// Address range: 0x100003f48 - 0x100003f54
struct _IO_FILE * function_100003f48(char * filename, char * modes) {
    // 0x100003f48
    return _fopen(filename, modes);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(int32_t c, struct _IO_FILE * stream) {
    // 0x100003f54
    return _fputc(c, stream);
}

// Address range: 0x100003f60 - 0x100003f6c
void function_100003f60(int64_t * ptr) {
    // 0x100003f60
    _free(ptr);
}

// Address range: 0x100003f6c - 0x100003f78
int64_t * function_100003f6c(int32_t size) {
    // 0x100003f6c
    return _malloc(size);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned int uint;
typedef unsigned long long tree;
#define B(x) (1ULL<<(x))

tree *list = 0;
uint cap = 0, len = 0;
uint offset[32] = {0, 1, 0};

void append(tree t)
{
	if (len == cap) {
		cap = cap ? cap*2 : 2;
		list = realloc(list, cap*sizeof(tree));
	}
	list[len++] = 1 | t<<1;
}

void show(tree t, uint len)
{
	for (; len--; t >>= 1)
		putchar(t&1 ? '(' : ')');
}

void listtrees(uint n)
{
	uint i;
	for (i = offset[n]; i < offset[n+1]; i++) {
		show(list[i], n*2);
		putchar('\n');
	}
}

/* assemble tree from subtrees
	n:   length of tree we want to make
	t:   assembled parts so far
	sl:  length of subtree we are looking at
	pos: offset of subtree we are looking at
	rem: remaining length to be put together
*/
void assemble(uint n, tree t, uint sl, uint pos, uint rem)
{
	if (!rem) {
		append(t);
		return;
	}

	if (sl > rem) // need smaller subtrees
		pos = offset[sl = rem];
	else if (pos >= offset[sl + 1]) {
		// used up sl-trees, try smaller ones
		if (!--sl) return;
		pos = offset[sl];
	}

	assemble(n, t<<(2*sl) | list[pos], sl, pos, rem - sl);
	assemble(n, t, sl, pos + 1, rem);
}

void mktrees(uint n)
{
	if (offset[n + 1]) return;
	if (n) mktrees(n - 1);

	assemble(n, 0, n-1, offset[n-1], n-1);
	offset[n+1] = len;
}

int main(int c, char**v)
{
	int n;
	if (c < 2 || (n = atoi(v[1])) <= 0 || n > 25) n = 5;

	// init 1-tree
	append(0);

	mktrees((uint)n);
	fprintf(stderr, "Number of %d-trees: %u\n", n, offset[n+1] - offset[n]);
	listtrees((uint)n);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a90(void);
int64_t function_100003b60(void);
int64_t function_100003bd8(void);
int64_t function_100003c70(void);
int64_t function_100003dc4(void);
int32_t function_100003f60(char * nptr);
int32_t function_100003f6c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f78(int32_t c);
int64_t * function_100003f84(int64_t * ptr, int32_t size);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000000; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x100008080
int32_t g3 = 0; // 0x100008088
int32_t g4 = 2; // 0x10000808c

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _putchar(int32_t a1);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003a90 - 0x100003b60
int64_t function_100003a90(void) {
    int32_t v1 = *(int32_t *)((int64_t)&g1 + 140); // 0x100003aa4
    int64_t v2; // 0x100003a90
    int64_t result; // 0x100003a90
    if (v1 == g3) {
        int32_t v3 = v1 == 0 ? 2 : 2 * v1;
        g3 = v3;
        int64_t v4 = (int64_t)_realloc((int64_t *)g2, 8 * v3); // 0x100003b18
        g2 = v4;
        v2 = v4;
        result = v4;
    } else {
        // 0x100003a90
        v2 = g2;
    }
    uint32_t v5 = g4; // 0x100003b40
    g4 = v5 + 1;
    int64_t v6; // 0x100003a90
    *(int64_t *)(8 * (int64_t)v5 + v2) = 2 * v6 | 1;
    return result;
}

// Address range: 0x100003b60 - 0x100003bd8
int64_t function_100003b60(void) {
    // 0x100003b60
    int64_t v1; // 0x100003b60
    int32_t v2 = v1; // 0x100003b70
    if (v2 == 0) {
        // 0x100003bcc
        int64_t result; // 0x100003b60
        return result;
    }
    int32_t v3 = v2; // 0x100003b8c
    v3--;
    int64_t v4; // 0x100003b60
    int32_t result2 = _putchar(v4 % 2 == 0 ? 41 : 40); // 0x100003bb4
    v4 /= 2;
    while (v3 != 0) {
        // 0x100003b94
        v3--;
        result2 = _putchar(v4 % 2 == 0 ? 41 : 40);
        v4 /= 2;
    }
    // 0x100003bcc
    return result2;
}

// Address range: 0x100003bd8 - 0x100003c70
int64_t function_100003bd8(void) {
    // 0x100003bd8
    int64_t v1; // 0x100003bd8
    int64_t v2 = 4 * v1; // 0x100003be8
    uint32_t v3 = *(int32_t *)((v2 & 0x3fffffffc) + (int64_t)&g1); // 0x100003bf8
    int32_t * v4 = (int32_t *)((v2 + 4 & 0xfffffffc) + (int64_t)&g1); // 0x100003c18
    if (v3 >= *v4) {
        // 0x100003c64
        int64_t result; // 0x100003bd8
        return result;
    }
    int32_t result2; // 0x100003c4c
    for (int32_t i = v3; i < *v4; i++) {
        // 0x100003c2c
        function_100003b60();
        result2 = _putchar(10);
    }
    // 0x100003c64
    return result2;
}

// Address range: 0x100003c70 - 0x100003dc4
int64_t function_100003c70(void) {
    // 0x100003c70
    int64_t v1; // 0x100003c70
    uint32_t v2 = (int32_t)v1; // 0x100003c8c
    if (v2 == 0) {
        // 0x100003db8
        return function_100003a90();
    }
    uint32_t v3 = (int32_t)v1; // 0x100003c84
    if (v3 == v2 || v3 < v2) {
        uint32_t v4 = *(int32_t *)((4 * v1 + 4 & 0xfffffffc) + (int64_t)&g1); // 0x100003d00
        if (v3 == 1 == v4 <= (int32_t)v1) {
            // 0x100003db8
            int64_t result; // 0x100003c70
            return result;
        }
    }
    // 0x100003d54
    function_100003c70();
    // 0x100003db8
    return function_100003c70();
}

// Address range: 0x100003dc4 - 0x100003e7c
int64_t function_100003dc4(void) {
    // 0x100003dc4
    int64_t v1; // 0x100003dc4
    int32_t * v2 = (int32_t *)((4 * v1 + 4 & 0xfffffffc) + (int64_t)&g1); // 0x100003de4
    if (*v2 != 0) {
        // 0x100003e70
        int64_t result; // 0x100003dc4
        return result;
    }
    if ((int32_t)v1 != 0) {
        // 0x100003e10
        function_100003dc4();
    }
    int64_t result2 = function_100003c70(); // 0x100003e50
    *v2 = g4;
    // 0x100003e70
    return result2;
}

// Address range: 0x100003e7c - 0x100003f60
int64_t entry_point(void) {
    // 0x100003e7c
    int64_t v1; // 0x100003e7c
    int32_t v2 = v1; // 0x100003e8c
    if (v2 < 2 == (1 - v2 & v2) < 0) {
        // 0x100003ea8
        _atoi((char *)*(int64_t *)(v1 + 8));
    }
    // 0x100003ee8
    function_100003a90();
    function_100003dc4();
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003f00
    _fprintf((struct _IO_FILE *)v3, "Number of %d-trees: %u\n", v1, (int32_t)v1);
    function_100003bd8();
    return 0;
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * nptr) {
    // 0x100003f60
    return _atoi(nptr);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f6c
    return _fprintf(stream, format);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(int32_t c) {
    // 0x100003f78
    return _putchar(c);
}

// Address range: 0x100003f84 - 0x100003f90
int64_t * function_100003f84(int64_t * ptr, int32_t size) {
    // 0x100003f84
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

enum { S_NONE, S_LIST, S_STRING, S_SYMBOL };

typedef struct {
	int type;
	size_t len;
	void *buf;
} s_expr, *expr;

void whine(const char *s)
{
	fprintf(stderr, "parse error before ==>%.10s\n", s);
}

expr parse_string(const char *s, char **e)
{
	expr ex = calloc(sizeof(s_expr), 1);
	char buf[256] = {0};
	int i = 0;

	while (*s) {
		if (i >= 256) {
			fprintf(stderr, "string too long:\n");
			whine(s);
			goto fail;
		}
		switch (*s) {
		case '\\':
			switch (*++s) {
			case '\\':
			case '"':	buf[i++] = *s++;
					continue;

			default:	whine(s);
					goto fail;
			}
		case '"':	goto success;
		default:	buf[i++] = *s++;
		}
	}
fail:
	free(ex);
	return 0;

success:
	*(const char **)e = s + 1;
	ex->type = S_STRING;
	ex->buf = strdup(buf);
	ex->len = strlen(buf);
	return ex;
}

expr parse_symbol(const char *s, char **e)
{
	expr ex = calloc(sizeof(s_expr), 1);
	char buf[256] = {0};
	int i = 0;

	while (*s) {
		if (i >= 256) {
			fprintf(stderr, "symbol too long:\n");
			whine(s);
			goto fail;
		}
		if (isspace(*s)) goto success;
		if (*s == ')' || *s == '(') {
			s--;
			goto success;
		}

		switch (*s) {
		case '\\':
			switch (*++s) {
			case '\\': case '"': case '(': case ')':
					buf[i++] = *s++;
					continue;
			default:	whine(s);
					goto fail;
			}
		case '"':	whine(s);
				goto success;
		default:	buf[i++] = *s++;
		}
	}
fail:
	free(ex);
	return 0;

success:
	*(const char **)e = s + 1;
	ex->type = S_SYMBOL;
	ex->buf = strdup(buf);
	ex->len = strlen(buf);
	return ex;
}

void append(expr list, expr ele)
{
	list->buf = realloc(list->buf, sizeof(expr) * ++list->len);
	((expr*)(list->buf))[list->len - 1] = ele;
}

expr parse_list(const char *s, char **e)
{
	expr ex = calloc(sizeof(s_expr), 1), chld;
	char *next;

	ex->len = 0;

	while (*s) {
		if (isspace(*s)) {
			s++;
			continue;
		}

		switch (*s) {
		case '"':
			chld = parse_string(s+1, &next);
			if (!chld) goto fail;
			append(ex, chld);
			s = next;
			continue;
		case '(':
			chld = parse_list(s+1, &next);
			if (!chld) goto fail;
			append(ex, chld);
			s = next;
			continue;
		case ')':
			goto success;

		default:
			chld = parse_symbol(s, &next);
			if (!chld) goto fail;
			append(ex, chld);
			s = next;
			continue;
		}
	}

fail:
	whine(s);
	free(ex);
	return 0;

success:
	*(const char **)e = s+1;
	ex->type = S_LIST;
	return ex;
}

expr parse_term(const char *s, char **e)
{
	while (*s) {
		if (isspace(*s)) {
			s++;
			continue;
		}
		switch(*s) {
		case '(':
			return parse_list(s+1, e);
		case '"':
			return parse_string(s+1, e);
		default:
			return parse_symbol(s+1, e);
		}
	}
	return 0;
}

void print_expr(expr e, int depth)
{
#define sep() for(i = 0; i < depth; i++) printf("    ")
	int i;
	if (!e) return;


	switch(e->type) {
	case S_LIST:
		sep();
		puts("(");
		for (i = 0; i < e->len; i++)
			print_expr(((expr*)e->buf)[i], depth + 1);
		sep();
		puts(")");
		return;
	case S_SYMBOL:
	case S_STRING:
		sep();
		if (e->type == S_STRING) putchar('"');
		for (i = 0; i < e->len; i++) {
			switch(((char*)e->buf)[i]) {
			case '"':
			case '\\':
				putchar('\\');
				break;
			case ')': case '(':
				if (e->type == S_SYMBOL)
					putchar('\\');
			}

			putchar(((char*)e->buf)[i]);
		}
		if (e->type == S_STRING) putchar('"');
		putchar('\n');
		return;
	}
}

int main()
{
	char *next;
	const char *in = "((data da\\(\\)ta \"quot\\\\ed data\" 123 4.5)\n"
			" (\"data\" (!@# (4.5) \"(mo\\\"re\" \"data)\")))";

	expr x = parse_term(in, &next);

	printf("input is:\n%s\n", in);
	printf("parsed as:\n");
	print_expr(x, 0);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000032f8(int64_t a1);
int64_t function_100003338(void);
int64_t function_100003558(void);
int64_t function_1000037f8(int64_t a1, int64_t a2);
int64_t function_100003860(void);
int64_t function_100003a38(void);
int64_t function_100003b24(void);
int64_t function_100003e58(void);
int64_t * function_100003e64(int32_t nmemb, int32_t size);
int32_t function_100003e70(struct _IO_FILE * stream, char * format, ...);
void function_100003e7c(int64_t * ptr);
int32_t function_100003e88(int32_t c);
int64_t * function_100003e94(int64_t * s, int32_t c, int32_t n);
int32_t function_100003ea0(char * format, ...);
int32_t function_100003eac(int32_t c);
int32_t function_100003eb8(char * s);
int64_t * function_100003ec4(int64_t * ptr, int32_t size);
char * function_100003ed0(char * s);
int32_t function_100003edc(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int32_t _isspace(int32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000032f8 - 0x100003338
int64_t function_1000032f8(int64_t a1) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003310
    int64_t v2; // 0x1000032f8
    return _fprintf((struct _IO_FILE *)v1, "parse error before ==>%.10s\n", (char *)v2);
}

// Address range: 0x100003338 - 0x100003558
int64_t function_100003338(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003350
    int64_t v2; // 0x100003338
    char * v3 = (char *)v2; // 0x100003358
    int64_t * v4 = _calloc(24, 1); // 0x100003368
    int64_t v5; // bp-296, 0x100003338
    _memset(&v5, 0, 256);
    char v6 = *v3; // 0x10000338c
    char v7; // 0x100003338
    char * v8; // 0x100003338
    char * v9; // 0x100003338
    int32_t v10; // 0x100003338
    uint32_t v11; // 0x100003338
    int64_t result; // 0x100003338
    if (v6 != 0) {
        int64_t v12 = (int64_t)v4; // 0x100003368
        int64_t v13 = &v5;
        v7 = v6;
        v8 = v3;
        v10 = 0;
        char * v14; // 0x100003338
        while (true) {
          lab_0x1000033a0:
            // 0x1000033a0
            v11 = v10;
            v14 = v8;
            if (v11 < 256 == (255 - v11 & v11) < 0) {
                // break -> 0x1000033b4
                break;
            }
            char v15 = v7;
            if (v15 == 34) {
                // 0x1000034c8
                *(int64_t *)v2 = (int64_t)v14 + 1;
                *(int32_t *)v4 = 2;
                *(int64_t *)(v12 + 16) = (int64_t)_strdup((char *)&v5);
                *(int64_t *)(v12 + 8) = (int64_t)_strlen((char *)&v5);
                result = v12;
                goto lab_0x100003518;
            }
            int64_t v16 = (int64_t)v14;
            int64_t v17 = v16 + 1;
            char * v18 = (char *)v17;
            if (v15 == 92) {
                char v19 = *v18; // 0x100003414
                switch (v19) {
                    case 92: {
                        // 0x100003440
                        *(char *)((int64_t)v11 + v13) = v19;
                        v9 = (char *)(v16 + 2);
                        goto lab_0x100003388;
                    }
                    case 34: {
                        // 0x100003440
                        *(char *)((int64_t)v11 + v13) = v19;
                        v9 = (char *)(v16 + 2);
                        goto lab_0x100003388;
                    }
                    default: {
                        // 0x100003470
                        function_1000032f8(v17);
                        // 0x1000034b8
                        _free(v4);
                        result = 0;
                        goto lab_0x100003518;
                    }
                }
            } else {
                // 0x100003480
                *(char *)((int64_t)v11 + v13) = v15;
                v9 = v18;
                goto lab_0x100003388;
            }
        }
        // 0x1000033b4
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010, "string too long:\n");
        function_1000032f8((int64_t)v14);
    }
    // 0x1000034b8
    _free(v4);
    result = 0;
    goto lab_0x100003518;
  lab_0x100003388:;
    char v20 = *v9; // 0x10000338c
    v7 = v20;
    v8 = v9;
    v10 = v11 + 1;
    if (v20 == 0) {
        // 0x1000034b8
        _free(v4);
        result = 0;
        goto lab_0x100003518;
    }
    goto lab_0x1000033a0;
  lab_0x100003518:
    // 0x100003518
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003540
        ___stack_chk_fail();
    }
    // 0x100003544
    return result;
}

// Address range: 0x100003558 - 0x1000037f8
int64_t function_100003558(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003570
    int64_t v2; // 0x100003558
    char * v3 = (char *)v2; // 0x100003578
    int64_t * v4 = _calloc(24, 1); // 0x100003588
    int64_t v5; // bp-296, 0x100003558
    _memset(&v5, 0, 256);
    char v6 = *v3; // 0x1000035ac
    char v7; // 0x100003558
    char * v8; // 0x100003558
    char * v9; // 0x100003558
    char * v10; // 0x100003558
    int32_t v11; // 0x100003558
    uint32_t v12; // 0x100003558
    int64_t result; // 0x100003558
    int64_t v13; // 0x100003588
    if (v6 != 0) {
        // 0x1000035c0
        v13 = (int64_t)v4;
        int64_t v14 = &v5;
        v7 = v6;
        v8 = v3;
        v11 = 0;
        char * v15; // 0x100003558
        while (true) {
          lab_0x1000035c0:
            // 0x1000035c0
            v12 = v11;
            v15 = v8;
            if (v12 < 256 == (255 - v12 & v12) < 0) {
                // break -> 0x1000035d4
                break;
            }
            // 0x1000035f8
            v10 = v15;
            if (_isspace((int32_t)v7) != 0) {
                goto lab_0x100003768;
            }
            char v16 = *v15; // 0x10000361c
            switch (v16) {
                case 41: {
                    // 0x100003648
                    v10 = (char *)((int64_t)v15 - 1);
                    goto lab_0x100003768;
                }
                case 40: {
                    // 0x100003648
                    v10 = (char *)((int64_t)v15 - 1);
                    goto lab_0x100003768;
                }
                case 34: {
                    // 0x100003714
                    function_1000032f8((int64_t)v15);
                    v10 = v15;
                    goto lab_0x100003768;
                }
                default: {
                    int64_t v17 = (int64_t)v15;
                    int64_t v18 = v17 + 1;
                    char * v19 = (char *)v18;
                    if (v16 == 92) {
                        char v20 = *v19; // 0x100003694
                        switch (v20) {
                            case 34: {
                                // 0x1000036d8
                                *(char *)((int64_t)v12 + v14) = v20;
                                v9 = (char *)(v17 + 2);
                                goto lab_0x1000035a8;
                            }
                            case 40: {
                                // 0x1000036d8
                                *(char *)((int64_t)v12 + v14) = v20;
                                v9 = (char *)(v17 + 2);
                                goto lab_0x1000035a8;
                            }
                            case 92: {
                                // 0x1000036d8
                                *(char *)((int64_t)v12 + v14) = v20;
                                v9 = (char *)(v17 + 2);
                                goto lab_0x1000035a8;
                            }
                            case 41: {
                                // 0x1000036d8
                                *(char *)((int64_t)v12 + v14) = v20;
                                v9 = (char *)(v17 + 2);
                                goto lab_0x1000035a8;
                            }
                            default: {
                                // 0x100003708
                                function_1000032f8(v18);
                                // 0x100003758
                                _free(v4);
                                result = 0;
                                goto lab_0x1000037b8;
                            }
                        }
                    } else {
                        // 0x100003720
                        *(char *)((int64_t)v12 + v14) = v16;
                        v9 = v19;
                        goto lab_0x1000035a8;
                    }
                }
            }
        }
        // 0x1000035d4
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010, "symbol too long:\n");
        function_1000032f8((int64_t)v15);
    }
    // 0x100003758
    _free(v4);
    result = 0;
    goto lab_0x1000037b8;
  lab_0x100003768:
    // 0x100003768
    *(int64_t *)v2 = (int64_t)v10 + 1;
    *(int32_t *)v4 = 3;
    *(int64_t *)(v13 + 16) = (int64_t)_strdup((char *)&v5);
    *(int64_t *)(v13 + 8) = (int64_t)_strlen((char *)&v5);
    result = v13;
    goto lab_0x1000037b8;
  lab_0x1000035a8:;
    char v21 = *v9; // 0x1000035ac
    v7 = v21;
    v8 = v9;
    v11 = v12 + 1;
    if (v21 == 0) {
        // 0x100003758
        _free(v4);
        result = 0;
        goto lab_0x1000037b8;
    }
    goto lab_0x1000035c0;
  lab_0x1000037b8:
    // 0x1000037b8
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x1000037e0
        ___stack_chk_fail();
    }
    // 0x1000037e4
    return result;
}

// Address range: 0x1000037f8 - 0x100003860
int64_t function_1000037f8(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)(a1 + 16); // 0x100003810
    int64_t * v2 = (int64_t *)(a1 + 8); // 0x100003818
    int64_t v3 = *v2 + 1; // 0x10000381c
    *v2 = v3;
    int64_t result = (int64_t)_realloc((int64_t *)*v1, 8 * (int32_t)v3); // 0x10000382c
    *v1 = result;
    *(int64_t *)(result - 8 + 8 * *v2) = a2;
    return result;
}

// Address range: 0x100003860 - 0x100003a38
int64_t function_100003860(void) {
    // 0x100003860
    int64_t v1; // 0x100003860
    char * v2 = (char *)v1; // bp-32, 0x10000386c
    int64_t * v3 = _calloc(24, 1); // 0x10000387c
    int64_t result = (int64_t)v3; // 0x10000387c
    *(int64_t *)(result + 8) = 0;
    char v4 = *v2; // 0x100003894
    char * v5 = v2; // 0x1000038a0
    if (v4 == 0) {
      lab_0x1000039e8_4:
        // 0x1000039e8
        function_1000032f8((int64_t)v5);
        _free(v3);
        // 0x100003a28
        return 0;
    }
    // 0x1000038a8
    char * v6; // bp-64, 0x100003860
    int64_t v7 = (int64_t)v6;
    char * v8 = v2;
    char v9 = v4; // 0x100003894
    char * v10; // 0x100003860
    char * v11; // 0x100003860
    while (true) {
      lab_0x1000038a8:
        // 0x1000038a8
        v11 = v8;
        if (_isspace((int32_t)v9) == 0) {
            // 0x1000038d4
            switch (*v11) {
                case 34: {
                    int64_t v12 = function_100003338(); // 0x100003924
                    v5 = v11;
                    if (v12 == 0) {
                        goto lab_0x1000039e8_4;
                    }
                    // 0x100003944
                    function_1000037f8(result, v12);
                    *(int64_t *)&v2 = v7;
                    v10 = v6;
                    goto lab_0x100003890;
                }
                case 40: {
                    int64_t v13 = function_100003860(); // 0x100003968
                    v5 = v11;
                    if (v13 == 0) {
                        goto lab_0x1000039e8_4;
                    }
                    // 0x100003988
                    function_1000037f8(result, v13);
                    *(int64_t *)&v2 = v7;
                    v10 = v6;
                    goto lab_0x100003890;
                }
                case 41: {
                    goto lab_0x100003a00;
                }
                default: {
                    int64_t v14 = function_100003558(); // 0x1000039ac
                    v5 = v11;
                    if (v14 == 0) {
                        goto lab_0x1000039e8_4;
                    }
                    // 0x1000039cc
                    function_1000037f8(result, v14);
                    *(int64_t *)&v2 = v7;
                    v10 = v6;
                    goto lab_0x100003890;
                }
            }
        } else {
            char * v15 = (char *)((int64_t)v11 + 1); // 0x1000038cc
            v2 = v15;
            v10 = v15;
            goto lab_0x100003890;
        }
    }
  lab_0x100003a00:
    // 0x100003a00
    *(int64_t *)v1 = (int64_t)v11 + 1;
    *(int32_t *)v3 = 1;
    // 0x100003a28
    return result;
  lab_0x100003890:
    // 0x100003890
    v8 = v10;
    v9 = *v8;
    v5 = v8;
    if (v9 == 0) {
        goto lab_0x1000039e8_4;
    }
    goto lab_0x1000038a8;
}

// Address range: 0x100003a38 - 0x100003b24
int64_t function_100003a38(void) {
    // 0x100003a38
    int64_t v1; // 0x100003a38
    char * v2 = (char *)v1;
    char v3 = *v2; // 0x100003a54
    if (v3 == 0) {
        // 0x100003b14
        return 0;
    }
    char * v4 = v2; // 0x100003a7c
    if (_isspace((int32_t)v3) == 0) {
      lab_0x100003a94:;
        // 0x100003a94
        int64_t result; // 0x100003a38
        switch (*v4) {
            case 34: {
                // 0x100003adc
                result = function_100003338();
                // break -> 0x100003b14
                break;
            }
            case 40: {
                // 0x100003ac4
                result = function_100003860();
                // break -> 0x100003b14
                break;
            }
            default: {
                // 0x100003af4
                result = function_100003558();
                // break -> 0x100003b14
                break;
            }
        }
        // 0x100003b14
        return result;
    }
    int64_t v5; // 0x100003a38
    int64_t v6 = v5 + 1;
    char * v7 = (char *)v6;
    char v8 = *v7; // 0x100003a54
    while (v8 != 0) {
        // 0x100003a68
        v4 = v7;
        if (_isspace((int32_t)v8) == 0) {
            goto lab_0x100003a94;
        }
        v6++;
        v7 = (char *)v6;
        v8 = *v7;
    }
    // 0x100003b14
    return 0;
}

// Address range: 0x100003b24 - 0x100003de4
int64_t function_100003b24(void) {
    int64_t result = 0; // 0x100003b44
    int64_t v1; // 0x100003b24
    if (v1 == 0) {
        // 0x100003dd8
        return result;
    }
    int32_t v2 = v1; // 0x100003b34
    int32_t v3 = v1;
    if (v3 == 1) {
        int32_t v4 = -v2;
        if (v4 < 0 != (v4 & v2) < 0) {
            _printf("    ");
            int32_t v5 = 1; // 0x100003bb8
            int32_t v6 = v5 - v2; // 0x100003b94
            int32_t v7 = v5; // 0x100003b9c
            while (v6 < 0 != ((v6 ^ v5) & (v5 ^ v2)) < 0) {
                // 0x100003ba4
                _printf("    ");
                v5 = v7 + 1;
                v6 = v5 - v2;
                v7 = v5;
            }
        }
        // 0x100003bc4
        _puts("(");
        int64_t * v8 = (int64_t *)(v1 + 8); // 0x100003be0
        if (*v8 != 0) {
            function_100003b24();
            int32_t v9 = 1; // 0x100003c18
            int32_t v10 = v9; // 0x100003bec
            while (*v8 > (int64_t)v9) {
                // 0x100003bf4
                function_100003b24();
                v9 = v10 + 1;
                v10 = v9;
            }
        }
        // 0x100003c2c
        if (v4 < 0 != (v4 & v2) < 0) {
            _printf("    ");
            int32_t v11 = 1; // 0x100003c58
            int32_t v12 = v11 - v2; // 0x100003c34
            int32_t v13 = v11; // 0x100003c3c
            while (v12 < 0 != ((v12 ^ v11) & (v11 ^ v2)) < 0) {
                // 0x100003c44
                _printf("    ");
                v11 = v13 + 1;
                v12 = v11 - v2;
                v13 = v11;
            }
        }
        // 0x100003dd8
        return _puts(")");
    }
    if (v3 != 3 && v3 != 2) {
        // 0x100003dd8
        return result;
    }
    int32_t v14 = -v2; // 0x100003c84
    int32_t v15 = 0; // 0x100003c8c
    if (v14 < 0 != (v14 & v2) < 0) {
        _printf("    ");
        v15++;
        while (v15 - v2 < 0 != ((v15 - v2 ^ v15) & (v15 ^ v2)) < 0) {
            // 0x100003c94
            _printf("    ");
            v15++;
        }
    }
    if (v3 == 2) {
        // 0x100003ccc
        _putchar(34);
    }
    int64_t * v16 = (int64_t *)(v1 + 8); // 0x100003ce8
    int64_t v17; // 0x100003b24
    int32_t v18; // 0x100003b24
    int64_t * v19; // 0x100003d00
    if (*v16 != 0) {
        // 0x100003cfc
        v19 = (int64_t *)(v1 + 16);
        v17 = 0;
        v18 = 0;
        while (true) {
          lab_0x100003cfc:;
            char v20 = *(char *)(*v19 + v17); // 0x100003d08
            if (v20 == 34) {
                // 0x100003d4c
                _putchar(92);
                goto lab_0x100003d80;
            } else {
                if (v20 == 41 || v20 == 40) {
                    if (v3 == 3) {
                        // 0x100003d70
                        _putchar(92);
                    }
                    goto lab_0x100003d80;
                } else {
                    if (v20 == 92) {
                        // 0x100003d4c
                        _putchar(92);
                        goto lab_0x100003d80;
                    } else {
                        goto lab_0x100003d80;
                    }
                }
            }
        }
    }
  lab_0x100003da8:
    if (v3 == 2) {
        // 0x100003dc0
        _putchar(34);
    }
    // 0x100003dd8
    return _putchar(10);
  lab_0x100003d80:
    // 0x100003d80
    _putchar((int32_t)*(char *)(*v19 + v17));
    int32_t v21 = v18 + 1; // 0x100003d9c
    int64_t v22 = v21; // 0x100003ce0
    v17 = v22;
    v18 = v21;
    if (*v16 <= v22) {
        // break -> 0x100003da8
        goto lab_0x100003da8;
    }
    goto lab_0x100003cfc;
}

// Address range: 0x100003de4 - 0x100003e58
int64_t entry_point(void) {
    // 0x100003de4
    function_100003a38();
    int64_t v1; // bp-32, 0x100003de4
    _printf("input is:\n%s\n", &v1);
    _printf("parsed as:\n");
    function_100003b24();
    return 0;
}

// Address range: 0x100003e58 - 0x100003e64
int64_t function_100003e58(void) {
    // 0x100003e58
    return ___stack_chk_fail();
}

// Address range: 0x100003e64 - 0x100003e70
int64_t * function_100003e64(int32_t nmemb, int32_t size) {
    // 0x100003e64
    return _calloc(nmemb, size);
}

// Address range: 0x100003e70 - 0x100003e7c
int32_t function_100003e70(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e70
    return _fprintf(stream, format);
}

// Address range: 0x100003e7c - 0x100003e88
void function_100003e7c(int64_t * ptr) {
    // 0x100003e7c
    _free(ptr);
}

// Address range: 0x100003e88 - 0x100003e94
int32_t function_100003e88(int32_t c) {
    // 0x100003e88
    return _isspace(c);
}

// Address range: 0x100003e94 - 0x100003ea0
int64_t * function_100003e94(int64_t * s, int32_t c, int32_t n) {
    // 0x100003e94
    return _memset(s, c, n);
}

// Address range: 0x100003ea0 - 0x100003eac
int32_t function_100003ea0(char * format, ...) {
    // 0x100003ea0
    return _printf(format);
}

// Address range: 0x100003eac - 0x100003eb8
int32_t function_100003eac(int32_t c) {
    // 0x100003eac
    return _putchar(c);
}

// Address range: 0x100003eb8 - 0x100003ec4
int32_t function_100003eb8(char * s) {
    // 0x100003eb8
    return _puts(s);
}

// Address range: 0x100003ec4 - 0x100003ed0
int64_t * function_100003ec4(int64_t * ptr, int32_t size) {
    // 0x100003ec4
    return _realloc(ptr, size);
}

// Address range: 0x100003ed0 - 0x100003edc
char * function_100003ed0(char * s) {
    // 0x100003ed0
    return _strdup(s);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(char * s) {
    // 0x100003edc
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 20

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <time.h>
#include <pthread.h>

#define N_BUCKETS 15

pthread_mutex_t bucket_mutex[N_BUCKETS];
int buckets[N_BUCKETS];

pthread_t equalizer;
pthread_t randomizer;

void transfer_value(int from, int to, int howmuch)
{
  bool swapped = false;

  if ( (from == to) || ( howmuch < 0 ) ||
       (from < 0 ) || (to < 0) || (from >= N_BUCKETS) || (to >= N_BUCKETS) ) return;

  if ( from > to ) {
    int temp1 = from;
    from = to;
    to = temp1;
    swapped = true;
    howmuch = -howmuch;
  }

  pthread_mutex_lock(&bucket_mutex[from]);
  pthread_mutex_lock(&bucket_mutex[to]);

  if ( howmuch > buckets[from] && !swapped )
    howmuch = buckets[from];
  if ( -howmuch > buckets[to] && swapped )
    howmuch = -buckets[to];

  buckets[from] -= howmuch;
  buckets[to] += howmuch;

  pthread_mutex_unlock(&bucket_mutex[from]);
  pthread_mutex_unlock(&bucket_mutex[to]);
}

void print_buckets()
{
  int i;
  int sum=0;

  for(i=0; i < N_BUCKETS; i++) pthread_mutex_lock(&bucket_mutex[i]);
  for(i=0; i < N_BUCKETS; i++) {
    printf("%3d ", buckets[i]);
    sum += buckets[i];
  }
  printf("= %d\n", sum);
  for(i=0; i < N_BUCKETS; i++) pthread_mutex_unlock(&bucket_mutex[i]);
}

void *equalizer_start(void *t)
{
  for(;;) {
    int b1 = rand()%N_BUCKETS;
    int b2 = rand()%N_BUCKETS;
    int diff = buckets[b1] - buckets[b2];
    if ( diff < 0 )
      transfer_value(b2, b1, -diff/2);
    else
      transfer_value(b1, b2, diff/2);
  }
  return NULL;
}

void *randomizer_start(void *t)
{
  for(;;) {
    int b1 = rand()%N_BUCKETS;
    int b2 = rand()%N_BUCKETS;
    int diff = rand()%(buckets[b1]+1);
    transfer_value(b1, b2, diff);
  }
  return NULL;
}

int main()
{
  int i, total=0;

  for(i=0; i < N_BUCKETS; i++) pthread_mutex_init(&bucket_mutex[i], NULL);

  for(i=0; i < N_BUCKETS; i++) {
    buckets[i] = rand() % 100;
    total += buckets[i];
    printf("%3d ", buckets[i]);
  }
  printf("= %d\n", total);

  // we should check if these succeeded
  pthread_create(&equalizer, NULL, equalizer_start, NULL);
  pthread_create(&randomizer, NULL, randomizer_start, NULL);

  for(;;) {
    sleep(1);
    print_buckets();
  }

  // we do not provide a "good" way to stop this run, so the following
  // is never reached indeed...
  for(i=0; i < N_BUCKETS; i++) pthread_mutex_destroy(bucket_mutex+i);
  return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000395c(void);
int64_t function_100003b80(void);
int64_t function_100003cb4(void);
int64_t function_100003d74(void);
int32_t function_100003f48(char * format, ...);
int32_t function_100003f54(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg);
int32_t function_100003f60(int64_t * mutex, int64_t * mutexattr);
int32_t function_100003f6c(int64_t * mutex);
int32_t function_100003f78(int64_t * mutex);
int32_t function_100003f84(void);
int32_t function_100003f90(int32_t seconds);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int32_t * g2 = NULL; // 0x1000083c0
int32_t * g3 = (int32_t *)100; // 0x100008408

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _pthread_create(int32_t * a1, int64_t * a2, int64_t * (*a3)(int64_t *), int64_t * a4);
int32_t _pthread_mutex_init(int64_t * a1, int64_t * a2);
int32_t _pthread_mutex_lock(int64_t * a1);
int32_t _pthread_mutex_unlock(int64_t * a1);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x10000395c - 0x100003b80
int64_t function_10000395c(void) {
    // 0x10000395c
    int64_t v1; // 0x10000395c
    int32_t v2 = v1; // 0x100003968
    int32_t v3 = v1; // 0x10000396c
    int32_t v4 = v1; // 0x100003970
    int64_t result; // 0x10000395c
    if (v3 < 0 || v2 < 0 || v4 < 0 || v2 == v3) {
        // 0x100003b74
        return result;
    }
    if (v2 < 15 == (14 - v2 & v2) < 0) {
        // 0x100003b74
        return result;
    }
    if (v3 < 15 != (14 - v3 & v3) < 0) {
        int32_t v5 = v2 - v3; // 0x100003a00
        bool v6 = v5 == 0 | v5 < 0 != ((v5 ^ v2) & (int32_t)(v1 ^ v1)) < 0; // 0x100003a04
        int32_t v7 = v6 ? v4 : -v4;
        int64_t v8 = 0x100000000 * (v6 ? v1 : v1);
        int64_t * v9 = (int64_t *)((v8 >> 26) + (int64_t)&g1); // 0x100003a58
        _pthread_mutex_lock(v9);
        int64_t v10 = 0x100000000 * (v6 ? v1 : v1);
        int64_t * v11 = (int64_t *)((v10 >> 26) + (int64_t)&g1); // 0x100003a68
        _pthread_mutex_lock(v11);
        int32_t * v12 = (int32_t *)((v8 >> 30) + (int64_t)&g2); // 0x100003a7c
        int32_t v13 = *v12; // 0x100003a7c
        int32_t v14 = v7 - v13; // 0x100003a80
        int32_t v15 = v6 == v14 != 0 == v14 < 0 == ((v14 ^ v7) & (v13 ^ v7)) < 0 ? v13 : v7;
        int32_t v16 = -v15; // 0x100003abc
        int32_t * v17 = (int32_t *)((v10 >> 30) + (int64_t)&g2); // 0x100003acc
        int32_t v18 = *v17; // 0x100003acc
        int32_t v19 = v16 - v18; // 0x100003ad0
        int32_t v20 = v6 | v19 == 0 | v19 < 0 != ((v19 ^ v16) & (v18 ^ v16)) < 0 ? v15 : -v18;
        *v12 = v13 - v20;
        *v17 = v20 + *v17;
        _pthread_mutex_unlock(v9);
        result = _pthread_mutex_unlock(v11);
    }
    // 0x100003b74
    return result;
}

// Address range: 0x100003b80 - 0x100003cb4
int64_t function_100003b80(void) {
    int64_t v1 = 0;
    _pthread_mutex_lock((int64_t *)(64 * v1 + (int64_t)&g1));
    v1++;
    int32_t v2 = 0; // 0x100003ba4
    while (v1 != 15) {
        // 0x100003bac
        _pthread_mutex_lock((int64_t *)(64 * v1 + (int64_t)&g1));
        v1++;
        v2 = 0;
    }
    int64_t v3; // 0x100003b80
    _printf("%3d ", v3);
    int32_t v4 = v2 + 1; // 0x100003c3c
    v2 = v4;
    while (v4 != 15) {
        // 0x100003bf0
        _printf("%3d ", v3);
        v4 = v2 + 1;
        v2 = v4;
    }
    // 0x100003c48
    _printf("= %d\n", v3);
    int32_t result; // 0x100003c90
    for (int64_t i = 0; i < 15; i++) {
        // 0x100003c80
        result = _pthread_mutex_unlock((int64_t *)(64 * i + (int64_t)&g1));
    }
    // 0x100003ca8
    return result;
}

// Address range: 0x100003cb4 - 0x100003d74
int64_t function_100003cb4(void) {
    while (true) {
        // 0x100003cc8
        _rand();
        _rand();
        function_10000395c();
    }
}

// Address range: 0x100003d74 - 0x100003df8
int64_t function_100003d74(void) {
    while (true) {
        // 0x100003d88
        _rand();
        _rand();
        _rand();
        function_10000395c();
    }
}

// Address range: 0x100003df8 - 0x100003f48
int64_t entry_point(void) {
    int64_t v1 = 0;
    _pthread_mutex_init((int64_t *)(64 * v1 + (int64_t)&g1), NULL);
    v1++;
    int64_t v2 = 0; // 0x100003e20
    while (v1 != 15) {
        // 0x100003e28
        _pthread_mutex_init((int64_t *)(64 * v1 + (int64_t)&g1), NULL);
        v1++;
        v2 = 0;
    }
    *(int32_t *)(4 * v2 + (int64_t)&g2) = _rand() % 100;
    _printf("%3d ", 0);
    int64_t v3 = v2 + 1;
    v2 = v3;
    while (v3 != 15) {
        // 0x100003e70
        *(int32_t *)(4 * v2 + (int64_t)&g2) = _rand() % 100;
        _printf("%3d ", 0);
        v3 = v2 + 1;
        v2 = v3;
    }
    // 0x100003edc
    _printf("= %d\n", 0);
    _pthread_create((int32_t *)"/lib/dyld", NULL, (int64_t * (*)(int64_t *))0x100003cb4, NULL);
    _pthread_create((int32_t *)&g3, NULL, (int64_t * (*)(int64_t *))0x100003d74, NULL);
    while (true) {
        // 0x100003f38
        _sleep(1);
        function_100003b80();
    }
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg) {
    // 0x100003f54
    return _pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int64_t * mutex, int64_t * mutexattr) {
    // 0x100003f60
    return _pthread_mutex_init(mutex, mutexattr);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(int64_t * mutex) {
    // 0x100003f6c
    return _pthread_mutex_lock(mutex);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(int64_t * mutex) {
    // 0x100003f78
    return _pthread_mutex_unlock(mutex);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(void) {
    // 0x100003f84
    return _rand();
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(int32_t seconds) {
    // 0x100003f90
    return _sleep(seconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <math.h>
#include <stdint.h>
#include <stdio.h>

static uint64_t state;
static const uint64_t STATE_MAGIC = 0x2545F4914F6CDD1D;

void seed(uint64_t num) {
    state = num;
}

uint32_t next_int() {
    uint64_t x;
    uint32_t answer;

    x = state;
    x = x ^ (x >> 12);
    x = x ^ (x << 25);
    x = x ^ (x >> 27);
    state = x;
    answer = ((x * STATE_MAGIC) >> 32);

    return answer;
}

float next_float() {
    return (float)next_int() / (1LL << 32);
}

int main() {
    int counts[5] = { 0, 0, 0, 0, 0 };
    int i;

    seed(1234567);
    printf("%u\n", next_int());
    printf("%u\n", next_int());
    printf("%u\n", next_int());
    printf("%u\n", next_int());
    printf("%u\n", next_int());
    printf("\n");

    seed(987654321);
    for (i = 0; i < 100000; i++) {
        int j = (int)floor(next_float() * 5.0);
        counts[j]++;
    }
    for (i = 0; i < 5; i++) {
        printf("%d: %d\n", i, counts[i]);
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ce8(void);
int64_t function_100003d04(void);
int64_t function_100003d78(int64_t a1);
int64_t function_100003f78(void);
int32_t function_100003f84(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ce8 - 0x100003d04
int64_t function_100003ce8(void) {
    // 0x100003ce8
    int64_t result; // 0x100003ce8
    return result;
}

// Address range: 0x100003d04 - 0x100003d78
int64_t function_100003d04(void) {
    uint64_t v1 = g1; // 0x100003d0c
    int64_t v2 = v1 / 0x1000 ^ v1; // 0x100003d1c
    uint64_t v3 = 0x2000000 * v2 ^ v2; // 0x100003d2c
    int64_t v4 = v3 / 0x8000000 ^ v3; // 0x100003d3c
    g1 = v4;
    return 0x2545f4914f6cdd1d * v4 / 0x100000000;
}

// Address range: 0x100003d78 - 0x100003d9c
int64_t function_100003d78(int64_t a1) {
    // 0x100003d78
    return function_100003d04();
}

// Address range: 0x100003d9c - 0x100003f78
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003db0
    int64_t v2 = 0; // bp-48, 0x100003dbc
    function_100003ce8();
    function_100003d04();
    int64_t v3; // 0x100003d9c
    int32_t v4 = v3; // 0x100003df0
    _printf("%u\n", v4);
    function_100003d04();
    _printf("%u\n", v4);
    function_100003d04();
    _printf("%u\n", v4);
    function_100003d04();
    _printf("%u\n", v4);
    function_100003d04();
    _printf("%u\n", v4);
    _printf("\n");
    function_100003ce8();
    int64_t v5 = &v2;
    int32_t v6 = 0;
    function_100003d78((int64_t)v6);
    float32_t v7; // 0x100003d9c
    int32_t * v8 = (int32_t *)(4 * (int64_t)__asm_fcvtms(5.0 * (float64_t)v7) + v5); // 0x100003ec4
    *v8 = *v8 + 1;
    int32_t v9 = v6 + 1; // 0x100003ed8
    int32_t v10 = 0; // 0x100003e98
    while (v6 < 0x1869f != (0x1869e - v6 & v9) < 0) {
        // 0x100003ea0
        v6 = v9;
        function_100003d78((int64_t)v6);
        v8 = (int32_t *)(4 * (int64_t)__asm_fcvtms(5.0 * (float64_t)v7) + v5);
        *v8 = *v8 + 1;
        v9 = v6 + 1;
        v10 = 0;
    }
    _printf("%d: %d\n", v3, v3);
    int32_t v11 = v10 + 1; // 0x100003f38
    v10 = v11;
    while (v11 != 5) {
        // 0x100003f00
        _printf("%d: %d\n", v3, v3);
        v11 = v10 + 1;
        v10 = v11;
    }
    // 0x100003f44
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f64
        ___stack_chk_fail();
    }
    // 0x100003f68
    return 0;
}

// Address range: 0x100003f78 - 0x100003f84
int64_t function_100003f78(void) {
    // 0x100003f78
    return ___stack_chk_fail();
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

int pancake(int n) {
    int gap = 2, sum = 2, adj = -1;
    while (sum < n) {
        adj++;
        gap = gap * 2 - 1;
        sum += gap;
    }
    return n + adj;
}

int main() {
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 1; j < 6; j++) {
            int n = i * 5 + j;
            printf("p(%2d) = %2d  ", n, pancake(n));
        }
        printf("\n");
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e28(void);
int32_t function_100003f80(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e28 - 0x100003ea4
int64_t function_100003e28(void) {
    // 0x100003e28
    int64_t v1; // 0x100003e28
    int32_t v2 = v1; // 0x100003e2c
    int32_t v3 = 2 - v2; // 0x100003e50
    int32_t v4 = -1; // 0x100003e58
    int32_t v5 = 2; // 0x100003e58
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e90
        return v2 - 1;
    }
    int32_t v6 = 2; // 0x100003e58
    v4++;
    v6 = 2 * v6 - 1;
    v5 += v6;
    int32_t v7 = v5 - v2; // 0x100003e50
    while (v7 < 0 != ((v7 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003e60
        v4++;
        v6 = 2 * v6 - 1;
        v5 += v6;
        v7 = v5 - v2;
    }
    // 0x100003e90
    return v4 + v2;
}

// Address range: 0x100003ea4 - 0x100003f80
int64_t entry_point(void) {
    for (int32_t i = 0; i < 4; i++) {
        for (int32_t j = 1; j < 6; j++) {
            // 0x100003ef0
            function_100003e28();
            int64_t v1; // 0x100003ea4
            _printf("p(%2d) = %2d  ", v1, v1);
        }
        // 0x100003f50
        _printf((char *)0x100003f9b);
    }
    // 0x100003f70
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

int max (int *a, int n, int i, int j, int k) {
    int m = i;
    if (j < n && a[j] > a[m]) {
        m = j;
    }
    if (k < n && a[k] > a[m]) {
        m = k;
    }
    return m;
}

void downheap (int *a, int n, int i) {
    while (1) {
        int j = max(a, n, i, 2 * i + 1, 2 * i + 2);
        if (j == i) {
            break;
        }
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
        i = j;
    }
}

void heapsort (int *a, int n) {
    int i;
    for (i = (n - 2) / 2; i >= 0; i--) {
        downheap(a, n, i);
    }
    for (i = 0; i < n; i++) {
        int t = a[n - i - 1];
        a[n - i - 1] = a[0];
        a[0] = t;
        downheap(a, n - i - 1, 0);
    }
}

int main () {
    int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};
    int n = sizeof a / sizeof a[0];
    int i;
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    heapsort(a, n);
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b30(void);
int64_t function_100003bf4(void);
int64_t function_100003cac(void);
int64_t function_100003f48(int64_t a1);
int64_t * function_100003f54(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f60(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4100000004; // 0x100003f6c

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b30 - 0x100003bf4
int64_t function_100003b30(void) {
    // 0x100003b30
    int64_t v1; // 0x100003b30
    int32_t v2 = v1; // 0x100003b38
    int32_t v3 = v1; // 0x100003b3c
    int32_t v4 = v1; // 0x100003b40
    int32_t v5 = v4 - v2; // 0x100003b58
    int32_t v6 = v3; // 0x100003b60
    if (v5 < 0 != ((v5 ^ v4) & (int32_t)(v1 ^ v1)) < 0) {
        int32_t v7 = *(int32_t *)(v1 + (0x100000000 * v1 >> 30)); // 0x100003b70
        int32_t v8 = *(int32_t *)(v1 + (0x100000000 * v1 >> 30)); // 0x100003b7c
        int32_t v9 = v7 - v8; // 0x100003b80
        v6 = v9 == 0 | v9 < 0 != ((v9 ^ v7) & (v8 ^ v7)) < 0 ? v3 : v4;
    }
    int32_t v10 = v1; // 0x100003b44
    int32_t v11 = v10 - v2; // 0x100003ba4
    int32_t result = v6; // 0x100003bac
    if (v11 < 0 != ((v11 ^ v10) & (int32_t)(v1 ^ v1)) < 0) {
        int32_t v12 = *(int32_t *)(v1 + (0x100000000 * v1 >> 30)); // 0x100003bbc
        int32_t v13 = *(int32_t *)(4 * (int64_t)v6 + v1); // 0x100003bc8
        int32_t v14 = v12 - v13; // 0x100003bcc
        result = v14 == 0 | v14 < 0 != ((v14 ^ v12) & (v13 ^ v12)) < 0 ? v6 : v10;
    }
    // 0x100003be8
    return result;
}

// Address range: 0x100003bf4 - 0x100003cac
int64_t function_100003bf4(void) {
    // 0x100003bf4
    int64_t v1; // 0x100003bf4
    int32_t v2 = v1; // 0x100003c08
    int64_t result = function_100003b30(); // 0x100003c38
    int32_t v3 = result; // 0x100003c3c
    if (v2 == v3) {
        // 0x100003ca0
        return result;
    }
    int32_t v4 = v3;
    int32_t * v5 = (int32_t *)(4 * (int64_t)v2 + v1); // 0x100003c64
    int32_t * v6 = (int32_t *)((0x100000000 * result >> 30) + v1); // 0x100003c74
    *v5 = *v6;
    *v6 = *v5;
    int64_t result2 = function_100003b30(); // 0x100003c38
    int32_t v7 = result2; // 0x100003c3c
    while (v4 != v7) {
        int32_t v8 = v4;
        v4 = v7;
        v5 = (int32_t *)(4 * (int64_t)v8 + v1);
        v6 = (int32_t *)((0x100000000 * result2 >> 30) + v1);
        *v5 = *v6;
        *v6 = *v5;
        result2 = function_100003b30();
        v7 = result2;
    }
    // 0x100003ca0
    return result2;
}

// Address range: 0x100003cac - 0x100003db4
int64_t function_100003cac(void) {
    // 0x100003cac
    int64_t v1; // 0x100003cac
    int32_t v2 = v1; // 0x100003cbc
    int32_t v3 = v2 - 2; // 0x100003cc8
    int64_t result; // 0x100003cac
    if (v3 >= 0xffffffff) {
        int32_t v4 = v3 / 2;
        result = function_100003bf4();
        int32_t v5 = v4 - 1; // 0x100003ce4
        while (v4 >= 1) {
            // 0x100003cec
            v4 = v5;
            result = function_100003bf4();
            v5 = v4 - 1;
        }
    }
    int32_t v6 = -v2; // 0x100003d20
    if (v6 < 0 == (v6 & v2) < 0) {
        // 0x100003da8
        return result;
    }
    int32_t v7 = 0; // 0x100003d28
    int32_t * v8 = (int32_t *)(v1 + (int64_t)(4 * ((v7 ^ 0x3fffffff) + v2))); // 0x100003d44
    *v8 = (int32_t)result;
    *(int32_t *)v1 = *v8;
    int64_t result2 = function_100003bf4(); // 0x100003d90
    v7++;
    int32_t v9 = v7 - v2; // 0x100003d20
    while (v9 < 0 != ((v9 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x100003d30
        v8 = (int32_t *)(v1 + (int64_t)(4 * ((v7 ^ 0x3fffffff) + v2)));
        *v8 = (int32_t)result2;
        *(int32_t *)v1 = *v8;
        result2 = function_100003bf4();
        v7++;
        v9 = v7 - v2;
    }
    // 0x100003da8
    return result2;
}

// Address range: 0x100003db4 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003db4
    int64_t v1; // bp-64, 0x100003db4
    _memcpy(&v1, &g1, 40);
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003e10
        _printf("%d%s", (int64_t)&g1, (char *)40);
    }
    // 0x100003e7c
    function_100003cac();
    int32_t v2; // 0x100003efc
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003ea8
        v2 = _printf("%d%s", 10, (char *)40);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f20
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f34
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f38
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int64_t function_100003f48(int64_t a1) {
    // 0x100003f48
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f54 - 0x100003f60
int64_t * function_100003f54(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f54
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdbool.h>
#include <stdio.h>

#define MAX_WORD 80
#define LETTERS 26

bool is_letter(char c) { return c >= 'a' && c <= 'z'; }

int index(char c) { return c - 'a'; }

void word_wheel(const char* letters, char central, int min_length, FILE* dict) {
    int max_count[LETTERS] = { 0 };
    for (const char* p = letters; *p; ++p) {
        char c = *p;
        if (is_letter(c))
            ++max_count[index(c)];
    }
    char word[MAX_WORD + 1] = { 0 };
    while (fgets(word, MAX_WORD, dict)) {
        int count[LETTERS] = { 0 };
        for (const char* p = word; *p; ++p) {
            char c = *p;
            if (c == '\n') {
                if (p >= word + min_length && count[index(central)] > 0)
                    printf("%s", word);
            } else if (is_letter(c)) {
                int i = index(c);
                if (++count[i] > max_count[i]) {
                    break;
                }
            } else {
                break;
            }
        }
    }
}

int main(int argc, char** argv) {
    const char* dict = argc == 2 ? argv[1] : "unixdict.txt";
    FILE* in = fopen(dict, "r");
    if (in == NULL) {
        perror(dict);
        return 1;
    }
    word_wheel("ndeokgelw", 'k', 3, in);
    fclose(in);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bb8(void);
int64_t function_100003c00(void);
int64_t function_100003c18(void);
int64_t function_100003f28(void);
int32_t function_100003f34(struct _IO_FILE * stream);
char * function_100003f40(char * s, int32_t n, struct _IO_FILE * stream);
struct _IO_FILE * function_100003f4c(char * filename, char * modes);
int64_t * function_100003f58(int64_t * s, int32_t c, int32_t n);
void function_100003f64(char * s);
int32_t function_100003f70(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _fclose(struct _IO_FILE * a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
struct _IO_FILE * _fopen(char * a1, char * a2);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
void _perror(char * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bb8 - 0x100003c00
int64_t function_100003bb8(void) {
    // 0x100003bb8
    int64_t v1; // 0x100003bb8
    char v2 = v1; // 0x100003bbc
    int32_t v3 = v2; // 0x100003bbc
    int64_t result = 0; // 0x100003bd4
    if (v2 < 97 == (96 - v3 & v3) < 0) {
        int32_t v4 = v3 - 122; // 0x100003be0
        result = v4 == 0 | v4 < 0 != (121 - v3 & v3) < 0;
    }
    // 0x100003bf0
    return result;
}

// Address range: 0x100003c00 - 0x100003c18
int64_t function_100003c00(void) {
    // 0x100003c00
    int64_t v1; // 0x100003c00
    return (0x1000000 * (int32_t)v1 >> 24) - 97;
}

// Address range: 0x100003c18 - 0x100003e60
int64_t function_100003c18(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c30
    int64_t v2; // bp-144, 0x100003c18
    _memset(&v2, 0, 104);
    int64_t v3; // 0x100003c18
    if (*(char *)v3 != 0) {
        int64_t v4 = &v2;
        int32_t * v5; // 0x100003ca8
        if (function_100003bb8() % 2 != 0) {
            // 0x100003c98
            v5 = (int32_t *)((0x100000000 * function_100003c00() >> 30) + v4);
            *v5 = *v5 + 1;
        }
        // 0x100003cbc
        int64_t v6; // 0x100003c18
        int64_t v7 = v6 + 1; // 0x100003cc0
        v6 = v7;
        while (*(char *)v7 != 0) {
            // 0x100003c7c
            if (function_100003bb8() % 2 != 0) {
                // 0x100003c98
                v5 = (int32_t *)((0x100000000 * function_100003c00() >> 30) + v4);
                *v5 = *v5 + 1;
            }
            // 0x100003cbc
            v7 = v6 + 1;
            v6 = v7;
        }
    }
    struct _IO_FILE * v8 = (struct _IO_FILE *)v3; // 0x100003c44
    int64_t v9; // bp-225, 0x100003c18
    _memset(&v9, 0, 81);
    if (_fgets((char *)&v9, 80, v8) != NULL) {
        // 0x100003d00
        int64_t v10; // bp-332, 0x100003c18
        int64_t v11 = &v10;
        while (true) {
            // 0x100003d00
            _memset(&v10, 0, 104);
            char * v12 = (char *)&v9; // 0x100003d18
            while (true) {
              lab_0x100003d1c:;
                char * v13 = v12;
                switch (*v13) {
                    case 0: {
                        goto lab_0x100003e28;
                    }
                    case 10: {
                        int64_t v14 = (int64_t)v13;
                        if ((0x100000000 * v3 >> 32) + (int64_t)&v9 <= v14) {
                            // 0x100003d74
                            if (*(int32_t *)((4 * function_100003c00() & 0xfffffffc) + v11) >= 1) {
                                // 0x100003d94
                                _printf("%s", NULL);
                            }
                        }
                        // 0x100003e18
                        v12 = (char *)(v14 + 1);
                        goto lab_0x100003d1c;
                    }
                    default: {
                        // 0x100003db4
                        if (function_100003bb8() % 2 == 0) {
                            // break -> 0x100003e28
                            break;
                        }
                        int64_t v15 = 0x100000000 * function_100003c00() >> 30; // 0x100003dd8
                        int32_t * v16 = (int32_t *)(v15 + v11); // 0x100003ddc
                        int32_t v17 = *v16 + 1; // 0x100003de0
                        *v16 = v17;
                        int32_t v18 = *(int32_t *)(v15 + (int64_t)&v2); // 0x100003df0
                        int32_t v19 = v17 - v18; // 0x100003df4
                        if (v19 != 0 && v19 < 0 == ((v19 ^ v17) & (v18 ^ v17)) < 0) {
                            // break -> 0x100003e28
                            break;
                        }
                        // 0x100003e18
                        v12 = (char *)((int64_t)v13 + 1);
                        goto lab_0x100003d1c;
                    }
                }
            }
          lab_0x100003e28:
            // 0x100003e28
            if (_fgets((char *)&v9, 80, v8) == NULL) {
                // break -> 0x100003e2c
                break;
            }
        }
    }
    int64_t result = 0; // 0x100003e44
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e4c
        result = ___stack_chk_fail();
    }
    // 0x100003e50
    return result;
}

// Address range: 0x100003e60 - 0x100003f28
int64_t entry_point(void) {
    char * v1 = "unixdict.txt"; // 0x100003e84
    int64_t v2; // 0x100003e60
    if ((int32_t)v2 == 2) {
        // 0x100003e8c
        v1 = (char *)*(int64_t *)(v2 + 8);
    }
    struct _IO_FILE * v3 = _fopen(v1, "r"); // 0x100003ec0
    int64_t result; // 0x100003e60
    if (v3 == NULL) {
        // 0x100003edc
        _perror(v1);
        result = 1;
    } else {
        // 0x100003ef0
        function_100003c18();
        _fclose(v3);
        result = 0;
    }
    // 0x100003f18
    return result;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(void) {
    // 0x100003f28
    return ___stack_chk_fail();
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(struct _IO_FILE * stream) {
    // 0x100003f34
    return _fclose(stream);
}

// Address range: 0x100003f40 - 0x100003f4c
char * function_100003f40(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003f40
    return _fgets(s, n, stream);
}

// Address range: 0x100003f4c - 0x100003f58
struct _IO_FILE * function_100003f4c(char * filename, char * modes) {
    // 0x100003f4c
    return _fopen(filename, modes);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t * function_100003f58(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f58
    return _memset(s, c, n);
}

// Address range: 0x100003f64 - 0x100003f70
void function_100003f64(char * s) {
    // 0x100003f64
    _perror(s);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct philData {
    pthread_mutex_t *fork_lft, *fork_rgt;
    const char *name;
    pthread_t thread;
    int   fail;
} Philosopher;

int running = 1;

void *PhilPhunction(void *p) {
    Philosopher *phil = (Philosopher*)p;
    int failed;
    int tries_left;
    pthread_mutex_t *fork_lft, *fork_rgt, *fork_tmp;

    while (running) {
        printf("%s is sleeping --er thinking\n", phil->name);
        sleep( 1+ rand()%8);

        fork_lft = phil->fork_lft;
        fork_rgt = phil->fork_rgt;
        printf("%s is hungry\n", phil->name);
        tries_left = 2;   /* try twice before being forceful */
        do {
            failed = pthread_mutex_lock( fork_lft);
            failed = (tries_left>0)? pthread_mutex_trylock( fork_rgt )
                                   : pthread_mutex_lock(fork_rgt);
            if (failed) {
                pthread_mutex_unlock( fork_lft);
                fork_tmp = fork_lft;
                fork_lft = fork_rgt;
                fork_rgt = fork_tmp;
                tries_left -= 1;
            }
        } while(failed && running);

        if (!failed) {
            printf("%s is eating\n", phil->name);
            sleep( 1+ rand() % 8);
            pthread_mutex_unlock( fork_rgt);
            pthread_mutex_unlock( fork_lft);
        }
    }
    return NULL;
}

void Ponder()
{
    const char *nameList[] = { "Kant", "Guatma", "Russel", "Aristotle", "Bart" };
    pthread_mutex_t forks[5];
    Philosopher philosophers[5];
    Philosopher *phil;
    int i;
    int failed;

    for (i=0;i<5; i++) {
        failed = pthread_mutex_init(&forks[i], NULL);
        if (failed) {
            printf("Failed to initialize mutexes.");
            exit(1);
        }
    }

    for (i=0;i<5; i++) {
        phil = &philosophers[i];
        phil->name = nameList[i];
        phil->fork_lft = &forks[i];
        phil->fork_rgt = &forks[(i+1)%5];
        phil->fail = pthread_create( &phil->thread, NULL, PhilPhunction, phil);
    }

    sleep(40);
    running = 0;
    printf("cleanup time\n");

    for(i=0; i<5; i++) {
        phil = &philosophers[i];
        if ( !phil->fail && pthread_join( phil->thread, NULL) ) {
            printf("error joining thread for %s", phil->name);
            exit(1);
        }
    }
}

int main()
{
    Ponder();
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039f4(void);
int64_t function_100003be4(void);
int64_t function_100003e6c(void);
void function_100003e78(int32_t status);
int64_t * function_100003e84(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003e90(char * format, ...);
int32_t function_100003e9c(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg);
int32_t function_100003ea8(int32_t th, int64_t ** thread_return);
int32_t function_100003eb4(int64_t * mutex, int64_t * mutexattr);
int32_t function_100003ec0(int64_t * mutex);
int32_t function_100003ecc(int64_t * mutex);
int32_t function_100003ed8(int64_t * mutex);
int32_t function_100003ee4(void);
int32_t function_100003ef0(int32_t seconds);

// --------------------- Global Variables ---------------------

int32_t * g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _pthread_create(int32_t * a1, int64_t * a2, int64_t * (*a3)(int64_t *), int64_t * a4);
int32_t _pthread_join(int32_t a1, int64_t ** a2);
int32_t _pthread_mutex_init(int64_t * a1, int64_t * a2);
int32_t _pthread_mutex_lock(int64_t * a1);
int32_t _pthread_mutex_trylock(int64_t * a1);
int32_t _pthread_mutex_unlock(int64_t * a1);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000039f4 - 0x100003be4
int64_t function_1000039f4(void) {
    // 0x1000039f4
    if (*(int32_t *)&g1 == 0) {
        // 0x100003bd4
        return 0;
    }
    // 0x100003a28
    int64_t v1; // 0x1000039f4
    char * v2 = (char *)v1; // 0x100003a40
    _printf("%s is sleeping --er thinking\n", v2);
    int32_t v3 = _rand(); // 0x100003a44
    int32_t v4 = _sleep(v3 + 1 - 8 * v3 / 8); // 0x100003a5c
    _printf("%s is hungry\n", v2);
    int64_t v5 = v4;
    int32_t v6 = 2;
    int64_t v7 = *(int64_t *)(v1 + 8);
    int64_t * v8 = (int64_t *)v5;
    _pthread_mutex_lock(v8);
    int64_t * v9 = (int64_t *)v7;
    int32_t v10; // 0x1000039f4
    if (v6 < 1) {
        // 0x100003ad0
        v10 = _pthread_mutex_lock(v9);
    } else {
        // 0x100003ac0
        v10 = _pthread_mutex_trylock(v9);
    }
    int64_t v11; // 0x1000039f4
    while (v10 != 0) {
        // 0x100003b64
        _pthread_mutex_unlock(v8);
        v11 = v5;
        if (*(int32_t *)&g1 == 0) {
            return 0;
        }
        v5 = v7;
        v6--;
        v7 = v11;
        v8 = (int64_t *)v5;
        _pthread_mutex_lock(v8);
        v9 = (int64_t *)v7;
        if (v6 < 1) {
            // 0x100003ad0
            v10 = _pthread_mutex_lock(v9);
        } else {
            // 0x100003ac0
            v10 = _pthread_mutex_trylock(v9);
        }
    }
    // 0x100003bd0
    _printf("%s is eating\n", v2);
    int32_t v12 = _rand(); // 0x100003ba0
    _sleep(v12 + 1 - 8 * v12 / 8);
    _pthread_mutex_unlock(v9);
    _pthread_mutex_unlock(v8);
    while (*(int32_t *)&g1 != 0) {
        // 0x100003a28
        _printf("%s is sleeping --er thinking\n", v2);
        v3 = _rand();
        v4 = _sleep(v3 + 1 - 8 * v3 / 8);
        _printf("%s is hungry\n", v2);
        v5 = v4;
        v6 = 2;
        v7 = *(int64_t *)(v1 + 8);
        v8 = (int64_t *)v5;
        _pthread_mutex_lock(v8);
        v9 = (int64_t *)v7;
        if (v6 < 1) {
            // 0x100003ad0
            v10 = _pthread_mutex_lock(v9);
        } else {
            // 0x100003ac0
            v10 = _pthread_mutex_trylock(v9);
        }
        while (v10 != 0) {
            // 0x100003b64
            _pthread_mutex_unlock(v8);
            v11 = v5;
            if (*(int32_t *)&g1 == 0) {
                return 0;
            }
            v5 = v7;
            v6--;
            v7 = v11;
            v8 = (int64_t *)v5;
            _pthread_mutex_lock(v8);
            v9 = (int64_t *)v7;
            if (v6 < 1) {
                // 0x100003ad0
                v10 = _pthread_mutex_lock(v9);
            } else {
                // 0x100003ac0
                v10 = _pthread_mutex_trylock(v9);
            }
        }
        // 0x100003bd0
        _printf("%s is eating\n", v2);
        v12 = _rand();
        _sleep(v12 + 1 - 8 * v12 / 8);
        _pthread_mutex_unlock(v9);
        _pthread_mutex_unlock(v8);
    }
    // 0x100003bd4
    return 0;
}

// Address range: 0x100003be4 - 0x100003e40
int64_t function_100003be4(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003bfc
    int64_t v2; // bp-72, 0x100003be4
    _memcpy(&v2, (int64_t *)"6?", 40);
    int64_t v3; // bp-392, 0x100003be4
    int64_t v4 = &v3;
    int32_t v5 = 0; // 0x100003be4
    uint64_t v6 = 0;
    int64_t v7; // 0x100003be4
    int64_t v8; // 0x100003be4
    while (_pthread_mutex_init((int64_t *)(64 * v6 + v4), NULL) == 0) {
        int32_t v9 = v5;
        int64_t v10 = v6 + 1;
        v5 = v9 + 1;
        if (v6 < 4 == (3 - v9 & (int32_t)v10) < 0) {
            // 0x100003c90
            int64_t v11; // bp-592, 0x100003be4
            v8 = &v11;
            v7 = 0;
            goto lab_0x100003ca4;
        }
        v6 = v10;
    }
    // 0x100003c60
    _printf("Failed to initialize mutexes.");
    _exit(1);
    // UNREACHABLE
  lab_0x100003ca4:;
    int64_t v12 = 40 * v7 + v8; // 0x100003cb4
    int64_t v13 = *(int64_t *)(8 * v7 + (int64_t)&v2); // 0x100003cc4
    *(int64_t *)(v12 + 16) = v13;
    int64_t * v14 = (int64_t *)v12; // 0x100003ce4
    *v14 = 64 * v7 + v4;
    int64_t v15 = v7 + 1;
    int64_t v16 = v15 == 5 ? 0 : 0x100000000 * v15 >> 26; // 0x100003d08
    *(int64_t *)(v12 + 8) = v16 + v4;
    int32_t v17 = _pthread_create((int32_t *)(v12 + 24), NULL, (int64_t * (*)(int64_t *))0x1000039f4, v14); // 0x100003d2c
    *(int32_t *)(v12 + 32) = v17;
    v7 = v15;
    int64_t v18; // 0x100003be4
    int32_t v19; // 0x100003be4
    int64_t v20; // 0x100003be4
    if (v15 == 5) {
        // 0x100003d4c
        _sleep(40);
        *(int32_t *)&g1 = 0;
        v18 = 0;
        v19 = 0;
        v20 = _printf("cleanup time\n");
        goto lab_0x100003d84;
    } else {
        goto lab_0x100003ca4;
    }
  lab_0x100003d84:;
    int32_t v21 = v19;
    uint64_t v22 = v18;
    int64_t v23 = 40 * v22 + v8; // 0x100003d94
    int64_t v24 = v20; // 0x100003dac
    if (*(int32_t *)(v23 + 32) == 0) {
        // 0x100003db4
        v24 = 0;
        if (_pthread_join((int32_t)*(int64_t *)(v23 + 24), NULL) != 0) {
            // 0x100003dd4
            _printf("error joining thread for %s", NULL);
            _exit(1);
            // UNREACHABLE
        }
        goto lab_0x100003dfc;
    } else {
        goto lab_0x100003dfc;
    }
  lab_0x100003dfc:;
    int64_t result = v24;
    int64_t v25 = v22 + 1;
    v18 = v25;
    v19 = v21 + 1;
    v20 = result;
    if (v22 < 4 == (3 - v21 & (int32_t)v25) < 0) {
        // 0x100003e0c
        if (*(int64_t *)*(int64_t *)0x100004008 == v1) {
            // 0x100003e30
            return result;
        }
        // 0x100003e30
        return ___stack_chk_fail();
    }
    goto lab_0x100003d84;
}

// Address range: 0x100003e40 - 0x100003e6c
int64_t entry_point(void) {
    // 0x100003e40
    function_100003be4();
    return 0;
}

// Address range: 0x100003e6c - 0x100003e78
int64_t function_100003e6c(void) {
    // 0x100003e6c
    return ___stack_chk_fail();
}

// Address range: 0x100003e78 - 0x100003e84
void function_100003e78(int32_t status) {
    // 0x100003e78
    _exit(status);
}

// Address range: 0x100003e84 - 0x100003e90
int64_t * function_100003e84(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e84
    return _memcpy(dest, src, n);
}

// Address range: 0x100003e90 - 0x100003e9c
int32_t function_100003e90(char * format, ...) {
    // 0x100003e90
    return _printf(format);
}

// Address range: 0x100003e9c - 0x100003ea8
int32_t function_100003e9c(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg) {
    // 0x100003e9c
    return _pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x100003ea8 - 0x100003eb4
int32_t function_100003ea8(int32_t th, int64_t ** thread_return) {
    // 0x100003ea8
    return _pthread_join(th, thread_return);
}

// Address range: 0x100003eb4 - 0x100003ec0
int32_t function_100003eb4(int64_t * mutex, int64_t * mutexattr) {
    // 0x100003eb4
    return _pthread_mutex_init(mutex, mutexattr);
}

// Address range: 0x100003ec0 - 0x100003ecc
int32_t function_100003ec0(int64_t * mutex) {
    // 0x100003ec0
    return _pthread_mutex_lock(mutex);
}

// Address range: 0x100003ecc - 0x100003ed8
int32_t function_100003ecc(int64_t * mutex) {
    // 0x100003ecc
    return _pthread_mutex_trylock(mutex);
}

// Address range: 0x100003ed8 - 0x100003ee4
int32_t function_100003ed8(int64_t * mutex) {
    // 0x100003ed8
    return _pthread_mutex_unlock(mutex);
}

// Address range: 0x100003ee4 - 0x100003ef0
int32_t function_100003ee4(void) {
    // 0x100003ee4
    return _rand();
}

// Address range: 0x100003ef0 - 0x100003efc
int32_t function_100003ef0(int32_t seconds) {
    // 0x100003ef0
    return _sleep(seconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`#include <stdio.h>
#include <math.h>

int main(void)
{
    double e;

    puts("The double precision in C give about 15 significant digits.\n"
         "Values below are presented with 16 digits after the decimal point.\n");

    // The most direct way to compute Euler constant.
    //
    e = exp(1);
    printf("Euler constant e = %.16lf\n", e);

    // The fast and independed method: e = lim (1 + 1/n)**n
    //
    e = 1.0 + 0x1p-26;
    for (int i = 0; i < 26; i++)
        e *= e;
    printf("Euler constant e = %.16lf\n", e);

    // Taylor expansion e = 1 + 1/1 + 1/2 + 1/2/3 + 1/2/3/4 + 1/2/3/4/5 + ...
    // Actually Kahan summation may improve the accuracy, but is not necessary.
    //
    const int N = 1000;
    double a[1000];
    a[0] = 1.0;
    for (int i = 1; i < N; i++)
    {
        a[i] = a[i-1] / i;
    }
    e = 1.;
    for (int i = N - 1; i > 0; i--)
        e += a[i];
    printf("Euler constant e = %.16lf\n", e);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d08(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003ed0(int64_t a1);
float64_t function_100003edc(float64_t a1);
int32_t function_100003ee8(char * format, ...);
int32_t function_100003ef4(char * s);

// --------------------- Global Variables ---------------------

float64_t g1 = 1.0; // 0x100003f00

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
float64_t _exp(float64_t a1);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003cec - 0x100003d08
int64_t entry_point(void) {
    // 0x100003cec
    return ___chkstk_darwin();
}

// Address range: 0x100003d08 - 0x100003ed0
int64_t function_100003d08(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003d08
    int64_t v1; // 0x100003d08
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003d1c
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    _puts("The double precision in C give about 15 significant digits.\nValues below are presented with 16 digits after the decimal point.\n");
    int128_t v3; // 0x100003d08
    float64_t v4 = _exp((float64_t)(int64_t)v3); // 0x100003d34
    _printf("Euler constant e = %.16lf\n", v4);
    int32_t v5 = 0; // 0x100003d94
    float64_t v6 = g1;
    v5++;
    float64_t v7 = v6 * v6; // 0x100003d74
    while (v5 != 26) {
        // 0x100003d7c
        v6 = v7;
        v5++;
        v7 = v6 * v6;
    }
    // 0x100003da0
    _printf("Euler constant e = %.16lf\n", v4);
    float64_t v8 = 1.0; // bp-8008, 0x100003dc4
    int64_t v9 = &v8;
    int32_t v10 = 1;
    float64_t v11 = *(float64_t *)((int64_t)(8 * v10 - 8) + v9); // 0x100003df4
    __asm_sshll(0.0f, 0);
    *(float64_t *)(8 * (int64_t)v10 + v9) = v11 / v6;
    int32_t v12 = v10 + 1; // 0x100003e1c
    while (v10 < 999 != (998 - v10 & v12) < 0) {
        // 0x100003de8
        v10 = v12;
        v11 = *(float64_t *)((int64_t)(8 * v10 - 8) + v9);
        __asm_sshll(0.0f, 0);
        *(float64_t *)(8 * (int64_t)v10 + v9) = v11 / v6;
        v12 = v10 + 1;
    }
    int32_t v13 = _printf("Euler constant e = %.16lf\n", v4); // 0x100003e90
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003eb4
        ___stack_chk_fail((int64_t)v13);
    }
    // 0x100003eb8
    return 0;
}

// Address range: 0x100003ed0 - 0x100003edc
int64_t function_100003ed0(int64_t a1) {
    // 0x100003ed0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003edc - 0x100003ee8
float64_t function_100003edc(float64_t a1) {
    // 0x100003edc
    return _exp(a1);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * format, ...) {
    // 0x100003ee8
    return _printf(format);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * s) {
    // 0x100003ef4
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdlib.h>
#include <stdio.h>
#include <math.h>

/* declare a typedef for a function pointer */
typedef double (*Class2Func)(double);

/*A couple of functions with the above prototype */
double functionA( double v)
{
   return v*v*v;
}
double functionB(double v)
{
   return exp(log(v)/3);
}

/* A function taking a function as an argument */
double Function1( Class2Func f2, double val )
{
    return f2(val);
}

/*A function returning a function */
Class2Func WhichFunc( int idx)
{
   return (idx < 4) ? &functionA : &functionB;
}

/* A list of functions */
Class2Func funcListA[] = {&functionA, &sin, &cos, &tan };
Class2Func funcListB[] = {&functionB, &asin, &acos, &atan };

/* Composing Functions */
double InvokeComposed( Class2Func f1, Class2Func f2, double val )
{
   return f1(f2(val));
}

typedef struct sComposition {
   Class2Func f1;
   Class2Func f2;
} *Composition;

Composition Compose( Class2Func f1, Class2Func f2)
{
   Composition comp = malloc(sizeof(struct sComposition));
   comp->f1 = f1;
   comp->f2 = f2;
   return comp;
}

double CallComposed( Composition comp, double val )
{
    return comp->f1( comp->f2(val) );
}
/** * * * * * * * * * * * * * * * * * * * * * * * * * * */

int main(int argc, char *argv[])
{
   int ix;
   Composition c;

   printf("Function1(functionA, 3.0) = %f\n", Function1(WhichFunc(0), 3.0));

   for (ix=0; ix<4; ix++) {
       c = Compose(funcListA[ix], funcListB[ix]);
       printf("Compostion %d(0.9) = %f\n", ix, CallComposed(c, 0.9));
   }

   return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cbc(void);
int64_t function_100003ce0(void);
int64_t function_100003d10(void);
int64_t function_100003d30(int64_t a1, int64_t a2);
int64_t function_100003d3c(void);
int64_t function_100003d74(void);
int64_t function_100003da0(int64_t a1);
int64_t function_100003da8(int64_t a1, int64_t a2);
int64_t function_100003db4(int64_t a1, int64_t a2);
int64_t function_100003dfc(void);
int64_t function_100003e2c(int64_t a1);
int64_t function_100003e34(int64_t a1, int64_t a2);
float64_t function_100003f20(float64_t a1);
float64_t function_100003f2c(float64_t a1);
int64_t * function_100003f38(int32_t size);
int32_t function_100003f44(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x10000000003cbc; // 0x100008000
int64_t g2 = 0x10000000003ce0; // 0x100008020

// ------- Dynamically Linked Functions Without Header --------

float64_t _exp(float64_t a1);
float64_t _log(float64_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cbc - 0x100003ce0
int64_t function_100003cbc(void) {
    // 0x100003cbc
    int64_t result; // 0x100003cbc
    return result;
}

// Address range: 0x100003ce0 - 0x100003d10
int64_t function_100003ce0(void) {
    // 0x100003ce0
    int128_t v1; // 0x100003ce0
    return _exp(_log((float64_t)(int64_t)v1));
}

// Address range: 0x100003d10 - 0x100003d30
int64_t function_100003d10(void) {
    // 0x100003d10
    int64_t result; // 0x100003d10
    return result;
}

// Address range: 0x100003d30 - 0x100003d3c
int64_t function_100003d30(int64_t a1, int64_t a2) {
    // 0x100003d30
    int64_t result; // 0x100003d30
    return result;
}

// Address range: 0x100003d3c - 0x100003d74
int64_t function_100003d3c(void) {
    // 0x100003d3c
    int64_t v1; // 0x100003d3c
    int32_t v2 = v1; // 0x100003d40
    return v2 < 4 == (3 - v2 & v2) < 0 ? 0x100003ce0 : 0x100003cbc;
}

// Address range: 0x100003d74 - 0x100003da0
int64_t function_100003d74(void) {
    // 0x100003d74
    int64_t result; // 0x100003d74
    return result;
}

// Address range: 0x100003da0 - 0x100003da8
int64_t function_100003da0(int64_t a1) {
    // 0x100003da0
    int64_t result; // 0x100003da0
    return result;
}

// Address range: 0x100003da8 - 0x100003db4
int64_t function_100003da8(int64_t a1, int64_t a2) {
    // 0x100003da8
    int64_t result; // 0x100003da8
    return result;
}

// Address range: 0x100003db4 - 0x100003dfc
int64_t function_100003db4(int64_t a1, int64_t a2) {
    int64_t * v1 = _malloc(16); // 0x100003dcc
    int64_t result = (int64_t)v1; // 0x100003dcc
    *v1 = a1;
    *(int64_t *)(result + 8) = a2;
    return result;
}

// Address range: 0x100003dfc - 0x100003e2c
int64_t function_100003dfc(void) {
    // 0x100003dfc
    int64_t result; // 0x100003dfc
    return result;
}

// Address range: 0x100003e2c - 0x100003e34
int64_t function_100003e2c(int64_t a1) {
    // 0x100003e2c
    int64_t result; // 0x100003e2c
    return result;
}

// Address range: 0x100003e34 - 0x100003e40
int64_t function_100003e34(int64_t a1, int64_t a2) {
    // 0x100003e34
    int64_t result; // 0x100003e34
    return result;
}

// Address range: 0x100003e40 - 0x100003f20
int64_t entry_point(void) {
    // 0x100003e40
    function_100003d3c();
    function_100003d10();
    int128_t v1; // 0x100003e40
    _printf("Function1(functionA, 3.0) = %f\n", (float64_t)(int64_t)v1);
    for (int64_t i = 0; i < 4; i++) {
        int64_t v2 = 8 * i; // 0x100003ea8
        int64_t v3 = *(int64_t *)(v2 + (int64_t)&g2); // 0x100003eb8
        function_100003db4(*(int64_t *)(v2 + (int64_t)&g1), v3);
        function_100003dfc();
        _printf("Compostion %d(0.9) = %f\n", v3, (float64_t)(int64_t)v1);
    }
    // 0x100003f10
    return 0;
}

// Address range: 0x100003f20 - 0x100003f2c
float64_t function_100003f20(float64_t a1) {
    // 0x100003f20
    return _exp(a1);
}

// Address range: 0x100003f2c - 0x100003f38
float64_t function_100003f2c(float64_t a1) {
    // 0x100003f2c
    return _log(a1);
}

// Address range: 0x100003f38 - 0x100003f44
int64_t * function_100003f38(int32_t size) {
    // 0x100003f38
    return _malloc(size);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * format, ...) {
    // 0x100003f44
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 17

`
`#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

#define LIMIT 15
int smallPrimes[LIMIT];

static void sieve() {
    int i = 2, j;
    int p = 5;

    smallPrimes[0] = 2;
    smallPrimes[1] = 3;

    while (i < LIMIT) {
        for (j = 0; j < i; j++) {
            if (smallPrimes[j] * smallPrimes[j] <= p) {
                if (p % smallPrimes[j] == 0) {
                    p += 2;
                    break;
                }
            } else {
                smallPrimes[i++] = p;
                p += 2;
                break;
            }
        }
    }
}

static bool is_prime(uint64_t n) {
    uint64_t i;

    for (i = 0; i < LIMIT; i++) {
        if (n % smallPrimes[i] == 0) {
            return n == smallPrimes[i];
        }
    }

    i = smallPrimes[LIMIT - 1] + 2;
    for (; i * i <= n; i += 2) {
        if (n % i == 0) {
            return false;
        }
    }

    return true;
}

static uint64_t divisor_count(uint64_t n) {
    uint64_t count = 1;
    uint64_t d;

    while (n % 2 == 0) {
        n /= 2;
        count++;
    }

    for (d = 3; d * d <= n; d += 2) {
        uint64_t q = n / d;
        uint64_t r = n % d;
        uint64_t dc = 0;
        while (r == 0) {
            dc += count;
            n = q;
            q = n / d;
            r = n % d;
        }
        count += dc;
    }

    if (n != 1) {
        return count *= 2;
    }
    return count;
}

static uint64_t OEISA073916(size_t n) {
    uint64_t count = 0;
    uint64_t result = 0;
    size_t i;

    if (is_prime(n)) {
        return (uint64_t)pow(smallPrimes[n - 1], n - 1);
    }

    for (i = 1; count < n; i++) {
        if (n % 2 == 1) {
            //  The solution for an odd (non-prime) term is always a square number
            uint64_t root = (uint64_t)sqrt(i);
            if (root * root != i) {
                continue;
            }
        }
        if (divisor_count(i) == n) {
            count++;
            result = i;
        }
    }

    return result;
}

int main() {
    size_t n;

    sieve();

    for (n = 1; n <= LIMIT; n++) {
        if (n == 13) {
            printf("A073916(%lu) = One more bit needed to represent result.\n", n);
        } else {
            printf("A073916(%lu) = %llu\n", n, OEISA073916(n));
        }
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a04(void);
int64_t function_100003b50(void);
int64_t function_100003c74(void);
int64_t function_100003db8(void);
float64_t function_100003f28(float64_t a1, float64_t a2);
int32_t function_100003f34(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x100000c; // 0x100008004

// ------- Dynamically Linked Functions Without Header --------

float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000394c - 0x100003a04
int64_t entry_point(void) {
    // 0x10000394c
    function_100003b50();
    int64_t v1; // 0x10000394c
    int32_t v2 = v1;
    for (int64_t i = 1; i < 16; i++) {
        // 0x100003980
        if (i == 13) {
            // 0x100003994
            _printf("A073916(%lu) = One more bit needed to represent result.\n", v2);
        } else {
            // 0x1000039b0
            function_100003a04();
            _printf("A073916(%lu) = %llu\n", v2, v1);
        }
    }
    // 0x1000039f4
    return 0;
}

// Address range: 0x100003a04 - 0x100003b50
int64_t function_100003a04(void) {
    // 0x100003a04
    int64_t v1; // 0x100003a04
    uint64_t v2 = v1;
    if (function_100003c74() % 2 != 0) {
        // 0x100003a2c
        int128_t v3; // 0x100003a04
        _pow((float64_t)(int64_t)__asm_sshll(0.0f, 0), (float64_t)(int64_t)v3);
        // 0x100003b40
        float64_t result; // 0x100003a04
        return result;
    }
    // 0x100003a74
    if (v2 == 0) {
        // 0x100003b40
        return (float64_t)0;
    }
    int64_t v4 = 1; // 0x100003b28
    int64_t v5 = 0;
    float64_t v6 = 4.9406564584124654e-324; // 0x100003a04
    int64_t v7 = 0;
    int64_t v8; // 0x100003a04
    int64_t v9; // 0x100003a04
    int64_t v10; // 0x100003a04
    float64_t v11; // 0x100003b24
    int64_t v12; // 0x100003a04
    int64_t v13; // 0x100003a04
    while (true) {
      lab_0x100003a8c_2:
        // 0x100003a8c
        v12 = v7;
        v11 = v6;
        v10 = v5;
        v9 = v4;
        if (v2 == (2 * v2 / 2 || 1)) {
            int64_t v14 = sqrt(v11); // 0x100003abc
            v8 = v10;
            v13 = v12;
            if (v14 * v14 == (int64_t)v11) {
                goto lab_0x100003aec;
            } else {
                goto lab_0x100003b24;
            }
        } else {
            // 0x100003a8c
            goto lab_0x100003aec;
        }
    }
  lab_0x100003b34:;
    // 0x100003b40
    int64_t v15; // 0x100003a04
    return (float64_t)v15;
  lab_0x100003aec:;
    int64_t v16 = function_100003db8(); // 0x100003af0
    v8 = v16 == v2 ? v9 : v10;
    v13 = v12 + (int64_t)(v16 == v2);
    goto lab_0x100003b24;
  lab_0x100003b24:
    // 0x100003b24
    v7 = v13;
    v5 = v8;
    v4 = (int64_t)v11 + 1;
    v6 = v4;
    v15 = v5;
    if (v7 >= v2) {
        // break -> 0x100003b34
        goto lab_0x100003b34;
    }
    goto lab_0x100003a8c_2;
}

// Address range: 0x100003b50 - 0x100003c74
int64_t function_100003b50(void) {
    // 0x100003b50
    *(int32_t *)&g1 = 2;
    *(int32_t *)&g2 = 3;
    int32_t v1 = 2;
    int32_t v2 = 5; // 0x100003b50
    int32_t v3; // 0x100003b50
    while (true) {
      lab_0x100003b98:;
        int32_t v4 = v2;
        int32_t v5 = v1;
        int32_t v6 = -v5; // 0x100003ba0
        v2 = v4;
        v3 = v5;
        if (v6 < 0 != (v5 & v6) < 0) {
            int32_t v7 = 0;
            int32_t v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1); // 0x100003bbc
            int32_t v9 = v8 * v8; // 0x100003bc8
            while (v9 - v4 == 0 || v9 - v4 < 0 != ((v9 - v4 ^ v9) & (v9 ^ v4)) < 0) {
                if (v4 % v8 == 0) {
                    // 0x100003c10
                    v2 = v4 + 2;
                    v3 = v5;
                    goto lab_0x100003c68;
                }
                int32_t v10 = v7 + 1; // 0x100003c5c
                int32_t v11 = v10 - v5; // 0x100003ba0
                int32_t v12 = v10; // 0x100003ba8
                v2 = v4;
                v3 = v5;
                if (v11 < 0 == ((v11 ^ v10) & (v10 ^ v5)) < 0) {
                    goto lab_0x100003c68;
                }
                v7 = v12;
                v8 = *(int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
                v9 = v8 * v8;
            }
            // 0x100003c24
            *(int32_t *)(4 * (int64_t)v5 + (int64_t)&g1) = v4;
            v2 = v4 + 2;
            v3 = v5 + 1;
        }
        goto lab_0x100003c68;
    }
    // 0x100003c6c
    int64_t result; // 0x100003b50
    return result;
  lab_0x100003c68:
    // 0x100003c68
    v1 = v3;
    if (v1 < 15 == (14 - v1 & v1) < 0) {
        int64_t result2; // 0x100003b50
        return result2;
    }
    goto lab_0x100003b98;
}

// Address range: 0x100003c74 - 0x100003db8
int64_t function_100003c74(void) {
    // 0x100003c74
    int64_t v1; // 0x100003c74
    uint64_t v2 = v1;
    int64_t v3 = 0; // 0x100003cfc
    uint64_t v4 = (int64_t)*(int32_t *)(4 * v3 + (int64_t)&g1); // 0x100003ca8
    int64_t result; // 0x100003c74
    int64_t v5; // 0x100003c74
    while (v2 % v4 != 0) {
        // 0x100003c84
        v3++;
        if (v3 >= 15) {
            int64_t v6 = (int64_t)(*(int32_t *)((int64_t)&g1 + 56) + 2); // 0x100003d1c
            uint64_t v7 = v6 * v6; // 0x100003d30
            v5 = v6;
            result = 1;
            if (v7 >= v2 == (v7 != v2)) {
                return result;
            } else {
                goto lab_0x100003d48;
            }
        }
        v4 = (int64_t)*(int32_t *)(4 * v3 + (int64_t)&g1);
    }
    // 0x100003cc8
    result = v2 == v4;
  lab_0x100003da8:
    // 0x100003da8
    return result;
  lab_0x100003d48:
    // 0x100003d48
    result = 0;
    if (v2 % v5 == 0) {
        return result;
    } else {
        int64_t v8 = v5 + 2; // 0x100003d88
        uint64_t v9 = v8 * v8; // 0x100003d30
        v5 = v8;
        result = 1;
        if (v9 >= v2 == (v9 != v2)) {
            return result;
        } else {
            goto lab_0x100003d48;
        }
    }
}

// Address range: 0x100003db8 - 0x100003f28
int64_t function_100003db8(void) {
    int64_t v1 = 1;
    int64_t v2; // 0x100003db8
    int64_t v3 = v2;
    int64_t v4 = v3 / 2; // 0x100003dd4
    int64_t v5 = v1 + 1; // 0x100003de8
    while (v3 == 2 * v4) {
        // 0x100003dcc
        v1 = v5;
        v3 = v4;
        v4 = v3 / 2;
        v5 = v1 + 1;
    }
    // 0x100003e1c
    if (v3 <= 9 == (v3 != 9)) {
        // 0x100003ee8
        return v1 << (int64_t)(v3 != 1);
    }
    uint64_t v6 = 3;
    int64_t v7 = v3; // 0x100003e78
    int64_t v8 = 0; // 0x100003e78
    int64_t v9; // 0x100003db8
    int64_t v10; // 0x100003db8
    int64_t v11; // 0x100003db8
    int64_t v12; // 0x100003e88
    if (v3 % v6 == 0) {
        v10 = v3 / v6;
        v12 = v1;
        v11 = v12;
        v9 = v10;
        v7 = v10;
        v8 = v12;
        while (v10 % v6 == 0) {
            // 0x100003e80
            v10 = v9 / v6;
            v12 = v11 + v1;
            v11 = v12;
            v9 = v10;
            v7 = v10;
            v8 = v12;
        }
    }
    int64_t v13 = v7;
    int64_t v14 = v8 + v1; // 0x100003ecc
    int64_t v15 = v6 + 2; // 0x100003edc
    uint64_t v16 = v15 * v15; // 0x100003e24
    while (v16 >= v13 != v16 != v13) {
        int64_t v17 = v14;
        v6 = v15;
        v9 = v13;
        v7 = v13;
        v8 = 0;
        if (v13 % v6 == 0) {
            v10 = v9 / v6;
            v12 = v17;
            v11 = v12;
            v9 = v10;
            v7 = v10;
            v8 = v12;
            while (v10 % v6 == 0) {
                // 0x100003e80
                v10 = v9 / v6;
                v12 = v11 + v17;
                v11 = v12;
                v9 = v10;
                v7 = v10;
                v8 = v12;
            }
        }
        // 0x100003ec4
        v13 = v7;
        v14 = v8 + v17;
        v15 = v6 + 2;
        v16 = v15 * v15;
    }
    // 0x100003ee8
    return v14 << (int64_t)(v13 != 1);
}

// Address range: 0x100003f28 - 0x100003f34
float64_t function_100003f28(float64_t a1, float64_t a2) {
    // 0x100003f28
    return _pow(a1, a2);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdbool.h>
#include <time.h>

#define n 100
#define nn ((n * (n + 1)) >> 1)

bool Contains(int lst[], int item, int size) {
	for (int i = size - 1; i >= 0; i--)
 		if (item == lst[i]) return true;
	return false;
}

int * MianChowla()
{
	static int mc[n]; mc[0] = 1;
	int sums[nn];	sums[0] = 2;
	int sum, le, ss = 1;
	for (int i = 1; i < n; i++) {
		le = ss;
		for (int j = mc[i - 1] + 1; ; j++) {
			mc[i] = j;
			for (int k = 0; k <= i; k++) {
				sum = mc[k] + j;
				if (Contains(sums, sum, ss)) {
					ss = le; goto nxtJ;
				}
				sums[ss++] = sum;
			}
			break;
		nxtJ:;
		}
	}
	return mc;
}

int main() {
	clock_t st = clock(); int * mc; mc = MianChowla();
        double et = ((double)(clock() - st)) / CLOCKS_PER_SEC;
	printf("The first 30 terms of the Mian-Chowla sequence are:\n");
	for (int i = 0; i < 30; i++) printf("%d ", mc[i]);
	printf("\n\nTerms 91 to 100 of the Mian-Chowla sequence are:\n");
	for (int i = 90; i < 100; i++) printf("%d ", mc[i]);
	printf("\n\nComputation time was %f seconds.", et);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b70(void);
int64_t function_100003c10(void);
int64_t function_100003c2c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003edc(void);
int32_t function_100003ee8(void);
int32_t function_100003ef4(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = NULL; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(void);
int32_t _clock(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b70 - 0x100003c10
int64_t function_100003b70(void) {
    // 0x100003b70
    int64_t v1; // 0x100003b70
    int32_t v2 = v1; // 0x100003b8c
    v2--;
    int64_t result = 0; // 0x100003b9c
    while (v2 >= 0) {
        // 0x100003ba4
        result = 1;
        if (*(int32_t *)(4 * (int64_t)v2 + v1) == (int32_t)v1) {
            // break -> 0x100003c00
            break;
        }
        v2--;
        result = 0;
    }
    // 0x100003c00
    return result;
}

// Address range: 0x100003c10 - 0x100003c2c
int64_t function_100003c10(void) {
    // 0x100003c10
    return ___chkstk_darwin();
}

// Address range: 0x100003c2c - 0x100003db0
int64_t function_100003c2c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003c2c
    int64_t v1; // 0x100003c2c
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003c40
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    *(int32_t *)&g1 = 1;
    int32_t v3 = 2; // bp-20208, 0x100003c54
    int64_t v4 = &v3;
    int64_t v5 = 1;
    int32_t v6 = 1; // 0x100003c2c
    int32_t v7 = 1; // 0x100003c2c
    while (true) {
        int32_t v8 = v7;
        int64_t v9 = 4 * v5;
        int32_t v10 = *(int32_t *)(v9 + (int64_t)&g1 - 4) + 1;
        int32_t * v11 = (int32_t *)(v9 + (int64_t)&g1); // 0x100003cb0
        *v11 = v10;
        int32_t v12 = v5;
        int32_t v13 = v10; // 0x100003ccc
        v7 = v8;
        if ((v12 & -v6) >= 0) {
            while (true) {
                int32_t v14 = v13;
                int32_t v15 = v8; // 0x100003d20
                int32_t v16 = 0;
                int32_t v17 = *(int32_t *)(4 * (int64_t)v16 + (int64_t)&g1); // 0x100003ce0
                while (function_100003b70() % 2 == 0) {
                    int32_t v18 = v15;
                    v15 = v18 + 1;
                    *(int32_t *)(4 * (int64_t)v18 + v4) = v17 + v14;
                    int32_t v19 = v16 + 1; // 0x100003d38
                    int32_t v20 = v19 - v12; // 0x100003cc4
                    v7 = v15;
                    if (v20 != 0 && v20 < 0 == ((v20 ^ v19) & (v19 ^ v12)) < 0) {
                        // break (via goto) -> 0x100003d60
                        goto lab_0x100003d60;
                    }
                    v16 = v19;
                    v17 = *(int32_t *)(4 * (int64_t)v16 + (int64_t)&g1);
                }
                int32_t v21 = v14 + 1;
                *v11 = v21;
                v13 = v21;
            }
        }
      lab_0x100003d60:
        // 0x100003d60
        v5++;
        v6++;
        if (v5 == 100) {
            // break -> 0x100003d70
            break;
        }
    }
    // 0x100003d70
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003d90
        ___stack_chk_fail();
    }
    // 0x100003d94
    return (int64_t)&g1;
}

// Address range: 0x100003db0 - 0x100003edc
int64_t entry_point(void) {
    // 0x100003db0
    _clock();
    function_100003c10();
    _clock();
    _printf("The first 30 terms of the Mian-Chowla sequence are:\n");
    int64_t v1; // 0x100003db0
    for (int32_t i = 0; i < 30; i++) {
        // 0x100003e18
        _printf("%d ", v1);
    }
    // 0x100003e50
    _printf("\n\nTerms 91 to 100 of the Mian-Chowla sequence are:\n");
    for (int32_t i = 90; i < 100; i++) {
        // 0x100003e7c
        _printf("%d ", v1);
    }
    // 0x100003eb4
    int128_t v2; // 0x100003db0
    _printf("\n\nComputation time was %f seconds.", (float64_t)(int64_t)v2);
    return 0;
}

// Address range: 0x100003edc - 0x100003ee8
int64_t function_100003edc(void) {
    // 0x100003edc
    return ___stack_chk_fail();
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(void) {
    // 0x100003ee8
    return _clock();
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * format, ...) {
    // 0x100003ef4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// low <= num < high
int randInt(int low, int high) {
    return (rand() % (high - low)) + low;
}

// shuffle an array of n elements
void shuffle(int *const array, const int n) {
    if (n > 1) {
        int i;
        for (i = 0; i < n - 1; i++) {
            int j = randInt(i, n);

            int t = array[i];
            array[i] = array[j];
            array[j] = t;
        }
    }
}

// print an n * n array
void printSquare(const int *const latin, const int n) {
    int i, j;
    for (i = 0; i < n; i++) {
        printf("[");
        for (j = 0; j < n; j++) {
            if (j > 0) {
                printf(", ");
            }
            printf("%d", latin[i * n + j]);
        }
        printf("]\n");
    }
    printf("\n");
}

void latinSquare(const int n) {
    int *latin, *used;
    int i, j, k;

    if (n <= 0) {
        printf("[]\n");
        return;
    }

    // allocate
    latin = (int *)malloc(n * n * sizeof(int));
    if (!latin) {
        printf("Failed to allocate memory.");
        return;
    }

    // initialize
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            latin[i * n + j] = j;
        }
    }

    // first row
    shuffle(latin, n);

    // middle row(s)
    for (i = 1; i < n - 1; i++) {
        bool shuffled = false;

        while (!shuffled) {
            shuffle(&latin[i * n], n);

            for (k = 0; k < i; k++) {
                for (j = 0; j < n; j++) {
                    if (latin[k * n + j] == latin[i * n + j]) {
                        goto shuffling;
                    }
                }
            }
            shuffled = true;

        shuffling: {}
        }
    }

    //last row
    used = (int *)malloc(n * sizeof(int));
    for (j = 0; j < n; j++) {
        memset(used, 0, n * sizeof(int));
        for (i = 0; i < n - 1; i++) {
            used[latin[i * n + j]] = 1;
        }
        for (k = 0; k < n; k++) {
            if (used[k] == 0) {
                latin[(n - 1) * n + j] = k;
                break;
            }
        }
    }
    free(used);

    // print the result
    printSquare(latin, n);
    free(latin);
}

int main() {
    // initialze the random number generator
    srand((unsigned int)time((time_t)0));

    latinSquare(5);
    latinSquare(5);
    latinSquare(10);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000393c(int32_t a1, int32_t a2);
int64_t function_100003980(void);
int64_t function_100003a38(void);
int64_t function_100003b3c(void);
int64_t function_100003f28(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void function_100003f34(int64_t * ptr);
int64_t * function_100003f40(int32_t size);
int32_t function_100003f4c(char * format, ...);
int32_t function_100003f58(void);
void function_100003f64(int32_t seed);
int32_t function_100003f70(int32_t * timer);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000393c - 0x100003980
int64_t function_10000393c(int32_t a1, int32_t a2) {
    // 0x10000393c
    return _rand() % (a2 - a1) + a1;
}

// Address range: 0x100003980 - 0x100003a38
int64_t function_100003980(void) {
    // 0x100003980
    int64_t v1; // 0x100003980
    int32_t v2 = v1; // 0x100003990
    int32_t v3 = v2 - 1; // 0x100003998
    int64_t result; // 0x100003980
    if (v3 == 0 || v3 < 0 != (v2 & -v2) < 0) {
        // 0x100003a2c
        return result;
    }
    int32_t v4 = 1 - v2; // 0x1000039bc
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x100003a2c
        return result;
    }
    int32_t v5 = 0; // 0x1000039c4
    int64_t result2 = function_10000393c(v5, v2); // 0x1000039d4
    int32_t * v6 = (int32_t *)(4 * (int64_t)v5 + v1); // 0x1000039e4
    int32_t * v7 = (int32_t *)((0x100000000 * result2 >> 30) + v1); // 0x1000039f4
    *v6 = *v7;
    *v7 = *v6;
    v5++;
    int32_t v8 = v5 - v3; // 0x1000039bc
    while (v8 < 0 != ((v8 ^ v5) & (v5 ^ v3)) < 0) {
        // 0x1000039cc
        result2 = function_10000393c(v5, v2);
        v6 = (int32_t *)(4 * (int64_t)v5 + v1);
        v7 = (int32_t *)((0x100000000 * result2 >> 30) + v1);
        *v6 = *v7;
        *v7 = *v6;
        v5++;
        v8 = v5 - v3;
    }
    // 0x100003a2c
    return result2;
}

// Address range: 0x100003a38 - 0x100003b3c
int64_t function_100003a38(void) {
    // 0x100003a38
    int64_t v1; // 0x100003a38
    int32_t v2 = v1; // 0x100003a48
    int32_t v3 = -v2;
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003b24
        return _printf("\n");
    }
    int32_t v4 = 0; // 0x100003a64
    _printf("[");
    int32_t v5 = 0; // 0x100003af8
    if (v5 >= 1) {
        // 0x100003aac
        _printf(", ");
    }
    // 0x100003abc
    _printf("%d", v1);
    v5++;
    while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003a98
        if (v5 >= 1) {
            // 0x100003aac
            _printf(", ");
        }
        // 0x100003abc
        _printf("%d", v1);
        v5++;
    }
    // 0x100003b04
    _printf("]\n");
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003a98
        _printf("[");
        v5 = 0;
        if (v5 >= 1) {
            // 0x100003aac
            _printf(", ");
        }
        // 0x100003abc
        _printf("%d", v1);
        v5++;
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003a98
            if (v5 >= 1) {
                // 0x100003aac
                _printf(", ");
            }
            // 0x100003abc
            _printf("%d", v1);
            v5++;
        }
        // 0x100003b04
        _printf("]\n");
        v4++;
    }
    // 0x100003b24
    return _printf("\n");
}

// Address range: 0x100003b3c - 0x100003ed8
int64_t function_100003b3c(void) {
    // 0x100003b3c
    int64_t v1; // 0x100003b3c
    int32_t v2 = v1; // 0x100003b48
    if (v2 < 1) {
        // 0x100003ecc
        return _printf("[]\n");
    }
    int32_t v3 = 4 * v2;
    int64_t * v4 = _malloc(v3 * v2); // 0x100003b88
    if (v4 == NULL) {
        // 0x100003ecc
        return _printf("Failed to allocate memory.");
    }
    int64_t v5 = (int64_t)v4; // 0x100003b88
    int32_t v6 = -v2;
    int32_t v7 = 0; // 0x100003bcc
    if (v6 < 0 != (v6 & v2) < 0) {
        int32_t v8 = v7 * v2; // 0x100003c04
        int32_t v9 = 0;
        *(int32_t *)((int64_t)(4 * (v9 + v8)) + v5) = v9;
        int32_t v10 = v9 + 1; // 0x100003c1c
        while (v10 - v2 < 0 != ((v10 - v2 ^ v10) & (v10 ^ v2)) < 0) {
            // 0x100003bf4
            v9 = v10;
            *(int32_t *)((int64_t)(4 * (v9 + v8)) + v5) = v9;
            v10 = v9 + 1;
        }
        // 0x100003c2c
        v7++;
        while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
            // 0x100003bf4
            v8 = v7 * v2;
            v9 = 0;
            *(int32_t *)((int64_t)(4 * (v9 + v8)) + v5) = v9;
            v10 = v9 + 1;
            while (v10 - v2 < 0 != ((v10 - v2 ^ v10) & (v10 ^ v2)) < 0) {
                // 0x100003bf4
                v9 = v10;
                *(int32_t *)((int64_t)(4 * (v9 + v8)) + v5) = v9;
                v10 = v9 + 1;
            }
            // 0x100003c2c
            v7++;
        }
    }
    // 0x100003c3c
    function_100003980();
    int32_t v11 = v2 - 1; // 0x100003c5c
    int32_t v12 = 2 - v2; // 0x100003c60
    int32_t v13 = 1; // 0x100003c68
    if (v12 < 0 != (v12 & v11) < 0) {
        while (true) {
            int32_t v14 = v13;
            int32_t v15 = -v14;
            int32_t v16 = v14 * v2;
            function_100003980();
            if (v15 < 0 != (v14 & v15) < 0) {
                while (true) {
                    int32_t v17 = 0; // 0x100003d48
                    while (true) {
                        int32_t v18 = v17;
                        if (v6 < 0 != (v6 & v2) < 0) {
                            int32_t v19 = v18 * v2; // 0x100003cec
                            int32_t v20 = 0;
                            int32_t v21 = *(int32_t *)((int64_t)(4 * (v20 + v16)) + v5); // 0x100003d14
                            if (*(int32_t *)((int64_t)(4 * (v20 + v19)) + v5) == v21) {
                                // break (via goto) -> 0x100003c84
                                goto lab_0x100003c84;
                            }
                            int32_t v22 = v20 + 1; // 0x100003d34
                            while (v22 - v2 < 0 != ((v22 - v2 ^ v22) & (v22 ^ v2)) < 0) {
                                // 0x100003ce0
                                v20 = v22;
                                v21 = *(int32_t *)((int64_t)(4 * (v20 + v16)) + v5);
                                if (*(int32_t *)((int64_t)(4 * (v20 + v19)) + v5) == v21) {
                                    // break (via goto) -> 0x100003c84
                                    goto lab_0x100003c84;
                                }
                                // 0x100003cc8
                                v22 = v20 + 1;
                            }
                        }
                        // 0x100003d44
                        v17 = v18 + 1;
                        int32_t v23 = v17 - v14; // 0x100003cb0
                        if (v23 < 0 == ((v23 ^ v17) & (v17 ^ v14)) < 0) {
                            // break (via goto) -> 0x100003d68
                            goto lab_0x100003d68;
                        }
                    }
                  lab_0x100003c84:
                    // 0x100003c84
                    function_100003980();
                }
            }
          lab_0x100003d68:
            // 0x100003d68
            v13 = v14 + 1;
            int32_t v24 = v13 - v11; // 0x100003c60
            if (v24 < 0 == ((v24 ^ v13) & (v13 ^ v11)) < 0) {
                // break -> 0x100003d78
                break;
            }
        }
    }
    int64_t * v25 = _malloc(v3); // 0x100003d80
    if (v6 < 0 != (v6 & v2) < 0) {
        int64_t v26 = (int64_t)v25; // 0x100003d80
        int32_t v27 = 1 - v2;
        int32_t v28 = v11 * v2;
        int32_t v29 = 0; // 0x100003ea0
        while (true) {
            int32_t v30 = v29;
            ___memset_chk(v26, 0, 0x100000000 * v1 >> 30, -1);
            int32_t v31 = 0; // 0x100003ddc
            if (v27 < 0 != (v27 & v11) < 0) {
                int32_t v32 = *(int32_t *)((int64_t)(4 * (v31 * v2 + v30)) + v5); // 0x100003e00
                *(int32_t *)(4 * (int64_t)v32 + v26) = 1;
                int32_t v33 = v31 + 1; // 0x100003e14
                int32_t v34 = v33 - v11; // 0x100003dd4
                v31 = v33;
                while (v34 < 0 != ((v34 ^ v33) & (v33 ^ v11)) < 0) {
                    // 0x100003de4
                    v32 = *(int32_t *)((int64_t)(4 * (v31 * v2 + v30)) + v5);
                    *(int32_t *)(4 * (int64_t)v32 + v26) = 1;
                    v33 = v31 + 1;
                    v34 = v33 - v11;
                    v31 = v33;
                }
            }
            int32_t v35 = 0;
            while (*(int32_t *)(4 * (int64_t)v35 + v26) != 0) {
                int32_t v36 = v35 + 1; // 0x100003e8c
                int32_t v37 = v36 - v2; // 0x100003e30
                if (v37 < 0 == ((v37 ^ v36) & (v36 ^ v2)) < 0) {
                    goto lab_0x100003e9c;
                }
                v35 = v36;
            }
            // 0x100003e5c
            *(int32_t *)((int64_t)(4 * (v30 + v28)) + v5) = v35;
          lab_0x100003e9c:
            // 0x100003e9c
            v29 = v30 + 1;
            int32_t v38 = v29 - v2; // 0x100003d98
            if (v38 < 0 == ((v38 ^ v29) & (v29 ^ v2)) < 0) {
                // break -> 0x100003eac
                break;
            }
        }
    }
    // 0x100003eac
    _free(v25);
    function_100003a38();
    _free(v4);
    // 0x100003ecc
    return &g1;
}

// Address range: 0x100003ed8 - 0x100003f28
int64_t entry_point(void) {
    // 0x100003ed8
    _srand(_time(NULL));
    function_100003b3c();
    function_100003b3c();
    function_100003b3c();
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f28
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int64_t * ptr) {
    // 0x100003f34
    _free(ptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t size) {
    // 0x100003f40
    return _malloc(size);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(void) {
    // 0x100003f58
    return _rand();
}

// Address range: 0x100003f64 - 0x100003f70
void function_100003f64(int32_t seed) {
    // 0x100003f64
    _srand(seed);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(int32_t * timer) {
    // 0x100003f70
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <unistd.h>	//for isatty()
#include <stdio.h>	//for fileno()

int main(void)
{
	puts(isatty(fileno(stdin))
		? "stdin is tty"
		: "stdin is not tty");
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f64(struct _IO_FILE * stream);
int32_t function_100003f70(int32_t fd);
int32_t function_100003f7c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fileno(struct _IO_FILE * a1);
int32_t _isatty(int32_t a1);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003f00 - 0x100003f64
int64_t entry_point(void) {
    int32_t v1 = _fileno((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000); // 0x100003f24
    _puts(_isatty(v1) == 0 ? "stdin is not tty" : "stdin is tty");
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(struct _IO_FILE * stream) {
    // 0x100003f64
    return _fileno(stream);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(int32_t fd) {
    // 0x100003f70
    return _isatty(fd);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * s) {
    // 0x100003f7c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`/*
The function anynacci determines the n-arity of the sequence from the number of seed elements. 0 ended arrays are used since C does not have a way of determining the length of dynamic and function-passed integer arrays.*/

#include<stdlib.h>
#include<stdio.h>

int *
anynacci (int *seedArray, int howMany)
{
  int *result = malloc (howMany * sizeof (int));
  int i, j, initialCardinality;

  for (i = 0; seedArray[i] != 0; i++);
  initialCardinality = i;

  for (i = 0; i < initialCardinality; i++)
    result[i] = seedArray[i];

  for (i = initialCardinality; i < howMany; i++)
    {
      result[i] = 0;
      for (j = i - initialCardinality; j < i; j++)
        result[i] += result[j];
    }
  return result;
}

int
main ()
{
  int fibo[] = { 1, 1, 0 }, tribo[] = { 1, 1, 2, 0 }, tetra[] = { 1, 1, 2, 4, 0 }, luca[] = { 2, 1, 0 };
  int *fibonacci = anynacci (fibo, 10), *tribonacci = anynacci (tribo, 10), *tetranacci = anynacci (tetra, 10),
      *lucas = anynacci(luca, 10);
  int i;

  printf ("\nFibonacci\tTribonacci\tTetranacci\tLucas\n");

  for (i = 0; i < 10; i++)
    printf ("\n%d\t\t%d\t\t%d\t\t%d", fibonacci[i], tribonacci[i],
            tetranacci[i], lucas[i]);

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bf4(void);
int64_t function_100003f10(int64_t a1);
int64_t * function_100003f1c(int32_t size);
int32_t function_100003f28(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bf4 - 0x100003d60
int64_t function_100003bf4(void) {
    // 0x100003bf4
    int64_t v1; // 0x100003bf4
    int32_t v2 = v1; // 0x100003c04
    int64_t * v3 = _malloc(4 * v2); // 0x100003c10
    int32_t v4 = 0; // 0x100003c1c
    while (*(int32_t *)(4 * (int64_t)v4 + v1) != 0) {
        // 0x100003c20
        v4++;
    }
    int64_t result = (int64_t)v3; // 0x100003c10
    int32_t v5 = -v4;
    int32_t v6 = 0; // 0x100003c70
    if (v5 < 0 != (v4 & v5) < 0) {
        int64_t v7 = 4 * (int64_t)v6; // 0x100003c80
        *(int32_t *)(v7 + result) = *(int32_t *)(v7 + v1);
        v6++;
        while (v6 - v4 < 0 != ((v6 - v4 ^ v6) & (v6 ^ v4)) < 0) {
            // 0x100003c78
            v7 = 4 * (int64_t)v6;
            *(int32_t *)(v7 + result) = *(int32_t *)(v7 + v1);
            v6++;
        }
    }
    int32_t v8 = v4 - v2; // 0x100003cb8
    if (v8 < 0 == ((v8 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003d50
        return result;
    }
    int32_t * v9 = (int32_t *)(4 * (int64_t)v4 + result); // 0x100003cd4
    *v9 = 0;
    int32_t v10 = 0; // 0x100003ce0
    int32_t v11 = v10; // 0x100003cfc
    int32_t v12; // 0x100003bf4
    int32_t v13; // 0x100003d20
    int32_t v14; // 0x100003d30
    int32_t v15; // 0x100003cf4
    if (v5 < 0 != ((v10 ^ v5) & (v10 ^ v4)) < 0) {
        v13 = *(int32_t *)(4 * (int64_t)v11 + result);
        *v9 = v13;
        v14 = v11 + 1;
        v15 = v14 - v4;
        v12 = v13;
        v11 = v14;
        while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v4)) < 0) {
            // 0x100003d04
            v13 = *(int32_t *)(4 * (int64_t)v11 + result) + v12;
            *v9 = v13;
            v14 = v11 + 1;
            v15 = v14 - v4;
            v12 = v13;
            v11 = v14;
        }
    }
    int32_t v16 = v4 + 1; // 0x100003d44
    while (v16 - v2 < 0 != ((v16 - v2 ^ v16) & (v16 ^ v2)) < 0) {
        int32_t v17 = v16;
        v9 = (int32_t *)(4 * (int64_t)v17 + result);
        *v9 = 0;
        v10 = v17 - v4;
        v11 = v10;
        if (v5 < 0 != ((v10 ^ v5) & (v10 ^ v17)) < 0) {
            v13 = *(int32_t *)(4 * (int64_t)v11 + result);
            *v9 = v13;
            v14 = v11 + 1;
            v15 = v14 - v17;
            v12 = v13;
            v11 = v14;
            while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v17)) < 0) {
                // 0x100003d04
                v13 = *(int32_t *)(4 * (int64_t)v11 + result) + v12;
                *v9 = v13;
                v14 = v11 + 1;
                v15 = v14 - v17;
                v12 = v13;
                v11 = v14;
            }
        }
        // 0x100003d40
        v16 = v17 + 1;
    }
    // 0x100003d50
    return result;
}

// Address range: 0x100003d60 - 0x100003f10
int64_t entry_point(void) {
    // 0x100003d60
    function_100003bf4();
    function_100003bf4();
    function_100003bf4();
    function_100003bf4();
    _printf("\nFibonacci\tTribonacci\tTetranacci\tLucas\n");
    int32_t v1; // 0x100003ec4
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003e68
        int64_t v2; // 0x100003d60
        v1 = _printf("\n%d\t\t%d\t\t%d\t\t%d", 10, v2, v2, v2);
    }
    int64_t v3 = *(int64_t *)0x100004008; // 0x100003ee4
    if (*(int64_t *)v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003efc
        ___stack_chk_fail((int64_t)v1);
    }
    // 0x100003f00
    return 0;
}

// Address range: 0x100003f10 - 0x100003f1c
int64_t function_100003f10(int64_t a1) {
    // 0x100003f10
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f1c - 0x100003f28
int64_t * function_100003f1c(int32_t size) {
    // 0x100003f1c
    return _malloc(size);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(char * format, ...) {
    // 0x100003f28
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <arpa/inet.h>

int main()
{
  if (htonl(1) == 1)
    printf("big endian\n");
  else
    printf("little endian\n");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f6c - 0x100003f8c
int64_t entry_point(int64_t a1) {
    // 0x100003f6c
    _printf("little endian\n");
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>

char *to_base(int64_t num, int base)
{
  char *tbl = "0123456789abcdefghijklmnopqrstuvwxyz";
  char buf[66] = {'\0'};
  char *out;
  uint64_t n;
  int i, len = 0, neg = 0;
  if (base > 36) {
    fprintf(stderr, "base %d too large\n", base);
    return 0;
  }

  /* safe against most negative integer */
  n = ((neg = num < 0)) ? (~num) + 1 : num;

  do { buf[len++] = tbl[n % base]; } while(n /= base);

  out = malloc(len + neg + 1);
  for (i = neg; len > 0; i++) out[i] = buf[--len];
  if (neg) out[0] = '-';

  return out;
}

long from_base(const char *num_str, int base)
{
  char *endptr;
  /* there is also strtoul() for parsing into an unsigned long */
  /* in C99, there is also strtoll() and strtoull() for parsing into long long and
   * unsigned long long, respectively */
  int result = strtol(num_str, &endptr, base);
  return result;
}

int main()
{
  int64_t x;
  x = ~(1LL << 63) + 1;
  printf("%lld in base 2: %s\n", x, to_base(x, 2));
  x = 383;
  printf("%lld in base 16: %s\n", x, to_base(x, 16));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c0c(void);
int64_t function_100003e28(void);
int64_t function_100003efc(void);
int32_t function_100003f08(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f14(int32_t size);
int64_t * function_100003f20(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f2c(char * format, ...);
int32_t function_100003f38(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003c0c - 0x100003e28
int64_t function_100003c0c(void) {
    // 0x100003c0c
    int64_t v1; // 0x100003c0c
    int64_t v2 = v1;
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c20
    int32_t v4 = v1; // 0x100003c2c
    int64_t v5; // bp-90, 0x100003c0c
    _memset(&v5, 0, 66);
    int32_t v6 = v4 - 36; // 0x100003c58
    int64_t result; // 0x100003c0c
    if (v6 == 0 || v6 < 0 != (35 - v4 & v4) < 0) {
        uint64_t v7 = 0x100000000 * v1 >> 32; // 0x100003ce8
        int64_t v8 = &v5;
        uint64_t v9 = v2 >= 0 ? v2 : -v2;
        int32_t v10 = 0;
        char v11 = *(char *)(v9 % v7 + (int64_t)"0123456789abcdefghijklmnopqrstuvwxyz"); // 0x100003cfc
        int32_t v12 = v10 + 1; // 0x100003d08
        *(char *)((int64_t)v10 + v8) = v11;
        int64_t v13 = v9 / v7; // 0x100003d38
        while (v9 >= v7) {
            // 0x100003ce0
            v9 = v13;
            v10 = v12;
            v11 = *(char *)(v9 % v7 + (int64_t)"0123456789abcdefghijklmnopqrstuvwxyz");
            v12 = v10 + 1;
            *(char *)((int64_t)v10 + v8) = v11;
            v13 = v9 / v7;
        }
        int64_t * v14 = _malloc(v12 + (v2 < 0 ? 2 : 1)); // 0x100003d58
        char * v15 = (char *)v14; // bp-136, 0x100003d5c
        if (v12 >= 1) {
            int64_t v16 = (int64_t)v12 - 1;
            char v17 = *(char *)(v16 + v8); // 0x100003d94
            int64_t v18 = v2 < 0;
            *(char *)(v18 + (int64_t)v14) = v17;
            int64_t v19 = v18; // 0x100003d78
            if (v10 != 0) {
                int64_t v20 = v16;
                int64_t v21 = v20 - 1;
                char v22 = *(char *)(v21 + v8); // 0x100003d94
                *(char *)((0x100000000 * v19 + 0x100000000 >> 32) + (int64_t)v15) = v22;
                v19++;
                while (v20 >= 2) {
                    // 0x100003d80
                    v20 = v21;
                    v21 = v20 - 1;
                    v22 = *(char *)(v21 + v8);
                    *(char *)((0x100000000 * v19 + 0x100000000 >> 32) + (int64_t)v15) = v22;
                    v19++;
                }
            }
        }
        if (v2 >= 0) {
            // 0x100003dbc
            result = (int64_t)v15;
        } else {
            // 0x100003dd0
            *v15 = 45;
            result = (int64_t)v15;
        }
    } else {
        int64_t v23 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c70
        _fprintf((struct _IO_FILE *)v23, "base %d too large\n", 66);
        result = 0;
    }
    // 0x100003dec
    if (*(int64_t *)*(int64_t *)0x100004008 != v3) {
        // 0x100003e14
        ___stack_chk_fail();
    }
    // 0x100003e18
    return result;
}

// Address range: 0x100003e28 - 0x100003e64
int64_t function_100003e28(void) {
    // 0x100003e28
    int64_t v1; // bp-40, 0x100003e28
    int64_t v2; // 0x100003e28
    int32_t result = _strtol((char *)v2, (char **)&v1, (int32_t)v2); // 0x100003e48
    return result;
}

// Address range: 0x100003e64 - 0x100003efc
int64_t entry_point(void) {
    // 0x100003e64
    function_100003c0c();
    int64_t v1; // 0x100003e64
    char * v2 = (char *)v1; // 0x100003eb0
    _printf("%lld in base 2: %s\n", 2, v2);
    function_100003c0c();
    _printf("%lld in base 16: %s\n", 16, v2);
    return 0;
}

// Address range: 0x100003efc - 0x100003f08
int64_t function_100003efc(void) {
    // 0x100003efc
    return ___stack_chk_fail();
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f08
    return _fprintf(stream, format);
}

// Address range: 0x100003f14 - 0x100003f20
int64_t * function_100003f14(int32_t size) {
    // 0x100003f14
    return _malloc(size);
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t * function_100003f20(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f20
    return _memset(s, c, n);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * format, ...) {
    // 0x100003f2c
    return _printf(format);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * nptr, char ** endptr, int32_t base) {
    // 0x100003f38
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <string.h>

void nb(int cells, int total_block_size, int* blocks, int block_count,
        char* output, int offset, int* count) {
    if (block_count == 0) {
        printf("%2d  %s\n", ++*count, output);
        return;
    }
    int block_size = blocks[0];
    int max_pos = cells - (total_block_size + block_count - 1);
    total_block_size -= block_size;
    cells -= block_size + 1;
    ++blocks;
    --block_count;
    for (int i = 0; i <= max_pos; ++i, --cells) {
        memset(output + offset, '.', max_pos + block_size);
        memset(output + offset + i, '#', block_size);
        nb(cells, total_block_size, blocks, block_count, output,
           offset + block_size + i + 1, count);
    }
}

void nonoblock(int cells, int* blocks, int block_count) {
    printf("%d cells and blocks [", cells);
    for (int i = 0; i < block_count; ++i)
        printf(i == 0 ? "%d" : ", %d", blocks[i]);
    printf("]:\n");
    int total_block_size = 0;
    for (int i = 0; i < block_count; ++i)
        total_block_size += blocks[i];
    if (cells < total_block_size + block_count - 1) {
        printf("no solution\n");
        return;
    }
    char output[cells + 1];
    memset(output, '.', cells);
    output[cells] = '\0';
    int count = 0;
    nb(cells, total_block_size, blocks, block_count, output, 0, &count);
}

int main() {
    int blocks1[] = {2, 1};
    nonoblock(5, blocks1, 2);
    printf("\n");

    nonoblock(5, NULL, 0);
    printf("\n");

    int blocks2[] = {8};
    nonoblock(10, blocks2, 1);
    printf("\n");

    int blocks3[] = {2, 3, 2, 3};
    nonoblock(15, blocks3, 4);
    printf("\n");

    int blocks4[] = {2, 3};
    nonoblock(5, blocks4, 2);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a30(void);
int64_t function_100003bd8(int64_t a1, int64_t * a2, int64_t a3);
int64_t function_100003d64(void);
int64_t function_100003dc8(int64_t a1);
int64_t function_100003f10(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f1c(int64_t a1);
int32_t function_100003f28(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000002; // 0x100003f70
int64_t g2 = 0x300000002; // 0x100003f78
int32_t g3 = 8; // 0x100003f80
float128_t g4 = 6.36598737388394823701663973294276408e-314L; // 0x100003f90

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003a30 - 0x100003bd8
int64_t function_100003a30(void) {
    // 0x100003a30
    int64_t v1; // 0x100003a30
    int64_t v2 = v1;
    int32_t v3 = v1; // 0x100003a48
    if (v3 == 0) {
        // 0x100003a6c
        *(int32_t *)v2 = (int32_t)v2 + 1;
        // 0x100003bcc
        return _printf("%2d  %s\n", v1, (char *)v1);
    }
    int32_t v4 = 1 - v3 - (int32_t)v1 + (int32_t)v1; // 0x100003ac0
    int32_t v5 = -v4; // 0x100003b14
    int64_t result; // 0x100003a30
    if (v4 != 0 && v5 < 0 == (v4 & v5) < 0) {
        // 0x100003bcc
        return result;
    }
    int64_t v6 = (0x100000000 * v1 >> 32) + v1; // 0x100003b2c
    int32_t v7 = 0; // 0x100003bb4
    ___memset_chk(v6, 46, (int64_t)(v4 + (int32_t)v1), -1);
    ___memset_chk(v6 + (int64_t)v7, 35, 0x100000000 * v1 >> 32, -1);
    v7++;
    int32_t v8 = v7 - v4; // 0x100003b14
    result = function_100003a30();
    while (v8 == 0 || v8 < 0 != ((v8 ^ v7) & (v7 ^ v4)) < 0) {
        // 0x100003b24
        ___memset_chk(v6, 46, (int64_t)(v4 + (int32_t)v1), -1);
        ___memset_chk(v6 + (int64_t)v7, 35, 0x100000000 * v1 >> 32, -1);
        v7++;
        v8 = v7 - v4;
        result = function_100003a30();
    }
    // 0x100003bcc
    return result;
}

// Address range: 0x100003bd8 - 0x100003d64
int64_t function_100003bd8(int64_t a1, int64_t * a2, int64_t a3) {
    int64_t v1 = (int64_t)a2;
    _printf("%d cells and blocks [", v1);
    int32_t v2 = a3; // 0x100003c30
    int32_t v3 = -v2;
    int32_t v4; // 0x100003bd8
    int64_t v5; // bp-88, 0x100003bd8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003ca4
        _printf("]:\n");
        v4 = 0;
    } else {
        int32_t v6 = 0; // 0x100003c98
        uint32_t v7 = *(int32_t *)(4 * (int64_t)v6 + v1); // 0x100003c74
        *(int64_t *)((int64_t)&v5 - 16) = (int64_t)v7;
        _printf(v6 != 0 ? ", %d" : "%d");
        v6++;
        while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
            // 0x100003c44
            v7 = *(int32_t *)(4 * (int64_t)v6 + v1);
            *(int64_t *)((int64_t)&v5 - 16) = (int64_t)v7;
            _printf(v6 != 0 ? ", %d" : "%d");
            v6++;
        }
        // 0x100003ca4
        _printf("]:\n");
        int32_t v8 = 0; // 0x100003cf4
        int32_t v9 = 0; // 0x100003ce4
        v9 += *(int32_t *)(4 * (int64_t)v8 + v1);
        v8++;
        int32_t v10 = v8 - v2; // 0x100003cc4
        v4 = v9;
        while (v10 < 0 != ((v10 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x100003cd4
            v9 += *(int32_t *)(4 * (int64_t)v8 + v1);
            v8++;
            v10 = v8 - v2;
            v4 = v9;
        }
    }
    int64_t v11 = 0x100000000 * a1 >> 32; // 0x100003bf4
    int32_t v12 = v11; // 0x100003d00
    int32_t v13 = v2 - 1 + v4; // 0x100003d10
    int32_t v14 = v12 - v13; // 0x100003d14
    if (v14 < 0 == ((v14 ^ v12) & (v13 ^ v12)) < 0) {
        // 0x100003d34
        v5 = (v11 + 1 & 0xffffffff) + 15 & 0x1fffffff0;
        return ___chkstk_darwin();
    }
    // 0x100003d24
    return function_100003dc8((int64_t)_printf("no solution\n"));
}

// Address range: 0x100003d64 - 0x100003dc8
int64_t function_100003d64(void) {
    // 0x100003d64
    int64_t v1; // 0x100003d64
    int64_t v2; // 0x100003d64
    int64_t v3 = (int64_t)&v1 - *(int64_t *)(v2 - 80); // 0x100003d6c
    int64_t * v4 = (int64_t *)(v2 - 72); // 0x100003d74
    *v4 = v3;
    int32_t * v5 = (int32_t *)(v2 - 12); // 0x100003d7c
    ___memset_chk(v3, 46, (int64_t)*v5, -1);
    *(char *)(*v4 + (int64_t)*v5) = 0;
    *(int32_t *)(v2 - 60) = 0;
    return function_100003dc8(function_100003a30());
}

// Address range: 0x100003dc8 - 0x100003df8
int64_t function_100003dc8(int64_t a1) {
    int64_t result = a1; // 0x100003de0
    int64_t v1; // 0x100003dc8
    if (*(int64_t *)*(int64_t *)0x100004018 != *(int64_t *)(v1 - 8)) {
        // 0x100003de8
        result = ___stack_chk_fail(a1);
    }
    // 0x100003dec
    return result;
}

// Address range: 0x100003df8 - 0x100003f10
int64_t entry_point(void) {
    int64_t v1 = g1; // bp-32, 0x100003e30
    function_100003bd8(5, &v1, 2);
    _printf((char *)0x100003f6c);
    function_100003bd8(5, NULL, 0);
    _printf("\n");
    int32_t v2 = g3; // bp-64, 0x100003e7c
    function_100003bd8(10, (int64_t *)&v2, 1);
    _printf("\n");
    int64_t v3 = (float64_t)g4; // bp-48, 0x100003ea4
    function_100003bd8(15, &v3, 4);
    _printf("\n");
    int64_t v4 = g2; // bp-56, 0x100003ed4
    int64_t v5 = function_100003bd8(5, &v4, 2); // 0x100003ed8
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003ee8
    if (v6 != *(int64_t *)*(int64_t *)0x100004018) {
        // 0x100003efc
        ___stack_chk_fail(v5);
    }
    // 0x100003f00
    return 0;
}

// Address range: 0x100003f10 - 0x100003f1c
int64_t function_100003f10(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f10
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f1c - 0x100003f28
int64_t function_100003f1c(int64_t a1) {
    // 0x100003f1c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(char * format, ...) {
    // 0x100003f28
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

float *benford_distribution(void)
{
    static float prob[9];
    for (int i = 1; i < 10; i++)
        prob[i - 1] = log10f(1 + 1.0 / i);

    return prob;
}

float *get_actual_distribution(char *fn)
{
    FILE *input = fopen(fn, "r");
    if (!input)
    {
        perror("Can't open file");
        exit(EXIT_FAILURE);
    }

    int tally[9] = { 0 };
    char c;
    int total = 0;
    while ((c = getc(input)) != EOF)
    {
        /* get the first nonzero digit on the current line */
        while (c < '1' || c > '9')
            c = getc(input);

        tally[c - '1']++;
        total++;

        /* discard rest of line */
        while ((c = getc(input)) != '\n' && c != EOF)
            ;
    }
    fclose(input);

    static float freq[9];
    for (int i = 0; i < 9; i++)
        freq[i] = tally[i] / (float) total;

    return freq;
}

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf("Usage: benford <file>\n");
        return EXIT_FAILURE;
    }

    float *actual = get_actual_distribution(argv[1]);
    float *expected = benford_distribution();

    puts("digit\tactual\texpected");
    for (int i = 0; i < 9; i++)
        printf("%d\t%.3f\t%.3f\n", i + 1, actual[i], expected[i]);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b60(void);
int64_t function_100003bec(void);
int64_t function_100003ee0(void);
void function_100003eec(int32_t status);
int32_t function_100003ef8(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f04(char * filename, char * modes);
int32_t function_100003f10(struct _IO_FILE * stream);
float32_t function_100003f1c(float32_t a1);
int64_t * function_100003f28(int64_t * s, int32_t c, int32_t n);
void function_100003f34(char * s);
int32_t function_100003f40(char * format, ...);
int32_t function_100003f4c(char * s);

// --------------------- Global Variables ---------------------

float32_t * g1 = NULL; // 0x100008000
float32_t * g2 = NULL; // 0x100008024

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _getc(struct _IO_FILE * a1);
float32_t _log10f(float32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
void _perror(char * a1);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b60 - 0x100003bec
int64_t function_100003b60(void) {
    int64_t v1 = 1;
    float64_t v2; // 0x100003b60
    float64_t v3 = 1.0 / v2 + 1.0; // 0x100003ba4
    _log10f((float32_t)(int32_t)__asm_sshll(0.0f, 0));
    *(float32_t *)(4 * v1 + (int64_t)&g1 - 4) = (float32_t)v3;
    v1++;
    while (v1 != 10) {
        // 0x100003b8c
        v3 = 1.0 / v3 + 1.0;
        _log10f((float32_t)(int32_t)__asm_sshll(0.0f, 0));
        *(float32_t *)(4 * v1 + (int64_t)&g1 - 4) = (float32_t)v3;
        v1++;
    }
    // 0x100003bd8
    return (int64_t)&g1;
}

// Address range: 0x100003bec - 0x100003de8
int64_t function_100003bec(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c00
    int64_t v2; // 0x100003bec
    struct _IO_FILE * v3 = _fopen((char *)v2, "r"); // 0x100003c18
    if (v3 == NULL) {
        // 0x100003c34
        _perror("Can't open file");
        _exit(1);
        // UNREACHABLE
    }
    // 0x100003c48
    int64_t v4; // bp-60, 0x100003bec
    _memset(&v4, 0, 36);
    int32_t v5 = _getc(v3); // 0x100003c64
    int64_t v6 = &v4;
    float32_t v7 = 0.0f; // 0x100003c78
    if (v5 % 256 != 255) {
        float32_t v8 = 0.0f;
        int32_t v9 = v5; // 0x100003bec
        int32_t v10; // 0x100003bec
        int32_t v11; // 0x100003ca4
        int32_t v12; // 0x100003c84
        while (true) {
            // 0x100003c84
            v10 = 0x1000000 * v9;
            v12 = v10 >> 24;
            if (v10 < 0x31000000 == (48 - v12 & v12) < 0) {
                // 0x100003cb4
                v11 = v12 - 57;
                if (v11 == 0 || v11 < 0 != (56 - v12 & v12) < 0) {
                    // break -> 0x100003cd0
                    break;
                }
            }
            // 0x100003cc0
            v9 = _getc(v3);
        }
        int32_t * v13 = (int32_t *)(4 * (int64_t)(v12 - 49) + v6); // 0x100003ce0
        *v13 = *v13 + 1;
        uint32_t v14 = _getc(v3) % 256;
        while (v14 != 10 == (v14 != 255)) {
            // 0x100003cfc
            v14 = _getc(v3) % 256;
        }
        int32_t v15 = _getc(v3); // 0x100003c64
        float32_t v16 = (int32_t)v8 + 1; // 0x100003c78
        v7 = (int32_t)v8 + 1;
        while (v15 % 256 != 255) {
            // 0x100003c84
            v8 = v16;
            v9 = v15;
            while (true) {
                // 0x100003c84
                v10 = 0x1000000 * v9;
                v12 = v10 >> 24;
                if (v10 < 0x31000000 == (48 - v12 & v12) < 0) {
                    // 0x100003cb4
                    v11 = v12 - 57;
                    if (v11 == 0 || v11 < 0 != (56 - v12 & v12) < 0) {
                        // break -> 0x100003cd0
                        break;
                    }
                }
                // 0x100003cc0
                v9 = _getc(v3);
            }
            // 0x100003cd0
            v13 = (int32_t *)(4 * (int64_t)(v12 - 49) + v6);
            *v13 = *v13 + 1;
            v14 = _getc(v3) % 256;
            while (v14 != 10 == (v14 != 255)) {
                // 0x100003cfc
                v14 = _getc(v3) % 256;
            }
            // 0x100003c60
            v15 = _getc(v3);
            v16 = (int32_t)v8 + 1;
            v7 = (int32_t)v8 + 1;
        }
    }
    // 0x100003d4c
    _fclose(v3);
    for (int64_t i = 0; i < 9; i++) {
        int64_t v17 = 4 * i; // 0x100003d78
        float32_t v18 = *(float32_t *)(v17 + v6); // 0x100003d78
        *(float32_t *)(v17 + (int64_t)&g2) = v18 / v7;
    }
    // 0x100003db0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003dd0
        ___stack_chk_fail();
    }
    // 0x100003dd4
    return (int64_t)&g2;
}

// Address range: 0x100003de8 - 0x100003ee0
int64_t entry_point(void) {
    // 0x100003de8
    int64_t v1; // 0x100003de8
    if ((int32_t)v1 != 2) {
        // 0x100003e14
        _printf("Usage: benford <file>\n");
        // 0x100003ed0
        return 1;
    }
    // 0x100003e2c
    function_100003bec();
    function_100003b60();
    _puts("digit\tactual\texpected");
    for (int32_t i = 0; i < 9; i++) {
        // 0x100003e6c
        int128_t v2; // 0x100003de8
        _printf("%d\t%.3f\t%.3f\n", v1, (float64_t)(int64_t)v2, (float64_t)(int64_t)v2);
    }
    // 0x100003ed0
    return 0;
}

// Address range: 0x100003ee0 - 0x100003eec
int64_t function_100003ee0(void) {
    // 0x100003ee0
    return ___stack_chk_fail();
}

// Address range: 0x100003eec - 0x100003ef8
void function_100003eec(int32_t status) {
    // 0x100003eec
    _exit(status);
}

// Address range: 0x100003ef8 - 0x100003f04
int32_t function_100003ef8(struct _IO_FILE * stream) {
    // 0x100003ef8
    return _fclose(stream);
}

// Address range: 0x100003f04 - 0x100003f10
struct _IO_FILE * function_100003f04(char * filename, char * modes) {
    // 0x100003f04
    return _fopen(filename, modes);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(struct _IO_FILE * stream) {
    // 0x100003f10
    return _getc(stream);
}

// Address range: 0x100003f1c - 0x100003f28
float32_t function_100003f1c(float32_t a1) {
    // 0x100003f1c
    return _log10f(a1);
}

// Address range: 0x100003f28 - 0x100003f34
int64_t * function_100003f28(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f28
    return _memset(s, c, n);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(char * s) {
    // 0x100003f34
    _perror(s);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(char * format, ...) {
    // 0x100003f40
    return _printf(format);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * s) {
    // 0x100003f4c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <stdlib.h>

/* func: our one and only data type; it holds either a pointer to
   a function call, or an integer.  Also carry a func pointer to
   a potential parameter, to simulate closure                   */
typedef struct func_t *func;
typedef struct func_t {
        func (*fn) (func, func);
        func _;
        int num;
} func_t;

func new(func(*f)(func, func), func _) {
        func x = malloc(sizeof(func_t));
        x->fn = f;
        x->_ = _;       /* closure, sort of */
        x->num = 0;
        return x;
}

func call(func f, func n) {
        return f->fn(f, n);
}

func Y(func(*f)(func, func)) {
        func g = new(f, 0);
        g->_ = g;
        return g;
}

func num(int n) {
        func x = new(0, 0);
        x->num = n;
        return x;
}


func fac(func self, func n) {
        int nn = n->num;
        return nn > 1   ? num(nn * call(self->_, num(nn - 1))->num)
                        : num(1);
}

func fib(func self, func n) {
        int nn = n->num;
        return nn > 1
                ? num(  call(self->_, num(nn - 1))->num +
                        call(self->_, num(nn - 2))->num )
                : num(1);
}

void show(func n) { printf(" %d", n->num); }

int main() {
        int i;
        func f = Y(fac);
        printf("fac: ");
        for (i = 1; i < 10; i++)
                show( call(f, num(i)) );
        printf("\n");

        f = Y(fib);
        printf("fib: ");
        for (i = 1; i < 10; i++)
                show( call(f, num(i)) );
        printf("\n");

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bd8(int64_t a1, int64_t a2);
int64_t function_100003c28(void);
int64_t function_100003c50(int64_t a1, int64_t a2);
int64_t function_100003c5c(int64_t a1);
int64_t function_100003c98(int32_t a1);
int64_t function_100003cd4(void);
int64_t function_100003d6c(void);
int64_t function_100003e28(int64_t a1);
int64_t * function_100003f7c(int32_t size);
int32_t function_100003f88(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bd8 - 0x100003c28
int64_t function_100003bd8(int64_t a1, int64_t a2) {
    int64_t * v1 = _malloc(24); // 0x100003bf0
    int64_t result = (int64_t)v1; // 0x100003bf0
    *v1 = a1;
    *(int64_t *)(result + 8) = a2;
    *(int32_t *)(result + 16) = 0;
    return result;
}

// Address range: 0x100003c28 - 0x100003c50
int64_t function_100003c28(void) {
    // 0x100003c28
    int64_t result; // 0x100003c28
    return result;
}

// Address range: 0x100003c50 - 0x100003c5c
int64_t function_100003c50(int64_t a1, int64_t a2) {
    // 0x100003c50
    int64_t result; // 0x100003c50
    return result;
}

// Address range: 0x100003c5c - 0x100003c98
int64_t function_100003c5c(int64_t a1) {
    int64_t result = function_100003bd8(a1, 0); // 0x100003c74
    *(int64_t *)(result + 8) = result;
    return result;
}

// Address range: 0x100003c98 - 0x100003cd4
int64_t function_100003c98(int32_t a1) {
    int64_t result = function_100003bd8(0, 0); // 0x100003cb0
    *(int32_t *)(result + 16) = a1;
    return result;
}

// Address range: 0x100003cd4 - 0x100003d6c
int64_t function_100003cd4(void) {
    // 0x100003cd4
    int64_t v1; // 0x100003cd4
    int32_t v2 = *(int32_t *)(v1 + 16); // 0x100003cec
    int32_t v3 = v2 - 1; // 0x100003cf8
    int64_t result; // 0x100003cd4
    if (v3 == 0 || v3 < 0 != (v2 & -v2) < 0) {
        // 0x100003d4c
        result = function_100003c98(1);
    } else {
        // 0x100003d08
        function_100003c98(v3);
        int32_t v4 = *(int32_t *)(function_100003c28() + 16); // 0x100003d38
        result = function_100003c98(v4 * v2);
    }
    // 0x100003d5c
    return result;
}

// Address range: 0x100003d6c - 0x100003e28
int64_t function_100003d6c(void) {
    // 0x100003d6c
    int64_t v1; // 0x100003d6c
    int32_t v2 = *(int32_t *)(v1 + 16); // 0x100003d84
    int32_t v3 = v2 - 1; // 0x100003d90
    int64_t result; // 0x100003d6c
    if (v3 == 0 || v3 < 0 != (v2 & -v2) < 0) {
        // 0x100003e08
        result = function_100003c98(1);
    } else {
        // 0x100003da0
        function_100003c98(v3);
        int32_t v4 = *(int32_t *)(function_100003c28() + 16); // 0x100003dc4
        function_100003c98(v2 - 2);
        int32_t v5 = *(int32_t *)(function_100003c28() + 16); // 0x100003df4
        result = function_100003c98(v5 + v4);
    }
    // 0x100003e18
    return result;
}

// Address range: 0x100003e28 - 0x100003e64
int64_t function_100003e28(int64_t a1) {
    // 0x100003e28
    int64_t v1; // 0x100003e28
    return _printf(" %d", v1);
}

// Address range: 0x100003e64 - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003e64
    function_100003c5c(0x100003cd4);
    _printf("fac: ");
    for (int32_t i = 1; i < 10; i++) {
        // 0x100003eb0
        function_100003c98(i);
        function_100003e28(function_100003c28());
    }
    // 0x100003ee4
    _printf("\n");
    function_100003c5c(0x100003d6c);
    _printf("fib: ");
    for (int32_t i = 1; i < 10; i++) {
        // 0x100003f2c
        function_100003c98(i);
        function_100003e28(function_100003c28());
    }
    // 0x100003f60
    _printf("\n");
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int64_t * function_100003f7c(int32_t size) {
    // 0x100003f7c
    return _malloc(size);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>		/* getaddrinfo, getnameinfo */
#include <stdio.h>		/* fprintf, printf */
#include <stdlib.h>		/* exit */
#include <string.h>		/* memset */

int
main()
{
	struct addrinfo hints, *res, *res0;
	int error;
	char host[NI_MAXHOST];

	/*
	 * Request only one socket type from getaddrinfo(). Else we
	 * would get both SOCK_DGRAM and SOCK_STREAM, and print two
	 * copies of each numeric address.
	 */
	memset(&hints, 0, sizeof hints);
	hints.ai_family = PF_UNSPEC;     /* IPv4, IPv6, or anything */
	hints.ai_socktype = SOCK_DGRAM;  /* Dummy socket type */

	/*
	 * Use getaddrinfo() to resolve "www.kame.net" and allocate
	 * a linked list of addresses.
	 */
	error = getaddrinfo("www.kame.net", NULL, &hints, &res0);
	if (error) {
		fprintf(stderr, "%s\n", gai_strerror(error));
		exit(1);
	}

	/* Iterate the linked list. */
	for (res = res0; res; res = res->ai_next) {
		/*
		 * Use getnameinfo() to convert res->ai_addr to a
		 * printable string.
		 *
		 * NI_NUMERICHOST means to present the numeric address
		 * without doing reverse DNS to get a domain name.
		 */
		error = getnameinfo(res->ai_addr, res->ai_addrlen,
		    host, sizeof host, NULL, 0, NI_NUMERICHOST);

		if (error) {
			fprintf(stderr, "%s\n", gai_strerror(error));
		} else {
			/* Print the numeric address. */
			printf("%s\n", host);
		}
	}

	/* Free the linked list. */
	freeaddrinfo(res0);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct addrinfo {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct sockaddr * e5;
    char * e6;
    struct addrinfo * e7;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f28(int64_t a1);
void function_100003f34(int32_t status);
int32_t function_100003f40(struct _IO_FILE * stream, char * format, ...);
void function_100003f4c(struct addrinfo * ai);
char * function_100003f58(int32_t ecode);
int32_t function_100003f64(char * name, char * service, struct addrinfo * req, struct addrinfo ** pai);
int32_t function_100003f70(struct sockaddr * sa, int32_t salen, char * host, int32_t hostlen, char * serv, int32_t servlen, int32_t flags);
int64_t * function_100003f7c(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f88(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _freeaddrinfo(struct addrinfo * a1);
char * _gai_strerror(int32_t a1);
int32_t _getaddrinfo(char * a1, char * a2, struct addrinfo * a3, struct addrinfo ** a4);
int32_t _getnameinfo(struct sockaddr * a1, int32_t a2, char * a3, int32_t a4, char * a5, int32_t a6, int32_t a7);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d70 - 0x100003f28
int64_t entry_point(void) {
    // 0x100003d70
    int64_t v1; // bp-1112, 0x100003d70
    _memset(&v1, 0, 48);
    struct addrinfo * v2; // bp-1128, 0x100003d70
    int32_t v3 = _getaddrinfo("www.kame.net", NULL, (struct addrinfo *)&v1, &v2); // 0x100003dc8
    if (v3 != 0) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003dec
        _gai_strerror(v3);
        _fprintf((struct _IO_FILE *)v4, "%s\n", &v1);
        _exit(1);
        // UNREACHABLE
    }
    struct addrinfo * v5 = v2; // 0x100003e20
    v2 = NULL;
    if (v5 != NULL) {
        int64_t v6 = (int64_t)v5; // 0x100003edc
        int64_t v7 = *(int64_t *)(v6 + 32); // 0x100003e44
        uint32_t v8 = *(int32_t *)(v6 + 16); // 0x100003e4c
        int64_t v9; // bp-1057, 0x100003d70
        int32_t v10 = _getnameinfo((struct sockaddr *)v7, v8, (char *)&v9, 1025, NULL, 0, 2); // 0x100003e64
        int64_t v11; // 0x100003e88
        if (v10 == 0) {
            // 0x100003eb8
            _printf("%s\n", (char *)(int64_t)v8);
        } else {
            // 0x100003e80
            v11 = *(int64_t *)*(int64_t *)0x100004010;
            _gai_strerror(v10);
            _fprintf((struct _IO_FILE *)v11, "%s\n", &v9);
        }
        // 0x100003ed8
        v6 += 40;
        while (v6 != 0) {
            // 0x100003e40
            v7 = *(int64_t *)(v6 + 32);
            v8 = *(int32_t *)(v6 + 16);
            v10 = _getnameinfo((struct sockaddr *)v7, v8, (char *)&v9, 1025, NULL, 0, 2);
            if (v10 == 0) {
                // 0x100003eb8
                _printf("%s\n", (char *)(int64_t)v8);
            } else {
                // 0x100003e80
                v11 = *(int64_t *)*(int64_t *)0x100004010;
                _gai_strerror(v10);
                _fprintf((struct _IO_FILE *)v11, "%s\n", &v9);
            }
            // 0x100003ed8
            v6 += 40;
        }
    }
    // 0x100003ee8
    _freeaddrinfo(v2);
    int64_t v12 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003efc
    if (v12 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f10
        ___stack_chk_fail((int64_t)&g1);
    }
    // 0x100003f14
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(int64_t a1) {
    // 0x100003f28
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int32_t status) {
    // 0x100003f34
    _exit(status);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f40
    return _fprintf(stream, format);
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(struct addrinfo * ai) {
    // 0x100003f4c
    _freeaddrinfo(ai);
}

// Address range: 0x100003f58 - 0x100003f64
char * function_100003f58(int32_t ecode) {
    // 0x100003f58
    return _gai_strerror(ecode);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * name, char * service, struct addrinfo * req, struct addrinfo ** pai) {
    // 0x100003f64
    return _getaddrinfo(name, service, req, pai);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(struct sockaddr * sa, int32_t salen, char * host, int32_t hostlen, char * serv, int32_t servlen, int32_t flags) {
    // 0x100003f70
    return _getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);
}

// Address range: 0x100003f7c - 0x100003f88
int64_t * function_100003f7c(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f7c
    return _memset(s, c, n);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <string.h>
#include <locale.h>

typedef int bool;
typedef unsigned long long ull;

#define TRUE 1
#define FALSE 0

char as_digit(int d) {
    return (d >= 0 && d <= 9) ? d + '0' : d - 10 + 'a';
}

void revstr(char *str) {
    int i, len = strlen(str);
    char t;
    for (i = 0; i < len/2; ++i) {
        t = str[i];
        str[i] = str[len - i - 1];
        str[len - i - 1] = t;
    }
}

char* to_base(char s[], ull n, int b) {
    int i = 0;
    while (n) {
        s[i++] = as_digit(n % b);
        n /= b;
    }
    s[i] = '\0';
    revstr(s);
    return s;
}

ull uabs(ull a, ull  b) {
    return a > b ? a - b : b - a;
}

bool is_esthetic(ull n, int b) {
    int i, j;
    if (!n) return FALSE;
    i = n % b;
    n /= b;
    while (n) {
        j = n % b;
        if (uabs(i, j) != 1) return FALSE;
        n /= b;
        i = j;
    }
    return TRUE;
}

ull esths[45000];
int le = 0;

void dfs(ull n, ull m, ull i) {
    ull d, i1, i2;
    if (i >= n && i <= m) esths[le++] = i;
    if (i == 0 || i > m) return;
    d = i % 10;
    i1 = i * 10 + d - 1;
    i2 = i1 + 2;
    if (d == 0) {
        dfs(n, m, i2);
    } else if (d == 9) {
        dfs(n, m, i1);
    } else {
        dfs(n, m, i1);
        dfs(n, m, i2);
    }
}

void list_esths(ull n, ull n2, ull m, ull m2, int per_line, bool all) {
    int i;
    le = 0;
    for (i = 0; i < 10; ++i) {
        dfs(n2, m2, i);
    }
    printf("Base 10: %'d esthetic numbers between %'llu and %'llu:\n", le, n, m);
    if (all) {
        for (i = 0; i < le; ++i) {
            printf("%llu ", esths[i]);
            if (!(i+1)%per_line) printf("\n");
        }
    } else {
        for (i = 0; i < per_line; ++i) printf("%llu ", esths[i]);
        printf("\n............\n");
        for (i = le - per_line; i < le; ++i) printf("%llu ", esths[i]);
    }
    printf("\n\n");
}

int main() {
    ull n;
    int b, c;
    char ch[15] = {0};
    for (b = 2; b <= 16; ++b) {
        printf("Base %d: %dth to %dth esthetic numbers:\n", b, 4*b, 6*b);
        for (n = 1, c = 0; c < 6 * b; ++n) {
            if (is_esthetic(n, b)) {
                if (++c >= 4 * b) printf("%s ", to_base(ch, n, b));
            }
        }
        printf("\n\n");
    }
    char *oldLocale = setlocale(LC_NUMERIC, NULL);
    setlocale(LC_NUMERIC, "");

    // the following all use the obvious range limitations for the numbers in question
    list_esths(1000, 1010, 9999, 9898, 16, TRUE);
    list_esths(1e8, 101010101, 13*1e7, 123456789, 9, TRUE);
    list_esths(1e11, 101010101010, 13*1e10, 123456789898, 7, FALSE);
    list_esths(1e14, 101010101010101, 13*1e13, 123456789898989, 5, FALSE);
    list_esths(1e17, 101010101010101010, 13*1e16, 123456789898989898, 4, FALSE);
    setlocale(LC_NUMERIC, oldLocale);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003564(void);
int64_t function_1000035c8(void);
int64_t function_100003690(void);
int64_t function_100003734(void);
int64_t function_10000378c(void);
int64_t function_100003870(void);
int64_t function_1000039d0(void);
int64_t function_100003ee8(int64_t a1);
int32_t function_100003ef4(char * format, ...);
char * function_100003f00(int32_t category, char * locale);
int32_t function_100003f0c(char * s);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
char * _setlocale(int32_t a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003564 - 0x1000035c8
int64_t function_100003564(void) {
    // 0x100003564
    int64_t v1; // 0x100003564
    int32_t v2 = v1; // 0x100003568
    if (v2 < 0) {
        // 0x1000035b8
        return 0x1000000 * (v2 + 87) >> 24;
    }
    int32_t v3 = v2 - 9; // 0x100003584
    if (v3 != 0 && v3 < 0 == (8 - v2 & v2) < 0) {
        // 0x1000035b8
        return 0x1000000 * (v2 + 87) >> 24;
    }
    // 0x1000035b8
    return 0x1000000 * (v2 + 48) >> 24;
}

// Address range: 0x1000035c8 - 0x100003690
int64_t function_1000035c8(void) {
    // 0x1000035c8
    int64_t v1; // 0x1000035c8
    int32_t result = _strlen((char *)v1); // 0x1000035dc
    int32_t v2 = result / 2; // 0x1000035fc
    if (result > 1 == (v2 & -v2) < 0) {
        // 0x100003684
        return result;
    }
    int32_t v3 = 0; // 0x100003608
    char * v4 = (char *)(v1 + (int64_t)v3); // 0x10000361c
    char * v5 = (char *)(v1 + (int64_t)(result + -1 - v3)); // 0x10000363c
    *v4 = *v5;
    *v5 = *v4;
    v3++;
    while (v3 - v2 < 0 != ((v3 - v2 ^ v3) & (v3 ^ v2)) < 0) {
        // 0x100003610
        v4 = (char *)(v1 + (int64_t)v3);
        v5 = (char *)(v1 + (int64_t)(result + -1 - v3));
        *v4 = *v5;
        *v5 = *v4;
        v3++;
    }
    // 0x100003684
    return result;
}

// Address range: 0x100003690 - 0x100003734
int64_t function_100003690(void) {
    // 0x100003690
    int64_t result; // 0x100003690
    if (result == 0) {
        // 0x10000370c
        *(char *)result = 0;
        function_1000035c8();
        return result;
    }
    uint64_t v1 = 0x100000000 * result >> 32;
    int32_t v2 = 0;
    int64_t v3; // 0x100003690
    uint64_t v4 = v3;
    int64_t v5 = function_100003564(); // 0x1000036dc
    int32_t v6 = v2 + 1; // 0x1000036ec
    *(char *)(result + (int64_t)v2) = (char)v5;
    v3 = v4 / v1;
    while (v1 <= v4) {
        // 0x1000036c4
        v2 = v6;
        v4 = v3;
        v5 = function_100003564();
        v6 = v2 + 1;
        *(char *)(result + (int64_t)v2) = (char)v5;
        v3 = v4 / v1;
    }
    // 0x10000370c
    *(char *)((int64_t)v6 + result) = 0;
    function_1000035c8();
    return result;
}

// Address range: 0x100003734 - 0x10000378c
int64_t function_100003734(void) {
    // 0x100003734
    int64_t v1; // 0x100003734
    uint64_t v2 = v1;
    uint64_t v3 = v1;
    return v3 == v2 | v3 < v2 ? v2 - v3 : v3 - v2;
}

// Address range: 0x10000378c - 0x100003870
int64_t function_10000378c(void) {
    // 0x10000378c
    int64_t v1; // 0x10000378c
    if (v1 == 0) {
        // 0x100003860
        return 0;
    }
    uint64_t v2 = 0x100000000 * v1 >> 32; // 0x1000037d4
    int64_t result = 1; // 0x1000037f4
    int64_t v3; // 0x10000378c
    while (v2 <= v3) {
        // 0x1000037fc
        v3 /= v2;
        result = 0;
        if (function_100003734() != 1) {
            // break -> 0x100003860
            break;
        }
        result = 1;
    }
    // 0x100003860
    return result;
}

// Address range: 0x100003870 - 0x1000039d0
int64_t function_100003870(void) {
    // 0x100003870
    int64_t v1; // 0x100003870
    uint64_t v2 = v1;
    uint64_t v3 = v1;
    if (v2 >= v1) {
        if (v2 >= v3 != v2 != v3) {
            // 0x1000038b8
            *(int32_t *)&g1 = *(int32_t *)&g1 + 1;
        }
    }
    int64_t result; // 0x100003870
    if (v2 == 0) {
        // 0x1000039c4
        return result;
    }
    if (v2 != v3 && v2 >= v3) {
        // 0x1000039c4
        return result;
    }
    uint64_t v4 = v2 % 10;
    if (v4 == 0) {
        // 0x1000039c4
        return function_100003870();
    }
    // 0x100003974
    result = function_100003870();
    if (v4 != 9) {
        // 0x10000399c
        result = function_100003870();
    }
    // 0x1000039c4
    return result;
}

// Address range: 0x1000039d0 - 0x100003c10
int64_t function_1000039d0(void) {
    // 0x1000039d0
    int64_t v1; // 0x1000039d0
    int64_t v2 = v1;
    *(int32_t *)&g1 = 0;
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003a18
        function_100003870();
    }
    int32_t v3 = v1; // 0x1000039ec
    _printf("Base 10: %'d esthetic numbers between %'llu and %'llu:\n", v2, 9, v2);
    if ((int32_t)v1 != 0) {
        int32_t v4 = *(int32_t *)&g1; // 0x100003a90
        int32_t v5 = -v4; // 0x100003a94
        if (v5 < 0 == (v4 & v5) < 0) {
            // 0x100003bf8
            return _printf("\n\n");
        }
        int32_t v6 = 0; // 0x100003a9c
        _printf("%llu ", v2);
        int32_t v7 = v6 == -1; // 0x100003ae0
        if (v7 % v3 - v7 != (int32_t)(v6 == -1)) {
            // 0x100003afc
            _printf("\n");
        }
        // 0x100003b10
        v6++;
        int32_t v8 = *(int32_t *)&g1; // 0x100003a90
        while (v6 - v8 < 0 != ((v6 - v8 ^ v6) & (v8 ^ v6)) < 0) {
            // 0x100003aa4
            _printf("%llu ", v2);
            v7 = v6 == -1;
            if (v7 % v3 - v7 != (int32_t)(v6 == -1)) {
                // 0x100003afc
                _printf("\n");
            }
            // 0x100003b10
            v6++;
            v8 = *(int32_t *)&g1;
        }
        // 0x100003bf8
        return _printf("\n\n");
    }
    int32_t v9 = -v3;
    if (v9 < 0 != (v9 & v3) < 0) {
        _printf("%llu ", v2);
        int32_t v10 = 1; // 0x100003b70
        int32_t v11 = v10 - v3; // 0x100003b34
        int32_t v12 = v10; // 0x100003b3c
        while (v11 < 0 != ((v11 ^ v10) & (v10 ^ v3)) < 0) {
            // 0x100003b44
            _printf("%llu ", v2);
            v10 = v12 + 1;
            v11 = v10 - v3;
            v12 = v10;
        }
    }
    // 0x100003b7c
    _printf("\n............\n");
    int32_t v13 = *(int32_t *)&g1;
    int32_t v14 = v13 - v3; // 0x100003b94
    if (v9 < 0 == ((v14 ^ v9) & (v14 ^ v13)) < 0) {
        // 0x100003bf8
        return _printf("\n\n");
    }
    int32_t v15 = v14; // 0x100003bb4
    _printf("%llu ", v2);
    v15++;
    int32_t v16 = *(int32_t *)&g1; // 0x100003ba8
    while (v15 - v16 < 0 != ((v15 - v16 ^ v15) & (v16 ^ v15)) < 0) {
        // 0x100003bbc
        _printf("%llu ", v2);
        v15++;
        v16 = *(int32_t *)&g1;
    }
    // 0x100003bf8
    return _printf("\n\n");
}

// Address range: 0x100003c10 - 0x100003ee8
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c24
    uint32_t v2 = 2;
    int64_t v3; // 0x100003c10
    int64_t v4; // 0x100003c10
    int64_t v5; // 0x100003c10
    _printf("Base %d: %dth to %dth esthetic numbers:\n", v4, v5, v3);
    int32_t v6 = 6 * v2; // 0x100003cbc
    int32_t v7 = -v6; // 0x100003cc0
    int64_t v8 = v4; // 0x100003cc8
    int64_t v9 = v5; // 0x100003cc8
    char * v10; // 0x100003c10
    char * v11; // 0x100003c10
    int32_t v12; // 0x100003c10
    int32_t v13; // 0x100003c10
    int32_t v14; // 0x100003c10
    int32_t v15; // 0x100003c10
    int32_t v16; // 0x100003cc0
    int32_t v17; // 0x100003cf0
    int32_t v18; // 0x100003d04
    int64_t v19; // 0x100003cd4
    int64_t v20; // 0x100003c10
    int64_t v21; // 0x100003c10
    int64_t v22; // 0x100003c10
    int64_t v23; // 0x100003c10
    if (v7 < 0 != (v6 & v7) < 0) {
        // 0x100003cd0
        v19 = v2;
        v15 = 4 * v2;
        v11 = (char *)1;
        v12 = 0;
        v13 = v12;
        v20 = v19;
        v22 = v5;
        if ((int32_t)function_10000378c() != 0) {
            // 0x100003cec
            v17 = v12 + 1;
            v18 = v17 - v15;
            v13 = v17;
            v20 = v19;
            v22 = v5;
            if (v18 < 0 == ((v18 ^ v17) & (v17 ^ v15)) < 0) {
                // 0x100003d14
                function_100003690();
                _printf("%s ", v11);
                v13 = v17;
                v20 = (int64_t)v11;
                v22 = v19;
            }
        }
        // 0x100003d44
        v23 = v22;
        v14 = v13;
        v16 = v14 - v6;
        v10 = (char *)((int64_t)v11 + 1);
        v8 = v20;
        v9 = v23;
        while (v16 < 0 != ((v16 ^ v14) & (v14 ^ v6)) < 0) {
            // 0x100003cd0
            v11 = v10;
            v12 = v14;
            v21 = v23;
            v13 = v12;
            v20 = v19;
            v22 = v21;
            if ((int32_t)function_10000378c() != 0) {
                // 0x100003cec
                v17 = v12 + 1;
                v18 = v17 - v15;
                v13 = v17;
                v20 = v19;
                v22 = v21;
                if (v18 < 0 == ((v18 ^ v17) & (v17 ^ v15)) < 0) {
                    // 0x100003d14
                    function_100003690();
                    _printf("%s ", v11);
                    v13 = v17;
                    v20 = (int64_t)v11;
                    v22 = v19;
                }
            }
            // 0x100003d44
            v23 = v22;
            v14 = v13;
            v16 = v14 - v6;
            v10 = (char *)((int64_t)v11 + 1);
            v8 = v20;
            v9 = v23;
        }
    }
    // 0x100003d54
    _printf("\n\n");
    int32_t v24 = v2 + 1; // 0x100003d68
    int32_t v25 = v2 - 15; // 0x100003c4c
    while (v25 == 0 || v25 < 0 != (14 - v2 & v24) < 0) {
        int64_t v26 = v9;
        v2 = v24;
        _printf("Base %d: %dth to %dth esthetic numbers:\n", v8, v26, v3);
        v6 = 6 * v2;
        v7 = -v6;
        v9 = v26;
        if (v7 < 0 != (v6 & v7) < 0) {
            // 0x100003cd0
            v19 = v2;
            v15 = 4 * v2;
            v11 = (char *)1;
            v12 = 0;
            v21 = v26;
            v13 = v12;
            v20 = v19;
            v22 = v21;
            if ((int32_t)function_10000378c() != 0) {
                // 0x100003cec
                v17 = v12 + 1;
                v18 = v17 - v15;
                v13 = v17;
                v20 = v19;
                v22 = v21;
                if (v18 < 0 == ((v18 ^ v17) & (v17 ^ v15)) < 0) {
                    // 0x100003d14
                    function_100003690();
                    _printf("%s ", v11);
                    v13 = v17;
                    v20 = (int64_t)v11;
                    v22 = v19;
                }
            }
            // 0x100003d44
            v23 = v22;
            v14 = v13;
            v16 = v14 - v6;
            v10 = (char *)((int64_t)v11 + 1);
            v8 = v20;
            v9 = v23;
            while (v16 < 0 != ((v16 ^ v14) & (v14 ^ v6)) < 0) {
                // 0x100003cd0
                v11 = v10;
                v12 = v14;
                v21 = v23;
                v13 = v12;
                v20 = v19;
                v22 = v21;
                if ((int32_t)function_10000378c() != 0) {
                    // 0x100003cec
                    v17 = v12 + 1;
                    v18 = v17 - v15;
                    v13 = v17;
                    v20 = v19;
                    v22 = v21;
                    if (v18 < 0 == ((v18 ^ v17) & (v17 ^ v15)) < 0) {
                        // 0x100003d14
                        function_100003690();
                        _printf("%s ", v11);
                        v13 = v17;
                        v20 = (int64_t)v11;
                        v22 = v19;
                    }
                }
                // 0x100003d44
                v23 = v22;
                v14 = v13;
                v16 = v14 - v6;
                v10 = (char *)((int64_t)v11 + 1);
                v8 = v20;
                v9 = v23;
            }
        }
        // 0x100003d54
        _printf("\n\n");
        v24 = v2 + 1;
        v25 = v2 - 15;
    }
    char * v27 = _setlocale(4, NULL); // 0x100003d80
    _setlocale(4, (char *)0x100003f97);
    function_1000039d0();
    function_1000039d0();
    function_1000039d0();
    function_1000039d0();
    function_1000039d0();
    char * v28 = _setlocale(4, v27); // 0x100003eb0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ed4
        ___stack_chk_fail((int64_t)v28);
    }
    // 0x100003ed8
    return 0;
}

// Address range: 0x100003ee8 - 0x100003ef4
int64_t function_100003ee8(int64_t a1) {
    // 0x100003ee8
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * format, ...) {
    // 0x100003ef4
    return _printf(format);
}

// Address range: 0x100003f00 - 0x100003f0c
char * function_100003f00(int32_t category, char * locale) {
    // 0x100003f00
    return _setlocale(category, locale);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(char * s) {
    // 0x100003f0c
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>
#include <stdlib.h>

int main(int c, char **v)
{
	int i, j, m, n, *s;

	/* default size: 5 */
	if (c < 2 || ((m = atoi(v[1]))) <= 0) m = 5;

	/* alloc array*/
	s = malloc(sizeof(int) * m * m);

	for (i = n = 0; i < m * 2; i++)
		for (j = (i < m) ? 0 : i-m+1; j <= i && j < m; j++)
			s[(i&1)? j*(m-1)+i : (i-j)*m+j ] = n++;

	for (i = 0; i < m * m; putchar((++i % m) ? ' ':'\n'))
		printf("%3d", s[i]);

	/* free(s) */
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f74(char * nptr);
int64_t * function_100003f80(int32_t size);
int32_t function_100003f8c(char * format, ...);
int32_t function_100003f98(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d08 - 0x100003f74
int64_t entry_point(void) {
    // 0x100003d08
    int64_t v1; // 0x100003d08
    int32_t v2 = v1; // 0x100003d18
    int32_t v3; // 0x100003d08
    if (v2 < 2 == (1 - v2 & v2) < 0) {
        int32_t v4 = _atoi((char *)*(int64_t *)(v1 + 8)); // 0x100003d3c
        v3 = v4;
        if (v4 < 1) {
            // 0x100003d54
            v3 = 5;
            goto lab_0x100003d60;
        } else {
            goto lab_0x100003d60;
        }
    } else {
        // 0x100003d54
        v3 = 5;
        goto lab_0x100003d60;
    }
  lab_0x100003d60:;
    int32_t v5 = v3;
    int64_t * v6 = _malloc(4 * v5 * v5); // 0x100003d74
    int32_t v7 = 2 * v5; // 0x100003d90
    int32_t v8 = -v7; // 0x100003d90
    if (v8 < 0 != (v7 & v8) < 0) {
        int32_t v9 = 0;
        uint32_t v10 = 0;
        int32_t v11 = v10 - v5; // 0x100003da8
        int32_t v12 = v11 < 0 == ((v11 ^ v10) & (v10 ^ v5)) < 0 ? v11 + 1 : 0;
        int32_t v13 = v12 - v10; // 0x100003df0
        int32_t v14 = v9; // 0x100003e00
        int32_t v15; // 0x100003d08
        int32_t v16; // 0x100003d08
        int32_t v17; // 0x100003d08
        int32_t v18; // 0x100003e10
        int32_t v19; // 0x100003e34
        int32_t v20; // 0x100003eb4
        int32_t v21; // 0x100003df0
        if (v13 == 0 || v13 < 0 != ((v13 ^ v12) & (v12 ^ v10)) < 0) {
            // 0x100003e20
            v15 = v9;
            v17 = v12;
            v18 = v17 - v5;
            v14 = v15;
            while (v18 < 0 != ((v18 ^ v17) & (v17 ^ v5)) < 0) {
                if (v10 % 2 == 0) {
                    // 0x100003e78
                    v16 = (v10 - v17) * v5 + v17;
                } else {
                    // 0x100003e58
                    v16 = v17 * (v5 - 1) + v10;
                }
                // 0x100003e9c
                v19 = v15 + 1;
                *(int32_t *)((int64_t)(4 * v16) + (int64_t)v6) = v15;
                v20 = v17 + 1;
                v21 = v20 - v10;
                v14 = v19;
                if (v21 != 0 && v21 < 0 == ((v21 ^ v20) & (v20 ^ v10)) < 0) {
                    // break -> 0x100003ec4
                    break;
                }
                v15 = v19;
                v17 = v20;
                v18 = v17 - v5;
                v14 = v15;
            }
        }
        int32_t v22 = v10 + 1; // 0x100003ec8
        while (v22 - v7 < 0 != ((v22 - v7 ^ v22) & (v22 ^ v7)) < 0) {
            // 0x100003da0
            v9 = v14;
            v10 = v22;
            v11 = v10 - v5;
            v12 = v11 < 0 == ((v11 ^ v10) & (v10 ^ v5)) < 0 ? v11 + 1 : 0;
            v13 = v12 - v10;
            v14 = v9;
            if (v13 == 0 || v13 < 0 != ((v13 ^ v12) & (v12 ^ v10)) < 0) {
                // 0x100003e20
                v15 = v9;
                v17 = v12;
                v18 = v17 - v5;
                v14 = v15;
                while (v18 < 0 != ((v18 ^ v17) & (v17 ^ v5)) < 0) {
                    if (v10 % 2 == 0) {
                        // 0x100003e78
                        v16 = (v10 - v17) * v5 + v17;
                    } else {
                        // 0x100003e58
                        v16 = v17 * (v5 - 1) + v10;
                    }
                    // 0x100003e9c
                    v19 = v15 + 1;
                    *(int32_t *)((int64_t)(4 * v16) + (int64_t)v6) = v15;
                    v20 = v17 + 1;
                    v21 = v20 - v10;
                    v14 = v19;
                    if (v21 != 0 && v21 < 0 == ((v21 ^ v20) & (v20 ^ v10)) < 0) {
                        // break -> 0x100003ec4
                        break;
                    }
                    v15 = v19;
                    v17 = v20;
                    v18 = v17 - v5;
                    v14 = v15;
                }
            }
            // 0x100003ec4
            v22 = v10 + 1;
        }
    }
    int32_t v23 = v5 * v5; // 0x100003ee8
    int32_t v24 = -v23; // 0x100003eec
    if (v24 < 0 == (v23 & v24) < 0) {
        // 0x100003f64
        return 0;
    }
    _printf("%3d", v1);
    int32_t v25 = 1; // 0x100003f28
    _putchar(v25 % v5 == 0 ? 10 : 32);
    int32_t v26 = v25 - v23; // 0x100003eec
    int32_t v27 = v25; // 0x100003ef4
    while (v26 < 0 != ((v26 ^ v25) & (v25 ^ v23)) < 0) {
        // 0x100003efc
        _printf("%3d", v1);
        v25 = v27 + 1;
        _putchar(v25 % v5 == 0 ? 10 : 32);
        v26 = v25 - v23;
        v27 = v25;
    }
    // 0x100003f64
    return 0;
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * nptr) {
    // 0x100003f74
    return _atoi(nptr);
}

// Address range: 0x100003f80 - 0x100003f8c
int64_t * function_100003f80(int32_t size) {
    // 0x100003f80
    return _malloc(size);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(int32_t c) {
    // 0x100003f98
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#define _ISOC99_SOURCE

#include <math.h>
#include <stdio.h>

int main() {
  printf("%g\n", INFINITY);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f48 - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003f48
    int128_t v1; // 0x100003f48
    _printf("%g\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>

int valid(int n, int nuts)
{
	int k;
	for (k = n; k; k--, nuts -= 1 + nuts/n)
		if (nuts%n != 1) return 0;
	return nuts && !(nuts%n);
}

int main(void)
{
	int n, x;
	for (n = 2; n < 10; n++) {
		for (x = 0; !valid(n, x); x++);
		printf("%d: %d\n", n, x);
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003df4(void);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003df4 - 0x100003ed8
int64_t function_100003df4(void) {
    // 0x100003df4
    int64_t v1; // 0x100003df4
    int32_t v2 = v1; // 0x100003df8
    int32_t v3 = v1; // 0x100003dfc
    int32_t v4 = v2; // 0x100003e18
    int32_t v5 = v3; // 0x100003e18
    int64_t result; // 0x100003df4
    if (v2 == 0) {
      lab_0x100003e7c:
        // 0x100003e7c
        result = 0;
        if (v5 != 0) {
            // 0x100003e98
            result = v5 % v2 == 0;
        }
    } else {
        int32_t v6 = v3; // 0x100003e70
        result = 0;
        while (v6 % v2 == 1) {
            // 0x100003e50
            v4--;
            v6 += -1 - v6 / v2;
            v5 = v6;
            if (v4 == 0) {
                goto lab_0x100003e7c;
            }
            result = 0;
        }
    }
    // 0x100003ecc
    return result;
}

// Address range: 0x100003ed8 - 0x100003f8c
int64_t entry_point(void) {
    for (int32_t i = 2; i < 10; i++) {
        uint32_t v1 = 0;
        int32_t v2 = v1 + 1; // 0x100003f24
        while ((int32_t)function_100003df4() == 0) {
            // 0x100003f10
            v1 = v2;
            v2 = v1 + 1;
        }
        // 0x100003f40
        int64_t v3; // 0x100003ed8
        _printf("%d: %d\n", (int64_t)v1, v3);
    }
    // 0x100003f7c
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

/* should be 64-bit integers if going over 1 billion */
typedef unsigned long xint;
#define FMT "%lu"

xint total, prim, max_peri;

void new_tri(xint in[])
{
    int i;
    xint t[3], p;
    xint x = in[0], y = in[1], z = in[2];

recur:  p = x + y + z;
    if (p > max_peri) return;

    prim ++;
    total += max_peri / p;

    t[0] = x - 2 * y + 2 * z;
    t[1] = 2 * x - y + 2 * z;
    t[2] = t[1] - y + z;
    new_tri(t);

    t[0] += 4 * y;
    t[1] += 2 * y;
    t[2] += 4 * y;
    new_tri(t);

    z = t[2] - 4 * x;
    y = t[1] - 4 * x;
    x = t[0] - 2 * x;
    goto recur;
}

int main()
{
    xint seed[3] = {3, 4, 5};

    for (max_peri = 10; max_peri <= 100000000; max_peri *= 10) {
        total = prim = 0;
        new_tri(seed);

        printf( "Up to "FMT": "FMT" triples, "FMT" primitives.\n",
            max_peri, total, prim);
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c34(void);
int64_t function_100003f48(void);
int32_t function_100003f54(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x200000000; // 0x100008008
int64_t g3 = 0x50800000012; // 0x100008010

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c34 - 0x100003e24
int64_t function_100003c34(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c48
    int64_t v2; // 0x100003c34
    int64_t v3 = *(int64_t *)(v2 + 8); // 0x100003c64
    int64_t v4 = *(int64_t *)(v2 + 16); // 0x100003c70
    int64_t v5 = v3 + v2 + v4; // 0x100003c8c
    int64_t v6 = g1; // 0x100003ca0
    int64_t v7 = v4; // 0x100003cac
    int64_t result; // 0x100003c34
    if (v5 != v6 && v5 >= v6) {
        // 0x100003cd8
        return result;
    }
    g2++;
    g3 += v6 / v5;
    int64_t v8 = 2 * v3; // 0x100003d30
    int64_t v9 = 2 * v7; // 0x100003d3c
    int64_t v10; // 0x100003c34
    int64_t v11 = 2 * v10 - v3 + v9; // 0x100003d68
    function_100003c34();
    int64_t v12 = 4 * v3; // 0x100003da0
    int64_t v13 = function_100003c34(); // 0x100003dd8
    int64_t v14 = 4 * v10; // 0x100003dec
    v7 = v7 - v3 + v12 - v14 + v11;
    int64_t v15 = v11 + v8 - v14; // 0x100003e04
    int64_t v16 = v9 - v8 + v12 + -1 * v10; // 0x100003e18
    int64_t v17 = v15 + v16 + v7; // 0x100003c8c
    int64_t v18 = g1; // 0x100003ca0
    while (v17 == v18 || v17 < v18) {
        // 0x100003ce4
        g2++;
        g3 += v18 / v17;
        v8 = 2 * v15;
        v9 = 2 * v7;
        v11 = 2 * v16 - v15 + v9;
        function_100003c34();
        v12 = 4 * v15;
        v13 = function_100003c34();
        v14 = 4 * v16;
        v7 = v7 - v15 + v12 - v14 + v11;
        v15 = v11 + v8 - v14;
        v16 = v9 - v8 + v12 + -1 * v16;
        v17 = v15 + v16 + v7;
        v18 = g1;
    }
    // 0x100003cb4
    result = v13;
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003cd4
        result = ___stack_chk_fail();
    }
    // 0x100003cd8
    return result;
}

// Address range: 0x100003e24 - 0x100003f48
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e38
    g1 = 10;
    g2 = 0;
    g3 = 0;
    function_100003c34();
    int64_t v2; // 0x100003e24
    _printf("Up to %lu: %lu triples, %lu primitives.\n", (int32_t)v2, (int32_t)v2, (int32_t)v2);
    int64_t v3 = 10 * g1; // 0x100003f08
    g1 = v3;
    while (v3 >= 0x5f5e100 != v3 != 0x5f5e100) {
        // 0x100003e94
        g2 = 0;
        g3 = 0;
        function_100003c34();
        _printf("Up to %lu: %lu triples, %lu primitives.\n", (int32_t)v2, (int32_t)v2, (int32_t)v2);
        v3 = 10 * g1;
        g1 = v3;
    }
    // 0x100003f14
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f34
        ___stack_chk_fail();
    }
    // 0x100003f38
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int64_t function_100003f48(void) {
    // 0x100003f48
    return ___stack_chk_fail();
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include<unistd.h>
#include<stdio.h>
#include<time.h>

#define SHORTLAG 1000
#define LONGLAG  2000

int main(){
	int i,times,hour,min,sec,min1,min2;
	
	time_t t;
	struct tm* currentTime;
	
	while(1){
		time(&t);
		currentTime = localtime(&t);
		
		hour = currentTime->tm_hour;
		min = currentTime->tm_min;
		sec = currentTime->tm_sec;
		
		hour = 12;
		min = 0;
		sec = 0;
		
		if((min==0 || min==30) && sec==0)
			times = ((hour*60 + min)%240)%8;
		if(times==0){
			times = 8;
		}	

		if(min==0){
			min1 = 0;
			min2 = 0;
		}
		
		else{
			min1 = 3;
			min2 = 0;
		}
		
		if((min==0 || min==30) && sec==0){
			printf("\nIt is now %d:%d%d %s. Sounding the bell %d times.",hour,min1,min2,(hour>11)?"PM":"AM",times);
		
			for(i=1;i<=times;i++){
				printf("\a");
				
				(i%2==0)?sleep(LONGLAG):sleep(SHORTLAG);
			}
		}
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
struct tm * function_100003f3c(int32_t * timer);
int32_t function_100003f48(char * format, ...);
int32_t function_100003f54(int32_t seconds);
int32_t function_100003f60(int32_t * timer);

// ------- Dynamically Linked Functions Without Header --------

struct tm * _localtime(int32_t * a1);
int32_t _printf(char * a1, ...);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003cdc - 0x100003f3c
int64_t entry_point(void) {
    // 0x100003cdc
    while (true) {
      lab_0x100003cf0:;
        // 0x100003cf0
        int64_t v1; // bp-56, 0x100003cdc
        _time((int32_t *)&v1);
        _localtime((int32_t *)&v1);
        int64_t v2; // 0x100003cdc
        _printf("\nIt is now %d:%d%d %s. Sounding the bell %d times.", v2, v2, v2, (char *)v2, v2);
        int32_t v3 = 1; // 0x100003f28
        while (true) {
          lab_0x100003ed8:;
            int32_t v4 = v3;
            _printf((char *)0x100003fa5);
            if (v4 == 2 * v4 / 2) {
                // 0x100003f08
                _sleep(2000);
            } else {
                // 0x100003f14
                _sleep(1000);
            }
            // 0x100003f24
            v3 = v4 + 1;
            int32_t v5 = v4 - 7; // 0x100003ec8
            if (v5 == 0 || v5 < 0 != (v4 + 0x7ffffff9 & v3) < 0) {
                goto lab_0x100003ed8;
            } else {
                goto lab_0x100003cf0;
            }
        }
    }
}

// Address range: 0x100003f3c - 0x100003f48
struct tm * function_100003f3c(int32_t * timer) {
    // 0x100003f3c
    return _localtime(timer);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(int32_t seconds) {
    // 0x100003f54
    return _sleep(seconds);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int32_t * timer) {
    // 0x100003f60
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>

typedef const char * String;
typedef struct sTable {
    String * *rows;
    int      n_rows,n_cols;
} *Table;

typedef int (*CompareFctn)(String a, String b);

struct {
   CompareFctn  compare;
   int   column;
   int   reversed;
} sortSpec;

int CmprRows( const void *aa, const void *bb)
{
   String *rA = *(String *const *)aa;
   String *rB = *(String *const *)bb;
   int sortCol = sortSpec.column;

   String left = sortSpec.reversed ? rB[sortCol] : rA[sortCol];
   String right = sortSpec.reversed ? rA[sortCol] : rB[sortCol];
   return sortSpec.compare( left, right );
}

/** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * tbl parameter is a table of rows of strings
 * argSpec is a string containing zero or more of the letters o,c,r
 * if o is present - the corresponding optional argument is a function which
 *      determines the ordering of the strings.
 * if c is present - the corresponding optional argument is an integer that
 *      specifies the column to sort on.
 * if r is present - the corresponding optional argument is either
 *      true(nonzero) or false(zero) and if true, the sort will b in reverse order
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int sortTable(Table tbl, const char* argSpec,... )
{
   va_list vl;
   const char *p;
   int c;
   sortSpec.compare = &strcmp;
   sortSpec.column = 0;
   sortSpec.reversed = 0;

   va_start(vl, argSpec);
   if (argSpec)
      for (p=argSpec; *p; p++) {
         switch (*p) {
         case 'o':
            sortSpec.compare = va_arg(vl,CompareFctn);
            break;
         case 'c':
            c = va_arg(vl,int);
            if ( 0<=c && c<tbl->n_cols)
               sortSpec.column  = c;
            break;
         case 'r':
            sortSpec.reversed = (0!=va_arg(vl,int));
            break;
         }
      }
   va_end(vl);
   qsort( tbl->rows, tbl->n_rows, sizeof(String *), CmprRows);
   return 0;
}

void printTable( Table tbl, FILE *fout, const char *colFmts[])
{
   int row, col;

   for (row=0; row<tbl->n_rows; row++) {
      fprintf(fout, "   ");
      for(col=0; col<tbl->n_cols; col++) {
         fprintf(fout, colFmts[col], tbl->rows[row][col]);
      }
      fprintf(fout, "\n");
   }
   fprintf(fout, "\n");
}

int ord(char v)
{
    return v-'0';
}

/* an alternative comparison function */
int cmprStrgs(String s1, String s2)
{
    const char *p1 = s1;
    const char *p2 = s2;
    const char *mrk1, *mrk2;
    while ((tolower(*p1) == tolower(*p2)) && *p1) {
       p1++; p2++;
    }
    if (isdigit(*p1) && isdigit(*p2)) {
        long v1, v2;
        if ((*p1 == '0') ||(*p2 == '0')) {
            while (p1 > s1) {
                p1--; p2--;
                if (*p1 != '0') break;
            }
            if (!isdigit(*p1)) {
                p1++; p2++;
            }
        }
        mrk1 = p1; mrk2 = p2;
        v1 = 0;
        while(isdigit(*p1)) {
            v1 = 10*v1+ord(*p1);
            p1++;
        }
        v2 = 0;
        while(isdigit(*p2)) {
            v2 = 10*v2+ord(*p2);
            p2++;
        }
        if (v1 == v2)
           return(p2-mrk2)-(p1-mrk1);
        return v1 - v2;
    }
    if (tolower(*p1) != tolower(*p2))
       return (tolower(*p1) - tolower(*p2));
    for(p1=s1, p2=s2; (*p1 == *p2) && *p1; p1++, p2++);
    return (*p1 -*p2);
}

int main()
{
   const char *colFmts[] = {" %-5.5s"," %-5.5s"," %-9.9s"};
   String r1[] = { "a101", "red",  "Java" };
   String r2[] = { "ab40", "gren", "Smalltalk" };
   String r3[] = { "ab9",  "blue", "Fortran" };
   String r4[] = { "ab09", "ylow", "Python" };
   String r5[] = { "ab1a", "blak", "Factor" };
   String r6[] = { "ab1b", "brwn", "C Sharp" };
   String r7[] = { "Ab1b", "pink", "Ruby" };
   String r8[] = { "ab1",  "orng", "Scheme" };

   String *rows[] = { r1, r2, r3, r4, r5, r6, r7, r8 };
   struct sTable table;
   table.rows = rows;
   table.n_rows = 8;
   table.n_cols = 3;

   sortTable(&table, "");
   printf("sort on col 0, ascending\n");
   printTable(&table, stdout, colFmts);

   sortTable(&table, "ro", 1, &cmprStrgs);
   printf("sort on col 0, reverse.special\n");
   printTable(&table, stdout, colFmts);

   sortTable(&table, "c", 1);
   printf("sort on col 1, ascending\n");
   printTable(&table, stdout, colFmts);

   sortTable(&table, "cr", 2, 1);
   printf("sort on col 2, reverse\n");
   printTable(&table, stdout, colFmts);
   return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100000cfeedfacf(void);
int64_t function_100003410(void);
int64_t function_1000034f4(int64_t a1, int64_t a2);
int64_t function_100003500(void);
int64_t function_1000036c8(void);
int64_t function_1000037c0(void);
int64_t function_1000037d8(void);
int64_t function_100003e3c(int64_t a1);
int32_t function_100003e48(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003e54(int32_t c);
int32_t function_100003e60(char * format, ...);
void function_100003e6c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003e78(int32_t c);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int32_t g2 = 0; // 0x100008008
int32_t g3 = 2; // 0x10000800c

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _isdigit(int32_t a1);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));

// ------------------------ Functions -------------------------

// Address range: 0x100003410 - 0x1000034f4
int64_t function_100003410(void) {
    // 0x100003410
    return function_100000cfeedfacf();
}

// Address range: 0x1000034f4 - 0x100003500
int64_t function_1000034f4(int64_t a1, int64_t a2) {
    // 0x1000034f4
    int64_t result; // 0x1000034f4
    return result;
}

// Address range: 0x100003500 - 0x1000036c8
int64_t function_100003500(void) {
    // 0x100003500
    int64_t v1; // 0x100003500
    int64_t v2 = v1;
    *(int64_t *)&g1 = *(int64_t *)0x100004038;
    g2 = 0;
    g3 = 0;
    if (v1 == 0) {
        // 0x100003698
        _qsort((int64_t *)v2, *(int32_t *)(v2 + 8), 8, (int32_t (*)(int64_t *, int64_t *))0x100003410);
        return 0;
    }
    // 0x100003550
    int64_t v3; // 0x100003500
    int32_t * v4 = (int32_t *)&v3; // 0x100003558
    while (true) {
        int32_t * v5 = v4;
        v4 = v5;
        int64_t v6; // 0x100003500
        switch (*(char *)v6) {
            case 0: {
                // 0x100003698
                _qsort((int64_t *)v2, *(int32_t *)(v2 + 8), 8, (int32_t (*)(int64_t *, int64_t *))0x100003410);
                return 0;
            }
            case 99: {
                int32_t v7 = *v5; // 0x1000035e4
                int32_t * v8 = (int32_t *)((int64_t)v5 + 8); // 0x1000035ec
                int32_t v9 = -v7; // 0x100003604
                v4 = v8;
                if (v7 == 0 || v9 < 0 != (v7 & v9) < 0) {
                    int32_t v10 = *(int32_t *)(v2 + 12); // 0x10000361c
                    int32_t v11 = v7 - v10; // 0x100003620
                    v4 = v8;
                    if (v11 < 0 != ((v11 ^ v7) & (v10 ^ v7)) < 0) {
                        // 0x100003630
                        g2 = v7;
                        v4 = v8;
                    }
                }
                // break -> 0x100003684
                break;
            }
            case 111: {
                // 0x1000035b8
                *(int64_t *)&g1 = *(int64_t *)v5;
                v4 = (int32_t *)((int64_t)v5 + 8);
                // break -> 0x100003684
                break;
            }
            case 114: {
                // 0x100003648
                g3 = *v5 != 0;
                v4 = (int32_t *)((int64_t)v5 + 8);
                // break -> 0x100003684
                break;
            }
        }
        // 0x100003684
        int64_t v12; // 0x100003500
        v12++;
    }
    // 0x100003698
    _qsort((int64_t *)v2, *(int32_t *)(v2 + 8), 8, (int32_t (*)(int64_t *, int64_t *))0x100003410);
    return 0;
}

// Address range: 0x1000036c8 - 0x1000037c0
int64_t function_1000036c8(void) {
    // 0x1000036c8
    int64_t v1; // 0x1000036c8
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x1000036d8
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x1000036f0
    int32_t v4 = *v3; // 0x1000036f0
    int32_t v5 = -v4; // 0x1000036f4
    if (v5 < 0 == (v4 & v5) < 0) {
        // 0x1000037a4
        return _fprintf(v2, "\n");
    }
    int32_t * v6 = (int32_t *)(v1 + 12);
    int32_t v7 = 0; // 0x100003798
    _fprintf(v2, "   ");
    int32_t v8 = *v6; // 0x100003724
    int32_t v9 = -v8; // 0x100003728
    int32_t v10 = 0; // 0x100003730
    int32_t v11; // 0x100003774
    int32_t v12; // 0x100003724
    int32_t v13; // 0x100003728
    if (v9 < 0 != (v8 & v9) < 0) {
        _fprintf(v2, (char *)*(int64_t *)(8 * (int64_t)v10 + v1));
        v11 = v10 + 1;
        v12 = *v6;
        v13 = v11 - v12;
        v10 = v11;
        while (v13 < 0 != ((v13 ^ v11) & (v12 ^ v11)) < 0) {
            // 0x100003738
            _fprintf(v2, (char *)*(int64_t *)(8 * (int64_t)v10 + v1));
            v11 = v10 + 1;
            v12 = *v6;
            v13 = v11 - v12;
            v10 = v11;
        }
    }
    // 0x100003780
    _fprintf(v2, "\n");
    v7++;
    int32_t v14 = *v3; // 0x1000036f0
    while (v7 - v14 < 0 != ((v7 - v14 ^ v7) & (v14 ^ v7)) < 0) {
        // 0x100003704
        _fprintf(v2, "   ");
        v8 = *v6;
        v9 = -v8;
        v10 = 0;
        if (v9 < 0 != (v8 & v9) < 0) {
            _fprintf(v2, (char *)*(int64_t *)(8 * (int64_t)v10 + v1));
            v11 = v10 + 1;
            v12 = *v6;
            v13 = v11 - v12;
            v10 = v11;
            while (v13 < 0 != ((v13 ^ v11) & (v12 ^ v11)) < 0) {
                // 0x100003738
                _fprintf(v2, (char *)*(int64_t *)(8 * (int64_t)v10 + v1));
                v11 = v10 + 1;
                v12 = *v6;
                v13 = v11 - v12;
                v10 = v11;
            }
        }
        // 0x100003780
        _fprintf(v2, "\n");
        v7++;
        v14 = *v3;
    }
    // 0x1000037a4
    return _fprintf(v2, "\n");
}

// Address range: 0x1000037c0 - 0x1000037d8
int64_t function_1000037c0(void) {
    // 0x1000037c0
    int64_t v1; // 0x1000037c0
    return (0x1000000 * (int32_t)v1 >> 24) - 48;
}

// Address range: 0x1000037d8 - 0x100003b9c
int64_t function_1000037d8(void) {
    // 0x1000037d8
    int64_t v1; // 0x1000037d8
    uint64_t v2 = v1;
    char * c = (char *)v2;
    char * c2 = (char *)v1;
    int32_t v3 = _tolower((int32_t)*c); // 0x100003808
    char * c5 = c; // 0x100003834
    char * c6 = c2; // 0x100003834
    if (v3 == _tolower((int32_t)*c2)) {
        // 0x100003854
        c5 = c;
        c6 = c2;
        if (*c != 0) {
            int64_t v4; // 0x1000037d8
            int64_t v5 = v4 + 1; // 0x100003864
            int64_t v6; // 0x1000037d8
            int64_t v7 = v6 + 1; // 0x100003870
            char * c3 = (char *)v5;
            char * c4 = (char *)v7;
            int32_t v8 = _tolower((int32_t)*c3); // 0x100003808
            c5 = c3;
            c6 = c4;
            while (v8 == _tolower((int32_t)*c4)) {
                // 0x100003854
                c5 = c3;
                c6 = c4;
                if (*c3 == 0) {
                    // break -> 0x10000387c
                    break;
                }
                v5++;
                v7++;
                c3 = (char *)v5;
                c4 = (char *)v7;
                v8 = _tolower((int32_t)*c3);
                c5 = c3;
                c6 = c4;
            }
        }
    }
    // 0x10000387c
    char * v9; // 0x1000037d8
    char * v10; // 0x1000037d8
    char v11; // 0x1000038b8
    if (_isdigit((int32_t)*c5) == 0) {
        goto lab_0x100003a8c;
    } else {
        // 0x100003898
        if (_isdigit((int32_t)*c6) == 0) {
            goto lab_0x100003a8c;
        } else {
            // 0x1000038b4
            v11 = *c5;
            if (v11 == 48) {
                goto lab_0x1000038e4;
            } else {
                // 0x1000038cc
                v9 = c5;
                v10 = c6;
                if (*c6 == 48) {
                    goto lab_0x1000038e4;
                } else {
                    goto lab_0x100003974;
                }
            }
        }
    }
  lab_0x100003a8c:;
    int32_t v12 = _tolower((int32_t)*c5); // 0x100003a94
    if (v12 != _tolower((int32_t)*c6)) {
        int32_t v13 = _tolower((int32_t)*c5); // 0x100003ac8
        // 0x100003b8c
        return v13 - _tolower((int32_t)*c6);
    }
    char v14 = *c; // 0x100003b08
    char v15 = *c2; // 0x100003b10
    char v16 = v14; // 0x100003b24
    char v17 = v15; // 0x100003b24
    char v18 = v14; // 0x100003b24
    if (v14 == v15) {
        v17 = 0;
        v18 = 0;
        while (v16 != 0) {
            // 0x100003b54
            int64_t v19; // 0x1000037d8
            int64_t v20 = v19 + 1; // 0x100003b58
            int64_t v21; // 0x1000037d8
            int64_t v22 = v21 + 1; // 0x100003b64
            char v23 = *(char *)v20; // 0x100003b08
            char v24 = *(char *)v22; // 0x100003b10
            v16 = v23;
            v21 = v22;
            v19 = v20;
            v17 = v24;
            v18 = v23;
            if (v23 != v24) {
                // break -> 0x100003b70
                break;
            }
            v17 = 0;
            v18 = 0;
        }
    }
    // 0x100003b8c
    return (int32_t)v18 - (int32_t)v17;
  lab_0x1000038e4:;
    int64_t v25 = (int64_t)c5; // 0x1000038e8
    char v26 = v11; // 0x1000038f8
    char * v27 = c5; // 0x1000038f8
    char * v28 = c6; // 0x1000038f8
    if (v2 != v25 && v2 <= v25) {
        int64_t v29 = v25 - 1; // 0x100003904
        char * v30 = (char *)v29;
        char * v31 = (char *)((int64_t)c6 - 1);
        char v32 = *v30; // 0x10000391c
        v26 = v32;
        v27 = v30;
        v28 = v31;
        while (v32 == 48) {
            // 0x1000038e8
            v26 = 48;
            v27 = v30;
            v28 = v31;
            if (v2 == v29 || v2 > v29) {
                // break -> 0x100003938
                break;
            }
            v29--;
            v30 = (char *)v29;
            v31 = (char *)((int64_t)v31 - 1);
            v32 = *v30;
            v26 = v32;
            v27 = v30;
            v28 = v31;
        }
    }
    // 0x100003938
    v9 = v27;
    v10 = v28;
    if (_isdigit((int32_t)v26) == 0) {
        // 0x100003954
        v9 = (char *)((int64_t)v27 + 1);
        v10 = (char *)((int64_t)v28 + 1);
    }
    goto lab_0x100003974;
  lab_0x100003974:;
    char * v33 = v9; // 0x1000039a0
    int64_t v34 = 0; // 0x1000039a0
    if (_isdigit((int32_t)*v9) != 0) {
        int64_t v35 = 0x100000000 * function_1000037c0() >> 32; // 0x1000039c8
        char * v36 = (char *)((int64_t)v9 + 1);
        v33 = v36;
        v34 = v35;
        int64_t v37 = v35; // 0x1000039a0
        char * v38 = v36; // 0x1000039a0
        while (_isdigit((int32_t)*v36) != 0) {
            // 0x1000039a8
            v35 = (0x100000000 * function_1000037c0() >> 32) + 10 * v37;
            v36 = (char *)((int64_t)v38 + 1);
            v33 = v36;
            v34 = v35;
            v37 = v35;
            v38 = v36;
        }
    }
    char * v39 = v10; // 0x1000039fc
    int64_t v40 = 0; // 0x1000039fc
    if (_isdigit((int32_t)*v10) != 0) {
        int64_t v41 = 0x100000000 * function_1000037c0() >> 32; // 0x100003a24
        char * v42 = (char *)((int64_t)v10 + 1);
        int64_t v43 = v41; // 0x1000039fc
        char * v44 = v42; // 0x1000039fc
        v39 = v42;
        v40 = v41;
        while (_isdigit((int32_t)*v42) != 0) {
            // 0x100003a04
            v41 = (0x100000000 * function_1000037c0() >> 32) + 10 * v43;
            v42 = (char *)((int64_t)v44 + 1);
            v43 = v41;
            v44 = v42;
            v39 = v42;
            v40 = v41;
        }
    }
    // 0x100003a3c
    int32_t result; // 0x1000037d8
    if (v34 == v40) {
        // 0x100003a54
        result = (int64_t)v9 - (int64_t)v10 - (int64_t)v33 + (int64_t)v39;
    } else {
        // 0x100003a78
        result = v34 - v40;
    }
    // 0x100003b8c
    return result;
}

// Address range: 0x100003b9c - 0x100003e3c
int64_t entry_point(void) {
    // 0x100003b9c
    function_100003500();
    _printf("sort on col 0, ascending\n");
    function_1000036c8();
    function_100003500();
    _printf("sort on col 0, reverse.special\n");
    function_1000036c8();
    function_100003500();
    _printf("sort on col 1, ascending\n");
    function_1000036c8();
    function_100003500();
    _printf("sort on col 2, reverse\n");
    int64_t v1 = function_1000036c8(); // 0x100003e00
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e10
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e24
        ___stack_chk_fail(v1);
    }
    // 0x100003e28
    return 0;
}

// Address range: 0x100003e3c - 0x100003e48
int64_t function_100003e3c(int64_t a1) {
    // 0x100003e3c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e48 - 0x100003e54
int32_t function_100003e48(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e48
    return _fprintf(stream, format);
}

// Address range: 0x100003e54 - 0x100003e60
int32_t function_100003e54(int32_t c) {
    // 0x100003e54
    return _isdigit(c);
}

// Address range: 0x100003e60 - 0x100003e6c
int32_t function_100003e60(char * format, ...) {
    // 0x100003e60
    return _printf(format);
}

// Address range: 0x100003e6c - 0x100003e78
void function_100003e6c(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003e6c
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003e78 - 0x100003e84
int32_t function_100003e78(int32_t c) {
    // 0x100003e78
    return _tolower(c);
}

// Address range: 0x100000cfeedfacf - 0x100000cfeedfad0
int64_t function_100000cfeedfacf(void) {
    // 0x100000cfeedfacf
    int64_t result; // 0x100000cfeedfacf
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`#include <stdio.h>

const char *donuts[] = {"iced", "jam", "plain",
                        "something completely different"};
int pos[] = {0, 0, 0, 0};

void printDonuts(int k) {
  for (size_t i = 1; i < k + 1; i += 1) // offset: i:1..N, N=k+1
    printf("%s\t", donuts[pos[i]]);     // str:0..N-1
  printf("\n");
}

// idea: custom number system with 2s complement like 0b10...0==MIN stop case
void combination_with_repetiton(int n, int k) {
  while (1) {
    for (int i = k; i > 0; i -= 1) {
      if (pos[i] > n - 1) // if number spilled over: xx0(n-1)xx
      {
        pos[i - 1] += 1; // set xx1(n-1)xx
        for (int j = i; j <= k; j += 1)
          pos[j] = pos[j - 1]; // set xx11..1
      }
    }
    if (pos[0] > 0) // stop condition: 1xxxx
      break;
    printDonuts(k);
    pos[k] += 1; // xxxxN -> xxxxN+1
  }
}

int main() {
  combination_with_repetiton(3, 2);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d64(void);
int64_t function_100003df8(void);
int32_t function_100003f68(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008020

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d64 - 0x100003df8
int64_t function_100003d64(void) {
    // 0x100003d64
    int64_t v1; // 0x100003d64
    uint64_t v2 = 0x100000000 * v1 + 0x100000000 >> 32; // 0x100003d8c
    if (v2 <= 1) {
        // 0x100003de0
        return _printf((char *)0x100003fa6);
    }
    int64_t v3 = 1; // 0x100003dd4
    _printf("%s\t", (char *)v1);
    while (v3 + 1 != v2) {
        // 0x100003d9c
        v3++;
        _printf("%s\t", (char *)v1);
    }
    // 0x100003de0
    return _printf((char *)0x100003fa6);
}

// Address range: 0x100003df8 - 0x100003f34
int64_t function_100003df8(void) {
    // 0x100003df8
    int64_t v1; // 0x100003df8
    int32_t v2 = v1; // 0x100003e08
    int32_t v3 = (int32_t)v1 - 1;
    int64_t v4 = 0x100000000 * v1;
    int32_t * v5 = (int32_t *)((v4 >> 30) + (int64_t)&g1);
    int64_t v6 = v4 >> 32;
    int64_t v7; // 0x100003df8
    int64_t result = v7;
    int64_t v8; // 0x100003df8
    int64_t v9; // 0x100003df8
    int32_t v10; // 0x100003df8
    int32_t v11; // 0x100003df8
    int32_t v12; // 0x100003df8
    int32_t v13; // 0x100003e48
    int32_t * v14; // 0x100003e6c
    int64_t v15; // 0x100003df8
    int32_t v16; // 0x100003df8
    int32_t v17; // 0x100003eac
    int32_t v18; // 0x100003ec0
    int32_t v19; // 0x100003e8c
    int32_t v20; // 0x100003e3c
    if (v2 >= 1) {
        v9 = v6;
        v20 = *(int32_t *)(4 * v9 + (int64_t)&g1);
        v13 = v20 - v3;
        v8 = v9 - 1;
        if (v13 != 0 && v13 < 0 == ((v13 ^ v20) & (v20 ^ v3)) < 0) {
            // 0x100003e58
            v14 = (int32_t *)(4 * v8 + (int64_t)&g1);
            *v14 = *v14 + 1;
            v15 = v9 - v6;
            v16 = v9;
            v12 = v16;
            if (v15 == 0 || v15 < 0 != (v16 & (int32_t)(v9 ^ v1)) < 0) {
                v17 = *(int32_t *)((int64_t)(4 * v12 - 4) + (int64_t)&g1);
                *(int32_t *)(4 * (int64_t)v12 + (int64_t)&g1) = v17;
                v18 = v12 + 1;
                v19 = v18 - v2;
                v12 = v18;
                while (v19 == 0 || v19 < 0 != ((v19 ^ v18) & (v18 ^ v2)) < 0) {
                    // 0x100003e9c
                    v17 = *(int32_t *)((int64_t)(4 * v12 - 4) + (int64_t)&g1);
                    *(int32_t *)(4 * (int64_t)v12 + (int64_t)&g1) = v17;
                    v18 = v12 + 1;
                    v19 = v18 - v2;
                    v12 = v18;
                }
            }
        }
        // 0x100003ed4
        v10 = v2 - 1;
        while (v9 >= 2) {
            // 0x100003e30
            v11 = v10;
            v9 = v8;
            v20 = *(int32_t *)(4 * v9 + (int64_t)&g1);
            v13 = v20 - v3;
            v8 = v9 - 1;
            if (v13 != 0 && v13 < 0 == ((v13 ^ v20) & (v20 ^ v3)) < 0) {
                // 0x100003e58
                v14 = (int32_t *)(4 * v8 + (int64_t)&g1);
                *v14 = *v14 + 1;
                v15 = v9 - v6;
                v16 = v9;
                v12 = v16;
                if (v15 == 0 || v15 < 0 != ((v11 - v2 ^ v16) & (int32_t)(v9 ^ v1)) < 0) {
                    v17 = *(int32_t *)((int64_t)(4 * v12 - 4) + (int64_t)&g1);
                    *(int32_t *)(4 * (int64_t)v12 + (int64_t)&g1) = v17;
                    v18 = v12 + 1;
                    v19 = v18 - v2;
                    v12 = v18;
                    while (v19 == 0 || v19 < 0 != ((v19 ^ v18) & (v18 ^ v2)) < 0) {
                        // 0x100003e9c
                        v17 = *(int32_t *)((int64_t)(4 * v12 - 4) + (int64_t)&g1);
                        *(int32_t *)(4 * (int64_t)v12 + (int64_t)&g1) = v17;
                        v18 = v12 + 1;
                        v19 = v18 - v2;
                        v12 = v18;
                    }
                }
            }
            // 0x100003ed4
            v10 = v11 - 1;
        }
    }
    while (*(int32_t *)&g1 < 1) {
        int64_t v21 = function_100003d64(); // 0x100003f04
        *v5 = *v5 + 1;
        result = v21;
        if (v2 >= 1) {
            v9 = v6;
            v20 = *(int32_t *)(4 * v9 + (int64_t)&g1);
            v13 = v20 - v3;
            v8 = v9 - 1;
            if (v13 != 0 && v13 < 0 == ((v13 ^ v20) & (v20 ^ v3)) < 0) {
                // 0x100003e58
                v14 = (int32_t *)(4 * v8 + (int64_t)&g1);
                *v14 = *v14 + 1;
                v15 = v9 - v6;
                v16 = v9;
                v12 = v16;
                if (v15 == 0 || v15 < 0 != (v16 & (int32_t)(v9 ^ v1)) < 0) {
                    v17 = *(int32_t *)((int64_t)(4 * v12 - 4) + (int64_t)&g1);
                    *(int32_t *)(4 * (int64_t)v12 + (int64_t)&g1) = v17;
                    v18 = v12 + 1;
                    v19 = v18 - v2;
                    v12 = v18;
                    while (v19 == 0 || v19 < 0 != ((v19 ^ v18) & (v18 ^ v2)) < 0) {
                        // 0x100003e9c
                        v17 = *(int32_t *)((int64_t)(4 * v12 - 4) + (int64_t)&g1);
                        *(int32_t *)(4 * (int64_t)v12 + (int64_t)&g1) = v17;
                        v18 = v12 + 1;
                        v19 = v18 - v2;
                        v12 = v18;
                    }
                }
            }
            // 0x100003ed4
            v10 = v2 - 1;
            while (v9 >= 2) {
                // 0x100003e30
                v11 = v10;
                v9 = v8;
                v20 = *(int32_t *)(4 * v9 + (int64_t)&g1);
                v13 = v20 - v3;
                v8 = v9 - 1;
                if (v13 != 0 && v13 < 0 == ((v13 ^ v20) & (v20 ^ v3)) < 0) {
                    // 0x100003e58
                    v14 = (int32_t *)(4 * v8 + (int64_t)&g1);
                    *v14 = *v14 + 1;
                    v15 = v9 - v6;
                    v16 = v9;
                    v12 = v16;
                    if (v15 == 0 || v15 < 0 != ((v11 - v2 ^ v16) & (int32_t)(v9 ^ v1)) < 0) {
                        v17 = *(int32_t *)((int64_t)(4 * v12 - 4) + (int64_t)&g1);
                        *(int32_t *)(4 * (int64_t)v12 + (int64_t)&g1) = v17;
                        v18 = v12 + 1;
                        v19 = v18 - v2;
                        v12 = v18;
                        while (v19 == 0 || v19 < 0 != ((v19 ^ v18) & (v18 ^ v2)) < 0) {
                            // 0x100003e9c
                            v17 = *(int32_t *)((int64_t)(4 * v12 - 4) + (int64_t)&g1);
                            *(int32_t *)(4 * (int64_t)v12 + (int64_t)&g1) = v17;
                            v18 = v12 + 1;
                            v19 = v18 - v2;
                            v12 = v18;
                        }
                    }
                }
                // 0x100003ed4
                v10 = v11 - 1;
            }
        }
    }
    // 0x100003f28
    return result;
}

// Address range: 0x100003f34 - 0x100003f68
int64_t entry_point(void) {
    // 0x100003f34
    function_100003df8();
    return 0;
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

struct RealSet {
    bool(*contains)(struct RealSet*, struct RealSet*, double);
    struct RealSet *left;
    struct RealSet *right;
    double low, high;
};

typedef enum {
    CLOSED,
    LEFT_OPEN,
    RIGHT_OPEN,
    BOTH_OPEN,
} RangeType;

double length(struct RealSet *self) {
    const double interval = 0.00001;
    double p = self->low;
    int count = 0;

    if (isinf(self->low) || isinf(self->high)) return -1.0;
    if (self->high <= self->low) return 0.0;

    do {
        if (self->contains(self, NULL, p)) count++;
        p += interval;
    } while (p < self->high);
    return count * interval;
}

bool empty(struct RealSet *self) {
    if (self->low == self->high) {
        return !self->contains(self, NULL, self->low);
    }
    return length(self) == 0.0;
}

static bool contains_closed(struct RealSet *self, struct RealSet *_, double d) {
    return self->low <= d && d <= self->high;
}

static bool contains_left_open(struct RealSet *self, struct RealSet *_, double d) {
    return self->low < d && d <= self->high;
}

static bool contains_right_open(struct RealSet *self, struct RealSet *_, double d) {
    return self->low <= d && d < self->high;
}

static bool contains_both_open(struct RealSet *self, struct RealSet *_, double d) {
    return self->low < d && d < self->high;
}

static bool contains_intersect(struct RealSet *self, struct RealSet *_, double d) {
    return self->left->contains(self->left, NULL, d) && self->right->contains(self->right, NULL, d);
}

static bool contains_union(struct RealSet *self, struct RealSet *_, double d) {
    return self->left->contains(self->left, NULL, d) || self->right->contains(self->right, NULL, d);
}

static bool contains_subtract(struct RealSet *self, struct RealSet *_, double d) {
    return self->left->contains(self->left, NULL, d) && !self->right->contains(self->right, NULL, d);
}

struct RealSet* makeSet(double low, double high, RangeType type) {
    bool(*contains)(struct RealSet*, struct RealSet*, double);
    struct RealSet *rs;

    switch (type) {
    case CLOSED:
        contains = contains_closed;
        break;
    case LEFT_OPEN:
        contains = contains_left_open;
        break;
    case RIGHT_OPEN:
        contains = contains_right_open;
        break;
    case BOTH_OPEN:
        contains = contains_both_open;
        break;
    default:
        return NULL;
    }

    rs = malloc(sizeof(struct RealSet));
    rs->contains = contains;
    rs->left = NULL;
    rs->right = NULL;
    rs->low = low;
    rs->high = high;
    return rs;
}

struct RealSet* makeIntersect(struct RealSet *left, struct RealSet *right) {
    struct RealSet *rs = malloc(sizeof(struct RealSet));
    rs->contains = contains_intersect;
    rs->left = left;
    rs->right = right;
    rs->low = fmin(left->low, right->low);
    rs->high = fmin(left->high, right->high);
    return rs;
}

struct RealSet* makeUnion(struct RealSet *left, struct RealSet *right) {
    struct RealSet *rs = malloc(sizeof(struct RealSet));
    rs->contains = contains_union;
    rs->left = left;
    rs->right = right;
    rs->low = fmin(left->low, right->low);
    rs->high = fmin(left->high, right->high);
    return rs;
}

struct RealSet* makeSubtract(struct RealSet *left, struct RealSet *right) {
    struct RealSet *rs = malloc(sizeof(struct RealSet));
    rs->contains = contains_subtract;
    rs->left = left;
    rs->right = right;
    rs->low = left->low;
    rs->high = left->high;
    return rs;
}

int main() {
    struct RealSet *a = makeSet(0.0, 1.0, LEFT_OPEN);
    struct RealSet *b = makeSet(0.0, 2.0, RIGHT_OPEN);
    struct RealSet *c = makeSet(1.0, 2.0, LEFT_OPEN);
    struct RealSet *d = makeSet(0.0, 3.0, RIGHT_OPEN);
    struct RealSet *e = makeSet(0.0, 1.0, BOTH_OPEN);
    struct RealSet *f = makeSet(0.0, 1.0, CLOSED);
    struct RealSet *g = makeSet(0.0, 0.0, CLOSED);
    int i;

    for (i = 0; i < 3; ++i) {
        struct RealSet *t;

        t = makeUnion(a, b);
        printf("(0, 1]   union   [0, 2) contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        t = makeIntersect(b, c);
        printf("[0, 2) intersect (1, 2] contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        t = makeSubtract(d, e);
        printf("[0, 3)     -     (0, 1) contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        t = makeSubtract(d, f);
        printf("[0, 3)     -     [0, 1] contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        printf("\n");
    }

    printf("[0, 0] is empty %d\n", empty(g));

    free(a);
    free(b);
    free(c);
    free(d);
    free(e);
    free(f);
    free(g);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_1000032c4(void);
int64_t function_1000034b4(int32_t a1, float64_t a2);
int64_t function_100003524(int32_t a1);
int64_t function_100003534(void);
int64_t function_1000035cc(int64_t a1);
int64_t function_1000036d0(void);
int64_t function_100003730(void);
int64_t function_100003790(void);
int64_t function_1000037f0(void);
int64_t function_100003850(int64_t a1, int64_t a2);
int64_t function_1000038e0(void);
int64_t function_100003918(float64_t a1);
int64_t function_100003964(int64_t a1, int64_t a2);
int64_t function_1000039f4(void);
int64_t function_100003a2c(float64_t a1);
int64_t function_100003a78(int64_t a1, int64_t a2);
int64_t function_100003af0(void);
int64_t function_100003b28(float64_t a1);
void function_100003e9c(int64_t * ptr);
int64_t * function_100003ea8(int32_t size);
int32_t function_100003eb4(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t g1 = 1.0e-5; // 0x100003ec0
float64_t g2 = INFINITY; // 0x100003ec8

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000032c4 - 0x1000034b4
int64_t function_1000032c4(void) {
    // 0x1000032c4
    int64_t result; // 0x1000032c4
    float64_t v1 = *(float64_t *)(result + 24); // 0x100003344
    if (fabs(v1) == g2) {
        // 0x100003460
        return function_100003524(0);
    }
    float64_t v2 = *(float64_t *)(result + 32); // 0x1000033fc
    if (fabs(v2) == g2) {
        // 0x100003460
        return function_100003524(0);
    }
    if (v2 <= v1 == (v2 != v1)) {
        // 0x10000349c
        return result;
    }
    // 0x10000348c
    return function_100003524(0);
}

// Address range: 0x1000034b4 - 0x100003524
int64_t function_1000034b4(int32_t a1, float64_t a2) {
    // 0x1000034b4
    __asm_sshll(0.0f, 0);
    return function_100003524((int32_t)(float32_t)((g1 + a2) * g1));
}

// Address range: 0x100003524 - 0x100003534
int64_t function_100003524(int32_t a1) {
    // 0x100003524
    int64_t result; // 0x100003524
    return result;
}

// Address range: 0x100003534 - 0x1000035cc
int64_t function_100003534(void) {
    // 0x100003534
    int64_t v1; // 0x100003534
    float64_t v2 = *(float64_t *)(v1 + 24); // 0x100003548
    int64_t result; // 0x100003534
    if (v2 != *(float64_t *)(v1 + 32)) {
        // 0x100003598
        function_1000032c4();
        result = v2 == 0.0;
    }
    // 0x100003564
    return result;
}

// Address range: 0x1000035cc - 0x1000036c0
int64_t function_1000035cc(int64_t a1) {
    // 0x1000035cc
    int64_t v1; // 0x1000035cc
    uint64_t v2 = v1 & 0xffffffff; // 0x1000035ec
    return v2 >= 3 == (v2 != 3) ? 0 : v1;
}

// Address range: 0x1000036d0 - 0x100003730
int64_t function_1000036d0(void) {
    // 0x1000036d0
    float64_t v1; // 0x1000036d0
    float64_t v2 = v1;
    int64_t v3; // 0x1000036d0
    float64_t v4 = *(float64_t *)(v3 + 24); // 0x1000036e4
    int64_t result = 0; // 0x1000036fc
    if (v4 <= v2 != v4 != v2) {
        float64_t v5 = *(float64_t *)(v3 + 32); // 0x10000370c
        result = v2 == v5 | v2 > v5;
    }
    // 0x100003720
    return result;
}

// Address range: 0x100003730 - 0x100003790
int64_t function_100003730(void) {
    // 0x100003730
    float64_t v1; // 0x100003730
    float64_t v2 = v1;
    int64_t result = 0; // 0x10000374c
    int64_t v3; // 0x100003730
    if (*(float64_t *)(v3 + 24) > v2) {
        float64_t v4 = *(float64_t *)(v3 + 32); // 0x10000376c
        result = v2 == v4 | v2 > v4;
    }
    // 0x100003780
    return result;
}

// Address range: 0x100003790 - 0x1000037f0
int64_t function_100003790(void) {
    // 0x100003790
    float64_t v1; // 0x100003790
    float64_t v2 = v1;
    int64_t v3; // 0x100003790
    float64_t v4 = *(float64_t *)(v3 + 24); // 0x1000037a4
    int64_t result = 0; // 0x1000037bc
    if (v4 <= v2 != v4 != v2) {
        // 0x1000037c4
        result = v2 > *(float64_t *)(v3 + 32);
    }
    // 0x1000037e0
    return result;
}

// Address range: 0x1000037f0 - 0x100003850
int64_t function_1000037f0(void) {
    int64_t result = 0; // 0x10000380c
    int64_t v1; // 0x1000037f0
    float64_t v2; // 0x1000037f0
    if (*(float64_t *)(v1 + 24) > v2) {
        // 0x100003824
        result = v2 > *(float64_t *)(v1 + 32);
    }
    // 0x100003840
    return result;
}

// Address range: 0x100003850 - 0x1000038e0
int64_t function_100003850(int64_t a1, int64_t a2) {
    int64_t * v1 = _malloc(40); // 0x100003868
    int64_t result = (int64_t)v1; // 0x100003868
    *v1 = 0x1000038e0;
    *(int64_t *)(result + 8) = a1;
    *(int64_t *)(result + 16) = a2;
    float64_t v2 = llvm_minnum_f64(*(float64_t *)(a1 + 24), *(float64_t *)(a2 + 24)); // 0x1000038a8
    *(float64_t *)(result + 24) = v2;
    float64_t v3 = llvm_minnum_f64(*(float64_t *)(a1 + 32), *(float64_t *)(a2 + 32)); // 0x1000038c4
    *(float64_t *)(result + 32) = v3;
    return result;
}

// Address range: 0x1000038e0 - 0x100003918
int64_t function_1000038e0(void) {
    // 0x1000038e0
    int64_t v1; // 0x1000038e0
    return *(int64_t *)(v1 + 8);
}

// Address range: 0x100003918 - 0x100003964
int64_t function_100003918(float64_t a1) {
    // 0x100003918
    int64_t v1; // 0x100003918
    if (v1 % 2 == 0) {
        // 0x100003950
        return 0;
    }
    // 0x100003928
    return *(int64_t *)(*(int64_t *)(v1 - 8) + 16);
}

// Address range: 0x100003964 - 0x1000039f4
int64_t function_100003964(int64_t a1, int64_t a2) {
    int64_t * v1 = _malloc(40); // 0x10000397c
    int64_t result = (int64_t)v1; // 0x10000397c
    *v1 = 0x1000039f4;
    *(int64_t *)(result + 8) = a1;
    *(int64_t *)(result + 16) = a2;
    float64_t v2 = llvm_minnum_f64(*(float64_t *)(a1 + 24), *(float64_t *)(a2 + 24)); // 0x1000039bc
    *(float64_t *)(result + 24) = v2;
    float64_t v3 = llvm_minnum_f64(*(float64_t *)(a1 + 32), *(float64_t *)(a2 + 32)); // 0x1000039d8
    *(float64_t *)(result + 32) = v3;
    return result;
}

// Address range: 0x1000039f4 - 0x100003a2c
int64_t function_1000039f4(void) {
    // 0x1000039f4
    int64_t v1; // 0x1000039f4
    return *(int64_t *)(v1 + 8);
}

// Address range: 0x100003a2c - 0x100003a78
int64_t function_100003a2c(float64_t a1) {
    // 0x100003a2c
    int64_t v1; // 0x100003a2c
    if (v1 % 2 == 0) {
        // 0x100003a3c
        return *(int64_t *)(*(int64_t *)(v1 - 8) + 16);
    }
    // 0x100003a64
    return 1;
}

// Address range: 0x100003a78 - 0x100003af0
int64_t function_100003a78(int64_t a1, int64_t a2) {
    int64_t * v1 = _malloc(40); // 0x100003a90
    int64_t result = (int64_t)v1; // 0x100003a90
    *v1 = 0x100003af0;
    *(int64_t *)(result + 8) = a1;
    *(int64_t *)(result + 16) = a2;
    *(int64_t *)(result + 24) = *(int64_t *)(a1 + 24);
    *(int64_t *)(result + 32) = *(int64_t *)(a1 + 32);
    return result;
}

// Address range: 0x100003af0 - 0x100003b28
int64_t function_100003af0(void) {
    // 0x100003af0
    int64_t v1; // 0x100003af0
    return *(int64_t *)(v1 + 8);
}

// Address range: 0x100003b28 - 0x100003b78
int64_t function_100003b28(float64_t a1) {
    // 0x100003b28
    int64_t v1; // 0x100003b28
    if (v1 % 2 == 0) {
        // 0x100003b64
        return 0;
    }
    // 0x100003b38
    return *(int64_t *)(*(int64_t *)(v1 - 8) + 16);
}

// Address range: 0x100003b78 - 0x100003e9c
int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = function_1000035cc(1); // 0x100003ba8
    int64_t v2 = function_1000035cc(0x4000000000000000); // 0x100003bc4
    int64_t v3 = function_1000035cc(v2); // 0x100003bdc
    int64_t v4 = function_1000035cc(function_1000035cc(v3)); // 0x100003c08
    function_1000035cc(function_1000035cc(v4));
    int64_t result = function_100003964(v1, v2); // 0x100003c64
    __asm_sshll(0.0f, 0);
    return result;
}

// Address range: 0x100003e9c - 0x100003ea8
void function_100003e9c(int64_t * ptr) {
    // 0x100003e9c
    _free(ptr);
}

// Address range: 0x100003ea8 - 0x100003eb4
int64_t * function_100003ea8(int32_t size) {
    // 0x100003ea8
    return _malloc(size);
}

// Address range: 0x100003eb4 - 0x100003ec0
int32_t function_100003eb4(char * format, ...) {
    // 0x100003eb4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 22

`
`#include <stdio.h>
#include <stdlib.h>

void clear() {
	for(int n = 0;n < 10; n++) {
		printf("\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\r\n\r\n\r\n");
	}
}

#define UP    "00^00\r\n00|00\r\n00000\r\n"
#define DOWN  "00000\r\n00|00\r\n00v00\r\n"
#define LEFT  "00000\r\n<--00\r\n00000\r\n"
#define RIGHT "00000\r\n00-->\r\n00000\r\n"
#define HOME  "00000\r\n00+00\r\n00000\r\n"

int main() {
	clear();
	system("stty raw");

	printf(HOME);
	printf("space to exit; wasd to move\r\n");
	char c = 1;

	while(c) {
		c = getc(stdin);
		clear();

		switch (c)
		{
			case 'a':
				printf(LEFT);
				break;
			case 'd':
				printf(RIGHT);
				break;
			case 'w':
				printf(UP);
				break;
			case 's':
				printf(DOWN);
				break;
			case ' ':
				c = 0;
				break;
			default:
				printf(HOME);
		};

		printf("space to exit; wasd key to move\r\n");
	}

	system("stty cooked");
	system("clear");
	return 1;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ce8(void);
int32_t function_100003ea4(struct _IO_FILE * stream);
int32_t function_100003eb0(char * format, ...);
int32_t function_100003ebc(char * command);

// ------- Dynamically Linked Functions Without Header --------

int32_t _getc(struct _IO_FILE * a1);
int32_t _printf(char * a1, ...);
int32_t _system(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ce8 - 0x100003d3c
int64_t function_100003ce8(void) {
    int32_t result; // 0x100003d18
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003d10
        result = _printf("\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\r\n\r\n\r\n");
    }
    // 0x100003d30
    return result;
}

// Address range: 0x100003d3c - 0x100003ea4
int64_t entry_point(void) {
    // 0x100003d3c
    function_100003ce8();
    _system("stty raw");
    _printf("00000\r\n00+00\r\n00000\r\n");
    _printf("space to exit; wasd to move\r\n");
    while (true) {
        int32_t v1 = 0x1000000 * _getc((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
        function_100003ce8();
        int32_t v2; // 0x100003d3c
        switch (v1) {
            case 0x20000000: {
                // 0x100003e6c
                _printf("space to exit; wasd key to move\r\n");
                // 0x100003e7c
                _system("stty cooked");
                _system("clear");
                return 1;
            }
            case 0x61000000: {
                // 0x100003e14
                _printf("00000\r\n<--00\r\n00000\r\n");
                v2 = 97;
                // break -> 0x100003e6c
                break;
            }
            case 0x64000000: {
                // 0x100003e24
                _printf("00000\r\n00-->\r\n00000\r\n");
                v2 = 100;
                // break -> 0x100003e6c
                break;
            }
            case 0x73000000: {
                // 0x100003e44
                _printf("00000\r\n00|00\r\n00v00\r\n");
                v2 = 115;
                // break -> 0x100003e6c
                break;
            }
            case 0x77000000: {
                // 0x100003e34
                _printf("00^00\r\n00|00\r\n00000\r\n");
                v2 = 119;
                // break -> 0x100003e6c
                break;
            }
            default: {
                // 0x100003e5c
                _printf("00000\r\n00+00\r\n00000\r\n");
                v2 = v1 >> 24;
                // break -> 0x100003e6c
                break;
            }
        }
        // 0x100003e6c
        _printf("space to exit; wasd key to move\r\n");
        if (v2 % 256 == 0) {
            // 0x100003e7c
            _system("stty cooked");
            _system("clear");
            return 1;
        }
    }
    // 0x100003e6c
    _printf("space to exit; wasd key to move\r\n");
    // 0x100003e7c
    _system("stty cooked");
    _system("clear");
    return 1;
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(struct _IO_FILE * stream) {
    // 0x100003ea4
    return _getc(stream);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(char * format, ...) {
    // 0x100003eb0
    return _printf(format);
}

// Address range: 0x100003ebc - 0x100003ec8
int32_t function_100003ebc(char * command) {
    // 0x100003ebc
    return _system(command);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

void swap(char* str, int i, int j) {
    char c = str[i];
    str[i] = str[j];
    str[j] = c;
}

void reverse(char* str, int i, int j) {
    for (; i < j; ++i, --j)
        swap(str, i, j);
}

bool next_permutation(char* str) {
    int len = strlen(str);
    if (len < 2)
        return false;
    for (int i = len - 1; i > 0; ) {
        int j = i, k;
        if (str[--i] < str[j]) {
            k = len;
            while (str[i] >= str[--k]) {}
            swap(str, i, k);
            reverse(str, j, len - 1);
            return true;
        }
    }
    return false;
}

uint32_t next_highest_int(uint32_t n) {
    char str[16];
    snprintf(str, sizeof(str), "%u", n);
    if (!next_permutation(str))
        return 0;
    return strtoul(str, 0, 10);
}

int main() {
    uint32_t numbers[] = {0, 9, 12, 21, 12453, 738440, 45072010, 95322020};
    const int count = sizeof(numbers)/sizeof(int);
    for (int i = 0; i < count; ++i)
        printf("%d -> %d\n", numbers[i], next_highest_int(numbers[i]));
    // Last one is too large to convert to an integer
    const char big[] = "9589776899767587796600";
    char next[sizeof(big)];
    memcpy(next, big, sizeof(big));
    next_permutation(next);
    printf("%s -> %s\n", big, next);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003af4(void);
int64_t function_100003b54(void);
int64_t function_100003bc4(void);
int64_t function_100003d14(void);
int64_t function_100003f14(int64_t * a1, int64_t a2, int64_t a3);
int64_t function_100003f20(int64_t a1);
int32_t function_100003f2c(char * format, ...);
int32_t function_100003f38(char * s);
int32_t function_100003f44(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___snprintf_chk(int64_t * a1, int64_t a2, int64_t a3);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);
int32_t _strtoul(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003af4 - 0x100003b54
int64_t function_100003af4(void) {
    // 0x100003af4
    int64_t result; // 0x100003af4
    char * v1 = (char *)((0x100000000 * result >> 32) + result); // 0x100003b10
    char * v2 = (char *)(result + (0x100000000 * result >> 32)); // 0x100003b24
    *v1 = *v2;
    *v2 = *v1;
    return result;
}

// Address range: 0x100003b54 - 0x100003bc4
int64_t function_100003b54(void) {
    // 0x100003b54
    int64_t v1; // 0x100003b54
    int32_t v2 = v1; // 0x100003b64
    int32_t v3 = v1; // 0x100003b68
    int32_t v4 = v2 - v3; // 0x100003b78
    int32_t v5 = v3; // 0x100003b80
    int64_t result; // 0x100003b54
    if (v4 < 0 == ((v4 ^ v2) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x100003bb8
        return result;
    }
    int32_t v6 = v2; // 0x100003b80
    v6++;
    v5--;
    int32_t v7 = v6 - v5; // 0x100003b78
    result = function_100003af4();
    while (v7 < 0 != ((v7 ^ v6) & (v6 ^ v5)) < 0) {
        // 0x100003b88
        v6++;
        v5--;
        v7 = v6 - v5;
        result = function_100003af4();
    }
    // 0x100003bb8
    return result;
}

// Address range: 0x100003bc4 - 0x100003d14
int64_t function_100003bc4(void) {
    // 0x100003bc4
    int64_t v1; // 0x100003bc4
    int32_t v2 = _strlen((char *)v1); // 0x100003bd8
    if (v2 < 2 != (1 - v2 & v2) < 0) {
        // 0x100003d00
        return 0;
    }
    int32_t v3 = v2 - 1;
    int64_t result = 0; // 0x100003c28
    int32_t v4; // 0x100003bc4
    int32_t v5; // 0x100003c7c
    char v6; // 0x100003c7c
    while (v3 >= 1) {
        int32_t v7 = v3 - 1; // 0x100003c40
        char v8 = *(char *)(v1 + (int64_t)v7); // 0x100003c48
        int32_t v9 = v8; // 0x100003c48
        char v10 = *(char *)(v1 + (int64_t)v3); // 0x100003c54
        int32_t v11 = v9 - (int32_t)v10; // 0x100003c58
        if (v11 < 0 != ((v11 ^ v9) & (int32_t)(v10 ^ v8)) < 0) {
            // 0x100003c74
            v6 = *(char *)(v1 + (int64_t)v7);
            v5 = v6;
            v4 = v2;
            goto lab_0x100003c74_2;
        }
        v3 = v7;
        result = 0;
    }
    // 0x100003d00
    return result;
  lab_0x100003c74_2:;
    int32_t v12 = v4 - 1; // 0x100003c88
    char v13 = *(char *)(v1 + (int64_t)v12); // 0x100003c90
    int32_t v14 = v5 - (int32_t)v13; // 0x100003c94
    v4 = v12;
    if (v14 < 0 == ((v14 ^ v5) & (int32_t)(v13 ^ v6)) < 0) {
        goto lab_0x100003c74_2;
    } else {
        // 0x100003ca8
        function_100003af4();
        function_100003b54();
        result = 1;
        return result;
    }
}

// Address range: 0x100003d14 - 0x100003dd4
int64_t function_100003d14(void) {
    // 0x100003d14
    int64_t v1; // bp-40, 0x100003d14
    ___snprintf_chk(&v1, 16, 0);
    int64_t v2 = function_100003bc4(); // 0x100003d68
    int64_t v3 = v2; // 0x100003d6c
    int64_t result = 0; // 0x100003d6c
    if (v2 % 2 != 0) {
        int32_t v4 = _strtoul((char *)&v1, NULL, 10); // 0x100003d88
        v3 = v4;
        result = v4;
    }
    int64_t v5 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003dac
    if (v5 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003dc0
        ___stack_chk_fail(v3);
    }
    // 0x100003dc4
    return result;
}

// Address range: 0x100003dd4 - 0x100003f14
int64_t entry_point(void) {
    int64_t v1; // 0x100003dd4
    for (int32_t i = 0; i < 8; i++) {
        // 0x100003e30
        function_100003d14();
        _printf("%d -> %d\n", v1, v1);
    }
    // 0x100003e84
    function_100003bc4();
    int32_t v2 = _printf("%s -> %s\n", (char *)v1, (char *)v1); // 0x100003edc
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003eec
    if (v3 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003f00
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f04
    return 0;
}

// Address range: 0x100003f14 - 0x100003f20
int64_t function_100003f14(int64_t * a1, int64_t a2, int64_t a3) {
    // 0x100003f14
    return ___snprintf_chk(a1, a2, a3);
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t function_100003f20(int64_t a1) {
    // 0x100003f20
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * format, ...) {
    // 0x100003f2c
    return _printf(format);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * s) {
    // 0x100003f38
    return _strlen(s);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * nptr, char ** endptr, int32_t base) {
    // 0x100003f44
    return _strtoul(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>

void transpose(void *dest, void *src, int src_h, int src_w)
{
	int i, j;
	double (*d)[src_h] = dest, (*s)[src_w] = src;
	for (i = 0; i < src_h; i++)
		for (j = 0; j < src_w; j++)
			d[j][i] = s[i][j];
}

int main()
{
	int i, j;
	double a[3][5] = {{ 0, 1, 2, 3, 4 },
			  { 5, 6, 7, 8, 9 },
			  { 1, 0, 0, 0, 42}};
	double b[5][3];
	transpose(b, a, 3, 5);

	for (i = 0; i < 5; i++)
		for (j = 0; j < 3; j++)
			printf("%g%c", b[i][j], j == 2 ? '\n' : ' ');
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ce0(void);
int64_t function_100003efc(void);
int64_t * function_100003f08(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f14(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100003f20

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ce0 - 0x100003dbc
int64_t function_100003ce0(void) {
    // 0x100003ce0
    int64_t result; // 0x100003ce0
    int32_t v1 = result; // 0x100003cec
    int32_t v2 = -v1; // 0x100003d24
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x100003db4
        return result;
    }
    int32_t v3 = result; // 0x100003cf0
    int32_t v4 = -v3; // 0x100003d44
    int32_t v5 = 0;
    int64_t v6; // 0x100003d60
    int64_t v7; // 0x100003d6c
    int64_t v8; // 0x100003ce0
    int32_t v9; // 0x100003d94
    if (v4 < 0 != (v4 & v3) < 0) {
        // 0x100003d54
        v6 = v5;
        v9 = 0;
        v7 = v9;
        v8 = *(int64_t *)(8 * ((result & 0xffffffff) * v6 + v7) + result);
        *(int64_t *)(8 * ((result & 0xffffffff) * v7 + v6) + result) = v8;
        v9++;
        while (v9 - v3 < 0 != ((v9 - v3 ^ v9) & (v9 ^ v3)) < 0) {
            // 0x100003d54
            v7 = v9;
            v8 = *(int64_t *)(8 * ((result & 0xffffffff) * v6 + v7) + result);
            *(int64_t *)(8 * ((result & 0xffffffff) * v7 + v6) + result) = v8;
            v9++;
        }
    }
    int32_t v10 = v5 + 1; // 0x100003da8
    while (v10 - v1 < 0 != ((v10 - v1 ^ v10) & (v10 ^ v1)) < 0) {
        // 0x100003d3c
        v5 = v10;
        if (v4 < 0 != (v4 & v3) < 0) {
            // 0x100003d54
            v6 = v5;
            v9 = 0;
            v7 = v9;
            v8 = *(int64_t *)(8 * ((result & 0xffffffff) * v6 + v7) + result);
            *(int64_t *)(8 * ((result & 0xffffffff) * v7 + v6) + result) = v8;
            v9++;
            while (v9 - v3 < 0 != ((v9 - v3 ^ v9) & (v9 ^ v3)) < 0) {
                // 0x100003d54
                v7 = v9;
                v8 = *(int64_t *)(8 * ((result & 0xffffffff) * v6 + v7) + result);
                *(int64_t *)(8 * ((result & 0xffffffff) * v7 + v6) + result) = v8;
                v9++;
            }
        }
        // 0x100003da4
        v10 = v5 + 1;
    }
    // 0x100003db4
    return result;
}

// Address range: 0x100003dbc - 0x100003efc
int64_t entry_point(void) {
    // 0x100003dbc
    int64_t v1; // bp-160, 0x100003dbc
    _memcpy(&v1, &g1, 120);
    function_100003ce0();
    char v2 = &v1; // 0x100003e98
    for (int32_t i = 0; i < 5; i++) {
        for (int32_t j = 0; j < 3; j++) {
            // 0x100003e44
            int128_t v3; // 0x100003dbc
            _printf("%g%c", (float64_t)(int64_t)v3, v2);
        }
    }
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ed0
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003ee4
        ___stack_chk_fail();
    }
    // 0x100003ee8
    return 0;
}

// Address range: 0x100003efc - 0x100003f08
int64_t function_100003efc(void) {
    // 0x100003efc
    return ___stack_chk_fail();
}

// Address range: 0x100003f08 - 0x100003f14
int64_t * function_100003f08(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f08
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * format, ...) {
    // 0x100003f14
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>

void selection_sort (int *a, int n) {
    int i, j, m, t;
    for (i = 0; i < n; i++) {
        for (j = i, m = i; j < n; j++) {
            if (a[j] < a[m]) {
                m = j;
            }
        }
        t = a[i];
        a[i] = a[m];
        a[m] = t;
    }
}

int main () {
    int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};
    int n = sizeof a / sizeof a[0];
    int i;
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    selection_sort(a, n);
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cc0(void);
int64_t function_100003f48(int64_t a1);
int64_t * function_100003f54(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f60(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4100000004; // 0x100003f6c

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cc0 - 0x100003db4
int64_t function_100003cc0(void) {
    // 0x100003cc0
    int64_t result; // 0x100003cc0
    int32_t v1 = result; // 0x100003cc8
    int32_t v2 = -v1; // 0x100003cdc
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x100003dac
        return result;
    }
    int32_t v3 = 0;
    int32_t v4 = v3 - v1; // 0x100003d08
    int32_t v5 = v3; // 0x100003d10
    int32_t v6 = v3; // 0x100003d10
    int32_t v7 = v3; // 0x100003d10
    int32_t v8; // 0x100003cc0
    int32_t v9; // 0x100003d20
    int32_t v10; // 0x100003d2c
    int32_t v11; // 0x100003d30
    int32_t v12; // 0x100003d54
    int32_t v13; // 0x100003d08
    if (v4 < 0 != ((v4 ^ v3) & (v3 ^ v1)) < 0) {
        v9 = *(int32_t *)(4 * (int64_t)v6 + result);
        v10 = *(int32_t *)(4 * (int64_t)v5 + result);
        v11 = v9 - v10;
        v8 = v11 < 0 == ((v11 ^ v9) & (v10 ^ v9)) < 0 ? v5 : v6;
        v12 = v6 + 1;
        v13 = v12 - v1;
        v5 = v8;
        v6 = v12;
        v7 = v8;
        while (v13 < 0 != ((v13 ^ v12) & (v12 ^ v1)) < 0) {
            // 0x100003d18
            v9 = *(int32_t *)(4 * (int64_t)v6 + result);
            v10 = *(int32_t *)(4 * (int64_t)v5 + result);
            v11 = v9 - v10;
            v8 = v11 < 0 == ((v11 ^ v9) & (v10 ^ v9)) < 0 ? v5 : v6;
            v12 = v6 + 1;
            v13 = v12 - v1;
            v5 = v8;
            v6 = v12;
            v7 = v8;
        }
    }
    int32_t * v14 = (int32_t *)(4 * (int64_t)v3 + result); // 0x100003d68
    int32_t * v15 = (int32_t *)(4 * (int64_t)v7 + result); // 0x100003d78
    *v14 = *v15;
    *v15 = *v14;
    int32_t v16 = v3 + 1; // 0x100003da0
    while (v16 - v1 < 0 != ((v16 - v1 ^ v16) & (v16 ^ v1)) < 0) {
        // 0x100003d00
        v3 = v16;
        v4 = v3 - v1;
        v5 = v3;
        v6 = v3;
        v7 = v3;
        if (v4 < 0 != ((v4 ^ v3) & (v3 ^ v1)) < 0) {
            v9 = *(int32_t *)(4 * (int64_t)v6 + result);
            v10 = *(int32_t *)(4 * (int64_t)v5 + result);
            v11 = v9 - v10;
            v8 = v11 < 0 == ((v11 ^ v9) & (v10 ^ v9)) < 0 ? v5 : v6;
            v12 = v6 + 1;
            v13 = v12 - v1;
            v5 = v8;
            v6 = v12;
            v7 = v8;
            while (v13 < 0 != ((v13 ^ v12) & (v12 ^ v1)) < 0) {
                // 0x100003d18
                v9 = *(int32_t *)(4 * (int64_t)v6 + result);
                v10 = *(int32_t *)(4 * (int64_t)v5 + result);
                v11 = v9 - v10;
                v8 = v11 < 0 == ((v11 ^ v9) & (v10 ^ v9)) < 0 ? v5 : v6;
                v12 = v6 + 1;
                v13 = v12 - v1;
                v5 = v8;
                v6 = v12;
                v7 = v8;
            }
        }
        // 0x100003d60
        v14 = (int32_t *)(4 * (int64_t)v3 + result);
        v15 = (int32_t *)(4 * (int64_t)v7 + result);
        *v14 = *v15;
        *v15 = *v14;
        v16 = v3 + 1;
    }
    // 0x100003dac
    return result;
}

// Address range: 0x100003db4 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003db4
    int64_t v1; // bp-64, 0x100003db4
    _memcpy(&v1, &g1, 40);
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003e10
        _printf("%d%s", (int64_t)&g1, (char *)40);
    }
    // 0x100003e7c
    function_100003cc0();
    int32_t v2; // 0x100003efc
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003ea8
        v2 = _printf("%d%s", 10, (char *)40);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f20
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f34
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f38
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int64_t function_100003f48(int64_t a1) {
    // 0x100003f48
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f54 - 0x100003f60
int64_t * function_100003f54(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f54
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>

int pangram(const char *s)
{
	int c, mask = (1 << 26) - 1;
	while ((c = (*s++)) != '\0') /* 0x20 converts lowercase to upper */
		if ((c &= ~0x20) <= 'Z' && c >= 'A')
			mask &= ~(1 << (c - 'A'));

	return !mask;
}

int main()
{
	int i;
	const char *s[] = {	"The quick brown fox jumps over lazy dogs.",
				"The five boxing wizards dump quickly.",  };

	for (i = 0; i < 2; i++)
		printf("%s: %s\n", pangram(s[i]) ? "yes" : "no ", s[i]);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d94(void);
int64_t function_100003f28(void);
int32_t function_100003f34(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d94 - 0x100003e38
int64_t function_100003d94(void) {
    // 0x100003d94
    int64_t v1; // 0x100003d94
    char v2 = *(char *)v1; // 0x100003db4
    if (v2 == 0) {
        // 0x100003e20
        return false;
    }
    int32_t v3 = 0x3ffffff;
    int32_t v4 = v2;
    int32_t v5 = v4 & -33; // 0x100003dd0
    int32_t v6 = v5 - 90; // 0x100003dd8
    int32_t v7 = v3; // 0x100003de0
    int32_t v8; // 0x100003dec
    if (v6 == 0 || v6 < 0 != (89 - v5 & v4) < 0) {
        // 0x100003de8
        v8 = v5 - 65;
        v7 = v3;
        if (v8 < 0 == (64 - v5 & v4) < 0) {
            // 0x100003dfc
            v7 = v3 & (-1 << v8) - 1;
        }
    }
    // 0x100003e1c
    int64_t v9; // 0x100003d94
    int64_t v10 = v9 + 1;
    int32_t v11 = v7;
    char v12 = *(char *)v10; // 0x100003db4
    while (v12 != 0) {
        // 0x100003dcc
        v3 = v11;
        v4 = v12;
        v5 = v4 & -33;
        v6 = v5 - 90;
        v7 = v3;
        if (v6 == 0 || v6 < 0 != (89 - v5 & v4) < 0) {
            // 0x100003de8
            v8 = v5 - 65;
            v7 = v3;
            if (v8 < 0 == (64 - v5 & v4) < 0) {
                // 0x100003dfc
                v7 = v3 & (-1 << v8) - 1;
            }
        }
        // 0x100003e1c
        v10++;
        v11 = v7;
        v12 = *(char *)v10;
    }
    // 0x100003e20
    return v11 == 0;
}

// Address range: 0x100003e38 - 0x100003f28
int64_t entry_point(void) {
    for (int32_t i = 0; i < 2; i++) {
        // 0x100003e84
        function_100003d94();
        int64_t v1; // 0x100003e38
        _printf("%s: %s\n", (char *)v1, (char *)v1);
    }
    int64_t v2 = *(int64_t *)0x100004008; // 0x100003efc
    if (*(int64_t *)v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f14
        ___stack_chk_fail();
    }
    // 0x100003f18
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(void) {
    // 0x100003f28
    return ___stack_chk_fail();
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <string.h>

void parse_sep(const char *str, const char *const *pat, int len)
{
	int i, slen;
	while (*str != '\0') {
		for (i = 0; i < len || !putchar(*(str++)); i++) {
			slen = strlen(pat[i]);
			if (strncmp(str, pat[i], slen)) continue;
			printf("{%.*s}", slen, str);
			str += slen;
			break;
		}
	}
}

int main()
{
	const char *seps[] = { "==", "!=", "=" };
	parse_sep("a!===b=!=c", seps, 3);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003da8(void);
int64_t function_100003f50(int64_t a1);
int32_t function_100003f5c(char * format, ...);
int32_t function_100003f68(int32_t c);
int32_t function_100003f74(char * s);
int32_t function_100003f80(char * s1, char * s2, int32_t n);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _strlen(char * a1);
int32_t _strncmp(char * a1, char * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003da8 - 0x100003ed0
int64_t function_100003da8(void) {
    // 0x100003da8
    int64_t v1; // 0x100003da8
    char * v2 = (char *)v1; // 0x100003db4
    int32_t v3 = v1; // 0x100003dbc
    if (*v2 == 0) {
        // 0x100003ec4
        int64_t result; // 0x100003da8
        return result;
    }
    char * v4 = v2; // 0x100003dd4
    char * v5; // 0x100003da8
    int32_t result2; // 0x100003da8
    while (true) {
      lab_0x100003de4:;
        char * v6 = v4; // 0x100003da8
        int32_t v7 = 0; // 0x100003da8
        while (true) {
            int32_t v8 = v7;
            char * v9 = v6;
            int32_t v10 = v8 - v3; // 0x100003dec
            char * v11 = v9; // 0x100003dfc
            if (v10 < 0 == ((v10 ^ v8) & (v8 ^ v3)) < 0) {
                char * v12 = (char *)((int64_t)v9 + 1);
                int32_t v13 = _putchar((int32_t)*v9); // 0x100003e14
                v11 = v12;
                v5 = v12;
                result2 = v13;
                if (v13 != 0) {
                    // break -> 0x100003ec0
                    break;
                }
            }
            char * v14 = v11;
            int64_t * v15 = (int64_t *)(8 * (int64_t)v8 + v1); // 0x100003e3c
            int32_t v16 = _strlen((char *)*v15); // 0x100003e40
            int64_t v17 = *v15; // 0x100003e58
            int32_t v18 = _strncmp(v14, (char *)v17, v16); // 0x100003e60
            v6 = v14;
            v7 = v8 + 1;
            if (v18 == 0) {
                int64_t v19 = v16; // 0x100003e5c
                int32_t v20 = _printf("{%.*s}", v17, (char *)v19); // 0x100003e98
                v5 = (char *)(v19 + (int64_t)v14);
                result2 = v20;
                goto lab_0x100003ec0;
            }
        }
        goto lab_0x100003ec0;
    }
    // 0x100003ec4
    return result2;
  lab_0x100003ec0:
    // 0x100003ec0
    v4 = v5;
    if (*v4 == 0) {
        return result2;
    }
    goto lab_0x100003de4;
}

// Address range: 0x100003ed0 - 0x100003f50
int64_t entry_point(void) {
    int64_t v1 = function_100003da8(); // 0x100003f18
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f28
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f3c
        ___stack_chk_fail(v1);
    }
    // 0x100003f40
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t function_100003f50(int64_t a1) {
    // 0x100003f50
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(int32_t c) {
    // 0x100003f68
    return _putchar(c);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * s) {
    // 0x100003f74
    return _strlen(s);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * s1, char * s2, int32_t n) {
    // 0x100003f80
    return _strncmp(s1, s2, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct stirling_cache_tag {
    int max;
    int* values;
} stirling_cache;

int stirling_number2(stirling_cache* sc, int n, int k) {
    if (k == n)
        return 1;
    if (k == 0 || k > n || n > sc->max)
        return 0;
    return sc->values[n*(n-1)/2 + k - 1];
}

bool stirling_cache_create(stirling_cache* sc, int max) {
    int* values = calloc(max * (max + 1)/2, sizeof(int));
    if (values == NULL)
        return false;
    sc->max = max;
    sc->values = values;
    for (int n = 1; n <= max; ++n) {
        for (int k = 1; k < n; ++k) {
            int s1 = stirling_number2(sc, n - 1, k - 1);
            int s2 = stirling_number2(sc, n - 1, k);
            values[n*(n-1)/2 + k - 1] = s1 + s2 * k;
        }
    }
    return true;
}

void stirling_cache_destroy(stirling_cache* sc) {
    free(sc->values);
    sc->values = NULL;
}

void print_stirling_numbers(stirling_cache* sc, int max) {
    printf("Stirling numbers of the second kind:\nn/k");
    for (int k = 0; k <= max; ++k)
        printf(k == 0 ? "%2d" : "%8d", k);
    printf("\n");
    for (int n = 0; n <= max; ++n) {
        printf("%2d ", n);
        for (int k = 0; k <= n; ++k)
            printf(k == 0 ? "%2d" : "%8d", stirling_number2(sc, n, k));
        printf("\n");
    }
}

int main() {
    stirling_cache sc = { 0 };
    const int max = 12;
    if (!stirling_cache_create(&sc, max)) {
        fprintf(stderr, "Out of memory\n");
        return 1;
    }
    print_stirling_numbers(&sc, max);
    stirling_cache_destroy(&sc);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a94(void);
int64_t function_100003b5c(void);
int64_t function_100003ce8(int64_t a1);
int64_t function_100003d18(void);
int64_t * function_100003f28(int32_t nmemb, int32_t size);
int32_t function_100003f34(struct _IO_FILE * stream, char * format, ...);
void function_100003f40(int64_t * ptr);
int32_t function_100003f4c(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003a94 - 0x100003b5c
int64_t function_100003a94(void) {
    // 0x100003a94
    int64_t v1; // 0x100003a94
    int32_t v2 = v1; // 0x100003a9c
    int32_t v3 = v1; // 0x100003aa0
    if (v3 == v2) {
        // 0x100003b50
        return 1;
    }
    // 0x100003ac8
    if (v3 == 0) {
        // 0x100003b50
        return 0;
    }
    int32_t v4 = v3 - v2; // 0x100003ae4
    if (v4 != 0 && v4 < 0 == ((v4 ^ v3) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x100003b50
        return 0;
    }
    int32_t v5 = v2 - (int32_t)v1; // 0x100003b00
    int64_t result = 0; // 0x100003b08
    if (v5 == 0 || v5 < 0 != ((v5 ^ v2) & (int32_t)(v1 ^ v1)) < 0) {
        int64_t v6 = *(int64_t *)(v1 + 8); // 0x100003b1c
        uint32_t v7 = *(int32_t *)(v6 + (int64_t)(4 * ((v2 - 1) * v2 / 2 + v3) - 4)); // 0x100003b44
        result = v7;
    }
    // 0x100003b50
    return result;
}

// Address range: 0x100003b5c - 0x100003ce8
int64_t function_100003b5c(void) {
    // 0x100003b5c
    int64_t v1; // 0x100003b5c
    int32_t v2 = v1; // 0x100003b6c
    int64_t * v3 = _calloc((v2 + 1) * v2 / 2, 4); // 0x100003b94
    if (v3 == NULL) {
        // 0x100003cd4
        return 0;
    }
    int64_t v4 = (int64_t)v3; // 0x100003b94
    *(int32_t *)v1 = v2;
    *(int64_t *)(v1 + 8) = v4;
    int32_t v5 = 1 - v2; // 0x100003bf0
    if (v5 != 0 && v5 < 0 == (v5 & v2) < 0) {
        // 0x100003cd4
        return 1;
    }
    int32_t v6 = 1;
    int32_t v7 = 1 - v6; // 0x100003c14
    int32_t v8; // 0x100003b5c
    int32_t v9; // 0x100003b5c
    int64_t v10; // 0x100003c38
    int64_t v11; // 0x100003c50
    int32_t v12; // 0x100003ca0
    if (v7 < 0 != (v7 & v6) < 0) {
        // 0x100003c24
        v9 = (v6 - 1) * v6 / 2;
        v8 = 1;
        v10 = function_100003a94();
        v11 = function_100003a94();
        *(int32_t *)((int64_t)(4 * (v8 + v9) - 4) + v4) = v8 * (int32_t)v11 + (int32_t)v10;
        v12 = v8 + 1;
        while (v12 - v6 < 0 != ((v12 - v6 ^ v12) & (v12 ^ v6)) < 0) {
            // 0x100003c24
            v8 = v12;
            v10 = function_100003a94();
            v11 = function_100003a94();
            *(int32_t *)((int64_t)(4 * (v8 + v9) - 4) + v4) = v8 * (int32_t)v11 + (int32_t)v10;
            v12 = v8 + 1;
        }
    }
    int32_t v13 = v6 + 1; // 0x100003cb4
    while (v13 - v2 == 0 || v13 - v2 < 0 != ((v13 - v2 ^ v13) & (v13 ^ v2)) < 0) {
        // 0x100003c0c
        v6 = v13;
        v7 = 1 - v6;
        if (v7 < 0 != (v7 & v6) < 0) {
            // 0x100003c24
            v9 = (v6 - 1) * v6 / 2;
            v8 = 1;
            v10 = function_100003a94();
            v11 = function_100003a94();
            *(int32_t *)((int64_t)(4 * (v8 + v9) - 4) + v4) = v8 * (int32_t)v11 + (int32_t)v10;
            v12 = v8 + 1;
            while (v12 - v6 < 0 != ((v12 - v6 ^ v12) & (v12 ^ v6)) < 0) {
                // 0x100003c24
                v8 = v12;
                v10 = function_100003a94();
                v11 = function_100003a94();
                *(int32_t *)((int64_t)(4 * (v8 + v9) - 4) + v4) = v8 * (int32_t)v11 + (int32_t)v10;
                v12 = v8 + 1;
            }
        }
        // 0x100003cb0
        v13 = v6 + 1;
    }
    // 0x100003cd4
    return 1;
}

// Address range: 0x100003ce8 - 0x100003d18
int64_t function_100003ce8(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x100003cfc
    _free((int64_t *)*v1);
    *v1 = 0;
    return &g1;
}

// Address range: 0x100003d18 - 0x100003ea4
int64_t function_100003d18(void) {
    // 0x100003d18
    int64_t v1; // 0x100003d18
    int32_t v2 = v1; // 0x100003d28
    _printf("Stirling numbers of the second kind:\nn/k");
    int32_t v3 = -v2;
    if (v2 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e98
        return _printf("\n");
    }
    int32_t v4 = 0; // 0x100003d50
    _printf(v4 != 0 ? "%8d" : "%2d");
    v4++;
    while (v4 - v2 == 0 || v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003d58
        _printf(v4 != 0 ? "%8d" : "%2d");
        v4++;
    }
    // 0x100003dd4
    _printf("\n");
    uint32_t v5 = 0;
    int64_t v6; // 0x100003d18
    _printf("%2d ", v6);
    int32_t v7 = -v5; // 0x100003e00
    int32_t v8 = 0; // 0x100003e08
    int64_t v9 = v6; // 0x100003e08
    int32_t v10; // 0x100003e6c
    int32_t v11; // 0x100003e00
    if (v5 == 0 || v7 < 0 != (v5 & v7) < 0) {
        function_100003a94();
        _printf(v8 != 0 ? "%8d" : "%2d");
        v10 = v8 + 1;
        v11 = v10 - v5;
        v8 = v10;
        while (v11 == 0 || v11 < 0 != ((v11 ^ v10) & (v10 ^ v5)) < 0) {
            // 0x100003e10
            function_100003a94();
            _printf(v8 != 0 ? "%8d" : "%2d");
            v10 = v8 + 1;
            v11 = v10 - v5;
            v8 = v10;
        }
        // 0x100003df8
        v9 = v5;
    }
    int32_t v12 = v5 + 1; // 0x100003e8c
    int32_t v13 = v12 - v2; // 0x100003dc4
    v6 = v9;
    int32_t result = _printf("\n"); // 0x100003dcc
    while (v13 == 0 || v13 < 0 != ((v13 ^ v12) & (v12 ^ v2)) < 0) {
        // 0x100003dd4
        v5 = v12;
        _printf("%2d ", v6);
        v7 = -v5;
        v8 = 0;
        v9 = v6;
        if (v5 == 0 || v7 < 0 != (v5 & v7) < 0) {
            function_100003a94();
            _printf(v8 != 0 ? "%8d" : "%2d");
            v10 = v8 + 1;
            v11 = v10 - v5;
            v8 = v10;
            while (v11 == 0 || v11 < 0 != ((v11 ^ v10) & (v10 ^ v5)) < 0) {
                // 0x100003e10
                function_100003a94();
                _printf(v8 != 0 ? "%8d" : "%2d");
                v10 = v8 + 1;
                v11 = v10 - v5;
                v8 = v10;
            }
            // 0x100003df8
            v9 = v5;
        }
        // 0x100003e78
        v12 = v5 + 1;
        v13 = v12 - v2;
        v6 = v9;
        result = _printf("\n");
    }
    // 0x100003e98
    return result;
}

// Address range: 0x100003ea4 - 0x100003f28
int64_t entry_point(void) {
    int64_t v1 = 0; // bp-40, 0x100003eb8
    int64_t result; // 0x100003ea4
    if (function_100003b5c() % 2 == 0) {
        // 0x100003ed4
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000, "Out of memory\n");
        result = 1;
    } else {
        // 0x100003ef8
        function_100003d18();
        function_100003ce8((int64_t)&v1);
        result = 0;
    }
    // 0x100003f18
    return result;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t * function_100003f28(int32_t nmemb, int32_t size) {
    // 0x100003f28
    return _calloc(nmemb, size);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f34
    return _fprintf(stream, format);
}

// Address range: 0x100003f40 - 0x100003f4c
void function_100003f40(int64_t * ptr) {
    // 0x100003f40
    _free(ptr);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <string.h>

#define MAX_BASE 10

typedef unsigned long long ulong;

int usedDigits[MAX_BASE];
ulong powerDgt[MAX_BASE][MAX_BASE];
ulong numbers[60];
int nCount = 0;

void initPowerDgt() {
    int i, j;
    powerDgt[0][0] = 0;
    for (i = 1; i < MAX_BASE; ++i) powerDgt[0][i] = 1;
    for (j = 1; j < MAX_BASE; ++j) {
        for (i = 0; i < MAX_BASE; ++i) {
            powerDgt[j][i] = powerDgt[j-1][i] * i;
        }
    }
}

ulong calcNum(int depth, int used[MAX_BASE]) {
    int i;
    ulong result = 0, r, n;
    if (depth < 3) return 0;
    for (i = 1; i < MAX_BASE; ++i) {
        if (used[i] > 0) result += powerDgt[depth][i] * used[i];
    }
    if (result == 0) return 0;
    n = result;
    do {
        r = n / MAX_BASE;
        used[n-r*MAX_BASE]--;
        n = r;
        depth--;
    } while (r);
    if (depth) return 0;
    i = 1;
    while (i < MAX_BASE && used[i] == 0) i++;
    if (i >= MAX_BASE) numbers[nCount++] = result;
    return 0;
}

void nextDigit(int dgt, int depth) {
    int i, used[MAX_BASE];
    if (depth < MAX_BASE-1) {
        for (i = dgt; i < MAX_BASE; ++i) {
            usedDigits[dgt]++;
            nextDigit(i, depth+1);
            usedDigits[dgt]--;
        }
    }
    if (dgt == 0) dgt = 1;
    for (i = dgt; i < MAX_BASE; ++i) {
        usedDigits[i]++;
        memcpy(used, usedDigits, sizeof(usedDigits));
        calcNum(depth, used);
        usedDigits[i]--;
    }
}

int main() {
    int i, j;
    ulong t;
    initPowerDgt();
    nextDigit(0, 0);

    // sort and remove duplicates
    for (i = 0; i < nCount-1; ++i) {
        for (j = i + 1; j < nCount; ++j) {
            if (numbers[j] < numbers[i]) {
                t = numbers[i];
                numbers[i] = numbers[j];
                numbers[j] = t;
            }
        }
    }
    j = 0;
    for (i = 1; i < nCount; ++i) {
        if (numbers[i] != numbers[j]) {
            j++;
            t = numbers[i];
            numbers[i] = numbers[j];
            numbers[j] = t;
        }
    }
    printf("Own digits power sums for N = 3 to 9 inclusive:\n");
    for (i = 0; i <= j; ++i) printf("%lld\n", numbers[i]);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003874(void);
int64_t function_10000397c(void);
int64_t function_100003b8c(void);
int64_t function_100003f3c(void);
int64_t * function_100003f48(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f54(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x200000000; // 0x100008008
int64_t g3 = 0; // 0x1000081e8
int64_t g4 = 0; // 0x100008508

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003874 - 0x10000397c
int64_t function_100003874(void) {
    // 0x100003874
    g3 = 0;
    int64_t v1 = 1;
    *(int64_t *)(8 * v1 + (int64_t)&g3) = 1;
    v1++;
    int64_t v2 = 1; // 0x10000389c
    while (v1 != 10) {
        // 0x1000038a4
        *(int64_t *)(8 * v1 + (int64_t)&g3) = 1;
        v1++;
        v2 = 1;
    }
    int64_t v3; // 0x100003874
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003908
        v3 = 8 * i + (int64_t)&g3 + 80 * v2;
        *(int64_t *)v3 = *(int64_t *)(v3 - 80) * i;
    }
    int64_t v4 = v2 + 1;
    v2 = v4;
    while (v4 != 10) {
        for (int64_t i = 0; i < 10; i++) {
            // 0x100003908
            v3 = 8 * i + (int64_t)&g3 + 80 * v2;
            *(int64_t *)v3 = *(int64_t *)(v3 - 80) * i;
        }
        // 0x100003964
        v4 = v2 + 1;
        v2 = v4;
    }
    // 0x100003974
    int64_t result; // 0x100003874
    return result;
}

// Address range: 0x10000397c - 0x100003b8c
int64_t function_10000397c(void) {
    // 0x10000397c
    int64_t v1; // 0x10000397c
    int32_t v2 = v1; // 0x100003980
    if (v2 < 3 != (2 - v2 & v2) < 0) {
        // 0x100003b80
        return 0;
    }
    int64_t v3 = 80 * (0x100000000 * v1 >> 32) + (int64_t)&g3;
    int64_t v4 = 0;
    int64_t v5 = 1;
    uint32_t v6 = *(int32_t *)(4 * v5 + v1); // 0x1000039d0
    int64_t v7 = v4; // 0x1000039dc
    int64_t v8; // 0x100003a00
    if (v6 >= 1) {
        // 0x1000039e4
        v8 = *(int64_t *)(v3 + 8 * v5);
        v7 = v8 * (int64_t)v6 + v4;
    }
    int64_t v9 = v7;
    int64_t v10 = v5 + 1;
    while (v10 != 10) {
        // 0x1000039c8
        v4 = v9;
        v5 = v10;
        v6 = *(int32_t *)(4 * v5 + v1);
        v7 = v4;
        if (v6 >= 1) {
            // 0x1000039e4
            v8 = *(int64_t *)(v3 + 8 * v5);
            v7 = v8 * (int64_t)v6 + v4;
        }
        // 0x100003a28
        v9 = v7;
        v10 = v5 + 1;
    }
    // 0x100003a38
    if (v9 == 0) {
        // 0x100003b80
        return 0;
    }
    int32_t v11 = v2; // 0x100003a44
    uint64_t v12 = v9;
    int64_t v13 = v12 / 10; // 0x100003a68
    int32_t * v14 = (int32_t *)(4 * (-10 * v13 + v12) + v1); // 0x100003a88
    *v14 = *v14 - 1;
    v11--;
    while (v12 >= 10) {
        // 0x100003a60
        v12 = v13;
        v13 = v12 / 10;
        v14 = (int32_t *)(4 * (-10 * v13 + v12) + v1);
        *v14 = *v14 - 1;
        v11--;
    }
    // 0x100003ac0
    if (v11 != 0) {
        // 0x100003b80
        return 0;
    }
    int32_t v15 = 1;
    while (*(int32_t *)(4 * (int64_t)v15 + v1) == 0) {
        int32_t v16 = v15 + 1; // 0x100003b30
        if (v15 < 9 == (8 - v15 & v16) < 0) {
            int32_t v17 = *(int32_t *)&g1; // 0x100003b58
            *(int32_t *)&g1 = v17 + 1;
            *(int64_t *)(8 * (int64_t)v17 + (int64_t)&g2) = v9;
            return 0;
        }
        v15 = v16;
    }
    // 0x100003b80
    return 0;
}

// Address range: 0x100003b8c - 0x100003d20
int64_t function_100003b8c(void) {
    // 0x100003b8c
    int64_t v1; // 0x100003b8c
    int32_t v2 = v1; // 0x100003ba8
    int32_t v3 = v1; // 0x100003bac
    int64_t v4; // 0x100003b8c
    if (v3 < 9 != (8 - v3 & v3) < 0) {
        if (v2 < 10 != (9 - v2 & v2) < 0) {
            int32_t * v5 = (int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g4); // 0x100003bf8
            int32_t v6 = v2;
            *v5 = *v5 + 1;
            int64_t v7 = function_100003b8c(); // 0x100003c10
            int32_t v8 = *v5 - 1; // 0x100003c24
            *v5 = v8;
            int32_t v9 = v6 + 1; // 0x100003c34
            v4 = v7;
            while (v6 < 9 != (8 - v6 & v9) < 0) {
                // 0x100003be4
                v6 = v9;
                *v5 = v8 + 1;
                v7 = function_100003b8c();
                v8 = *v5 - 1;
                *v5 = v8;
                v9 = v6 + 1;
                v4 = v7;
            }
        }
    }
    int32_t v10 = v2 == 0 ? 1 : v2;
    int64_t v11 = v4; // 0x100003c7c
    if (v10 < 10 != (9 - v10 & v10) < 0) {
        int32_t v12 = v10;
        int32_t * v13 = (int32_t *)(4 * (int64_t)v12 + (int64_t)&g4); // 0x100003c9c
        *v13 = *v13 + 1;
        int64_t v14; // bp-64, 0x100003b8c
        _memcpy(&v14, &g4, 40);
        int64_t v15 = function_10000397c(); // 0x100003cc0
        *v13 = *v13 - 1;
        int32_t v16 = v12 + 1; // 0x100003ce4
        v11 = v15;
        while (v12 < 9 != (8 - v12 & v16) < 0) {
            // 0x100003c84
            v12 = v16;
            v13 = (int32_t *)(4 * (int64_t)v12 + (int64_t)&g4);
            *v13 = *v13 + 1;
            _memcpy(&v14, &g4, 40);
            v15 = function_10000397c();
            *v13 = *v13 - 1;
            v16 = v12 + 1;
            v11 = v15;
        }
    }
    int64_t v17 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003cfc
    int64_t result = v11; // 0x100003d08
    if (v17 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003d10
        result = ___stack_chk_fail();
    }
    // 0x100003d14
    return result;
}

// Address range: 0x100003d20 - 0x100003f3c
int64_t entry_point(void) {
    // 0x100003d20
    function_100003874();
    function_100003b8c();
    int32_t v1 = *(int32_t *)&g1; // 0x100003d58
    int32_t v2 = 1 - v1;
    int32_t v3 = v2; // 0x100003d68
    int32_t v4 = v1; // 0x100003d68
    if (v2 < 0 != (v2 & v1 - 1) < 0) {
        int32_t v5 = 0;
        int32_t v6 = v4;
        int32_t v7 = v5 + 1;
        int32_t v8 = v7 - v6; // 0x100003d8c
        int32_t v9 = v6; // 0x100003d94
        int32_t v10; // 0x100003d20
        int32_t v11; // 0x100003d88
        int32_t v12; // 0x100003d20
        int64_t * v13; // 0x100003db0
        int64_t * v14; // 0x100003da8
        uint64_t v15; // 0x100003da8
        uint64_t v16; // 0x100003db0
        int32_t v17; // 0x100003d8c
        if (v8 < 0 != ((v8 ^ v7) & (v7 ^ v6)) < 0) {
            // 0x100003d9c
            v13 = (int64_t *)(8 * (int64_t)v5 + (int64_t)&g2);
            v12 = v7;
            v14 = (int64_t *)(8 * (int64_t)v12 + (int64_t)&g2);
            v15 = *v14;
            v16 = *v13;
            v10 = v6;
            if (v15 < v16) {
                // 0x100003dc4
                *v13 = v15;
                *v14 = v16;
                v10 = *(int32_t *)&g1;
            }
            // 0x100003dfc
            v11 = v10;
            v12++;
            v17 = v12 - v11;
            v9 = v10;
            while (v17 < 0 != ((v17 ^ v12) & (v11 ^ v12)) < 0) {
                // 0x100003d9c
                v14 = (int64_t *)(8 * (int64_t)v12 + (int64_t)&g2);
                v15 = *v14;
                v16 = *v13;
                v10 = v11;
                if (v15 < v16) {
                    // 0x100003dc4
                    *v13 = v15;
                    *v14 = v16;
                    v10 = *(int32_t *)&g1;
                }
                // 0x100003dfc
                v11 = v10;
                v12++;
                v17 = v12 - v11;
                v9 = v10;
            }
        }
        // 0x100003e10
        v4 = v9;
        int32_t v18 = v4 - 1; // 0x100003d5c
        while (v7 - v18 < 0 != ((v7 - v18 ^ v7) & (v18 ^ v7)) < 0) {
            // 0x100003d80
            v5 = v7;
            v6 = v4;
            v7 = v5 + 1;
            v8 = v7 - v6;
            v9 = v6;
            if (v8 < 0 != ((v8 ^ v7) & (v7 ^ v6)) < 0) {
                // 0x100003d9c
                v13 = (int64_t *)(8 * (int64_t)v5 + (int64_t)&g2);
                v12 = v7;
                v14 = (int64_t *)(8 * (int64_t)v12 + (int64_t)&g2);
                v15 = *v14;
                v16 = *v13;
                v10 = v6;
                if (v15 < v16) {
                    // 0x100003dc4
                    *v13 = v15;
                    *v14 = v16;
                    v10 = *(int32_t *)&g1;
                }
                // 0x100003dfc
                v11 = v10;
                v12++;
                v17 = v12 - v11;
                v9 = v10;
                while (v17 < 0 != ((v17 ^ v12) & (v11 ^ v12)) < 0) {
                    // 0x100003d9c
                    v14 = (int64_t *)(8 * (int64_t)v12 + (int64_t)&g2);
                    v15 = *v14;
                    v16 = *v13;
                    v10 = v11;
                    if (v15 < v16) {
                        // 0x100003dc4
                        *v13 = v15;
                        *v14 = v16;
                        v10 = *(int32_t *)&g1;
                    }
                    // 0x100003dfc
                    v11 = v10;
                    v12++;
                    v17 = v12 - v11;
                    v9 = v10;
                }
            }
            // 0x100003e10
            v4 = v9;
            v18 = v4 - 1;
        }
        // 0x100003d50
        v3 = 1 - v4;
    }
    int32_t v19 = v3;
    int32_t v20 = 1; // 0x100003e44
    int32_t v21 = 0; // 0x100003e44
    if (v19 < 0 != (v4 & v19) < 0) {
        int32_t v22 = 0;
        int64_t * v23 = (int64_t *)(8 * (int64_t)v20 + (int64_t)&g2); // 0x100003e58
        int64_t v24 = *v23; // 0x100003e58
        int64_t v25 = *(int64_t *)(8 * (int64_t)v22 + (int64_t)&g2); // 0x100003e60
        int32_t v26 = v4; // 0x100003e6c
        int32_t v27 = v22; // 0x100003e6c
        int64_t * v28; // 0x100003e98
        if (v24 != v25) {
            // 0x100003e74
            v27 = v22 + 1;
            v28 = (int64_t *)(8 * (int64_t)v27 + (int64_t)&g2);
            *v23 = *v28;
            *v28 = v24;
            v26 = *(int32_t *)&g1;
        }
        int32_t v29 = v27;
        int32_t v30 = v26; // 0x100003e38
        v20++;
        int32_t v31 = v20 - v30; // 0x100003e3c
        v21 = v29;
        while (v31 < 0 != ((v31 ^ v20) & (v30 ^ v20)) < 0) {
            // 0x100003e4c
            v22 = v29;
            v23 = (int64_t *)(8 * (int64_t)v20 + (int64_t)&g2);
            v24 = *v23;
            v25 = *(int64_t *)(8 * (int64_t)v22 + (int64_t)&g2);
            v26 = v30;
            v27 = v22;
            if (v24 != v25) {
                // 0x100003e74
                v27 = v22 + 1;
                v28 = (int64_t *)(8 * (int64_t)v27 + (int64_t)&g2);
                *v23 = *v28;
                *v28 = v24;
                v26 = *(int32_t *)&g1;
            }
            // 0x100003eb8
            v29 = v27;
            v30 = v26;
            v20++;
            v31 = v20 - v30;
            v21 = v29;
        }
    }
    int32_t v32 = v21;
    _printf("Own digits power sums for N = 3 to 9 inclusive:\n");
    int32_t v33 = -v32; // 0x100003ee4
    if (v32 != 0 && v33 < 0 == (v32 & v33) < 0) {
        // 0x100003f2c
        return 0;
    }
    int32_t v34 = 0; // 0x100003eec
    _printf("%lld\n", 0);
    v34++;
    while (v34 - v32 == 0 || v34 - v32 < 0 != ((v34 - v32 ^ v34) & (v34 ^ v32)) < 0) {
        // 0x100003ef4
        _printf("%lld\n", 0);
        v34++;
    }
    // 0x100003f2c
    return 0;
}

// Address range: 0x100003f3c - 0x100003f48
int64_t function_100003f3c(void) {
    // 0x100003f3c
    return ___stack_chk_fail();
}

// Address range: 0x100003f48 - 0x100003f54
int64_t * function_100003f48(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f48
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

long long x, y, dx, dy, scale, clen, cscale;
typedef struct { double r, g, b; } rgb;
rgb ** pix;

void sc_up()
{
	scale *= 2; x *= 2; y *= 2;
	cscale *= 3;
}

void h_rgb(long long x, long long y)
{
	rgb *p = &pix[y][x];

#	define SAT 1
	double h = 6.0 * clen / cscale;
	double VAL = 1;
	double c = SAT * VAL;
	double X = c * (1 - fabs(fmod(h, 2) - 1));

	switch((int)h) {
	case 0: p->r += c; p->g += X; return;
	case 1:	p->r += X; p->g += c; return;
	case 2: p->g += c; p->b += X; return;
	case 3: p->g += X; p->b += c; return;
	case 4: p->r += X; p->b += c; return;
	default:
		p->r += c; p->b += X;
	}
}

void iter_string(const char * str, int d)
{
	long long len;
	while (*str != '\0') {
		switch(*(str++)) {
		case 'X':
			if (d)	iter_string("XHXVX", d - 1);
			else{
				clen ++;
				h_rgb(x/scale, y/scale);
				x += dx;
				y -= dy;
			}
			continue;
		case 'V':
			len = 1LLU << d;
			while (len--) {
				clen ++;
				h_rgb(x/scale, y/scale);
				y += dy;
			}
			continue;
		case 'H':
			len = 1LLU << d;
			while(len --) {
				clen ++;
				h_rgb(x/scale, y/scale);
				x -= dx;
			}
			continue;
		}
	}
}

void sierp(long leng, int depth)
{
	long i;
	long h = leng + 20, w = leng + 20;

	/* allocate pixel buffer */
	rgb *buf = malloc(sizeof(rgb) * w * h);
	pix = malloc(sizeof(rgb *) * h);
	for (i = 0; i < h; i++)
		pix[i] = buf + w * i;
	memset(buf, 0, sizeof(rgb) * w * h);

        /* init coords; scale up to desired; exec string */
	x = y = 10; dx = leng; dy = leng; scale = 1; clen = 0; cscale = 3;
	for (i = 0; i < depth; i++) sc_up();
	iter_string("VXH", depth);

	/* write color PNM file */
	unsigned char *fpix = malloc(w * h * 3);
	double maxv = 0, *dbuf = (double*)buf;

	for (i = 3 * w * h - 1; i >= 0; i--)
		if (dbuf[i] > maxv) maxv = dbuf[i];
	for (i = 3 * h * w - 1; i >= 0; i--)
		fpix[i] = 255 * dbuf[i] / maxv;

	printf("P6\n%ld %ld\n255\n", w, h);
	fflush(stdout); /* printf and fwrite may treat buffer differently */
	fwrite(fpix, h * w * 3, 1, stdout);
}

int main(int c, char ** v)
{
	int size, depth;

	depth  = (c > 1) ? atoi(v[1]) : 10;
	size = 1 << depth;

	fprintf(stderr, "size: %d depth: %d\n", size, depth);
	sierp(size, depth + 2);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003620(void);
int64_t function_100003678(int64_t a1, int64_t a2);
int64_t function_100003890(void);
int64_t function_100003b20(void);
int64_t function_100003f00(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003f0c(char * nptr);
int32_t function_100003f18(struct _IO_FILE * stream);
float64_t function_100003f24(float64_t a1, float64_t a2);
int32_t function_100003f30(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f3c(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t * function_100003f48(int32_t size);
int32_t function_100003f54(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t g1 = 255.0; // 0x100003f60
float64_t g2 = 7.2912123841084054e-304; // 0x100008000
float64_t g3 = 4.2439915819305446e-314; // 0x100008008
int64_t g4 = 0x50800000012; // 0x100008010
int64_t g5 = 0x200085; // 0x100008018
int64_t g6 = 0x4800000019; // 0x100008020
char g7[11] = "__PAGEZERO"; // 0x100008028
char g8[3] = "RO"; // 0x100008030
int64_t g9 = 0; // 0x100008038
int32_t g10;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _atoi(char * a1);
int32_t _fflush(struct _IO_FILE * a1);
float64_t _fmod(float64_t a1, float64_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003620 - 0x100003678
int64_t function_100003620(void) {
    // 0x100003620
    *(int64_t *)&g7 = 2 * *(int64_t *)&g7;
    *(int64_t *)&g8 = 2 * *(int64_t *)&g8;
    g9 *= 2;
    g3 = 3 * (int64_t)g3;
    int64_t result; // 0x100003620
    return result;
}

// Address range: 0x100003678 - 0x10000387c
int64_t function_100003678(int64_t a1, int64_t a2) {
    float64_t v1 = 6.0 * g2 / g3; // 0x1000036dc
    int128_t v2; // 0x100003678
    float64_t result = _fmod((float64_t)(int64_t)v2, (float64_t)(int64_t)v2); // 0x10000370c
    float64_t v3 = __asm_fabd(v1, 1.0); // 0x10000371c
    uint32_t v4 = (int32_t)v1; // 0x100003730
    if (v4 >= 4 != v4 != 4) {
        // 0x10000374c
        return result;
    }
    // 0x100003844
    int64_t v5; // 0x100003678
    int64_t v6 = *(int64_t *)(g6 + 8 * v5) + 24 * v5; // 0x1000036ac
    float64_t * v7 = (float64_t *)v6; // 0x1000036b0
    *v7 = *v7 + 1.0;
    float64_t * v8 = (float64_t *)(v6 + 16); // 0x100003860
    *v8 = 1.0 - v3 + *v8;
    return result;
}

// Address range: 0x100003890 - 0x100003b20
int64_t function_100003890(void) {
    // 0x100003890
    int64_t v1; // 0x100003890
    int64_t v2 = 1 << (v1 & 0xffffffff);
    int64_t v3; // 0x100003890
    int64_t v4; // 0x1000038c4
    int64_t v5; // 0x100003890
    int64_t v6; // 0x100003890
    int64_t result; // 0x100003890
    while (true) {
      lab_0x1000038a8_3:
        // 0x1000038a8
        result = v6;
        int64_t v7 = v3; // 0x100003890
        while (true) {
          lab_0x1000038a8:;
            char v8 = *(char *)v7; // 0x1000038ac
            if (v8 == 0) {
                return result;
            }
            // 0x1000038c0
            v4 = v7 + 1;
            v7 = v4;
            switch (v8) {
                case 72: {
                    int64_t v9 = v2 - 1; // 0x100003a88
                    g2 = (int64_t)g2 + 1;
                    int64_t v10 = function_100003678((int64_t)&g8, (int64_t)&g10); // 0x100003ae8
                    *(int64_t *)&g8 = *(int64_t *)&g8 - g4;
                    v5 = v10;
                    int64_t v11 = v9; // 0x100003a98
                    while (v9 != 0) {
                        // 0x100003aa0
                        v9 = v11 - 1;
                        g2 = (int64_t)g2 + 1;
                        v10 = function_100003678((int64_t)&g8, (int64_t)&g10);
                        *(int64_t *)&g8 = *(int64_t *)&g8 - g4;
                        v5 = v10;
                        v11 = v9;
                    }
                    goto lab_0x1000038a8_2;
                }
                case 86: {
                    int64_t v12 = v2 - 1; // 0x1000039e4
                    g2 = (int64_t)g2 + 1;
                    int64_t v13 = function_100003678((int64_t)&g9, (int64_t)&g10); // 0x100003a44
                    g9 += g5;
                    v5 = v13;
                    int64_t v14 = v12; // 0x1000039f4
                    while (v12 != 0) {
                        // 0x1000039fc
                        v12 = v14 - 1;
                        g2 = (int64_t)g2 + 1;
                        v13 = function_100003678((int64_t)&g9, (int64_t)&g10);
                        g9 += g5;
                        v5 = v13;
                        v14 = v12;
                    }
                    goto lab_0x1000038a8_2;
                }
                case 88: {
                    goto lab_0x10000390c;
                }
                default: {
                    goto lab_0x1000038a8;
                }
            }
        }
      lab_0x10000390c:
        if ((int32_t)v1 == 0) {
            // 0x100003938
            g2 = (int64_t)g2 + 1;
            int64_t v15 = function_100003678((int64_t)&g8, (int64_t)&g9); // 0x100003984
            *(int64_t *)&g8 = *(int64_t *)&g8 + g4;
            g9 -= g5;
            v5 = v15;
        } else {
            // 0x100003920
            v5 = function_100003890();
        }
        goto lab_0x1000038a8_2;
    }
    // 0x100003b14
    return result;
  lab_0x1000038a8_2:
    // 0x1000038a8
    v6 = v5;
    v3 = v4;
    goto lab_0x1000038a8_3;
}

// Address range: 0x100003b20 - 0x100003e48
int64_t function_100003b20(void) {
    // 0x100003b20
    int64_t v1; // 0x100003b20
    int64_t v2 = v1 + 20; // 0x100003b38
    int64_t v3 = v2 * v2;
    int64_t v4 = 24 * v3; // 0x100003b5c
    int32_t v5 = v4; // 0x100003b60
    int64_t v6 = (int64_t)_malloc(v5); // 0x100003b60
    int64_t * v7 = _malloc(8 * (int32_t)v2); // 0x100003b74
    g6 = (int64_t)v7;
    int64_t v8 = -20 - v1; // 0x100003b94
    if (v8 < 0 != (v8 & v2) < 0) {
        // 0x100003ba4
        *v7 = v6;
        int64_t v9 = -19 - v1; // 0x100003b94
        if (v9 < 0 != (v9 & v2) < 0) {
            int64_t v10 = 1;
            *(int64_t *)(8 * v10 + g6) = 24 * v2 * v10 + v6;
            int64_t v11 = v10 + 1; // 0x100003bdc
            int64_t v12 = v11 - v2; // 0x100003b94
            while (v12 < 0 != ((v12 ^ v11) & (v11 ^ v2)) < 0) {
                // 0x100003ba4
                v10 = v11;
                *(int64_t *)(8 * v10 + g6) = 24 * v2 * v10 + v6;
                v11 = v10 + 1;
                v12 = v11 - v2;
            }
        }
    }
    // 0x100003be8
    ___memset_chk(v6, 0, v4, -1);
    g9 = 10;
    *(int64_t *)&g8 = 10;
    *(int64_t *)&g7 = 1;
    g2 = 0.0;
    g3 = 1.4821969375237396e-323;
    int64_t v13 = 0x100000000 * v1;
    int64_t v14 = v13 >> 32; // 0x100003c80
    int64_t v15 = 0; // 0x100003c8c
    if (v13 > 0 != (v14 & -v14) < 0) {
        function_100003620();
        v15++;
        while (v15 - v14 < 0 != ((v15 - v14 ^ v15) & (v15 ^ v14)) < 0) {
            // 0x100003c94
            function_100003620();
            v15++;
        }
    }
    // 0x100003cac
    function_100003890();
    int32_t v16 = 3 * (int32_t)v3; // 0x100003cd4
    int64_t * v17 = _malloc(v16); // 0x100003cd4
    float64_t v18 = 0.0; // bp-80, 0x100003ce4
    int64_t v19 = 3 * v3; // 0x100003cfc
    int64_t v20 = v19 - 1;
    if (v20 >= 0) {
        int64_t v21 = (int64_t)v17; // 0x100003cd4
        int64_t v22 = v20;
        float64_t v23 = 0.0; // 0x100003d2c
        float64_t v24 = 0.0;
        int64_t v25 = 8 * v22 + v6; // 0x100003d28
        float64_t v26 = *(float64_t *)v25; // 0x100003d28
        float64_t v27 = v24; // 0x100003d30
        float64_t v28 = v23; // 0x100003d30
        int64_t v29; // 0x100003b20
        if (v26 != v23) {
            v27 = v24;
            v28 = v23;
            if (v26 > v23 == v26 >= v23 == v26 <= v23) {
                // 0x100003d40
                v29 = *(int64_t *)v25;
                v18 = v29;
                v27 = v29;
                v28 = v29;
            }
        }
        float64_t v30 = v27;
        v22--;
        while (v22 >= 0) {
            // 0x100003d20
            v23 = v28;
            v24 = v30;
            v25 = 8 * v22 + v6;
            v26 = *(float64_t *)v25;
            v27 = v24;
            v28 = v23;
            if (v26 != v23) {
                v27 = v24;
                v28 = v23;
                if (v26 > v23 == v26 >= v23 == v26 <= v23) {
                    // 0x100003d40
                    v29 = *(int64_t *)v25;
                    v18 = v29;
                    v27 = v29;
                    v28 = v29;
                }
            }
            // 0x100003d58
            v30 = v27;
            v22--;
        }
        float64_t v31 = *(float64_t *)(8 * v20 + v6); // 0x100003da4
        *(char *)(v20 + v21) = (char)(int32_t)(v31 * g1 / v30);
        int64_t v32 = v19 - 2;
        if (v32 >= 0) {
            float64_t v33 = *(float64_t *)(8 * v32 + v6); // 0x100003da4
            *(char *)(v32 + v21) = (char)(int32_t)(v33 * g1 / v18);
            int64_t v34 = v32 - 1;
            int64_t v35 = v34; // 0x100003d94
            while (v34 >= 0) {
                // 0x100003d9c
                v33 = *(float64_t *)(8 * v35 + v6);
                *(char *)(v35 + v21) = (char)(int32_t)(v33 * g1 / v18);
                v34 = v35 - 1;
                v35 = v34;
            }
        }
    }
    // 0x100003de0
    _printf("P6\n%ld %ld\n255\n", (int32_t)v1, v5);
    int64_t * v36 = (int64_t *)*(int64_t *)0x100004010; // 0x100003e0c
    _fflush((struct _IO_FILE *)*v36);
    return _fwrite(v17, v16, 1, (struct _IO_FILE *)*v36);
}

// Address range: 0x100003e48 - 0x100003f00
int64_t entry_point(void) {
    // 0x100003e48
    int64_t v1; // 0x100003e48
    int32_t v2 = v1; // 0x100003e58
    int32_t v3 = v2 - 1; // 0x100003e64
    if (v3 != 0 && v3 < 0 == (v2 & -v2) < 0) {
        // 0x100003e74
        _atoi((char *)*(int64_t *)(v1 + 8));
    }
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003eb4
    _fprintf((struct _IO_FILE *)v4, "size: %d depth: %d\n", v1, v1);
    function_100003b20();
    return 0;
}

// Address range: 0x100003f00 - 0x100003f0c
int64_t function_100003f00(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f00
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(char * nptr) {
    // 0x100003f0c
    return _atoi(nptr);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(struct _IO_FILE * stream) {
    // 0x100003f18
    return _fflush(stream);
}

// Address range: 0x100003f24 - 0x100003f30
float64_t function_100003f24(float64_t a1, float64_t a2) {
    // 0x100003f24
    return _fmod(a1, a2);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f30
    return _fprintf(stream, format);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003f3c
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003f48 - 0x100003f54
int64_t * function_100003f48(int32_t size) {
    // 0x100003f48
    return _malloc(size);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <math.h>
#include <complex.h>
#include <wchar.h>
#include <locale.h>

int main() {
    wchar_t pi = L'\u03c0'; /* Small pi symbol */
    wchar_t ae = L'\u2245'; /* Approximately equals symbol */
    double complex e = cexp(M_PI * I) + 1.0;
    setlocale(LC_CTYPE, "");
    printf("e ^ %lci + 1 = [%.16f, %.16f] %lc 0\n", pi, creal(e), cimag(e), ae);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
float64_t function_100003f54(float64_t a1);
int32_t function_100003f60(char * format, ...);
char * function_100003f6c(int32_t category, char * locale);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f80

// ------- Dynamically Linked Functions Without Header --------

float64_t _cexp(float64_t a1);
int32_t _printf(char * a1, ...);
char * _setlocale(int32_t a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003ea4 - 0x100003f54
int64_t entry_point(void) {
    // 0x100003ea4
    int128_t v1; // 0x100003ea4
    float64_t v2 = _cexp((float64_t)(int64_t)v1); // 0x100003ee8
    _setlocale(2, (char *)&g1);
    int64_t v3; // 0x100003ea4
    _printf("e ^ %lci + 1 = [%.16f, %.16f] %lc 0\n", (char)&g1, v2, (float64_t)(int64_t)v1, (char)v3);
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
float64_t function_100003f54(float64_t a1) {
    // 0x100003f54
    return _cexp(a1);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// Address range: 0x100003f6c - 0x100003f78
char * function_100003f6c(int32_t category, char * locale) {
    // 0x100003f6c
    return _setlocale(category, locale);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdlib.h>
#include <stdio.h>
#include <sys/stat.h>

int main(void)
{
  struct stat foo;
  stat("input.txt", &foo);
  printf("%ld\n", foo.st_size);
  stat("/input.txt", &foo);
  printf("%ld\n", foo.st_size);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f74(char * format, ...);
int32_t function_100003f80(char * file, struct stat * buf);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _stat(char * a1, struct stat * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003ef8 - 0x100003f74
int64_t entry_point(void) {
    // 0x100003ef8
    int64_t v1; // bp-168, 0x100003ef8
    _stat("input.txt", (struct stat *)&v1);
    int32_t v2 = &v1; // 0x100003f3c
    _printf("%ld\n", v2);
    _stat("/input.txt", (struct stat *)&v1);
    _printf("%ld\n", v2);
    return 0;
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _printf(format);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * file, struct stat * buf) {
    // 0x100003f80
    return _stat(file, buf);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct edit_s edit_t, *edit;
struct edit_s {
	char c1, c2;
	int n;
	edit next;
};

void leven(char *a, char *b)
{
	int i, j, la = strlen(a), lb = strlen(b);
	edit *tbl = malloc(sizeof(edit) * (1 + la));
	tbl[0] = calloc((1 + la) * (1 + lb), sizeof(edit_t));
	for (i = 1; i <= la; i++)
		tbl[i] = tbl[i-1] + (1+lb);

	for (i = la; i >= 0; i--) {
		char *aa = a + i;
		for (j = lb; j >= 0; j--) {
			char *bb = b + j;
			if (!*aa && !*bb) continue;

			edit e = &tbl[i][j];
			edit repl = &tbl[i+1][j+1];
			edit dela = &tbl[i+1][j];
			edit delb = &tbl[i][j+1];

			e->c1 = *aa;
			e->c2 = *bb;
			if (!*aa) {
				e->next = delb;
				e->n = e->next->n + 1;
				continue;
			}
			if (!*bb) {
				e->next = dela;
				e->n = e->next->n + 1;
				continue;
			}

			e->next = repl;
			if (*aa == *bb) {
				e->n = e->next->n;
				continue;
			}

			if (e->next->n > delb->n) {
				e->next = delb;
				e->c1 = 0;
			}
			if (e->next->n > dela->n) {
				e->next = dela;
				e->c1 = *aa;
				e->c2 = 0;
			}
			e->n = e->next->n + 1;
		}
	}

	edit p = tbl[0];
	printf("%s -> %s: %d edits\n", a, b, p->n);

	while (p->next) {
		if (p->c1 == p->c2)
			printf("%c", p->c1);
		else {
			putchar('(');
			if (p->c1) putchar(p->c1);
			putchar(',');
			if (p->c2) putchar(p->c2);
			putchar(')');
		}

		p = p->next;
	}
	putchar('\n');

	free(tbl[0]);
	free(tbl);
}

int main(void)
{
	leven("raisethysword", "rosettacode");
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a18(void);
int64_t * function_100003f2c(int32_t nmemb, int32_t size);
void function_100003f38(int64_t * ptr);
int64_t * function_100003f44(int32_t size);
int32_t function_100003f50(char * format, ...);
int32_t function_100003f5c(int32_t c);
int32_t function_100003f68(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003a18 - 0x100003ef0
int64_t function_100003a18(void) {
    // 0x100003a18
    int64_t v1; // 0x100003a18
    int32_t v2 = _strlen((char *)v1); // 0x100003a30
    int32_t v3 = _strlen((char *)v1); // 0x100003a40
    int64_t * v4 = _malloc(8 * v2 + 8); // 0x100003a6c
    int64_t v5 = (int64_t)v4; // 0x100003a6c
    int32_t v6 = v3 + 1; // 0x100003a80
    *v4 = (int64_t)_calloc(v6 * (v2 + 1), 16);
    int32_t v7 = 1 - v2; // 0x100003ab4
    if (v7 == 0 || v7 < 0 != (v7 & v2) < 0) {
        int32_t v8 = 1; // 0x100003af4
        int64_t v9 = *(int64_t *)((int64_t)(8 * v8 - 8) + v5); // 0x100003ad0
        *(int64_t *)(8 * (int64_t)v8 + v5) = v9 + 16 * (int64_t)v6;
        v8++;
        while (v8 - v2 == 0 || v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x100003ac4
            v9 = *(int64_t *)((int64_t)(8 * v8 - 8) + v5);
            *(int64_t *)(8 * (int64_t)v8 + v5) = v9 + 16 * (int64_t)v6;
            v8++;
        }
    }
    int64_t v10; // 0x100003a18
    int64_t v11; // 0x100003a18
    char * v12; // 0x100003b2c
    int64_t * v13; // 0x100003a18
    int64_t * v14; // 0x100003a18
    char * v15; // 0x100003b5c
    char v16; // 0x100003b64
    if (v2 >= 0) {
        int64_t v17 = v2; // 0x100003a18
        while (true) {
            int64_t v18 = v17;
            if (v3 >= 0) {
                // 0x100003b50
                v12 = (char *)(v18 + v1);
                int64_t v19 = 8 * v18;
                v13 = (int64_t *)(v19 + v5);
                v14 = (int64_t *)((v19 + 8 & 0xfffffff8) + v5);
                v10 = v3;
                while (true) {
                  lab_0x100003b50:
                    // 0x100003b50
                    v11 = v10;
                    v15 = (char *)(v11 + v1);
                    v16 = *v12;
                    if (v16 == 0) {
                        // 0x100003b78
                        if (*v15 == 0) {
                            goto lab_0x100003d8c;
                        } else {
                            goto lab_0x100003b94;
                        }
                    } else {
                        goto lab_0x100003b94;
                    }
                }
            }
          lab_0x100003da0:
            // 0x100003da0
            v17 = v18 - 1;
            if (v18 < 1) {
                // break -> 0x100003db0
                break;
            }
        }
    }
    int64_t v20 = *v4; // 0x100003db4
    _printf("%s -> %s: %d edits\n", (char *)16, (char *)v1, v1);
    int64_t * v21 = (int64_t *)(v20 + 8); // 0x100003df4
    if (*v21 == 0) {
        // 0x100003ec8
        _putchar(10);
        _free((int64_t *)*v4);
        _free(v4);
        return &g1;
    }
    char * v22 = (char *)v20;
    char * v23 = (char *)(v20 + 1); // 0x100003e14
    char v24; // 0x100003e58
    char v25; // 0x100003e88
    if (*v22 == *v23) {
        // 0x100003e28
        _printf("%c", 16);
    } else {
        // 0x100003e4c
        _putchar(40);
        v24 = *v22;
        if (v24 != 0) {
            // 0x100003e6c
            _putchar((int32_t)v24);
        }
        // 0x100003e7c
        _putchar(44);
        v25 = *v23;
        if (v25 != 0) {
            // 0x100003e9c
            _putchar((int32_t)v25);
        }
        // 0x100003eac
        _putchar(41);
    }
    int64_t v26 = *v21; // 0x100003ebc
    int64_t * v27 = (int64_t *)(v26 + 8); // 0x100003df4
    while (*v27 != 0) {
        // 0x100003e08
        v22 = (char *)v26;
        v23 = (char *)(v26 + 1);
        if (*v22 == *v23) {
            // 0x100003e28
            _printf("%c", 16);
        } else {
            // 0x100003e4c
            _putchar(40);
            v24 = *v22;
            if (v24 != 0) {
                // 0x100003e6c
                _putchar((int32_t)v24);
            }
            // 0x100003e7c
            _putchar(44);
            v25 = *v23;
            if (v25 != 0) {
                // 0x100003e9c
                _putchar((int32_t)v25);
            }
            // 0x100003eac
            _putchar(41);
        }
        // 0x100003eb8
        v26 = *v27;
        v27 = (int64_t *)(v26 + 8);
    }
    // 0x100003ec8
    _putchar(10);
    _free((int64_t *)*v4);
    _free(v4);
    return &g1;
  lab_0x100003b94:;
    int64_t v28 = *v13; // 0x100003b9c
    int64_t v29 = 16 * v11; // 0x100003ba4
    int64_t v30 = v28 + v29; // 0x100003ba4
    char * v31 = (char *)v30; // 0x100003ba8
    int64_t v32 = *v14; // 0x100003bb8
    int64_t v33 = 0x100000000 * v11 + 0x100000000 >> 28; // 0x100003bc4
    int64_t v34 = v28 + v33; // 0x100003bfc
    *v31 = v16;
    char * v35 = (char *)(v30 + 1); // 0x100003c20
    *v35 = *v15;
    if (*v12 == 0) {
        // 0x100003c3c
        *(int64_t *)(v30 + 8) = v34;
        *(int32_t *)(v30 + 4) = *(int32_t *)(v34 + 4) + 1;
    } else {
        int64_t v36 = v32 + v29; // 0x100003be0
        int64_t * v37 = (int64_t *)(v30 + 8);
        if (*v15 == 0) {
            // 0x100003c7c
            *v37 = v36;
            *(int32_t *)(v30 + 4) = *(int32_t *)(v36 + 4) + 1;
        } else {
            int64_t v38 = v32 + v33; // 0x100003bc4
            *v37 = v38;
            int32_t v39 = *(int32_t *)(v38 + 4);
            if (*v12 == *v15) {
                // 0x100003cd0
                *(int32_t *)(v30 + 4) = v39;
            } else {
                int32_t v40 = *(int32_t *)(v34 + 4); // 0x100003cf8
                int32_t v41 = v39 - v40; // 0x100003cfc
                int32_t v42 = v39; // 0x100003d04
                if (v41 != 0 && v41 < 0 == ((v41 ^ v39) & (v40 ^ v39)) < 0) {
                    // 0x100003d0c
                    *v37 = v34;
                    *v31 = 0;
                    v42 = *(int32_t *)(*v37 + 4);
                }
                int32_t v43 = v42; // 0x100003d2c
                int32_t v44 = *(int32_t *)(v36 + 4); // 0x100003d34
                int32_t v45 = v43 - v44; // 0x100003d38
                int32_t v46 = v43; // 0x100003d40
                if (v45 != 0 && v45 < 0 == ((v45 ^ v43) & (v44 ^ v43)) < 0) {
                    // 0x100003d48
                    *v37 = v36;
                    *v31 = *v12;
                    *v35 = 0;
                    v46 = *(int32_t *)(*v37 + 4);
                }
                // 0x100003d70
                *(int32_t *)(v30 + 4) = v46 + 1;
            }
        }
    }
    goto lab_0x100003d8c;
  lab_0x100003d8c:
    // 0x100003d8c
    v10 = v11 - 1;
    if (v11 < 1) {
        // break -> 0x100003da0
        goto lab_0x100003da0;
    }
    goto lab_0x100003b50;
}

// Address range: 0x100003ef0 - 0x100003f2c
int64_t entry_point(void) {
    // 0x100003ef0
    function_100003a18();
    return 0;
}

// Address range: 0x100003f2c - 0x100003f38
int64_t * function_100003f2c(int32_t nmemb, int32_t size) {
    // 0x100003f2c
    return _calloc(nmemb, size);
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int64_t * ptr) {
    // 0x100003f38
    _free(ptr);
}

// Address range: 0x100003f44 - 0x100003f50
int64_t * function_100003f44(int32_t size) {
    // 0x100003f44
    return _malloc(size);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * format, ...) {
    // 0x100003f50
    return _printf(format);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(int32_t c) {
    // 0x100003f5c
    return _putchar(c);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * s) {
    // 0x100003f68
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <string.h>

int main(void)
{
  const char *string = "Hello, world!";
  size_t length = strlen(string);

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f8c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003f48 - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003f48
    _strlen("Hello, world!");
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * s) {
    // 0x100003f8c
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <stdlib.h>

int verbose = 0;
#define COND(a, b) int a(int *s) { return (b); }
typedef int(*condition)(int *);

/* BEGIN problem specific setup */
#define N_FLOORS 5
#define TOP (N_FLOORS - 1)
int solution[N_FLOORS] = { 0 };
int occupied[N_FLOORS] = { 0 };

enum tenants {
	baker = 0,
	cooper,
	fletcher,
	miller,
	smith,
	phantom_of_the_opera,
};

const char *names[] = {
	"baker",
	"cooper",
	"fletcher",
	"miller",
	"smith",
};

COND(c0, s[baker] != TOP);
COND(c1, s[cooper] != 0);
COND(c2, s[fletcher] != 0 && s[fletcher] != TOP);
COND(c3, s[miller] > s[cooper]);
COND(c4, abs(s[smith] - s[fletcher]) != 1);
COND(c5, abs(s[cooper] - s[fletcher]) != 1);
#define N_CONDITIONS 6

condition cond[] = { c0, c1, c2, c3, c4, c5 };

/* END of problem specific setup */

int solve(int person)
{
	int i, j;
	if (person == phantom_of_the_opera) {
		/* check condition */
		for (i = 0; i < N_CONDITIONS; i++) {
			if (cond[i](solution)) continue;

			if (verbose) {
				for (j = 0; j < N_FLOORS; j++)
					printf("%d %s\n", solution[j], names[j]);
				printf("cond %d bad\n\n", i);
			}
			return 0;
		}

		printf("Found arrangement:\n");
		for (i = 0; i < N_FLOORS; i++)
			printf("%d %s\n", solution[i], names[i]);
		return 1;
	}

	for (i = 0; i < N_FLOORS; i++) {
		if (occupied[i]) continue;
		solution[person] = i;
		occupied[i] = 1;
		if (solve(person + 1)) return 1;
		occupied[i] = 0;
	}
	return 0;
}

int main()
{
	verbose = 0;
	if (!solve(0)) printf("Nobody lives anywhere\n");
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b10(void);
int64_t function_100003b34(void);
int64_t function_100003b58(void);
int64_t function_100003ba8(void);
int64_t function_100003bd4(void);
int64_t function_100003c14(void);
int64_t function_100003c54(int64_t a1);
int32_t function_100003f24(int32_t x);
int32_t function_100003f30(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1 = -0x1120531; // 0x100008058
int32_t * g2 = (int32_t *)0x100000c; // 0x10000805c
int32_t * g3 = (int32_t *)0x200085; // 0x100008070

// ------- Dynamically Linked Functions Without Header --------

int32_t _abs(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b10 - 0x100003b34
int64_t function_100003b10(void) {
    // 0x100003b10
    int64_t v1; // 0x100003b10
    return (int32_t)v1 != 4;
}

// Address range: 0x100003b34 - 0x100003b58
int64_t function_100003b34(void) {
    // 0x100003b34
    int64_t v1; // 0x100003b34
    return *(int32_t *)(v1 + 4) != 0;
}

// Address range: 0x100003b58 - 0x100003ba8
int64_t function_100003b58(void) {
    // 0x100003b58
    int64_t v1; // 0x100003b58
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x100003b64
    return v2 != 0 == (v2 != 4);
}

// Address range: 0x100003ba8 - 0x100003bd4
int64_t function_100003ba8(void) {
    // 0x100003ba8
    int64_t v1; // 0x100003ba8
    int32_t v2 = *(int32_t *)(v1 + 12); // 0x100003bb4
    int32_t v3 = *(int32_t *)(v1 + 4); // 0x100003bbc
    int32_t v4 = v2 - v3; // 0x100003bc0
    return !((v4 == 0 | v4 < 0 != ((v4 ^ v2) & (v3 ^ v2)) < 0));
}

// Address range: 0x100003bd4 - 0x100003c14
int64_t function_100003bd4(void) {
    // 0x100003bd4
    int64_t v1; // 0x100003bd4
    return _abs(*(int32_t *)(v1 + 16) - *(int32_t *)(v1 + 8)) != 1;
}

// Address range: 0x100003c14 - 0x100003c54
int64_t function_100003c14(void) {
    // 0x100003c14
    int64_t v1; // 0x100003c14
    return _abs(*(int32_t *)(v1 + 4) - *(int32_t *)(v1 + 8)) != 1;
}

// Address range: 0x100003c54 - 0x100003ed4
int64_t function_100003c54(int64_t a1) {
    // 0x100003c54
    int64_t v1; // 0x100003c54
    if ((int32_t)v1 == 5) {
        // 0x100003c94
        return (int64_t)&g2;
    }
    int32_t * v2 = (int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g2);
    int32_t v3 = 0;
    uint64_t v4 = 0;
    int32_t * v5 = (int32_t *)(4 * v4 + (int64_t)&g3); // 0x100003e2c
    if (*v5 == 0) {
        // 0x100003e44
        *v2 = (int32_t)v4;
        *v5 = 1;
        if ((int32_t)function_100003c54(v4) != 0) {
            // break -> 0x100003c94
            break;
        }
        // 0x100003e94
        *v5 = 0;
    }
    int64_t v6 = v4 + 1;
    int64_t result = 0; // 0x100003e18
    while (v4 < 4 != (3 - v3 & (int32_t)v6) < 0) {
        // 0x100003e20
        v3++;
        v4 = v6;
        v5 = (int32_t *)(4 * v4 + (int64_t)&g3);
        if (*v5 == 0) {
            // 0x100003e44
            *v2 = (int32_t)v4;
            *v5 = 1;
            result = 1;
            if ((int32_t)function_100003c54(v4) != 0) {
                // break -> 0x100003c94
                break;
            }
            // 0x100003e94
            *v5 = 0;
        }
        // 0x100003eac
        v6 = v4 + 1;
        result = 0;
    }
    // 0x100003c94
    return result;
}

// Address range: 0x100003ed4 - 0x100003f24
int64_t entry_point(void) {
    // 0x100003ed4
    g1 = 0;
    if ((int32_t)function_100003c54(0) == 0) {
        // 0x100003f04
        _printf("Nobody lives anywhere\n");
    }
    // 0x100003f14
    return 0;
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(int32_t x) {
    // 0x100003f24
    return _abs(x);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * format, ...) {
    // 0x100003f30
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdlib.h>

#define IS_CTRL  (1 << 0)
#define IS_EXT	 (1 << 1)
#define IS_ALPHA (1 << 2)
#define IS_DIGIT (1 << 3) /* not used, just give you an idea */

unsigned int char_tbl[256] = {0};

/* could use ctypes, but then they pretty much do the same thing */
void init_table()
{
	int i;

	for (i = 0; i < 32; i++) char_tbl[i] |= IS_CTRL;
	char_tbl[127] |= IS_CTRL;

	for (i = 'A'; i <= 'Z'; i++) {
		char_tbl[i] |= IS_ALPHA;
		char_tbl[i + 0x20] |= IS_ALPHA; /* lower case */
	}

	for (i = 128; i < 256; i++) char_tbl[i] |= IS_EXT;
}

/* depends on what "stripped" means; we do it in place.
 * "what" is a combination of the IS_* macros, meaning strip if
 * a char IS_ any of them
 */
void strip(char * str, int what)
{
	unsigned char *ptr, *s = (void*)str;
	ptr = s;
	while (*s != '\0') {
		if ((char_tbl[(int)*s] & what) == 0)
			*(ptr++) = *s;
		s++;
	}
	*ptr = '\0';
}

int main()
{
	char a[256];
	int i;

	init_table();

	/* populate string with one of each char */
	for (i = 1; i < 255; i++) a[i - 1] = i; a[255] = '\0';
	strip(a, IS_CTRL);
	printf("%s\n", a);

	for (i = 1; i < 255; i++) a[i - 1] = i; a[255] = '\0';
	strip(a, IS_CTRL | IS_EXT);
	printf("%s\n", a);

	for (i = 1; i < 255; i++) a[i - 1] = i; a[255] = '\0';
	strip(a, IS_CTRL | IS_EXT | IS_ALPHA);
	printf("%s\n", a);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bf8(void);
int64_t function_100003d20(void);
int64_t function_100003f7c(int64_t a1);
int32_t function_100003f88(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
char g2[9] = "TA_CONST"; // 0x1000081fc

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bf8 - 0x100003d20
int64_t function_100003bf8(void) {
    for (int64_t i = 0; i < 32; i++) {
        int32_t * v1 = (int32_t *)(4 * i + (int64_t)&g1); // 0x100003c28
        *v1 = *v1 | 1;
    }
    // 0x100003c48
    *(int32_t *)&g2 = *(int32_t *)&g2 | 1;
    int32_t v2 = 65;
    int32_t * v3 = (int32_t *)(4 * (int64_t)v2 + (int64_t)&g1); // 0x100003c90
    *v3 = *v3 | 4;
    int32_t * v4 = (int32_t *)(4 * (int64_t)(v2 + 32) + (int64_t)&g1); // 0x100003ca8
    *v4 = *v4 | 4;
    int32_t v5 = v2 + 1; // 0x100003cbc
    int32_t v6 = v2 - 89; // 0x100003c6c
    while (v6 == 0 || v6 < 0 != (88 - v2 & v5) < 0) {
        // 0x100003c7c
        v2 = v5;
        v3 = (int32_t *)(4 * (int64_t)v2 + (int64_t)&g1);
        *v3 = *v3 | 4;
        v4 = (int32_t *)(4 * (int64_t)(v2 + 32) + (int64_t)&g1);
        *v4 = *v4 | 4;
        v5 = v2 + 1;
        v6 = v2 - 89;
    }
    int32_t v7 = 128;
    int32_t * v8 = (int32_t *)(4 * (int64_t)v7 + (int64_t)&g1); // 0x100003cf8
    *v8 = *v8 | 2;
    int32_t v9 = v7 + 1; // 0x100003d0c
    while (v7 < 255 != (254 - v7 & v9) < 0) {
        // 0x100003ce8
        v7 = v9;
        v8 = (int32_t *)(4 * (int64_t)v7 + (int64_t)&g1);
        *v8 = *v8 | 2;
        v9 = v7 + 1;
    }
    // 0x100003d18
    int64_t result; // 0x100003bf8
    return result;
}

// Address range: 0x100003d20 - 0x100003dbc
int64_t function_100003d20(void) {
    // 0x100003d20
    int64_t result; // 0x100003d20
    char * v1 = (char *)result;
    char v2 = *v1; // 0x100003d44
    if (v2 == 0) {
        // 0x100003dac
        *v1 = 0;
        return result;
    }
    int32_t v3 = *(int32_t *)(4 * (int64_t)v2 + (int64_t)&g1); // 0x100003d68
    char * v4 = v1; // 0x100003d78
    if ((v3 & (int32_t)result) == 0) {
        // 0x100003d80
        v4 = (char *)((int64_t)v1 + 1);
        *v1 = v2;
    }
    // 0x100003d9c
    int64_t v5; // 0x100003d20
    int64_t v6 = v5 + 1; // 0x100003da0
    char v7 = *(char *)v6; // 0x100003d44
    while (v7 != 0) {
        unsigned char v8 = v7;
        char * v9 = v4; // 0x100003d88
        v3 = *(int32_t *)(4 * (int64_t)v8 + (int64_t)&g1);
        v4 = v9;
        if ((v3 & (int32_t)result) == 0) {
            // 0x100003d80
            v4 = (char *)((int64_t)v9 + 1);
            *v9 = v8;
        }
        // 0x100003d9c
        v6++;
        v7 = *(char *)v6;
    }
    // 0x100003dac
    *v4 = 0;
    return result;
}

// Address range: 0x100003dbc - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003dbc
    function_100003bf8();
    int64_t v1; // bp-296, 0x100003dbc
    int64_t v2 = &v1;
    int32_t v3 = 1;
    *(char *)((int64_t)(v3 - 1) + v2) = (char)v3;
    int32_t v4 = v3 + 1; // 0x100003e20
    while (v3 < 254 != (253 - v3 & v4) < 0) {
        // 0x100003e04
        v3 = v4;
        *(char *)((int64_t)(v3 - 1) + v2) = (char)v3;
        v4 = v3 + 1;
    }
    // 0x100003e2c
    function_100003d20();
    _printf("%s\n", (char *)1);
    int32_t v5 = 1;
    *(char *)((int64_t)(v5 - 1) + v2) = (char)v5;
    int32_t v6 = v5 + 1; // 0x100003e98
    while (v5 < 254 != (253 - v5 & v6) < 0) {
        // 0x100003e7c
        v5 = v6;
        *(char *)((int64_t)(v5 - 1) + v2) = (char)v5;
        v6 = v5 + 1;
    }
    // 0x100003ea4
    function_100003d20();
    _printf("%s\n", (char *)3);
    int32_t v7 = 1;
    *(char *)((int64_t)(v7 - 1) + v2) = (char)v7;
    int32_t v8 = v7 + 1; // 0x100003f0c
    while (v7 < 254 != (253 - v7 & v8) < 0) {
        // 0x100003ef0
        v7 = v8;
        *(char *)((int64_t)(v7 - 1) + v2) = (char)v7;
        v8 = v7 + 1;
    }
    // 0x100003f18
    function_100003d20();
    int32_t v9 = _printf("%s\n", (char *)7); // 0x100003f40
    int64_t v10 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f50
    if (v10 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f64
        ___stack_chk_fail((int64_t)v9);
    }
    // 0x100003f68
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int64_t function_100003f7c(int64_t a1) {
    // 0x100003f7c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include<stdlib.h>
#include<string.h>
#include<stdio.h>

int flag = 1;

void heapPermute(int n, int arr[],int arrLen){
	int temp;
	int i;
	
	if(n==1){
		printf("\n[");
		
		for(i=0;i<arrLen;i++)
			printf("%d,",arr[i]);
		printf("\b] Sign : %d",flag);
		
		flag*=-1;
	}
	else{
		for(i=0;i<n-1;i++){
			heapPermute(n-1,arr,arrLen);
			
			if(n%2==0){
				temp = arr[i];
				arr[i] = arr[n-1];
				arr[n-1] = temp;
			}
			else{
				temp = arr[0];
				arr[0] = arr[n-1];
				arr[n-1] = temp;
			}
		}
		heapPermute(n-1,arr,arrLen);
	}
}

int main(int argC,char* argV[0])
{
	int *arr, i=0, count = 1;
	char* token;
	
	if(argC==1)
		printf("Usage : %s <comma separated list of integers>",argV[0]);
	else{
		while(argV[1][i]!=00){
			if(argV[1][i++]==',')
				count++;
		}
		
		arr = (int*)malloc(count*sizeof(int));
		
		i = 0;
		
		token = strtok(argV[1],",");
		
		while(token!=NULL){
			arr[i++] = atoi(token);
			token = strtok(NULL,",");
		}
		
		heapPermute(i,arr,count);
	}
		
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bf8(void);
int32_t function_100003f34(char * nptr);
int64_t * function_100003f40(int32_t size);
int32_t function_100003f4c(char * format, ...);
char * function_100003f58(char * s, char * delim);

// --------------------- Global Variables ---------------------

int32_t * g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
char * _strtok(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003bf8 - 0x100003dd8
int64_t function_100003bf8(void) {
    // 0x100003bf8
    int64_t v1; // 0x100003bf8
    int32_t v2 = v1; // 0x100003c04
    if (v2 == 1) {
        int32_t v3 = v1; // 0x100003c0c
        _printf("\n[");
        int32_t v4 = -v3; // 0x100003c40
        if (v4 < 0 != (v4 & v3) < 0) {
            _printf("%d,", v1);
            int32_t v5 = 1; // 0x100003c7c
            int32_t v6 = v5 - v3; // 0x100003c40
            int32_t v7 = v5; // 0x100003c48
            while (v6 < 0 != ((v6 ^ v5) & (v5 ^ v3)) < 0) {
                // 0x100003c50
                _printf("%d,", v1);
                v5 = v7 + 1;
                v6 = v5 - v3;
                v7 = v5;
            }
        }
        int32_t result = _printf("\b] Sign : %d", v1); // 0x100003ca8
        *(int32_t *)&g1 = -*(int32_t *)&g1;
        // 0x100003dcc
        return result;
    }
    int32_t v8 = v2 - 1; // 0x100003cd4
    int32_t v9 = 1 - v2; // 0x100003cd8
    int64_t result2 = function_100003bf8(); // 0x100003ce0
    if (v9 < 0 == (v9 & v8) < 0) {
        // 0x100003dcc
        return result2;
    }
    int32_t * v10 = (int32_t *)((4 * v1 + 0xfffffffc & 0xfffffffc) + v1);
    int32_t v11 = 0;
    int32_t v12; // 0x100003bf8
    int32_t * v13; // 0x100003d28
    int64_t v14; // 0x100003bf8
    if (2 * v2 / 2 == v2) {
        // 0x100003d20
        v13 = (int32_t *)(4 * (int64_t)v11 + v1);
        *v13 = *v10;
        v12 = *v13;
    } else {
        // 0x100003d64
        *(int32_t *)v1 = *v10;
        v12 = *(int32_t *)&v14;
    }
    // 0x100003da4
    *v10 = v12;
    int32_t v15 = v11 + 1; // 0x100003da8
    int32_t v16 = v15 - v8; // 0x100003cd8
    result2 = function_100003bf8();
    while (v16 < 0 != ((v16 ^ v15) & (v15 ^ v8)) < 0) {
        // 0x100003ce8
        v11 = v15;
        if (2 * v2 / 2 == v2) {
            // 0x100003d20
            v13 = (int32_t *)(4 * (int64_t)v11 + v1);
            *v13 = *v10;
            v12 = *v13;
        } else {
            // 0x100003d64
            *(int32_t *)v1 = *v10;
            v12 = *(int32_t *)&v14;
        }
        // 0x100003da4
        *v10 = v12;
        v15 = v11 + 1;
        v16 = v15 - v8;
        result2 = function_100003bf8();
    }
    // 0x100003dcc
    return result2;
}

// Address range: 0x100003dd8 - 0x100003f34
int64_t entry_point(void) {
    // 0x100003dd8
    int64_t v1; // 0x100003dd8
    if ((int32_t)v1 == 1) {
        // 0x100003e10
        _printf("Usage : %s <comma separated list of integers>", (char *)v1);
        // 0x100003f24
        return 0;
    }
    int64_t * v2 = (int64_t *)(v1 + 8); // 0x100003e38
    int64_t v3 = *v2; // 0x100003e38
    char v4 = *(char *)v3; // 0x100003e40
    int32_t v5 = 0; // 0x100003e4c
    int32_t v6 = 1; // 0x100003e4c
    int32_t v7 = 4; // 0x100003e4c
    if (v4 != 0) {
        v5++;
        v6 += (int32_t)(v4 == 44);
        char v8 = *(char *)(v3 + (int64_t)v5); // 0x100003e40
        while (v8 != 0) {
            // 0x100003e54
            v5++;
            v6 += (int32_t)(v8 == 44);
            v8 = *(char *)(v3 + (int64_t)v5);
        }
        // 0x100003e34
        v7 = 4 * v6;
    }
    int64_t v9 = (int64_t)_malloc(v7); // 0x100003e9c
    char * v10 = _strtok((char *)*v2, (char *)0x100003fa6); // 0x100003eb8
    int32_t v11 = 0; // 0x100003ed0
    if (v10 != NULL) {
        *(int32_t *)(4 * (int64_t)v11 + v9) = _atoi(v10);
        char * v12 = _strtok(NULL, ","); // 0x100003f04
        v11++;
        while (v12 != NULL) {
            // 0x100003ed8
            *(int32_t *)(4 * (int64_t)v11 + v9) = _atoi(v12);
            v12 = _strtok(NULL, ",");
            v11++;
        }
    }
    // 0x100003f10
    function_100003bf8();
    // 0x100003f24
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * nptr) {
    // 0x100003f34
    return _atoi(nptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t size) {
    // 0x100003f40
    return _malloc(size);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// Address range: 0x100003f58 - 0x100003f64
char * function_100003f58(char * s, char * delim) {
    // 0x100003f58
    return _strtok(s, delim);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* 65536 = 2^16, so we can factor all 32 bit ints */
char bits[65536];

typedef unsigned long ulong;
ulong primes[7000], n_primes;

typedef struct { ulong p, e; } prime_factor; /* prime, exponent */

void sieve()
{
	int i, j;
	memset(bits, 1, 65536);
	bits[0] = bits[1] = 0;
	for (i = 0; i < 256; i++)
		if (bits[i])
			for (j = i * i; j < 65536; j += i)
				bits[j] = 0;

	/* collect primes into a list. slightly faster this way if dealing with large numbers */
	for (i = j = 0; i < 65536; i++)
		if (bits[i]) primes[j++] = i;

	n_primes = j;
}

int get_prime_factors(ulong n, prime_factor *lst)
{
	ulong i, e, p;
	int len = 0;

	for (i = 0; i < n_primes; i++) {
		p = primes[i];
		if (p * p > n) break;
		for (e = 0; !(n % p); n /= p, e++);
		if (e) {
			lst[len].p = p;
			lst[len++].e = e;
		}
	}

	return n == 1 ? len : (lst[len].p = n, lst[len].e = 1, ++len);
}

int ulong_cmp(const void *a, const void *b)
{
	return *(const ulong*)a < *(const ulong*)b ? -1 : *(const ulong*)a > *(const ulong*)b;
}

int get_factors(ulong n, ulong *lst)
{
	int n_f, len, len2, i, j, k, p;
	prime_factor f[100];

	n_f = get_prime_factors(n, f);

	len2 = len = lst[0] = 1;
	/* L = (1); L = (L, L * p**(1 .. e)) forall((p, e)) */
	for (i = 0; i < n_f; i++, len2 = len)
		for (j = 0, p = f[i].p; j < f[i].e; j++, p *= f[i].p)
			for (k = 0; k < len2; k++)
				lst[len++] = lst[k] * p;

	qsort(lst, len, sizeof(ulong), ulong_cmp);
	return len;
}

int main()
{
	ulong fac[10000];
	int len, i, j;
	ulong nums[] = {3, 120, 1024, 2UL*2*2*2*3*3*3*5*5*7*11*13*17*19 };

	sieve();

	for (i = 0; i < 4; i++) {
		len = get_factors(nums[i], fac);
		printf("%lu:", nums[i]);
		for (j = 0; j < len; j++)
			printf(" %lu", fac[j]);
		printf("\n");
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038b8(void);
int64_t function_100003a2c(void);
int64_t function_100003bb4(void);
int64_t function_100003c1c(void);
int64_t function_100003df0(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f30(int64_t a1);
int64_t * function_100003f3c(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f48(char * format, ...);
void function_100003f54(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x100000cfeedfa; // 0x100008001
int64_t g3 = 0; // 0x100018000
int64_t g4 = 0; // 0x100018008
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));

// ------------------------ Functions -------------------------

// Address range: 0x1000038b8 - 0x100003a2c
int64_t function_1000038b8(void) {
    int64_t * v1 = _memset(&g1, 1, 0x10000); // 0x1000038d8
    *(char *)&g2 = 0;
    *(char *)&g1 = 0;
    int32_t v2 = 0;
    char v3 = *(char *)((int64_t)v2 + (int64_t)&g1); // 0x100003914
    int32_t v4; // 0x1000038b8
    int32_t v5; // 0x100003930
    int32_t v6; // 0x100003970
    if (v3 != 0) {
        // 0x100003928
        v5 = v2 * v2;
        v4 = v5;
        if (v5 < 0x10000 != (0xffff - v5 & v5) < 0) {
            *(char *)((int64_t)v4 + (int64_t)&g1) = 0;
            v6 = v4 + v2;
            v4 = v6;
            while (v6 < 0x10000 != (0xffff - v6 & v6) < 0) {
                // 0x100003950
                *(char *)((int64_t)v4 + (int64_t)&g1) = 0;
                v6 = v4 + v2;
                v4 = v6;
            }
        }
    }
    int32_t v7 = v2 + 1; // 0x100003988
    while (v2 < 255 != (254 - v2 & v7) < 0) {
        // 0x100003904
        v2 = v7;
        v3 = *(char *)((int64_t)v2 + (int64_t)&g1);
        if (v3 != 0) {
            // 0x100003928
            v5 = v2 * v2;
            v4 = v5;
            if (v5 < 0x10000 != (0xffff - v5 & v5) < 0) {
                *(char *)((int64_t)v4 + (int64_t)&g1) = 0;
                v6 = v4 + v2;
                v4 = v6;
                while (v6 < 0x10000 != (0xffff - v6 & v6) < 0) {
                    // 0x100003950
                    *(char *)((int64_t)v4 + (int64_t)&g1) = 0;
                    v6 = v4 + v2;
                    v4 = v6;
                }
            }
        }
        // 0x100003984
        v7 = v2 + 1;
    }
    int32_t v8 = 0;
    int32_t v9 = 0;
    int64_t v10 = v9; // 0x1000039b4
    int32_t v11 = v8; // 0x1000039d0
    if (*(char *)(v10 + (int64_t)&g1) != 0) {
        // 0x1000039d8
        *(int64_t *)(8 * (int64_t)v8 + (int64_t)&g4) = v10;
        v11 = v8 + 1;
    }
    int32_t v12 = v11;
    int32_t v13 = v9 + 1; // 0x100003a04
    while (v9 < 0xffff != (0xfffe - v9 & v13) < 0) {
        // 0x1000039b4
        v8 = v12;
        v9 = v13;
        v10 = v9;
        v11 = v8;
        if (*(char *)(v10 + (int64_t)&g1) != 0) {
            // 0x1000039d8
            *(int64_t *)(8 * (int64_t)v8 + (int64_t)&g4) = v10;
            v11 = v8 + 1;
        }
        // 0x100003a00
        v12 = v11;
        v13 = v9 + 1;
    }
    // 0x100003a10
    g3 = v12;
    return (int64_t)v1;
}

// Address range: 0x100003a2c - 0x100003bb4
int64_t function_100003a2c(void) {
    int64_t v1 = g3; // 0x100003a5c
    int64_t v2 = 0; // 0x100003a5c
    int32_t v3 = 0; // 0x100003a5c
    int64_t v4; // 0x100003a2c
    int64_t v5; // 0x100003a2c
    if (g3 != 0) {
        int32_t v6 = 0;
        int64_t v7; // 0x100003a2c
        int64_t v8 = v7;
        uint64_t v9 = *(int64_t *)(8 * v2 + (int64_t)&g4); // 0x100003a70
        uint64_t v10 = v9 * v9; // 0x100003a80
        v3 = v6;
        v4 = v8;
        while (v10 == v8 || v10 < v8) {
            int64_t v11 = v1;
            int64_t v12 = v8; // 0x100003ac0
            int64_t v13 = v8; // 0x100003ac0
            int64_t v14 = v11; // 0x100003ac0
            int32_t v15 = v6; // 0x100003ac0
            if (v8 % v9 == 0) {
                int64_t v16 = v12 / v9; // 0x100003ad4
                int64_t v17 = 1; // 0x100003ae0
                int64_t v18 = v17; // 0x100003ac0
                v12 = v16;
                while (v16 % v9 == 0) {
                    // 0x100003acc
                    v16 = v12 / v9;
                    v17 = v18 + 1;
                    v18 = v17;
                    v12 = v16;
                }
                // 0x100003aec
                v13 = v16;
                v14 = v11;
                v15 = v6;
                if (v17 != 0) {
                    int64_t v19 = 16 * (int64_t)v6 + v5; // 0x100003b10
                    *(int64_t *)v19 = v9;
                    *(int64_t *)(v19 + 8) = v17;
                    v13 = v16;
                    v14 = g3;
                    v15 = v6 + 1;
                }
            }
            // 0x100003b3c
            v1 = v14;
            v2++;
            v3 = v15;
            v4 = v13;
            if (v2 >= v1) {
                // break -> 0x100003b4c
                break;
            }
            v6 = v15;
            v8 = v13;
            v9 = *(int64_t *)(8 * v2 + (int64_t)&g4);
            v10 = v9 * v9;
            v3 = v6;
            v4 = v8;
        }
    }
    int32_t result = v3; // 0x100003b58
    if (v4 != 1) {
        int64_t v20 = 16 * (int64_t)v3 + v5; // 0x100003b7c
        *(int64_t *)v20 = v4;
        *(int64_t *)(v20 + 8) = 1;
        result = v3 + 1;
    }
    // 0x100003ba8
    return result;
}

// Address range: 0x100003bb4 - 0x100003c1c
int64_t function_100003bb4(void) {
    // 0x100003bb4
    int64_t v1; // 0x100003bb4
    uint64_t v2 = v1;
    uint64_t v3 = v1;
    return v3 < v2 ? 0xffffffff : (int64_t)(v3 != v2);
}

// Address range: 0x100003c1c - 0x100003dd0
int64_t function_100003c1c(void) {
    int32_t v1 = function_100003a2c(); // 0x100003c50
    int64_t v2; // 0x100003c1c
    int64_t * v3 = (int64_t *)v2; // 0x100003c5c
    *v3 = 1;
    int32_t v4 = -v1; // 0x100003c7c
    int32_t result = 1; // 0x100003c84
    if (v4 < 0 != (v4 & v1) < 0) {
        int32_t v5 = 0; // 0x100003d64
        int32_t v6 = 1;
        int64_t v7; // bp-1632, 0x100003c1c
        int64_t v8 = 16 * (int64_t)v5 + (int64_t)&v7; // 0x100003c9c
        int64_t * v9 = (int64_t *)(v8 + 8); // 0x100003cb8
        int64_t v10 = *v9; // 0x100003cb8
        int32_t v11 = v6; // 0x100003cc4
        int64_t v12; // 0x100003c1c
        int64_t v13; // 0x100003c1c
        int64_t v14; // 0x100003cb8
        int64_t v15; // 0x100003d48
        int32_t v16; // 0x100003c1c
        int32_t v17; // 0x100003c1c
        int32_t v18; // 0x100003c1c
        int32_t v19; // 0x100003c1c
        int32_t v20; // 0x100003c1c
        int32_t v21; // 0x100003c1c
        int64_t * v22; // 0x100003c9c
        int64_t v23; // 0x100003c9c
        int32_t v24; // 0x100003cdc
        int32_t v25; // 0x100003d34
        int64_t v26; // 0x100003cf4
        int32_t v27; // 0x100003d0c
        int32_t v28; // 0x100003d20
        int32_t v29; // 0x100003cdc
        if (v10 != 0) {
            // 0x100003cd4
            v22 = (int64_t *)v8;
            v23 = *v22;
            v24 = -v6;
            v25 = 0;
            v16 = v6;
            v21 = v23;
            v12 = v10;
            v13 = v23;
            v18 = v16;
            if (v24 < 0 != (v6 & v24) < 0) {
                // 0x100003cec
                v28 = 0;
                v26 = *(int64_t *)(8 * (int64_t)v28 + v2);
                v27 = v16 + 1;
                *(int64_t *)(8 * (int64_t)v16 + v2) = v26 * (int64_t)v21;
                v28++;
                v29 = v28 - v6;
                v17 = v27;
                while (v29 < 0 != ((v29 ^ v28) & (v28 ^ v6)) < 0) {
                    // 0x100003cec
                    v26 = *(int64_t *)(8 * (int64_t)v28 + v2);
                    v27 = v17 + 1;
                    *(int64_t *)(8 * (int64_t)v17 + v2) = v26 * (int64_t)v21;
                    v28++;
                    v29 = v28 - v6;
                    v17 = v27;
                }
                // 0x100003cd4
                v12 = *v9;
                v13 = *v22;
                v18 = v27;
            }
            // 0x100003d30
            v19 = v18;
            v15 = v13;
            v14 = v12;
            v25++;
            v20 = v21 * (int32_t)v15;
            v11 = v19;
            while (v14 > (int64_t)v25) {
                // 0x100003cd4
                v16 = v19;
                v21 = v20;
                v12 = v14;
                v13 = v15;
                v18 = v16;
                if (v24 < 0 != (v6 & v24) < 0) {
                    // 0x100003cec
                    v28 = 0;
                    v26 = *(int64_t *)(8 * (int64_t)v28 + v2);
                    v27 = v16 + 1;
                    *(int64_t *)(8 * (int64_t)v16 + v2) = v26 * (int64_t)v21;
                    v28++;
                    v29 = v28 - v6;
                    v17 = v27;
                    while (v29 < 0 != ((v29 ^ v28) & (v28 ^ v6)) < 0) {
                        // 0x100003cec
                        v26 = *(int64_t *)(8 * (int64_t)v28 + v2);
                        v27 = v17 + 1;
                        *(int64_t *)(8 * (int64_t)v17 + v2) = v26 * (int64_t)v21;
                        v28++;
                        v29 = v28 - v6;
                        v17 = v27;
                    }
                    // 0x100003cd4
                    v12 = *v9;
                    v13 = *v22;
                    v18 = v27;
                }
                // 0x100003d30
                v19 = v18;
                v15 = v13;
                v14 = v12;
                v25++;
                v20 = v21 * (int32_t)v15;
                v11 = v19;
            }
        }
        int32_t v30 = v11;
        v5++;
        int32_t v31 = v5 - v1; // 0x100003c7c
        result = v30;
        while (v31 < 0 != ((v31 ^ v5) & (v5 ^ v1)) < 0) {
            // 0x100003c8c
            v6 = v30;
            v8 = 16 * (int64_t)v5 + (int64_t)&v7;
            v9 = (int64_t *)(v8 + 8);
            v10 = *v9;
            v11 = v6;
            if (v10 != 0) {
                // 0x100003cd4
                v22 = (int64_t *)v8;
                v23 = *v22;
                v24 = -v6;
                v25 = 0;
                v16 = v6;
                v21 = v23;
                v12 = v10;
                v13 = v23;
                v18 = v16;
                if (v24 < 0 != (v6 & v24) < 0) {
                    // 0x100003cec
                    v28 = 0;
                    v26 = *(int64_t *)(8 * (int64_t)v28 + v2);
                    v27 = v16 + 1;
                    *(int64_t *)(8 * (int64_t)v16 + v2) = v26 * (int64_t)v21;
                    v28++;
                    v29 = v28 - v6;
                    v17 = v27;
                    while (v29 < 0 != ((v29 ^ v28) & (v28 ^ v6)) < 0) {
                        // 0x100003cec
                        v26 = *(int64_t *)(8 * (int64_t)v28 + v2);
                        v27 = v17 + 1;
                        *(int64_t *)(8 * (int64_t)v17 + v2) = v26 * (int64_t)v21;
                        v28++;
                        v29 = v28 - v6;
                        v17 = v27;
                    }
                    // 0x100003cd4
                    v12 = *v9;
                    v13 = *v22;
                    v18 = v27;
                }
                // 0x100003d30
                v19 = v18;
                v15 = v13;
                v14 = v12;
                v25++;
                v20 = v21 * (int32_t)v15;
                v11 = v19;
                while (v14 > (int64_t)v25) {
                    // 0x100003cd4
                    v16 = v19;
                    v21 = v20;
                    v12 = v14;
                    v13 = v15;
                    v18 = v16;
                    if (v24 < 0 != (v6 & v24) < 0) {
                        // 0x100003cec
                        v28 = 0;
                        v26 = *(int64_t *)(8 * (int64_t)v28 + v2);
                        v27 = v16 + 1;
                        *(int64_t *)(8 * (int64_t)v16 + v2) = v26 * (int64_t)v21;
                        v28++;
                        v29 = v28 - v6;
                        v17 = v27;
                        while (v29 < 0 != ((v29 ^ v28) & (v28 ^ v6)) < 0) {
                            // 0x100003cec
                            v26 = *(int64_t *)(8 * (int64_t)v28 + v2);
                            v27 = v17 + 1;
                            *(int64_t *)(8 * (int64_t)v17 + v2) = v26 * (int64_t)v21;
                            v28++;
                            v29 = v28 - v6;
                            v17 = v27;
                        }
                        // 0x100003cd4
                        v12 = *v9;
                        v13 = *v22;
                        v18 = v27;
                    }
                    // 0x100003d30
                    v19 = v18;
                    v15 = v13;
                    v14 = v12;
                    v25++;
                    v20 = v21 * (int32_t)v15;
                    v11 = v19;
                }
            }
            // 0x100003d60
            v30 = v11;
            v5++;
            v31 = v5 - v1;
            result = v30;
        }
    }
    // 0x100003d78
    _qsort(v3, result, 8, (int32_t (*)(int64_t *, int64_t *))0x100003bb4);
    int64_t v32 = *(int64_t *)0x100004010; // 0x100003da0
    if (*(int64_t *)v32 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003db8
        ___stack_chk_fail((int64_t)&g5);
    }
    // 0x100003dbc
    return result;
}

// Address range: 0x100003dd0 - 0x100003df0
int64_t entry_point(void) {
    // 0x100003dd0
    return ___chkstk_darwin();
}

// Address range: 0x100003df0 - 0x100003f30
int64_t function_100003df0(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003df0
    int64_t v1; // 0x100003df0
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003e04
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    function_1000038b8();
    int64_t v3; // bp-80008, 0x100003df0
    int32_t v4 = &v3;
    int32_t v5; // 0x100003edc
    for (int32_t i = 0; i < 4; i++) {
        int32_t v6 = function_100003c1c(); // 0x100003e60
        _printf("%lu:", v4);
        int32_t v7 = -v6; // 0x100003e90
        if (v7 < 0 != (v7 & v6) < 0) {
            _printf(" %lu", v4);
            int32_t v8 = 1; // 0x100003ec8
            int32_t v9 = v8 - v6; // 0x100003e90
            int32_t v10 = v8; // 0x100003e98
            while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v6)) < 0) {
                // 0x100003ea0
                _printf(" %lu", v4);
                v8 = v10 + 1;
                v9 = v8 - v6;
                v10 = v8;
            }
        }
        // 0x100003ed4
        v5 = _printf((char *)0x100003f8a);
    }
    // 0x100003ef4
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003f14
        ___stack_chk_fail((int64_t)v5);
    }
    // 0x100003f18
    return 0;
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t function_100003f30(int64_t a1) {
    // 0x100003f30
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f3c
    return _memset(s, c, n);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// Address range: 0x100003f54 - 0x100003f60
void function_100003f54(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f54
    _qsort(base, nmemb, size, compar);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdlib.h>
int main(int argc,char* argv[]){
/* foreach macro viewing an array of int values as a collection of int values */
#define foreach( intpvar , intary ) int* intpvar; for( intpvar=intary; intpvar < (intary+(sizeof(intary)/sizeof(intary[0]))) ; intpvar++)
int a1[]={ 1 , 1 , 2 , 3 , 5 , 8 };
int a2[]={ 3 , 1 , 4 , 1, 5, 9 };
foreach( p1 , a1 ) {
 printf("loop 1 %d\n",*p1);
}
foreach( p2 , a2 ){
 printf("loop 2 %d\n",*p2);
}
exit(0);
return(0);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
void function_100003f48(int32_t status);
int32_t function_100003f54(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 2.12199579145933796095262875903977762e-314L; // 0x100003f60
float128_t g2 = 2.12199579244746925263512184739291521e-314L; // 0x100003f78

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e30 - 0x100003f48
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004000; // bp-24, 0x100003e48
    int64_t v2 = (float64_t)g1; // bp-48, 0x100003e68
    float128_t v3 = g2; // bp-80, 0x100003e80
    int64_t v4; // 0x100003e30
    if (&v2 < &v1) {
        int32_t * v5 = (int32_t *)&v2; // 0x100003edc
        _printf("loop 1 %d\n", v4);
        while ((int32_t *)((int64_t)v5 + 4) < (int32_t *)&v1) {
            // 0x100003eb0
            v5 = (int32_t *)((int64_t)v5 + 4);
            _printf("loop 1 %d\n", v4);
        }
    }
    int64_t v6; // bp-56, 0x100003e30
    if (&v3 >= (float128_t *)&v6) {
        // 0x100003f40
        return 0;
    }
    int32_t * v7 = (int32_t *)&v3; // 0x100003f38
    _printf("loop 2 %d\n", v4);
    while ((int32_t *)((int64_t)v7 + 4) < (int32_t *)&v6) {
        // 0x100003f0c
        v7 = (int32_t *)((int64_t)v7 + 4);
        _printf("loop 2 %d\n", v4);
    }
    // 0x100003f40
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
void function_100003f48(int32_t status) {
    // 0x100003f48
    _exit(status);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

// can be any swap function. This swap is optimized for numbers.
void swap(int *x, int *y) {
	if(x == y)
		return;
	*x ^= *y;
	*y ^= *x;
	*x ^= *y;
}
void cocktailsort(int *a, size_t n) {
	while(1) {
		// packing two similar loops into one
		char flag;
		size_t start[2] = {1, n - 1},
			   end[2] = {n, 0},
			   inc[2] = {1, -1};
		for(int it = 0; it < 2; ++it) {
			flag = 1;
			for(int i = start[it]; i != end[it]; i += inc[it])
				if(a[i - 1] > a[i]) {
					swap(a + i - 1, a + i);
					flag = 0;
				}
			if(flag)
				return;
		}
	}
}

int main(void) {
	int a[] = { 5, -1, 101, -4, 0, 1, 8, 6, 2, 3 };
	size_t n = sizeof(a)/sizeof(a[0]);

	cocktailsort(a, n);
	for (size_t i = 0; i < n; ++i)
		printf("%d ", a[i]);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c68(void);
int64_t function_100003ce4(void);
int64_t function_100003f3c(int64_t a1);
int64_t * function_100003f48(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f54(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 4.94065645841246544176568792868221372e-324L; // 0x100003f60
int64_t g2 = -0xfffffffb; // 0x100003f70

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c68 - 0x100003ce4
int64_t function_100003c68(void) {
    // 0x100003c68
    int64_t result; // 0x100003c68
    // 0x100003cdc
    return result;
}

// Address range: 0x100003ce4 - 0x100003e64
int64_t function_100003ce4(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003cf8
    int64_t v2; // bp-40, 0x100003ce4
    int64_t v3 = &v2; // 0x100003d64
    float128_t v4; // bp-80, 0x100003ce4
    int64_t v5 = &v4;
    int64_t v6; // 0x100003ce4
    while (true) {
      lab_0x100003d0c:
        // 0x100003d0c
        v2 = 1;
        v4 = g1;
        int64_t v7 = 0;
        int32_t v8 = 0; // 0x100003ce4
        int64_t v9; // 0x100003ce4
        int64_t v10 = v9; // 0x100003ce4
        while (true) {
          lab_0x100003d58:;
            int64_t v11 = v7;
            int64_t v12 = 8 * v11; // 0x100003d68
            int64_t v13 = *(int64_t *)(v12 + v3); // 0x100003d68
            int64_t v14 = 0x100000000 * v13 >> 32; // 0x100003d74
            int64_t v15; // bp-56, 0x100003ce4
            int64_t * v16 = (int64_t *)(v12 + (int64_t)&v15); // 0x100003d80
            int64_t v17 = *v16; // 0x100003d80
            v6 = v10;
            if (v17 == v14) {
                // break (via goto) -> 0x100003e1c
                goto lab_0x100003e1c_2;
            }
            int32_t v18 = v8;
            int32_t v19 = v13; // 0x100003e00
            int64_t v20; // 0x100003ce4
            int32_t v21 = *(int32_t *)(v20 + (int64_t)(4 * v19 - 4)); // 0x100003da0
            int32_t v22 = *(int32_t *)(4 * v14 + v20); // 0x100003dac
            int32_t v23 = v21 - v22; // 0x100003db0
            int64_t v24 = v17; // 0x100003db8
            int32_t v25 = 1; // 0x100003db8
            int64_t v26 = v10; // 0x100003db8
            if (v23 != 0 && v23 < 0 == ((v23 ^ v21) & (v22 ^ v21)) < 0) {
                // 0x100003dc0
                v26 = function_100003c68();
                v24 = *v16;
                v25 = 0;
            }
            int64_t v27 = v26;
            int32_t v28 = v25;
            int64_t v29 = v24; // 0x100003d80
            v19 += (int32_t)*(int64_t *)(v12 + v5);
            int64_t v30 = v19; // 0x100003d74
            while (v29 != v30) {
                // 0x100003d94
                v21 = *(int32_t *)(v20 + (int64_t)(4 * v19 - 4));
                v22 = *(int32_t *)(4 * v30 + v20);
                v23 = v21 - v22;
                v24 = v29;
                v25 = v28;
                v26 = v27;
                if (v23 != 0 && v23 < 0 == ((v23 ^ v21) & (v22 ^ v21)) < 0) {
                    // 0x100003dc0
                    v26 = function_100003c68();
                    v24 = *v16;
                    v25 = 0;
                }
                // 0x100003dec
                v27 = v26;
                v28 = v25;
                v29 = v24;
                v19 += (int32_t)*(int64_t *)(v12 + v5);
                v30 = v19;
            }
            // 0x100003e08
            v6 = v27;
            if (v28 % 256 != 0) {
                // break (via goto) -> 0x100003e1c
                goto lab_0x100003e1c_2;
            }
            // 0x100003d44
            v7 = v11 + 1;
            v9 = v27;
            v8 = v18 + 1;
            v10 = v27;
            if (v11 == 0 == ((int32_t)v7 & -v18) < 0) {
                goto lab_0x100003d0c;
            } else {
                goto lab_0x100003d58;
            }
        }
    }
  lab_0x100003e1c_2:;
    int64_t result = v6; // 0x100003e34
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e3c
        result = ___stack_chk_fail(v6);
    }
    // 0x100003e40
    return result;
}

// Address range: 0x100003e64 - 0x100003f3c
int64_t entry_point(void) {
    // 0x100003e64
    int64_t v1; // bp-64, 0x100003e64
    _memcpy(&v1, &g2, 40);
    function_100003ce4();
    int32_t v2; // 0x100003ef0
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003ed0
        v2 = _printf("%d ", 10);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f14
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f28
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f2c
    return 0;
}

// Address range: 0x100003f3c - 0x100003f48
int64_t function_100003f3c(int64_t a1) {
    // 0x100003f3c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f48 - 0x100003f54
int64_t * function_100003f48(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f48
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

int main(int argc, char **argv) {
  FILE *in, *out;
  int c;

  in = fopen("input.txt", "r");
  if (!in) {
    fprintf(stderr, "Error opening input.txt for reading.\n");
    return 1;
  }

  out = fopen("output.txt", "w");
  if (!out) {
    fprintf(stderr, "Error opening output.txt for writing.\n");
    fclose(in);
    return 1;
  }

  while ((c = fgetc(in)) != EOF) {
    fputc(c, out);
  }

  fclose(out);
  fclose(in);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f04(struct _IO_FILE * stream);
int32_t function_100003f10(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f1c(char * filename, char * modes);
int32_t function_100003f28(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f34(int32_t c, struct _IO_FILE * stream);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fclose(struct _IO_FILE * a1);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fputc(int32_t a1, struct _IO_FILE * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003dec - 0x100003f04
int64_t entry_point(void) {
    struct _IO_FILE * v1 = _fopen("input.txt", "r"); // 0x100003e14
    if (v1 == NULL) {
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003e38
        _fprintf((struct _IO_FILE *)v2, "Error opening input.txt for reading.\n");
        // 0x100003ef4
        return 1;
    }
    struct _IO_FILE * v3 = _fopen("output.txt", "w"); // 0x100003e64
    if (v3 == NULL) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003e88
        _fprintf((struct _IO_FILE *)v4, "Error opening output.txt for writing.\n");
        _fclose(v1);
        // 0x100003ef4
        return 1;
    }
    int32_t v5 = _fgetc(v1); // 0x100003eb4
    if (v5 != -1) {
        _fputc(v5, v3);
        int32_t v6 = _fgetc(v1); // 0x100003eb4
        while (v6 != -1) {
            // 0x100003ecc
            _fputc(v6, v3);
            v6 = _fgetc(v1);
        }
    }
    // 0x100003edc
    _fclose(v3);
    _fclose(v1);
    // 0x100003ef4
    return 0;
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(struct _IO_FILE * stream) {
    // 0x100003f04
    return _fclose(stream);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(struct _IO_FILE * stream) {
    // 0x100003f10
    return _fgetc(stream);
}

// Address range: 0x100003f1c - 0x100003f28
struct _IO_FILE * function_100003f1c(char * filename, char * modes) {
    // 0x100003f1c
    return _fopen(filename, modes);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f28
    return _fprintf(stream, format);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(int32_t c, struct _IO_FILE * stream) {
    // 0x100003f34
    return _fputc(c, stream);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define R 6371
#define TO_RAD (3.1415926536 / 180)
double dist(double th1, double ph1, double th2, double ph2)
{
	double dx, dy, dz;
	ph1 -= ph2;
	ph1 *= TO_RAD, th1 *= TO_RAD, th2 *= TO_RAD;

	dz = sin(th1) - sin(th2);
	dx = cos(ph1) * cos(th1) - cos(th2);
	dy = sin(ph1) * cos(th1);
	return asin(sqrt(dx * dx + dy * dy + dz * dz) / 2) * 2 * R;
}

int main()
{
	double d = dist(36.12, -86.67, 33.94, -118.4);
	/* Americans don't know kilometers */
	printf("dist: %.1f km (%.1f mi.)\n", d, d / 1.609344);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d78(void);
float64_t function_100003f20(float64_t a1);
float64_t function_100003f2c(float64_t a1);
int32_t function_100003f38(char * format, ...);
float64_t function_100003f44(float64_t a1);

// ------- Dynamically Linked Functions Without Header --------

float64_t _asin(float64_t a1);
float64_t _cos(float64_t a1);
int32_t _printf(char * a1, ...);
float64_t _sin(float64_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d78 - 0x100003ea4
int64_t function_100003d78(void) {
    // 0x100003d78
    int128_t v1; // 0x100003d78
    float64_t v2 = _cos(_cos(_cos(_sin(_sin((float64_t)(int64_t)v1))))); // 0x100003e10
    return _asin(_cos(_sin(v2)));
}

// Address range: 0x100003ea4 - 0x100003f20
int64_t entry_point(void) {
    // 0x100003ea4
    function_100003d78();
    int128_t v1; // 0x100003ea4
    _printf("dist: %.1f km (%.1f mi.)\n", (float64_t)(int64_t)v1, (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f20 - 0x100003f2c
float64_t function_100003f20(float64_t a1) {
    // 0x100003f20
    return _asin(a1);
}

// Address range: 0x100003f2c - 0x100003f38
float64_t function_100003f2c(float64_t a1) {
    // 0x100003f2c
    return _cos(a1);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * format, ...) {
    // 0x100003f38
    return _printf(format);
}

// Address range: 0x100003f44 - 0x100003f50
float64_t function_100003f44(float64_t a1) {
    // 0x100003f44
    return _sin(a1);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

pthread_mutex_t condm = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int bang = 0;

#define WAITBANG() do { \
   pthread_mutex_lock(&condm); \
   while( bang == 0 ) \
   { \
      pthread_cond_wait(&cond, &condm); \
   } \
   pthread_mutex_unlock(&condm); } while(0);\

void *t_enjoy(void *p)
{
  WAITBANG();
  printf("Enjoy\n");
  pthread_exit(0);
}

void *t_rosetta(void *p)
{
  WAITBANG();
  printf("Rosetta\n");
  pthread_exit(0);
}

void *t_code(void *p)
{
  WAITBANG();
  printf("Code\n");
  pthread_exit(0);
}

typedef void *(*threadfunc)(void *);
int main()
{
   int i;
   pthread_t a[3];
   threadfunc p[3] = {t_enjoy, t_rosetta, t_code};

   for(i=0;i<3;i++)
   {
     pthread_create(&a[i], NULL, p[i], NULL);
   }
   sleep(1);
   bang = 1;
   pthread_cond_broadcast(&cond);
   for(i=0;i<3;i++)
   {
     pthread_join(a[i], NULL);
   }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c80(void);
int64_t function_100003f18(int64_t a1);
int32_t function_100003f24(char * format, ...);
int32_t function_100003f30(int64_t * cond);
int32_t function_100003f3c(int64_t * cond, int64_t * mutex);
int32_t function_100003f48(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg);
void function_100003f54(int64_t * retval);
int32_t function_100003f60(int32_t th, int64_t ** thread_return);
int32_t function_100003f6c(int64_t * mutex);
int32_t function_100003f78(int64_t * mutex);
int32_t function_100003f84(int32_t seconds);

// --------------------- Global Variables ---------------------

float128_t g1 = 2.22507385851485347181302194380861076e-308L; // 0x100004058
int64_t g2 = 0x32aaaba7; // 0x100008000
int64_t g3 = 0x3cb0b1bb; // 0x100008040
int32_t g4 = -0x1120531; // 0x100008070
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _pthread_cond_broadcast(int64_t * a1);
int32_t _pthread_cond_wait(int64_t * a1, int64_t * a2);
int32_t _pthread_create(int32_t * a1, int64_t * a2, int64_t * (*a3)(int64_t *), int64_t * a4);
void _pthread_exit(int64_t * a1);
int32_t _pthread_join(int32_t a1, int64_t ** a2);
int32_t _pthread_mutex_lock(int64_t * a1);
int32_t _pthread_mutex_unlock(int64_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c80 - 0x100003de8
int64_t function_100003c80(void) {
    // 0x100003c80
    _pthread_mutex_lock(&g2);
    if (*(int32_t *)((int64_t)&g2 + 112) == 0) {
        _pthread_cond_wait(&g3, &g2);
        while (*(int32_t *)((int64_t)&g2 + 112) == 0) {
            // 0x100003cbc
            _pthread_cond_wait(&g3, &g2);
        }
    }
    // 0x100003cd4
    _pthread_mutex_unlock(&g2);
    _printf("Enjoy\n");
    _pthread_exit(NULL);
    _pthread_mutex_lock(&g2);
    if (g4 == 0) {
        _pthread_cond_wait(&g3, &g2);
        while (g4 == 0) {
            // 0x100003d34
            _pthread_cond_wait(&g3, &g2);
        }
    }
    // 0x100003d4c
    _pthread_mutex_unlock(&g2);
    _printf("Rosetta\n");
    _pthread_exit(NULL);
    _pthread_mutex_lock(&g2);
    if (g4 != 0) {
        // 0x100003dc4
        _pthread_mutex_unlock(&g2);
        _printf("Code\n");
        _pthread_exit(NULL);
        return &g5;
    }
    _pthread_cond_wait(&g3, &g2);
    while (g4 == 0) {
        // 0x100003dac
        _pthread_cond_wait(&g3, &g2);
    }
    // 0x100003dc4
    _pthread_mutex_unlock(&g2);
    _printf("Code\n");
    _pthread_exit(NULL);
    return &g5;
}

// Address range: 0x100003de8 - 0x100003f18
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dfc
    float128_t v2 = g1; // bp-80, 0x100003e14
    int64_t v3; // bp-48, 0x100003de8
    int64_t v4 = &v3;
    for (int64_t i = 0; i < 3; i++) {
        int64_t v5 = 8 * i; // 0x100003e44
        int64_t v6 = *(int64_t *)(v5 + (int64_t)&v2); // 0x100003e50
        _pthread_create((int32_t *)(v5 + v4), NULL, (int64_t * (*)(int64_t *))v6, NULL);
    }
    // 0x100003e74
    _sleep(1);
    g4 = 1;
    _pthread_cond_broadcast(&g3);
    int32_t v7; // 0x100003ec4
    for (int64_t i = 0; i < 3; i++) {
        // 0x100003eb4
        v7 = _pthread_join((int32_t)*(int64_t *)(8 * i + v4), NULL);
    }
    // 0x100003edc
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f04
        ___stack_chk_fail((int64_t)v7);
    }
    // 0x100003f08
    return 0;
}

// Address range: 0x100003f18 - 0x100003f24
int64_t function_100003f18(int64_t a1) {
    // 0x100003f18
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(int64_t * cond) {
    // 0x100003f30
    return _pthread_cond_broadcast(cond);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(int64_t * cond, int64_t * mutex) {
    // 0x100003f3c
    return _pthread_cond_wait(cond, mutex);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg) {
    // 0x100003f48
    return _pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x100003f54 - 0x100003f60
void function_100003f54(int64_t * retval) {
    // 0x100003f54
    _pthread_exit(retval);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int32_t th, int64_t ** thread_return) {
    // 0x100003f60
    return _pthread_join(th, thread_return);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(int64_t * mutex) {
    // 0x100003f6c
    return _pthread_mutex_lock(mutex);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(int64_t * mutex) {
    // 0x100003f78
    return _pthread_mutex_unlock(mutex);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(int32_t seconds) {
    // 0x100003f84
    return _sleep(seconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int inc(int x) { return (int)&((char *)x)[1]; }
int dec(int x) { return (int)&((char *)x)[-1]; }
int gt(int x, int y)
{
	while (y && x) y = dec(y), x = dec(x);
	return x;
}

int eq(int x, int y)
{
	return !gt(x, y) && !gt(y, x);
}

int add(int x, int y)
{
	while(y) x = inc(x), y = dec(y);
	return x;
}

/* strlen(a) + 1 */
int length(const char *a)
{
	char *x = 0; // assuming (int)(char*)0 == 0
	if (!a) return 0;
	while (*a) a++, x++;
	return (int)x;
}

char *str_cat(char *a, const char *b)
{
	int len = add(1, add(length(a), length(b)));
	if (!(a = realloc(a, len))) abort();
	return strcat(a, b);
}

char *get_line(char *l, FILE *fp)
{
	int c, len = 0;
	char tmp[2] = {0};

	*l = 0;
	while ((c = fgetc(fp)) != EOF) {
		*tmp = c;
		len = inc(len);

		l = str_cat(l, tmp);
		if (eq(*tmp, '\n')) return l;
	}

	*tmp = '\n';
	return len ? str_cat(l, tmp) : l;
}

int main()
{
	int l1, l2;
	char *line = malloc(1), *buf = malloc(1), *longest = malloc(1);
	while (1) {
		line = get_line(line, stdin);

		if (!(l1 = length(line))) break;
		l2 = length(longest);

		if (gt(l1, l2)) {
			*buf = *longest = 0;
			longest = str_cat(longest, line);
		} else if (gt(l2, l1)) continue;

		buf = str_cat(buf, line);
	}
	printf("%s", buf);

	free(buf);
	free(longest);
	free(line);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a94(void);
int64_t function_100003ab0(void);
int64_t function_100003acc(void);
int64_t function_100003b4c(void);
int64_t function_100003bb4(void);
int64_t function_100003c0c(void);
int64_t function_100003c84(void);
int64_t function_100003d0c(void);
int64_t function_100003f40(int64_t a1, int64_t a2, int64_t a3);
void function_100003f4c(void);
int32_t function_100003f58(struct _IO_FILE * stream);
void function_100003f64(int64_t * ptr);
int64_t * function_100003f70(int32_t size);
int32_t function_100003f7c(char * format, ...);
int64_t * function_100003f88(int64_t * ptr, int32_t size);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___strcat_chk(int64_t a1, int64_t a2, int64_t a3);
void _abort(void);
int32_t _fgetc(struct _IO_FILE * a1);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003a94 - 0x100003ab0
int64_t function_100003a94(void) {
    // 0x100003a94
    int64_t v1; // 0x100003a94
    return (0x100000000 * v1 >> 32) + 1;
}

// Address range: 0x100003ab0 - 0x100003acc
int64_t function_100003ab0(void) {
    // 0x100003ab0
    int64_t v1; // 0x100003ab0
    return (0x100000000 * v1 >> 32) - 1;
}

// Address range: 0x100003acc - 0x100003b4c
int64_t function_100003acc(void) {
    // 0x100003acc
    int64_t v1; // 0x100003acc
    if ((int32_t)v1 != 0 != (int32_t)v1 != 0) {
        // 0x100003b3c
        int64_t v2; // 0x100003acc
        return v2 & 0xffffffff;
    }
    int64_t v3 = function_100003ab0(); // 0x100003b24
    int64_t v4 = function_100003ab0(); // 0x100003b30
    while ((int32_t)v3 != 0 == ((int32_t)v4 != 0)) {
        // 0x100003b20
        v3 = function_100003ab0();
        v4 = function_100003ab0();
    }
    // 0x100003b3c
    return v4 & 0xffffffff;
}

// Address range: 0x100003b4c - 0x100003bb4
int64_t function_100003b4c(void) {
    int64_t result = 0; // 0x100003b7c
    if ((int32_t)function_100003acc() == 0) {
        // 0x100003b84
        result = (int32_t)function_100003acc() == 0;
    }
    // 0x100003ba0
    return result;
}

// Address range: 0x100003bb4 - 0x100003c0c
int64_t function_100003bb4(void) {
    // 0x100003bb4
    int64_t v1; // 0x100003bb4
    int64_t v2; // 0x100003bb4
    if ((int32_t)v2 == 0) {
        // 0x100003bfc
        return v1 & 0xffffffff;
    }
    v1 = function_100003a94();
    while ((int32_t)function_100003ab0() != 0) {
        // 0x100003be0
        v1 = function_100003a94();
    }
    // 0x100003bfc
    return v1 & 0xffffffff;
}

// Address range: 0x100003c0c - 0x100003c84
int64_t function_100003c0c(void) {
    // 0x100003c0c
    int64_t v1; // 0x100003c0c
    if (v1 == 0) {
        // 0x100003c78
        return 0;
    }
    // 0x100003c38
    if (*(char *)v1 == 0) {
        // 0x100003c78
        return 0;
    }
    int32_t result = 0; // 0x100003c48
    int64_t v2; // 0x100003c0c
    int64_t v3 = v2 + 1; // 0x100003c54
    result++;
    while (*(char *)v3 != 0) {
        // 0x100003c50
        v3++;
        result++;
    }
    // 0x100003c78
    return result;
}

// Address range: 0x100003c84 - 0x100003d0c
int64_t function_100003c84(void) {
    // 0x100003c84
    function_100003c0c();
    function_100003c0c();
    function_100003bb4();
    int64_t v1; // 0x100003c84
    int64_t * v2 = _realloc((int64_t *)v1, (int32_t)function_100003bb4()); // 0x100003cd0
    if (v2 == NULL) {
        // 0x100003cec
        _abort();
    }
    // 0x100003cf0
    return ___strcat_chk((int64_t)v2, v1, -1);
}

// Address range: 0x100003d0c - 0x100003e00
int64_t function_100003d0c(void) {
    // 0x100003d0c
    int64_t v1; // 0x100003d0c
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x100003d1c
    *(char *)v1 = 0;
    int64_t result; // 0x100003d0c
    if (_fgetc(v2) == -1) {
        // 0x100003df0
        return result;
    }
    int64_t v3 = function_100003a94(); // 0x100003d64
    int64_t v4 = function_100003c84(); // 0x100003d74
    result = v4;
    while ((int32_t)function_100003b4c() == 0) {
        // 0x100003d34
        if (_fgetc(v2) == -1) {
            // 0x100003da8
            result = v4;
            if ((int32_t)v3 == 0) {
                return result;
            } else {
                // 0x100003dc4
                result = function_100003c84();
                return result;
            }
        }
        v3 = function_100003a94();
        v4 = function_100003c84();
        result = v4;
    }
  lab_0x100003df0:
    // 0x100003df0
    return result;
}

// Address range: 0x100003e00 - 0x100003f40
int64_t entry_point(void) {
    // 0x100003e00
    _malloc(1);
    int64_t v1 = (int64_t)_malloc(1); // 0x100003e40
    int64_t v2 = (int64_t)_malloc(1); // 0x100003e40
    int64_t v3; // 0x100003e00
    int64_t v4; // 0x100003e00
    int64_t v5; // 0x100003e54
    while (true) {
        // 0x100003e44
        v4 = v2;
        v3 = v1;
        v5 = function_100003d0c();
        if ((int32_t)function_100003c0c() == 0) {
            // break (via goto) -> 0x100003f00
            goto lab_0x100003f00;
        }
        // 0x100003e7c
        function_100003c0c();
        while ((int32_t)function_100003acc() == 0) {
            // 0x100003ec8
            v2 = v4;
            if ((int32_t)function_100003acc() == 0) {
                goto lab_0x100003eec;
            }
            v5 = function_100003d0c();
            if ((int32_t)function_100003c0c() == 0) {
                // break (via goto) -> 0x100003f00
                goto lab_0x100003f00;
            }
            // 0x100003e7c
            function_100003c0c();
        }
        // 0x100003ea4
        *(char *)v4 = 0;
        *(char *)v3 = 0;
        v2 = function_100003c84();
      lab_0x100003eec:
        // 0x100003eec
        v1 = function_100003c84();
    }
  lab_0x100003f00:
    // 0x100003f00
    _printf("%s", (char *)*(int64_t *)*(int64_t *)0x100004000);
    _free((int64_t *)v3);
    _free((int64_t *)v4);
    _free((int64_t *)v5);
    return 0;
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t function_100003f40(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003f40
    return ___strcat_chk(a1, a2, a3);
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(void) {
    // 0x100003f4c
    _abort();
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(struct _IO_FILE * stream) {
    // 0x100003f58
    return _fgetc(stream);
}

// Address range: 0x100003f64 - 0x100003f70
void function_100003f64(int64_t * ptr) {
    // 0x100003f64
    _free(ptr);
}

// Address range: 0x100003f70 - 0x100003f7c
int64_t * function_100003f70(int32_t size) {
    // 0x100003f70
    return _malloc(size);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// Address range: 0x100003f88 - 0x100003f94
int64_t * function_100003f88(int64_t * ptr, int32_t size) {
    // 0x100003f88
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`#include <stdio.h>

char a1[] = {'a','b','c'};
char a2[] = {'A','B','C'};
int a3[] = {1,2,3};

int main(void) {
    for (int i = 0; i < 3; i++) {
        printf("%c%c%i\n", a1[i], a2[i], a3[i]);
    }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f94(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003eec - 0x100003f94
int64_t entry_point(void) {
    for (int32_t i = 0; i < 3; i++) {
        // 0x100003f18
        int64_t v1; // 0x100003eec
        _printf("%c%c%i\n", (char)v1, (char)v1, v1);
    }
    // 0x100003f84
    return 0;
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(char * format, ...) {
    // 0x100003f94
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`typedef unsigned long long int ulong;

ulong mul_mod(ulong a, ulong b, const ulong mod) {
	ulong res = 0, c; // return (a * b) % mod, avoiding overflow errors while doing modular multiplication.
	for (b %= mod; a; a & 1 ? b >= mod - res ? res -= mod : 0, res += b : 0, a >>= 1, (c = b) >= mod - b ? c -= mod : 0, b += c);
	return res % mod;
}

ulong pow_mod(ulong n, ulong exp, const ulong mod) {
	ulong res = 1; // return (n ^ exp) % mod
	for (n %= mod; exp; exp & 1 ? res = mul_mod(res, n, mod) : 0, n = mul_mod(n, n, mod), exp >>= 1);
	return res;
}

int is_prime(ulong N) {
	// Perform a Miller-Rabin test, it should be a deterministic version.
	const ulong n_primes = 9, primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
	for (ulong i = 0; i < n_primes; ++i)
		if (N % primes[i] == 0) return N == primes[i];
	if (N < primes[n_primes - 1]) return 0;
	int res = 1, s = 0;
	ulong t;
	for (t = N - 1; ~t & 1; t >>= 1, ++s);
	for (ulong i = 0; i < n_primes && res; ++i) {
		ulong B = pow_mod(primes[i], t, N);
		if (B != 1) {
			for (int b = s; b-- && (res = B + 1 != N);)
				B = mul_mod(B, B, N);
			res = !res;
		}
	}
	return res;
}

int main(void){
	return is_prime(8193145868754512737);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a98(void);
int64_t function_100003bbc(void);
int64_t function_100003c74(void);
int64_t function_100003f40(void);
int64_t * function_100003f4c(int64_t * dest, int64_t * src, int32_t n);

// --------------------- Global Variables ---------------------

int64_t g1 = 2; // 0x100003f58

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003a98 - 0x100003bbc
int64_t function_100003a98(void) {
    // 0x100003a98
    int64_t v1; // 0x100003a98
    uint64_t v2 = v1;
    if (v1 == 0) {
        // 0x100003ba0
        return 0;
    }
    int64_t v3 = -v2;
    int64_t v4 = 0;
    int64_t v5; // 0x100003a98
    uint64_t v6 = v5;
    uint64_t v7 = v1 % v2;
    int64_t v8 = v4; // 0x100003aec
    int64_t v9; // 0x100003a98
    if (v6 % 2 != 0) {
        // 0x100003af4
        v9 = v7 < v2 - v4 ? 0 : v3;
        v8 = v4 + v7 + v9;
    }
    int64_t v10 = v8;
    int64_t v11 = (v7 < v2 - v7 ? 0 : v3) + 2 * v7; // 0x100003ad4
    v5 = v6 / 2;
    while (v6 >= 2) {
        // 0x100003ae0
        v4 = v10;
        v6 = v5;
        v7 = v11;
        v8 = v4;
        if (v6 % 2 != 0) {
            // 0x100003af4
            v9 = v7 < v2 - v4 ? 0 : v3;
            v8 = v4 + v7 + v9;
        }
        // 0x100003b44
        v10 = v8;
        v11 = (v7 < v2 - v7 ? 0 : v3) + 2 * v7;
        v5 = v6 / 2;
    }
    // 0x100003ba0
    return v10 % v2;
}

// Address range: 0x100003bbc - 0x100003c74
int64_t function_100003bbc(void) {
    // 0x100003bbc
    int64_t v1; // 0x100003bbc
    if (v1 == 0) {
        // 0x100003c64
        return 1;
    }
    // 0x100003bbc
    int64_t v2; // 0x100003bbc
    uint64_t v3 = v2;
    int64_t v4 = 1; // 0x100003c1c
    if (v3 % 2 != 0) {
        // 0x100003c24
        v4 = function_100003a98();
    }
    int64_t result = v4;
    function_100003a98();
    v2 = v3 / 2;
    while (v3 >= 2) {
        // 0x100003c10
        v3 = v2;
        v4 = result;
        if (v3 % 2 != 0) {
            // 0x100003c24
            v4 = function_100003a98();
        }
        // 0x100003c40
        result = v4;
        function_100003a98();
        v2 = v3 / 2;
    }
    // 0x100003c64
    return result;
}

// Address range: 0x100003c74 - 0x100003f10
int64_t function_100003c74(void) {
    // 0x100003c74
    int64_t v1; // 0x100003c74
    uint64_t v2 = v1;
    int64_t v3; // bp-96, 0x100003c74
    int64_t v4 = &v3; // 0x100003c84
    _memcpy(&v3, &g1, 72);
    int64_t v5 = 0; // 0x100003d2c
    uint64_t v6 = *(int64_t *)(8 * v5 + v4); // 0x100003ce0
    int32_t result; // 0x100003c74
    int32_t v7; // 0x100003c74
    int32_t v8; // 0x100003c74
    int64_t v9; // 0x100003c74
    while (v2 % v6 != 0) {
        // 0x100003cc0
        v5++;
        if (v5 >= 9) {
            // 0x100003d38
            result = 0;
            if (v2 < *(int64_t *)(v4 + 64)) {
                goto lab_0x100003ed4;
            } else {
                int64_t v10 = v2 - 1; // 0x100003d6c
                v8 = 0;
                v9 = v10;
                v7 = 0;
                if (v10 % 2 == 0) {
                    goto lab_0x100003d94;
                } else {
                    goto lab_0x100003db8;
                }
            }
        }
        v6 = *(int64_t *)(8 * v5 + v4);
    }
    // 0x100003d00
    result = v2 == v6;
    goto lab_0x100003ed4;
  lab_0x100003ed4:;
    int64_t v11 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ee8
    if (v11 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003efc
        ___stack_chk_fail();
    }
    // 0x100003f00
    return result;
  lab_0x100003d94:;
    uint64_t v12 = v9;
    int32_t v13 = v7 + 1; // 0x100003da4
    v8 = v13;
    v9 = v12 / 2;
    v7 = v13;
    if ((v12 & 2) == 0) {
        goto lab_0x100003d94;
    } else {
        goto lab_0x100003db8;
    }
  lab_0x100003db8:;
    int64_t v14 = 0; // 0x100003c74
    int32_t v15 = 1; // 0x100003c74
    goto lab_0x100003df4;
  lab_0x100003df4:;
    int32_t v16 = v15;
    int64_t v17 = function_100003bbc(); // 0x100003e08
    int32_t v18 = v16; // 0x100003e1c
    int32_t v19; // 0x100003c74
    int64_t v20; // 0x100003c74
    if (v17 == 1) {
        goto lab_0x100003eb8;
    } else {
        // 0x100003e30
        v19 = v8;
        v20 = v17;
        int32_t v21 = v16; // 0x100003e4c
        if (v8 == 0) {
            // 0x100003e9c
            v18 = v21 == 0;
            goto lab_0x100003eb8;
        } else {
            goto lab_0x100003e78;
        }
    }
  lab_0x100003eb8:;
    int64_t v22 = v14 + 1; // 0x100003ebc
    v14 = v22;
    v15 = v18;
    result = v18;
    if (v22 < 9 != v18 != 0) {
        goto lab_0x100003ed4;
    } else {
        goto lab_0x100003df4;
    }
  lab_0x100003e78:
    // 0x100003e78
    if (v20 + 1 == v2) {
        // 0x100003e9c
        v18 = true;
        goto lab_0x100003eb8;
    } else {
        int32_t v23 = v19 - 1;
        v19 = v23;
        v20 = function_100003a98();
        if (v23 == 0) {
            // 0x100003e9c
            v18 = false;
            goto lab_0x100003eb8;
        } else {
            goto lab_0x100003e78;
        }
    }
}

// Address range: 0x100003f10 - 0x100003f40
int64_t entry_point(void) {
    // 0x100003f10
    return function_100003c74();
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t function_100003f40(void) {
    // 0x100003f40
    return ___stack_chk_fail();
}

// Address range: 0x100003f4c - 0x100003f58
int64_t * function_100003f4c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f4c
    return _memcpy(dest, src, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`/* man-or-boy.c */
#include <stdio.h>
#include <stdlib.h>

// --- thunks
typedef struct arg
{
  int       (*fn)(struct arg*);
  int        *k;
  struct arg *x1, *x2, *x3, *x4, *x5;
} ARG;

// --- lambdas
int f_1 (ARG* _) { return -1; }
int f0  (ARG* _) { return  0; }
int f1  (ARG* _) { return  1; }

// --- helper
int eval(ARG* a) { return a->fn(a); }
#define MAKE_ARG(...) (&(ARG){__VA_ARGS__})
#define FUN(...) MAKE_ARG(B, &k, __VA_ARGS__)

int A(ARG*);

// --- functions
int B(ARG* a)
{
  int k = *a->k -= 1;
  return A(FUN(a, a->x1, a->x2, a->x3, a->x4));
}

int A(ARG* a)
{
  return *a->k <= 0 ? eval(a->x4) + eval(a->x5) : B(a);
}

int main(int argc, char **argv)
{
  int k = argc == 2 ? strtol(argv[1], 0, 0) : 10;
  printf("%d\n", A(FUN(MAKE_ARG(f1), MAKE_ARG(f_1), MAKE_ARG(f_1),
                       MAKE_ARG(f1), MAKE_ARG(f0))));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c84(void);
int64_t function_100003c98(void);
int64_t function_100003cac(void);
int64_t function_100003cc0(void);
int64_t function_100003ce0(int64_t a1, int64_t a2);
int64_t function_100003cec(int64_t a1);
int64_t function_100003d74(void);
int64_t * function_100003f70(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f7c(char * format, ...);
int32_t function_100003f88(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003c84 - 0x100003c98
int64_t function_100003c84(void) {
    // 0x100003c84
    return 0xffffffff;
}

// Address range: 0x100003c98 - 0x100003cac
int64_t function_100003c98(void) {
    // 0x100003c98
    return 0;
}

// Address range: 0x100003cac - 0x100003cc0
int64_t function_100003cac(void) {
    // 0x100003cac
    return 1;
}

// Address range: 0x100003cc0 - 0x100003ce0
int64_t function_100003cc0(void) {
    // 0x100003cc0
    int64_t result; // 0x100003cc0
    return result;
}

// Address range: 0x100003ce0 - 0x100003cec
int64_t function_100003ce0(int64_t a1, int64_t a2) {
    // 0x100003ce0
    int64_t result; // 0x100003ce0
    return result;
}

// Address range: 0x100003cec - 0x100003d74
int64_t function_100003cec(int64_t a1) {
    int32_t * v1 = (int32_t *)*(int64_t *)(a1 + 8); // 0x100003d04
    *v1 = *v1 - 1;
    return function_100003d74();
}

// Address range: 0x100003d74 - 0x100003df0
int64_t function_100003d74(void) {
    // 0x100003d74
    int64_t v1; // 0x100003d74
    int64_t v2; // 0x100003d74
    if (*(int32_t *)*(int64_t *)(v2 + 8) < 1) {
        int64_t v3 = function_100003cc0(); // 0x100003da8
        v1 = function_100003cc0() + v3;
    } else {
        // 0x100003dd0
        v1 = function_100003cec(v2);
    }
    // 0x100003de0
    return v1 & 0xffffffff;
}

// Address range: 0x100003df0 - 0x100003f70
int64_t entry_point(void) {
    // 0x100003df0
    int64_t v1; // 0x100003df0
    if ((int32_t)v1 == 2) {
        // 0x100003e20
        _strtol((char *)*(int64_t *)(v1 + 8), NULL, 0);
    }
    // 0x100003e48
    int64_t v2; // bp-168, 0x100003df0
    _memset(&v2, 0, 56);
    v2 = 0x100003cac;
    int64_t v3; // bp-224, 0x100003df0
    _memset(&v3, 0, 56);
    v3 = 0x100003c84;
    int64_t v4; // bp-280, 0x100003df0
    _memset(&v4, 0, 56);
    v4 = 0x100003c84;
    int64_t v5; // bp-336, 0x100003df0
    _memset(&v5, 0, 56);
    v5 = 0x100003cac;
    int64_t v6; // bp-392, 0x100003df0
    _memset(&v6, 0, 56);
    v6 = 0x100003c98;
    function_100003d74();
    _printf("%d\n", 0);
    return 0;
}

// Address range: 0x100003f70 - 0x100003f7c
int64_t * function_100003f70(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f70
    return _memset(s, c, n);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * nptr, char ** endptr, int32_t base) {
    // 0x100003f88
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define KeyType const char *
#define ValType int

#define HASH_SIZE 4096

// hash function useful when KeyType is char * (string)
unsigned strhashkey( const char * key, int max)
{
    unsigned h=0;
    unsigned hl, hr;

    while(*key) {
        h += *key;
        hl= 0x5C5 ^ (h&0xfff00000 )>>18;
        hr =(h&0x000fffff );
        h = hl ^ hr ^ *key++;
    }
    return h % max;
}

typedef struct sHme {
    KeyType    key;
    ValType    value;
    struct sHme  *link;
} *MapEntry;

typedef struct he {
    MapEntry  first, last;
} HashElement;

HashElement hash[HASH_SIZE];

typedef void (*KeyCopyF)(KeyType *kdest, KeyType ksrc);
typedef void (*ValCopyF)(ValType *vdest, ValType vsrc);
typedef unsigned (*KeyHashF)( KeyType key, int upperBound );
typedef int (*KeyCmprF)(KeyType key1, KeyType key2);

void HashAddH( KeyType key, ValType value,
        KeyCopyF copyKey, ValCopyF copyVal, KeyHashF hashKey, KeyCmprF keySame )
{
    unsigned hix = (*hashKey)(key, HASH_SIZE);
    MapEntry m_ent;

    for (m_ent= hash[hix].first;
            m_ent && !(*keySame)(m_ent->key,key); m_ent=m_ent->link);
    if (m_ent) {
        (*copyVal)(&m_ent->value, value);
    }
    else {
        MapEntry last;
        MapEntry hme = malloc(sizeof(struct sHme));
        (*copyKey)(&hme->key, key);
        (*copyVal)(&hme->value, value);
        hme->link = NULL;
        last = hash[hix].last;
        if (last) {
//	    printf("Dup. hash key\n");
            last->link = hme;
        }
        else
            hash[hix].first = hme;
        hash[hix].last = hme;
    }
}

int HashGetH(ValType *val, KeyType key, KeyHashF hashKey, KeyCmprF keySame )
{
    unsigned hix = (*hashKey)(key, HASH_SIZE);
    MapEntry m_ent;
    for (m_ent= hash[hix].first;
            m_ent && !(*keySame)(m_ent->key,key); m_ent=m_ent->link);
    if (m_ent) {
        *val = m_ent->value;
    }
    return (m_ent != NULL);
}

void copyStr(const char**dest, const char *src)
{
    *dest = strdup(src);
}
void copyInt( int *dest, int src)
{
    *dest = src;
}
int strCompare( const char *key1, const char *key2)
{
    return strcmp(key1, key2) == 0;
}

void HashAdd( KeyType key, ValType value )
{
    HashAddH( key, value, &copyStr, &copyInt, &strhashkey, &strCompare);
}

int HashGet(ValType *val, KeyType key)
{
    return HashGetH( val, key, &strhashkey, &strCompare);
}

int main()
{
    static const char * keyList[] = {"red","orange","yellow","green", "blue", "violet" };
    static int valuList[] = {1,43,640, 747, 42, 42};
    int ix;

    for (ix=0; ix<6; ix++) {
        HashAdd(keyList[ix], valuList[ix]);
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a98(void);
int64_t function_100003b3c(void);
int64_t function_100003b70(int64_t a1);
int64_t function_100003c38(int64_t a1);
int64_t function_100003c4c(int64_t a1);
int64_t function_100003cd0(int64_t a1, int64_t a2);
int64_t function_100003cdc(void);
int64_t function_100003d08(int64_t a1);
int64_t function_100003dcc(void);
int64_t function_100003dfc(void);
int64_t function_100003e1c(void);
int64_t function_100003e54(int64_t a1, int32_t a2);
int64_t function_100003ea0(void);
int64_t * function_100003f50(int32_t size);
int32_t function_100003f5c(char * s1, char * s2);
char * function_100003f68(char * s);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x2b00000001; // 0x100008030
int64_t g2 = 0x100000cfeedfacf; // 0x100008048
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t * _malloc(int32_t a1);
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003a98 - 0x100003b3c
int64_t function_100003a98(void) {
    // 0x100003a98
    int64_t v1; // 0x100003a98
    char v2 = *(char *)v1; // 0x100003ab0
    if (v2 == 0) {
        // 0x100003b20
        return 0;
    }
    int32_t v3 = v2; // 0x100003ac8
    uint32_t v4 = v3; // 0x100003ad0
    int64_t v5; // 0x100003a98
    int64_t v6 = v5 + 1; // 0x100003b08
    int32_t v7 = v3 ^ 1477 ^ v4 % 0x100000 ^ v4 / 0x40000 & 0x3ffc; // 0x100003b14
    char v8 = *(char *)v6; // 0x100003ab0
    while (v8 != 0) {
        // 0x100003ac4
        v3 = v8;
        v4 = v7 + v3;
        v6++;
        v7 = v3 ^ 1477 ^ v4 % 0x100000 ^ v4 / 0x40000 & 0x3ffc;
        v8 = *(char *)v6;
    }
    // 0x100003b20
    return v7 % (int32_t)v1;
}

// Address range: 0x100003b3c - 0x100003b70
int64_t function_100003b3c(void) {
    // 0x100003b3c
    int64_t result; // 0x100003b3c
    return result;
}

// Address range: 0x100003b70 - 0x100003c38
int64_t function_100003b70(int64_t a1) {
    // 0x100003b70
    int64_t v1; // 0x100003b70
    int64_t v2 = *(int64_t *)((16 * v1 & 0xffffffff0) + (int64_t)&g2);
    if (v2 == 0) {
        // 0x100003c1c
        return (int64_t)_malloc(24);
    }
    // 0x100003bac
    return *(int64_t *)v2;
}

// Address range: 0x100003c38 - 0x100003c4c
int64_t function_100003c38(int64_t a1) {
    // 0x100003c38
    return a1 + 8;
}

// Address range: 0x100003c4c - 0x100003cd0
int64_t function_100003c4c(int64_t a1) {
    // 0x100003c4c
    *(int64_t *)(a1 + 16) = 0;
    int32_t v1; // 0x100003c4c
    int64_t v2 = 16 * (int64_t)(uint32_t)v1; // 0x100003c64
    int64_t * v3 = (int64_t *)(v2 + (int64_t)&g2 + 8); // 0x100003c68
    int64_t v4 = *v3; // 0x100003c68
    if (v4 == 0) {
        // 0x100003c94
        *(int64_t *)(v2 + (int64_t)&g2) = a1;
    } else {
        // 0x100003c84
        *(int64_t *)(v4 + 16) = a1;
    }
    // 0x100003cb0
    *v3 = a1;
    return function_100003cd0((int64_t)&g3, (int64_t)&g3);
}

// Address range: 0x100003cd0 - 0x100003cdc
int64_t function_100003cd0(int64_t a1, int64_t a2) {
    // 0x100003cd0
    int64_t result; // 0x100003cd0
    return result;
}

// Address range: 0x100003cdc - 0x100003d08
int64_t function_100003cdc(void) {
    // 0x100003cdc
    int64_t result; // 0x100003cdc
    return result;
}

// Address range: 0x100003d08 - 0x100003dcc
int64_t function_100003d08(int64_t a1) {
    // 0x100003d08
    int64_t v1; // 0x100003d08
    int64_t v2 = *(int64_t *)((16 * v1 & 0xffffffff0) + (int64_t)&g2);
    if (v2 == 0) {
        // 0x100003db0
        return 0;
    }
    // 0x100003d44
    return *(int64_t *)v2;
}

// Address range: 0x100003dcc - 0x100003dfc
int64_t function_100003dcc(void) {
    // 0x100003dcc
    int64_t v1; // 0x100003dcc
    int64_t result = (int64_t)_strdup((char *)v1); // 0x100003de4
    *(int64_t *)v1 = result;
    return result;
}

// Address range: 0x100003dfc - 0x100003e1c
int64_t function_100003dfc(void) {
    // 0x100003dfc
    int64_t result; // 0x100003dfc
    *(int32_t *)result = (int32_t)result;
    return result;
}

// Address range: 0x100003e1c - 0x100003e54
int64_t function_100003e1c(void) {
    // 0x100003e1c
    int64_t v1; // 0x100003e1c
    return _strcmp((char *)v1, (char *)v1) == 0;
}

// Address range: 0x100003e54 - 0x100003ea0
int64_t function_100003e54(int64_t a1, int32_t a2) {
    // 0x100003e54
    return function_100003b3c();
}

// Address range: 0x100003ea0 - 0x100003edc
int64_t function_100003ea0(void) {
    // 0x100003ea0
    return function_100003cdc();
}

// Address range: 0x100003edc - 0x100003f50
int64_t entry_point(void) {
    for (int64_t i = 0; i < 6; i++) {
        int32_t v1 = *(int32_t *)(4 * i + (int64_t)&g1); // 0x100003f24
        function_100003e54(*(int64_t *)(8 * i + (int64_t)"t?"), v1);
    }
    // 0x100003f40
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t * function_100003f50(int32_t size) {
    // 0x100003f50
    return _malloc(size);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * s1, char * s2) {
    // 0x100003f5c
    return _strcmp(s1, s2);
}

// Address range: 0x100003f68 - 0x100003f74
char * function_100003f68(char * s) {
    // 0x100003f68
    return _strdup(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 17

`
`#include <stdio.h>

typedef unsigned int uint;

/* the sequence, 0-th member is 0 */
uint f(uint n)
{
	return n < 2 ? n : (n&1) ? f(n/2) + f(n/2 + 1) : f(n/2);
}

uint gcd(uint a, uint b)
{
	return a ? a < b ? gcd(b%a, a) : gcd(a%b, b) : b;
}

void find(uint from, uint to)
{
	do {
		uint n;
		for (n = 1; f(n) != from ; n++);
		printf("%3u at Stern #%u.\n", from, n);
	} while (++from <= to);
}

int main(void)
{
	uint n;
	for (n = 1; n < 16; n++) printf("%u ", f(n));
	puts("are the first fifteen.");

	find(1, 10);
	find(100, 0);

	for (n = 1; n < 1000 && gcd(f(n), f(n+1)) == 1; n++);
	printf(n == 1000 ? "All GCDs are 1.\n" : "GCD of #%d and #%d is not 1", n, n+1);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bbc(void);
int64_t function_100003c74(void);
int64_t function_100003d24(void);
int32_t function_100003f34(char * format, ...);
int32_t function_100003f40(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003bbc - 0x100003c74
int64_t function_100003bbc(void) {
    // 0x100003bbc
    int64_t v1; // 0x100003bbc
    uint32_t v2 = (int32_t)v1; // 0x100003bc8
    int64_t v3; // 0x100003bbc
    if (v2 < 2) {
        // 0x100003c64
        return v3 & 0xffffffff;
    }
    int64_t v4 = function_100003bbc();
    v3 = v4;
    if (v2 % 2 != 0) {
        // 0x100003c00
        v3 = function_100003bbc() + v4;
    }
    // 0x100003c64
    return v3 & 0xffffffff;
}

// Address range: 0x100003c74 - 0x100003d24
int64_t function_100003c74(void) {
    // 0x100003c74
    int64_t v1; // 0x100003c74
    int64_t v2; // 0x100003c74
    if ((int32_t)v2 != 0) {
        // 0x100003c9c
        v1 = function_100003c74();
    }
    // 0x100003d14
    return v1 & 0xffffffff;
}

// Address range: 0x100003d24 - 0x100003dd0
int64_t function_100003d24(void) {
    // 0x100003d24
    int64_t v1; // 0x100003d24
    uint32_t v2 = (int32_t)v1; // 0x100003d34
    int32_t v3 = v1; // 0x100003d38
    while (v3 != (int32_t)function_100003bbc()) {
        // continue -> 0x100003d48
    }
    int32_t result = _printf("%3u at Stern #%u.\n", v2, (int32_t)v1); // 0x100003d9c
    v3++;
    while (v3 == v2 || v3 < v2) {
        // 0x100003d3c
        while (v3 != (int32_t)function_100003bbc()) {
            // continue -> 0x100003d48
        }
        // 0x100003d78
        result = _printf("%3u at Stern #%u.\n", v2, (int32_t)v1);
        v3++;
    }
    // 0x100003dc4
    return result;
}

// Address range: 0x100003dd0 - 0x100003f34
int64_t entry_point(void) {
    for (int32_t i = 1; i < 16; i++) {
        // 0x100003e00
        function_100003bbc();
        int64_t v1; // 0x100003dd0
        _printf("%u ", (int32_t)v1);
    }
    // 0x100003e34
    _puts("are the first fifteen.");
    function_100003d24();
    function_100003d24();
    int32_t v2 = 1; // 0x100003ecc
    function_100003bbc();
    function_100003bbc();
    int32_t v3 = v2; // 0x100003ebc
    while ((int32_t)function_100003c74() == 1) {
        // 0x100003ec8
        v2++;
        v3 = 1000;
        if (v2 >= 1000) {
            // break -> 0x100003ed8
            break;
        }
        function_100003bbc();
        function_100003bbc();
        v3 = v2;
    }
    // 0x100003ed8
    _printf(v3 != 1000 ? "GCD of #%d and #%d is not 1" : "All GCDs are 1.\n");
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(char * s) {
    // 0x100003f40
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

char *sortedWord(const char *word, char *wbuf)
{
    char *p1, *p2, *endwrd;
    char t;
    int swaps;

    strcpy(wbuf, word);
    endwrd = wbuf+strlen(wbuf);
    do {
       swaps = 0;
       p1 = wbuf; p2 = endwrd-1;
       while (p1<p2) {
          if (*p2 > *p1) {
             t = *p2; *p2 = *p1; *p1 = t;
             swaps = 1;
          }
          p1++; p2--;
       }
       p1 = wbuf; p2 = p1+1;
       while(p2 < endwrd) {
           if (*p2 > *p1) {
             t = *p2; *p2 = *p1; *p1 = t;
             swaps = 1;
           }
           p1++; p2++;
       }
    } while (swaps);
    return wbuf;
}

static
short cxmap[] = {
    0x06, 0x1f, 0x4d, 0x0c, 0x5c, 0x28, 0x5d, 0x0e, 0x09, 0x33, 0x31, 0x56,
    0x52, 0x19, 0x29, 0x53, 0x32, 0x48, 0x35, 0x55, 0x5e, 0x14, 0x27, 0x24,
    0x02, 0x3e, 0x18, 0x4a, 0x3f, 0x4c, 0x45, 0x30, 0x08, 0x2c, 0x1a, 0x03,
    0x0b, 0x0d, 0x4f, 0x07, 0x20, 0x1d, 0x51, 0x3b, 0x11, 0x58, 0x00, 0x49,
    0x15, 0x2d, 0x41, 0x17, 0x5f, 0x39, 0x16, 0x42, 0x37, 0x22, 0x1c, 0x0f,
    0x43, 0x5b, 0x46, 0x4b, 0x0a, 0x26, 0x2e, 0x40, 0x12, 0x21, 0x3c, 0x36,
    0x38, 0x1e, 0x01, 0x1b, 0x05, 0x4e, 0x44, 0x3d, 0x04, 0x10, 0x5a, 0x2a,
    0x23, 0x34, 0x25, 0x2f, 0x2b, 0x50, 0x3a, 0x54, 0x47, 0x59, 0x13, 0x57,
   };
#define CXMAP_SIZE (sizeof(cxmap)/sizeof(short))


int Str_Hash( const char *key, int ix_max )
{
   const char *cp;
   short mash;
   int  hash = 33501551;
   for (cp = key; *cp; cp++) {
      mash = cxmap[*cp % CXMAP_SIZE];
      hash = (hash >>4) ^ 0x5C5CF5C ^ ((hash<<1) + (mash<<5));
      hash &= 0x3FFFFFFF;
      }
   return  hash % ix_max;
}

typedef struct sDictWord  *DictWord;
struct sDictWord {
    const char *word;
    DictWord next;
};

typedef struct sHashEntry *HashEntry;
struct sHashEntry {
    const char *key;
    HashEntry next;
    DictWord  words;
    HashEntry link;
    short wordCount;
};

#define HT_SIZE 8192

HashEntry hashTable[HT_SIZE];

HashEntry mostPerms = NULL;

int buildAnagrams( FILE *fin )
{
    char buffer[40];
    char bufr2[40];
    char *hkey;
    int hix;
    HashEntry he, *hep;
    DictWord  we;
    int  maxPC = 2;
    int numWords = 0;

    while ( fgets(buffer, 40, fin)) {
        for(hkey = buffer; *hkey && (*hkey!='\n'); hkey++);
        *hkey = 0;
        hkey = sortedWord(buffer, bufr2);
        hix = Str_Hash(hkey, HT_SIZE);
        he = hashTable[hix]; hep = &hashTable[hix];
        while( he && strcmp(he->key , hkey) ) {
            hep = &he->next;
            he = he->next;
        }
        if ( ! he ) {
            he = malloc(sizeof(struct sHashEntry));
            he->next = NULL;
            he->key = strdup(hkey);
            he->wordCount = 0;
            he->words = NULL;
            he->link = NULL;
            *hep = he;
        }
        we = malloc(sizeof(struct sDictWord));
        we->word = strdup(buffer);
        we->next = he->words;
        he->words = we;
        he->wordCount++;
        if ( maxPC < he->wordCount) {
            maxPC = he->wordCount;
            mostPerms = he;
            he->link = NULL;
        }
        else if (maxPC == he->wordCount) {
            he->link = mostPerms;
            mostPerms = he;
        }

        numWords++;
    }
    printf("%d words in dictionary max ana=%d\n", numWords, maxPC);
    return maxPC;
}


int main( )
{
    HashEntry he;
    DictWord  we;
    FILE *f1;

    f1 = fopen("unixdict.txt","r");
    buildAnagrams(f1);
    fclose(f1);

    f1 = fopen("anaout.txt","w");
//    f1 = stdout;

    for (he = mostPerms; he; he = he->link) {
        fprintf(f1,"%d:", he->wordCount);
        for(we = he->words; we; we = we->next) {
            fprintf(f1,"%s, ", we->word);
        }
        fprintf(f1, "\n");
    }

    fclose(f1);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000382c(void);
int64_t function_1000039dc(void);
int64_t function_100003aa8(void);
int64_t function_100003ed0(int64_t a1);
int64_t function_100003edc(int64_t a1, int64_t a2, int64_t a3);
int32_t function_100003ee8(struct _IO_FILE * stream);
char * function_100003ef4(char * s, int32_t n, struct _IO_FILE * stream);
struct _IO_FILE * function_100003f00(char * filename, char * modes);
int32_t function_100003f0c(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f18(int32_t size);
int32_t function_100003f24(char * format, ...);
int32_t function_100003f30(char * s1, char * s2);
char * function_100003f3c(char * s);
int32_t function_100003f48(char * s);

// --------------------- Global Variables ---------------------

int16_t * g1 = (int16_t *)0xc004d001f0006; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x1000080c0
int64_t g3 = 0x200000000; // 0x1000080c8

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _fclose(struct _IO_FILE * a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000382c - 0x1000039dc
int64_t function_10000382c(void) {
    // 0x10000382c
    int64_t result; // 0x10000382c
    ___strcpy_chk(result, result, -1);
    char * v1 = (char *)result;
    uint64_t v2 = result + (int64_t)_strlen(v1); // 0x100003864
    int64_t v3 = v2 - 1;
    char * v4 = (char *)v3;
    int64_t v5 = result + 1;
    int32_t v6 = 0; // 0x10000389c
    char * v7; // 0x10000382c
    char * v8; // 0x10000382c
    int64_t v9; // 0x10000382c
    int32_t v10; // 0x10000382c
    int32_t v11; // 0x10000382c
    char * v12; // 0x10000382c
    char * v13; // 0x10000382c
    int64_t v14; // 0x10000382c
    int64_t v15; // 0x10000382c
    int32_t v16; // 0x1000038b4
    int64_t v17; // 0x1000038fc
    char v18; // 0x1000038a8
    int32_t v19; // 0x1000038a8
    char v20; // 0x1000038b0
    if (v1 < v4) {
        v18 = *v4;
        v19 = v18;
        v20 = *v1;
        v16 = v19 - (int32_t)v20;
        v11 = 0;
        if (v16 != 0 && v16 < 0 == ((v16 ^ v19) & (int32_t)(v20 ^ v18)) < 0) {
            // 0x1000038c4
            *v4 = v20;
            *v1 = v18;
            v11 = 1;
        }
        // 0x1000038f8
        v17 = v9 + 1;
        v7 = (char *)v17;
        v14 = v3 - 1;
        v12 = (char *)v14;
        v6 = v11;
        v15 = v14;
        v9 = v17;
        v10 = v11;
        while (v7 < v12) {
            // 0x1000038a4
            v8 = v7;
            v13 = v12;
            v18 = *v13;
            v19 = v18;
            v20 = *v8;
            v16 = v19 - (int32_t)v20;
            v11 = v10;
            if (v16 != 0 && v16 < 0 == ((v16 ^ v19) & (int32_t)(v20 ^ v18)) < 0) {
                // 0x1000038c4
                *v13 = v20;
                *v8 = v18;
                v11 = 1;
            }
            // 0x1000038f8
            v17 = v9 + 1;
            v7 = (char *)v17;
            v14 = v15 - 1;
            v12 = (char *)v14;
            v6 = v11;
            v15 = v14;
            v9 = v17;
            v10 = v11;
        }
    }
    int32_t v21 = v6; // 0x10000393c
    int32_t v22 = v6; // 0x10000393c
    char * v23; // 0x10000382c
    int64_t v24; // 0x10000382c
    int32_t v25; // 0x10000382c
    char * v26; // 0x10000382c
    int64_t v27; // 0x10000382c
    int64_t v28; // 0x10000382c
    char v29; // 0x100003948
    int32_t v30; // 0x100003948
    char v31; // 0x100003950
    int32_t v32; // 0x100003954
    if (v2 > v5) {
        v23 = (char *)v24;
        v26 = (char *)v5;
        v29 = *v26;
        v30 = v29;
        v31 = *v23;
        v32 = v30 - (int32_t)v31;
        v25 = v21;
        if (v32 != 0 && v32 < 0 == ((v32 ^ v30) & (int32_t)(v31 ^ v29)) < 0) {
            // 0x100003964
            *v26 = v31;
            *v23 = v29;
            v25 = 1;
        }
        // 0x100003998
        v27 = v5 + 1;
        v28 = v27;
        v24++;
        v21 = v25;
        v22 = v25;
        while (v27 != v2) {
            // 0x100003944
            v23 = (char *)v24;
            v26 = (char *)v28;
            v29 = *v26;
            v30 = v29;
            v31 = *v23;
            v32 = v30 - (int32_t)v31;
            v25 = v21;
            if (v32 != 0 && v32 < 0 == ((v32 ^ v30) & (int32_t)(v31 ^ v29)) < 0) {
                // 0x100003964
                *v26 = v31;
                *v23 = v29;
                v25 = 1;
            }
            // 0x100003998
            v27 = v28 + 1;
            v28 = v27;
            v24++;
            v21 = v25;
            v22 = v25;
        }
    }
    while (v22 != 0) {
        // 0x100003870
        v6 = 0;
        if (v1 < v4) {
            v18 = *v4;
            v19 = v18;
            v20 = *v1;
            v16 = v19 - (int32_t)v20;
            v11 = 0;
            if (v16 != 0 && v16 < 0 == ((v16 ^ v19) & (int32_t)(v20 ^ v18)) < 0) {
                // 0x1000038c4
                *v4 = v20;
                *v1 = v18;
                v11 = 1;
            }
            // 0x1000038f8
            v17 = v9 + 1;
            v7 = (char *)v17;
            v14 = v3 - 1;
            v12 = (char *)v14;
            v6 = v11;
            v15 = v14;
            v9 = v17;
            v10 = v11;
            while (v7 < v12) {
                // 0x1000038a4
                v8 = v7;
                v13 = v12;
                v18 = *v13;
                v19 = v18;
                v20 = *v8;
                v16 = v19 - (int32_t)v20;
                v11 = v10;
                if (v16 != 0 && v16 < 0 == ((v16 ^ v19) & (int32_t)(v20 ^ v18)) < 0) {
                    // 0x1000038c4
                    *v13 = v20;
                    *v8 = v18;
                    v11 = 1;
                }
                // 0x1000038f8
                v17 = v9 + 1;
                v7 = (char *)v17;
                v14 = v15 - 1;
                v12 = (char *)v14;
                v6 = v11;
                v15 = v14;
                v9 = v17;
                v10 = v11;
            }
        }
        // 0x10000392c
        v21 = v6;
        v22 = v6;
        if (v2 > v5) {
            v23 = (char *)v24;
            v26 = (char *)v5;
            v29 = *v26;
            v30 = v29;
            v31 = *v23;
            v32 = v30 - (int32_t)v31;
            v25 = v21;
            if (v32 != 0 && v32 < 0 == ((v32 ^ v30) & (int32_t)(v31 ^ v29)) < 0) {
                // 0x100003964
                *v26 = v31;
                *v23 = v29;
                v25 = 1;
            }
            // 0x100003998
            v27 = v5 + 1;
            v28 = v27;
            v24++;
            v21 = v25;
            v22 = v25;
            while (v27 != v2) {
                // 0x100003944
                v23 = (char *)v24;
                v26 = (char *)v28;
                v29 = *v26;
                v30 = v29;
                v31 = *v23;
                v32 = v30 - (int32_t)v31;
                v25 = v21;
                if (v32 != 0 && v32 < 0 == ((v32 ^ v30) & (int32_t)(v31 ^ v29)) < 0) {
                    // 0x100003964
                    *v26 = v31;
                    *v23 = v29;
                    v25 = 1;
                }
                // 0x100003998
                v27 = v28 + 1;
                v28 = v27;
                v24++;
                v21 = v25;
                v22 = v25;
            }
        }
    }
    // 0x1000039cc
    return result;
}

// Address range: 0x1000039dc - 0x100003aa8
int64_t function_1000039dc(void) {
    // 0x1000039dc
    int64_t v1; // 0x1000039dc
    char v2 = *(char *)v1; // 0x100003a04
    if (v2 == 0) {
        // 0x100003a8c
        return 0x1ff316f % (int32_t)v1;
    }
    uint32_t v3 = 0x1ff316f;
    int16_t v4 = *(int16_t *)(2 * ((int64_t)v2 % 96) + (int64_t)&g1); // 0x100003a3c
    int32_t v5 = v3 / 16 ^ 0x5c5cf5c ^ 32 * (int32_t)v4 + 2 * v3 & 0x3ffffffe; // 0x100003a70
    int64_t v6; // 0x1000039dc
    int64_t v7 = v6 + 1; // 0x100003a80
    char v8 = *(char *)v7; // 0x100003a04
    while (v8 != 0) {
        // 0x100003a18
        v3 = v5;
        v4 = *(int16_t *)(2 * ((int64_t)v8 % 96) + (int64_t)&g1);
        v5 = v3 / 16 ^ 0x5c5cf5c ^ 32 * (int32_t)v4 + 2 * v3 & 0x3ffffffe;
        v7++;
        v8 = *(char *)v7;
    }
    // 0x100003a8c
    return v5 % (int32_t)v1;
}

// Address range: 0x100003aa8 - 0x100003da4
int64_t function_100003aa8(void) {
    // 0x100003aa8
    int64_t v1; // 0x100003aa8
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x100003ac4
    int64_t v3; // bp-64, 0x100003aa8
    char * v4 = _fgets((char *)&v3, 40, v2); // 0x100003ae4
    int32_t result = 2; // 0x100003af0
    if (v4 != NULL) {
        int32_t v5 = 2;
        char v6 = *(char *)&v3; // 0x100003b08
        char v7 = v6; // 0x100003b1c
        char * v8 = (char *)&v3; // 0x100003b1c
        char * v9; // 0x100003aa8
        char * v10; // 0x100003aa8
        char * v11; // 0x100003aa8
        char v12; // 0x100003b08
        if (v6 != 0) {
            v10 = (char *)&v3;
            v8 = v10;
            while (v7 != 10) {
                // 0x100003b4c
                v11 = (char *)((int64_t)v10 + 1);
                v12 = *v11;
                v7 = v12;
                v9 = v11;
                v8 = v11;
                if (v12 == 0) {
                    // break -> 0x100003b5c
                    break;
                }
                v10 = v9;
                v8 = v10;
            }
        }
        // 0x100003b5c
        *v8 = 0;
        char * v13 = (char *)function_10000382c(); // 0x100003b70
        int64_t v14 = function_1000039dc(); // 0x100003b7c
        int64_t * v15 = (int64_t *)((0x100000000 * v14 >> 29) + (int64_t)&g3);
        int64_t v16 = *v15;
        int64_t v17 = v16; // 0x100003bbc
        int64_t * v18 = v15; // 0x100003bbc
        int64_t * v19; // 0x100003aa8
        int16_t * v20; // 0x100003aa8
        int64_t v21; // 0x100003aa8
        int64_t v22; // 0x100003aa8
        int64_t * v23; // 0x100003aa8
        int64_t v24; // 0x100003aa8
        int64_t * v25; // 0x100003c24
        int64_t v26; // 0x100003c24
        int16_t * v27; // 0x100003aa8
        int64_t * v28; // 0x100003aa8
        int64_t v29; // 0x100003bc8
        if (v16 == 0) {
            // 0x100003c20
            v25 = _malloc(40);
            v26 = (int64_t)v25;
            *(int64_t *)(v26 + 8) = 0;
            *v25 = (int64_t)_strdup(v13);
            v27 = (int16_t *)(v26 + 32);
            *v27 = 0;
            v28 = (int64_t *)(v26 + 16);
            *v28 = 0;
            *(int64_t *)(v26 + 24) = 0;
            *v18 = v26;
            v20 = v27;
            v19 = v28;
            v24 = v26;
        } else {
            v22 = v17;
            v29 = *(int64_t *)v22;
            while (_strcmp((char *)v29, v13) != 0) {
                // 0x100003bf0
                v23 = (int64_t *)(v22 + 8);
                v21 = *v23;
                v18 = v23;
                if (v21 == 0) {
                    goto lab_0x100003c20;
                }
                v22 = v21;
                v29 = *(int64_t *)v22;
            }
            // 0x100003c6c
            v20 = (int16_t *)(v22 + 32);
            v19 = (int64_t *)(v22 + 16);
            v24 = v22;
        }
        int64_t v30 = v24;
        int64_t * v31 = _malloc(16); // 0x100003c70
        int64_t v32 = (int64_t)v31; // 0x100003c70
        *v31 = (int64_t)_strdup((char *)&v3);
        *(int64_t *)(v32 + 8) = *v19;
        *v19 = v32;
        int16_t v33 = *v20 + 1; // 0x100003cac
        *v20 = v33;
        int32_t v34 = v33; // 0x100003cbc
        int32_t v35 = v5 - v34; // 0x100003cc0
        int32_t v36; // 0x100003aa8
        if (v35 < 0 == ((v35 ^ v5) & (v5 ^ v34)) < 0) {
            // 0x100003cf4
            v36 = v5;
            if (v5 == v34) {
                // 0x100003d10
                *(int64_t *)(v30 + 24) = g2;
                g2 = v30;
                v36 = v5;
            }
        } else {
            // 0x100003cd0
            g2 = v30;
            *(int64_t *)(v30 + 24) = 0;
            v36 = v34;
        }
        int32_t v37 = v36;
        char * v38 = _fgets((char *)&v3, 40, v2); // 0x100003ae4
        result = v37;
        while (v38 != NULL) {
            // 0x100003b04
            v5 = v37;
            v6 = *(char *)&v3;
            v7 = v6;
            v8 = (char *)&v3;
            if (v6 != 0) {
                v10 = (char *)&v3;
                v8 = v10;
                while (v7 != 10) {
                    // 0x100003b4c
                    v11 = (char *)((int64_t)v10 + 1);
                    v12 = *v11;
                    v7 = v12;
                    v9 = v11;
                    v8 = v11;
                    if (v12 == 0) {
                        // break -> 0x100003b5c
                        break;
                    }
                    v10 = v9;
                    v8 = v10;
                }
            }
            // 0x100003b5c
            *v8 = 0;
            v13 = (char *)function_10000382c();
            v14 = function_1000039dc();
            v15 = (int64_t *)((0x100000000 * v14 >> 29) + (int64_t)&g3);
            v16 = *v15;
            v17 = v16;
            v18 = v15;
            if (v16 == 0) {
                // 0x100003c20
                v25 = _malloc(40);
                v26 = (int64_t)v25;
                *(int64_t *)(v26 + 8) = 0;
                *v25 = (int64_t)_strdup(v13);
                v27 = (int16_t *)(v26 + 32);
                *v27 = 0;
                v28 = (int64_t *)(v26 + 16);
                *v28 = 0;
                *(int64_t *)(v26 + 24) = 0;
                *v18 = v26;
                v20 = v27;
                v19 = v28;
                v24 = v26;
            } else {
                v22 = v17;
                v29 = *(int64_t *)v22;
                while (_strcmp((char *)v29, v13) != 0) {
                    // 0x100003bf0
                    v23 = (int64_t *)(v22 + 8);
                    v21 = *v23;
                    v18 = v23;
                    if (v21 == 0) {
                        goto lab_0x100003c20;
                    }
                    v22 = v21;
                    v29 = *(int64_t *)v22;
                }
                // 0x100003c6c
                v20 = (int16_t *)(v22 + 32);
                v19 = (int64_t *)(v22 + 16);
                v24 = v22;
            }
            // 0x100003c6c
            v30 = v24;
            v31 = _malloc(16);
            v32 = (int64_t)v31;
            *v31 = (int64_t)_strdup((char *)&v3);
            *(int64_t *)(v32 + 8) = *v19;
            *v19 = v32;
            v33 = *v20 + 1;
            *v20 = v33;
            v34 = v33;
            v35 = v5 - v34;
            if (v35 < 0 == ((v35 ^ v5) & (v5 ^ v34)) < 0) {
                // 0x100003cf4
                v36 = v5;
                if (v5 == v34) {
                    // 0x100003d10
                    *(int64_t *)(v30 + 24) = g2;
                    g2 = v30;
                    v36 = v5;
                }
            } else {
                // 0x100003cd0
                g2 = v30;
                *(int64_t *)(v30 + 24) = 0;
                v36 = v34;
            }
            // 0x100003d30
            v37 = v36;
            v38 = _fgets((char *)&v3, 40, v2);
            result = v37;
        }
    }
    int32_t v39 = _printf("%d words in dictionary max ana=%d\n", 40, v1); // 0x100003d64
    int64_t v40 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003d7c
    if (v40 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003d90
        ___stack_chk_fail((int64_t)v39);
    }
    // 0x100003d94
    return result;
}

// Address range: 0x100003da4 - 0x100003ed0
int64_t entry_point(void) {
    struct _IO_FILE * v1 = _fopen("unixdict.txt", "r"); // 0x100003dc4
    function_100003aa8();
    _fclose(v1);
    struct _IO_FILE * v2 = _fopen("anaout.txt", "w"); // 0x100003dec
    if (g2 == 0) {
        // 0x100003eb8
        _fclose(v2);
        return 0;
    }
    int64_t v3 = g2;
    int64_t v4; // 0x100003da4
    _fprintf(v2, "%d:", v4);
    int64_t v5 = *(int64_t *)(v3 + 16);
    int64_t v6 = v5; // 0x100003e58
    int64_t v7; // 0x100003da4
    if (v5 != 0) {
        _fprintf(v2, "%s, ", (char *)v4);
        v7 = *(int64_t *)(v6 + 8);
        v6 = v7;
        while (v7 != 0) {
            // 0x100003e60
            _fprintf(v2, "%s, ", (char *)v4);
            v7 = *(int64_t *)(v6 + 8);
            v6 = v7;
        }
    }
    // 0x100003e94
    _fprintf(v2, (char *)0x100003f9c);
    v3 += 24;
    while (v3 != 0) {
        // 0x100003e18
        _fprintf(v2, "%d:", v4);
        v5 = *(int64_t *)(v3 + 16);
        v6 = v5;
        if (v5 != 0) {
            _fprintf(v2, "%s, ", (char *)v4);
            v7 = *(int64_t *)(v6 + 8);
            v6 = v7;
            while (v7 != 0) {
                // 0x100003e60
                _fprintf(v2, "%s, ", (char *)v4);
                v7 = *(int64_t *)(v6 + 8);
                v6 = v7;
            }
        }
        // 0x100003e94
        _fprintf(v2, (char *)0x100003f9c);
        v3 += 24;
    }
    // 0x100003eb8
    _fclose(v2);
    return 0;
}

// Address range: 0x100003ed0 - 0x100003edc
int64_t function_100003ed0(int64_t a1) {
    // 0x100003ed0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003edc - 0x100003ee8
int64_t function_100003edc(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003edc
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(struct _IO_FILE * stream) {
    // 0x100003ee8
    return _fclose(stream);
}

// Address range: 0x100003ef4 - 0x100003f00
char * function_100003ef4(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003ef4
    return _fgets(s, n, stream);
}

// Address range: 0x100003f00 - 0x100003f0c
struct _IO_FILE * function_100003f00(char * filename, char * modes) {
    // 0x100003f00
    return _fopen(filename, modes);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f0c
    return _fprintf(stream, format);
}

// Address range: 0x100003f18 - 0x100003f24
int64_t * function_100003f18(int32_t size) {
    // 0x100003f18
    return _malloc(size);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * s1, char * s2) {
    // 0x100003f30
    return _strcmp(s1, s2);
}

// Address range: 0x100003f3c - 0x100003f48
char * function_100003f3c(char * s) {
    // 0x100003f3c
    return _strdup(s);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * s) {
    // 0x100003f48
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`#include <stdio.h>
#include <stdlib.h>

void bead_sort(int *a, int len)
{
	int i, j, max, sum;
	unsigned char *beads;
#	define BEAD(i, j) beads[i * max + j]

	for (i = 1, max = a[0]; i < len; i++)
		if (a[i] > max) max = a[i];

	beads = calloc(1, max * len);

	/* mark the beads */
	for (i = 0; i < len; i++)
		for (j = 0; j < a[i]; j++)
			BEAD(i, j) = 1;

	for (j = 0; j < max; j++) {
		/* count how many beads are on each post */
		for (sum = i = 0; i < len; i++) {
			sum += BEAD(i, j);
			BEAD(i, j) = 0;
		}
		/* mark bottom sum beads */
		for (i = len - sum; i < len; i++) BEAD(i, j) = 1;
	}

	for (i = 0; i < len; i++) {
		for (j = 0; j < max && BEAD(i, j); j++);
		a[i] = j;
	}
	free(beads);
}

int main()
{
	int i, x[] = {5, 3, 1, 7, 4, 1, 1, 20};
	int len = sizeof(x)/sizeof(x[0]);

	bead_sort(x, len);
	for (i = 0; i < len; i++)
		printf("%d\n", x[i]);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b58(void);
int64_t function_100003f54(int64_t a1);
int64_t * function_100003f60(int32_t nmemb, int32_t size);
void function_100003f6c(int64_t * ptr);
int32_t function_100003f78(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b58 - 0x100003e7c
int64_t function_100003b58(void) {
    // 0x100003b58
    int64_t v1; // 0x100003b58
    int32_t v2 = v1; // 0x100003b68
    int32_t v3 = v1;
    int32_t v4 = 1 - v2; // 0x100003b8c
    int32_t v5 = 1; // 0x100003b94
    int32_t v6 = v3; // 0x100003b94
    if (v4 < 0 != (v4 & v2) < 0) {
        int32_t v7 = v3;
        int32_t v8 = *(int32_t *)(4 * (int64_t)v5 + v1); // 0x100003ba4
        int32_t v9 = v8 - v7; // 0x100003bac
        int32_t v10 = v9 == 0 | v9 < 0 != ((v9 ^ v8) & (v8 ^ v7)) < 0 ? v7 : v8;
        v5++;
        int32_t v11 = v5 - v2; // 0x100003b8c
        v6 = v10;
        while (v11 < 0 != ((v11 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003b9c
            v7 = v10;
            v8 = *(int32_t *)(4 * (int64_t)v5 + v1);
            v9 = v8 - v7;
            v10 = v9 == 0 | v9 < 0 != ((v9 ^ v8) & (v8 ^ v7)) < 0 ? v7 : v8;
            v5++;
            v11 = v5 - v2;
            v6 = v10;
        }
    }
    int64_t * v12 = _calloc(1, v6 * v2); // 0x100003bfc
    int64_t v13 = (int64_t)v12; // 0x100003bfc
    int32_t v14 = -v2;
    if (v14 < 0 != (v14 & v2) < 0) {
        int32_t v15 = 0;
        int32_t * v16 = (int32_t *)(4 * (int64_t)v15 + v1); // 0x100003c38
        int32_t v17 = *v16; // 0x100003c38
        int32_t v18 = -v17; // 0x100003c3c
        int32_t v19; // 0x100003c58
        int32_t v20; // 0x100003c78
        int32_t v21; // 0x100003c38
        if (v18 < 0 != (v17 & v18) < 0) {
            // 0x100003c4c
            v19 = v15 * v6;
            v20 = 0;
            *(char *)((int64_t)(v20 + v19) + v13) = 1;
            v20++;
            v21 = *v16;
            while (v20 - v21 < 0 != ((v20 - v21 ^ v20) & (v21 ^ v20)) < 0) {
                // 0x100003c4c
                *(char *)((int64_t)(v20 + v19) + v13) = 1;
                v20++;
                v21 = *v16;
            }
        }
        int32_t v22 = v15 + 1; // 0x100003c8c
        while (v22 - v2 < 0 != ((v22 - v2 ^ v22) & (v22 ^ v2)) < 0) {
            // 0x100003c2c
            v15 = v22;
            v16 = (int32_t *)(4 * (int64_t)v15 + v1);
            v17 = *v16;
            v18 = -v17;
            if (v18 < 0 != (v17 & v18) < 0) {
                // 0x100003c4c
                v19 = v15 * v6;
                v20 = 0;
                *(char *)((int64_t)(v20 + v19) + v13) = 1;
                v20++;
                v21 = *v16;
                while (v20 - v21 < 0 != ((v20 - v21 ^ v20) & (v21 ^ v20)) < 0) {
                    // 0x100003c4c
                    *(char *)((int64_t)(v20 + v19) + v13) = 1;
                    v20++;
                    v21 = *v16;
                }
            }
            // 0x100003c88
            v22 = v15 + 1;
        }
    }
    int32_t v23 = -v6;
    if (v23 < 0 != (v6 & v23) < 0) {
        int32_t v24 = 0;
        int32_t v25 = 0; // 0x100003cd4
        int32_t v26 = 0; // 0x100003cd4
        int32_t v27; // 0x100003b58
        int32_t v28; // 0x100003cf0
        unsigned char v29; // 0x100003cf4
        int32_t v30; // 0x100003cfc
        int32_t v31; // 0x100003d2c
        int32_t v32; // 0x100003ccc
        if (v14 < 0 != (v14 & v2) < 0) {
            v28 = v25 * v6 + v24;
            v30 = (int32_t)*(char *)((int64_t)v28 + v13);
            *(char *)((int64_t)v28 + v13) = 0;
            v31 = v25 + 1;
            v32 = v31 - v2;
            v27 = v30;
            v25 = v31;
            v26 = v30;
            while (v32 < 0 != ((v32 ^ v31) & (v31 ^ v2)) < 0) {
                // 0x100003cdc
                v28 = v25 * v6 + v24;
                v29 = *(char *)((int64_t)v28 + v13);
                v30 = v27 + (int32_t)v29;
                *(char *)((int64_t)v28 + v13) = 0;
                v31 = v25 + 1;
                v32 = v31 - v2;
                v27 = v30;
                v25 = v31;
                v26 = v30;
            }
        }
        int32_t v33 = v2 - v26; // 0x100003d40
        int32_t v34 = -v26; // 0x100003d54
        int32_t v35 = v33; // 0x100003d5c
        int32_t v36; // 0x100003d90
        int32_t v37; // 0x100003d54
        if (v34 < 0 != ((v33 ^ v34) & (v33 ^ v2)) < 0) {
            *(char *)((int64_t)(v35 * v6 + v24) + v13) = 1;
            v36 = v35 + 1;
            v37 = v36 - v2;
            v35 = v36;
            while (v37 < 0 != ((v37 ^ v36) & (v36 ^ v2)) < 0) {
                // 0x100003d64
                *(char *)((int64_t)(v35 * v6 + v24) + v13) = 1;
                v36 = v35 + 1;
                v37 = v36 - v2;
                v35 = v36;
            }
        }
        int32_t v38 = v24 + 1; // 0x100003da4
        while (v38 - v6 < 0 != ((v38 - v6 ^ v38) & (v38 ^ v6)) < 0) {
            // 0x100003cc4
            v24 = v38;
            v25 = 0;
            v26 = 0;
            if (v14 < 0 != (v14 & v2) < 0) {
                v28 = v25 * v6 + v24;
                v30 = (int32_t)*(char *)((int64_t)v28 + v13);
                *(char *)((int64_t)v28 + v13) = 0;
                v31 = v25 + 1;
                v32 = v31 - v2;
                v27 = v30;
                v25 = v31;
                v26 = v30;
                while (v32 < 0 != ((v32 ^ v31) & (v31 ^ v2)) < 0) {
                    // 0x100003cdc
                    v28 = v25 * v6 + v24;
                    v29 = *(char *)((int64_t)v28 + v13);
                    v30 = v27 + (int32_t)v29;
                    *(char *)((int64_t)v28 + v13) = 0;
                    v31 = v25 + 1;
                    v32 = v31 - v2;
                    v27 = v30;
                    v25 = v31;
                    v26 = v30;
                }
            }
            // 0x100003d38
            v33 = v2 - v26;
            v34 = -v26;
            v35 = v33;
            if (v34 < 0 != ((v33 ^ v34) & (v33 ^ v2)) < 0) {
                *(char *)((int64_t)(v35 * v6 + v24) + v13) = 1;
                v36 = v35 + 1;
                v37 = v36 - v2;
                v35 = v36;
                while (v37 < 0 != ((v37 ^ v36) & (v36 ^ v2)) < 0) {
                    // 0x100003d64
                    *(char *)((int64_t)(v35 * v6 + v24) + v13) = 1;
                    v36 = v35 + 1;
                    v37 = v36 - v2;
                    v35 = v36;
                }
            }
            // 0x100003da0
            v38 = v24 + 1;
        }
    }
    int32_t v39 = 0; // 0x100003dc8
    if (v14 < 0 == (v14 & v2) < 0) {
        // 0x100003e68
        _free(v12);
        return &g1;
    }
    int32_t v40 = v39 * v6;
    int32_t v41 = 0; // 0x100003df0
    int32_t v42; // 0x100003b58
    int32_t v43; // 0x100003b58
    int32_t v44; // 0x100003e38
    int32_t v45; // 0x100003de0
    if (v23 < 0 != (v6 & v23) < 0) {
        v43 = 0;
        v41 = v43;
        while (*(char *)((int64_t)(v43 + v40) + v13) != 0) {
            // 0x100003e34
            v44 = v43 + 1;
            v45 = v44 - v6;
            v42 = v44;
            v41 = v44;
            if (v45 < 0 == ((v45 ^ v44) & (v44 ^ v6)) < 0) {
                // break -> 0x100003e44
                break;
            }
            v43 = v42;
            v41 = v43;
        }
    }
    // 0x100003e44
    *(int32_t *)(4 * (int64_t)v39 + v1) = v41;
    v39++;
    while (v39 - v2 < 0 != ((v39 - v2 ^ v39) & (v39 ^ v2)) < 0) {
        // 0x100003dd8
        v40 = v39 * v6;
        v41 = 0;
        if (v23 < 0 != (v6 & v23) < 0) {
            v43 = 0;
            v41 = v43;
            while (*(char *)((int64_t)(v43 + v40) + v13) != 0) {
                // 0x100003e34
                v44 = v43 + 1;
                v45 = v44 - v6;
                v42 = v44;
                v41 = v44;
                if (v45 < 0 == ((v45 ^ v44) & (v44 ^ v6)) < 0) {
                    // break -> 0x100003e44
                    break;
                }
                v43 = v42;
                v41 = v43;
            }
        }
        // 0x100003e44
        *(int32_t *)(4 * (int64_t)v39 + v1) = v41;
        v39++;
    }
    // 0x100003e68
    _free(v12);
    return &g1;
}

// Address range: 0x100003e7c - 0x100003f54
int64_t entry_point(void) {
    // 0x100003e7c
    function_100003b58();
    int32_t v1; // 0x100003f08
    for (int32_t i = 0; i < 8; i++) {
        // 0x100003ee8
        v1 = _printf("%d\n", 8);
    }
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f2c
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f40
        ___stack_chk_fail((int64_t)v1);
    }
    // 0x100003f44
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
int64_t function_100003f54(int64_t a1) {
    // 0x100003f54
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f60 - 0x100003f6c
int64_t * function_100003f60(int32_t nmemb, int32_t size) {
    // 0x100003f60
    return _calloc(nmemb, size);
}

// Address range: 0x100003f6c - 0x100003f78
void function_100003f6c(int64_t * ptr) {
    // 0x100003f6c
    _free(ptr);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

typedef struct node_t *node, node_t;
struct node_t { int v; node next; };
typedef struct { node head, tail; } slist;

void push(slist *l, node e) {
	if (!l->head) l->head = e;
	if (l->tail)  l->tail->next = e;
	l->tail = e;
}

node removehead(slist *l) {
	node e = l->head;
	if (e) {
		l->head = e->next;
		e->next = 0;
	}
	return e;
}

void join(slist *a, slist *b) {
	push(a, b->head);
	a->tail = b->tail;
}

void merge(slist *a, slist *b) {
	slist r = {0};
	while (a->head && b->head)
		push(&r, removehead(a->head->v <= b->head->v ? a : b));

	join(&r, a->head ? a : b);
	*a = r;
	b->head = b->tail = 0;
}

void sort(int *ar, int len)
{
	node_t all[len];

	// array to list
	for (int i = 0; i < len; i++)
		all[i].v = ar[i], all[i].next = i < len - 1 ? all + i + 1 : 0;

	slist list = {all, all + len - 1}, rem, strand = {0},  res = {0};

	for (node e = 0; list.head; list = rem) {
		rem.head = rem.tail = 0;
		while ((e = removehead(&list)))
			push((!strand.head || e->v >= strand.tail->v) ? &strand : &rem, e);

		merge(&res, &strand);
	}

	// list to array
	for (int i = 0; res.head; i++, res.head = res.head->next)
		ar[i] = res.head->v;
}

void show(const char *title, int *x, int len)
{
	printf("%s ", title);
	for (int i = 0; i < len; i++)
		printf("%3d ", x[i]);
	putchar('\n');
}

int main(void)
{
	int x[] = {-2,0,-2,5,5,3,-1,-3,5,5,0,2,-4,4,2};
#	define SIZE sizeof(x)/sizeof(int)

	show("before sort:", x, SIZE);
	sort(x, sizeof(x)/sizeof(int));
	show("after sort: ", x, SIZE);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003928(void);
int64_t function_10000399c(void);
int64_t function_1000039ec(int64_t * a1, int64_t a2);
int64_t function_100003a2c(void);
int64_t function_100003b4c(int64_t a1, int32_t a2);
int64_t function_100003b98(void);
int64_t function_100003dd0(void);
int64_t function_100003f10(int64_t a1);
int64_t * function_100003f1c(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f28(char * format, ...);
int32_t function_100003f34(int32_t c);

// --------------------- Global Variables ---------------------

int64_t g1 = 0xfffffffe; // 0x100003f64

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003928 - 0x10000399c
int64_t function_100003928(void) {
    // 0x100003928
    int64_t result; // 0x100003928
    if (result == 0) {
        // 0x10000394c
        abort();
        // UNREACHABLE
    }
    // 0x10000395c
    if (*(int64_t *)(result + 8) != 0) {
        // branch -> 0x100003988
    }
    // 0x100003988
    return result;
}

// Address range: 0x10000399c - 0x1000039ec
int64_t function_10000399c(void) {
    // 0x10000399c
    int64_t result; // 0x10000399c
    if (result != 0) {
        int64_t * v1 = (int64_t *)(result + 8); // 0x1000039c8
        *(int64_t *)result = *v1;
        *v1 = 0;
    }
    // 0x1000039e0
    return result;
}

// Address range: 0x1000039ec - 0x100003a2c
int64_t function_1000039ec(int64_t * a1, int64_t a2) {
    int64_t result = function_100003928(); // 0x100003a0c
    *(int64_t *)((int64_t)a1 + 8) = *(int64_t *)(a2 + 8);
    return result;
}

// Address range: 0x100003a2c - 0x100003b4c
int64_t function_100003a2c(void) {
    float128_t v1 = 0.0L; // bp-48, 0x100003a40
    int64_t v2; // 0x100003a2c
    if (v2 != 0) {
        int64_t v3; // 0x100003a2c
        while (v3 != 0) {
            // 0x100003a90
            v3 = function_10000399c();
            if (function_100003928() == 0) {
                // break -> 0x100003ae8
                break;
            }
        }
    }
    // 0x100003ae8
    int64_t v4; // 0x100003a2c
    int64_t result = function_1000039ec((int64_t *)&v1, v4); // 0x100003b20
    *(float128_t *)v2 = v1;
    *(int64_t *)(v2 + 8) = 0;
    *(int64_t *)v2 = 0;
    return result;
}

// Address range: 0x100003b4c - 0x100003b98
int64_t function_100003b4c(int64_t a1, int32_t a2) {
    // 0x100003b4c
    return ___chkstk_darwin();
}

// Address range: 0x100003b98 - 0x100003dd0
int64_t function_100003b98(void) {
    // 0x100003b98
    int64_t v1; // 0x100003b98
    int64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 - 136); // 0x100003ba8
    int64_t v4; // 0x100003b98
    *v3 = (int64_t)&v4 - *(int64_t *)(v2 - 144);
    int32_t * v5 = (int32_t *)(v2 - 44); // 0x100003bb0
    *v5 = 0;
    int32_t * v6 = (int32_t *)(v2 - 20); // 0x100003bbc
    int32_t v7 = *v6; // 0x100003bbc
    int32_t v8 = -v7; // 0x100003bc0
    int64_t v9 = *v3;
    int64_t v10 = v9; // 0x100003bc8
    if (v8 < 0 != (v7 & v8) < 0) {
        int64_t v11 = *(int64_t *)(v2 - 16); // 0x100003bd4
        int64_t v12 = 0; // 0x100003bd8
        *(int32_t *)(16 * v12 + v9) = *(int32_t *)(4 * v12 + v11);
        int32_t v13 = *v5; // 0x100003bec
        int32_t v14 = *v6 - 1; // 0x100003bf4
        int32_t v15 = v13 - v14; // 0x100003bf8
        int64_t v16 = 0; // 0x100003c00
        if (v15 < 0 != ((v15 ^ v13) & (v14 ^ v13)) < 0) {
            // 0x100003c08
            v16 = 16 * (int64_t)v13 + 16 + *v3;
        }
        // 0x100003c2c
        *(int64_t *)(v2 - 152) = v16;
        *(int64_t *)(*v3 + 8 + 16 * (int64_t)*v5) = v16;
        int32_t v17 = *v5 + 1; // 0x100003c48
        *v5 = v17;
        int32_t v18 = *v6; // 0x100003bbc
        int32_t v19 = v17 - v18; // 0x100003bc0
        int64_t v20 = *v3;
        v10 = v20;
        while (v19 < 0 != ((v19 ^ v17) & (v18 ^ v17)) < 0) {
            // 0x100003bd0
            v11 = *(int64_t *)(v2 - 16);
            v12 = v17;
            *(int32_t *)(16 * v12 + v20) = *(int32_t *)(4 * v12 + v11);
            v13 = *v5;
            v14 = *v6 - 1;
            v15 = v13 - v14;
            v16 = 0;
            if (v15 < 0 != ((v15 ^ v13) & (v14 ^ v13)) < 0) {
                // 0x100003c08
                v16 = 16 * (int64_t)v13 + 16 + *v3;
            }
            // 0x100003c2c
            *(int64_t *)(v2 - 152) = v16;
            *(int64_t *)(*v3 + 8 + 16 * (int64_t)*v5) = v16;
            v17 = *v5 + 1;
            *v5 = v17;
            v18 = *v6;
            v19 = v17 - v18;
            v20 = *v3;
            v10 = v20;
        }
    }
    int64_t v21 = v2 - 64; // 0x100003c5c
    int64_t * v22 = (int64_t *)v21; // 0x100003c5c
    *v22 = v10;
    *(int64_t *)(v2 - 56) = v10 - 16 + 16 * (int64_t)*v6;
    int64_t v23 = v2 - 96; // 0x100003c70
    int64_t * v24 = (int64_t *)v23; // 0x100003c70
    *v24 = 0;
    int64_t * v25 = (int64_t *)(v2 - 88); // 0x100003c74
    *v25 = 0;
    int64_t * v26 = (int64_t *)(v2 - 112); // 0x100003c78
    *v26 = 0;
    *(int64_t *)(v2 - 104) = 0;
    int64_t * v27 = (int64_t *)(v2 - 120); // 0x100003c80
    *v27 = 0;
    int64_t v28; // 0x100003b98
    if (*v22 != 0) {
        int64_t v29 = v2 - 80; // 0x100003ca0
        *(int64_t *)(v2 - 72) = 0;
        *(int64_t *)v29 = 0;
        int64_t v30 = function_10000399c(); // 0x100003cac
        *v27 = v30;
        int64_t v31 = v30; // 0x100003cc0
        int64_t v32; // 0x100003b98
        int64_t v33; // 0x100003cac
        int32_t v34; // 0x100003ce0
        int32_t v35; // 0x100003ce8
        int32_t v36; // 0x100003cec
        if (v30 != 0) {
            v32 = v23;
            if (*v24 != 0) {
                // 0x100003cdc
                v34 = *(int32_t *)v31;
                v35 = *(int32_t *)*v25;
                v36 = v34 - v35;
                v32 = v36 < 0 == ((v36 ^ v34) & (v35 ^ v34)) < 0 ? v23 : v29;
            }
            // 0x100003d14
            *(int64_t *)(v2 - 160) = v32;
            function_100003928();
            v33 = function_10000399c();
            *v27 = v33;
            while (v33 != 0) {
                // 0x100003cc8
                v32 = v23;
                if (*v24 != 0) {
                    // 0x100003cdc
                    v34 = *(int32_t *)v33;
                    v35 = *(int32_t *)*v25;
                    v36 = v34 - v35;
                    v32 = v36 < 0 == ((v36 ^ v34) & (v35 ^ v34)) < 0 ? v23 : v29;
                }
                // 0x100003d14
                *(int64_t *)(v2 - 160) = v32;
                function_100003928();
                v33 = function_10000399c();
                *v27 = v33;
            }
        }
        int64_t v37 = function_100003a2c(); // 0x100003d2c
        *(float128_t *)v21 = *(float128_t *)v29;
        v28 = v37;
        while (*v22 != 0) {
            // 0x100003c9c
            *(int64_t *)(v2 - 72) = 0;
            *(int64_t *)v29 = 0;
            v30 = function_10000399c();
            *v27 = v30;
            v31 = v30;
            if (v30 != 0) {
                v32 = v23;
                if (*v24 != 0) {
                    // 0x100003cdc
                    v34 = *(int32_t *)v31;
                    v35 = *(int32_t *)*v25;
                    v36 = v34 - v35;
                    v32 = v36 < 0 == ((v36 ^ v34) & (v35 ^ v34)) < 0 ? v23 : v29;
                }
                // 0x100003d14
                *(int64_t *)(v2 - 160) = v32;
                function_100003928();
                v33 = function_10000399c();
                *v27 = v33;
                while (v33 != 0) {
                    // 0x100003cc8
                    v32 = v23;
                    if (*v24 != 0) {
                        // 0x100003cdc
                        v34 = *(int32_t *)v33;
                        v35 = *(int32_t *)*v25;
                        v36 = v34 - v35;
                        v32 = v36 < 0 == ((v36 ^ v34) & (v35 ^ v34)) < 0 ? v23 : v29;
                    }
                    // 0x100003d14
                    *(int64_t *)(v2 - 160) = v32;
                    function_100003928();
                    v33 = function_10000399c();
                    *v27 = v33;
                }
            }
            // 0x100003d24
            v37 = function_100003a2c();
            *(float128_t *)v21 = *(float128_t *)v29;
            v28 = v37;
        }
    }
    int32_t * v38 = (int32_t *)(v2 - 124); // 0x100003d40
    *v38 = 0;
    int64_t v39 = *v26;
    if (v39 != 0) {
        int64_t * v40 = (int64_t *)(v2 - 16); // 0x100003d64
        *(int32_t *)*v40 = *(int32_t *)v39;
        *v38 = *v38 + 1;
        int64_t v41 = *(int64_t *)(*v26 + 8); // 0x100003d84
        *v26 = v41;
        if (v41 != 0) {
            *(int32_t *)(*v40 + 4 * (int64_t)*v38) = *(int32_t *)v41;
            *v38 = *v38 + 1;
            int64_t v42 = *(int64_t *)(*v26 + 8); // 0x100003d84
            *v26 = v42;
            while (v42 != 0) {
                // 0x100003d5c
                *(int32_t *)(*v40 + 4 * (int64_t)*v38) = *(int32_t *)v42;
                *v38 = *v38 + 1;
                v42 = *(int64_t *)(*v26 + 8);
                *v26 = v42;
            }
        }
    }
    // 0x100003d90
    *(int64_t *)(v2 - 168) = *(int64_t *)(v2 - 32);
    int64_t result = v28; // 0x100003db0
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003db8
        result = ___stack_chk_fail(v28);
    }
    // 0x100003dbc
    return result;
}

// Address range: 0x100003dd0 - 0x100003e6c
int64_t function_100003dd0(void) {
    // 0x100003dd0
    int64_t v1; // 0x100003dd0
    int32_t v2 = v1; // 0x100003de4
    _printf("%s ", (char *)v1);
    int32_t v3 = -v2; // 0x100003e10
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e58
        return _putchar(10);
    }
    int32_t v4 = 0; // 0x100003e18
    _printf("%3d ", v1);
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003e20
        _printf("%3d ", v1);
        v4++;
    }
    // 0x100003e58
    return _putchar(10);
}

// Address range: 0x100003e6c - 0x100003f10
int64_t entry_point(void) {
    // 0x100003e6c
    int64_t v1; // bp-84, 0x100003e6c
    _memcpy(&v1, &g1, 60);
    function_100003dd0();
    function_100003b4c((int64_t)&v1, 15);
    int64_t v2 = function_100003dd0(); // 0x100003ed8
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003ee8
    if (v3 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003efc
        ___stack_chk_fail(v2);
    }
    // 0x100003f00
    return 0;
}

// Address range: 0x100003f10 - 0x100003f1c
int64_t function_100003f10(int64_t a1) {
    // 0x100003f10
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f1c - 0x100003f28
int64_t * function_100003f1c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f1c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(char * format, ...) {
    // 0x100003f28
    return _printf(format);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(int32_t c) {
    // 0x100003f34
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>

typedef unsigned long long ull;

ull binomial(ull m, ull n)
{
	ull r = 1, d = m - n;
	if (d > n) { n = d; d = m - n; }

	while (m > n) {
		r *= m--;
		while (d > 1 && ! (r%d) ) r /= d--;
	}

	return r;
}

ull catalan1(int n) {
	return binomial(2 * n, n) / (1 + n);
}

ull catalan2(int n) {
	int i;
	ull r = !n;

	for (i = 0; i < n; i++)
		r += catalan2(i) * catalan2(n - 1 - i);
	return r;
}

ull catalan3(int n)
{
	return n ? 2 * (2 * n - 1) * catalan3(n - 1) / (1 + n) : 1;
}

int main(void)
{
	int i;
	puts("\tdirect\tsumming\tfrac");
	for (i = 0; i < 16; i++) {
		printf("%d\t%llu\t%llu\t%llu\n", i,
			catalan1(i), catalan2(i), catalan3(i));
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c24(void);
int64_t function_100003d2c(int32_t a1);
int64_t function_100003d78(void);
int64_t function_100003e1c(void);
int32_t function_100003f60(char * format, ...);
int32_t function_100003f6c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c24 - 0x100003d2c
int64_t function_100003c24(void) {
    // 0x100003c24
    int64_t v1; // 0x100003c24
    uint64_t v2 = v1;
    uint64_t v3 = v1;
    uint64_t v4 = v3 - v2; // 0x100003c40
    bool v5 = v4 == v2 | v4 < v2; // 0x100003c54
    uint64_t v6 = v5 ? v2 : v4;
    if (v3 == v6 || v3 < v6) {
        // 0x100003d20
        return 1;
    }
    int64_t v7 = v5 ? v4 : v2;
    int64_t v8; // 0x100003c24
    int64_t v9 = v8; // 0x100003ca8
    int64_t v10 = v7; // 0x100003cc8
    int64_t v11 = v9; // 0x100003cc8
    int64_t v12 = v9; // 0x100003cc8
    int64_t v13 = v7; // 0x100003cc8
    uint64_t v14; // 0x100003c24
    uint64_t v15; // 0x100003c24
    int64_t v16; // 0x100003d04
    int64_t v17; // 0x100003d10
    if (v7 != 1 && v7 != 0) {
        v14 = v13;
        v15 = v12;
        v10 = v14;
        v11 = v15;
        while (v15 % v14 == 0) {
            // 0x100003d00
            v16 = v14 - 1;
            v17 = v15 / v14;
            v10 = 1;
            v11 = v17;
            v12 = v17;
            v13 = v16;
            if (v16 == 1) {
                // break -> 0x100003c80
                break;
            }
            v14 = v13;
            v15 = v12;
            v10 = v14;
            v11 = v15;
        }
    }
    int64_t result = v11;
    int64_t v18 = v8 - 1; // 0x100003c9c
    while (v18 != v6 && v18 >= v6) {
        // 0x100003c98
        v7 = v10;
        v9 = result * v18;
        v10 = v7;
        v11 = v9;
        v12 = v9;
        v13 = v7;
        if (v7 != 1 && v7 != 0) {
            v14 = v13;
            v15 = v12;
            v10 = v14;
            v11 = v15;
            while (v15 % v14 == 0) {
                // 0x100003d00
                v16 = v14 - 1;
                v17 = v15 / v14;
                v10 = 1;
                v11 = v17;
                v12 = v17;
                v13 = v16;
                if (v16 == 1) {
                    // break -> 0x100003c80
                    break;
                }
                v14 = v13;
                v15 = v12;
                v10 = v14;
                v11 = v15;
            }
        }
        // 0x100003c80
        result = v11;
        v18--;
    }
    // 0x100003d20
    return result;
}

// Address range: 0x100003d2c - 0x100003d78
int64_t function_100003d2c(int32_t a1) {
    // 0x100003d2c
    return (uint64_t)function_100003c24() / (int64_t)(a1 + 1);
}

// Address range: 0x100003d78 - 0x100003e1c
int64_t function_100003d78(void) {
    // 0x100003d78
    int64_t v1; // 0x100003d78
    int32_t v2 = v1; // 0x100003d84
    int64_t result = v2 == 0; // 0x100003d90
    int32_t v3 = -v2; // 0x100003db0
    int32_t v4 = 0; // 0x100003db8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e0c
        return result;
    }
    int64_t result2 = result; // 0x100003db8
    int64_t v5 = function_100003d78(); // 0x100003dc4
    result2 += function_100003d78() * v5;
    v4++;
    int32_t v6 = v4 - v2; // 0x100003db0
    while (v6 < 0 != ((v6 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003dc0
        v5 = function_100003d78();
        result2 += function_100003d78() * v5;
        v4++;
        v6 = v4 - v2;
    }
    // 0x100003e0c
    return result2;
}

// Address range: 0x100003e1c - 0x100003eac
int64_t function_100003e1c(void) {
    // 0x100003e1c
    int64_t v1; // 0x100003e1c
    int32_t v2 = v1; // 0x100003e28
    int64_t result = 1; // 0x100003e38
    if (v2 != 0) {
        // 0x100003e40
        result = function_100003e1c() * (int64_t)(4 * v2 - 2) / (0x100000000 * v1 + 0x100000000 >> 32);
    }
    // 0x100003e9c
    return result;
}

// Address range: 0x100003eac - 0x100003f60
int64_t entry_point(void) {
    // 0x100003eac
    _puts("\tdirect\tsumming\tfrac");
    for (int32_t i = 0; i < 16; i++) {
        // 0x100003ee4
        function_100003d2c(i);
        function_100003d78();
        function_100003e1c();
        int64_t v1; // 0x100003eac
        _printf("%d\t%llu\t%llu\t%llu\n", v1, v1, v1, v1);
    }
    // 0x100003f50
    return 0;
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * s) {
    // 0x100003f6c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned uint;
typedef struct { uint i, v; } filt_t;

// ludics with at least so many elements and reach at least such value
uint* ludic(uint min_len, uint min_val, uint *len)
{
	uint cap, i, v, active = 1, nf = 0;
	filt_t *f = calloc(cap = 2, sizeof(*f));
	f[1].i = 4;

	for (v = 1; ; ++v) {
		for (i = 1; i < active && --f[i].i; i++);

		if (i < active)
			f[i].i = f[i].v;
		else if (nf == f[i].i)
			f[i].i = f[i].v, ++active;  // enable one more filter
		else {
			if (nf >= cap)
				f = realloc(f, sizeof(*f) * (cap*=2));
			f[nf] = (filt_t){ v + nf, v };
			if (++nf >= min_len && v >= min_val) break;
		}
	}

	// pack the sequence into a uint[]
	// filt_t struct was used earlier for cache locality in loops
	uint *x = (void*) f;
	for (i = 0; i < nf; i++) x[i] = f[i].v;
	x = realloc(x, sizeof(*x) * nf);

	*len = nf;
	return x;
}

int find(uint *a, uint v)
{
	uint i;
	for (i = 0; a[i] <= v; i++)
		if (v == a[i]) return 1;
	return 0;
}

int main(void)
{
	uint len, i, *x = ludic(2005, 1000, &len);

	printf("First 25:");
	for (i = 0; i < 25; i++) printf(" %u", x[i]);
	putchar('\n');

	for (i = 0; x[i] <= 1000; i++);
	printf("Ludics below 1000: %u\n", i);

	printf("Ludic 2000 to 2005:");
	for (i = 2000; i <= 2005; i++) printf(" %u", x[i - 1]);
	putchar('\n');

	printf("Triples below 250:");
	for (i = 0; x[i] + 6 <= 250; i++)
		if (find(x, x[i] + 2) && find(x, x[i] + 6))
			printf(" (%u %u %u)", x[i], x[i] + 2, x[i] + 6);

	putchar('\n');

	free(x);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003970(void);
int64_t function_100003c24(void);
int64_t * function_100003f0c(int32_t nmemb, int32_t size);
void function_100003f18(int64_t * ptr);
int32_t function_100003f24(char * format, ...);
int32_t function_100003f30(int32_t c);
int64_t * function_100003f3c(int64_t * ptr, int32_t size);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003970 - 0x100003c24
int64_t function_100003970(void) {
    int64_t v1 = (int64_t)_calloc(2, 8); // 0x1000039a8
    *(int32_t *)(v1 + 8) = 4;
    int32_t v2 = 1; // 0x1000039c4
    int32_t v3 = 0; // 0x1000039c4
    int32_t v4 = 2; // 0x1000039c4
    int64_t v5 = v1; // 0x1000039c4
    int32_t v6 = 1; // 0x1000039c4
    int64_t v7; // 0x100003970
    int64_t v8; // 0x100003970
    uint32_t v9; // 0x100003b40
    while (true) {
        uint32_t v10 = v6;
        int64_t v11 = v5;
        int32_t v12 = v4;
        int32_t v13 = v3;
        int32_t v14 = v2;
        int64_t v15 = v11 + 8;
        int32_t * v16 = (int32_t *)v15;
        int32_t v17 = *v16;
        int64_t v18 = v15; // 0x1000039ec
        int32_t * v19 = v16; // 0x1000039ec
        int32_t v20 = v17; // 0x1000039ec
        if (v14 > 1) {
            uint64_t v21 = (int64_t)v14;
            int64_t v22 = 1;
            int32_t v23 = v17 - 1; // 0x100003a04
            *v16 = v23;
            while (v23 != 0) {
                int64_t v24 = v22 + 1;
                int64_t v25 = 8 * v24 + v11;
                int32_t * v26 = (int32_t *)v25;
                int32_t v27 = *v26;
                v18 = v25;
                v19 = v26;
                v20 = v27;
                if (v24 >= v21) {
                    goto lab_0x100003a78;
                }
                v22 = v24;
                v23 = v27 - 1;
                *v26 = v23;
            }
            int64_t v28 = (8 * v22 & 0x7fffffff8) + v11;
            *(int32_t *)v28 = *(int32_t *)(v28 + 4);
            v2 = v14;
            v3 = v13;
            v4 = v12;
            v5 = v11;
        } else {
          lab_0x100003a78:
            // 0x100003a78
            if (v13 == v20) {
                // 0x100003a9c
                *v19 = *(int32_t *)(v18 + 4);
                v2 = v14 + 1;
                v3 = v13;
                v4 = v12;
                v5 = v11;
            } else {
                int32_t v29 = v12; // 0x100003adc
                int64_t v30 = v11; // 0x100003adc
                if (v13 >= v12) {
                    int64_t * v31 = _realloc((int64_t *)v11, 16 * v12); // 0x100003b04
                    v29 = 2 * v12;
                    v30 = (int64_t)v31;
                }
                // 0x100003b10
                v7 = v30;
                *(int64_t *)(v7 + 8 * (int64_t)v13) = (int64_t)(v10 + v13);
                v9 = v13 + 1;
                v2 = v14;
                v3 = v9;
                v4 = v29;
                v5 = v7;
                if (v9 >= (int32_t)v8 && v10 >= (int32_t)v8) {
                    // break -> 0x100003ba4
                    break;
                }
            }
        }
        // 0x100003b84
        v6 = v10 + 1;
    }
    int64_t * v32; // 0x100003c00
    if (v9 == 0) {
        // 0x100003bec
        v32 = _realloc((int64_t *)v7, 4 * v9);
        *(int32_t *)v8 = v9;
        return (int64_t)v32;
    }
    int64_t v33 = 0;
    int32_t v34 = *(int32_t *)(v7 + 4 + 8 * v33); // 0x100003bc8
    *(int32_t *)(4 * v33 + v7) = v34;
    v33++;
    while (v33 != (int64_t)v9) {
        // 0x100003bbc
        v34 = *(int32_t *)(v7 + 4 + 8 * v33);
        *(int32_t *)(4 * v33 + v7) = v34;
        v33++;
    }
    // 0x100003bec
    v32 = _realloc((int64_t *)v7, 4 * v9);
    *(int32_t *)v8 = v9;
    return (int64_t)v32;
}

// Address range: 0x100003c24 - 0x100003cac
int64_t function_100003c24(void) {
    // 0x100003c24
    int64_t v1; // 0x100003c24
    uint32_t v2 = (int32_t)v1; // 0x100003c2c
    int32_t v3 = 0; // 0x100003c34
    uint32_t v4 = *(int32_t *)(4 * (int64_t)v3 + v1); // 0x100003c40
    v3++;
    while (v4 != v2 && v4 >= v2 != v4 != v2) {
        // 0x100003c38
        v4 = *(int32_t *)(4 * (int64_t)v3 + v1);
        v3++;
    }
    // 0x100003ca0
    return v4 >= v2 != v4 != v2;
}

// Address range: 0x100003cac - 0x100003f0c
int64_t entry_point(void) {
    int64_t v1 = function_100003970(); // 0x100003cc8
    _printf("First 25:");
    for (int32_t i = 0; i < 25; i++) {
        // 0x100003cf8
        _printf(" %u", 1000);
    }
    // 0x100003d30
    _putchar(10);
    int32_t v2 = 0; // 0x100003d3c
    uint32_t v3 = *(int32_t *)(4 * (int64_t)v2 + v1); // 0x100003d48
    v2++;
    while (v3 >= 1000 != v3 != 1000) {
        // 0x100003d40
        v3 = *(int32_t *)(4 * (int64_t)v2 + v1);
        v2++;
    }
    // 0x100003d70
    int64_t v4; // bp-24, 0x100003cac
    int64_t v5 = &v4; // 0x100003cc4
    _printf("Ludics below 1000: %u\n", 1000);
    _printf("Ludic 2000 to 2005:");
    for (int32_t i = 2000; i < 2006; i++) {
        // 0x100003db8
        _printf(" %u", 1000);
    }
    // 0x100003df4
    _putchar(10);
    _printf("Triples below 250:");
    int32_t * v6 = (int32_t *)v1; // 0x100003e18
    int32_t v7 = *v6; // 0x100003e18
    if (v7 >= 244 == (v7 != 244)) {
        // 0x100003eec
        _putchar(10);
        _free((int64_t *)v1);
        return 0;
    }
    int32_t v8 = 0; // 0x100003ee0
    int64_t v9; // 0x100003cac
    if ((int32_t)function_100003c24() != 0) {
        // 0x100003e58
        if ((int32_t)function_100003c24() != 0) {
            // 0x100003e80
            _printf(" (%u %u %u)", *v6 + 6, (int32_t)v5, (int32_t)v9);
        }
    }
    // 0x100003edc
    v8++;
    int32_t * v10 = (int32_t *)(4 * (int64_t)v8 + v1); // 0x100003e18
    int32_t v11 = *v10; // 0x100003e18
    int32_t * v12 = v10; // 0x100003e28
    while (v11 >= 244 != v11 != 244) {
        // 0x100003e30
        if ((int32_t)function_100003c24() != 0) {
            int32_t v13 = *v12; // 0x100003e64
            if ((int32_t)function_100003c24() != 0) {
                // 0x100003e80
                _printf(" (%u %u %u)", v13 + 6, (int32_t)v5, (int32_t)v9);
            }
        }
        // 0x100003edc
        v8++;
        v10 = (int32_t *)(4 * (int64_t)v8 + v1);
        v11 = *v10;
        v12 = v10;
    }
    // 0x100003eec
    _putchar(10);
    _free((int64_t *)v1);
    return 0;
}

// Address range: 0x100003f0c - 0x100003f18
int64_t * function_100003f0c(int32_t nmemb, int32_t size) {
    // 0x100003f0c
    return _calloc(nmemb, size);
}

// Address range: 0x100003f18 - 0x100003f24
void function_100003f18(int64_t * ptr) {
    // 0x100003f18
    _free(ptr);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(int32_t c) {
    // 0x100003f30
    return _putchar(c);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int64_t * ptr, int32_t size) {
    // 0x100003f3c
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>

#define MAT_ELEM(rows,cols,r,c) (r*cols+c)

//Improve performance by assuming output matrices do not overlap with
//input matrices. If this is C++, use the __restrict extension instead
#ifdef __cplusplus
    typedef double * const __restrict MAT_OUT_t;
#else
    typedef double * const restrict MAT_OUT_t;
#endif
typedef const double * const MAT_IN_t;

static inline void mat_mult(
    const int m,
    const int n,
    const int p,
    MAT_IN_t a,
    MAT_IN_t b,
    MAT_OUT_t c)
{
    for (int row=0; row<m; row++) {
        for (int col=0; col<p; col++) {
            c[MAT_ELEM(m,p,row,col)] = 0;
            for (int i=0; i<n; i++) {
                c[MAT_ELEM(m,p,row,col)] += a[MAT_ELEM(m,n,row,i)]*b[MAT_ELEM(n,p,i,col)];
            }
        }
    }
}

static inline void mat_show(
    const int m,
    const int p,
    MAT_IN_t a)
{
    for (int row=0; row<m;row++) {
        for (int col=0; col<p;col++) {
            printf("\t%7.3f", a[MAT_ELEM(m,p,row,col)]);
        }
        putchar('\n');
    }
}

int main(void)
{
    double a[4*4] = {1, 1,   1,   1,
                     2, 4,   8,  16,
                     3, 9,  27,  81,
                     4, 16, 64, 256};

    double b[4*3] = {    4.0,   -3.0,  4.0/3,
                     -13.0/3, 19.0/4, -7.0/3,
                       3.0/2,   -2.0,  7.0/6,
                      -1.0/6,  1.0/4, -1.0/6};

    double c[4*3] = {0};

    mat_mult(4,4,3,a,b,c);
    mat_show(4,3,c);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c70(void);
int64_t function_100003db0(void);
int64_t function_100003e74(int64_t a1);
int64_t * function_100003e80(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003e8c(int64_t * s, int32_t c, int32_t n);
int32_t function_100003e98(char * format, ...);
int32_t function_100003ea4(int32_t c);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x3ff0000000000000; // 0x100003eb0
int64_t g2 = 0x4010000000000000; // 0x100003f30

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b90 - 0x100003c70
int64_t entry_point(void) {
    // 0x100003b90
    int64_t v1; // bp-168, 0x100003b90
    _memcpy(&v1, &g1, 128);
    int64_t v2; // bp-264, 0x100003b90
    _memcpy(&v2, &g2, 96);
    int64_t v3; // bp-360, 0x100003b90
    _memset(&v3, 0, 96);
    function_100003c70();
    int64_t v4 = function_100003db0(); // 0x100003c34
    int64_t v5 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c44
    if (v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003c58
        ___stack_chk_fail(v4);
    }
    // 0x100003c5c
    return 0;
}

// Address range: 0x100003c70 - 0x100003db0
int64_t function_100003c70(void) {
    // 0x100003c70
    int64_t result; // 0x100003c70
    int32_t v1 = result; // 0x100003c74
    int32_t v2 = -v1; // 0x100003c9c
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x100003da8
        return result;
    }
    int32_t v3 = result; // 0x100003c78
    int32_t v4 = result; // 0x100003c7c
    int32_t v5 = -v4; // 0x100003cbc
    int32_t v6 = -v3;
    int32_t v7 = 0;
    int32_t v8; // 0x100003c70
    int32_t v9; // 0x100003c70
    int32_t v10; // 0x100003ce0
    int32_t v11; // 0x100003d88
    float64_t * v12; // 0x100003d60
    float64_t v13; // 0x100003d40
    float64_t v14; // 0x100003d64
    int32_t v15; // 0x100003d74
    if (v5 < 0 != (v5 & v4) < 0) {
        // 0x100003ccc
        v9 = v7 * v3;
        v8 = 0;
        v10 = v8 + v7 * v4;
        *(float64_t *)(result + (int64_t)(8 * v10)) = 0.0;
        if (v6 < 0 != (v6 & v3) < 0) {
            // 0x100003d0c
            v12 = (float64_t *)(8 * (int64_t)v10 + result);
            v14 = *v12;
            v15 = 0;
            v13 = *(float64_t *)(result + (int64_t)(8 * (v15 * v4 + v8)));
            v14 += *(float64_t *)(result + (int64_t)(8 * (v15 + v9))) * v13;
            *v12 = v14;
            v15++;
            while (v15 - v3 < 0 != ((v15 - v3 ^ v15) & (v15 ^ v3)) < 0) {
                // 0x100003d0c
                v13 = *(float64_t *)(result + (int64_t)(8 * (v15 * v4 + v8)));
                v14 += *(float64_t *)(result + (int64_t)(8 * (v15 + v9))) * v13;
                *v12 = v14;
                v15++;
            }
        }
        // 0x100003d84
        v11 = v8 + 1;
        while (v11 - v4 < 0 != ((v11 - v4 ^ v11) & (v11 ^ v4)) < 0) {
            // 0x100003ccc
            v8 = v11;
            v10 = v8 + v7 * v4;
            *(float64_t *)(result + (int64_t)(8 * v10)) = 0.0;
            if (v6 < 0 != (v6 & v3) < 0) {
                // 0x100003d0c
                v12 = (float64_t *)(8 * (int64_t)v10 + result);
                v14 = *v12;
                v15 = 0;
                v13 = *(float64_t *)(result + (int64_t)(8 * (v15 * v4 + v8)));
                v14 += *(float64_t *)(result + (int64_t)(8 * (v15 + v9))) * v13;
                *v12 = v14;
                v15++;
                while (v15 - v3 < 0 != ((v15 - v3 ^ v15) & (v15 ^ v3)) < 0) {
                    // 0x100003d0c
                    v13 = *(float64_t *)(result + (int64_t)(8 * (v15 * v4 + v8)));
                    v14 += *(float64_t *)(result + (int64_t)(8 * (v15 + v9))) * v13;
                    *v12 = v14;
                    v15++;
                }
            }
            // 0x100003d84
            v11 = v8 + 1;
        }
    }
    int32_t v16 = v7 + 1; // 0x100003d9c
    while (v16 - v1 < 0 != ((v16 - v1 ^ v16) & (v16 ^ v1)) < 0) {
        // 0x100003cb4
        v7 = v16;
        if (v5 < 0 != (v5 & v4) < 0) {
            // 0x100003ccc
            v9 = v7 * v3;
            v8 = 0;
            v10 = v8 + v7 * v4;
            *(float64_t *)(result + (int64_t)(8 * v10)) = 0.0;
            if (v6 < 0 != (v6 & v3) < 0) {
                // 0x100003d0c
                v12 = (float64_t *)(8 * (int64_t)v10 + result);
                v14 = *v12;
                v15 = 0;
                v13 = *(float64_t *)(result + (int64_t)(8 * (v15 * v4 + v8)));
                v14 += *(float64_t *)(result + (int64_t)(8 * (v15 + v9))) * v13;
                *v12 = v14;
                v15++;
                while (v15 - v3 < 0 != ((v15 - v3 ^ v15) & (v15 ^ v3)) < 0) {
                    // 0x100003d0c
                    v13 = *(float64_t *)(result + (int64_t)(8 * (v15 * v4 + v8)));
                    v14 += *(float64_t *)(result + (int64_t)(8 * (v15 + v9))) * v13;
                    *v12 = v14;
                    v15++;
                }
            }
            // 0x100003d84
            v11 = v8 + 1;
            while (v11 - v4 < 0 != ((v11 - v4 ^ v11) & (v11 ^ v4)) < 0) {
                // 0x100003ccc
                v8 = v11;
                v10 = v8 + v7 * v4;
                *(float64_t *)(result + (int64_t)(8 * v10)) = 0.0;
                if (v6 < 0 != (v6 & v3) < 0) {
                    // 0x100003d0c
                    v12 = (float64_t *)(8 * (int64_t)v10 + result);
                    v14 = *v12;
                    v15 = 0;
                    v13 = *(float64_t *)(result + (int64_t)(8 * (v15 * v4 + v8)));
                    v14 += *(float64_t *)(result + (int64_t)(8 * (v15 + v9))) * v13;
                    *v12 = v14;
                    v15++;
                    while (v15 - v3 < 0 != ((v15 - v3 ^ v15) & (v15 ^ v3)) < 0) {
                        // 0x100003d0c
                        v13 = *(float64_t *)(result + (int64_t)(8 * (v15 * v4 + v8)));
                        v14 += *(float64_t *)(result + (int64_t)(8 * (v15 + v9))) * v13;
                        *v12 = v14;
                        v15++;
                    }
                }
                // 0x100003d84
                v11 = v8 + 1;
            }
        }
        // 0x100003d98
        v16 = v7 + 1;
    }
    // 0x100003da8
    return result;
}

// Address range: 0x100003db0 - 0x100003e74
int64_t function_100003db0(void) {
    // 0x100003db0
    int64_t v1; // 0x100003db0
    int32_t v2 = v1; // 0x100003dbc
    int32_t v3 = -v2; // 0x100003dd8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e68
        int64_t result; // 0x100003db0
        return result;
    }
    int32_t v4 = v1; // 0x100003dc0
    int32_t v5 = -v4; // 0x100003df8
    int32_t v6 = 0; // 0x100003e5c
    int32_t v7; // 0x100003db0
    int32_t v8; // 0x100003e40
    int32_t v9; // 0x100003df8
    int128_t v10; // 0x100003db0
    if (v5 < 0 != (v5 & v4) < 0) {
        _printf("\t%7.3f", (float64_t)(int64_t)v10);
        v8 = 1;
        v9 = v8 - v4;
        v7 = v8;
        while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v4)) < 0) {
            // 0x100003e08
            _printf("\t%7.3f", (float64_t)(int64_t)v10);
            v8 = v7 + 1;
            v9 = v8 - v4;
            v7 = v8;
        }
    }
    int32_t result2 = _putchar(10); // 0x100003e50
    v6++;
    while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
        // 0x100003df0
        if (v5 < 0 != (v5 & v4) < 0) {
            _printf("\t%7.3f", (float64_t)(int64_t)v10);
            v8 = 1;
            v9 = v8 - v4;
            v7 = v8;
            while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v4)) < 0) {
                // 0x100003e08
                _printf("\t%7.3f", (float64_t)(int64_t)v10);
                v8 = v7 + 1;
                v9 = v8 - v4;
                v7 = v8;
            }
        }
        // 0x100003e4c
        result2 = _putchar(10);
        v6++;
    }
    // 0x100003e68
    return result2;
}

// Address range: 0x100003e74 - 0x100003e80
int64_t function_100003e74(int64_t a1) {
    // 0x100003e74
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e80 - 0x100003e8c
int64_t * function_100003e80(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003e80
    return _memcpy(dest, src, n);
}

// Address range: 0x100003e8c - 0x100003e98
int64_t * function_100003e8c(int64_t * s, int32_t c, int32_t n) {
    // 0x100003e8c
    return _memset(s, c, n);
}

// Address range: 0x100003e98 - 0x100003ea4
int32_t function_100003e98(char * format, ...) {
    // 0x100003e98
    return _printf(format);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(int32_t c) {
    // 0x100003ea4
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include<stdlib.h>
#include<stdio.h>
#include<math.h>

typedef struct{
	double x,y;
}point;

double shoelace(char* inputFile){
	int i,numPoints;
	double leftSum = 0,rightSum = 0;
	
	point* pointSet;
	FILE* fp = fopen(inputFile,"r");
	
	fscanf(fp,"%d",&numPoints);
	
	pointSet = (point*)malloc((numPoints + 1)*sizeof(point));
	
	for(i=0;i<numPoints;i++){
		fscanf(fp,"%lf %lf",&pointSet[i].x,&pointSet[i].y);
	}
	
	fclose(fp);
	
	pointSet[numPoints] = pointSet[0];
	
	for(i=0;i<numPoints;i++){
		leftSum += pointSet[i].x*pointSet[i+1].y;
		rightSum += pointSet[i+1].x*pointSet[i].y;
	}
	
	free(pointSet);
	
	return 0.5*fabs(leftSum - rightSum);
}

int main(int argC,char* argV[])
{
	if(argC==1)
		printf("\nUsage : %s <full path of polygon vertices file>",argV[0]);
	
	else
		printf("The polygon area is %lf square units.",shoelace(argV[1]));
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cc8(void);
int32_t function_100003efc(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f08(char * filename, char * modes);
void function_100003f14(int64_t * ptr);
int32_t function_100003f20(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f2c(int32_t size);
int32_t function_100003f38(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cc8 - 0x100003e7c
int64_t function_100003cc8(void) {
    // 0x100003cc8
    int64_t v1; // 0x100003cc8
    struct _IO_FILE * v2 = _fopen((char *)v1, "r"); // 0x100003cf0
    _fscanf(v2, "%d", (int64_t *)v1);
    int32_t v3; // 0x100003cc8
    int64_t * v4 = _malloc(16 * v3 + 16); // 0x100003d28
    int64_t v5 = (int64_t)v4; // 0x100003d28
    int32_t v6 = -v3;
    if (v6 < 0 == (v3 & v6) < 0) {
        // 0x100003e54
        _fclose(v2);
        *(float128_t *)(16 * (int64_t)v3 + v5) = *(float128_t *)v4;
        // 0x100003e54
        _free(v4);
        __asm_fabd(0.0, 0.0);
        return &g1;
    }
    int32_t v7 = 0; // 0x100003d90
    _fscanf(v2, "%lf %lf", (float64_t *)v1, (float64_t *)v1);
    v7++;
    while (v7 - v3 < 0 != ((v7 - v3 ^ v7) & (v7 ^ v3)) < 0) {
        // 0x100003d50
        _fscanf(v2, "%lf %lf", (float64_t *)v1, (float64_t *)v1);
        v7++;
    }
    // 0x100003d9c
    _fclose(v2);
    *(float128_t *)(16 * (int64_t)v3 + v5) = *(float128_t *)v4;
    int32_t v8 = 0; // 0x100003df0
    float64_t v9 = 0.0; // 0x100003e00
    float64_t v10 = 0.0; // 0x100003e38
    int64_t v11 = 16 * (int64_t)v8 + v5; // 0x100003de4
    v8++;
    int64_t v12 = 16 * (int64_t)v8 + v5; // 0x100003df4
    v9 += *(float64_t *)v11 * *(float64_t *)(v12 + 8);
    v10 += *(float64_t *)v12 * *(float64_t *)(v11 + 8);
    int32_t v13 = v8 - v3; // 0x100003dc8
    float64_t v14 = v10; // 0x100003dd0
    float64_t v15 = v9; // 0x100003dd0
    while (v13 < 0 != ((v13 ^ v8) & (v8 ^ v3)) < 0) {
        // 0x100003dd8
        v11 = 16 * (int64_t)v8 + v5;
        v8++;
        v12 = 16 * (int64_t)v8 + v5;
        v9 += *(float64_t *)v11 * *(float64_t *)(v12 + 8);
        v10 += *(float64_t *)v12 * *(float64_t *)(v11 + 8);
        v13 = v8 - v3;
        v14 = v10;
        v15 = v9;
    }
    // 0x100003e54
    _free(v4);
    __asm_fabd(v15, v14);
    return &g1;
}

// Address range: 0x100003e7c - 0x100003efc
int64_t entry_point(void) {
    // 0x100003e7c
    int64_t v1; // 0x100003e7c
    if ((int32_t)v1 == 1) {
        // 0x100003ea8
        _printf("\nUsage : %s <full path of polygon vertices file>", (char *)v1);
    } else {
        // 0x100003ec8
        function_100003cc8();
        int128_t v2; // 0x100003e7c
        _printf("The polygon area is %lf square units.", (float64_t)(int64_t)v2);
    }
    // 0x100003eec
    return 0;
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(struct _IO_FILE * stream) {
    // 0x100003efc
    return _fclose(stream);
}

// Address range: 0x100003f08 - 0x100003f14
struct _IO_FILE * function_100003f08(char * filename, char * modes) {
    // 0x100003f08
    return _fopen(filename, modes);
}

// Address range: 0x100003f14 - 0x100003f20
void function_100003f14(int64_t * ptr) {
    // 0x100003f14
    _free(ptr);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f20
    return _fscanf(stream, format);
}

// Address range: 0x100003f2c - 0x100003f38
int64_t * function_100003f2c(int32_t size) {
    // 0x100003f2c
    return _malloc(size);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * format, ...) {
    // 0x100003f38
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
#include <stdlib.h>

void get_div_cnt(int n){
	int lmt,f,divcnt,divsum;
	divsum = 1;
	divcnt = 1;
	lmt = n/2;
    f = 2;
	for (;;) {
	  if (f > lmt ) break;
	  if (!(n % f)){
		  divsum +=f;
		  divcnt++;
	  }
	  if (divsum == n) break;
      f++;
	}
    printf("%8d equals the sum of its first %d divisors\n", n, divcnt);	
}

int main() {
    const int maxNumber = 100*1000*1000;
    int *dsum = (int *)malloc((maxNumber + 1) * sizeof(int));
    int i, j;
    for (i = 0; i <= maxNumber; ++i) {
        dsum[i] = 1;
    }
    for (i = 2; i <= maxNumber; ++i) {
        for (j = i + i; j <= maxNumber; j += i) {
        if (dsum[j] == j) get_div_cnt(j);
        dsum[j] += i;
        }
    }
    free(dsum);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d10(void);
void function_100003f54(int64_t * ptr);
int64_t * function_100003f60(int32_t size);
int32_t function_100003f6c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d10 - 0x100003e04
int64_t function_100003d10(void) {
    // 0x100003d10
    int64_t v1; // 0x100003d10
    int32_t v2 = v1; // 0x100003d1c
    int32_t v3 = v2 / 2; // 0x100003d34
    int32_t v4 = 2 - v3; // 0x100003d4c
    if (v4 != 0 && v4 < 0 == (v4 & v3) < 0) {
        // 0x100003dd0
        return _printf("%8d equals the sum of its first %d divisors\n", v1, v1);
    }
    int32_t v5 = 1; // 0x100003d54
    int32_t v6 = 2; // 0x100003dc4
    while ((v2 % v6 == 0 ? v6 : 0) + v5 != v2) {
        // 0x100003d60
        v5 += (v2 % v6 == 0 ? v6 : 0);
        // 0x100003d44
        v6++;
        int32_t v7 = v6 - v3; // 0x100003d4c
        if (v7 != 0 && v7 < 0 == ((v7 ^ v6) & (v6 ^ v3)) < 0) {
            // break -> 0x100003dd0
            break;
        }
    }
    // 0x100003dd0
    return _printf("%8d equals the sum of its first %d divisors\n", v1, v1);
}

// Address range: 0x100003e04 - 0x100003f54
int64_t entry_point(void) {
    int64_t * v1 = _malloc(0x17d78404); // 0x100003e2c
    int64_t v2 = (int64_t)v1; // 0x100003e2c
    int32_t v3 = 0;
    *(int32_t *)(4 * (int64_t)v3 + v2) = 1;
    int32_t v4 = v3 + 1; // 0x100003e6c
    int32_t v5 = v3 - 0x5f5e0ff; // 0x100003e44
    while (v5 == 0 || v5 < 0 != (0x5f5e0fe - v3 & v4) < 0) {
        // 0x100003e54
        v3 = v4;
        *(int32_t *)(4 * (int64_t)v3 + v2) = 1;
        v4 = v3 + 1;
        v5 = v3 - 0x5f5e0ff;
    }
    int32_t v6 = 2;
    int32_t v7 = 2 * v6; // 0x100003ea4
    int32_t v8 = v7 - 0x5f5e100; // 0x100003eb8
    int32_t v9 = v7; // 0x100003ec0
    int32_t v10; // 0x100003e04
    int32_t v11; // 0x100003f1c
    int32_t v12; // 0x100003eb8
    int32_t * v13; // 0x100003ed0
    int32_t v14; // 0x100003ed0
    if (v8 == 0 || v8 < 0 != (0x5f5e0ff - v7 & v7) < 0) {
        v13 = (int32_t *)(4 * (int64_t)v9 + v2);
        v14 = *v13;
        v10 = v14;
        if (v14 == v9) {
            // 0x100003ee8
            function_100003d10();
            v10 = *v13;
        }
        // 0x100003ef4
        *v13 = v10 + v6;
        v11 = v9 + v6;
        v12 = v11 - 0x5f5e100;
        v9 = v11;
        while (v12 == 0 || v12 < 0 != (0x5f5e0ff - v11 & v11) < 0) {
            // 0x100003ec8
            v13 = (int32_t *)(4 * (int64_t)v9 + v2);
            v14 = *v13;
            v10 = v14;
            if (v14 == v9) {
                // 0x100003ee8
                function_100003d10();
                v10 = *v13;
            }
            // 0x100003ef4
            *v13 = v10 + v6;
            v11 = v9 + v6;
            v12 = v11 - 0x5f5e100;
            v9 = v11;
        }
    }
    int32_t v15 = v6 + 1; // 0x100003f30
    int32_t v16 = v6 - 0x5f5e0ff; // 0x100003e8c
    while (v16 == 0 || v16 < 0 != (0x5f5e0fe - v6 & v15) < 0) {
        // 0x100003e9c
        v6 = v15;
        v7 = 2 * v6;
        v8 = v7 - 0x5f5e100;
        v9 = v7;
        if (v8 == 0 || v8 < 0 != (0x5f5e0ff - v7 & v7) < 0) {
            v13 = (int32_t *)(4 * (int64_t)v9 + v2);
            v14 = *v13;
            v10 = v14;
            if (v14 == v9) {
                // 0x100003ee8
                function_100003d10();
                v10 = *v13;
            }
            // 0x100003ef4
            *v13 = v10 + v6;
            v11 = v9 + v6;
            v12 = v11 - 0x5f5e100;
            v9 = v11;
            while (v12 == 0 || v12 < 0 != (0x5f5e0ff - v11 & v11) < 0) {
                // 0x100003ec8
                v13 = (int32_t *)(4 * (int64_t)v9 + v2);
                v14 = *v13;
                v10 = v14;
                if (v14 == v9) {
                    // 0x100003ee8
                    function_100003d10();
                    v10 = *v13;
                }
                // 0x100003ef4
                *v13 = v10 + v6;
                v11 = v9 + v6;
                v12 = v11 - 0x5f5e100;
                v9 = v11;
            }
        }
        // 0x100003f2c
        v15 = v6 + 1;
        v16 = v6 - 0x5f5e0ff;
    }
    // 0x100003f3c
    _free(v1);
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
void function_100003f54(int64_t * ptr) {
    // 0x100003f54
    _free(ptr);
}

// Address range: 0x100003f60 - 0x100003f6c
int64_t * function_100003f60(int32_t size) {
    // 0x100003f60
    return _malloc(size);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>

int main(void)
{
    for (int i = 1; i <= 100; ++i) {
        if (i % 3 == 0) printf("fizz");
        if (i % 5 == 0) printf("buzz");
        if (i * i * i * i % 15 == 1) printf("%d", i);
        puts("");
    }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f80(char * format, ...);
int32_t function_100003f8c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e5c - 0x100003f80
int64_t entry_point(void) {
    int32_t v1 = 1;
    if (v1 % 3 == 0) {
        // 0x100003eb0
        _printf("fizz");
    }
    if (v1 % 5 == 0) {
        // 0x100003ee4
        _printf("buzz");
    }
    int32_t v2 = v1 * v1;
    int64_t v3; // 0x100003e5c
    if (v2 * v2 % 15 == 1) {
        // 0x100003f30
        _printf("%d", v3);
    }
    // 0x100003f50
    _puts((char *)0x100003fa5);
    int32_t v4 = v1 + 1; // 0x100003f64
    while (v1 == 99 || v1 < 99 != (98 - v1 & v4) < 0) {
        // 0x100003e8c
        v1 = v4;
        if (v1 % 3 == 0) {
            // 0x100003eb0
            _printf("fizz");
        }
        if (v1 % 5 == 0) {
            // 0x100003ee4
            _printf("buzz");
        }
        // 0x100003ef4
        v2 = v1 * v1;
        if (v2 * v2 % 15 == 1) {
            // 0x100003f30
            _printf("%d", v3);
        }
        // 0x100003f50
        _puts((char *)0x100003fa5);
        v4 = v1 + 1;
    }
    // 0x100003f70
    return 0;
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * s) {
    // 0x100003f8c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int day(int y, int m, int d) {
    return 367 * y - 7 * (y + (m + 9) / 12) / 4 + 275 * m / 9 + d - 730530;
}

void cycle(int diff, int l, char *t) {
    int p = round(100 * sin(2 * M_PI * diff / l));
    printf("%12s cycle: %3i%%", t, p);
    if (abs(p) < 15)
        printf(" (critical day)");
    printf("\n");
}

int main(int argc, char *argv[]) {
    int diff;

    if (argc < 7) {
        printf("Usage:\n");
        printf("cbio y1 m1 d1 y2 m2 d2\n");
        exit(1);
    }
    diff = abs(day(atoi(argv[1]), atoi(argv[2]), atoi(argv[3]))
             - day(atoi(argv[4]), atoi(argv[5]), atoi(argv[6])));
    printf("Age: %u days\n", diff);
    cycle(diff, 23, "Physical");
    cycle(diff, 28, "Emotional");
    cycle(diff, 33, "Intellectual");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c58(void);
int64_t function_100003cd4(void);
int32_t function_100003edc(int32_t x);
int32_t function_100003ee8(char * nptr);
void function_100003ef4(int32_t status);
int32_t function_100003f00(char * format, ...);
float64_t function_100003f0c(float64_t a1);

// --------------------- Global Variables ---------------------

float64_t g1 = 100.0; // 0x100003f18
float64_t g2 = 6.2831853071795862; // 0x100003f20

// ------- Dynamically Linked Functions Without Header --------

int32_t _abs(int32_t a1);
int32_t _atoi(char * a1);
int32_t _printf(char * a1, ...);
float64_t _sin(float64_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c58 - 0x100003cd4
int64_t function_100003c58(void) {
    // 0x100003c58
    int64_t v1; // 0x100003c58
    int32_t v2 = v1; // 0x100003c5c
    int32_t v3 = v1; // 0x100003c60
    return (int32_t)v1 - 0xb25a2 + 367 * v2 + 275 * v3 / 9 + 7 * ((v3 + 9) / 12 + v2) / -4;
}

// Address range: 0x100003cd4 - 0x100003d9c
int64_t function_100003cd4(void) {
    // 0x100003cd4
    float64_t v1; // 0x100003cd4
    float64_t v2 = v1;
    int128_t v3 = __asm_sshll(0.0f, 0); // 0x100003cf4
    __asm_sshll(0.0f, 0);
    _sin((float64_t)(int64_t)v3);
    int32_t v4 = __asm_fcvtas(v2 * g2 / v2 * g1); // 0x100003d30
    int64_t v5; // 0x100003cd4
    _printf("%12s cycle: %3i%%", (char *)v5, v5);
    int32_t v6 = _abs(v4); // 0x100003d60
    if (v6 < 15 != (14 - v6 & v6) < 0) {
        // 0x100003d74
        _printf(" (critical day)");
    }
    // 0x100003d84
    return _printf("\n");
}

// Address range: 0x100003d9c - 0x100003edc
int64_t entry_point(void) {
    // 0x100003d9c
    int64_t v1; // 0x100003d9c
    int32_t v2 = v1; // 0x100003da8
    if (v2 < 7 != (6 - v2 & v2) < 0) {
        // 0x100003dc4
        _printf("Usage:\n");
        _printf("cbio y1 m1 d1 y2 m2 d2\n");
        _exit(1);
        // UNREACHABLE
    }
    // 0x100003de4
    _atoi((char *)*(int64_t *)(v1 + 8));
    _atoi((char *)*(int64_t *)(v1 + 16));
    _atoi((char *)*(int64_t *)(v1 + 24));
    int64_t v3 = function_100003c58(); // 0x100003e1c
    _atoi((char *)*(int64_t *)(v1 + 32));
    int32_t v4 = _atoi((char *)*(int64_t *)(v1 + 40)); // 0x100003e3c
    _atoi((char *)*(int64_t *)(v1 + 48));
    _abs((int32_t)v3 - (int32_t)function_100003c58());
    _printf("Age: %u days\n", v4);
    function_100003cd4();
    function_100003cd4();
    function_100003cd4();
    return 0;
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(int32_t x) {
    // 0x100003edc
    return _abs(x);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * nptr) {
    // 0x100003ee8
    return _atoi(nptr);
}

// Address range: 0x100003ef4 - 0x100003f00
void function_100003ef4(int32_t status) {
    // 0x100003ef4
    _exit(status);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * format, ...) {
    // 0x100003f00
    return _printf(format);
}

// Address range: 0x100003f0c - 0x100003f18
float64_t function_100003f0c(float64_t a1) {
    // 0x100003f0c
    return _sin(a1);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include<stdio.h>

int main()
{
	int police,sanitation,fire;
	
	printf("Police     Sanitation         Fire\n");
	printf("----------------------------------");
	
	for(police=2;police<=6;police+=2){
		for(sanitation=1;sanitation<=7;sanitation++){
			for(fire=1;fire<=7;fire++){
				if(police!=sanitation && sanitation!=fire && fire!=police && police+fire+sanitation==12){
					printf("\n%d\t\t%d\t\t%d",police,sanitation,fire);
				}
			}
		}
	}
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f48(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dd0 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003dd0
    _printf("Police     Sanitation         Fire\n");
    _printf("----------------------------------");
    int32_t v1 = 2;
    int32_t v2 = 1;
    int32_t v3 = v2 + v1;
    int32_t v4 = 1;
    int64_t v5; // 0x100003dd0
    if (v3 + v4 == 12 == (v4 != v1 && v1 != v2 && v2 != v4)) {
        // 0x100003ec4
        _printf("\n%d\t\t%d\t\t%d", v5, v5, v5);
    }
    int32_t v6 = v4 + 1; // 0x100003f04
    while (v4 == 6 || v4 < 6 != (5 - v4 & v6) < 0) {
        // 0x100003e58
        v4 = v6;
        if (v3 + v4 == 12 == (v4 != v1 && v1 != v2 && v2 != v4)) {
            // 0x100003ec4
            _printf("\n%d\t\t%d\t\t%d", v5, v5, v5);
        }
        // 0x100003f00
        v6 = v4 + 1;
    }
    int32_t v7 = v2 + 1; // 0x100003f18
    while (v2 == 6 || v2 < 6 != (5 - v2 & v7) < 0) {
        // 0x100003e44
        v2 = v7;
        v3 = v2 + v1;
        v4 = 1;
        if (v3 + v4 == 12 == (v4 != v1 && v1 != v2 && v2 != v4)) {
            // 0x100003ec4
            _printf("\n%d\t\t%d\t\t%d", v5, v5, v5);
        }
        // 0x100003f00
        v6 = v4 + 1;
        while (v4 == 6 || v4 < 6 != (5 - v4 & v6) < 0) {
            // 0x100003e58
            v4 = v6;
            if (v3 + v4 == 12 == (v4 != v1 && v1 != v2 && v2 != v4)) {
                // 0x100003ec4
                _printf("\n%d\t\t%d\t\t%d", v5, v5, v5);
            }
            // 0x100003f00
            v6 = v4 + 1;
        }
        // 0x100003f14
        v7 = v2 + 1;
    }
    int32_t v8 = v1 + 2; // 0x100003f2c
    while (v1 == 4 || v1 < 4 != (3 - v1 & v8) < 0) {
        // 0x100003e24
        v1 = v8;
        v2 = 1;
        v3 = v2 + v1;
        v4 = 1;
        if (v3 + v4 == 12 == (v4 != v1 && v1 != v2 && v2 != v4)) {
            // 0x100003ec4
            _printf("\n%d\t\t%d\t\t%d", v5, v5, v5);
        }
        // 0x100003f00
        v6 = v4 + 1;
        while (v4 == 6 || v4 < 6 != (5 - v4 & v6) < 0) {
            // 0x100003e58
            v4 = v6;
            if (v3 + v4 == 12 == (v4 != v1 && v1 != v2 && v2 != v4)) {
                // 0x100003ec4
                _printf("\n%d\t\t%d\t\t%d", v5, v5, v5);
            }
            // 0x100003f00
            v6 = v4 + 1;
        }
        // 0x100003f14
        v7 = v2 + 1;
        while (v2 == 6 || v2 < 6 != (5 - v2 & v7) < 0) {
            // 0x100003e44
            v2 = v7;
            v3 = v2 + v1;
            v4 = 1;
            if (v3 + v4 == 12 == (v4 != v1 && v1 != v2 && v2 != v4)) {
                // 0x100003ec4
                _printf("\n%d\t\t%d\t\t%d", v5, v5, v5);
            }
            // 0x100003f00
            v6 = v4 + 1;
            while (v4 == 6 || v4 < 6 != (5 - v4 & v6) < 0) {
                // 0x100003e58
                v4 = v6;
                if (v3 + v4 == 12 == (v4 != v1 && v1 != v2 && v2 != v4)) {
                    // 0x100003ec4
                    _printf("\n%d\t\t%d\t\t%d", v5, v5, v5);
                }
                // 0x100003f00
                v6 = v4 + 1;
            }
            // 0x100003f14
            v7 = v2 + 1;
        }
        // 0x100003f28
        v8 = v1 + 2;
    }
    // 0x100003f38
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include<stdio.h>

int main ()
{
  int i;
  const char *s[] = { "%d\n", "Fizz\n", s[3] + 4, "FizzBuzz\n" };
  for (i = 1; i <= 100; i++)
    printf(s[!(i % 3) + 2 * !(i % 5)], i);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f7c(void);
int32_t function_100003f88(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e5c - 0x100003f7c
int64_t entry_point(void) {
    char * v1 = "%d\n"; // bp-56, 0x100003e84
    int64_t v2 = (int64_t)&v1; // 0x100003f18
    int32_t v3 = 1;
    int64_t v4 = *(int64_t *)(8 * (2 * (int64_t)(v3 % 5 == 0) | (int64_t)(v3 % 3 == 0)) + v2); // 0x100003f1c
    _printf((char *)v4);
    int32_t v5 = v3 + 1; // 0x100003f3c
    while (v3 == 99 || v3 < 99 != (98 - v3 & v5) < 0) {
        // 0x100003ecc
        v3 = v5;
        v4 = *(int64_t *)(8 * (2 * (int64_t)(v3 % 5 == 0) | (int64_t)(v3 % 3 == 0)) + v2);
        _printf((char *)v4);
        v5 = v3 + 1;
    }
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f54
    if (v6 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f68
        ___stack_chk_fail();
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int64_t function_100003f7c(void) {
    // 0x100003f7c
    return ___stack_chk_fail();
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#define _CRT_SECURE_NO_WARNINGS    // turn off panic warnings
#define _CRT_NONSTDC_NO_WARNINGS   // enable old-gold POSIX names in MSVS

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>


struct StringArray
{
    size_t sizeOfArray;
    size_t numberOfElements;
    char** elements;
};
typedef struct StringArray* StringArray;

StringArray StringArray_new(size_t size)
{
    StringArray this = calloc(1, sizeof(struct StringArray));
    if (this)
    {
        this->elements = calloc(size, sizeof(int));
        if (this->elements)
            this->sizeOfArray = size;
        else
        {
            free(this);
            this = NULL;
        }
    }
    return this;
}

void StringArray_delete(StringArray* ptr_to_this)
{
    assert(ptr_to_this != NULL);
    StringArray this = (*ptr_to_this);
    if (this)
    {
        for (size_t i = 0; i < this->sizeOfArray; i++)
            free(this->elements[i]);
        free(this->elements);
        free(this);
        this = NULL;
    }
}

void StringArray_add(StringArray this, ...)
{
    char* s;
    va_list args;
    va_start(args, this);
    while (this->numberOfElements < this->sizeOfArray && (s = va_arg(args, char*)))
        this->elements[this->numberOfElements++] = strdup(s);
    va_end(args);
}


int main(int argc, char* argv[])
{
    StringArray a = StringArray_new(10);
    StringArray_add(a, "apple", "orange", NULL);

    printf(
        "There are %d elements in an array with a capacity of %d elements:\n\n",
        a->numberOfElements, a->sizeOfArray);

    for (size_t i = 0; i < a->numberOfElements; i++)
        printf("    the element %d is the string \"%s\"\n", i, a->elements[i]);

    StringArray_delete(&a);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b98(void);
int64_t function_100003c2c(void);
int64_t function_100003d14(void);
int64_t function_100003ebc(char * a1, char * a2, int64_t a3, char * a4);
int64_t * function_100003ec8(int32_t nmemb, int32_t size);
void function_100003ed4(int64_t * ptr);
int32_t function_100003ee0(char * format, ...);
char * function_100003eec(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b98 - 0x100003c2c
int64_t function_100003b98(void) {
    int64_t * v1 = _calloc(1, 24); // 0x100003bb0
    int64_t result = (int64_t)v1; // 0x100003bb0
    if (v1 == NULL) {
        // 0x100003c1c
        return result;
    }
    // 0x100003bcc
    int64_t v2; // 0x100003b98
    int64_t * v3 = _calloc((int32_t)v2, 4); // 0x100003bd4
    *(int64_t *)(result + 16) = (int64_t)v3;
    int64_t result2; // 0x100003b98
    if (v3 == NULL) {
        // 0x100003c08
        _free(v1);
        result2 = 0;
    } else {
        // 0x100003bf8
        *v1 = 0x100000000 * v2 >> 32;
        result2 = result;
    }
    // 0x100003c1c
    return result2;
}

// Address range: 0x100003c2c - 0x100003d14
int64_t function_100003c2c(void) {
    // 0x100003c2c
    int64_t v1; // 0x100003c2c
    int64_t v2; // 0x100003c2c
    if (v1 == 0) {
        // 0x100003c5c
        v2 = ___assert_rtn("StringArray_delete", "array-length-3.c", 38, "ptr_to_this != NULL");
    }
    // 0x100003c80
    if (v2 == 0) {
        // 0x100003d08
        return 0;
    }
    int64_t * v3 = (int64_t *)(v2 + 16);
    int64_t v4 = 0; // 0x100003ce0
    _free((int64_t *)*(int64_t *)(8 * v4 + *v3));
    v4++;
    int64_t v5 = *v3;
    while (v4 < (int64_t)&g1) {
        // 0x100003cc4
        _free((int64_t *)*(int64_t *)(8 * v4 + v5));
        v4++;
        v5 = *v3;
    }
    // 0x100003cec
    _free((int64_t *)v5);
    _free((int64_t *)v2);
    // 0x100003d08
    return &g1;
}

// Address range: 0x100003d14 - 0x100003dcc
int64_t function_100003d14(void) {
    // 0x100003d14
    int64_t v1; // 0x100003d14
    uint64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 + 8); // 0x100003d38
    int64_t result; // 0x100003d14
    if (*v3 >= v2) {
        // 0x100003dc0
        return result;
    }
    if (v1 == 0) {
        // 0x100003dc0
        return result;
    }
    // 0x100003d98
    int64_t v4; // 0x100003d14
    int64_t v5 = &v4; // 0x100003d64
    int64_t v6; // 0x100003d14
    int64_t result2 = (int64_t)_strdup((char *)v6);
    int64_t v7 = *v3; // 0x100003dac
    *v3 = v7 + 1;
    *(int64_t *)(8 * v7 + *(int64_t *)(v2 + 16)) = result2;
    while (*v3 < result2) {
        // 0x100003d8c
        v5 += 8;
        int64_t v8 = *(int64_t *)v5; // 0x100003d60
        if (v8 == 0) {
            // break -> 0x100003dc0
            break;
        }
        result2 = (int64_t)_strdup((char *)v8);
        v7 = *v3;
        *v3 = v7 + 1;
        *(int64_t *)(8 * v7 + *(int64_t *)(v2 + 16)) = result2;
    }
    // 0x100003dc0
    return result2;
}

// Address range: 0x100003dcc - 0x100003ebc
int64_t entry_point(void) {
    int64_t v1 = function_100003b98(); // 0x100003de8
    function_100003d14();
    int64_t v2; // 0x100003dcc
    _printf("There are %d elements in an array with a capacity of %d elements:\n\n", v2, v2);
    for (int64_t i = 0; i < *(int64_t *)(v1 + 8); i++) {
        // 0x100003e64
        _printf("    the element %d is the string \"%s\"\n", v2, (char *)v2);
    }
    // 0x100003ea4
    function_100003c2c();
    return 0;
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t function_100003ebc(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003ebc
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t * function_100003ec8(int32_t nmemb, int32_t size) {
    // 0x100003ec8
    return _calloc(nmemb, size);
}

// Address range: 0x100003ed4 - 0x100003ee0
void function_100003ed4(int64_t * ptr) {
    // 0x100003ed4
    _free(ptr);
}

// Address range: 0x100003ee0 - 0x100003eec
int32_t function_100003ee0(char * format, ...) {
    // 0x100003ee0
    return _printf(format);
}

// Address range: 0x100003eec - 0x100003ef8
char * function_100003eec(char * s) {
    // 0x100003eec
    return _strdup(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    const char *name, *id, *dept;
    int sal;
} person;

person ppl[] = {
    {"Tyler Bennett",   "E10297", "D101", 32000},
    {"John Rappl",      "E21437", "D050", 47000},
    {"George Woltman",  "E00127", "D101", 53500},
    {"Adam Smith",      "E63535", "D202", 18000},
    {"Claire Buckman",  "E39876", "D202", 27800},
    {"David McClellan", "E04242", "D101", 41500},
    {"Rich Holcomb",    "E01234", "D202", 49500},
    {"Nathan Adams",    "E41298", "D050", 21900},
    {"Richard Potter",  "E43128", "D101", 15900},
    {"David Motsinger", "E27002", "D202", 19250},
    {"Tim Sampair",     "E03033", "D101", 27000},
    {"Kim Arlich",      "E10001", "D190", 57000},
    {"Timothy Grove",   "E16398", "D190", 29900},
};

int pcmp(const void *a, const void *b)
{
    const person *aa = a, *bb = b;
    int x = strcmp(aa->dept, bb->dept);
    if (x) return x;
    return aa->sal > bb->sal ? -1 : aa->sal < bb->sal;
}

#define N sizeof(ppl)/sizeof(person)
void top(int n)
{
    int i, rank;
    qsort(ppl, N, sizeof(person), pcmp);

    for (i = rank = 0; i < N; i++) {
        if (i && strcmp(ppl[i].dept, ppl[i - 1].dept)) {
            rank = 0;
            printf("\n");
        }

        if (rank++ < n)
            printf("%s %d: %s\n", ppl[i].dept, ppl[i].sal, ppl[i].name);
    }
}

int main()
{
    top(2);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c10(void);
int64_t function_100003cd8(void);
int32_t function_100003e58(char * format, ...);
void function_100003e64(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003e70(char * s1, char * s2);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003c10 - 0x100003cd8
int64_t function_100003c10(void) {
    // 0x100003c10
    int64_t v1; // 0x100003c10
    int64_t v2 = *(int64_t *)(v1 + 16); // 0x100003c40
    int32_t v3 = _strcmp((char *)*(int64_t *)(v1 + 16), (char *)v2); // 0x100003c44
    int32_t result = v3; // 0x100003c58
    if (v3 == 0) {
        int32_t v4 = *(int32_t *)(v1 + 24); // 0x100003c70
        int32_t v5 = *(int32_t *)(v1 + 24); // 0x100003c78
        int32_t v6 = v4 - v5; // 0x100003c7c
        result = v6 == 0 | v6 < 0 != ((v6 ^ v4) & (v5 ^ v4)) < 0 ? (int32_t)(v6 < 0 != ((v6 ^ v4) & (v5 ^ v4)) < 0) : -1;
    }
    // 0x100003cc8
    return result;
}

// Address range: 0x100003cd8 - 0x100003e28
int64_t function_100003cd8(void) {
    // 0x100003cd8
    int64_t v1; // 0x100003cd8
    int32_t v2 = v1; // 0x100003ce4
    _qsort((int64_t *)"|>", 13, 32, (int32_t (*)(int64_t *, int64_t *))0x100003c10);
    int32_t v3 = 0;
    int64_t v4 = 0;
    int32_t v5 = v3; // 0x100003d30
    int64_t v6 = &g1; // 0x100003d30
    int64_t v7 = 13; // 0x100003d30
    int64_t v8; // 0x100003d48
    int64_t v9; // 0x100003d4c
    int64_t v10; // 0x100003d64
    int32_t v11; // 0x100003d68
    if (v4 != 0) {
        // 0x100003d38
        v8 = 32 * v4;
        v9 = *(int64_t *)(v8 + (int64_t)"|>" + 16);
        v10 = *(int64_t *)(v8 + (int64_t)"|>" - 16);
        v11 = _strcmp((char *)v9, (char *)v10);
        v5 = v3;
        v6 = 0;
        v7 = v10;
        if (v11 != 0) {
            // 0x100003d7c
            v5 = 0;
            v6 = _printf("\n");
            v7 = v10;
        }
    }
    int64_t v12 = v7;
    int32_t v13 = v5;
    int32_t v14 = v13 - v2; // 0x100003da0
    int64_t v15 = v6; // 0x100003da8
    if (v14 < 0 != ((v14 ^ v13) & (v13 ^ v2)) < 0) {
        // 0x100003db0
        v15 = _printf("%s %d: %s\n", (char *)v12, 32, (char *)0x100003c10);
    }
    int64_t result = v15;
    int64_t v16 = v4 + 1;
    while (v16 != 13) {
        // 0x100003d24
        v3 = v13 + 1;
        v4 = v16;
        v5 = v3;
        v6 = result;
        v7 = v12;
        if (v4 != 0) {
            // 0x100003d38
            v8 = 32 * v4;
            v9 = *(int64_t *)(v8 + (int64_t)"|>" + 16);
            v10 = *(int64_t *)(v8 + (int64_t)"|>" - 16);
            v11 = _strcmp((char *)v9, (char *)v10);
            v5 = v3;
            v6 = 0;
            v7 = v10;
            if (v11 != 0) {
                // 0x100003d7c
                v5 = 0;
                v6 = _printf("\n");
                v7 = v10;
            }
        }
        // 0x100003d90
        v12 = v7;
        v13 = v5;
        v14 = v13 - v2;
        v15 = v6;
        if (v14 < 0 != ((v14 ^ v13) & (v13 ^ v2)) < 0) {
            // 0x100003db0
            v15 = _printf("%s %d: %s\n", (char *)v12, 32, (char *)0x100003c10);
        }
        // 0x100003e0c
        result = v15;
        v16 = v4 + 1;
    }
    // 0x100003e1c
    return result;
}

// Address range: 0x100003e28 - 0x100003e58
int64_t entry_point(void) {
    // 0x100003e28
    function_100003cd8();
    return 0;
}

// Address range: 0x100003e58 - 0x100003e64
int32_t function_100003e58(char * format, ...) {
    // 0x100003e58
    return _printf(format);
}

// Address range: 0x100003e64 - 0x100003e70
void function_100003e64(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003e64
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003e70 - 0x100003e7c
int32_t function_100003e70(char * s1, char * s2) {
    // 0x100003e70
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

#define N 32
#define K 3
#define MAX N * K

typedef struct { int x; int y; } point;

void rot(int n, point *p, int rx, int ry) {
    int t;
    if (!ry) {
        if (rx == 1) {
            p->x = n - 1 - p->x;
            p->y = n - 1 - p->y;
        }
        t = p->x;
        p->x = p->y;
        p->y = t;
    }
}

void d2pt(int n, int d, point *p) {
    int s = 1, t = d, rx, ry;
    p->x = 0;
    p->y = 0;
    while (s < n) {
        rx = 1 & (t / 2);
        ry = 1 & (t ^ rx);
        rot(s, p, rx, ry);
        p->x += s * rx;
        p->y += s * ry;
        t /= 4;
        s *= 2;
    }
}

int main() {
    int d, x, y, cx, cy, px, py;
    char pts[MAX][MAX];
    point curr, prev;
    for (x = 0; x < MAX; ++x)
        for (y = 0; y < MAX; ++y) pts[x][y] = ' ';
    prev.x = prev.y = 0;
    pts[0][0] = '.';
    for (d = 1; d < N * N; ++d) {
        d2pt(N, d, &curr);
        cx = curr.x * K;
        cy = curr.y * K;
        px = prev.x * K;
        py = prev.y * K;
        pts[cx][cy] = '.';
        if (cx == px ) {
            if (py < cy)
                for (y = py + 1; y < cy; ++y) pts[cx][y] = '|';
            else
                for (y = cy + 1; y < py; ++y) pts[cx][y] = '|';
        }
        else {
            if (px < cx)
                for (x = px + 1; x < cx; ++x) pts[x][cy] = '_';
            else
                for (x = cx + 1; x < px; ++x) pts[x][cy] = '_';
        }
        prev = curr;
    }
    for (x = 0; x < MAX; ++x) {
        for (y = 0; y < MAX; ++y) printf("%c", pts[y][x]);
        printf("\n");
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039a8(void);
int64_t function_100003a54(void);
int64_t function_100003b68(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f78(void);
int32_t function_100003f84(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000039a8 - 0x100003a54
int64_t function_1000039a8(void) {
    // 0x1000039a8
    int64_t result; // 0x1000039a8
    if ((int32_t)result != 0) {
        // 0x100003a4c
        return result;
    }
    int32_t * v1 = (int32_t *)result; // 0x1000039b0
    int32_t v2 = result;
    int32_t * v3; // 0x1000039a8
    int32_t v4; // 0x1000039a8
    int32_t v5; // 0x1000039a8
    if ((int32_t)result == 1) {
        int32_t v6 = result; // 0x1000039ac
        *v1 = v6 + -1 - v2;
        int32_t * v7 = (int32_t *)(result + 4);
        int32_t v8 = -1 - *v7 + v6; // 0x100003a10
        *v7 = v8;
        v4 = v8;
        v3 = v7;
        int64_t v9; // 0x1000039a8
        v5 = *(int32_t *)&v9;
    } else {
        int32_t * v10 = (int32_t *)(result + 4); // 0x100003a30
        v4 = *v10;
        v3 = v10;
        v5 = v2;
    }
    // 0x100003a20
    *v1 = v4;
    *v3 = v5;
    // 0x100003a4c
    return result;
}

// Address range: 0x100003a54 - 0x100003b4c
int64_t function_100003a54(void) {
    // 0x100003a54
    int64_t v1; // 0x100003a54
    int32_t v2 = v1; // 0x100003a60
    int32_t * v3 = (int32_t *)v1; // 0x100003a68
    *v3 = 0;
    int32_t * v4 = (int32_t *)(v1 + 4); // 0x100003a88
    *v4 = 0;
    int32_t v5 = 1 - v2; // 0x100003a98
    if (v5 < 0 == (v5 & v2) < 0) {
        // 0x100003b40
        int64_t result; // 0x100003a54
        return result;
    }
    int32_t v6 = v1; // 0x100003a54
    int32_t v7 = 1; // 0x100003b34
    int32_t v8 = v6 / 2; // 0x100003ab0
    int64_t result2 = function_1000039a8(); // 0x100003ae4
    int64_t v9; // 0x100003a54
    *v3 = *(int32_t *)&v9 + v8 % 2 * v7;
    *v4 = *v4 + (v8 ^ v6) % 2 * v7;
    v7 *= 2;
    int32_t v10 = v7 - v2; // 0x100003a98
    v6 /= 4;
    while (v10 < 0 != ((v10 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x100003aa8
        v8 = v6 / 2;
        result2 = function_1000039a8();
        *v3 = *(int32_t *)&v9 + v8 % 2 * v7;
        *v4 = *v4 + (v8 ^ v6) % 2 * v7;
        v7 *= 2;
        v10 = v7 - v2;
        v6 /= 4;
    }
    // 0x100003b40
    return result2;
}

// Address range: 0x100003b4c - 0x100003b68
int64_t entry_point(void) {
    // 0x100003b4c
    return ___chkstk_darwin();
}

// Address range: 0x100003b68 - 0x100003f78
int64_t function_100003b68(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003b68
    int64_t v1; // 0x100003b68
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003b7c
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    int64_t v3; // bp-9224, 0x100003b68
    int64_t v4 = &v3;
    for (int64_t i = 0; i < 96; i++) {
        for (int64_t j = 0; j < 96; j++) {
            // 0x100003bbc
            *(char *)(96 * i + v4 + j) = 32;
        }
    }
    // 0x100003c08
    v3 = 46;
    int32_t v5; // 0x100003b68
    int32_t v6 = 3 * v5;
    int32_t v7 = 3 * v5;
    int64_t v8 = 96 * (int64_t)v6 + v4;
    int64_t v9 = v7;
    int64_t v10 = v4 + v9;
    int32_t v11 = v6 + 1;
    int32_t v12 = -v7;
    int32_t v13 = 1 - v7;
    int32_t v14 = v7 + 1;
    char v15 = 1;
    function_100003a54();
    int32_t v16 = 0; // 0x100003c68
    *(char *)(v8 + v9) = 46;
    int32_t v17; // 0x100003b68
    int32_t v18; // 0x100003b68
    int32_t v19; // 0x100003b68
    int32_t v20; // 0x100003b68
    int32_t v21; // 0x100003b68
    int32_t v22; // 0x100003b68
    int32_t v23; // 0x100003b68
    int32_t v24; // 0x100003b68
    int32_t v25; // 0x100003b68
    int32_t v26; // 0x100003da4
    int32_t v27; // 0x100003e30
    int32_t v28; // 0x100003dcc
    int32_t v29; // 0x100003ce8
    int32_t v30; // 0x100003e30
    int32_t v31; // 0x100003dcc
    if (v16 == v6) {
        if (v12 < 0 == (v7 & v12) < 0) {
            // 0x100003d44
            if (v14 < 0) {
                *(char *)(v8 + (int64_t)v14) = 124;
                v19 = v14 + 1;
                v20 = v19;
                while (v19 < 0) {
                    // 0x100003d5c
                    *(char *)(v8 + (int64_t)v20) = 124;
                    v19 = v20 + 1;
                    v20 = v19;
                }
            }
        } else {
            // 0x100003ce0
            v18 = 1;
            if (v13 < 0 != (v13 & v7) < 0) {
                *(char *)(v8 + (int64_t)v18) = 124;
                v17 = v18 + 1;
                v29 = v17 - v7;
                v18 = v17;
                while (v29 < 0 != ((v29 ^ v17) & (v17 ^ v7)) < 0) {
                    // 0x100003cf8
                    *(char *)(v8 + (int64_t)v18) = 124;
                    v17 = v18 + 1;
                    v29 = v17 - v7;
                    v18 = v17;
                }
            }
        }
    } else {
        // 0x100003d9c
        v26 = v16 - v6;
        if (v26 < 0 == ((v26 ^ v16) & (v16 ^ v6)) < 0) {
            // 0x100003e28
            v27 = v11 - v16;
            if (v27 < 0 != ((v27 ^ v11) & (v16 ^ v11)) < 0) {
                *(char *)(96 * (int64_t)v11 + v10) = 95;
                v24 = v11 + 1;
                v30 = v24 - v16;
                v25 = v24;
                while (v30 < 0 != ((v30 ^ v24) & (v24 ^ v16)) < 0) {
                    // 0x100003e40
                    *(char *)(96 * (int64_t)v25 + v10) = 95;
                    v24 = v25 + 1;
                    v30 = v24 - v16;
                    v25 = v24;
                }
            }
        } else {
            // 0x100003dc4
            v22 = v16 + 1;
            v28 = v22 - v6;
            v23 = v22;
            if (v28 < 0 != ((v28 ^ v22) & (v22 ^ v6)) < 0) {
                *(char *)(96 * (int64_t)v23 + v10) = 95;
                v21 = v23 + 1;
                v31 = v21 - v6;
                v23 = v21;
                while (v31 < 0 != ((v31 ^ v21) & (v21 ^ v6)) < 0) {
                    // 0x100003ddc
                    *(char *)(96 * (int64_t)v23 + v10) = 95;
                    v21 = v23 + 1;
                    v31 = v21 - v6;
                    v23 = v21;
                }
            }
        }
    }
    char v32 = v15 + 1; // 0x100003e90
    int32_t v33 = v32; // 0x100003c24
    int32_t v34 = 0; // 0x100003c30
    while ((1023 - v33 & v33) >= 0) {
        // 0x100003c38
        v15 = v32;
        function_100003a54();
        v16 = 0;
        *(char *)(v8 + v9) = 46;
        if (v16 == v6) {
            if (v12 < 0 == (v7 & v12) < 0) {
                // 0x100003d44
                if (v14 < 0) {
                    *(char *)(v8 + (int64_t)v14) = 124;
                    v19 = v14 + 1;
                    v20 = v19;
                    while (v19 < 0) {
                        // 0x100003d5c
                        *(char *)(v8 + (int64_t)v20) = 124;
                        v19 = v20 + 1;
                        v20 = v19;
                    }
                }
            } else {
                // 0x100003ce0
                v18 = 1;
                if (v13 < 0 != (v13 & v7) < 0) {
                    *(char *)(v8 + (int64_t)v18) = 124;
                    v17 = v18 + 1;
                    v29 = v17 - v7;
                    v18 = v17;
                    while (v29 < 0 != ((v29 ^ v17) & (v17 ^ v7)) < 0) {
                        // 0x100003cf8
                        *(char *)(v8 + (int64_t)v18) = 124;
                        v17 = v18 + 1;
                        v29 = v17 - v7;
                        v18 = v17;
                    }
                }
            }
        } else {
            // 0x100003d9c
            v26 = v16 - v6;
            if (v26 < 0 == ((v26 ^ v16) & (v16 ^ v6)) < 0) {
                // 0x100003e28
                v27 = v11 - v16;
                if (v27 < 0 != ((v27 ^ v11) & (v16 ^ v11)) < 0) {
                    *(char *)(96 * (int64_t)v11 + v10) = 95;
                    v24 = v11 + 1;
                    v30 = v24 - v16;
                    v25 = v24;
                    while (v30 < 0 != ((v30 ^ v24) & (v24 ^ v16)) < 0) {
                        // 0x100003e40
                        *(char *)(96 * (int64_t)v25 + v10) = 95;
                        v24 = v25 + 1;
                        v30 = v24 - v16;
                        v25 = v24;
                    }
                }
            } else {
                // 0x100003dc4
                v22 = v16 + 1;
                v28 = v22 - v6;
                v23 = v22;
                if (v28 < 0 != ((v28 ^ v22) & (v22 ^ v6)) < 0) {
                    *(char *)(96 * (int64_t)v23 + v10) = 95;
                    v21 = v23 + 1;
                    v31 = v21 - v6;
                    v23 = v21;
                    while (v31 < 0 != ((v31 ^ v21) & (v21 ^ v6)) < 0) {
                        // 0x100003ddc
                        *(char *)(96 * (int64_t)v23 + v10) = 95;
                        v21 = v23 + 1;
                        v31 = v21 - v6;
                        v23 = v21;
                    }
                }
            }
        }
        // 0x100003e80
        v32 = v15 + 1;
        v33 = v32;
        v34 = 0;
    }
    for (int32_t i = 0; i < 96; i++) {
        // 0x100003ed4
        _printf("%c", v15);
    }
    // 0x100003f1c
    _printf((char *)0x100003f93);
    while (v34 != 95) {
        // continue -> 0x100003ec0
        continue;
    }
    // 0x100003f3c
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003f5c
        ___stack_chk_fail();
    }
    // 0x100003f60
    return 0;
}

// Address range: 0x100003f78 - 0x100003f84
int64_t function_100003f78(void) {
    // 0x100003f78
    return ___stack_chk_fail();
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

int verbose = 0;
enum {
	clown = -1,
	abe, bob, col, dan, ed, fred, gav, hal, ian, jon,
	abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan,
};
const char *name[] = {
	"Abe", "Bob", "Col",  "Dan", "Ed",  "Fred", "Gav", "Hal",  "Ian", "Jon",
	"Abi", "Bea", "Cath", "Dee", "Eve", "Fay",  "Gay", "Hope", "Ivy", "Jan"
};
int pref[jan + 1][jon + 1] = {
	{ abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay },
	{ cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay },
	{ hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan },
	{ ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi },
	{ jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay },
	{ bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay },
	{ gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay },
	{ abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee },
	{ hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve },
	{ abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope },

	{ bob, fred, jon, gav, ian, abe, dan, ed, col, hal   },
	{ bob, abe, col, fred, gav, dan, ian, ed, jon, hal   },
	{ fred, bob, ed, gav, hal, col, ian, abe, dan, jon   },
	{ fred, jon, col, abe, ian, hal, gav, dan, bob, ed   },
	{ jon, hal, fred, dan, abe, gav, col, ed, ian, bob   },
	{ bob, abe, ed, ian, jon, dan, fred, gav, col, hal   },
	{ jon, gav, hal, fred, bob, abe, col, ed, dan, ian   },
	{ gav, jon, bob, abe, ian, dan, hal, ed, col, fred   },
	{ ian, col, hal, gav, fred, bob, abe, ed, jon, dan   },
	{ ed, hal, gav, abe, bob, jon, col, ian, fred, dan   },
};
int pairs[jan + 1], proposed[jan + 1];

void engage(int man, int woman)
{
	pairs[man] = woman;
	pairs[woman] = man;
	if (verbose) printf("%4s is engaged to %4s\n", name[man], name[woman]);
}

void dump(int woman, int man)
{
	pairs[man] = pairs[woman] = clown;
	if (verbose) printf("%4s dumps %4s\n", name[woman], name[man]);
}

/* how high this person ranks that: lower is more preferred */
int rank(int this, int that)
{
	int i;
	for (i = abe; i <= jon && pref[this][i] != that; i++);
	return i;
}

void propose(int man, int woman)
{
	int fiance = pairs[woman];
	if (verbose) printf("%4s proposes to %4s\n", name[man], name[woman]);

	if (fiance == clown) {
		engage(man, woman);
	} else if (rank(woman, man) < rank(woman, fiance)) {
		dump(woman, fiance);
		engage(man, woman);
	}
}

int covet(int man1, int wife2)
{
	if (rank(man1, wife2) < rank(man1, pairs[man1]) &&
			rank(wife2, man1) < rank(wife2, pairs[wife2])) {
		printf( "    %4s (w/ %4s) and %4s (w/ %4s) prefer each other"
			" over current pairing.\n",
			name[man1], name[pairs[man1]], name[wife2], name[pairs[wife2]]
		);
		return 1;
	}
	return 0;
}

int thy_neighbors_wife(int man1, int man2)
{	/* +: force checking all pairs; "||" would shortcircuit */
	return covet(man1, pairs[man2]) + covet(man2, pairs[man1]);
}

int unstable()
{
	int i, j, bad = 0;
	for (i = abe; i < jon; i++) {
		for (j = i + 1; j <= jon; j++)
			if (thy_neighbors_wife(i, j)) bad = 1;
	}
	return bad;
}

int main()
{
	int i, unengaged;
	/* init: everyone marries the clown */
	for (i = abe; i <= jan; i++)
		pairs[i] = proposed[i] = clown;

	/* rounds */
	do {
		unengaged = 0;
		for (i = abe; i <= jon; i++) {
		//for (i = abi; i <= jan; i++) { /* could let women propose */
			if (pairs[i] != clown) continue;
			unengaged = 1;
			propose(i, pref[i][++proposed[i]]);
		}
	} while (unengaged);

	printf("Pairing:\n");
	for (i = abe; i <= jon; i++)
		printf("  %4s - %s\n", name[i],
			pairs[i] == clown ? "clown" : name[pairs[i]]);

	printf(unstable()
		? "Marriages not stable\n" /* draw sad face here */
		: "Stable matchup\n");

	printf("\nBut if Bob and Fred were to swap:\n");
	i = pairs[bob];
	engage(bob, pairs[fred]);
	engage(fred, i);
	printf(unstable() ? "Marriages not stable\n" : "Stable matchup\n");

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003708(void);
int64_t function_100003794(void);
int64_t function_10000381c(void);
int64_t function_1000038ac(void);
int64_t function_1000039a4(void);
int64_t function_100003ab4(void);
int64_t function_100003b14(void);
int32_t function_100003e54(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0xe0000000a; // 0x1000080a0
int32_t g2 = -0x1120531; // 0x1000083c0
int32_t * g3 = (int32_t *)0x100000c; // 0x1000083c4
int32_t * g4 = NULL; // 0x100008414

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003708 - 0x100003794
int64_t function_100003708(void) {
    // 0x100003708
    int64_t v1; // 0x100003708
    *(int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g3) = (int32_t)v1;
    *(int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g3) = (int32_t)v1;
    int64_t result; // 0x100003708
    if (g2 != 0) {
        // 0x100003754
        result = _printf("%4s is engaged to %4s\n", (char *)v1, (char *)v1);
    }
    // 0x100003788
    return result;
}

// Address range: 0x100003794 - 0x10000381c
int64_t function_100003794(void) {
    // 0x100003794
    int64_t v1; // 0x100003794
    *(int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g3) = -1;
    *(int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g3) = -1;
    int64_t result; // 0x100003794
    if (g2 != 0) {
        // 0x1000037dc
        result = _printf("%4s dumps %4s\n", (char *)v1, (char *)v1);
    }
    // 0x100003810
    return result;
}

// Address range: 0x10000381c - 0x1000038ac
int64_t function_10000381c(void) {
    // 0x10000381c
    int64_t v1; // 0x10000381c
    int64_t v2 = 40 * (0x100000000 * v1 >> 32) + (int64_t)&g1;
    int32_t v3 = 0;
    int32_t result = v3; // 0x100003884
    while (*(int32_t *)(v2 + 4 * (int64_t)v3) != (int32_t)v1) {
        int32_t v4 = v3 + 1; // 0x100003894
        int32_t v5 = v3 - 8; // 0x100003834
        result = v4;
        if (v5 != 0 && v5 < 0 == (7 - v3 & v4) < 0) {
            // break -> 0x1000038a0
            break;
        }
        v3 = v4;
        result = v3;
    }
    // 0x1000038a0
    return result;
}

// Address range: 0x1000038ac - 0x1000039a4
int64_t function_1000038ac(void) {
    // 0x1000038ac
    int64_t v1; // 0x1000038ac
    if (g2 != 0) {
        // 0x1000038ec
        _printf("%4s proposes to %4s\n", (char *)v1, (char *)v1);
    }
    if (*(int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g3) == -1) {
        // 0x100003998
        return function_100003708();
    }
    int64_t v2 = function_10000381c(); // 0x10000394c
    int64_t v3 = function_10000381c(); // 0x10000395c
    int32_t v4 = v2; // 0x100003968
    int32_t v5 = v4 - (int32_t)v3; // 0x100003968
    int64_t result = v2 & 0xffffffff; // 0x100003970
    if (v5 < 0 != ((v5 ^ v4) & (int32_t)(v3 ^ v2)) < 0) {
        // 0x100003978
        function_100003794();
        result = function_100003708();
    }
    // 0x100003998
    return result;
}

// Address range: 0x1000039a4 - 0x100003ab4
int64_t function_1000039a4(void) {
    int64_t v1 = function_10000381c(); // 0x1000039c0
    int32_t v2 = v1; // 0x1000039c4
    int64_t v3 = function_10000381c(); // 0x1000039dc
    int32_t v4 = v2 - (int32_t)v3; // 0x1000039e8
    if (v4 < 0 == ((v4 ^ v2) & (int32_t)(v3 ^ v1)) < 0) {
        // 0x100003aa4
        return 0;
    }
    int64_t v5 = function_10000381c(); // 0x100003a00
    int32_t v6 = v5; // 0x100003a04
    int64_t v7; // 0x1000039a4
    uint32_t v8 = *(int32_t *)((0x100000000 * v7 >> 30) + (int64_t)&g3); // 0x100003a18
    int64_t v9 = function_10000381c(); // 0x100003a1c
    int32_t v10 = v6 - (int32_t)v9; // 0x100003a28
    int64_t result = 0; // 0x100003a30
    if (v10 < 0 != ((v10 ^ v6) & (int32_t)(v9 ^ v5)) < 0) {
        // 0x100003a38
        _printf("    %4s (w/ %4s) and %4s (w/ %4s) prefer each other over current pairing.\n", (char *)(int64_t)v8, (char *)v7, (char *)v7, (char *)v7);
        result = 1;
    }
    // 0x100003aa4
    return result;
}

// Address range: 0x100003ab4 - 0x100003b14
int64_t function_100003ab4(void) {
    int64_t v1 = function_1000039a4(); // 0x100003ae0
    return function_1000039a4() + v1 & 0xffffffff;
}

// Address range: 0x100003b14 - 0x100003bc4
int64_t function_100003b14(void) {
    int32_t v1 = 0;
    v1++;
    int32_t v2 = v1;
    int32_t result = (int32_t)function_100003ab4() == 0 ? 0 : 1;
    int32_t v3 = v2 + 1;
    int32_t v4 = v2 - 8; // 0x100003b54
    int32_t v5 = result; // 0x100003b5c
    while (v4 == 0 || v4 < 0 != (v3 & 7 - v2) < 0) {
        // 0x100003b64
        v2 = v3;
        result = (int32_t)function_100003ab4() == 0 ? v5 : 1;
        v3 = v2 + 1;
        v4 = v2 - 8;
        v5 = result;
    }
    while (v1 != 9) {
        // 0x100003b64
        v1++;
        v2 = v1;
        result = (int32_t)function_100003ab4() == 0 ? result : 1;
        v3 = v2 + 1;
        v4 = v2 - 8;
        v5 = result;
        while (v4 == 0 || v4 < 0 != (v3 & 7 - v2) < 0) {
            // 0x100003b64
            v2 = v3;
            result = (int32_t)function_100003ab4() == 0 ? v5 : 1;
            v3 = v2 + 1;
            v4 = v2 - 8;
            v5 = result;
        }
    }
    // 0x100003bb4
    return result;
}

// Address range: 0x100003bc4 - 0x100003e54
int64_t entry_point(void) {
    int32_t v1 = 0;
    int64_t v2 = 4 * (int64_t)v1; // 0x100003c00
    *(int32_t *)(v2 + (int64_t)&g4) = -1;
    *(int32_t *)(v2 + (int64_t)&g3) = -1;
    int32_t v3 = v1 + 1; // 0x100003c1c
    while (v1 == 18 || v1 < 18 != (17 - v1 & v3) < 0) {
        // 0x100003bf0
        v1 = v3;
        v2 = 4 * (int64_t)v1;
        *(int32_t *)(v2 + (int64_t)&g4) = -1;
        *(int32_t *)(v2 + (int64_t)&g3) = -1;
        v3 = v1 + 1;
    }
    int32_t v4 = 0;
    int64_t v5 = v4; // 0x100003c4c
    int64_t v6 = 4 * v5; // 0x100003c58
    int32_t v7 = 0; // 0x100003c64
    int64_t v8; // 0x100003bc4
    int64_t v9 = v8; // 0x100003c64
    int32_t v10; // 0x100003ca8
    uint32_t v11; // 0x100003cb0
    int32_t * v12; // 0x100003ca4
    if (*(int32_t *)(v6 + (int64_t)&g3) == -1) {
        // 0x100003c70
        v12 = (int32_t *)(v6 + (int64_t)&g4);
        v10 = *v12 + 1;
        *v12 = v10;
        v11 = *(int32_t *)(40 * v5 + (int64_t)&g1 + (int64_t)(4 * v10));
        function_1000038ac();
        v7 = 1;
        v9 = v11;
    }
    int64_t v13 = v9;
    int32_t v14 = v7;
    int32_t v15 = v4 + 1; // 0x100003cc0
    int32_t v16 = v4 - 8; // 0x100003c3c
    while (v16 == 0 || v16 < 0 != (7 - v4 & v15) < 0) {
        // 0x100003c4c
        v4 = v15;
        v5 = v4;
        v6 = 4 * v5;
        v7 = v14;
        v9 = v13;
        if (*(int32_t *)(v6 + (int64_t)&g3) == -1) {
            // 0x100003c70
            v12 = (int32_t *)(v6 + (int64_t)&g4);
            v10 = *v12 + 1;
            *v12 = v10;
            v11 = *(int32_t *)(40 * v5 + (int64_t)&g1 + (int64_t)(4 * v10));
            function_1000038ac();
            v7 = 1;
            v9 = v11;
        }
        // 0x100003cbc
        v13 = v9;
        v14 = v7;
        v15 = v4 + 1;
        v16 = v4 - 8;
    }
    // 0x100003cd0
    while (v14 != 0) {
        // 0x100003c2c
        v4 = 0;
        v5 = v4;
        v6 = 4 * v5;
        v7 = 0;
        v9 = v13;
        if (*(int32_t *)(v6 + (int64_t)&g3) == -1) {
            // 0x100003c70
            v12 = (int32_t *)(v6 + (int64_t)&g4);
            v10 = *v12 + 1;
            *v12 = v10;
            v11 = *(int32_t *)(40 * v5 + (int64_t)&g1 + (int64_t)(4 * v10));
            function_1000038ac();
            v7 = 1;
            v9 = v11;
        }
        // 0x100003cbc
        v13 = v9;
        v14 = v7;
        v15 = v4 + 1;
        v16 = v4 - 8;
        while (v16 == 0 || v16 < 0 != (7 - v4 & v15) < 0) {
            // 0x100003c4c
            v4 = v15;
            v5 = v4;
            v6 = 4 * v5;
            v7 = v14;
            v9 = v13;
            if (*(int32_t *)(v6 + (int64_t)&g3) == -1) {
                // 0x100003c70
                v12 = (int32_t *)(v6 + (int64_t)&g4);
                v10 = *v12 + 1;
                *v12 = v10;
                v11 = *(int32_t *)(40 * v5 + (int64_t)&g1 + (int64_t)(4 * v10));
                function_1000038ac();
                v7 = 1;
                v9 = v11;
            }
            // 0x100003cbc
            v13 = v9;
            v14 = v7;
            v15 = v4 + 1;
            v16 = v4 - 8;
        }
    }
    // 0x100003ce4
    _printf("Pairing:\n");
    int32_t v17 = 0;
    int64_t v18; // 0x100003bc4
    _printf("  %4s - %s\n", (char *)v13, (char *)v18);
    int32_t v19 = v17 + 1; // 0x100003d9c
    while (v17 == 8 || v17 < 8 != (7 - v17 & v19) < 0) {
        // 0x100003d0c
        v17 = v19;
        _printf("  %4s - %s\n", (char *)v13, (char *)v18);
        v19 = v17 + 1;
    }
    // 0x100003da8
    _printf((int32_t)function_100003b14() == 0 ? "Stable matchup\n" : "Marriages not stable\n");
    _printf("\nBut if Bob and Fred were to swap:\n");
    function_100003708();
    function_100003708();
    _printf((int32_t)function_100003b14() == 0 ? "Stable matchup\n" : "Marriages not stable\n");
    return 0;
}

// Address range: 0x100003e54 - 0x100003e60
int32_t function_100003e54(char * format, ...) {
    // 0x100003e54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef __GNUC__
#include <setjmp.h>
struct LOOP_T; typedef struct LOOP_T LOOP;
struct LOOP_T {
    jmp_buf b; LOOP * p;
} LOOP_base, * LOOP_V = &LOOP_base;
#define FOR(I, C, A, ACT) (LOOP_V = &(LOOP){ .p = LOOP_V }, \
                           (I), setjmp(LOOP_V->b), \
                           ((C) ? ((ACT),(A), longjmp(LOOP_V->b, 1), 0) : 0), \
                           LOOP_V = LOOP_V->p, 0)
#else
#define FOR(I, C, A, ACT) (({for(I;C;A){ACT;}}), 0)    // GNU version
#endif

typedef struct List { struct List * nx; char val[]; } List;
typedef struct { int _1, _2, _3; } Triple;

#define SEQ(OUT, SETS, PRED) (SEQ_var=&(ITERATOR){.l=NULL,.p=SEQ_var}, \
                              M_FFOLD(((PRED)?APPEND(OUT):0),M_ID SETS), \
                              SEQ_var->p->old=SEQ_var->l,SEQ_var=SEQ_var->p,SEQ_var->old)
typedef struct ITERATOR { List * l, * old; struct ITERATOR * p; } ITERATOR;
ITERATOR * FE_var, SEQ_base, * SEQ_var = &SEQ_base;
#define FOR_EACH(V, T, L, ACT) (FE_var=&(ITERATOR){.l=(L),.p=FE_var}, \
                                FOR((V) = *(T*)&FE_var->l->val, FE_var->l?((V)=*(T*)&FE_var->l->val,1):0, \
                                FE_var->l=FE_var->l->nx, ACT), FE_var=FE_var->p)

#define M_FFOLD(ID, ...) M_ID(M_CONC(M_FFOLD_, M_NARGS(__VA_ARGS__)) (ID, __VA_ARGS__))
#define FORSET(V, T, L) V, T, L
#define APPEND(T, val) (SEQ_var->l?listAppend(SEQ_var->l,sizeof(T),&val):(SEQ_var->l=listNew(sizeof(T),&val)))

#define M_FFOLD_1(ID, E) FOR_EACH M_IDP(FORSET E, ID)
#define M_FFOLD_2(ID, E, ...) FOR_EACH M_IDP(FORSET E, M_FFOLD_1(ID, __VA_ARGS__))
#define M_FFOLD_3(ID, E, ...) FOR_EACH M_IDP(FORSET E, M_FFOLD_2(ID, __VA_ARGS__))  //...

#define M_NARGS(...) M_NARGS_(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
#define M_NARGS_(_10, _9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) N
#define M_CONC(A, B) M_CONC_(A, B)
#define M_CONC_(A, B) A##B
#define M_ID(...) __VA_ARGS__
#define M_IDP(...) (__VA_ARGS__)

#define R(f, t) int,intRangeList(f, t)
#define T(a, b, c) Triple,((Triple){(a),(b),(c)})

List * listNew(int sz, void * val) {
 List * l = malloc(sizeof(List) + sz); l->nx = NULL; memcpy(l->val, val, sz); return l;
}
List * listAppend(List * l, int sz, void * val) {
 while (l->nx) { l = l->nx; } l->nx = listNew(sz, val); return l;
}
List * intRangeList(int f, int t) {
 List * l = listNew(sizeof f, &f), * e = l;
 for (int i = f + 1; i <= t; i ++) { e = e->nx = listNew(sizeof i, &i); } // C11 compliant
//int i;
//for (i = f + 1; i <= t; i ++) { e = e->nx = listNew(sizeof i, &i); }    // use this for C99
 return l;
}

int main(void) {
    volatile int x, y, z; const int n = 20;

    List * pTriples = SEQ(
                          T(x, y, z),
                          (
                           (x, R(1, n)),
                           (y, R(x, n)),
                           (z, R(y, n))
                          ),
                          (x*x + y*y == z*z)
                         );

    volatile Triple t;
    FOR_EACH(t, Triple, pTriples,  printf("%d, %d, %d\n", t._1, t._2, t._3)  );

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003928(void);
int64_t function_10000397c(void);
int64_t function_1000039e4(void);
int64_t function_100003f64(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t * function_100003f70(int32_t size);
int64_t * function_100003f7c(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f88(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x8010; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003928 - 0x10000397c
int64_t function_100003928(void) {
    // 0x100003928
    int64_t v1; // 0x100003928
    int32_t v2 = v1; // 0x100003934
    int64_t * v3 = _malloc(v2 + 8); // 0x100003944
    int64_t result = (int64_t)v3; // 0x100003944
    *v3 = 0;
    ___memcpy_chk(result + 8, v1, v2, -1);
    return result;
}

// Address range: 0x10000397c - 0x1000039e4
int64_t function_10000397c(void) {
    int64_t v1; // 0x10000397c
    int64_t result = v1;
    int64_t * v2 = (int64_t *)result;
    int64_t v3 = *v2; // 0x10000399c
    while (v3 != 0) {
        // 0x100003998
        result = v3;
        v2 = (int64_t *)result;
        v3 = *v2;
    }
    // 0x1000039c0
    *v2 = function_100003928();
    return result;
}

// Address range: 0x1000039e4 - 0x100003a7c
int64_t function_1000039e4(void) {
    // 0x1000039e4
    int64_t v1; // 0x1000039e4
    int32_t v2 = v1; // 0x1000039fc
    int64_t result = function_100003928(); // 0x100003a04
    int32_t v3 = (int32_t)v1 + 1;
    int32_t v4 = v3 - v2; // 0x100003a2c
    int32_t v5 = v3; // 0x100003a34
    if (v4 != 0 && v4 < 0 == ((v4 ^ v3) & (v3 ^ v2)) < 0) {
        // 0x100003a6c
        return result;
    }
    int64_t v6 = function_100003928(); // 0x100003a44
    *(int64_t *)result = v6;
    v5++;
    while (v5 - v2 == 0 || v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        int64_t v7 = v6;
        v6 = function_100003928();
        *(int64_t *)v7 = v6;
        v5++;
    }
    // 0x100003a6c
    return result;
}

// Address range: 0x100003a7c - 0x100003f64
int64_t entry_point(void) {
    int64_t v1 = 0; // bp-88, 0x100003a9c
    g1 = &v1;
    int64_t v2 = function_1000039e4(); // 0x100003ab8
    int64_t v3 = v2; // bp-112, 0x100003ac0
    int64_t v4 = &v3; // 0x100003ad8
    g2 = v4;
    int64_t v5 = v4; // 0x100003b08
    if (v2 != 0) {
        // 0x100003b10
        int64_t v6; // bp-136, 0x100003a7c
        int64_t v7 = &v6;
        int64_t v8; // bp-160, 0x100003a7c
        int64_t v9 = &v8;
        int32_t v10 = *(int32_t *)(v2 + 8); // 0x100003b24
        int64_t v11 = function_1000039e4(); // 0x100003b5c
        v6 = v11;
        g2 = v7;
        int64_t v12 = v7; // 0x100003bac
        int64_t v13; // 0x100003a7c
        int32_t v14; // 0x100003a7c
        int32_t v15; // 0x100003bc8
        int64_t v16; // 0x100003c00
        int64_t v17; // 0x100003d90
        int64_t * v18; // 0x100003da8
        int64_t v19; // 0x100003ba0
        int32_t v20; // 0x100003c6c
        int64_t * v21; // 0x100003d70
        int64_t v22; // 0x100003c44
        int64_t v23; // 0x100003d44
        if (v11 != 0) {
            // 0x100003bb4
            v14 = v10 * v10;
            v15 = *(int32_t *)(v11 + 8);
            v16 = function_1000039e4();
            v8 = v16;
            g2 = v9;
            v13 = v9;
            if (v16 != 0) {
                // 0x100003c58
                v20 = *(int32_t *)(v16 + 8);
                if (v15 * v15 + v14 == v20 * v20) {
                    // 0x100003cd4
                    if (*(int64_t *)g1 == 0) {
                        // 0x100003d24
                        v23 = function_100003928();
                        *(int64_t *)g1 = v23;
                    } else {
                        // 0x100003cf0
                        function_10000397c();
                    }
                }
                // 0x100003d64
                v21 = (int64_t *)g2;
                *v21 = *(int64_t *)*v21;
                v22 = *(int64_t *)g2;
                v13 = g2;
                while (v22 != 0) {
                    // 0x100003c58
                    v20 = *(int32_t *)(v22 + 8);
                    if (v15 * v15 + v14 == v20 * v20) {
                        // 0x100003cd4
                        if (*(int64_t *)g1 == 0) {
                            // 0x100003d24
                            v23 = function_100003928();
                            *(int64_t *)g1 = v23;
                        } else {
                            // 0x100003cf0
                            function_10000397c();
                        }
                    }
                    // 0x100003d64
                    v21 = (int64_t *)g2;
                    *v21 = *(int64_t *)*v21;
                    v22 = *(int64_t *)g2;
                    v13 = g2;
                }
            }
            // 0x100003d84
            v17 = *(int64_t *)(v13 + 16);
            g2 = v17;
            v18 = (int64_t *)v17;
            *v18 = *(int64_t *)*v18;
            v19 = *(int64_t *)g2;
            v12 = g2;
            while (v19 != 0) {
                // 0x100003bb4
                v15 = *(int32_t *)(v19 + 8);
                v16 = function_1000039e4();
                v8 = v16;
                g2 = v9;
                v13 = v9;
                if (v16 != 0) {
                    // 0x100003c58
                    v20 = *(int32_t *)(v16 + 8);
                    if (v15 * v15 + v14 == v20 * v20) {
                        // 0x100003cd4
                        if (*(int64_t *)g1 == 0) {
                            // 0x100003d24
                            v23 = function_100003928();
                            *(int64_t *)g1 = v23;
                        } else {
                            // 0x100003cf0
                            function_10000397c();
                        }
                    }
                    // 0x100003d64
                    v21 = (int64_t *)g2;
                    *v21 = *(int64_t *)*v21;
                    v22 = *(int64_t *)g2;
                    v13 = g2;
                    while (v22 != 0) {
                        // 0x100003c58
                        v20 = *(int32_t *)(v22 + 8);
                        if (v15 * v15 + v14 == v20 * v20) {
                            // 0x100003cd4
                            if (*(int64_t *)g1 == 0) {
                                // 0x100003d24
                                v23 = function_100003928();
                                *(int64_t *)g1 = v23;
                            } else {
                                // 0x100003cf0
                                function_10000397c();
                            }
                        }
                        // 0x100003d64
                        v21 = (int64_t *)g2;
                        *v21 = *(int64_t *)*v21;
                        v22 = *(int64_t *)g2;
                        v13 = g2;
                    }
                }
                // 0x100003d84
                v17 = *(int64_t *)(v13 + 16);
                g2 = v17;
                v18 = (int64_t *)v17;
                *v18 = *(int64_t *)*v18;
                v19 = *(int64_t *)g2;
                v12 = g2;
            }
        }
        int64_t v24 = *(int64_t *)(v12 + 16); // 0x100003dc8
        g2 = v24;
        int64_t * v25 = (int64_t *)v24; // 0x100003de0
        *v25 = *(int64_t *)*v25;
        int64_t v26 = *(int64_t *)g2; // 0x100003afc
        v5 = g2;
        while (v26 != 0) {
            // 0x100003b10
            v10 = *(int32_t *)(v26 + 8);
            v11 = function_1000039e4();
            v6 = v11;
            g2 = v7;
            v12 = v7;
            if (v11 != 0) {
                // 0x100003bb4
                v14 = v10 * v10;
                v15 = *(int32_t *)(v11 + 8);
                v16 = function_1000039e4();
                v8 = v16;
                g2 = v9;
                v13 = v9;
                if (v16 != 0) {
                    // 0x100003c58
                    v20 = *(int32_t *)(v16 + 8);
                    if (v15 * v15 + v14 == v20 * v20) {
                        // 0x100003cd4
                        if (*(int64_t *)g1 == 0) {
                            // 0x100003d24
                            v23 = function_100003928();
                            *(int64_t *)g1 = v23;
                        } else {
                            // 0x100003cf0
                            function_10000397c();
                        }
                    }
                    // 0x100003d64
                    v21 = (int64_t *)g2;
                    *v21 = *(int64_t *)*v21;
                    v22 = *(int64_t *)g2;
                    v13 = g2;
                    while (v22 != 0) {
                        // 0x100003c58
                        v20 = *(int32_t *)(v22 + 8);
                        if (v15 * v15 + v14 == v20 * v20) {
                            // 0x100003cd4
                            if (*(int64_t *)g1 == 0) {
                                // 0x100003d24
                                v23 = function_100003928();
                                *(int64_t *)g1 = v23;
                            } else {
                                // 0x100003cf0
                                function_10000397c();
                            }
                        }
                        // 0x100003d64
                        v21 = (int64_t *)g2;
                        *v21 = *(int64_t *)*v21;
                        v22 = *(int64_t *)g2;
                        v13 = g2;
                    }
                }
                // 0x100003d84
                v17 = *(int64_t *)(v13 + 16);
                g2 = v17;
                v18 = (int64_t *)v17;
                *v18 = *(int64_t *)*v18;
                v19 = *(int64_t *)g2;
                v12 = g2;
                while (v19 != 0) {
                    // 0x100003bb4
                    v15 = *(int32_t *)(v19 + 8);
                    v16 = function_1000039e4();
                    v8 = v16;
                    g2 = v9;
                    v13 = v9;
                    if (v16 != 0) {
                        // 0x100003c58
                        v20 = *(int32_t *)(v16 + 8);
                        if (v15 * v15 + v14 == v20 * v20) {
                            // 0x100003cd4
                            if (*(int64_t *)g1 == 0) {
                                // 0x100003d24
                                v23 = function_100003928();
                                *(int64_t *)g1 = v23;
                            } else {
                                // 0x100003cf0
                                function_10000397c();
                            }
                        }
                        // 0x100003d64
                        v21 = (int64_t *)g2;
                        *v21 = *(int64_t *)*v21;
                        v22 = *(int64_t *)g2;
                        v13 = g2;
                        while (v22 != 0) {
                            // 0x100003c58
                            v20 = *(int32_t *)(v22 + 8);
                            if (v15 * v15 + v14 == v20 * v20) {
                                // 0x100003cd4
                                if (*(int64_t *)g1 == 0) {
                                    // 0x100003d24
                                    v23 = function_100003928();
                                    *(int64_t *)g1 = v23;
                                } else {
                                    // 0x100003cf0
                                    function_10000397c();
                                }
                            }
                            // 0x100003d64
                            v21 = (int64_t *)g2;
                            *v21 = *(int64_t *)*v21;
                            v22 = *(int64_t *)g2;
                            v13 = g2;
                        }
                    }
                    // 0x100003d84
                    v17 = *(int64_t *)(v13 + 16);
                    g2 = v17;
                    v18 = (int64_t *)v17;
                    *v18 = *(int64_t *)*v18;
                    v19 = *(int64_t *)g2;
                    v12 = g2;
                }
            }
            // 0x100003dbc
            v24 = *(int64_t *)(v12 + 16);
            g2 = v24;
            v25 = (int64_t *)v24;
            *v25 = *(int64_t *)*v25;
            v26 = *(int64_t *)g2;
            v5 = g2;
        }
    }
    // 0x100003df4
    g2 = *(int64_t *)(v5 + 16);
    int64_t v27 = g1;
    *(int64_t *)(*(int64_t *)(v27 + 16) + 8) = *(int64_t *)v27;
    int64_t v28 = *(int64_t *)(g1 + 16); // 0x100003e24
    g1 = v28;
    int64_t v29 = *(int64_t *)(v28 + 8); // 0x100003e30
    int64_t v30 = v29; // bp-224, 0x100003e40
    g2 = &v30;
    int64_t v31; // bp-196, 0x100003a7c
    _memcpy(&v31, (int64_t *)(v29 + 8), 12);
    int64_t v32 = g2; // 0x100003e78
    int64_t v33 = *(int64_t *)v32; // 0x100003e7c
    if (v33 == 0) {
        // 0x100003f3c
        g2 = *(int64_t *)(v32 + 16);
        return 0;
    }
    int64_t v34 = v33 + 8; // 0x100003ea8
    _memcpy(&v31, (int64_t *)v34, 12);
    int64_t v35; // 0x100003a7c
    _printf("%d, %d, %d\n", v34, 12, v35);
    int64_t * v36 = (int64_t *)g2; // 0x100003f28
    *v36 = *(int64_t *)*v36;
    int64_t v37 = *(int64_t *)g2; // 0x100003e7c
    while (v37 != 0) {
        // 0x100003e90
        v34 = v37 + 8;
        _memcpy(&v31, (int64_t *)v34, 12);
        _printf("%d, %d, %d\n", v34, 12, v35);
        v36 = (int64_t *)g2;
        *v36 = *(int64_t *)*v36;
        v37 = *(int64_t *)g2;
    }
    // 0x100003f3c
    g2 += 16;
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int64_t function_100003f64(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    // 0x100003f64
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f70 - 0x100003f7c
int64_t * function_100003f70(int32_t size) {
    // 0x100003f70
    return _malloc(size);
}

// Address range: 0x100003f7c - 0x100003f88
int64_t * function_100003f7c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f7c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <math.h>
#include <stdio.h>
#include <limits.h>
#pragma precision=log10l(ULLONG_MAX)/2

typedef enum { FALSE=0, TRUE=1 } BOOL;

BOOL is_prime( int p ){
  if( p == 2 ) return TRUE;
  else if( p <= 1 || p % 2 == 0 ) return FALSE;
  else {
    BOOL prime = TRUE;
    const int to = sqrt(p);
    int i;
    for(i = 3; i <= to; i+=2)
      if (!(prime = p % i))break;
    return prime;
  }
}

BOOL is_mersenne_prime( int p ){
  if( p == 2 ) return TRUE;
  else {
    const long long unsigned m_p = ( 1LLU << p ) - 1;
    long long unsigned s = 4;
    int i;
    for (i = 3; i <= p; i++){
      s = (s * s - 2) % m_p;
    }
    return s == 0;
  }
}

int main(int argc, char **argv){

  const int upb = log2l(ULLONG_MAX)/2;
  int p;
  printf(" Mersenne primes:\n");
  for( p = 2; p <= upb; p += 1 ){
    if( is_prime(p) && is_mersenne_prime(p) ){
      printf (" M%u",p);
    }
  }
  printf("\n");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cac(void);
int64_t function_100003db4(void);
float64_t function_100003f60(float64_t a1);
int32_t function_100003f6c(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t g1 = 1.8446744073709552e+19; // 0x100003f78

// ------- Dynamically Linked Functions Without Header --------

float64_t _log2(float64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cac - 0x100003db4
int64_t function_100003cac(void) {
    // 0x100003cac
    int64_t v1; // 0x100003cac
    int32_t v2 = v1; // 0x100003cb0
    if (v2 == 2) {
        // 0x100003da8
        return 1;
    }
    int32_t v3 = v2 - 1; // 0x100003cd8
    if (v3 == 0 || v3 < 0 != (v2 & -v2) < 0 || 2 * v2 / 2 == v2) {
        // 0x100003da8
        return 0;
    }
    // 0x100003d14
    __asm_sshll(0.0f, 0);
    float64_t v4; // 0x100003cac
    int32_t v5 = sqrt(v4); // 0x100003d30
    int32_t v6 = 3 - v5; // 0x100003d4c
    if (v6 != 0 && v6 < 0 == (v6 & v5) < 0) {
        // 0x100003da8
        return 1;
    }
    int32_t v7 = 3; // 0x100003d54
    int32_t v8 = v2 % v7;
    int32_t result = 0; // 0x100003d7c
    while (v8 != 0) {
        // 0x100003d44
        v7 += 2;
        int32_t v9 = v7 - v5; // 0x100003d4c
        result = v8;
        if (v9 != 0 && v9 < 0 == ((v9 ^ v7) & (v7 ^ v5)) < 0) {
            // break -> 0x100003da8
            break;
        }
        v8 = v2 % v7;
        result = 0;
    }
    // 0x100003da8
    return result;
}

// Address range: 0x100003db4 - 0x100003e7c
int64_t function_100003db4(void) {
    // 0x100003db4
    int64_t v1; // 0x100003db4
    int32_t v2 = v1; // 0x100003db8
    if (v2 == 2) {
        // 0x100003e70
        return 1;
    }
    int32_t v3 = 3 - v2; // 0x100003e10
    int32_t v4 = 3; // 0x100003e18
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e70
        return 0;
    }
    int64_t v5 = 4;
    int64_t v6 = (v5 * v5 - 2) % (-1 - (-1 << (v1 & 0xffffffff)));
    v4++;
    while (v4 - v2 == 0 || v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003e20
        v5 = v6;
        v6 = (v5 * v5 - 2) % (-1 - (-1 << (v1 & 0xffffffff)));
        v4++;
    }
    // 0x100003e70
    return v6 == 0;
}

// Address range: 0x100003e7c - 0x100003f60
int64_t entry_point(void) {
    // 0x100003e7c
    int128_t v1; // 0x100003e7c
    _log2((float64_t)(int64_t)v1);
    int32_t v2 = 0.5 * g1; // 0x100003ea8
    _printf(" Mersenne primes:\n");
    int32_t v3 = 2 - v2; // 0x100003ed0
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003f44
        _printf((char *)0x100003f98);
        return 0;
    }
    int32_t v4 = 2; // 0x100003f38
    int64_t v5; // 0x100003e7c
    if ((int32_t)function_100003cac() != 0) {
        // 0x100003ef8
        if ((int32_t)function_100003db4() != 0) {
            // 0x100003f10
            _printf(" M%u", (int32_t)v5);
        }
    }
    // 0x100003f34
    v4++;
    while (v4 - v2 == 0 || v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003ee0
        if ((int32_t)function_100003cac() != 0) {
            // 0x100003ef8
            if ((int32_t)function_100003db4() != 0) {
                // 0x100003f10
                _printf(" M%u", (int32_t)v5);
            }
        }
        // 0x100003f34
        v4++;
    }
    // 0x100003f44
    _printf((char *)0x100003f98);
    return 0;
}

// Address range: 0x100003f60 - 0x100003f6c
float64_t function_100003f60(float64_t a1) {
    // 0x100003f60
    return _log2(a1);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>

#define LIMIT 5000
static bool PRIMES[LIMIT];

static void prime_sieve() {
    uint64_t p;
    int i;

    PRIMES[0] = false;
    PRIMES[1] = false;
    for (i = 2; i < LIMIT; i++) {
        PRIMES[i] = true;
    }

    for (i = 4; i < LIMIT; i += 2) {
        PRIMES[i] = false;
    }

    for (p = 3;; p += 2) {
        uint64_t q = p * p;
        if (q >= LIMIT) {
            break;
        }
        if (PRIMES[p]) {
            uint64_t inc = 2 * p;
            for (; q < LIMIT; q += inc) {
                PRIMES[q] = false;
            }
        }
    }
}

uint64_t modpow(uint64_t base, uint64_t exp, uint64_t mod) {
    uint64_t result = 1;

    if (mod == 1) {
        return 0;
    }

    base %= mod;
    for (; exp > 0; exp >>= 1) {
        if ((exp & 1) == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
    }
    return result;
}

void wieferich_primes() {
    uint64_t p;

    for (p = 2; p < LIMIT; ++p) {
        if (PRIMES[p] && modpow(2, p - 1, p * p) == 1) {
            printf("%lld\n", p);
        }
    }
}

int main() {
    prime_sieve();

    printf("Wieferich primes less than %d:\n", LIMIT);
    wieferich_primes();

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bfc(void);
int64_t function_100003ce8(void);
int64_t function_100003de4(void);
int32_t function_100003f64(char * format, ...);

// --------------------- Global Variables ---------------------

char * g1; // 0x100008000
int64_t g2 = 0; // 0x100008001

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bfc - 0x100003ce8
int64_t function_100003bfc(void) {
    // 0x100003bfc
    int64_t v1; // 0x100003bfc
    uint64_t v2 = v1;
    if (v2 == 1) {
        // 0x100003cdc
        return 0;
    }
    // 0x100003c4c
    if (v1 == 0) {
        // 0x100003cdc
        return 1;
    }
    int64_t v3 = 1;
    int64_t v4; // 0x100003bfc
    uint64_t v5 = v4;
    int64_t v6; // 0x100003bfc
    uint64_t v7 = v6 % v2;
    int64_t v8 = v3; // 0x100003c70
    if (v5 % 2 != 0) {
        // 0x100003c78
        v8 = v7 * v3 % v2;
    }
    int64_t result = v8;
    v6 = v7 * v7;
    v4 = v5 / 2;
    while (v5 >= 2) {
        // 0x100003c60
        v3 = result;
        v5 = v4;
        v7 = v6 % v2;
        v8 = v3;
        if (v5 % 2 != 0) {
            // 0x100003c78
            v8 = v7 * v3 % v2;
        }
        // 0x100003c9c
        result = v8;
        v6 = v7 * v7;
        v4 = v5 / 2;
    }
    // 0x100003cdc
    return result;
}

// Address range: 0x100003ce8 - 0x100003d9c
int64_t function_100003ce8(void) {
    int64_t v1 = 2;
    int64_t v2; // 0x100003ce8
    int64_t v3 = v2; // 0x100003d2c
    int64_t v4; // 0x100003d4c
    if (*(char *)(v1 + (int64_t)&g1) % 2 != 0) {
        // 0x100003d34
        v4 = function_100003bfc();
        v3 = v4;
        if (v4 == 1) {
            // 0x100003d60
            v3 = _printf("%lld\n", v1 - 1);
        }
    }
    int64_t result = v3;
    int64_t v5 = v1 + 1; // 0x100003d84
    while (v5 != 0x1388) {
        // 0x100003d18
        v1 = v5;
        v3 = result;
        if (*(char *)(v1 + (int64_t)&g1) % 2 != 0) {
            // 0x100003d34
            v4 = function_100003bfc();
            v3 = v4;
            if (v4 == 1) {
                // 0x100003d60
                v3 = _printf("%lld\n", v1 - 1);
            }
        }
        // 0x100003d80
        result = v3;
        v5 = v1 + 1;
    }
    // 0x100003d90
    return result;
}

// Address range: 0x100003d9c - 0x100003de4
int64_t entry_point(void) {
    // 0x100003d9c
    function_100003de4();
    int64_t v1; // 0x100003d9c
    _printf("Wieferich primes less than %d:\n", v1);
    function_100003ce8();
    return 0;
}

// Address range: 0x100003de4 - 0x100003f64
int64_t function_100003de4(void) {
    // 0x100003de4
    *(char *)&g1 = 0;
    *(char *)&g2 = 0;
    int32_t v1 = 2;
    *(char *)((int64_t)v1 + (int64_t)&g1) = 1;
    int32_t v2 = v1 + 1; // 0x100003e40
    while (v1 < 0x1387 != (0x1386 - v1 & v2) < 0) {
        // 0x100003e20
        v1 = v2;
        *(char *)((int64_t)v1 + (int64_t)&g1) = 1;
        v2 = v1 + 1;
    }
    int32_t v3 = 4;
    *(char *)((int64_t)v3 + (int64_t)&g1) = 0;
    int32_t v4 = v3 + 2; // 0x100003e8c
    while (v3 < 0x1386 != (0x1385 - v3 & v4) < 0) {
        // 0x100003e70
        v3 = v4;
        *(char *)((int64_t)v3 + (int64_t)&g1) = 0;
        v4 = v3 + 2;
    }
    int64_t v5 = 3;
    if (*(char *)(v5 + (int64_t)&g1) % 2 != 0) {
        for (int64_t i = 9; i < 0x1388; i += 2 * v5) {
            // 0x100003f18
            *(char *)(i + (int64_t)&g1) = 0;
        }
    }
    int64_t v6 = v5 + 2; // 0x100003f50
    int64_t v7 = v6 * v6; // 0x100003eac
    while (v7 < 0x1388) {
        // 0x100003ed0
        v5 = v6;
        if (*(char *)(v5 + (int64_t)&g1) % 2 != 0) {
            for (int64_t i = v7; i < 0x1388; i += 2 * v5) {
                // 0x100003f18
                *(char *)(i + (int64_t)&g1) = 0;
            }
        }
        // 0x100003f4c
        v6 = v5 + 2;
        v7 = v6 * v6;
    }
    // 0x100003f5c
    int64_t result; // 0x100003de4
    return result;
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <execinfo.h>

#define MAX_BT 200

void print_stack_trace()
{
  void *buffer[MAX_BT];
  int n;

  n = backtrace(buffer, MAX_BT);
  fprintf(stderr, "--- (depth %d) ---\n", n);
  backtrace_symbols_fd(buffer, n, STDERR_FILENO);
}


void inner(int k)
{
  print_stack_trace();
}

void middle(int x, int y)
{
  inner(x*y);
}

void outer(int a, int b, int c)
{
  middle(a+b, b+c);
}

int main()
{
  outer(2,3,5);
  return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003df4(void);
int64_t function_100003e94(int32_t a1);
int64_t function_100003eb4(int32_t a1, int32_t a2);
int64_t function_100003ee4(int64_t a1, int64_t a2, int64_t a3);
int64_t function_100003f5c(int64_t a1);
int32_t function_100003f68(int64_t ** array, int32_t size);
void function_100003f74(int64_t ** array, int32_t size, int32_t fd);
int32_t function_100003f80(struct _IO_FILE * stream, char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _backtrace(int64_t ** a1, int32_t a2);
void _backtrace_symbols_fd(int64_t ** a1, int32_t a2, int32_t a3);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003df4 - 0x100003e94
int64_t function_100003df4(void) {
    // 0x100003df4
    int64_t v1; // bp-1632, 0x100003df4
    int32_t v2 = _backtrace((int64_t **)&v1, 200); // 0x100003e20
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003e30
    int64_t v4; // 0x100003df4
    _fprintf((struct _IO_FILE *)v3, "--- (depth %d) ---\n", v4);
    _backtrace_symbols_fd((int64_t **)&v1, v2, 2);
    int64_t v5 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e6c
    int64_t result = &g1; // 0x100003e78
    if (v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e80
        result = ___stack_chk_fail((int64_t)&g1);
    }
    // 0x100003e84
    return result;
}

// Address range: 0x100003e94 - 0x100003eb4
int64_t function_100003e94(int32_t a1) {
    // 0x100003e94
    return function_100003df4();
}

// Address range: 0x100003eb4 - 0x100003ee4
int64_t function_100003eb4(int32_t a1, int32_t a2) {
    // 0x100003eb4
    return function_100003e94(a2 * a1);
}

// Address range: 0x100003ee4 - 0x100003f24
int64_t function_100003ee4(int64_t a1, int64_t a2, int64_t a3) {
    int32_t v1 = a2; // 0x100003ef4
    return function_100003eb4(v1 + (int32_t)a1, (int32_t)a3 + v1);
}

// Address range: 0x100003f24 - 0x100003f5c
int64_t entry_point(void) {
    // 0x100003f24
    function_100003ee4(2, 3, 5);
    return 0;
}

// Address range: 0x100003f5c - 0x100003f68
int64_t function_100003f5c(int64_t a1) {
    // 0x100003f5c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(int64_t ** array, int32_t size) {
    // 0x100003f68
    return _backtrace(array, size);
}

// Address range: 0x100003f74 - 0x100003f80
void function_100003f74(int64_t ** array, int32_t size, int32_t fd) {
    // 0x100003f74
    _backtrace_symbols_fd(array, size, fd);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f80
    return _fprintf(stream, format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char **argv)
{
    if (argc < 2) return 1;

    FILE *fd;
    fd = popen(argv[1], "r");
    if (!fd) return 1;

    char   buffer[256];
    size_t chread;
    /* String to store entire command contents in */
    size_t comalloc = 256;
    size_t comlen   = 0;
    char  *comout   = malloc(comalloc);

    /* Use fread so binary data is dealt with correctly */
    while ((chread = fread(buffer, 1, sizeof(buffer), fd)) != 0) {
        if (comlen + chread >= comalloc) {
            comalloc *= 2;
            comout = realloc(comout, comalloc);
        }
        memmove(comout + comlen, buffer, chread);
        comlen += chread;
    }

    /* We can now work with the output as we please. Just print
     * out to confirm output is as expected */
    fwrite(comout, 1, comlen, stdout);
    free(comout);
    pclose(fd);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f38(int64_t a1, int64_t * a2, int64_t a3, int64_t a4);
int64_t function_100003f44(void);
int32_t function_100003f50(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void function_100003f5c(int64_t * ptr);
int32_t function_100003f68(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t * function_100003f74(int32_t size);
int32_t function_100003f80(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f8c(char * command, char * modes);
int64_t * function_100003f98(int64_t * ptr, int32_t size);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memmove_chk(int64_t a1, int64_t * a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(void);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
void _free(int64_t * a1);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int64_t * _malloc(int32_t a1);
int32_t _pclose(struct _IO_FILE * a1);
struct _IO_FILE * _popen(char * a1, char * a2);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003d8c - 0x100003f38
int64_t entry_point(void) {
    // 0x100003d8c
    int64_t v1; // 0x100003d8c
    int32_t v2 = v1; // 0x100003db0
    int64_t result = 1; // 0x100003dc4
    if (v2 < 2 == (1 - v2 & v2) < 0) {
        struct _IO_FILE * v3 = _popen((char *)*(int64_t *)(v1 + 8), (char *)0x100003fa4); // 0x100003de8
        result = 1;
        if (v3 != NULL) {
            int64_t v4 = (int64_t)_malloc(256); // 0x100003e20
            int64_t v5; // bp-296, 0x100003d8c
            int32_t v6 = _fread(&v5, 1, 256, v3); // 0x100003e3c
            int32_t v7 = 0; // 0x100003e4c
            int32_t v8 = 0; // 0x100003e4c
            int64_t v9 = v4; // 0x100003e4c
            if (v6 != 0) {
                int64_t v10 = 256;
                int64_t v11 = v6;
                int64_t v12 = v7; // 0x100003e54
                int64_t v13 = v10; // 0x100003e6c
                int64_t v14 = v4; // 0x100003e6c
                int64_t * v15; // 0x100003e88
                if (v12 + v11 >= v10) {
                    // 0x100003e74
                    v13 = 2 * v10;
                    v15 = _realloc((int64_t *)v4, (int32_t)v13);
                    v14 = (int64_t)v15;
                }
                // 0x100003e94
                ___memmove_chk(v14 + v12, &v5, v11, -1);
                int32_t v16 = v7 + v6; // 0x100003ebc
                int32_t v17 = _fread(&v5, 1, 256, v3); // 0x100003e3c
                int32_t v18 = v17; // 0x100003e4c
                v7 = v16;
                v8 = v16;
                v9 = v14;
                while (v17 != 0) {
                    // 0x100003e54
                    v10 = v13;
                    int64_t v19 = v14;
                    v11 = v18;
                    v12 = v7;
                    v13 = v10;
                    v14 = v19;
                    if (v12 + v11 >= v10) {
                        // 0x100003e74
                        v13 = 2 * v10;
                        v15 = _realloc((int64_t *)v19, (int32_t)v13);
                        v14 = (int64_t)v15;
                    }
                    // 0x100003e94
                    ___memmove_chk(v14 + v12, &v5, v11, -1);
                    v16 = v7 + v18;
                    v17 = _fread(&v5, 1, 256, v3);
                    v18 = v17;
                    v7 = v16;
                    v8 = v16;
                    v9 = v14;
                }
            }
            int64_t v20 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003ed4
            int64_t * v21 = (int64_t *)v9; // 0x100003edc
            _fwrite(v21, 1, v8, (struct _IO_FILE *)v20);
            _free(v21);
            _pclose(v3);
            result = 0;
        }
    }
    int64_t v22 = *(int64_t *)0x100004010; // 0x100003f08
    if (*(int64_t *)v22 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003f20
        ___stack_chk_fail();
    }
    // 0x100003f24
    return result;
}

// Address range: 0x100003f38 - 0x100003f44
int64_t function_100003f38(int64_t a1, int64_t * a2, int64_t a3, int64_t a4) {
    // 0x100003f38
    return ___memmove_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f44 - 0x100003f50
int64_t function_100003f44(void) {
    // 0x100003f44
    return ___stack_chk_fail();
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003f50
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003f5c - 0x100003f68
void function_100003f5c(int64_t * ptr) {
    // 0x100003f5c
    _free(ptr);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003f68
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003f74 - 0x100003f80
int64_t * function_100003f74(int32_t size) {
    // 0x100003f74
    return _malloc(size);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(struct _IO_FILE * stream) {
    // 0x100003f80
    return _pclose(stream);
}

// Address range: 0x100003f8c - 0x100003f98
struct _IO_FILE * function_100003f8c(char * command, char * modes) {
    // 0x100003f8c
    return _popen(command, modes);
}

// Address range: 0x100003f98 - 0x100003fa4
int64_t * function_100003f98(int64_t * ptr, int32_t size) {
    // 0x100003f98
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>

int main(int argc, char const *argv[]) {
  for (char c = 0x41; c < 0x5b; c ++) putchar(c);
  putchar('\n');
  for (char c = 0x61; c < 0x7b; c ++) putchar(c);
  putchar('\n');
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f9c(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003eec - 0x100003f9c
int64_t entry_point(void) {
    int32_t v1 = 65; // 0x100003f38
    _putchar(v1);
    int32_t v2 = 0x1000000 * v1 + 0x1000000;
    v1 = v2 >> 24;
    while (v2 < 0x5b000000 != (90 - v1 & v1) < 0) {
        // 0x100003f24
        _putchar(v1);
        v2 = 0x1000000 * v1 + 0x1000000;
        v1 = v2 >> 24;
    }
    // 0x100003f40
    _putchar(10);
    int32_t v3 = 97; // 0x100003f7c
    _putchar(v3);
    int32_t v4 = 0x1000000 * v3 + 0x1000000;
    v3 = v4 >> 24;
    while (v4 < 0x7b000000 != (122 - v3 & v3) < 0) {
        // 0x100003f68
        _putchar(v3);
        v4 = 0x1000000 * v3 + 0x1000000;
        v3 = v4 >> 24;
    }
    // 0x100003f84
    _putchar(10);
    return 0;
}

// Address range: 0x100003f9c - 0x100003fa8
int32_t function_100003f9c(int32_t c) {
    // 0x100003f9c
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`/*
 * Rosetta Code - stream merge in C.
 *
 * Two streams (text files) with integer numbers, C89, Visual Studio 2010.
 *
 */

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

#define GET(N) { if(fscanf(f##N,"%d",&b##N ) != 1) f##N = NULL; }
#define PUT(N) { printf("%d\n", b##N); GET(N) }

void merge(FILE* f1, FILE* f2, FILE* out)
{
    int b1;
    int b2;

    if(f1) GET(1)
    if(f2) GET(2)

    while ( f1 && f2 )
    {
        if ( b1 <= b2 ) PUT(1)
        else            PUT(2)
    }
    while (f1 ) PUT(1)
    while (f2 ) PUT(2)
}

int main(int argc, char* argv[])
{
    if ( argc < 3 || argc > 3 )
    {
        puts("streammerge filename1 filename2");
        exit(EXIT_FAILURE);
    }
    else
        merge(fopen(argv[1],"r"),fopen(argv[2],"r"),stdout);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bdc(void);
void function_100003f40(int32_t status);
struct _IO_FILE * function_100003f4c(char * filename, char * modes);
int32_t function_100003f58(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f64(char * format, ...);
int32_t function_100003f70(char * s);

// ------- Dynamically Linked Functions Without Header --------

struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003bdc - 0x100003e94
int64_t function_100003bdc(void) {
    // 0x100003bdc
    int32_t v1; // 0x100003bdc
    int32_t v2 = v1;
    int64_t v3; // 0x100003bdc
    struct _IO_FILE * v4 = (struct _IO_FILE *)v3; // 0x100003be8
    int64_t v5 = 0; // 0x100003c00
    struct _IO_FILE * v6 = v4; // 0x100003c00
    int64_t v7; // 0x100003bdc
    if (v3 != 0) {
        int32_t v8 = _fscanf(v4, "%d", (int64_t *)v3); // 0x100003c20
        v5 = v8;
        v7 = (int64_t)"%d";
        v6 = v8 == 1 ? v4 : NULL;
    }
    struct _IO_FILE * v9 = (struct _IO_FILE *)v3; // 0x100003bec
    struct _IO_FILE * v10 = v9; // 0x100003c4c
    int64_t v11 = v5; // 0x100003c4c
    int64_t v12 = v7; // 0x100003c4c
    if (v3 != 0) {
        int32_t v13 = _fscanf(v9, "%d", (int64_t *)v3); // 0x100003c6c
        v10 = v13 == 1 ? v9 : NULL;
        v11 = v13;
        v12 = (int64_t)"%d";
    }
    struct _IO_FILE * v14 = v10; // 0x100003cc4
    int64_t v15 = v11; // 0x100003cc4
    int64_t v16 = v12; // 0x100003cc4
    struct _IO_FILE * v17 = v6; // 0x100003cc4
    if (v6 != NULL == (v10 != NULL)) {
        int32_t v18 = v2 - v1; // 0x100003cd4
        int64_t * v19 = (int64_t *)v3;
        _printf("%d\n", v12);
        struct _IO_FILE * v20; // 0x100003bdc
        struct _IO_FILE * v21; // 0x100003bdc
        int32_t v22; // 0x100003d20
        int32_t v23; // 0x100003d7c
        int32_t v24; // 0x100003bdc
        if (v18 == 0 || v18 < 0 != ((v18 ^ v2) & (v2 ^ v1)) < 0) {
            // 0x100003ce4
            v22 = _fscanf(v6, "%d", v19);
            v21 = v10;
            v24 = v22;
            v20 = v22 == 1 ? v6 : NULL;
        } else {
            // 0x100003d40
            v23 = _fscanf(v10, "%d", v19);
            v21 = v23 == 1 ? v10 : NULL;
            v24 = v23;
            v20 = v6;
        }
        // 0x100003d9c
        v17 = v20;
        v14 = v21;
        int64_t v25 = (int64_t)"%d"; // 0x100003cc4
        while (v14 != NULL == (v17 != NULL)) {
            struct _IO_FILE * v26 = v14;
            struct _IO_FILE * v27 = v17;
            _printf("%d\n", v25);
            if (v18 == 0 || v18 < 0 != ((v18 ^ v2) & (v2 ^ v1)) < 0) {
                // 0x100003ce4
                v22 = _fscanf(v27, "%d", v19);
                v21 = v26;
                v24 = v22;
                v20 = v22 == 1 ? v27 : NULL;
            } else {
                // 0x100003d40
                v23 = _fscanf(v26, "%d", v19);
                v21 = v23 == 1 ? v26 : NULL;
                v24 = v23;
                v20 = v27;
            }
            // 0x100003d9c
            v17 = v20;
            v14 = v21;
            v25 = (int64_t)"%d";
        }
        // 0x100003c90
        v15 = v24;
        v16 = (int64_t)"%d";
    }
    int64_t result = v15; // 0x100003db0
    int64_t v28 = v16; // 0x100003db0
    if (v17 != NULL) {
        // 0x100003db8
        _printf("%d\n", v16);
        int32_t v29 = _fscanf(v17, "%d", (int64_t *)v3); // 0x100003df4
        int64_t v30 = (int64_t)"%d"; // 0x100003db0
        while (v29 == 1) {
            // 0x100003db8
            _printf("%d\n", v30);
            v29 = _fscanf(v17, "%d", (int64_t *)v3);
            v30 = (int64_t)"%d";
        }
        // 0x100003da4
        result = v29;
        v28 = (int64_t)"%d";
    }
    // 0x100003e18
    if (v14 == NULL) {
        // 0x100003e88
        return result;
    }
    // 0x100003e2c
    _printf("%d\n", v28);
    int32_t result2 = _fscanf(v14, "%d", (int64_t *)v3); // 0x100003e68
    int64_t v31 = (int64_t)"%d"; // 0x100003e24
    while (result2 == 1) {
        // 0x100003e2c
        _printf("%d\n", v31);
        result2 = _fscanf(v14, "%d", (int64_t *)v3);
        v31 = (int64_t)"%d";
    }
    // 0x100003e88
    return result2;
}

// Address range: 0x100003e94 - 0x100003f40
int64_t entry_point(void) {
    // 0x100003e94
    int64_t v1; // 0x100003e94
    int32_t v2 = v1; // 0x100003ea4
    int32_t v3 = v2 - 3; // 0x100003eb0
    if (v3 == 0 != (v3 < 0 == (2 - v2 & v2) < 0)) {
        // 0x100003ed4
        _puts("streammerge filename1 filename2");
        _exit(1);
        // UNREACHABLE
    }
    // 0x100003ee8
    _fopen((char *)*(int64_t *)(v1 + 8), (char *)0x100003fa3);
    _fopen((char *)*(int64_t *)(v1 + 16), "r");
    function_100003bdc();
    return 0;
}

// Address range: 0x100003f40 - 0x100003f4c
void function_100003f40(int32_t status) {
    // 0x100003f40
    _exit(status);
}

// Address range: 0x100003f4c - 0x100003f58
struct _IO_FILE * function_100003f4c(char * filename, char * modes) {
    // 0x100003f4c
    return _fopen(filename, modes);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f58
    return _fscanf(stream, format);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * s) {
    // 0x100003f70
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *substring(const char *s, size_t n, ptrdiff_t m)
{
  char *result;
  /* check for null s */
  if (NULL == s)
    return NULL;
  /* negative m to mean 'up to the mth char from right' */
  if (m < 0)
    m = strlen(s) + m - n + 1;

  /* n < 0 or m < 0 is invalid */
  if (n < 0 || m < 0)
    return NULL;

  /* make sure string does not end before n
   * and advance the "s" pointer to beginning of substring */
  for ( ; n > 0; s++, n--)
    if (*s == '\0')
      /* string ends before n: invalid */
      return NULL;

  result = malloc(m+1);
  if (NULL == result)
    /* memory allocation failed */
    return NULL;
  result[0]=0;
  strncat(result, s, m); /* strncat() will automatically add null terminator
                          * if string ends early or after reading m characters */
  return result;
}

char *str_wholeless1(const char *s)
{
  return substring(s, 0, strlen(s) - 1);
}

char *str_fromch(const char *s, int ch, ptrdiff_t m)
{
  return substring(s, strchr(s, ch) - s, m);
}

char *str_fromstr(const char *s, char *in, ptrdiff_t m)
{
  return substring(s, strstr(s, in) - s , m);
}


#define TEST(A) do {		\
    char *r = (A);		\
    if (NULL == r)		\
      puts("--error--");	\
    else {			\
      puts(r);			\
      free(r);			\
    }				\
  } while(0)

int main()
{
  const char *s = "hello world shortest program";

  TEST( substring(s, 12, 5) );		// get "short"
  TEST( substring(s, 6, -1) );		// get "world shortest program"
  TEST( str_wholeless1(s) );		// "... progra"
  TEST( str_fromch(s, 'w', 5) );	// "world"
  TEST( str_fromstr(s, "ro", 3) );	// "rog"

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b08(void);
int64_t function_100003c68(void);
int64_t function_100003ca8(void);
int64_t function_100003cf8(void);
int64_t function_100003f28(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void function_100003f34(int64_t * ptr);
int64_t * function_100003f40(int32_t size);
int32_t function_100003f4c(char * s);
char * function_100003f58(char * s, int32_t c);
int32_t function_100003f64(char * s);
char * function_100003f70(char * haystack, char * needle);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___strncat_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _puts(char * a1);
char * _strchr(char * a1, int32_t a2);
int32_t _strlen(char * a1);
char * _strstr(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003b08 - 0x100003c68
int64_t function_100003b08(void) {
    // 0x100003b08
    int64_t v1; // 0x100003b08
    if (v1 == 0) {
        // 0x100003c58
        return 0;
    }
    char * v2 = (char *)v1; // 0x100003b14
    int64_t v3; // 0x100003b08
    if (v1 < 0) {
        int64_t v4 = v1 + 1 - v1 + (int64_t)_strlen(v2); // 0x100003b6c
        v3 = v4;
        if (v4 < 0) {
            // 0x100003c58
            return 0;
        }
    }
    char * v5 = v2; // 0x100003bb8
    char * v6 = v2; // 0x100003bb8
    int64_t result; // 0x100003b08
    if (v1 == 0) {
      lab_0x100003c00:;
        int64_t * v7 = _malloc((int32_t)v3 + 1); // 0x100003c08
        result = 0;
        if (v7 != NULL) {
            // 0x100003c30
            *(char *)v7 = 0;
            int64_t v8 = (int64_t)v7; // 0x100003c38
            ___strncat_chk(v8, (int64_t)v6, v3, -1);
            result = v8;
        }
    } else {
        result = 0;
        while (*v5 != 0) {
            // 0x100003be4
            v5 = (char *)((int64_t)v5 + 1);
            int64_t v9; // 0x100003b08
            int64_t v10 = v9 - 1; // 0x100003bf4
            v9 = v10;
            v6 = v5;
            if (v10 == 0) {
                goto lab_0x100003c00;
            }
            result = 0;
        }
    }
    // 0x100003c58
    return result;
}

// Address range: 0x100003c68 - 0x100003ca8
int64_t function_100003c68(void) {
    // 0x100003c68
    int64_t v1; // 0x100003c68
    _strlen((char *)v1);
    return function_100003b08();
}

// Address range: 0x100003ca8 - 0x100003cf8
int64_t function_100003ca8(void) {
    // 0x100003ca8
    int64_t v1; // 0x100003ca8
    _strchr((char *)v1, (int32_t)v1);
    return function_100003b08();
}

// Address range: 0x100003cf8 - 0x100003d48
int64_t function_100003cf8(void) {
    // 0x100003cf8
    int64_t v1; // 0x100003cf8
    _strstr((char *)v1, (char *)v1);
    return function_100003b08();
}

// Address range: 0x100003d48 - 0x100003f28
int64_t entry_point(void) {
    int64_t v1 = function_100003b08(); // 0x100003d74
    if (v1 == 0) {
        // 0x100003d94
        _puts("--error--");
    } else {
        // 0x100003da4
        _puts((char *)v1);
        _free((int64_t *)v1);
    }
    int64_t v2 = function_100003b08(); // 0x100003dcc
    if (v2 == 0) {
        // 0x100003dec
        _puts("--error--");
    } else {
        // 0x100003dfc
        _puts((char *)v2);
        _free((int64_t *)v2);
    }
    int64_t v3 = function_100003c68(); // 0x100003e1c
    if (v3 == 0) {
        // 0x100003e3c
        _puts("--error--");
    } else {
        // 0x100003e4c
        _puts((char *)v3);
        _free((int64_t *)v3);
    }
    int64_t v4 = function_100003ca8(); // 0x100003e74
    if (v4 == 0) {
        // 0x100003e94
        _puts("--error--");
    } else {
        // 0x100003ea4
        _puts((char *)v4);
        _free((int64_t *)v4);
    }
    int64_t v5 = function_100003cf8(); // 0x100003ed0
    if (v5 == 0) {
        // 0x100003ef0
        _puts("--error--");
    } else {
        // 0x100003f00
        _puts((char *)v5);
        _free((int64_t *)v5);
    }
    // 0x100003f18
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int64_t function_100003f28(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f28
    return ___strncat_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int64_t * ptr) {
    // 0x100003f34
    _free(ptr);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t size) {
    // 0x100003f40
    return _malloc(size);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * s) {
    // 0x100003f4c
    return _puts(s);
}

// Address range: 0x100003f58 - 0x100003f64
char * function_100003f58(char * s, int32_t c) {
    // 0x100003f58
    return _strchr(s, c);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * s) {
    // 0x100003f64
    return _strlen(s);
}

// Address range: 0x100003f70 - 0x100003f7c
char * function_100003f70(char * haystack, char * needle) {
    // 0x100003f70
    return _strstr(haystack, needle);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include<stdlib.h>
#include<string.h>
#include<stdio.h>

unsigned long long bruteForceProperDivisorSum(unsigned long long n){
	unsigned long long i,sum = 0;
	
	for(i=1;i<(n+1)/2;i++)
		if(n%i==0 && n!=i)
			sum += i;
		
	return sum;
}

void printSeries(unsigned long long* arr,int size,char* type){
	int i;
	
	printf("\nInteger : %llu, Type : %s, Series : ",arr[0],type);
	
	for(i=0;i<size-1;i++)
		printf("%llu, ",arr[i]);
	printf("%llu",arr[i]);
}

void aliquotClassifier(unsigned long long n){
	unsigned long long arr[16];
	int i,j;
	
	arr[0] = n;
	
	for(i=1;i<16;i++){
		arr[i] = bruteForceProperDivisorSum(arr[i-1]);
		
		if(arr[i]==0||arr[i]==n||(arr[i]==arr[i-1] && arr[i]!=n)){
			printSeries(arr,i+1,(arr[i]==0)?"Terminating":(arr[i]==n && i==1)?"Perfect":(arr[i]==n && i==2)?"Amicable":(arr[i]==arr[i-1] && arr[i]!=n)?"Aspiring":"Sociable");
			return;
		}
		
		for(j=1;j<i;j++){
			if(arr[j]==arr[i]){
				printSeries(arr,i+1,"Cyclic");
				return;
			}
		}
	}
	
	printSeries(arr,i+1,"Non-Terminating");
}

void processFile(char* fileName){
	FILE* fp = fopen(fileName,"r");
	char str[21];
	
	while(fgets(str,21,fp)!=NULL)
		aliquotClassifier(strtoull(str,(char**)NULL,10));
	
	fclose(fp);
}

int main(int argC,char* argV[])
{
    if(argC!=2)
		printf("Usage : %s <positive integer>",argV[0]);
	else{
		if(strchr(argV[1],'.')!=NULL)
			processFile(argV[1]);
		else
			aliquotClassifier(strtoull(argV[1],(char**)NULL,10));
	}
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038cc(void);
int64_t function_100003978(void);
int64_t function_100003a38(void);
int64_t function_100003d60(void);
int64_t function_100003eb4(int64_t a1);
int32_t function_100003ec0(struct _IO_FILE * stream);
char * function_100003ecc(char * s, int32_t n, struct _IO_FILE * stream);
struct _IO_FILE * function_100003ed8(char * filename, char * modes);
int32_t function_100003ee4(char * format, ...);
char * function_100003ef0(char * s, int32_t c);
int64_t function_100003efc(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _printf(char * a1, ...);
char * _strchr(char * a1, int32_t a2);
int64_t _strtoull(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x1000038cc - 0x100003978
int64_t function_1000038cc(void) {
    // 0x1000038cc
    int64_t v1; // 0x1000038cc
    uint64_t v2 = v1;
    uint64_t v3 = v2 + 1; // 0x1000038ec
    if (v3 <= 3) {
        // 0x10000396c
        return 0;
    }
    int64_t result = 0; // 0x100003900
    uint64_t v4 = 1;
    int64_t v5 = v2 == v4 | v2 % v4 != 0 ? 0 : v4;
    result += v5;
    int64_t v6 = v4 + 1; // 0x100003960
    while (v6 < v3 / 2) {
        // 0x100003908
        v4 = v6;
        v5 = v2 == v4 | v2 % v4 != 0 ? 0 : v4;
        result += v5;
        v6 = v4 + 1;
    }
    // 0x10000396c
    return result;
}

// Address range: 0x100003978 - 0x100003a38
int64_t function_100003978(void) {
    // 0x100003978
    int64_t v1; // 0x100003978
    int32_t v2 = v1; // 0x100003988
    _printf("\nInteger : %llu, Type : %s, Series : ", v1, (char *)v1);
    int32_t v3 = v2 - 1; // 0x1000039c4
    int32_t v4 = 1 - v2; // 0x1000039c8
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x100003a0c
        return _printf("%llu", v1);
    }
    int32_t v5 = 0; // 0x1000039d0
    _printf("%llu, ", v1);
    v5++;
    while (v5 - v3 < 0 != ((v5 - v3 ^ v5) & (v5 ^ v3)) < 0) {
        // 0x1000039d8
        _printf("%llu, ", v1);
        v5++;
    }
    // 0x100003a0c
    return _printf("%llu", v1);
}

// Address range: 0x100003a38 - 0x100003d60
int64_t function_100003a38(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003a4c
    int64_t v2; // bp-152, 0x100003a38
    int64_t v3 = &v2; // 0x100003a8c
    int32_t v4 = 1; // 0x100003a38
    uint64_t v5 = 1;
    int64_t v6 = function_1000038cc(); // 0x100003a94
    int64_t v7 = 8 * v5 + v3;
    *(int64_t *)v7 = v6;
    int64_t v8; // 0x100003a38
    int64_t v9; // 0x100003a38
    while (v6 != 0 && v6 != v8) {
        // 0x100003adc
        if (v6 == *(int64_t *)(v7 - 8)) {
            // break -> 0x100003b24
            break;
        }
        int32_t v10 = v4;
        int32_t v11 = v5;
        int32_t v12 = 1; // 0x100003ca4
        if (v5 > 1 != (1 - v10 & v11) < 0) {
            if (*(int64_t *)(8 * (int64_t)v12 + v3) == v6) {
                // 0x100003cd0
                v9 = function_100003978();
                goto lab_0x100003d30;
            }
            int32_t v13 = v12 + 1; // 0x100003cf4
            int32_t v14 = v13 - v11; // 0x100003c9c
            v12 = v13;
            while (v14 < 0 != ((v14 ^ v13) & (v13 ^ v11)) < 0) {
                // 0x100003cac
                if (*(int64_t *)(8 * (int64_t)v12 + v3) == v6) {
                    // 0x100003cd0
                    v9 = function_100003978();
                    goto lab_0x100003d30;
                }
                // 0x100003c94
                v13 = v12 + 1;
                v14 = v13 - v11;
                v12 = v13;
            }
        }
        int64_t v15 = v5 + 1;
        v4 = v10 + 1;
        if (v5 < 15 == (14 - v10 & (int32_t)v15) < 0) {
            // 0x100003d14
            v9 = function_100003978();
            goto lab_0x100003d30;
        }
        v5 = v15;
        v6 = function_1000038cc();
        v7 = 8 * v5 + v3;
        *(int64_t *)v7 = v6;
    }
    // 0x100003b24
    v9 = function_100003978();
    goto lab_0x100003d30;
  lab_0x100003d30:;
    int64_t result = v9; // 0x100003d48
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003d50
        result = ___stack_chk_fail(v9);
    }
    // 0x100003d54
    return result;
}

// Address range: 0x100003d60 - 0x100003e08
int64_t function_100003d60(void) {
    // 0x100003d60
    int64_t v1; // 0x100003d60
    struct _IO_FILE * v2 = _fopen((char *)v1, "r"); // 0x100003d8c
    int64_t v3; // bp-45, 0x100003d60
    if (_fgets((char *)&v3, 21, v2) != NULL) {
        _strtoull((char *)&v3, NULL, 10);
        function_100003a38();
        while (_fgets((char *)&v3, 21, v2) != NULL) {
            // 0x100003db8
            _strtoull((char *)&v3, NULL, 10);
            function_100003a38();
        }
    }
    int64_t v4 = _fclose(v2); // 0x100003dd4
    int64_t v5 = *(int64_t *)0x100004008; // 0x100003de0
    int64_t result = v4; // 0x100003df0
    if (*(int64_t *)v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003df8
        result = ___stack_chk_fail(v4);
    }
    // 0x100003dfc
    return result;
}

// Address range: 0x100003e08 - 0x100003eb4
int64_t entry_point(void) {
    // 0x100003e08
    int64_t v1; // 0x100003e08
    if ((int32_t)v1 != 2) {
        // 0x100003e34
        _printf("Usage : %s <positive integer>", (char *)v1);
        // 0x100003ea4
        return 0;
    }
    int64_t * v2 = (int64_t *)(v1 + 8); // 0x100003e58
    if (_strchr((char *)*v2, 46) == NULL) {
        // 0x100003e84
        _strtoull((char *)*v2, NULL, 10);
        function_100003a38();
    } else {
        // 0x100003e74
        function_100003d60();
    }
    // 0x100003ea4
    return 0;
}

// Address range: 0x100003eb4 - 0x100003ec0
int64_t function_100003eb4(int64_t a1) {
    // 0x100003eb4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ec0 - 0x100003ecc
int32_t function_100003ec0(struct _IO_FILE * stream) {
    // 0x100003ec0
    return _fclose(stream);
}

// Address range: 0x100003ecc - 0x100003ed8
char * function_100003ecc(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003ecc
    return _fgets(s, n, stream);
}

// Address range: 0x100003ed8 - 0x100003ee4
struct _IO_FILE * function_100003ed8(char * filename, char * modes) {
    // 0x100003ed8
    return _fopen(filename, modes);
}

// Address range: 0x100003ee4 - 0x100003ef0
int32_t function_100003ee4(char * format, ...) {
    // 0x100003ee4
    return _printf(format);
}

// Address range: 0x100003ef0 - 0x100003efc
char * function_100003ef0(char * s, int32_t c) {
    // 0x100003ef0
    return _strchr(s, c);
}

// Address range: 0x100003efc - 0x100003f08
int64_t function_100003efc(char * nptr, char ** endptr, int32_t base) {
    // 0x100003efc
    return _strtoull(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <err.h>
#include <string.h>

char * find_match(const char *buf, const char * buf_end, const char *pat, size_t len)
{
	ptrdiff_t i;
	char *start = buf;
	while (start + len < buf_end) {
		for (i = 0; i < len; i++)
			if (start[i] != pat[i]) break;

		if (i == len) return (char *)start;
		start++;
	}
	return 0;
}

int replace(const char *from, const char *to, const char *fname)
{
#define bail(msg) { warn(msg" '%s'", fname); goto done; }
	struct stat st;
	int ret = 0;
	char *buf = 0, *start, *end;
	size_t len = strlen(from), nlen = strlen(to);
	int fd = open(fname, O_RDWR);

	if (fd == -1) bail("Can't open");
	if (fstat(fd, &st) == -1) bail("Can't stat");
	if (!(buf = malloc(st.st_size))) bail("Can't alloc");
	if (read(fd, buf, st.st_size) != st.st_size) bail("Bad read");

	start = buf;
	end = find_match(start, buf + st.st_size, from, len);
	if (!end) goto done; /* no match found, don't change file */

	ftruncate(fd, 0);
	lseek(fd, 0, 0);
	do {
		write(fd, start, end - start);	/* write content before match */
		write(fd, to, nlen);		/* write replacement of match */
		start = end + len;		/* skip to end of match */
						/* find match again */
		end = find_match(start, buf + st.st_size, from, len);
	} while (end);

	/* write leftover after last match */
	if (start < buf + st.st_size)
		write(fd, start, buf + st.st_size - start);

done:
	if (fd != -1) close(fd);
	if (buf) free(buf);
	return ret;
}

int main()
{
	const char *from = "Goodbye, London!";
	const char *to   = "Hello, New York!";
	const char * files[] = { "test1.txt", "test2.txt", "test3.txt" };
	int i;

	for (i = 0; i < sizeof(files)/sizeof(char*); i++)
		replace(from, to, files[i]);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039f4(void);
int64_t function_100003adc(void);
int64_t function_100003e88(void);
int32_t function_100003e94(int32_t fd);
void function_100003ea0(int64_t * ptr);
int32_t function_100003eac(int32_t fd, struct stat * buf);
int32_t function_100003eb8(int32_t fd, int32_t length);
int32_t function_100003ec4(int32_t fd, int32_t offset, int32_t whence);
int64_t * function_100003ed0(int32_t size);
int32_t function_100003edc(char * file, int32_t oflag, ...);
int32_t function_100003ee8(int32_t fd, int64_t * buf, int32_t nbytes);
int32_t function_100003ef4(char * s);
void function_100003f00(char * format, ...);
int32_t function_100003f0c(int32_t fd, int64_t * buf, int32_t n);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _close(int32_t a1);
void _free(int64_t * a1);
int32_t _fstat(int32_t a1, struct stat * a2);
int32_t _ftruncate(int32_t a1, int32_t a2);
int32_t _lseek(int32_t a1, int32_t a2, int32_t a3);
int64_t * _malloc(int32_t a1);
int32_t _strlen(char * a1);
void _warn(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000039f4 - 0x100003adc
int64_t function_1000039f4(void) {
    // 0x1000039f4
    int64_t v1; // 0x1000039f4
    uint64_t v2 = v1;
    if (v1 + v2 >= v1) {
        // 0x100003ad0
        return 0;
    }
    int64_t v3; // 0x1000039f4
    int64_t v4 = v3;
    int64_t v5 = 0; // 0x100003a4c
    int64_t v6; // 0x1000039f4
    int64_t v7; // 0x1000039f4
    char v8; // 0x100003a68
    int64_t v9; // 0x100003a88
    if (v2 != 0) {
        v7 = 0;
        v8 = *(char *)(v7 + v1);
        v5 = v7;
        while (*(char *)(v7 + v4) == v8) {
            // 0x100003a84
            v9 = v7 + 1;
            v6 = v9;
            v5 = v9;
            if (v9 >= v2) {
                // break -> 0x100003a94
                break;
            }
            v7 = v6;
            v8 = *(char *)(v7 + v1);
            v5 = v7;
        }
    }
    int64_t result = v4; // 0x100003aa4
    while (v5 != v2) {
        int64_t v10 = v4 + 1; // 0x100003abc
        result = 0;
        if (v10 + v2 >= v1) {
            // break -> 0x100003ad0
            break;
        }
        v4 = v10;
        v5 = 0;
        if (v2 != 0) {
            v7 = 0;
            v8 = *(char *)(v7 + v1);
            v5 = v7;
            while (*(char *)(v7 + v4) == v8) {
                // 0x100003a84
                v9 = v7 + 1;
                v6 = v9;
                v5 = v9;
                if (v9 >= v2) {
                    // break -> 0x100003a94
                    break;
                }
                v7 = v6;
                v8 = *(char *)(v7 + v1);
                v5 = v7;
            }
        }
        // 0x100003a94
        result = v4;
    }
    // 0x100003ad0
    return result;
}

// Address range: 0x100003adc - 0x100003dbc
int64_t function_100003adc(void) {
    // 0x100003adc
    int64_t v1; // bp-200, 0x100003adc
    int64_t v2 = &v1; // 0x100003af0
    int64_t v3; // 0x100003adc
    int32_t v4 = _strlen((char *)v3); // 0x100003b0c
    int64_t * v5 = (int64_t *)(v2 + 152); // 0x100003b18
    int32_t v6 = _strlen((char *)*v5); // 0x100003b1c
    int32_t v7 = _open((char *)*(int64_t *)(v2 + 144), 2); // 0x100003b30
    if (v7 == -1) {
        // 0x100003d88
        _warn("Can't open '%s'", (char *)2);
        // 0x100003da8
        return 0;
    }
    // 0x100003b6c
    if (_fstat(v7, (struct stat *)&v1) == -1) {
        // 0x100003d88
        _warn("Can't stat '%s'", &v1);
        _close(v7);
        // 0x100003da8
        return 0;
    }
    int64_t * v8 = (int64_t *)(v2 + 96); // 0x100003bac
    int64_t * v9 = _malloc((int32_t)*v8); // 0x100003bb0
    if (v9 == NULL) {
        // 0x100003d88
        _warn("Can't alloc '%s'", &v1);
        _close(v7);
        // 0x100003da8
        return 0;
    }
    // 0x100003bec
    if (*v8 != (int64_t)_read(v7, v9, (int32_t)*v8)) {
        // 0x100003c18
        _warn("Bad read '%s'", v9);
        // 0x100003d88
        _close(v7);
        // 0x100003d9c
        _free(v9);
        // 0x100003da8
        return 0;
    }
    int64_t v10 = function_1000039f4(); // 0x100003c5c
    if (v10 == 0) {
        // 0x100003d88
        _close(v7);
        // 0x100003d9c
        _free(v9);
        // 0x100003da8
        return 0;
    }
    int64_t v11 = (int64_t)v9; // 0x100003c3c
    _ftruncate(v7, 0);
    _lseek(v7, 0, 0);
    int64_t v12 = v11;
    _write(v7, (int64_t *)v12, (int32_t)(v10 - v12));
    _write(v7, (int64_t *)*v5, v6);
    int64_t v13 = v10 + (int64_t)v4; // 0x100003cd8
    int64_t v14 = function_1000039f4(); // 0x100003cf8
    while (v14 != 0) {
        // 0x100003ca0
        v12 = v13;
        _write(v7, (int64_t *)v12, (int32_t)(v14 - v12));
        _write(v7, (int64_t *)*v5, v6);
        v13 = v14 + (int64_t)v4;
        v14 = function_1000039f4();
    }
    uint64_t v15 = *v8 + v11; // 0x100003d28
    if (v15 > v13) {
        // 0x100003d3c
        _write(v7, (int64_t *)v13, (int32_t)(v15 - v13));
    }
    // 0x100003d88
    _close(v7);
    // 0x100003d9c
    _free(v9);
    // 0x100003da8
    return 0;
}

// Address range: 0x100003dbc - 0x100003e88
int64_t entry_point(void) {
    for (int32_t i = 0; i < 3; i++) {
        // 0x100003e28
        function_100003adc();
    }
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e60
    if (v1 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e74
        ___stack_chk_fail();
    }
    // 0x100003e78
    return 0;
}

// Address range: 0x100003e88 - 0x100003e94
int64_t function_100003e88(void) {
    // 0x100003e88
    return ___stack_chk_fail();
}

// Address range: 0x100003e94 - 0x100003ea0
int32_t function_100003e94(int32_t fd) {
    // 0x100003e94
    return _close(fd);
}

// Address range: 0x100003ea0 - 0x100003eac
void function_100003ea0(int64_t * ptr) {
    // 0x100003ea0
    _free(ptr);
}

// Address range: 0x100003eac - 0x100003eb8
int32_t function_100003eac(int32_t fd, struct stat * buf) {
    // 0x100003eac
    return _fstat(fd, buf);
}

// Address range: 0x100003eb8 - 0x100003ec4
int32_t function_100003eb8(int32_t fd, int32_t length) {
    // 0x100003eb8
    return _ftruncate(fd, length);
}

// Address range: 0x100003ec4 - 0x100003ed0
int32_t function_100003ec4(int32_t fd, int32_t offset, int32_t whence) {
    // 0x100003ec4
    return _lseek(fd, offset, whence);
}

// Address range: 0x100003ed0 - 0x100003edc
int64_t * function_100003ed0(int32_t size) {
    // 0x100003ed0
    return _malloc(size);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(char * file, int32_t oflag, ...) {
    // 0x100003edc
    return _open(file, oflag);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x100003ee8
    return _read(fd, buf, nbytes);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * s) {
    // 0x100003ef4
    return _strlen(s);
}

// Address range: 0x100003f00 - 0x100003f0c
void function_100003f00(char * format, ...) {
    // 0x100003f00
    _warn(format);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(int32_t fd, int64_t * buf, int32_t n) {
    // 0x100003f0c
    return _write(fd, buf, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`#include <stdio.h>
#include <stdlib.h>

void main() {
    printf ("clearing screen");
    getchar();
    system("cls");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int32_t function_100003f70(void);
int32_t function_100003f7c(char * format, ...);
int32_t function_100003f88(char * command);

// ------- Dynamically Linked Functions Without Header --------

int32_t _getchar(void);
int32_t _printf(char * a1, ...);
int32_t _system(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003f44 - 0x100003f70
int64_t entry_point(int64_t a1) {
    // 0x100003f44
    _printf("clearing screen");
    _getchar();
    return _system("cls");
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(void) {
    // 0x100003f70
    return _getchar();
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * command) {
    // 0x100003f88
    return _system(command);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdbool.h>

int proper_divisors(const int n, bool print_flag)
{
    int count = 0;

    for (int i = 1; i < n; ++i) {
        if (n % i == 0) {
            count++;
            if (print_flag)
                printf("%d ", i);
        }
    }

    if (print_flag)
        printf("\n");

    return count;
}

int countProperDivisors(int n){
	int prod = 1,i,count=0;
	
	while(n%2==0){
		count++;
		n /= 2;
	}
	
	prod *= (1+count);

	for(i=3;i*i<=n;i+=2){
		count = 0;
		
		while(n%i==0){
			count++;
			n /= i;
		}
		
		prod *= (1+count);
	}
	
	if(n>2)
		prod *= 2;
	
	return prod - 1;
}

int main(void)
{
    for (int i = 1; i <= 10; ++i) {
        printf("%d: ", i);
        proper_divisors(i, true);
    }

    int max = 0;
    int max_i = 1;

    for (int i = 1; i <= 20000; ++i) {
        int v = countProperDivisors(i);
        if (v >= max) {
            max = v;
            max_i = i;
        }
    }

    printf("%d with %d divisors\n", max_i, max);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c30(void);
int64_t function_100003d10(void);
int32_t function_100003f74(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c30 - 0x100003d10
int64_t function_100003c30(void) {
    // 0x100003c30
    int64_t v1; // 0x100003c30
    int32_t v2 = v1; // 0x100003c3c
    uint32_t v3 = (int32_t)v1 % 2; // 0x100003c44
    int32_t v4 = 1 - v2; // 0x100003c60
    int32_t result = 0; // 0x100003c68
    if (v4 < 0 != (v4 & v2) < 0) {
        int32_t v5 = 1; // 0x100003cd8
        int32_t v6 = 0;
        int32_t v7 = v6; // 0x100003c8c
        int32_t v8; // 0x100003c98
        if (v2 % v5 == 0) {
            // 0x100003c94
            v8 = v6 + 1;
            v7 = v8;
            if (v3 != 0) {
                // 0x100003cac
                _printf("%d ", v1);
                v7 = v8;
            }
        }
        int32_t v9 = v7;
        v5++;
        int32_t v10 = v5 - v2; // 0x100003c60
        result = v9;
        while (v10 < 0 != ((v10 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003c70
            v6 = v9;
            v7 = v6;
            if (v2 % v5 == 0) {
                // 0x100003c94
                v8 = v6 + 1;
                v7 = v8;
                if (v3 != 0) {
                    // 0x100003cac
                    _printf("%d ", v1);
                    v7 = v8;
                }
            }
            // 0x100003cd4
            v9 = v7;
            v5++;
            v10 = v5 - v2;
            result = v9;
        }
    }
    // 0x100003ce4
    if (v3 != 0) {
        // 0x100003cf0
        _printf("\n");
    }
    // 0x100003d00
    return result;
}

// Address range: 0x100003d10 - 0x100003e54
int64_t function_100003d10(void) {
    int32_t v1 = 0; // 0x100003d24
    int64_t v2; // 0x100003d10
    int32_t v3 = v2;
    int32_t v4 = v3 / 2; // 0x100003d30
    v1++;
    while (v3 == 2 * v4) {
        // 0x100003d28
        v3 = v4;
        v4 = v3 / 2;
        v1++;
    }
    int32_t v5 = 9 - v3; // 0x100003d9c
    int32_t v6 = v1; // 0x100003da4
    int32_t v7; // 0x100003d10
    int32_t v8; // 0x100003e24
    if (v5 != 0 && v5 < 0 == (v5 & v3) < 0) {
        // 0x100003e20
        v7 = v3;
        v8 = v7 - 2;
        return (v1 << (int32_t)(v8 != 0 == v8 < 0 == (1 - v7 & v7) < 0)) - 1;
    }
    int32_t v9 = 3;
    int32_t v10 = v3; // 0x100003dd0
    int32_t v11 = 1; // 0x100003dd0
    int32_t v12; // 0x100003d10
    int32_t v13; // 0x100003d10
    int32_t v14; // 0x100003dec
    int32_t v15; // 0x100003d10
    if (v3 % v9 == 0) {
        v14 = v3 / v9;
        v15 = 2;
        v12 = v15;
        v13 = v14;
        v10 = v14;
        v11 = v15;
        while (v14 % v9 == 0) {
            // 0x100003dd8
            v14 = v13 / v9;
            v15 = v12 + 1;
            v12 = v15;
            v13 = v14;
            v10 = v14;
            v11 = v15;
        }
    }
    int32_t v16 = v10;
    v6 *= v11;
    int32_t v17 = v9 + 2; // 0x100003e14
    int32_t v18 = v17 * v17; // 0x100003d94
    int32_t v19 = v18 - v16; // 0x100003d9c
    while (v19 == 0 || v19 < 0 != ((v19 ^ v18) & (v16 ^ v18)) < 0) {
        // 0x100003db4
        v9 = v17;
        v13 = v16;
        v10 = v16;
        v11 = 1;
        if (v16 % v9 == 0) {
            v14 = v13 / v9;
            v15 = 2;
            v12 = v15;
            v13 = v14;
            v10 = v14;
            v11 = v15;
            while (v14 % v9 == 0) {
                // 0x100003dd8
                v14 = v13 / v9;
                v15 = v12 + 1;
                v12 = v15;
                v13 = v14;
                v10 = v14;
                v11 = v15;
            }
        }
        // 0x100003df8
        v16 = v10;
        v6 *= v11;
        v17 = v9 + 2;
        v18 = v17 * v17;
        v19 = v18 - v16;
    }
    // 0x100003e20
    v7 = v16;
    v8 = v7 - 2;
    return (v6 << (int32_t)(v8 != 0 == v8 < 0 == (1 - v7 & v7) < 0)) - 1;
}

// Address range: 0x100003e54 - 0x100003f74
int64_t entry_point(void) {
    int32_t v1 = 1;
    int64_t v2; // 0x100003e54
    _printf("%d: ", v2);
    function_100003c30();
    int32_t v3 = v1 + 1; // 0x100003eb8
    int32_t v4 = v1 - 9; // 0x100003e74
    v2 = 1;
    while (v4 == 0 || v4 < 0 != (8 - v1 & v3) < 0) {
        // 0x100003e84
        v1 = v3;
        _printf("%d: ", v2);
        function_100003c30();
        v3 = v1 + 1;
        v4 = v1 - 9;
        v2 = 1;
    }
    int32_t v5 = 1;
    function_100003d10();
    int32_t v6 = v5 + 1; // 0x100003f30
    int32_t v7 = v5 - 0x4e1f; // 0x100003ee0
    while (v7 == 0 || v7 < 0 != (0x4e1e - v5 & v6) < 0) {
        // 0x100003ef0
        v5 = v6;
        function_100003d10();
        v6 = v5 + 1;
        v7 = v5 - 0x4e1f;
    }
    // 0x100003f3c
    int64_t v8; // 0x100003e54
    _printf("%d with %d divisors\n", 1, v8);
    return 0;
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <err.h>
#include <string.h>

int main()
{
    struct stat s;
    int fd = open("mlijobs.txt", O_RDONLY);
    int cnt, max_cnt, occur;
    char *buf, *ptr;

    if (fd == -1) err(1, "open");
    fstat(fd, &s);
    ptr = buf = mmap(0, s.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);

    cnt = max_cnt = 0;
    while(ptr - buf < s.st_size - 33) {
        if (!strncmp(ptr, "License OUT", 11) && ++cnt >= max_cnt) {
            if (cnt > max_cnt) {
                max_cnt = cnt;
                occur = 0;
            }
            /* can't sprintf time stamp: might overlap */
            memmove(buf + 26 * occur, ptr + 14, 19);
            sprintf(buf + 26 * occur + 19, "%6d\n", cnt);
            occur++;
        } else if (!strncmp(ptr, "License IN ", 11)) cnt --;

        while (ptr < buf + s.st_size && *ptr++ != '\n');
    }

    printf(buf);
    munmap(buf, s.st_size);
    return close(fd);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f00(int64_t a1, int64_t a2, int64_t a3);
int64_t function_100003f0c(int64_t a1, int64_t a2, int64_t a3, char * a4);
int32_t function_100003f18(int32_t fd);
void function_100003f24(int32_t status, char * format, ...);
int32_t function_100003f30(int32_t fd, struct stat * buf);
int64_t * function_100003f3c(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset);
int32_t function_100003f48(int64_t * addr, int32_t len);
int32_t function_100003f54(char * file, int32_t oflag, ...);
int32_t function_100003f60(char * format, ...);
int32_t function_100003f6c(char * s1, char * s2, int32_t n);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memmove_chk(int64_t a1, int64_t a2, int64_t a3);
int64_t ___sprintf_chk(int64_t a1, int64_t a2, int64_t a3, char * a4);
int32_t _close(int32_t a1);
void _err(int32_t a1, char * a2, ...);
int32_t _fstat(int32_t a1, struct stat * a2);
int64_t * _mmap(int64_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _munmap(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);
int32_t _strncmp(char * a1, char * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003cac - 0x100003f00
int64_t entry_point(void) {
    int32_t v1 = _open("mlijobs.txt", 0); // 0x100003cc8
    if (v1 == -1) {
        // 0x100003ce4
        _err(1, "open");
    }
    // 0x100003cf4
    int64_t v2; // bp-168, 0x100003cac
    _fstat(v1, (struct stat *)&v2);
    int32_t v3; // 0x100003cac
    int64_t * v4 = _mmap(NULL, v3, 3, 2, v1, 0); // 0x100003d18
    int64_t v5 = v3; // 0x100003d40
    int64_t v6 = v5 - 33; // 0x100003d44
    int64_t v7 = 33 - v5; // 0x100003d48
    if (v7 < 0 == (v7 & v6) < 0) {
        // 0x100003ed8
        _printf((char *)v4);
        _munmap(v4, v3);
        return _close(v1);
    }
    int64_t v8 = (int64_t)v4;
    int64_t v9 = v8; // 0x100003cac
    int32_t v10 = 0; // 0x100003cac
    int32_t v11 = 0; // 0x100003cac
    char * v12 = (char *)v4; // 0x100003cac
    int32_t v13; // 0x100003cac
    int32_t v14; // 0x100003cac
    int32_t v15; // 0x100003cac
    int32_t v16; // 0x100003cac
    int32_t v17; // 0x100003cac
    char * v18; // 0x100003cac
    while (true) {
      lab_0x100003d58:
        // 0x100003d58
        v18 = v12;
        v14 = v11;
        int32_t v19 = v10;
        v16 = v15;
        v13 = v19;
        if (_strncmp(v18, "License OUT", 11) == 0) {
            int32_t v20 = v19 + 1; // 0x100003d80
            int32_t v21 = v20 - v14; // 0x100003d8c
            v13 = v20;
            if (v21 < 0 == ((v21 ^ v20) & (v20 ^ v14)) < 0) {
                int32_t v22 = v21 == 0 ? v16 : 0;
                int64_t v23 = (int64_t)(26 * v22) + v8; // 0x100003dd8
                ___memmove_chk(v23, v9 + 14, 19);
                ___sprintf_chk(v23 + 19, 0, -1, "%6d\n");
                v11 = v21 == 0 ? v14 : v20;
                v10 = v20;
                v17 = v22 + 1;
                goto lab_0x100003e78;
            } else {
                goto lab_0x100003e40;
            }
        } else {
            goto lab_0x100003e40;
        }
    }
  lab_0x100003ed8:
    // 0x100003ed8
    _printf((char *)v4);
    _munmap(v4, v3);
    return _close(v1);
  lab_0x100003e40:
    // 0x100003e40
    v11 = v14;
    v10 = v13 + (int32_t)(_strncmp(v18, "License IN ", 11) == 0);
    v17 = v16;
    goto lab_0x100003e78;
  lab_0x100003e78:;
    char * v24 = v18;
    int64_t v25 = (int64_t)v24;
    int64_t v26 = v25; // 0x100003e9c
    v12 = v24;
    while (v8 + v5 > v25) {
        int64_t v27 = v25 + 1; // 0x100003ea8
        char * v28 = (char *)v27;
        v26 = v27;
        v12 = v28;
        char * v29 = v28; // 0x100003ec8
        if (*v24 == 10) {
            // break -> 0x100003d34
            break;
        }
        v24 = v29;
        v25 = (int64_t)v24;
        v26 = v25;
        v12 = v24;
    }
    int64_t v30 = v26 - v8; // 0x100003d3c
    int64_t v31 = v30 - v6; // 0x100003d48
    v9 = v26;
    v15 = v17;
    if (v31 < 0 == ((v31 ^ v30) & (v30 ^ v6)) < 0) {
        // break -> 0x100003ed8
        goto lab_0x100003ed8;
    }
    goto lab_0x100003d58;
}

// Address range: 0x100003f00 - 0x100003f0c
int64_t function_100003f00(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003f00
    return ___memmove_chk(a1, a2, a3);
}

// Address range: 0x100003f0c - 0x100003f18
int64_t function_100003f0c(int64_t a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003f0c
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(int32_t fd) {
    // 0x100003f18
    return _close(fd);
}

// Address range: 0x100003f24 - 0x100003f30
void function_100003f24(int32_t status, char * format, ...) {
    // 0x100003f24
    _err(status, format);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(int32_t fd, struct stat * buf) {
    // 0x100003f30
    return _fstat(fd, buf);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset) {
    // 0x100003f3c
    return _mmap(addr, len, prot, flags, fd, offset);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(int64_t * addr, int32_t len) {
    // 0x100003f48
    return _munmap(addr, len);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * file, int32_t oflag, ...) {
    // 0x100003f54
    return _open(file, oflag);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * s1, char * s2, int32_t n) {
    // 0x100003f6c
    return _strncmp(s1, s2, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <stdio.h>
#include <stdlib.h>

typedef struct stem_t *stem;
struct stem_t { const char *str; stem next; };

void tree(int root, stem head)
{
	static const char *sdown = "  |", *slast = "  ", *snone = "   ";
	struct stem_t col = {0, 0}, *tail;

	for (tail = head; tail; tail = tail->next) {
		printf("%s", tail->str);
		if (!tail->next) break;
	}

	printf("--%d\n", root);

	if (root <= 1) return;

	if (tail && tail->str == slast)
		tail->str = snone;

	if (!tail)	tail = head = &col;
	else		tail->next = &col;

	while (root) { // make a tree by doing something random
		int r = 1 + (rand() % root);
		root -= r;
		col.str = root ? sdown : slast;

		tree(r, head);
	}

	tail->next = 0;
}

int main(int c, char**v)
{
	int n;
	if (c < 2 || (n = atoi(v[1])) < 0) n = 8;

	tree(n, 0);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d14(void);
int32_t function_100003f6c(char * nptr);
int32_t function_100003f78(char * format, ...);
int32_t function_100003f84(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x10000000003f90; // 0x100008000
int64_t g2 = 0x10000000003f94; // 0x100008008
int64_t g3 = 0x3f98; // 0x100008010

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003d14 - 0x100003ef8
int64_t function_100003d14(void) {
    // 0x100003d14
    int64_t v1; // 0x100003d14
    int32_t v2 = v1; // 0x100003d20
    int64_t v3 = 0; // bp-48, 0x100003d28
    int64_t v4; // 0x100003d14
    int64_t v5 = v4;
    bool v6 = true; // 0x100003d48
    while (v5 != 0) {
        // 0x100003d50
        _printf("%s", (char *)v1);
        int64_t v7 = *(int64_t *)(v5 + 8); // 0x100003d70
        v6 = false;
        if (v7 == 0) {
            // break -> 0x100003d9c
            break;
        }
        v5 = v7;
        v6 = true;
    }
    int64_t result = _printf("--%d\n", v1); // 0x100003db4
    int32_t v8 = v2 - 1; // 0x100003dbc
    if (v8 == 0 || v8 < 0 != (v2 & -v2) < 0) {
        // 0x100003eec
        return result;
    }
    // 0x100003dd0
    int64_t v9; // 0x100003d14
    if (v6) {
        // 0x100003e2c
        v9 = &v3;
    } else {
        int64_t * v10 = (int64_t *)v5; // 0x100003de8
        if (*v10 == g2) {
            // 0x100003e04
            *v10 = g3;
        }
        // 0x100003e40
        *(int64_t *)(v5 + 8) = (int64_t)&v3;
        v9 = v5;
    }
    int64_t result2 = result; // 0x100003e60
    if (v2 != 0) {
        int32_t v11 = v2;
        int32_t v12 = v11 + -1 - _rand() % v11; // 0x100003e8c
        v3 = v12 == 0 ? g2 : g1;
        result2 = function_100003d14();
        while (v12 != 0) {
            // 0x100003e68
            v11 = v12;
            v12 = v11 + -1 - _rand() % v11;
            v3 = v12 == 0 ? g2 : g1;
            result2 = function_100003d14();
        }
    }
    // 0x100003ee0
    *(int64_t *)(v9 + 8) = 0;
    // 0x100003eec
    return result2;
}

// Address range: 0x100003ef8 - 0x100003f6c
int64_t entry_point(void) {
    // 0x100003ef8
    int64_t v1; // 0x100003ef8
    int32_t v2 = v1; // 0x100003f08
    if (v2 < 2 == (1 - v2 & v2) < 0) {
        // 0x100003f24
        _atoi((char *)*(int64_t *)(v1 + 8));
    }
    // 0x100003f50
    function_100003d14();
    return 0;
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * nptr) {
    // 0x100003f6c
    return _atoi(nptr);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(void) {
    // 0x100003f84
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

char *list;
const char *line = "--------+--------------------\n";
int len = 0;

int irand(int n)
{
	int r, rand_max = RAND_MAX - (RAND_MAX % n);
	do { r = rand(); } while(r >= rand_max);
	return r / (rand_max / n);
}

char* get_digits(int n, char *ret)
{
	int i, j;
	char d[] = "123456789";

	for (i = 0; i < n; i++) {
		j = irand(9 - i);
		ret[i] = d[i + j];
		if (j) d[i + j] = d[i], d[i] = ret[i];
	}
	return ret;
}

#define MASK(x) (1 << (x - '1'))
int score(const char *digits, const char *guess, int *cow)
{
	int i, bits = 0, bull = *cow = 0;

	for (i = 0; guess[i] != '\0'; i++)
		if (guess[i] != digits[i])
			bits |= MASK(digits[i]);
		else ++bull;

	while (i--) *cow += ((bits & MASK(guess[i])) != 0);

	return bull;
}

void pick(int n, int got, int marker, char *buf)
{
	int i, bits = 1;
	if (got >= n)
		strcpy(list + (n + 1) * len++, buf);
	else
		for (i = 0; i < 9; i++, bits *= 2) {
			if ((marker & bits)) continue;
			buf[got] = i + '1';
			pick(n, got + 1, marker | bits, buf);
		}
}

void filter(const char *buf, int n, int bull, int cow)
{
	int i = 0, c;
	char *ptr = list;

	while (i < len) {
		if (score(ptr, buf, &c) != bull || c != cow)
			strcpy(ptr, list + --len * (n + 1));
		else
			ptr += n + 1, i++;
	}
}

void game(const char *tgt, char *buf)
{
	int i, p, bull, cow, n = strlen(tgt);

	for (i = 0, p = 1; i < n && (p *= 9 - i); i++);
	list = malloc(p * (n + 1));

	pick(n, 0, 0, buf);
	for (p = 1, bull = 0; n - bull; p++) {
		strcpy(buf, list + (n + 1) * irand(len));
		bull = score(tgt, buf, &cow);

		printf("Guess %2d| %s    (from: %d)\n"
			"Score   | %d bull, %d cow\n%s",
			p, buf, len, bull, cow, line);

		filter(buf, n, bull, cow);
	}
}

int main(int c, char **v)
{
	int n = c > 1 ? atoi(v[1]) : 4;

	char secret[10] = "", answer[10] = "";
	srand(time(0));

	printf("%sSecret  | %s\n%s", line, get_digits(n, secret), line);
	game(secret, answer);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000036c4(void);
int64_t function_100003738(void);
int64_t function_10000387c(void);
int64_t function_10000399c(void);
int64_t function_100003ab0(void);
int64_t function_100003bac(void);
int64_t function_100003ec0(int64_t a1);
int64_t function_100003ecc(int64_t a1, int64_t a2, int64_t a3);
int32_t function_100003ed8(char * nptr);
int64_t * function_100003ee4(int32_t size);
int32_t function_100003ef0(char * format, ...);
int32_t function_100003efc(void);
void function_100003f08(int32_t seed);
int32_t function_100003f14(char * s);
int32_t function_100003f20(int32_t * timer);

// --------------------- Global Variables ---------------------

int32_t g1 = -0x1120531; // 0x100008008
int64_t g2 = 0x200000000; // 0x100008010

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _atoi(char * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _strlen(char * a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000036c4 - 0x100003738
int64_t function_1000036c4(void) {
    // 0x1000036c4
    int64_t v1; // 0x1000036c4
    int32_t v2 = v1; // 0x1000036d0
    int32_t v3 = 0x7fffffff % v2 ^ 0x7fffffff; // 0x1000036e0
    int32_t v4 = _rand(); // 0x1000036f4
    while ((v4 - v3) < 0 == (v4 & -((v4 - v3))) < 0) {
        // 0x1000036f4
        v4 = _rand();
    }
    // 0x100003718
    return v4 / (v3 / v2);
}

// Address range: 0x100003738 - 0x10000387c
int64_t function_100003738(void) {
    int64_t * v1 = (int64_t *)*(int64_t *)0x100004008;
    int64_t result; // 0x100003738
    int32_t v2 = result; // 0x100003754
    char * v3 = (char *)0x3837363534333231; // bp-40, 0x100003768
    int32_t v4 = -v2; // 0x100003784
    int64_t * v5 = v1; // 0x10000378c
    int64_t v6; // 0x100003738
    if (v4 < 0 != (v4 & v2) < 0) {
        int64_t v7 = (int64_t)&v3;
        int32_t v8 = 0; // 0x100003834
        int64_t v9 = function_1000036c4(); // 0x1000037a0
        int32_t v10 = v9; // 0x1000037a4
        char * v11 = (char *)((int64_t)(v8 + v10) + v7); // 0x1000037bc
        int64_t v12 = v8; // 0x1000037c4
        char * v13 = (char *)(result + v12); // 0x1000037cc
        *v13 = *v11;
        char * v14; // 0x1000037f4
        if (v10 != 0) {
            // 0x1000037e4
            v14 = (char *)(v12 + v7);
            *v11 = *v14;
            *v14 = *v13;
        }
        // 0x100003830
        v8++;
        while (v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x100003794
            v9 = function_1000036c4();
            v10 = v9;
            v11 = (char *)((int64_t)(v8 + v10) + v7);
            v12 = v8;
            v13 = (char *)(result + v12);
            *v13 = *v11;
            if (v10 != 0) {
                // 0x1000037e4
                v14 = (char *)(v12 + v7);
                *v11 = *v14;
                *v14 = *v13;
            }
            // 0x100003830
            v8++;
        }
        // 0x10000377c
        v5 = (int64_t *)*(int64_t *)0x100004008;
        v6 = v9;
    }
    // 0x100003840
    if (*v5 != *v1) {
        // 0x100003868
        ___stack_chk_fail(v6);
    }
    // 0x10000386c
    return result;
}

// Address range: 0x10000387c - 0x10000399c
int64_t function_10000387c(void) {
    // 0x10000387c
    int64_t v1; // 0x10000387c
    int32_t * v2 = (int32_t *)v1; // 0x100003888
    *v2 = 0;
    char v3 = *(char *)v1; // 0x1000038ac
    int32_t v4 = 0; // 0x1000038b8
    if (v3 == 0) {
        // 0x100003990
        return 0;
    }
    int32_t v5 = 0;
    int32_t v6 = 0;
    char v7 = *(char *)v1; // 0x1000038d4
    int32_t v8; // 0x10000387c
    int32_t v9; // 0x10000387c
    if (v3 == v7) {
        // 0x100003910
        v8 = v5;
        v9 = v6 + 1;
    } else {
        // 0x1000038e8
        v8 = 1 << (int32_t)v7 - 49 | v5;
        v9 = v6;
    }
    int32_t result = v9;
    int32_t v10 = v8;
    v4++;
    int64_t v11 = v4; // 0x1000038a8
    char v12 = *(char *)(v1 + v11); // 0x1000038ac
    while (v12 != 0) {
        // 0x1000038c0
        v5 = v10;
        v6 = result;
        v7 = *(char *)(v11 + v1);
        if (v12 == v7) {
            // 0x100003910
            v8 = v5;
            v9 = v6 + 1;
        } else {
            // 0x1000038e8
            v8 = 1 << (int32_t)v7 - 49 | v5;
            v9 = v6;
        }
        // 0x100003924
        result = v9;
        v10 = v8;
        v4++;
        v11 = v4;
        v12 = *(char *)(v1 + v11);
    }
    // 0x100003938
    if (v4 == 0) {
        // 0x100003990
        return result;
    }
    int32_t v13 = v4;
    v13--;
    char v14 = *(char *)(v1 + (int64_t)v13); // 0x100003960
    int64_t v15; // 0x10000387c
    int32_t v16 = *(int32_t *)&v15; // 0x100003980
    *v2 = v16 + (int32_t)((1 << (int32_t)v14 - 49 & v10) != 0);
    while (v13 != 0) {
        // 0x100003954
        v13--;
        v14 = *(char *)(v1 + (int64_t)v13);
        v16 = *(int32_t *)&v15;
        *v2 = v16 + (int32_t)((1 << (int32_t)v14 - 49 & v10) != 0);
    }
    // 0x100003990
    return result;
}

// Address range: 0x10000399c - 0x100003ab0
int64_t function_10000399c(void) {
    // 0x10000399c
    int64_t v1; // 0x10000399c
    int32_t v2 = v1; // 0x1000039a8
    int32_t v3 = v1; // 0x1000039ac
    int32_t v4 = v3 - v2; // 0x1000039c8
    if (v4 < 0 == ((v4 ^ v3) & (int32_t)(v1 ^ v1)) < 0) {
        int32_t v5 = g1; // 0x1000039f0
        g1 = v5 + 1;
        // 0x100003aa4
        return ___strcpy_chk(g2 + (int64_t)(v5 * (v2 + 1)), v1, -1);
    }
    int32_t v6 = 1; // 0x10000399c
    int32_t v7 = 0;
    int64_t v8; // 0x10000399c
    int64_t result = v8; // 0x100003a40
    if ((v6 & (int32_t)v1) == 0) {
        // 0x100003a4c
        *(char *)((0x100000000 * v1 >> 32) + v1) = (char)v7 + 49;
        result = function_10000399c();
    }
    int32_t v9 = v7 + 1; // 0x100003a88
    v6 *= 2;
    while (v9 != 9) {
        // 0x100003a30
        v7 = v9;
        if ((v6 & (int32_t)v1) == 0) {
            // 0x100003a4c
            *(char *)((0x100000000 * v1 >> 32) + v1) = (char)v7 + 49;
            result = function_10000399c();
        }
        // 0x100003a84
        v9 = v7 + 1;
        v6 *= 2;
    }
    // 0x100003aa4
    return result;
}

// Address range: 0x100003ab0 - 0x100003bac
int64_t function_100003ab0(void) {
    int32_t v1 = -g1; // 0x100003af0
    if (v1 < 0 == (g1 & v1) < 0) {
        // 0x100003ba0
        int64_t result; // 0x100003ab0
        return result;
    }
    // 0x100003b00
    int64_t v2; // 0x100003ab0
    int32_t v3 = (int32_t)v2 + 1;
    int32_t v4 = 0;
    int64_t v5 = function_10000387c(); // 0x100003b0c
    int32_t v6; // 0x100003ab0
    int64_t v7; // 0x100003ab0
    int32_t v8; // 0x100003b54
    int64_t v9; // 0x100003b70
    int32_t v10; // 0x100003ab0
    int64_t result2; // 0x100003ab0
    if (v10 == (int32_t)v2 == (int32_t)v2 == (int32_t)v5) {
        // 0x100003b78
        v7 = g2 + (0x100000000 * v2 + 0x100000000 >> 32);
        v6 = v4 + 1;
        result2 = v5;
    } else {
        // 0x100003b3c
        v8 = g1 - 1;
        g1 = v8;
        v9 = ___strcpy_chk(g2, g2 + (int64_t)(v8 * v3), -1);
        v7 = g2;
        v6 = v4;
        result2 = v9;
    }
    int32_t v11 = v6;
    int32_t v12 = v11 - g1; // 0x100003af0
    while (v12 < 0 != ((v12 ^ v11) & (g1 ^ v11)) < 0) {
        int64_t v13 = v7;
        v4 = v11;
        v5 = function_10000387c();
        if (v10 == (int32_t)v2 == (int32_t)v2 == (int32_t)v5) {
            // 0x100003b78
            v7 = v13 + (0x100000000 * v2 + 0x100000000 >> 32);
            v6 = v4 + 1;
            result2 = v5;
        } else {
            // 0x100003b3c
            v8 = g1 - 1;
            g1 = v8;
            v9 = ___strcpy_chk(v13, g2 + (int64_t)(v8 * v3), -1);
            v7 = v13;
            v6 = v4;
            result2 = v9;
        }
        // 0x100003b9c
        v11 = v6;
        v12 = v11 - g1;
    }
    // 0x100003ba0
    return result2;
}

// Address range: 0x100003bac - 0x100003dac
int64_t function_100003bac(void) {
    // 0x100003bac
    int64_t v1; // 0x100003bac
    int32_t v2 = _strlen((char *)v1); // 0x100003bc4
    int32_t v3 = -v2; // 0x100003be8
    int32_t v4 = 0; // 0x100003bf8
    int32_t v5 = 1; // 0x100003bf8
    int32_t v6 = 1; // 0x100003bf8
    if (v3 < 0 != (v2 & v3) < 0) {
        v5 *= (9 - v4);
        v6 = 0;
        while (v5 != 0) {
            // 0x100003be0
            v4++;
            int32_t v7 = v4 - v2; // 0x100003be8
            v6 = v5;
            if (v7 < 0 == ((v7 ^ v4) & (v4 ^ v2)) < 0) {
                // break -> 0x100003c48
                break;
            }
            v5 *= (9 - v4);
            v6 = 0;
        }
    }
    int32_t v8 = v2 + 1; // 0x100003c58
    g2 = (int64_t)_malloc(v6 * v8);
    int64_t result = function_10000399c(); // 0x100003cb0
    if (v2 == 0) {
        // 0x100003da0
        return result;
    }
    ___strcpy_chk(v1, g2 + (int64_t)(v8 * (int32_t)function_1000036c4()), -1);
    int64_t v9 = function_10000387c(); // 0x100003d18
    int32_t v10; // bp-48, 0x100003bac
    int64_t v11; // 0x100003bac
    _printf("Guess %2d| %s    (from: %d)\nScore   | %d bull, %d cow\n%s", v1, &v10, v11, v1, v1, (char *)v1);
    v11 = v10;
    result = function_100003ab0();
    // 0x100003cb8
    while (v2 != (int32_t)v9) {
        // 0x100003cb8
        ___strcpy_chk(v1, g2 + (int64_t)(v8 * (int32_t)function_1000036c4()), -1);
        v9 = function_10000387c();
        _printf("Guess %2d| %s    (from: %d)\nScore   | %d bull, %d cow\n%s", v1, &v10, v11, v1, v1, (char *)v1);
        v11 = v10;
        result = function_100003ab0();
    }
    // 0x100003da0
    return result;
}

// Address range: 0x100003dac - 0x100003ec0
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dc0
    int64_t v2; // 0x100003dac
    int32_t v3 = v2; // 0x100003dcc
    int32_t v4 = v3 - 1; // 0x100003dd8
    if (v4 != 0 && v4 < 0 == (v3 & -v3) < 0) {
        // 0x100003de8
        _atoi((char *)*(int64_t *)(v2 + 8));
    }
    int64_t v5 = 0; // bp-40, 0x100003e18
    _srand(_time(NULL));
    function_100003738();
    _printf("%sSecret  | %s\n%s", &v5, (char *)v2, (char *)v2);
    int64_t v6 = function_100003bac(); // 0x100003e88
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003eac
        ___stack_chk_fail(v6);
    }
    // 0x100003eb0
    return 0;
}

// Address range: 0x100003ec0 - 0x100003ecc
int64_t function_100003ec0(int64_t a1) {
    // 0x100003ec0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ecc - 0x100003ed8
int64_t function_100003ecc(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003ecc
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003ed8 - 0x100003ee4
int32_t function_100003ed8(char * nptr) {
    // 0x100003ed8
    return _atoi(nptr);
}

// Address range: 0x100003ee4 - 0x100003ef0
int64_t * function_100003ee4(int32_t size) {
    // 0x100003ee4
    return _malloc(size);
}

// Address range: 0x100003ef0 - 0x100003efc
int32_t function_100003ef0(char * format, ...) {
    // 0x100003ef0
    return _printf(format);
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(void) {
    // 0x100003efc
    return _rand();
}

// Address range: 0x100003f08 - 0x100003f14
void function_100003f08(int32_t seed) {
    // 0x100003f08
    _srand(seed);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * s) {
    // 0x100003f14
    return _strlen(s);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(int32_t * timer) {
    // 0x100003f20
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void last_sunday(struct tm *res, unsigned year, unsigned mon)
{
	time_t sec;

	*res = (struct tm){
		.tm_year = year + mon / 12,
		.tm_mon = mon % 12,
		.tm_hour = 12,
		.tm_isdst = -1
	};
	sec = mktime(res);
	sec -= res->tm_wday * 86400;
	*res = *localtime(&sec);
}

int main(int argc, char *argv[])
{
	struct tm date;
	char str[12];
	unsigned m, y;

	if (argc < 2)
		return 1;
	y = strtoul(argv[1], NULL, 0) - 1900;
	for (m = 1; m <= 12; ++m) {
		last_sunday(&date, y, m);
		strftime(str, sizeof str, "%F", &date);
		puts(str);
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d60(void);
int64_t function_100003f50(void);
struct tm * function_100003f5c(int32_t * timer);
int64_t * function_100003f68(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f74(struct tm * tp);
int32_t function_100003f80(char * s);
int32_t function_100003f8c(char * s, int32_t maxsize, char * format, struct tm * tp);
int32_t function_100003f98(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
struct tm * _localtime(int32_t * a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _mktime(struct tm * a1);
int32_t _puts(char * a1);
int32_t _strftime(char * a1, int32_t a2, char * a3, struct tm * a4);
int32_t _strtoul(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003d60 - 0x100003e3c
int64_t function_100003d60(void) {
    int64_t v1 = 0; // bp-96, 0x100003d80
    int64_t v2; // 0x100003d60
    int64_t * v3 = (int64_t *)v2; // 0x100003ddc
    _memcpy(v3, &v1, 56);
    int64_t v4 = _mktime((struct tm *)v2); // 0x100003de4
    int64_t v5 = v4; // bp-40, 0x100003df0
    v5 = v4 - (int64_t)(0x15180 * *(int32_t *)(v2 + 24));
    return (int64_t)_memcpy(v3, (int64_t *)_localtime((int32_t *)&v5), 56);
}

// Address range: 0x100003e3c - 0x100003f50
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e50
    int64_t v2; // 0x100003e3c
    int32_t v3 = v2; // 0x100003e5c
    if (v3 < 2 != (1 - v3 & v3) < 0) {
        // 0x100003f40
        return 1;
    }
    // 0x100003e84
    _strtoul((char *)*(int64_t *)(v2 + 8), NULL, 0);
    for (int32_t i = 1; i < 13; i++) {
        // 0x100003ec0
        function_100003d60();
        int64_t v4; // bp-112, 0x100003e3c
        int64_t v5; // bp-36, 0x100003e3c
        _strftime((char *)&v5, 12, "%F", (struct tm *)&v4);
        _puts((char *)&v5);
    }
    // 0x100003f14
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f3c
        ___stack_chk_fail();
    }
    // 0x100003f40
    return 0;
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t function_100003f50(void) {
    // 0x100003f50
    return ___stack_chk_fail();
}

// Address range: 0x100003f5c - 0x100003f68
struct tm * function_100003f5c(int32_t * timer) {
    // 0x100003f5c
    return _localtime(timer);
}

// Address range: 0x100003f68 - 0x100003f74
int64_t * function_100003f68(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f68
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(struct tm * tp) {
    // 0x100003f74
    return _mktime(tp);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * s) {
    // 0x100003f80
    return _puts(s);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * s, int32_t maxsize, char * format, struct tm * tp) {
    // 0x100003f8c
    return _strftime(s, maxsize, format, tp);
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * nptr, char ** endptr, int32_t base) {
    // 0x100003f98
    return _strtoul(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdbool.h>
#include <stdio.h>
#include <string.h>

void memoizeIsPrime( bool * result, const int N )
{
    result[2] = true;
    result[3] = true;
    int prime[N];
    prime[0] = 3;
    int end = 1;
    for (int n = 5; n < N; n += 2)
    {
        bool n_is_prime = true;
        for (int i = 0; i < end; ++i)
        {
            const int PRIME = prime[i];
            if (n % PRIME == 0)
            {
                n_is_prime = false;
                break;
            }
            if (PRIME * PRIME > n)
            {
                break;
            }
        }
        if (n_is_prime)
        {
            prime[end++] = n;
            result[n] = true;
        }
    }
}/* memoizeIsPrime */

int sumOfDecimalDigits( int n )
{
    int sum = 0;
    while (n > 0)
    {
        sum += n % 10;
        n /= 10;
    }
    return sum;
}/* sumOfDecimalDigits */

int main( void )
{
    const int N = 500;

    printf( "Rosetta Code: additive primes less than %d:\n", N );

    bool is_prime[N];
    memset( is_prime, 0, sizeof(is_prime) );
    memoizeIsPrime( is_prime, N );

    printf( "   2" );
    int count = 1;
    for (int i = 3; i < N; i += 2)
    {
        if (is_prime[i] && is_prime[sumOfDecimalDigits( i )])
        {
            printf( "%4d", i );
            ++count;
            if ((count % 10) == 0)
            {
                printf( "\n" );
            }
        }
    }
    printf( "\nThose were %d additive primes.\n", count );
    return 0;
}/* main */
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b44(int64_t a1, int32_t a2);
int64_t function_100003ba4(void);
int64_t function_100003d20(void);
int64_t function_100003f18(int64_t a1);
void function_100003f24(int64_t * s, int32_t n);
int32_t function_100003f30(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
void _bzero(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b44 - 0x100003ba4
int64_t function_100003b44(int64_t a1, int32_t a2) {
    // 0x100003b44
    *(char *)(a1 + 2) = 1;
    *(char *)(a1 + 3) = 1;
    return ___chkstk_darwin();
}

// Address range: 0x100003ba4 - 0x100003d20
int64_t function_100003ba4(void) {
    // 0x100003ba4
    int64_t v1; // 0x100003ba4
    int64_t v2 = v1;
    int64_t v3; // 0x100003ba4
    int64_t v4 = (int64_t)&v3 - *(int64_t *)(v2 - 80); // 0x100003bac
    int64_t * v5 = (int64_t *)(v2 - 72); // 0x100003bb4
    *v5 = v4;
    *(int32_t *)v4 = 3;
    int32_t * v6 = (int32_t *)(v2 - 44); // 0x100003bc8
    *v6 = 1;
    int32_t * v7 = (int32_t *)(v2 - 48); // 0x100003bd0
    *v7 = 5;
    int32_t * v8 = (int32_t *)(v2 - 20); // 0x100003bdc
    int32_t v9 = *v8; // 0x100003bdc
    int32_t v10 = 5 - v9; // 0x100003be0
    if (v10 < 0 != (v10 & v9) < 0) {
        char * v11 = (char *)(v2 - 49); // 0x100003bf4
        int32_t * v12 = (int32_t *)(v2 - 56); // 0x100003bf8
        *v11 = 1;
        *v12 = 0;
        int32_t v13 = *v6; // 0x100003c04
        int32_t v14 = -v13; // 0x100003c08
        int32_t v15; // 0x100003c20
        int32_t v16; // 0x100003c28
        int32_t v17; // 0x100003ca0
        int32_t v18; // 0x100003c5c
        int32_t v19; // 0x100003c64
        int32_t v20; // 0x100003c80
        int32_t v21; // 0x100003c04
        int32_t v22; // 0x100003c08
        if (v14 < 0 == (v13 & v14) < 0) {
            // 0x100003c8c
            if (*v11 % 2 != 0) {
                // 0x100003c98
                v17 = *v6;
                *v6 = v17 + 1;
                *(int32_t *)(4 * (int64_t)v17 + *v5) = *v7;
                *(char *)(*(int64_t *)(v2 - 16) + (int64_t)*v7) = 1;
            }
        } else {
            v15 = *(int32_t *)*v5;
            *(int32_t *)(v2 - 60) = v15;
            v16 = *v7;
            while (v16 % v15 != 0) {
                // 0x100003c54
                v18 = v15 * v15;
                v19 = v18 - v16;
                if (v19 != 0 && v19 < 0 == ((v19 ^ v18) & (v16 ^ v18)) < 0) {
                    goto lab_0x100003c8c_2;
                }
                // 0x100003c7c
                v20 = *v12 + 1;
                *v12 = v20;
                v21 = *v6;
                v22 = v20 - v21;
                if (v22 < 0 == ((v22 ^ v20) & (v21 ^ v20)) < 0) {
                    goto lab_0x100003c8c_2;
                }
                v15 = *(int32_t *)(4 * (int64_t)v20 + *v5);
                *(int32_t *)(v2 - 60) = v15;
                v16 = *v7;
            }
            // 0x100003c8c
            *v11 = 0;
        }
        int32_t v23 = *v7 + 2; // 0x100003cd4
        *v7 = v23;
        int32_t v24 = *v8; // 0x100003bdc
        while (v23 - v24 < 0 != ((v23 - v24 ^ v23) & (v24 ^ v23)) < 0) {
            // 0x100003bf0
            *v11 = 1;
            *v12 = 0;
            v13 = *v6;
            v14 = -v13;
            if (v14 < 0 == (v13 & v14) < 0) {
                // 0x100003c8c
                if (*v11 % 2 != 0) {
                    // 0x100003c98
                    v17 = *v6;
                    *v6 = v17 + 1;
                    *(int32_t *)(4 * (int64_t)v17 + *v5) = *v7;
                    *(char *)(*(int64_t *)(v2 - 16) + (int64_t)*v7) = 1;
                }
            } else {
                v15 = *(int32_t *)*v5;
                *(int32_t *)(v2 - 60) = v15;
                v16 = *v7;
                while (v16 % v15 != 0) {
                    // 0x100003c54
                    v18 = v15 * v15;
                    v19 = v18 - v16;
                    if (v19 != 0 && v19 < 0 == ((v19 ^ v18) & (v16 ^ v18)) < 0) {
                        goto lab_0x100003c8c_2;
                    }
                    // 0x100003c7c
                    v20 = *v12 + 1;
                    *v12 = v20;
                    v21 = *v6;
                    v22 = v20 - v21;
                    if (v22 < 0 == ((v22 ^ v20) & (v21 ^ v20)) < 0) {
                        goto lab_0x100003c8c_2;
                    }
                    v15 = *(int32_t *)(4 * (int64_t)v20 + *v5);
                    *(int32_t *)(v2 - 60) = v15;
                    v16 = *v7;
                }
                // 0x100003c8c
                *v11 = 0;
            }
            // 0x100003cd0
            v23 = *v7 + 2;
            *v7 = v23;
            v24 = *v8;
        }
    }
    // 0x100003ce0
    *(int64_t *)(v2 - 88) = *(int64_t *)(v2 - 32);
    int64_t result; // 0x100003ba4
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003d08
        result = ___stack_chk_fail(v1);
    }
    // 0x100003d0c
    return result;
}

// Address range: 0x100003d20 - 0x100003d80
int64_t function_100003d20(void) {
    // 0x100003d20
    int64_t v1; // 0x100003d20
    int32_t v2 = v1; // 0x100003d24
    uint32_t v3 = v2; // 0x100003d3c
    if (v2 < 1) {
        // 0x100003d74
        return 0;
    }
    int32_t result = 0; // 0x100003d3c
    result += v3 % 10;
    while (v3 >= 10) {
        // 0x100003d44
        v3 /= 10;
        result += v3 % 10;
    }
    // 0x100003d74
    return result;
}

// Address range: 0x100003d80 - 0x100003f18
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003d98
    int64_t v2; // 0x100003d80
    _printf("Rosetta Code: additive primes less than %d:\n", v2);
    int64_t v3; // bp-532, 0x100003d80
    int64_t v4 = &v3; // 0x100003dd4
    _bzero(&v3, 500);
    function_100003b44(v4, 500);
    _printf("   2");
    int32_t v5 = 1;
    int32_t v6 = 3;
    int32_t v7 = v5; // 0x100003e2c
    int32_t v8; // 0x100003e70
    unsigned char v9; // 0x100003e44
    if (*(char *)((int64_t)v6 + v4) % 2 != 0) {
        // 0x100003e34
        v9 = *(char *)((0x100000000 * function_100003d20() >> 32) + v4);
        v7 = v5;
        if (v9 % 2 != 0) {
            // 0x100003e50
            _printf("%4d", 500);
            v8 = v5 + 1;
            v7 = v8;
            if (v8 % 10 == 0) {
                // 0x100003e9c
                _printf("\n");
                v7 = v8;
            }
        }
    }
    int32_t v10 = v6 + 2; // 0x100003eb8
    while (v6 < 498 != (497 - v6 & v10) < 0) {
        // 0x100003e1c
        v5 = v7;
        v6 = v10;
        v7 = v5;
        if (*(char *)((int64_t)v6 + v4) % 2 != 0) {
            // 0x100003e34
            v9 = *(char *)((0x100000000 * function_100003d20() >> 32) + v4);
            v7 = v5;
            if (v9 % 2 != 0) {
                // 0x100003e50
                _printf("%4d", 500);
                v8 = v5 + 1;
                v7 = v8;
                if (v8 % 10 == 0) {
                    // 0x100003e9c
                    _printf("\n");
                    v7 = v8;
                }
            }
        }
        // 0x100003eb4
        v10 = v6 + 2;
    }
    int32_t v11 = _printf("\nThose were %d additive primes.\n", 500); // 0x100003edc
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003f00
        ___stack_chk_fail((int64_t)v11);
    }
    // 0x100003f04
    return 0;
}

// Address range: 0x100003f18 - 0x100003f24
int64_t function_100003f18(int64_t a1) {
    // 0x100003f18
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f24 - 0x100003f30
void function_100003f24(int64_t * s, int32_t n) {
    // 0x100003f24
    _bzero(s, n);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * format, ...) {
    // 0x100003f30
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>

// See https://en.wikipedia.org/wiki/Divisor_function
unsigned int divisor_count(unsigned int n) {
    unsigned int total = 1;
    // Deal with powers of 2 first
    for (; (n & 1) == 0; n >>= 1) {
        ++total;
    }
    // Odd prime factors up to the square root
    for (unsigned int p = 3; p * p <= n; p += 2) {
        unsigned int count = 1;
        for (; n % p == 0; n /= p) {
            ++count;
        }
        total *= count;
    }
    // If n > 1 then it's prime
    if (n > 1) {
        total *= 2;
    }
    return total;
}

int main() {
    const unsigned int limit = 100;
    unsigned int n;

    printf("Count of divisors for the first %d positive integers:\n", limit);
    for (n = 1; n <= limit; ++n) {
        printf("%3d", divisor_count(n));
        if (n % 20 == 0) {
            printf("\n");
        }
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d70(void);
int32_t function_100003f54(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d70 - 0x100003e8c
int64_t function_100003d70(void) {
    // 0x100003d70
    int64_t v1; // 0x100003d70
    int32_t v2 = v1; // 0x100003d74
    int32_t v3 = v2; // 0x100003d90
    int32_t v4 = 1; // 0x100003d90
    int32_t v5 = 1; // 0x100003d90
    if (v2 % 2 == 0) {
        uint32_t v6 = v2;
        v5++;
        int32_t v7 = v6 / 2; // 0x100003dac
        v3 = v7;
        v4 = v5;
        while ((v6 & 2) == 0) {
            // 0x100003d98
            v6 = v7;
            v5++;
            v7 = v6 / 2;
            v3 = v7;
            v4 = v5;
        }
    }
    int32_t v8 = v3;
    int32_t v9 = v4; // 0x100003ddc
    int32_t v10; // 0x100003d70
    if (v8 <= 9 == (v8 != 9)) {
        // 0x100003e5c
        v10 = v8;
        return v4 << (int32_t)(v10 != 1 == (v10 != 0));
    }
    uint32_t v11 = 3;
    int32_t v12 = v8; // 0x100003e0c
    int32_t v13 = 1; // 0x100003e0c
    int32_t v14; // 0x100003d70
    int32_t v15; // 0x100003d70
    int32_t v16; // 0x100003e18
    int32_t v17; // 0x100003e2c
    if (v8 % v11 == 0) {
        v16 = 2;
        v17 = v8 / v11;
        v14 = v16;
        v15 = v17;
        v12 = v17;
        v13 = v16;
        while (v17 % v11 == 0) {
            // 0x100003e14
            v16 = v14 + 1;
            v17 = v15 / v11;
            v14 = v16;
            v15 = v17;
            v12 = v17;
            v13 = v16;
        }
    }
    int32_t v18 = v12;
    v9 *= v13;
    int32_t v19 = v11 + 2; // 0x100003e50
    uint32_t v20 = v19 * v19; // 0x100003dcc
    while (v20 >= v18 != v20 != v18) {
        // 0x100003df0
        v11 = v19;
        v15 = v18;
        v12 = v18;
        v13 = 1;
        if (v18 % v11 == 0) {
            v16 = 2;
            v17 = v15 / v11;
            v14 = v16;
            v15 = v17;
            v12 = v17;
            v13 = v16;
            while (v17 % v11 == 0) {
                // 0x100003e14
                v16 = v14 + 1;
                v17 = v15 / v11;
                v14 = v16;
                v15 = v17;
                v12 = v17;
                v13 = v16;
            }
        }
        // 0x100003e38
        v18 = v12;
        v9 *= v13;
        v19 = v11 + 2;
        v20 = v19 * v19;
    }
    // 0x100003e5c
    v10 = v18;
    return v9 << (int32_t)(v10 != 1 == (v10 != 0));
}

// Address range: 0x100003e8c - 0x100003f54
int64_t entry_point(void) {
    // 0x100003e8c
    int64_t v1; // 0x100003e8c
    _printf("Count of divisors for the first %d positive integers:\n", v1);
    for (int32_t i = 1; i < 101; i++) {
        // 0x100003edc
        function_100003d70();
        _printf("%3d", v1);
        if (i % 20 == 0) {
            // 0x100003f20
            _printf((char *)0x100003f9b);
        }
    }
    // 0x100003f44
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <sys/types.h>
#include <dirent.h>
#include <regex.h>
#include <stdio.h>

enum {
    WALK_OK = 0,
    WALK_BADPATTERN,
    WALK_BADOPEN,
};

int walker(const char *dir, const char *pattern)
{
    struct dirent *entry;
    regex_t reg;
    DIR *d;

    if (regcomp(&reg, pattern, REG_EXTENDED | REG_NOSUB))
        return WALK_BADPATTERN;
    if (!(d = opendir(dir)))
        return WALK_BADOPEN;
    while (entry = readdir(d))
        if (!regexec(&reg, entry->d_name, 0, NULL, 0))
            puts(entry->d_name);
    closedir(d);
    regfree(&reg);
    return WALK_OK;
}

int main()
{
    walker(".", ".\\.c$");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _TYPEDEF_regmatch_t {
    int32_t e0;
    int32_t e1;
};

struct __dirstream {
    int32_t e0;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct re_pattern_buffer {
    char * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    int64_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e18(void);
int32_t function_100003f4c(struct __dirstream * dirp);
struct __dirstream * function_100003f58(char * name);
int32_t function_100003f64(char * s);
struct dirent * function_100003f70(struct __dirstream * dirp);
int32_t function_100003f7c(struct re_pattern_buffer * preg, char * pattern, int32_t cflags);
int32_t function_100003f88(struct re_pattern_buffer * preg, char * string, int32_t nmatch, struct _TYPEDEF_regmatch_t pmatch[1], int32_t eflags);
void function_100003f94(struct re_pattern_buffer * preg);

// ------- Dynamically Linked Functions Without Header --------

int32_t _closedir(struct __dirstream * a1);
struct __dirstream * _opendir(char * a1);
int32_t _puts(char * a1);
struct dirent * _readdir(struct __dirstream * a1);
int32_t _regcomp(struct re_pattern_buffer * a1, char * a2, int32_t a3);
int32_t _regexec(struct re_pattern_buffer * a1, char * a2, int32_t a3, struct _TYPEDEF_regmatch_t a4[1], int32_t a5);
void _regfree(struct re_pattern_buffer * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e18 - 0x100003f10
int64_t function_100003e18(void) {
    // 0x100003e18
    int64_t v1; // bp-80, 0x100003e18
    int64_t v2; // 0x100003e18
    if (_regcomp((struct re_pattern_buffer *)&v1, (char *)v2, 5) != 0) {
        // 0x100003f00
        return 1;
    }
    struct __dirstream * v3 = _opendir((char *)v2); // 0x100003e5c
    if (v3 == NULL) {
        // 0x100003f00
        return 2;
    }
    struct dirent * v4 = _readdir(v3); // 0x100003e8c
    if (v4 != NULL) {
        char * v5 = (char *)((int64_t)v4 + 21); // 0x100003ec0
        if (_regexec((struct re_pattern_buffer *)&v1, v5, 0, {(struct {int32_t e0; int32_t e1;}){.e0 = 0, .e1 = 0}}, 0) == 0) {
            // 0x100003ed4
            _puts(v5);
        }
        struct dirent * v6 = _readdir(v3); // 0x100003e8c
        while (v6 != NULL) {
            // 0x100003ea8
            v5 = (char *)((int64_t)v6 + 21);
            if (_regexec((struct re_pattern_buffer *)&v1, v5, 0, {(struct {int32_t e0; int32_t e1;}){.e0 = 0, .e1 = 0}}, 0) == 0) {
                // 0x100003ed4
                _puts(v5);
            }
            // 0x100003ee4
            v6 = _readdir(v3);
        }
    }
    // 0x100003ee8
    _closedir(v3);
    _regfree((struct re_pattern_buffer *)&v1);
    // 0x100003f00
    return 0;
}

// Address range: 0x100003f10 - 0x100003f4c
int64_t entry_point(void) {
    // 0x100003f10
    function_100003e18();
    return 0;
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(struct __dirstream * dirp) {
    // 0x100003f4c
    return _closedir(dirp);
}

// Address range: 0x100003f58 - 0x100003f64
struct __dirstream * function_100003f58(char * name) {
    // 0x100003f58
    return _opendir(name);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * s) {
    // 0x100003f64
    return _puts(s);
}

// Address range: 0x100003f70 - 0x100003f7c
struct dirent * function_100003f70(struct __dirstream * dirp) {
    // 0x100003f70
    return _readdir(dirp);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(struct re_pattern_buffer * preg, char * pattern, int32_t cflags) {
    // 0x100003f7c
    return _regcomp(preg, pattern, cflags);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(struct re_pattern_buffer * preg, char * string, int32_t nmatch, struct _TYPEDEF_regmatch_t pmatch[1], int32_t eflags) {
    // 0x100003f88
    return _regexec(preg, string, nmatch, pmatch, eflags);
}

// Address range: 0x100003f94 - 0x100003fa0
void function_100003f94(struct re_pattern_buffer * preg) {
    // 0x100003f94
    _regfree(preg);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <time.h>

bool is_prime(unsigned int n) {
    assert(n < 64);
    static bool isprime[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0,
                             0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1,
                             0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,
                             0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0};
    return isprime[n];
}

void swap(unsigned int* a, size_t i, size_t j) {
    unsigned int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
}

bool prime_triangle_row(unsigned int* a, size_t length) {
    if (length == 2)
        return is_prime(a[0] + a[1]);
    for (size_t i = 1; i + 1 < length; i += 2) {
        if (is_prime(a[0] + a[i])) {
            swap(a, i, 1);
            if (prime_triangle_row(a + 1, length - 1))
                return true;
            swap(a, i, 1);
        }
    }
    return false;
}

int prime_triangle_count(unsigned int* a, size_t length) {
    int count = 0;
    if (length == 2) {
        if (is_prime(a[0] + a[1]))
            ++count;
    } else {
        for (size_t i = 1; i + 1 < length; i += 2) {
            if (is_prime(a[0] + a[i])) {
                swap(a, i, 1);
                count += prime_triangle_count(a + 1, length - 1);
                swap(a, i, 1);
            }
        }
    }
    return count;
}

void print(unsigned int* a, size_t length) {
    if (length == 0)
        return;
    printf("%2u", a[0]);
    for (size_t i = 1; i < length; ++i)
        printf(" %2u", a[i]);
    printf("\n");
}

int main() {
    clock_t start = clock();
    for (unsigned int n = 2; n < 21; ++n) {
        unsigned int a[n];
        for (unsigned int i = 0; i < n; ++i)
            a[i] = i + 1;
        if (prime_triangle_row(a, n))
            print(a, n);
    }
    printf("\n");
    for (unsigned int n = 2; n < 21; ++n) {
        unsigned int a[n];
        for (unsigned int i = 0; i < n; ++i)
            a[i] = i + 1;
        if (n > 2)
            printf(" ");
        printf("%d", prime_triangle_count(a, n));
    }
    printf("\n");
    clock_t end = clock();
    double duration = (end - start + 0.0) / CLOCKS_PER_SEC;
    printf("\nElapsed time: %f seconds\n", duration);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int64_t function_100003874(void);
int64_t function_1000038f0(void);
int64_t function_100003940(void);
int64_t function_100003a6c(void);
int64_t function_100003b88(void);
int64_t function_100003f18(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003f24(int64_t a1);
int32_t function_100003f30(void);
int32_t function_100003f3c(char * format, ...);

// --------------------- Global Variables ---------------------

char * g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___chkstk_darwin(int64_t a1);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _clock(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003874 - 0x1000038f0
int64_t function_100003874(void) {
    // 0x100003874
    int64_t v1; // 0x100003874
    if ((int32_t)v1 >= 64) {
        // 0x1000038a4
        ___assert_rtn("is_prime", "prime-triangle-1.c", 7, "n < 64");
    }
    unsigned char v2 = *(char *)((v1 & 0xffffffff) + (int64_t)&g1); // 0x1000038dc
    return v2 % 2;
}

// Address range: 0x1000038f0 - 0x100003940
int64_t function_1000038f0(void) {
    // 0x1000038f0
    int64_t result; // 0x1000038f0
    int32_t * v1 = (int32_t *)(result + 4 * result); // 0x100003908
    int32_t * v2 = (int32_t *)(result + 4 * result); // 0x100003918
    *v1 = *v2;
    *v2 = *v1;
    return result;
}

// Address range: 0x100003940 - 0x100003a6c
int64_t function_100003940(void) {
    // 0x100003940
    int64_t v1; // 0x100003940
    uint64_t v2 = v1;
    if (v2 == 2) {
        // 0x100003a58
        return function_100003874() % 2;
    }
    // 0x10000399c
    if (v2 <= 2) {
        // 0x100003a58
        return 0;
    }
    int64_t v3 = 1;
    if (function_100003874() % 2 != 0) {
        // 0x1000039dc
        function_1000038f0();
        if (function_100003940() % 2 != 0) {
            // break -> 0x100003a58
            break;
        }
        // 0x100003a1c
        function_1000038f0();
    }
    int64_t v4 = v3 + 2; // 0x1000039b0
    int64_t result = 0; // 0x1000039b0
    while (v3 + 3 < v2) {
        // 0x1000039b8
        v3 = v4;
        if (function_100003874() % 2 != 0) {
            // 0x1000039dc
            function_1000038f0();
            result = 1;
            if (function_100003940() % 2 != 0) {
                // break -> 0x100003a58
                break;
            }
            // 0x100003a1c
            function_1000038f0();
        }
        // 0x100003a34
        v4 = v3 + 2;
        result = 0;
    }
    // 0x100003a58
    return result;
}

// Address range: 0x100003a6c - 0x100003b88
int64_t function_100003a6c(void) {
    // 0x100003a6c
    int64_t v1; // 0x100003a6c
    uint64_t v2 = v1;
    if (v2 == 2) {
        // 0x100003b78
        return function_100003874() % 2 != 0;
    }
    // 0x100003ad8
    if (v2 <= 2) {
        // 0x100003b78
        return 0;
    }
    int32_t v3 = 0;
    int64_t v4 = 1;
    int32_t v5 = v3; // 0x100003b10
    int64_t v6; // 0x100003b3c
    if (function_100003874() % 2 != 0) {
        // 0x100003b18
        function_1000038f0();
        v6 = function_100003a6c();
        function_1000038f0();
        v5 = v3 + (int32_t)v6;
    }
    int32_t result = v5;
    int64_t v7 = v4 + 2; // 0x100003aec
    while (v4 + 3 < v2) {
        // 0x100003af4
        v3 = result;
        v4 = v7;
        v5 = v3;
        if (function_100003874() % 2 != 0) {
            // 0x100003b18
            function_1000038f0();
            v6 = function_100003a6c();
            function_1000038f0();
            v5 = v3 + (int32_t)v6;
        }
        // 0x100003b64
        result = v5;
        v7 = v4 + 2;
    }
    // 0x100003b78
    return result;
}

// Address range: 0x100003b88 - 0x100003c4c
int64_t function_100003b88(void) {
    // 0x100003b88
    int64_t v1; // 0x100003b88
    if (v1 == 0) {
        // 0x100003c40
        int64_t result; // 0x100003b88
        return result;
    }
    int32_t v2 = v1; // 0x100003bd0
    _printf("%2u", v2);
    if (v1 == 1) {
        // 0x100003c40
        return _printf("\n");
    }
    int64_t v3 = 1; // 0x100003bf0
    _printf(" %2u", v2);
    while (v3 + 1 != v1) {
        // 0x100003bf8
        v3++;
        _printf(" %2u", v2);
    }
    // 0x100003c40
    return _printf("\n");
}

// Address range: 0x100003c4c - 0x100003f18
int64_t entry_point(int64_t a1) {
    // 0x100003c4c
    return ___chkstk_darwin((int64_t)_clock());
}

// Address range: 0x100003f18 - 0x100003f24
int64_t function_100003f18(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003f18
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003f24 - 0x100003f30
int64_t function_100003f24(int64_t a1) {
    // 0x100003f24
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(void) {
    // 0x100003f30
    return _clock();
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include<stdio.h>

int isPrime(unsigned int n)
{
	unsigned int num;
	
	if ( n < 2||!(n & 1))
		return n == 2;

	for (num = 3; num <= n/num; num += 2)
		if (!(n % num))
			return 0;
	return 1;
}

int main()
{
	unsigned int l,u,i,sum=0;
	
	printf("Enter lower and upper bounds: ");
	scanf("%ld%ld",&l,&u);
	
	for(i=l;i<=u;i++){
		if(isPrime(i)==1)
			{
				printf("\n%ld",i);
				sum++;
			}
	}
	
	printf("\n\nPrime numbers found in [%ld,%ld] : %ld",l,u,sum);
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d68(void);
int32_t function_100003f34(char * format, ...);
int32_t function_100003f40(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d68 - 0x100003e34
int64_t function_100003d68(void) {
    // 0x100003d68
    int64_t v1; // 0x100003d68
    uint32_t v2 = (int32_t)v1; // 0x100003d6c
    if (v2 < 2 || v2 % 2 == 0) {
        // 0x100003e28
        return v2 == 2;
    }
    // 0x100003dbc
    if (v2 <= 11 == v2 >= 12) {
        // 0x100003e28
        return 1;
    }
    uint32_t v3 = 3; // 0x100003dd4
    int64_t result = 0; // 0x100003df8
    while (v2 % v3 != 0) {
        // 0x100003dbc
        v3 += 2;
        uint32_t v4 = v2 / v3; // 0x100003dc8
        result = 1;
        if (v3 >= v4 == (v3 != v4)) {
            // break -> 0x100003e28
            break;
        }
        result = 0;
    }
    // 0x100003e28
    return result;
}

// Address range: 0x100003e34 - 0x100003f34
int64_t entry_point(void) {
    // 0x100003e34
    int32_t v1; // 0x100003e34
    uint32_t v2 = v1;
    uint32_t v3 = v1;
    _printf("Enter lower and upper bounds: ");
    int64_t v4; // 0x100003e34
    _scanf("%ld%ld", (int32_t *)v4, (int32_t *)v4);
    int32_t v5 = v4;
    if (v3 >= v2 == (v3 != v2)) {
        // 0x100003ef0
        _printf("\n\nPrime numbers found in [%ld,%ld] : %ld", v5, (int32_t)v4, (int32_t)v4);
        return 0;
    }
    if ((int32_t)function_100003d68() == 1) {
        // 0x100003eb0
        _printf("\n%ld", v5);
    }
    // 0x100003ee0
    int32_t v6; // 0x100003e34
    int32_t v7 = v6 + 1; // 0x100003ee4
    while (v7 >= v2 != v7 != v2) {
        // 0x100003e98
        if ((int32_t)function_100003d68() == 1) {
            // 0x100003eb0
            _printf("\n%ld", v5);
        }
        // 0x100003ee0
        v7++;
    }
    // 0x100003ef0
    _printf("\n\nPrime numbers found in [%ld,%ld] : %ld", v5, (int32_t)v4, (int32_t)v4);
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(char * format, ...) {
    // 0x100003f40
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>

int main()
{
	printf("This code was in file %s in function %s, at line %d\n",\
		__FILE__, __FUNCTION__, __LINE__);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f44(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003eec - 0x100003f44
int64_t entry_point(void) {
    // 0x100003eec
    int64_t v1; // 0x100003eec
    _printf("This code was in file %s in function %s, at line %d\n", (char *)v1, (char *)v1, v1);
    return 0;
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * format, ...) {
    // 0x100003f44
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>

void vc(int n, int base, int *num, int *denom)
{
        int p = 0, q = 1;

        while (n) {
                p = p * base + (n % base);
                q *= base;
                n /= base;
        }

        *num = p;
        *denom = q;

        while (p) { n = p; p = q % p; q = n; }
        *num /= q;
        *denom /= q;
}

int main()
{
        int d, n, i, b;
        for (b = 2; b < 6; b++) {
                printf("base %d:", b);
                for (i = 0; i < 10; i++) {
                        vc(i, b, &n, &d);
                        if (n) printf("  %d/%d", n, d);
                        else   printf("  0");
                }
                printf("\n");
        }

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d5c(void);
int32_t function_100003f7c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d5c - 0x100003e6c
int64_t function_100003d5c(void) {
    // 0x100003d5c
    int64_t result; // 0x100003d5c
    int32_t v1 = result; // 0x100003d60
    int32_t v2 = result; // 0x100003d64
    int32_t * v3 = (int32_t *)result; // 0x100003d68
    int32_t * v4 = (int32_t *)result; // 0x100003d6c
    int32_t v5 = 1; // 0x100003d8c
    int32_t v6 = v1; // 0x100003d8c
    int32_t v7 = 0; // 0x100003d8c
    int32_t v8; // 0x100003d5c
    if (v1 == 0) {
        // 0x100003de0
        *v3 = 0;
        *v4 = 1;
        v8 = 1;
    } else {
        v7 = v6 % v2 + v7 * v2;
        v5 *= v2;
        v6 /= v2;
        while (v6 != 0) {
            // 0x100003d94
            v7 = v6 % v2 + v7 * v2;
            v5 *= v2;
            v6 /= v2;
        }
        // 0x100003de0
        *v3 = v7;
        *v4 = v5;
        v8 = v5;
        if (v7 != 0) {
            int32_t v9 = v5 % v7;
            int32_t v10 = v7; // 0x100003e08
            v8 = v7;
            while (v9 != 0) {
                int32_t v11 = v9;
                v9 = v10 % v11;
                v10 = v11;
                v8 = v11;
            }
        }
    }
    // 0x100003e3c
    int64_t v12; // 0x100003d5c
    *v3 = *(int32_t *)&v12 / v8;
    int64_t v13; // 0x100003d5c
    *v4 = *(int32_t *)&v13 / v8;
    return result;
}

// Address range: 0x100003e6c - 0x100003f7c
int64_t entry_point(void) {
    int64_t v1 = 2;
    int64_t v2; // 0x100003e6c
    _printf("base %d:", v2);
    int32_t v3; // bp-28, 0x100003e6c
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003ed4
        function_100003d5c();
        if (v3 == 0) {
            // 0x100003f28
            _printf("  0");
        } else {
            // 0x100003efc
            _printf("  %d/%d", v1, (int64_t)&v3);
        }
    }
    // 0x100003f4c
    _printf((char *)0x100003f9d);
    int64_t v4 = v1 + 1;
    v2 = v1;
    while (v4 != 6) {
        // 0x100003e9c
        v1 = v4;
        _printf("base %d:", v2);
        for (int32_t i = 0; i < 10; i++) {
            // 0x100003ed4
            function_100003d5c();
            if (v3 == 0) {
                // 0x100003f28
                _printf("  0");
            } else {
                // 0x100003efc
                _printf("  %d/%d", v1, (int64_t)&v3);
            }
        }
        // 0x100003f4c
        _printf((char *)0x100003f9d);
        v4 = v1 + 1;
        v2 = v1;
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

int next_perm(int size, int * nums)
{
        int *l, *k, tmp;

        for (k = nums + size - 2; k >= nums && k[0] >= k[1]; k--) {};
        if (k < nums) return 0;

        for (l = nums + size - 1; *l <= *k; l--) {};
        tmp = *k; *k = *l; *l = tmp;

        for (l = nums + size - 1, k++; k < l; k++, l--) {
                tmp = *k; *k = *l; *l = tmp;
        }

        return 1;
}

void make_part(int n, int * sizes)
{
        int x[1024], i, j, *ptr, len = 0;

        for (ptr = x, i = 0; i < n; i++)
                for (j = 0, len += sizes[i]; j < sizes[i]; j++, *(ptr++) = i);

        do {
                for (i = 0; i < n; i++) {
                        printf(" { ");
                        for (j = 0; j < len; j++)
                                if (x[j] == i) printf("%d ", j);

                        printf("}");
                }
                printf("\n");
        } while (next_perm(len, x));
}

int main()
{
        int s1[] = {2, 0, 2};
        int s2[] = {1, 2, 3, 4};

        printf("Part 2 0 2:\n");
        make_part(3, s1);

        printf("\nPart 1 2 3 4:\n");
        make_part(4, s2);

        return 1;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ab0(void);
int64_t function_100003c64(int64_t a1, int64_t a2);
int64_t function_100003c80(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f2c(int64_t a1);
int32_t function_100003f38(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 2; // 0x100003f70
float128_t g2 = 4.24399158242461027606401097390298646e-314L; // 0x100003f80

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ab0 - 0x100003c64
int64_t function_100003ab0(void) {
    // 0x100003ab0
    int64_t v1; // 0x100003ab0
    uint64_t v2 = v1;
    int64_t v3 = (0x100000000 * v1 >> 30) + v2; // 0x100003ac4
    int64_t v4 = v3 - 8; // 0x100003ac8
    if (v2 > v4) {
        // 0x100003c58
        return 0;
    }
    int64_t v5 = v4; // 0x100003aec
    int32_t * v6 = (int32_t *)v5;
    int32_t v7 = *v6; // 0x100003af8
    int64_t v8 = v5 + 4;
    int32_t * v9 = (int32_t *)v8;
    int32_t v10 = *v9; // 0x100003b00
    int32_t v11 = v7 - v10; // 0x100003b04
    while (v11 < 0 == ((v11 ^ v7) & (v10 ^ v7)) < 0) {
        // 0x100003b24
        v5 -= 4;
        if (v2 > v5) {
            // 0x100003c58
            return 0;
        }
        v6 = (int32_t *)v5;
        v7 = *v6;
        v8 = v5 + 4;
        v9 = (int32_t *)v8;
        v10 = *v9;
        v11 = v7 - v10;
    }
    int64_t v12 = v3 - 4;
    int32_t * v13 = (int32_t *)v12;
    int32_t v14 = *v13; // 0x100003b70
    int32_t v15 = v14 - v7; // 0x100003b7c
    int64_t v16 = v12; // 0x100003b84
    while (v15 == 0 || v15 < 0 != ((v15 ^ v14) & (v14 ^ v7)) < 0) {
        // 0x100003b6c
        v12 = v16 - 4;
        v13 = (int32_t *)v12;
        v14 = *v13;
        v15 = v14 - v7;
        v16 = v12;
    }
    // 0x100003ba0
    *v6 = v14;
    *v13 = v7;
    int64_t v17 = v3 - 4;
    int32_t * v18 = (int32_t *)v17;
    int64_t v19 = v8; // 0x100003bfc
    if (v9 >= v18) {
        // 0x100003c58
        return 1;
    }
    int64_t v20 = v17; // 0x100003bfc
    *v9 = *v18;
    *v18 = *v9;
    v20 -= 4;
    v19 += 4;
    int32_t * v21 = (int32_t *)v20;
    int32_t * v22 = (int32_t *)v19;
    while (v22 < v21) {
        // 0x100003c04
        *v22 = *v21;
        *v21 = *v22;
        v20 -= 4;
        v19 += 4;
        v21 = (int32_t *)v20;
        v22 = (int32_t *)v19;
    }
    // 0x100003c58
    return 1;
}

// Address range: 0x100003c64 - 0x100003c80
int64_t function_100003c64(int64_t a1, int64_t a2) {
    // 0x100003c64
    return ___chkstk_darwin();
}

// Address range: 0x100003c80 - 0x100003e70
int64_t function_100003c80(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003c80
    int64_t v1; // 0x100003c80
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003c94
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    int32_t v3 = v1; // 0x100003c98
    int32_t v4 = -v3;
    int32_t v5 = 0; // 0x100003cc4
    int64_t v6; // bp-4104, 0x100003c80
    if (v4 < 0 != (v4 & v3) < 0) {
        int32_t * v7 = (int32_t *)&v6;
        int32_t v8 = 0; // 0x100003ce0
        int32_t v9 = 0;
        int32_t * v10 = (int32_t *)(4 * (int64_t)v9 + v1); // 0x100003cd8
        int32_t v11 = *v10;
        int32_t v12 = -v11; // 0x100003cfc
        int32_t * v13 = v7; // 0x100003d04
        int32_t * v14 = v7; // 0x100003d04
        int32_t v15; // 0x100003c80
        int32_t v16; // 0x100003d14
        int32_t * v17; // 0x100003c80
        int32_t v18; // 0x100003cf8
        int32_t v19; // 0x100003cfc
        if (v12 < 0 != (v11 & v12) < 0) {
            v16 = 1;
            v17 = (int32_t *)((int64_t)v13 + 4);
            *v13 = v9;
            v18 = *v10;
            v19 = v16 - v18;
            v15 = v16;
            v13 = v17;
            v14 = v17;
            while (v19 < 0 != ((v19 ^ v16) & (v18 ^ v16)) < 0) {
                // 0x100003d10
                v16 = v15 + 1;
                v17 = (int32_t *)((int64_t)v13 + 4);
                *v13 = v9;
                v18 = *v10;
                v19 = v16 - v18;
                v15 = v16;
                v13 = v17;
                v14 = v17;
            }
        }
        // 0x100003d38
        v8 += v11;
        v7 = v14;
        int32_t v20 = v9 + 1; // 0x100003d3c
        int32_t v21 = v20 - v3; // 0x100003cbc
        v5 = v8;
        while (v21 < 0 != ((v21 ^ v20) & (v20 ^ v3)) < 0) {
            // 0x100003ccc
            v9 = v20;
            v10 = (int32_t *)(4 * (int64_t)v9 + v1);
            v11 = *v10;
            v12 = -v11;
            v13 = v7;
            v14 = v7;
            if (v12 < 0 != (v11 & v12) < 0) {
                v16 = 1;
                v17 = (int32_t *)((int64_t)v13 + 4);
                *v13 = v9;
                v18 = *v10;
                v19 = v16 - v18;
                v15 = v16;
                v13 = v17;
                v14 = v17;
                while (v19 < 0 != ((v19 ^ v16) & (v18 ^ v16)) < 0) {
                    // 0x100003d10
                    v16 = v15 + 1;
                    v17 = (int32_t *)((int64_t)v13 + 4);
                    *v13 = v9;
                    v18 = *v10;
                    v19 = v16 - v18;
                    v15 = v16;
                    v13 = v17;
                    v14 = v17;
                }
            }
            // 0x100003d38
            v8 += v11;
            v7 = v14;
            v20 = v9 + 1;
            v21 = v20 - v3;
            v5 = v8;
        }
    }
    int32_t v22 = -v5;
    int64_t v23 = &v6;
    int32_t v24; // 0x100003c80
    int32_t v25; // 0x100003c80
    int32_t v26; // 0x100003e00
    int32_t v27; // 0x100003d5c
    int32_t v28; // 0x100003de0
    int32_t v29; // 0x100003d88
    if (v4 < 0 != (v4 & v3) < 0) {
        v25 = 0;
        _printf(" { ");
        v24 = 0;
        int64_t v30; // 0x100003c80
        if (v22 < 0 != (v5 & v22) < 0) {
            if (*(int32_t *)(4 * (int64_t)v24 + v23) == v25) {
                // 0x100003db8
                _printf("%d ", v30);
            }
            // 0x100003ddc
            v28 = v24 + 1;
            v29 = v28 - v5;
            v24 = v28;
            while (v29 < 0 != ((v29 ^ v28) & (v28 ^ v5)) < 0) {
                // 0x100003d98
                if (*(int32_t *)(4 * (int64_t)v24 + v23) == v25) {
                    // 0x100003db8
                    _printf("%d ", v30);
                }
                // 0x100003ddc
                v28 = v24 + 1;
                v29 = v28 - v5;
                v24 = v28;
            }
        }
        // 0x100003dec
        _printf("}");
        v26 = v25 + 1;
        v27 = v26 - v3;
        while (v27 < 0 != ((v27 ^ v26) & (v26 ^ v3)) < 0) {
            // 0x100003d6c
            v25 = v26;
            _printf(" { ");
            v24 = 0;
            if (v22 < 0 != (v5 & v22) < 0) {
                if (*(int32_t *)(4 * (int64_t)v24 + v23) == v25) {
                    // 0x100003db8
                    _printf("%d ", v30);
                }
                // 0x100003ddc
                v28 = v24 + 1;
                v29 = v28 - v5;
                v24 = v28;
                while (v29 < 0 != ((v29 ^ v28) & (v28 ^ v5)) < 0) {
                    // 0x100003d98
                    if (*(int32_t *)(4 * (int64_t)v24 + v23) == v25) {
                        // 0x100003db8
                        _printf("%d ", v30);
                    }
                    // 0x100003ddc
                    v28 = v24 + 1;
                    v29 = v28 - v5;
                    v24 = v28;
                }
            }
            // 0x100003dec
            _printf("}");
            v26 = v25 + 1;
            v27 = v26 - v3;
        }
    }
    // 0x100003e0c
    _printf("\n");
    int64_t v31 = function_100003ab0(); // 0x100003e24
    while ((int32_t)v31 != 0) {
        // 0x100003d4c
        if (v4 < 0 != (v4 & v3) < 0) {
            v25 = 0;
            _printf(" { ");
            v24 = 0;
            if (v22 < 0 != (v5 & v22) < 0) {
                if (*(int32_t *)(4 * (int64_t)v24 + v23) == v25) {
                    // 0x100003db8
                    _printf("%d ", v23);
                }
                // 0x100003ddc
                v28 = v24 + 1;
                v29 = v28 - v5;
                v24 = v28;
                while (v29 < 0 != ((v29 ^ v28) & (v28 ^ v5)) < 0) {
                    // 0x100003d98
                    if (*(int32_t *)(4 * (int64_t)v24 + v23) == v25) {
                        // 0x100003db8
                        _printf("%d ", v23);
                    }
                    // 0x100003ddc
                    v28 = v24 + 1;
                    v29 = v28 - v5;
                    v24 = v28;
                }
            }
            // 0x100003dec
            _printf("}");
            v26 = v25 + 1;
            v27 = v26 - v3;
            while (v27 < 0 != ((v27 ^ v26) & (v26 ^ v3)) < 0) {
                // 0x100003d6c
                v25 = v26;
                _printf(" { ");
                v24 = 0;
                if (v22 < 0 != (v5 & v22) < 0) {
                    if (*(int32_t *)(4 * (int64_t)v24 + v23) == v25) {
                        // 0x100003db8
                        _printf("%d ", v23);
                    }
                    // 0x100003ddc
                    v28 = v24 + 1;
                    v29 = v28 - v5;
                    v24 = v28;
                    while (v29 < 0 != ((v29 ^ v28) & (v28 ^ v5)) < 0) {
                        // 0x100003d98
                        if (*(int32_t *)(4 * (int64_t)v24 + v23) == v25) {
                            // 0x100003db8
                            _printf("%d ", v23);
                        }
                        // 0x100003ddc
                        v28 = v24 + 1;
                        v29 = v28 - v5;
                        v24 = v28;
                    }
                }
                // 0x100003dec
                _printf("}");
                v26 = v25 + 1;
                v27 = v26 - v3;
            }
        }
        // 0x100003e0c
        _printf("\n");
        v31 = function_100003ab0();
    }
    int64_t result = v31; // 0x100003e50
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003e58
        result = ___stack_chk_fail(v31);
    }
    // 0x100003e5c
    return result;
}

// Address range: 0x100003e70 - 0x100003f2c
int64_t entry_point(void) {
    int64_t v1 = g1; // bp-40, 0x100003ea4
    int64_t v2 = (float64_t)g2; // bp-64, 0x100003ec4
    _printf("Part 2 0 2:\n");
    function_100003c64(3, (int64_t)&v1);
    _printf("\nPart 1 2 3 4:\n");
    int64_t v3 = function_100003c64(4, (int64_t)&v2); // 0x100003ef4
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003f04
    if (v4 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003f18
        ___stack_chk_fail(v3);
    }
    // 0x100003f1c
    return 1;
}

// Address range: 0x100003f2c - 0x100003f38
int64_t function_100003f2c(int64_t a1) {
    // 0x100003f2c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * format, ...) {
    // 0x100003f38
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>

void t(int n)
{
	int i, j, c, len;

	i = n * (n - 1) / 2;
	for (len = c = 1; c < i; c *= 10, len++);
	c -= i; // c is the col where width changes

#define SPEED_MATTERS 0
#if SPEED_MATTERS	// in case we really, really wanted to print huge triangles often
	char tmp[32], s[4096], *p;

	sprintf(tmp, "%*d", len, 0);

	inline void inc_numstr(void) {
		int k = len;

	redo:	if (!k--) return;

		if (tmp[k] == '9') {
			tmp[k] = '0';
			goto redo;
		}

		if (++tmp[k] == '!')
			tmp[k] = '1';
	}

	for (p = s, i = 1; i <= n; i++) {
		for (j = 1; j <= i; j++) {
			inc_numstr();
			__builtin_memcpy(p, tmp + 1 - (j >= c), len - (j < c));
			p += len - (j < c);

			*(p++) = (i - j)? ' ' : '\n';

			if (p - s + len >= 4096) {
				fwrite(s, 1, p - s, stdout);
				p = s;
			}
		}
	}

	fwrite(s, 1, p - s, stdout);
#else // NO_IT_DOESN'T
	int num;
	for (num = i = 1; i <= n; i++)
		for (j = 1; j <= i; j++)
			printf("%*d%c",	len - (j < c), num++, i - j ? ' ':'\n');
#endif
}

int main(void)
{
	t(5), t(14);

	// maybe not
	// t(10000);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003dd8(void);
int32_t function_100003f94(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dd8 - 0x100003f5c
int64_t function_100003dd8(void) {
    // 0x100003dd8
    int64_t v1; // 0x100003dd8
    int32_t v2 = v1; // 0x100003de4
    int32_t v3 = (v2 - 1) * v2 / 2; // 0x100003e00
    int32_t v4 = 1 - v3; // 0x100003e1c
    int32_t v5 = 1; // 0x100003e24
    if (v4 < 0 != (v4 & v3) < 0) {
        v5 *= 10;
        while (v5 - v3 < 0 != ((v5 - v3 ^ v5) & (v5 ^ v3)) < 0) {
            // 0x100003e30
            v5 *= 10;
        }
    }
    int32_t v6 = 1 - v2; // 0x100003e78
    if (v6 != 0 && v6 < 0 == (v6 & v2) < 0) {
        // 0x100003f50
        int64_t result; // 0x100003dd8
        return result;
    }
    int32_t v7 = 1;
    int32_t v8 = 1 - v7; // 0x100003e9c
    int64_t v9; // 0x100003dd8
    int64_t result2 = v9; // 0x100003ea4
    int32_t v10; // 0x100003dd8
    int32_t v11; // 0x100003f24
    int32_t v12; // 0x100003f30
    int32_t v13; // 0x100003e9c
    if (v8 == 0 || v8 < 0 != (v8 & v7) < 0) {
        v11 = _printf("%*d%c", v1, v1, (char)v1);
        v12 = 2;
        v13 = v12 - v7;
        v10 = v12;
        while (v13 == 0 || v13 < 0 != ((v13 ^ v12) & (v12 ^ v7)) < 0) {
            // 0x100003eac
            v11 = _printf("%*d%c", v1, v1, (char)v1);
            v12 = v10 + 1;
            v13 = v12 - v7;
            v10 = v12;
        }
        // 0x100003e94
        result2 = v11;
    }
    int32_t v14 = v7 + 1; // 0x100003f44
    int32_t v15 = v14 - v2; // 0x100003e78
    while (v15 == 0 || v15 < 0 != ((v15 ^ v14) & (v14 ^ v2)) < 0) {
        // 0x100003e94
        v7 = v14;
        v8 = 1 - v7;
        if (v8 == 0 || v8 < 0 != (v8 & v7) < 0) {
            v11 = _printf("%*d%c", v1, v1, (char)v1);
            v12 = 2;
            v13 = v12 - v7;
            v10 = v12;
            while (v13 == 0 || v13 < 0 != ((v13 ^ v12) & (v12 ^ v7)) < 0) {
                // 0x100003eac
                v11 = _printf("%*d%c", v1, v1, (char)v1);
                v12 = v10 + 1;
                v13 = v12 - v7;
                v10 = v12;
            }
            // 0x100003e94
            result2 = v11;
        }
        // 0x100003f40
        v14 = v7 + 1;
        v15 = v14 - v2;
    }
    // 0x100003f50
    return result2;
}

// Address range: 0x100003f5c - 0x100003f94
int64_t entry_point(void) {
    // 0x100003f5c
    function_100003dd8();
    function_100003dd8();
    return 0;
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(char * format, ...) {
    // 0x100003f94
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`/*  Written in 2015 by Sebastiano Vigna (vigna@acm.org)

To the extent possible under law, the author has dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.

See <http://creativecommons.org/publicdomain/zero/1.0/>. */

#include <stdint.h>
#include <stdio.h>
#include <math.h>

/* This is a fixed-increment version of Java 8's SplittableRandom generator
   See http://dx.doi.org/10.1145/2714064.2660195 and
   http://docs.oracle.com/javase/8/docs/api/java/util/SplittableRandom.html

   It is a very fast generator passing BigCrush, and it can be useful if
   for some reason you absolutely want 64 bits of state. */

static uint64_t x; /* The state can be seeded with any value. */

uint64_t next() {
	uint64_t z = (x += 0x9e3779b97f4a7c15);
	z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
	z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
	return z ^ (z >> 31);
}

double next_float() {
    return next() / pow(2.0, 64);
}

int main() {
    int i, j;
    x = 1234567;
    for(i = 0; i < 5; ++i)
        printf("%llu\n", next()); /* needed to use %lu verb for GCC 7.5.0-3 */
    x = 987654321;
    int vec5[5] = {0, 0, 0, 0, 0};
    for(i = 0; i < 100000; ++i) {
        j = next_float() * 5.0;
        vec5[j] += 1;
    }
    for(i = 0; i < 5; ++i)
        printf("%d: %d  ", i, vec5[i]);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d0c(void);
int64_t function_100003d90(void);
int64_t function_100003f64(void);
float64_t function_100003f70(float64_t a1, float64_t a2);
int32_t function_100003f7c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d0c - 0x100003d90
int64_t function_100003d0c(void) {
    int64_t v1 = g1 - 0x61c8864680b583eb; // 0x100003d28
    g1 = v1;
    uint64_t v2 = -0x40a7b892e31b1a47 * (v1 / 0x40000000 ^ v1); // 0x100003d50
    int64_t v3 = -0x6b2fb644ecceee15 * (v2 / 0x8000000 ^ v2); // 0x100003d74
    return v3 ^ (int64_t)(v3 < 0);
}

// Address range: 0x100003d90 - 0x100003dd0
int64_t function_100003d90(void) {
    // 0x100003d90
    function_100003d0c();
    int128_t v1; // 0x100003d90
    return _pow((float64_t)(int64_t)v1, (float64_t)(int64_t)v1);
}

// Address range: 0x100003dd0 - 0x100003f64
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003de4
    g1 = 0x12d687;
    int64_t v2; // 0x100003dd0
    for (int32_t i = 0; i < 5; i++) {
        // 0x100003e1c
        function_100003d0c();
        _printf("%llu\n", v2);
    }
    // 0x100003e48
    g1 = 0x3ade68b1;
    int64_t v3 = 0; // bp-48, 0x100003e58
    int64_t v4 = &v3;
    int32_t v5 = 0;
    function_100003d90();
    float64_t v6; // 0x100003dd0
    float64_t v7 = 5.0 * v6; // 0x100003e90
    int32_t * v8 = (int32_t *)(4 * (int64_t)(int32_t)v7 + v4); // 0x100003ea8
    *v8 = *v8 + 1;
    int32_t v9 = v5 + 1; // 0x100003ebc
    int32_t v10 = 0; // 0x100003e80
    while (v5 < 0x1869f != (0x1869e - v5 & v9) < 0) {
        // 0x100003e88
        v5 = v9;
        function_100003d90();
        v7 *= 5.0;
        v8 = (int32_t *)(4 * (int64_t)(int32_t)v7 + v4);
        *v8 = *v8 + 1;
        v9 = v5 + 1;
        v10 = 0;
    }
    _printf("%d: %d  ", v2, v2);
    int32_t v11 = v10 + 1; // 0x100003f1c
    v10 = v11;
    while (v11 != 5) {
        // 0x100003ee4
        _printf("%d: %d  ", v2, v2);
        v11 = v10 + 1;
        v10 = v11;
    }
    // 0x100003f28
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f50
        ___stack_chk_fail();
    }
    // 0x100003f54
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int64_t function_100003f64(void) {
    // 0x100003f64
    return ___stack_chk_fail();
}

// Address range: 0x100003f70 - 0x100003f7c
float64_t function_100003f70(float64_t a1, float64_t a2) {
    // 0x100003f70
    return _pow(a1, a2);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include "stdio.h"

typedef struct Range {
    int start, end, sum;
} Range;

Range maxSubseq(const int sequence[], const int len) {
    int maxSum = 0, thisSum = 0, i = 0;
    int start = 0, end = -1, j;

    for (j = 0; j < len; j++) {
        thisSum += sequence[j];
        if (thisSum < 0) {
            i = j + 1;
            thisSum = 0;
        } else if (thisSum > maxSum) {
            maxSum = thisSum;
            start = i;
            end   = j;
        }
    }

    Range r;
    if (start <= end && start >= 0 && end >= 0) {
        r.start = start;
        r.end = end + 1;
        r.sum = maxSum;
    } else {
        r.start = 0;
        r.end = 0;
        r.sum = 0;
    }
    return r;
}

int main(int argc, char **argv) {
    int a[] = {-1 , -2 , 3 , 5 , 6 , -2 , -1 , 4 , -4 , 2 , -1};
    int alength = sizeof(a)/sizeof(a[0]);

    Range r = maxSubseq(a, alength);
    printf("Max sum = %d\n", r.sum);
    int i;
    for (i = r.start; i < r.end; i++)
        printf("%d ", a[i]);
    printf("\n");

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c70(void);
int64_t function_100003f44(int64_t a1);
int64_t * function_100003f50(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f5c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = -0x100000001; // 0x100003f68

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c70 - 0x100003e20
int64_t function_100003c70(void) {
    // 0x100003c70
    int64_t v1; // 0x100003c70
    int32_t v2 = v1; // 0x100003c90
    int32_t v3 = -v2; // 0x100003cbc
    int32_t v4 = 0; // 0x100003cc4
    int32_t v5; // 0x100003c70
    int32_t v6; // 0x100003c70
    int32_t v7; // 0x100003d60
    int64_t result; // 0x100003e10
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e0c
        v6 = -1;
        v5 = 0;
        v7 = v5 - v6;
        result = v6 < 0 | v5 < 0 | v7 != 0 == v7 < 0 == ((v7 ^ v5) & (v6 ^ v5)) < 0 ? 0 : (int64_t)v5;
        return result;
    }
    int32_t v8 = 0;
    int32_t v9 = 0;
    int32_t v10 = -1;
    int32_t v11 = 0;
    int32_t v12 = *(int32_t *)(4 * (int64_t)v11 + v1); // 0x100003cdc
    int32_t v13; // 0x100003c70
    int32_t v14; // 0x100003c70
    int32_t v15; // 0x100003c70
    int32_t v16; // 0x100003c70
    int32_t v17; // 0x100003c70
    int32_t v18; // 0x100003c70
    int32_t v19; // 0x100003c70
    int32_t v20; // 0x100003d14
    bool v21; // 0x100003d18
    if (v12 < 0) {
        // 0x100003cf8
        v19 = v11 + 1;
        v13 = v19;
        v14 = v8;
        v15 = 0;
        v16 = v19;
        v17 = v9;
        v18 = v10;
    } else {
        // 0x100003d0c
        v20 = v12 - v8;
        v21 = v20 == 0 | v20 < 0 != ((v20 ^ v12) & (v12 ^ v8)) < 0;
        v13 = v11 + 1;
        v14 = v21 ? v8 : v12;
        v15 = v12;
        v16 = v4;
        v17 = v21 ? v9 : v4;
        v18 = v21 ? v10 : v11;
    }
    int32_t v22 = v18;
    int32_t v23 = v17;
    int32_t v24 = v13;
    int32_t v25 = v24 - v2; // 0x100003cbc
    v4 = v16;
    while (v25 < 0 != ((v25 ^ v24) & (v24 ^ v2)) < 0) {
        // 0x100003ccc
        v8 = v14;
        v9 = v23;
        v10 = v22;
        v11 = v24;
        v12 = *(int32_t *)(4 * (int64_t)v11 + v1) + v15;
        if (v12 < 0) {
            // 0x100003cf8
            v19 = v11 + 1;
            v13 = v19;
            v14 = v8;
            v15 = 0;
            v16 = v19;
            v17 = v9;
            v18 = v10;
        } else {
            // 0x100003d0c
            v20 = v12 - v8;
            v21 = v20 == 0 | v20 < 0 != ((v20 ^ v12) & (v12 ^ v8)) < 0;
            v13 = v11 + 1;
            v14 = v21 ? v8 : v12;
            v15 = v12;
            v16 = v4;
            v17 = v21 ? v9 : v4;
            v18 = v21 ? v10 : v11;
        }
        // 0x100003d48
        v22 = v18;
        v23 = v17;
        v24 = v13;
        v25 = v24 - v2;
        v4 = v16;
    }
    // 0x100003e0c
    v6 = v22;
    v5 = v23;
    v7 = v5 - v6;
    result = v6 < 0 | v5 < 0 | v7 != 0 == v7 < 0 == ((v7 ^ v5) & (v6 ^ v5)) < 0 ? 0 : (int64_t)v5;
    return result;
}

// Address range: 0x100003e20 - 0x100003f44
int64_t entry_point(void) {
    // 0x100003e20
    int64_t v1; // bp-68, 0x100003e20
    _memcpy(&v1, &g1, 44);
    int64_t v2 = function_100003c70(); // 0x100003e70
    _printf("Max sum = %d\n", 11);
    int32_t v3 = v2; // 0x100003ea8
    int32_t v4; // 0x100003e20
    int32_t v5 = v3 - v4; // 0x100003ebc
    int32_t v6 = v3; // 0x100003ec4
    if (v5 < 0 != ((v5 ^ v3) & (v4 ^ v3)) < 0) {
        _printf("%d ", 11);
        v6++;
        while (v6 - v4 < 0 != ((v6 - v4 ^ v6) & (v6 ^ v4)) < 0) {
            // 0x100003ecc
            _printf("%d ", 11);
            v6++;
        }
    }
    int32_t v7 = _printf((char *)0x100003fa6); // 0x100003f0c
    int64_t v8 = *(int64_t *)0x100004008; // 0x100003f18
    if (*(int64_t *)v8 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f30
        ___stack_chk_fail((int64_t)v7);
    }
    // 0x100003f34
    return 0;
}

// Address range: 0x100003f44 - 0x100003f50
int64_t function_100003f44(int64_t a1) {
    // 0x100003f44
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t * function_100003f50(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f50
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

/* wchar_t is the standard type for wide chars; what it is internally
 * depends on the compiler.
 */
wchar_t poker[] = L"♥♦♣♠";
wchar_t four_two[] = L"\x56db\x5341\x4e8c";

int main() {
    /* Set the locale to alert C's multibyte output routines */
    if (!setlocale(LC_CTYPE, "")) {
        fprintf(stderr, "Locale failure, check your env vars\n");
        return 1;
    }

#ifdef __STDC_ISO_10646__
    /* C99 compilers should understand these */
    printf("%lc\n", 0x2708);    /* ✈ */
    printf("%ls\n", poker);     /* ♥♦♣♠ */
    printf("%ls\n", four_two);  /* 四十二 */
#else
    /* oh well */
    printf("airplane\n");
    printf("club diamond club spade\n");
    printf("for ty two\n");
#endif
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f2c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f38(char * format, ...);
char * function_100003f44(int32_t category, char * locale);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f50

// ------- Dynamically Linked Functions Without Header --------

int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);
char * _setlocale(int32_t a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003e9c - 0x100003f2c
int64_t entry_point(void) {
    // 0x100003e9c
    int64_t result; // 0x100003e9c
    if (_setlocale(2, (char *)&g1) == NULL) {
        int64_t v1 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003ed4
        _fprintf((struct _IO_FILE *)v1, "Locale failure, check your env vars\n");
        result = 1;
    } else {
        // 0x100003ef0
        _printf("airplane\n");
        _printf("club diamond club spade\n");
        _printf("for ty two\n");
        result = 0;
    }
    // 0x100003f1c
    return result;
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f2c
    return _fprintf(stream, format);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * format, ...) {
    // 0x100003f38
    return _printf(format);
}

// Address range: 0x100003f44 - 0x100003f50
char * function_100003f44(int32_t category, char * locale) {
    // 0x100003f44
    return _setlocale(category, locale);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>

int main()
{
  int junk, *junkp;

  /* Print an unitialized variable! */
  printf("junk: %d\n", junk);

  /* Follow a pointer to unitialized memory! */
  junkp = malloc(sizeof *junkp);
  if (junkp)
    printf("*junkp: %d\n", *junkp);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t * function_100003f78(int32_t size);
int32_t function_100003f84(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ef8 - 0x100003f78
int64_t entry_point(void) {
    // 0x100003ef8
    int64_t v1; // 0x100003ef8
    _printf("junk: %d\n", v1);
    if (_malloc(4) != NULL) {
        // 0x100003f44
        _printf("*junkp: %d\n", v1);
    }
    // 0x100003f68
    return 0;
}

// Address range: 0x100003f78 - 0x100003f84
int64_t * function_100003f78(int32_t size) {
    // 0x100003f78
    return _malloc(size);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdlib.h>

#define N 26

int main() {
    unsigned char lower[N];

    for (size_t i = 0; i < N; i++) {
        lower[i] = i + 'a';
    }

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f9c(void);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003f04 - 0x100003f9c
int64_t entry_point(void) {
    // 0x100003f04
    int64_t v1; // bp-50, 0x100003f04
    int64_t v2 = &v1; // 0x100003f4c
    int64_t v3 = 0;
    *(char *)(v3 + v2) = (char)v3 + 97;
    int64_t v4 = v3 + 1; // 0x100003f5c
    while (v4 != 26) {
        // 0x100003f40
        v3 = v4;
        *(char *)(v3 + v2) = (char)v3 + 97;
        v4 = v3 + 1;
    }
    int64_t v5 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f74
    if (v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f88
        ___stack_chk_fail();
    }
    // 0x100003f8c
    return 0;
}

// Address range: 0x100003f9c - 0x100003fa8
int64_t function_100003f9c(void) {
    // 0x100003f9c
    return ___stack_chk_fail();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <termios.h>  /* general terminal interface: tcgetattr, tcsetattr, tcflush */
#include <unistd.h>   /* synchronous I/O multiplexing: select, FD_CLR, FD_ISSET, FD_SET, FD_ZERO */
#include <fcntl.h>

void set_mode(int want_key)
{
	static struct termios old, new;
	if (!want_key) {
		tcsetattr(STDIN_FILENO, TCSANOW, &old);
		return;
	}

	tcgetattr(STDIN_FILENO, &old);
	new = old;
	new.c_lflag &= ~(ICANON | ECHO);
	tcsetattr(STDIN_FILENO, TCSANOW, &new);
}

int get_key()
{
	int c = 0;
	struct timeval tv;
	fd_set fs;
	tv.tv_usec = tv.tv_sec = 0;

	FD_ZERO(&fs);
	FD_SET(STDIN_FILENO, &fs);
	select(STDIN_FILENO + 1, &fs, 0, 0, &tv);

	if (FD_ISSET(STDIN_FILENO, &fs)) {
		c = getchar();
		set_mode(0);
	}
	return c;
}

int main()
{
	int c;
	while(1) {
		set_mode(1);
                /* force C library buffers to be written to kernel buffers,
                   and flush pending input to avoid previously pressed keys */
                fflush(stdout);
		while (!(c = get_key())) usleep(10000);
		printf("key %d\n", c);
	}
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct termios {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char e4;
    char e5[1];
};

struct timeval {
    int64_t e0;
    int64_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c34(void);
int64_t function_100003cd0(void);
int64_t function_100003f20(int32_t a1, int64_t a2, int64_t a3);
int32_t function_100003f2c(struct _IO_FILE * stream);
int32_t function_100003f38(void);
int64_t * function_100003f44(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003f50(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f5c(char * format, ...);
int32_t function_100003f68(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout);
int32_t function_100003f74(int32_t fd, struct termios * termios_p);
int32_t function_100003f80(int32_t fd, int32_t optional_actions, struct termios * termios_p);
int32_t function_100003f8c(int32_t useconds);

// --------------------- Global Variables ---------------------

struct termios * g1 = NULL; // 0x100008000
struct termios * g2 = NULL; // 0x100008048
int64_t g3 = 0; // 0x100008060

// ------- Dynamically Linked Functions Without Header --------

int64_t ___darwin_check_fd_set_overflow(int32_t a1, int64_t a2, int64_t a3);
int32_t _fflush(struct _IO_FILE * a1);
int32_t _getchar(void);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _select(int32_t a1, struct _TYPEDEF_fd_set * a2, struct _TYPEDEF_fd_set * a3, struct _TYPEDEF_fd_set * a4, struct timeval * a5);
int32_t _tcgetattr(int32_t a1, struct termios * a2);
int32_t _tcsetattr(int32_t a1, int32_t a2, struct termios * a3);
int32_t _usleep(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c34 - 0x100003cd0
int64_t function_100003c34(void) {
    // 0x100003c34
    int32_t result; // 0x100003c34
    int64_t v1; // 0x100003c34
    if ((int32_t)v1 == 0) {
        // 0x100003c58
        result = _tcsetattr(0, 0, (struct termios *)&g1);
    } else {
        // 0x100003c70
        _tcgetattr(0, (struct termios *)&g1);
        _memcpy((int64_t *)&g2, (int64_t *)&g1, 72);
        g3 &= -265;
        result = _tcsetattr(0, 0, (struct termios *)&g2);
    }
    // 0x100003cc4
    return result;
}

// Address range: 0x100003cd0 - 0x100003eac
int64_t function_100003cd0(void) {
    int64_t v1 = 0; // bp-120, 0x100003cfc
    int64_t v2; // bp-248, 0x100003cd0
    _memset(&v2, 0, 128);
    if (*(int64_t *)0x100004000 == 0) {
        // 0x100003e30
        *(int32_t *)&v2 = *(int32_t *)&v2 | 1;
        _select(1, (struct _TYPEDEF_fd_set *)&v2, NULL, NULL, (struct timeval *)&v1);
    } else {
        int64_t v3 = &v2; // 0x100003d08
        if ((int32_t)___darwin_check_fd_set_overflow(0, v3, 0) == 0) {
            // 0x100003db4
            _select(1, (struct _TYPEDEF_fd_set *)&v2, NULL, NULL, (struct timeval *)&v1);
        } else {
            // 0x100003db4
            *(int32_t *)&v2 = *(int32_t *)&v2 | 1;
            _select(1, (struct _TYPEDEF_fd_set *)&v2, NULL, NULL, (struct timeval *)&v1);
        }
        // 0x100003df8
        if ((int32_t)___darwin_check_fd_set_overflow(0, v3, 0) == 0) {
            // 0x100003e98
            return 0;
        }
    }
    int64_t result = 0; // 0x100003e7c
    if (*(int32_t *)&v2 % 2 != 0) {
        uint32_t v4 = _getchar(); // 0x100003e84
        function_100003c34();
        result = v4;
    }
    // 0x100003e98
    return result;
}

// Address range: 0x100003eac - 0x100003f20
int64_t entry_point(void) {
    // 0x100003eac
    while (true) {
        // 0x100003ec0
        function_100003c34();
        _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004008);
        if ((int32_t)function_100003cd0() == 0) {
            _usleep(0x2710);
            while ((int32_t)function_100003cd0() == 0) {
                // 0x100003ef4
                _usleep(0x2710);
            }
        }
        // 0x100003f00
        int64_t v1; // 0x100003eac
        _printf("key %d\n", v1);
    }
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t function_100003f20(int32_t a1, int64_t a2, int64_t a3) {
    // 0x100003f20
    return ___darwin_check_fd_set_overflow(a1, a2, a3);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(struct _IO_FILE * stream) {
    // 0x100003f2c
    return _fflush(stream);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(void) {
    // 0x100003f38
    return _getchar();
}

// Address range: 0x100003f44 - 0x100003f50
int64_t * function_100003f44(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f44
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t * function_100003f50(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f50
    return _memset(s, c, n);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout) {
    // 0x100003f68
    return _select(nfds, readfds, writefds, exceptfds, timeout);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(int32_t fd, struct termios * termios_p) {
    // 0x100003f74
    return _tcgetattr(fd, termios_p);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(int32_t fd, int32_t optional_actions, struct termios * termios_p) {
    // 0x100003f80
    return _tcsetattr(fd, optional_actions, termios_p);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(int32_t useconds) {
    // 0x100003f8c
    return _usleep(useconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int w = 0, h = 0;
unsigned char *pix;

void refresh(int x, int y)
{
	int i, j, k;
	printf("\033[H");
	for (i = k = 0; i < h; putchar('\n'), i++)
		for (j = 0; j < w; j++, k++)
			putchar(pix[k] ? '#' : ' ');
}

void walk()
{
	int dx = 0, dy = 1, i, k;
	int x = w / 2, y = h / 2;

	pix = calloc(1, w * h);
	printf("\033[H\033[J");

	while (1) {
		i = (y * w + x);
		if (pix[i]) k = dx, dx = -dy, dy = k;
		else	    k = dy, dy = -dx, dx = k;

		pix[i] = !pix[i];
		printf("\033[%d;%dH%c", y + 1, x + 1, pix[i] ? '#' : ' ');

		x += dx, y += dy;

		k = 0;
		if (x < 0) {
			memmove(pix + 1, pix, w * h - 1);
			for (i = 0; i < w * h; i += w) pix[i] = 0;
			x++, k = 1;
		}
		else if (x >= w) {
			memmove(pix, pix + 1, w * h - 1);
			for (i = w-1; i < w * h; i += w) pix[i] = 0;
			x--, k = 1;
		}

		if (y >= h) {
			memmove(pix, pix + w, w * (h - 1));
			memset(pix + w * (h - 1), 0, w);
			y--, k = 1;
		}
		else if (y < 0) {
			memmove(pix + w, pix, w * (h - 1));
			memset(pix, 0, w);
			y++, k = 1;
		}
		if (k) refresh(x, y);
		printf("\033[%d;%dH\033[31m@\033[m", y + 1, x + 1);

		fflush(stdout);
		usleep(10000);
	}
}

int main(int c, char **v)
{
	if (c > 1) w = atoi(v[1]);
	if (c > 2) h = atoi(v[2]);
	if (w < 40) w = 40;
	if (h < 25) h = 25;

	walk();
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000382c(void);
int64_t function_100003914(void);
int64_t function_100003f20(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f2c(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int32_t function_100003f38(char * nptr);
int64_t * function_100003f44(int32_t nmemb, int32_t size);
int32_t function_100003f50(struct _IO_FILE * stream);
int32_t function_100003f5c(char * format, ...);
int32_t function_100003f68(int32_t c);
int32_t function_100003f74(int32_t useconds);

// --------------------- Global Variables ---------------------

char * g1 = "\x1b[H"; // 0x100003f80
char * g2 = "\x1b[H\x1b[J"; // 0x100003f84
char * g3 = "\x1b[%d;%dH%c"; // 0x100003f8b
char * g4 = "\x1b[%d;%dH\x1b[31m@\x1b[m"; // 0x100003f96
int32_t g5 = -0x1120531; // 0x100008000
int32_t g6 = 0x100000c; // 0x100008004
int64_t g7 = 0x200000000; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memmove_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___memset_chk(int64_t a1, int64_t a2, int32_t a3, int64_t a4);
int32_t _atoi(char * a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fflush(struct _IO_FILE * a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _usleep(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000382c - 0x100003914
int64_t function_10000382c(void) {
    int32_t result = _printf((char *)&g1); // 0x100003848
    int32_t v1 = -g6; // 0x100003864
    int32_t v2 = 0; // 0x10000386c
    if (v1 < 0 == (g6 & v1) < 0) {
        // 0x100003908
        return result;
    }
    int32_t v3 = 0; // 0x10000386c
    int32_t v4 = -g5; // 0x100003888
    int32_t v5 = v3; // 0x100003890
    int32_t v6; // 0x10000382c
    char v7; // 0x1000038a8
    int32_t v8; // 0x1000038d4
    int32_t v9; // 0x1000038e0
    int32_t v10; // 0x100003888
    if (v4 < 0 != (g5 & v4) < 0) {
        v7 = *(char *)(g7 + (int64_t)v5);
        _putchar(v7 == 0 ? 32 : 35);
        v8 = 1;
        v9 = v5 + 1;
        v10 = v8 - g5;
        v6 = v8;
        v5 = v9;
        v3 = v9;
        while (v10 < 0 != ((v10 ^ v8) & (g5 ^ v8)) < 0) {
            // 0x100003898
            v7 = *(char *)(g7 + (int64_t)v5);
            _putchar(v7 == 0 ? 32 : 35);
            v8 = v6 + 1;
            v9 = v5 + 1;
            v10 = v8 - g5;
            v6 = v8;
            v5 = v9;
            v3 = v9;
        }
    }
    // 0x1000038f0
    v2++;
    int32_t v11 = v2 - g6; // 0x100003864
    int32_t result2 = _putchar(10); // 0x10000386c
    while (v11 < 0 != ((v11 ^ v2) & (g6 ^ v2)) < 0) {
        // 0x10000387c
        v4 = -g5;
        v5 = v3;
        if (v4 < 0 != (g5 & v4) < 0) {
            v7 = *(char *)(g7 + (int64_t)v5);
            _putchar(v7 == 0 ? 32 : 35);
            v8 = 1;
            v9 = v5 + 1;
            v10 = v8 - g5;
            v6 = v8;
            v5 = v9;
            v3 = v9;
            while (v10 < 0 != ((v10 ^ v8) & (g5 ^ v8)) < 0) {
                // 0x100003898
                v7 = *(char *)(g7 + (int64_t)v5);
                _putchar(v7 == 0 ? 32 : 35);
                v8 = v6 + 1;
                v9 = v5 + 1;
                v10 = v8 - g5;
                v6 = v8;
                v5 = v9;
                v3 = v9;
            }
        }
        // 0x1000038f0
        v2++;
        v11 = v2 - g6;
        result2 = _putchar(10);
    }
    // 0x100003908
    return result2;
}

// Address range: 0x100003914 - 0x100003e4c
int64_t function_100003914(void) {
    // 0x100003914
    g7 = (int64_t)_calloc(1, g6 * g5);
    _printf((char *)&g2);
    int32_t v1 = 0; // 0x100003984
    int32_t v2 = 1; // 0x100003984
    int32_t v3 = g5 / 2; // 0x100003984
    int32_t v4 = g6 / 2; // 0x100003984
    int32_t v5; // 0x100003914
    while (true) {
      lab_0x100003988:;
        int32_t v6 = v2;
        int32_t v7 = v1;
        char * v8 = (char *)(g7 + (int64_t)(g5 * v4 + v3)); // 0x1000039b8
        char v9 = *v8; // 0x1000039b8
        v1 = v9 == 0 ? v6 : -v6;
        *v8 = (char)(v9 == 0);
        _printf((char *)&g3);
        int32_t v10 = v1 + v3; // 0x100003aac
        int32_t v11; // 0x100003914
        if (v10 < 0) {
            int64_t v12 = g7;
            ___memmove_chk(v12 + 1, v12, (int64_t)(g6 * g5 - 1), -1);
            int32_t v13 = g6 * g5; // 0x100003b34
            int32_t v14 = -v13; // 0x100003b38
            int32_t v15 = 0; // 0x100003b40
            if (v14 < 0 != (v13 & v14) < 0) {
                *(char *)(g7 + (int64_t)v15) = 0;
                int32_t v16 = g5 + v15; // 0x100003b70
                int32_t v17 = g6 * g5; // 0x100003b34
                int32_t v18 = v16 - v17; // 0x100003b38
                v15 = v16;
                while (v18 < 0 != ((v18 ^ v16) & (v17 ^ v16)) < 0) {
                    // 0x100003b48
                    *(char *)(g7 + (int64_t)v15) = 0;
                    v16 = g5 + v15;
                    v17 = g6 * g5;
                    v18 = v16 - v17;
                    v15 = v16;
                }
            }
            // 0x100003b7c
            v3 = v10 + 1;
            v11 = 1;
        } else {
            int32_t v19 = v10 - g5; // 0x100003ba0
            if (v19 < 0 == ((v19 ^ v10) & (g5 ^ v10)) < 0) {
                int64_t v20 = g7;
                ___memmove_chk(v20, v20 + 1, (int64_t)(g6 * g5 - 1), -1);
                int32_t v21 = g5 - 1; // 0x100003bf8
                int32_t v22 = g6 * g5; // 0x100003c18
                int32_t v23 = v21 - v22; // 0x100003c1c
                int32_t v24 = v21; // 0x100003c24
                if (v23 < 0 != ((v23 ^ v21) & (v22 ^ v21)) < 0) {
                    *(char *)(g7 + (int64_t)v24) = 0;
                    int32_t v25 = g5 + v24; // 0x100003c54
                    int32_t v26 = g6 * g5; // 0x100003c18
                    int32_t v27 = v25 - v26; // 0x100003c1c
                    v24 = v25;
                    while (v27 < 0 != ((v27 ^ v25) & (v26 ^ v25)) < 0) {
                        // 0x100003c2c
                        *(char *)(g7 + (int64_t)v24) = 0;
                        v25 = g5 + v24;
                        v26 = g6 * g5;
                        v27 = v25 - v26;
                        v24 = v25;
                    }
                }
                // 0x100003c60
                v3 = v10 - 1;
                v11 = 1;
            } else {
                // 0x100003b94
                v3 = v10;
                v11 = 0;
            }
        }
        // 0x100003c7c
        v2 = v9 == 0 ? -v7 : v7;
        int32_t v28 = v2 + v4; // 0x100003abc
        int32_t v29 = g5;
        int32_t v30 = v28 - g6; // 0x100003c88
        if (v30 < 0 == ((v30 ^ v28) & (g6 ^ v28)) < 0) {
            int64_t v31 = g7;
            ___memmove_chk(v31, v31 + (int64_t)v29, (int64_t)((g6 - 1) * v29), -1);
            int32_t v32 = g5;
            ___memset_chk(g7 + (int64_t)((g6 - 1) * v32), 0, v32, -1);
            v5 = v28 - 1;
            goto lab_0x100003df0;
        } else {
            if (v28 < 0) {
                int64_t v33 = g7;
                ___memmove_chk(v33 + (int64_t)v29, v33, (int64_t)((g6 - 1) * v29), -1);
                ___memset_chk(g7, 0, g5, -1);
                v5 = v28 + 1;
                goto lab_0x100003df0;
            } else {
                // 0x100003ddc
                v5 = v28;
                v4 = v28;
                if (v11 == 0) {
                    goto lab_0x100003e00;
                } else {
                    goto lab_0x100003df0;
                }
            }
        }
    }
  lab_0x100003df0:
    // 0x100003df0
    function_10000382c();
    v4 = v5;
    goto lab_0x100003e00;
  lab_0x100003e00:
    // 0x100003e00
    _printf((char *)&g4);
    _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004010);
    _usleep(0x2710);
    goto lab_0x100003988;
}

// Address range: 0x100003e4c - 0x100003f20
int64_t entry_point(void) {
    // 0x100003e4c
    int64_t v1; // 0x100003e4c
    int32_t v2 = v1; // 0x100003e5c
    int32_t v3 = v2 - 1; // 0x100003e68
    if (v3 != 0 && v3 < 0 == (v2 & -v2) < 0) {
        // 0x100003e78
        g5 = _atoi((char *)*(int64_t *)(v1 + 8));
    }
    int32_t v4 = v2 - 2; // 0x100003e94
    if (v4 != 0 && v4 < 0 == (1 - v2 & v2) < 0) {
        // 0x100003ea4
        g6 = _atoi((char *)*(int64_t *)(v1 + 16));
    }
    int32_t v5 = g5; // 0x100003ec0
    if (v5 < 40 != (39 - v5 & v5) < 0) {
        // 0x100003ed4
        g5 = 40;
    }
    int32_t v6 = g6; // 0x100003ee8
    if (v6 < 25 != (24 - v6 & v6) < 0) {
        // 0x100003efc
        g6 = 25;
    }
    // 0x100003f0c
    function_100003914();
    return 0;
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t function_100003f20(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f20
    return ___memmove_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f2c - 0x100003f38
int64_t function_100003f2c(int64_t a1, int64_t a2, int32_t a3, int64_t a4) {
    // 0x100003f2c
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * nptr) {
    // 0x100003f38
    return _atoi(nptr);
}

// Address range: 0x100003f44 - 0x100003f50
int64_t * function_100003f44(int32_t nmemb, int32_t size) {
    // 0x100003f44
    return _calloc(nmemb, size);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(struct _IO_FILE * stream) {
    // 0x100003f50
    return _fflush(stream);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(int32_t c) {
    // 0x100003f68
    return _putchar(c);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(int32_t useconds) {
    // 0x100003f74
    return _usleep(useconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <stdio.h>
#include <stdlib.h> /* malloc */
#include <string.h> /* strlen */
#define _XOPEN_SOURCE /* requred for time functions */
#define __USE_XOPEN
#include <time.h>
#define DB "database.csv" /* database name */
#define TRY(a)  if (!(a)) {perror(#a);exit(1);}
#define TRY2(a) if((a)<0) {perror(#a);exit(1);}
#define FREE(a) if(a) {free(a);a=NULL;}
#define sort_by(foo) \
static int by_##foo (const void*p1, const void*p2) { \
    return strcmp ((*(const pdb_t*)p1)->foo, (*(const pdb_t*)p2)->foo); }
typedef struct db {
    char title[26];
    char first_name[26];
    char last_name[26];
    time_t date;
    char publ[100];
    struct db *next;
}
db_t,*pdb_t;
typedef int (sort)(const void*, const void*);
enum {CREATE,PRINT,TITLE,DATE,AUTH,READLINE,READ,SORT,DESTROY};
static pdb_t dao (int cmd, FILE *f, pdb_t db, sort sortby);
static char *time2str (time_t *time);
static time_t str2time (char *date);
/* qsort callbacks */
sort_by(last_name);
sort_by(title);
static int by_date(pdb_t *p1, pdb_t *p2);
/* main */
int main (int argc, char **argv) {
    char buf[100];
    const char *commands[]={"-c", "-p", "-t", "-d", "-a", NULL};
    db_t db;
    db.next=NULL;
    pdb_t dblist;
    int i;
    FILE *f;
    TRY (f=fopen(DB,"a+"));
    if (argc<2) {
usage:  printf ("Usage: %s [commands]\n"
        "-c  Create new entry.\n"
        "-p  Print the latest entry.\n"
        "-t  Print all entries sorted by title.\n"
        "-d  Print all entries sorted by date.\n"
        "-a  Print all entries sorted by author.\n",argv[0]);
        fclose (f);
        return 0;
    }
    for (i=0;commands[i]&&strcmp(argv[1],commands[i]);i++);
    switch (i) {
        case CREATE:
        printf("-c  Create a new entry.\n");
        printf("Title           :");if((scanf(" %25[^\n]",db.title     ))<0)break;
        printf("Author Firstname:");if((scanf(" %25[^\n]",db.first_name))<0)break;
        printf("Author Lastname :");if((scanf(" %25[^\n]",db.last_name ))<0)break;
        printf("Date 10-12-2000 :");if((scanf(" %10[^\n]",buf          ))<0)break;
        printf("Publication     :");if((scanf(" %99[^\n]",db.publ      ))<0)break;
        db.date=str2time (buf);
        dao (CREATE,f,&db,NULL);
        break;
        case PRINT:
        printf ("-p  Print the latest entry.\n");
        while (!feof(f)) dao (READLINE,f,&db,NULL);
        dao (PRINT,f,&db,NULL);
        break;
        case TITLE:
        printf ("-t  Print all entries sorted by title.\n");
        dblist = dao (READ,f,&db,NULL);
        dblist = dao (SORT,f,dblist,by_title);
        dao (PRINT,f,dblist,NULL);
        dao (DESTROY,f,dblist,NULL);
        break;
        case DATE:
        printf ("-d  Print all entries sorted by date.\n");
        dblist = dao (READ,f,&db,NULL);
        dblist = dao (SORT,f,dblist,(int (*)(const void *,const  void *)) by_date);
        dao (PRINT,f,dblist,NULL);
        dao (DESTROY,f,dblist,NULL);
        break;
        case AUTH:
        printf ("-a  Print all entries sorted by author.\n");
        dblist = dao (READ,f,&db,NULL);
        dblist = dao (SORT,f,dblist,by_last_name);
        dao (PRINT,f,dblist,NULL);
        dao (DESTROY,f,dblist,NULL);
        break;
        default: {
            printf ("Unknown command: %s.\n",strlen(argv[1])<10?argv[1]:"");
            goto usage;
    }   }
    fclose (f);
    return 0;
}
/* Data Access Object (DAO) */
static pdb_t dao (int cmd, FILE *f, pdb_t in_db, sort sortby) {
    pdb_t *pdb=NULL,rec=NULL,hd=NULL;
    int i=0,ret;
    char buf[100];
    switch (cmd) {
        case CREATE:
        fprintf (f,"\"%s\",",in_db->title);
        fprintf (f,"\"%s\",",in_db->first_name);
        fprintf (f,"\"%s\",",in_db->last_name);
        fprintf (f,"\"%s\",",time2str(&in_db->date));
        fprintf (f,"\"%s\" \n",in_db->publ);
        break;
        case PRINT:
        for (;in_db;i++) {
            printf ("Title       : %s\n",     in_db->title);
            printf ("Author      : %s %s\n",  in_db->first_name, in_db->last_name);
            printf ("Date        : %s\n",     time2str(&in_db->date));
            printf ("Publication : %s\n\n",   in_db->publ);
            if (!((i+1)%3)) {
                printf ("Press Enter to continue.\n");
                ret = scanf ("%*[^\n]");
                if (ret<0) return rec; /* handle EOF */
                else getchar();
            }
            in_db=in_db->next;
        }
        break;
        case READLINE:
        if((fscanf(f," \"%[^\"]\",",in_db->title     ))<0)break;
        if((fscanf(f," \"%[^\"]\",",in_db->first_name))<0)break;
        if((fscanf(f," \"%[^\"]\",",in_db->last_name ))<0)break;
        if((fscanf(f," \"%[^\"]\",",buf              ))<0)break;
        if((fscanf(f," \"%[^\"]\" ",in_db->publ      ))<0)break;
        in_db->date=str2time (buf);
        break;
        case READ:
        while (!feof(f)) {
            dao (READLINE,f,in_db,NULL);
            TRY (rec=malloc(sizeof(db_t)));
            *rec=*in_db; /* copy contents */
            rec->next=hd;/* to linked list */
            hd=rec;i++;
        }
        if (i<2) {
            puts ("Empty database. Please create some entries.");
            fclose (f);
            exit (0);
        }
        break;
        case SORT:
        rec=in_db;
        for (;in_db;i++) in_db=in_db->next;
        TRY (pdb=malloc(i*sizeof(pdb_t)));
        in_db=rec;
        for (i=0;in_db;i++) {
            pdb[i]=in_db;
            in_db=in_db->next;
        }
        qsort (pdb,i,sizeof in_db,sortby);
        pdb[i-1]->next=NULL;
        for (i=i-1;i;i--) {
            pdb[i-1]->next=pdb[i];
        }
        rec=pdb[0];
        FREE (pdb);
        pdb=NULL;
        break;
        case DESTROY: {
            while ((rec=in_db)) {
                in_db=in_db->next;
                FREE (rec);
    }   }   }
    return rec;
}
/* convert numeric time to date string */
static char *time2str (time_t *time) {
    static char buf[255];
    struct tm *ptm;
    ptm=localtime (time);
    strftime(buf, 255, "%m-%d-%Y", ptm);
    return buf;
}
/* convert date string to numeric time */
static time_t str2time (char *date) {
    struct tm tm;
    memset (&tm, 0, sizeof(struct tm));
    strptime(date, "%m-%d-%Y", &tm);
    return mktime(&tm);
}
/* sort by date callback for qsort */
static int by_date (pdb_t *p1, pdb_t *p2) {
    if ((*p1)->date < (*p2)->date) {
        return -1;
    }
    else return ((*p1)->date > (*p2)->date);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int64_t function_10000335c(void);
int64_t function_1000033a8(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7);
int64_t function_100003a18(void);
int64_t function_100003a4c(void);
int64_t function_100003ac4(void);
int64_t function_100003b00(void);
int64_t function_100003b4c(int64_t a1);
void function_100003b58(int32_t status);
int32_t function_100003b64(struct _IO_FILE * stream);
int32_t function_100003b70(struct _IO_FILE * stream);
struct _IO_FILE * function_100003b7c(char * filename, char * modes);
int32_t function_100003b88(struct _IO_FILE * stream, char * format, ...);
void function_100003b94(int64_t * ptr);
int32_t function_100003ba0(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003bac(void);
struct tm * function_100003bb8(int32_t * timer);
int64_t * function_100003bc4(int32_t size);
int64_t * function_100003bd0(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003bdc(int64_t * s, int32_t c, int32_t n);
int32_t function_100003be8(struct tm * tp);
void function_100003bf4(char * s);
int32_t function_100003c00(char * format, ...);
int32_t function_100003c0c(char * s);
void function_100003c18(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int32_t function_100003c24(char * format, ...);
int32_t function_100003c30(char * s1, char * s2);
int32_t function_100003c3c(char * s, int32_t maxsize, char * format, struct tm * tp);
int32_t function_100003c48(char * s);
char * function_100003c54(char * s, char * fmt, struct tm * tp);

// --------------------- Global Variables ---------------------

char * g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _feof(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int32_t _getchar(void);
struct tm * _localtime(int32_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _mktime(struct tm * a1);
void _perror(char * a1);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int32_t _scanf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);
int32_t _strftime(char * a1, int32_t a2, char * a3, struct tm * a4);
int32_t _strlen(char * a1);
char * _strptime(char * a1, char * a2, struct tm * a3);

// ------------------------ Functions -------------------------

// Address range: 0x100002e30 - 0x100003348
int64_t entry_point(int64_t a1) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100002e48
    int64_t v2; // bp-192, 0x100002e30
    _memcpy(&v2, (int64_t *)"<", 48);
    struct _IO_FILE * v3 = _fopen("database.csv", "a+"); // 0x100002e84
    if (v3 == NULL) {
        // 0x100002ea0
        _perror("f=fopen(DB,\"a+\")");
        _exit(1);
        // UNREACHABLE
    }
    // 0x100002eb4
    int64_t v4; // 0x100002e30
    int32_t v5 = v4; // 0x100002e54
    int64_t v6 = (int64_t)"a+"; // 0x100002ec0
    int32_t v7; // 0x100002e30
    int64_t * v8; // 0x100002e30
    int64_t result; // 0x100002e30
    int64_t v9; // 0x100002e30
    if (v5 < 2 == (1 - v5 & v5) < 0) {
        // 0x100002f00
        v8 = (int64_t *)(v4 + 8);
        int32_t v10 = 0; // 0x100002f1c
        v7 = 0;
        v9 = (int64_t)"a+";
        result = (int64_t)v3;
        if (v2 != 0) {
            int64_t v11 = v2;
            int32_t v12 = _strcmp((char *)*v8, (char *)v11); // 0x100002f38
            v7 = v10;
            v9 = v11;
            result = 0;
            while (v12 != 0) {
                int32_t v13 = v10 + 1; // 0x100002f60
                int64_t v14 = *(int64_t *)(8 * (int64_t)v13 + (int64_t)&v2); // 0x100002f08
                v10 = v13;
                if (v14 == 0) {
                    // 0x100002f00
                    v7 = v13;
                    v9 = v11;
                    result = v12;
                    goto lab_0x100002f6c;
                }
                v11 = v14;
                v12 = _strcmp((char *)*v8, (char *)v11);
                v7 = v10;
                v9 = v11;
                result = 0;
            }
        }
        goto lab_0x100002f6c;
    } else {
        goto lab_0x100002ecc;
    }
  lab_0x100002ecc:
    // 0x100002ecc
    _printf("Usage: %s [commands]\n-c  Create new entry.\n-p  Print the latest entry.\n-t  Print all entries sorted by title.\n-d  Print all entries sorted by date.\n-a  Print all entries sorted by author.\n", (char *)v6);
    int32_t v15 = _fclose(v3); // 0x100002eec
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003330
        ___stack_chk_fail((int64_t)v15);
    }
    // 0x100002f88
    return 0;
  lab_0x100002f6c:;
    uint32_t v16 = v7;
    if (v16 >= 4 != v16 != 4) {
        // 0x100002f88
        return result;
    }
    // 0x1000032a0
    v6 = v9;
    _strlen((char *)*v8);
    _printf("Unknown command: %s.\n", (char *)v6);
    goto lab_0x100002ecc;
}

// Address range: 0x10000335c - 0x1000033a8
int64_t function_10000335c(void) {
    // 0x10000335c
    int64_t v1; // bp-80, 0x10000335c
    _memset(&v1, 0, 56);
    int64_t v2; // 0x10000335c
    _strptime((char *)v2, "%m-%d-%Y", (struct tm *)&v1);
    return _mktime((struct tm *)&v1);
}

// Address range: 0x1000033a8 - 0x1000039f4
int64_t function_1000033a8(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7) {
    // 0x1000033a8
    int64_t v1; // 0x1000033a8
    uint64_t v2 = v1 & 0xffffffff; // 0x1000033f0
    return v2 >= 8 == (v2 != 8) ? 0 : v1;
}

// Address range: 0x100003a18 - 0x100003a4c
int64_t function_100003a18(void) {
    // 0x100003a18
    int64_t v1; // 0x100003a18
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003a4c - 0x100003ac4
int64_t function_100003a4c(void) {
    // 0x100003a4c
    int64_t v1; // 0x100003a4c
    int64_t v2 = *(int64_t *)(v1 + 80); // 0x100003a60
    int64_t v3 = *(int64_t *)(v1 + 80); // 0x100003a6c
    int64_t v4 = v2 - v3; // 0x100003a70
    return v4 < 0 == ((v4 ^ v2) & (v3 ^ v2)) < 0 ? (int64_t)(v4 != 0) : 0xffffffff;
}

// Address range: 0x100003ac4 - 0x100003b00
int64_t function_100003ac4(void) {
    // 0x100003ac4
    int64_t v1; // 0x100003ac4
    return _strcmp((char *)(v1 + 52), (char *)(v1 + 52));
}

// Address range: 0x100003b00 - 0x100003b4c
int64_t function_100003b00(void) {
    // 0x100003b00
    int64_t v1; // 0x100003b00
    _strftime((char *)&g1, 255, "%m-%d-%Y", _localtime((int32_t *)v1));
    return (int64_t)&g1;
}

// Address range: 0x100003b4c - 0x100003b58
int64_t function_100003b4c(int64_t a1) {
    // 0x100003b4c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003b58 - 0x100003b64
void function_100003b58(int32_t status) {
    // 0x100003b58
    _exit(status);
}

// Address range: 0x100003b64 - 0x100003b70
int32_t function_100003b64(struct _IO_FILE * stream) {
    // 0x100003b64
    return _fclose(stream);
}

// Address range: 0x100003b70 - 0x100003b7c
int32_t function_100003b70(struct _IO_FILE * stream) {
    // 0x100003b70
    return _feof(stream);
}

// Address range: 0x100003b7c - 0x100003b88
struct _IO_FILE * function_100003b7c(char * filename, char * modes) {
    // 0x100003b7c
    return _fopen(filename, modes);
}

// Address range: 0x100003b88 - 0x100003b94
int32_t function_100003b88(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003b88
    return _fprintf(stream, format);
}

// Address range: 0x100003b94 - 0x100003ba0
void function_100003b94(int64_t * ptr) {
    // 0x100003b94
    _free(ptr);
}

// Address range: 0x100003ba0 - 0x100003bac
int32_t function_100003ba0(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ba0
    return _fscanf(stream, format);
}

// Address range: 0x100003bac - 0x100003bb8
int32_t function_100003bac(void) {
    // 0x100003bac
    return _getchar();
}

// Address range: 0x100003bb8 - 0x100003bc4
struct tm * function_100003bb8(int32_t * timer) {
    // 0x100003bb8
    return _localtime(timer);
}

// Address range: 0x100003bc4 - 0x100003bd0
int64_t * function_100003bc4(int32_t size) {
    // 0x100003bc4
    return _malloc(size);
}

// Address range: 0x100003bd0 - 0x100003bdc
int64_t * function_100003bd0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003bd0
    return _memcpy(dest, src, n);
}

// Address range: 0x100003bdc - 0x100003be8
int64_t * function_100003bdc(int64_t * s, int32_t c, int32_t n) {
    // 0x100003bdc
    return _memset(s, c, n);
}

// Address range: 0x100003be8 - 0x100003bf4
int32_t function_100003be8(struct tm * tp) {
    // 0x100003be8
    return _mktime(tp);
}

// Address range: 0x100003bf4 - 0x100003c00
void function_100003bf4(char * s) {
    // 0x100003bf4
    _perror(s);
}

// Address range: 0x100003c00 - 0x100003c0c
int32_t function_100003c00(char * format, ...) {
    // 0x100003c00
    return _printf(format);
}

// Address range: 0x100003c0c - 0x100003c18
int32_t function_100003c0c(char * s) {
    // 0x100003c0c
    return _puts(s);
}

// Address range: 0x100003c18 - 0x100003c24
void function_100003c18(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003c18
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003c24 - 0x100003c30
int32_t function_100003c24(char * format, ...) {
    // 0x100003c24
    return _scanf(format);
}

// Address range: 0x100003c30 - 0x100003c3c
int32_t function_100003c30(char * s1, char * s2) {
    // 0x100003c30
    return _strcmp(s1, s2);
}

// Address range: 0x100003c3c - 0x100003c48
int32_t function_100003c3c(char * s, int32_t maxsize, char * format, struct tm * tp) {
    // 0x100003c3c
    return _strftime(s, maxsize, format, tp);
}

// Address range: 0x100003c48 - 0x100003c54
int32_t function_100003c48(char * s) {
    // 0x100003c48
    return _strlen(s);
}

// Address range: 0x100003c54 - 0x100003c60
char * function_100003c54(char * s, char * fmt, struct tm * tp) {
    // 0x100003c54
    return _strptime(s, fmt, tp);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 30

`
`#include <stdio.h>
#include <math.h>

// https://webspace.science.uu.nl/~gent0113/calendar/isocalendar.htm

int p(int year) {
	return (int)((double)year + floor(year/4) - floor(year/100) + floor(year/400)) % 7;
}

int is_long_year(int year) {
	return p(year) == 4 || p(year - 1) == 3;
}

void print_long_years(int from, int to) {
	for (int year = from; year <= to; ++year) {
		if (is_long_year(year)) {
			printf("%d ", year);
		}
	}
}

int main() {

	printf("Long (53 week) years between 1800 and 2100\n\n");
	print_long_years(1800, 2100);
	printf("\n");
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003da8(void);
int64_t function_100003e24(void);
int64_t function_100003e84(void);
int32_t function_100003f60(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003da8 - 0x100003e24
int64_t function_100003da8(void) {
    // 0x100003da8
    int64_t v1; // 0x100003da8
    int32_t v2 = v1; // 0x100003dac
    __asm_sshll(0.0f, 0);
    float64_t v3 = __asm_frintm((float64_t)(v2 / 4)); // 0x100003dd0
    float64_t v4 = __asm_frintm((float64_t)(v2 / 100)); // 0x100003de8
    float64_t v5; // 0x100003da8
    return (int32_t)(v5 + v3 - v4 + __asm_frintm((float64_t)(v2 / 400))) % 7;
}

// Address range: 0x100003e24 - 0x100003e84
int64_t function_100003e24(void) {
    int64_t result = 1; // 0x100003e4c
    if ((int32_t)function_100003da8() != 4) {
        // 0x100003e54
        result = (int32_t)function_100003da8() == 3;
    }
    // 0x100003e70
    return result;
}

// Address range: 0x100003e84 - 0x100003f14
int64_t function_100003e84(void) {
    // 0x100003e84
    int64_t v1; // 0x100003e84
    int32_t v2 = v1; // 0x100003e90
    int32_t v3 = v1; // 0x100003e94
    int32_t v4 = v2 - v3; // 0x100003eac
    if (v4 != 0 && v4 < 0 == ((v4 ^ v2) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x100003f08
        int64_t result; // 0x100003e84
        return result;
    }
    int32_t v5 = v2; // 0x100003eb4
    int64_t v6 = function_100003e24(); // 0x100003ec0
    int64_t result2 = v6; // 0x100003ecc
    if ((int32_t)v6 != 0) {
        // 0x100003ed4
        result2 = _printf("%d ", v1);
    }
    // 0x100003ef8
    v5++;
    int32_t v7 = v5 - v3; // 0x100003eac
    while (v7 == 0 || v7 < 0 != ((v7 ^ v5) & (v5 ^ v3)) < 0) {
        // 0x100003ebc
        v6 = function_100003e24();
        result2 = v6;
        if ((int32_t)v6 != 0) {
            // 0x100003ed4
            result2 = _printf("%d ", v1);
        }
        // 0x100003ef8
        v5++;
        v7 = v5 - v3;
    }
    // 0x100003f08
    return result2;
}

// Address range: 0x100003f14 - 0x100003f60
int64_t entry_point(void) {
    // 0x100003f14
    _printf("Long (53 week) years between 1800 and 2100\n\n");
    function_100003e84();
    _printf((char *)0x100003f9d);
    return 0;
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>

unsigned digit_sum(unsigned n) {
    unsigned sum = 0;
    do { sum += n % 10; }
    while(n /= 10);
    return sum;
}

unsigned a131382(unsigned n) {
    unsigned m;
    for (m = 1; n != digit_sum(m*n); m++);
    return m;
}

int main() {
    unsigned n;
    for (n = 1; n <= 70; n++) {
        printf("%9u", a131382(n));
        if (n % 10 == 0) printf("\n");
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e18(void);
int64_t function_100003e78(void);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e18 - 0x100003e78
int64_t function_100003e18(void) {
    int32_t result = 0; // 0x100003e24
    int64_t v1; // 0x100003e18
    uint32_t v2 = (int32_t)v1; // 0x100003e24
    result += v2 % 10;
    while (v2 >= 10) {
        // 0x100003e28
        v2 /= 10;
        result += v2 % 10;
    }
    // 0x100003e6c
    return result;
}

// Address range: 0x100003e78 - 0x100003ee4
int64_t function_100003e78(void) {
    uint32_t result = 1;
    int32_t v1 = result + 1; // 0x100003eb8
    int64_t v2; // 0x100003e78
    while ((int32_t)v2 != (int32_t)function_100003e18()) {
        // 0x100003e94
        result = v1;
        v1 = result + 1;
    }
    // 0x100003ed4
    return result;
}

// Address range: 0x100003ee4 - 0x100003f8c
int64_t entry_point(void) {
    for (int32_t i = 1; i < 71; i++) {
        // 0x100003f14
        function_100003e78();
        int64_t v1; // 0x100003ee4
        _printf("%9u", (int32_t)v1);
        if (i % 10 == 0) {
            // 0x100003f58
            _printf((char *)0x100003f9c);
        }
    }
    // 0x100003f7c
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <time.h>

static const char *months[] = {"January", "February", "March", "April", "May",
    "June", "July", "August", "September", "October", "November", "December"};
static int long_months[] = {0, 2, 4, 6, 7, 9, 11};

int main() {
    int n = 0, y, i, m;
    struct tm t = {0};
    printf("Months with five weekends:\n");
    for (y = 1900; y <= 2100; y++) {
        for (i = 0; i < 7; i++) {
            m = long_months[i];
            t.tm_year = y-1900;
	    t.tm_mon = m;
	    t.tm_mday = 1;
            if (mktime(&t) == -1) { /* date not supported */
                printf("Error: %d %s\n", y, months[m]);
                continue;
            }
            if (t.tm_wday == 5) { /* Friday */
                printf("  %d %s\n", y, months[m]);
                n++;
            }
        }
    }
    printf("%d total\n", n);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t * function_100003ef0(int64_t * s, int32_t c, int32_t n);
int32_t function_100003efc(struct tm * tp);
int32_t function_100003f08(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _mktime(struct tm * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d60 - 0x100003ef0
int64_t entry_point(void) {
    // 0x100003d60
    int64_t v1; // bp-96, 0x100003d60
    _memset(&v1, 0, 56);
    _printf("Months with five weekends:\n");
    int32_t v2 = 1900;
    int32_t v3; // 0x100003d60
    for (int32_t i = 0; i < 7; i++) {
        // 0x100003dcc
        if (_mktime((struct tm *)&v1) == -1) {
            // 0x100003e14
            _printf("Error: %d %s\n", 0, (char *)56);
        } else {
            if (v3 == 5) {
                // 0x100003e5c
                _printf("  %d %s\n", 0, (char *)56);
            }
        }
    }
    int32_t v4 = v2 + 1; // 0x100003eb8
    while (v2 == 2099 || v2 < 2099 != (2098 - v2 & v4) < 0) {
        // 0x100003db8
        v2 = v4;
        for (int32_t i = 0; i < 7; i++) {
            // 0x100003dcc
            if (_mktime((struct tm *)&v1) == -1) {
                // 0x100003e14
                _printf("Error: %d %s\n", 0, (char *)56);
            } else {
                if (v3 == 5) {
                    // 0x100003e5c
                    _printf("  %d %s\n", 0, (char *)56);
                }
            }
        }
        // 0x100003eb4
        v4 = v2 + 1;
    }
    // 0x100003ec4
    _printf("%d total\n", 0);
    return 0;
}

// Address range: 0x100003ef0 - 0x100003efc
int64_t * function_100003ef0(int64_t * s, int32_t c, int32_t n) {
    // 0x100003ef0
    return _memset(s, c, n);
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(struct tm * tp) {
    // 0x100003efc
    return _mktime(tp);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(char * format, ...) {
    // 0x100003f08
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h> /* for atoi() and malloc() */
#include <string.h> /* for memmove() */

/* Conveniently print to standard error and exit nonzero. */
#define ERROR(fmt, arg) return fprintf(stderr, fmt "\n", arg)

int main(int argc, char **argv)
{
    FILE *fp;
    char *buf;
    size_t sz;
    int start, count, lines = 1;
    int dest = 0, src = 0, pos = -1;

    /* Initialization and sanity checks */
    if (argc != 4)
        ERROR("Usage: %s <file> <start> <count>", argv[0]);

    if ((count = atoi(argv[3])) < 1) /* We're a no-op. */
        return 0;

    if ((start = atoi(argv[2])) < 1)
        ERROR("Error: <start> (%d) must be positive", start);

    if ((fp = fopen(argv[1], "r")) == NULL)
        ERROR("No such file: %s", argv[1]);

    /* Determine filesize and allocate a buffer accordingly. */
    fseek(fp, 0, SEEK_END);
    sz = ftell(fp);
    buf = malloc(sz + 1);
    rewind(fp);

    /* Fill the buffer, count lines, and remember a few important offsets. */
    while ((buf[++pos] = fgetc(fp)) != EOF) {
        if (buf[pos] == '\n') {
            ++lines;
            if (lines == start) dest = pos + 1;
            if (lines == start + count) src = pos + 1;
        }
    }

    /* We've been asked to do something weird; clean up and bail. */
    if (start + count > lines) {
        free(buf);
        fclose(fp);
        ERROR("Error: invalid parameters for file with %d lines", --lines);
    }

    /* Overwrite the lines to be deleted with the survivors. */
    memmove(buf + dest, buf + src, pos - src);

    /* Reopen the file and write back just enough of the buffer. */
    freopen(argv[1], "w", fp);
    fwrite(buf, pos - src + dest, 1, fp);

    free(buf);
    fclose(fp);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e7c(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003e88(char * nptr);
int32_t function_100003e94(struct _IO_FILE * stream);
int32_t function_100003ea0(struct _IO_FILE * stream);
struct _IO_FILE * function_100003eac(char * filename, char * modes);
int32_t function_100003eb8(struct _IO_FILE * stream, char * format, ...);
void function_100003ec4(int64_t * ptr);
struct _IO_FILE * function_100003ed0(char * filename, char * modes, struct _IO_FILE * stream);
int32_t function_100003edc(struct _IO_FILE * stream, int32_t off, int32_t whence);
int32_t function_100003ee8(struct _IO_FILE * stream);
int32_t function_100003ef4(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t * function_100003f00(int32_t size);
void function_100003f0c(struct _IO_FILE * stream);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memmove_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _atoi(char * a1);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
struct _IO_FILE * _freopen(char * a1, char * a2, struct _IO_FILE * a3);
int32_t _fseek(struct _IO_FILE * a1, int32_t a2, int32_t a3);
int32_t _ftell(struct _IO_FILE * a1);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int64_t * _malloc(int32_t a1);
void _rewind(struct _IO_FILE * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b3c - 0x100003e7c
int64_t entry_point(void) {
    // 0x100003b3c
    int32_t result; // 0x100003b3c
    int64_t v1; // 0x100003b3c
    if ((int32_t)v1 != 4) {
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b88
        result = _fprintf((struct _IO_FILE *)v2, "Usage: %s <file> <start> <count>\n", (char *)v1);
        // 0x100003e6c
        return result;
    }
    int32_t v3 = _atoi((char *)*(int64_t *)(v1 + 24)); // 0x100003bb8
    if (v3 < 1 != (v3 & -v3) < 0) {
        // 0x100003e6c
        return 0;
    }
    int32_t v4 = _atoi((char *)*(int64_t *)(v1 + 16)); // 0x100003be0
    if (v4 < 1 != (v4 & -v4) < 0) {
        int64_t v5 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c00
        // 0x100003e6c
        return _fprintf((struct _IO_FILE *)v5, "Error: <start> (%d) must be positive\n", v1);
    }
    int64_t * v6 = (int64_t *)(v1 + 8); // 0x100003c2c
    struct _IO_FILE * v7 = _fopen((char *)*v6, "r"); // 0x100003c38
    if (v7 == NULL) {
        int64_t v8 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c5c
        // 0x100003e6c
        return _fprintf((struct _IO_FILE *)v8, "No such file: %s\n", (char *)v1);
    }
    // 0x100003c84
    _fseek(v7, 0, 2);
    int64_t * v9 = _malloc(_ftell(v7) + 1); // 0x100003ca8
    int64_t v10 = (int64_t)v9; // 0x100003ca8
    _rewind(v7);
    uint32_t v11 = _fgetc(v7); // 0x100003cc0
    *(char *)v9 = (char)v11;
    int32_t v12 = v4 + v3;
    int32_t v13 = 1; // 0x100003ce4
    int32_t v14 = 0; // 0x100003ce4
    int32_t v15 = 0; // 0x100003ce4
    int32_t v16 = 0; // 0x100003ce4
    if (v11 % 256 != 255) {
        int32_t v17 = 1;
        int32_t v18 = 0;
        int32_t v19 = 0;
        int32_t v20 = 0;
        int32_t v21 = v17; // 0x100003d00
        int32_t v22 = v18; // 0x100003d00
        int32_t v23 = v19; // 0x100003d00
        int32_t v24; // 0x100003b3c
        if (*(char *)((int64_t)v20 + v10) == 10) {
            // 0x100003d08
            v21 = v17 + 1;
            v24 = 1;
            v22 = v21 == v4 ? v24 : v18;
            v23 = v21 == v12 ? v24 : v19;
        }
        int32_t v25 = v23;
        int32_t v26 = v22;
        int32_t v27 = v21;
        uint32_t v28 = _fgetc(v7); // 0x100003cc0
        int32_t v29 = v20 + 1; // 0x100003ccc
        *(char *)((int64_t)v29 + v10) = (char)v28;
        int32_t v30 = v20; // 0x100003ce4
        v13 = v27;
        v14 = v26;
        v15 = v25;
        v16 = v29;
        while (v28 % 256 != 255) {
            // 0x100003cec
            v17 = v27;
            v18 = v26;
            v19 = v25;
            v20 = v29;
            v21 = v17;
            v22 = v18;
            v23 = v19;
            if (*(char *)((int64_t)v20 + v10) == 10) {
                // 0x100003d08
                v21 = v17 + 1;
                v24 = v30 + 2;
                v22 = v21 == v4 ? v24 : v18;
                v23 = v21 == v12 ? v24 : v19;
            }
            // 0x100003d70
            v25 = v23;
            v26 = v22;
            v27 = v21;
            v28 = _fgetc(v7);
            v29 = v20 + 1;
            *(char *)((int64_t)v29 + v10) = (char)v28;
            v30 = v20;
            v13 = v27;
            v14 = v26;
            v15 = v25;
            v16 = v29;
        }
    }
    int32_t v31 = v12 - v13; // 0x100003d84
    if (v31 == 0 || v31 < 0 != ((v31 ^ v12) & (v13 ^ v12)) < 0) {
        int32_t v32 = v16 - v15; // 0x100003dfc
        ___memmove_chk((int64_t)v14 + v10, (int64_t)v15 + v10, (int64_t)v32, -1);
        _freopen((char *)*v6, (char *)0x100003fa6, v7);
        _fwrite(v9, v32 + v14, 1, v7);
        _free(v9);
        _fclose(v7);
        result = 0;
    } else {
        // 0x100003d94
        _free(v9);
        _fclose(v7);
        int64_t v33 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dac
        result = _fprintf((struct _IO_FILE *)v33, "Error: invalid parameters for file with %d lines\n", 2);
    }
    // 0x100003e6c
    return result;
}

// Address range: 0x100003e7c - 0x100003e88
int64_t function_100003e7c(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003e7c
    return ___memmove_chk(a1, a2, a3, a4);
}

// Address range: 0x100003e88 - 0x100003e94
int32_t function_100003e88(char * nptr) {
    // 0x100003e88
    return _atoi(nptr);
}

// Address range: 0x100003e94 - 0x100003ea0
int32_t function_100003e94(struct _IO_FILE * stream) {
    // 0x100003e94
    return _fclose(stream);
}

// Address range: 0x100003ea0 - 0x100003eac
int32_t function_100003ea0(struct _IO_FILE * stream) {
    // 0x100003ea0
    return _fgetc(stream);
}

// Address range: 0x100003eac - 0x100003eb8
struct _IO_FILE * function_100003eac(char * filename, char * modes) {
    // 0x100003eac
    return _fopen(filename, modes);
}

// Address range: 0x100003eb8 - 0x100003ec4
int32_t function_100003eb8(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003eb8
    return _fprintf(stream, format);
}

// Address range: 0x100003ec4 - 0x100003ed0
void function_100003ec4(int64_t * ptr) {
    // 0x100003ec4
    _free(ptr);
}

// Address range: 0x100003ed0 - 0x100003edc
struct _IO_FILE * function_100003ed0(char * filename, char * modes, struct _IO_FILE * stream) {
    // 0x100003ed0
    return _freopen(filename, modes, stream);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(struct _IO_FILE * stream, int32_t off, int32_t whence) {
    // 0x100003edc
    return _fseek(stream, off, whence);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(struct _IO_FILE * stream) {
    // 0x100003ee8
    return _ftell(stream);
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003ef4
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003f00 - 0x100003f0c
int64_t * function_100003f00(int32_t size) {
    // 0x100003f00
    return _malloc(size);
}

// Address range: 0x100003f0c - 0x100003f18
void function_100003f0c(struct _IO_FILE * stream) {
    // 0x100003f0c
    _rewind(stream);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`#include<stdlib.h>
#include<stdio.h>
#include<math.h> /*Optional, but better if included as fabs, labs and abs functions are being used. */

int main(int argC, char* argV[])
{
	
	int i,zeroCount= 0,firstNonZero = -1;
	double* vector;
	
	if(argC == 1){
		printf("Usage : %s <Vector component coefficients seperated by single space>",argV[0]);
	}
	
	else{
		
		printf("Vector for [");
		for(i=1;i<argC;i++){
			printf("%s,",argV[i]);
		}
		printf("\b] -> ");
		
		
		vector = (double*)malloc((argC-1)*sizeof(double));
		
		for(i=1;i<=argC;i++){
			vector[i-1] = atof(argV[i]);
			if(vector[i-1]==0.0)
				zeroCount++;
			if(vector[i-1]!=0.0 && firstNonZero==-1)
				firstNonZero = i-1;
		}

		if(zeroCount == argC){
			printf("0");
		}
		
		else{
			for(i=0;i<argC;i++){
				if(i==firstNonZero && vector[i]==1)
					printf("e%d ",i+1);
				else if(i==firstNonZero && vector[i]==-1)
					printf("- e%d ",i+1);
				else if(i==firstNonZero && vector[i]<0 && fabs(vector[i])-abs(vector[i])>0.0)
					printf("- %lf e%d ",fabs(vector[i]),i+1);
				else if(i==firstNonZero && vector[i]<0 && fabs(vector[i])-abs(vector[i])==0.0)
					printf("- %ld e%d ",labs(vector[i]),i+1);
				else if(i==firstNonZero && vector[i]>0 && fabs(vector[i])-abs(vector[i])>0.0)
					printf("%lf e%d ",vector[i],i+1);
				else if(i==firstNonZero && vector[i]>0 && fabs(vector[i])-abs(vector[i])==0.0)
					printf("%ld e%d ",vector[i],i+1);
				else if(fabs(vector[i])==1.0 && i!=0)
					printf("%c e%d ",(vector[i]==-1)?'-':'+',i+1);
				else if(i!=0 && vector[i]!=0 && fabs(vector[i])-abs(vector[i])>0.0)
					printf("%c %lf e%d ",(vector[i]<0)?'-':'+',fabs(vector[i]),i+1);
				else if(i!=0 && vector[i]!=0 && fabs(vector[i])-abs(vector[i])==0.0)
					printf("%c %ld e%d ",(vector[i]<0)?'-':'+',labs(vector[i]),i+1);				
			}
		}
	}
	
	free(vector);
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003eac(int32_t x);
float64_t function_100003eb8(char * nptr);
void function_100003ec4(int64_t * ptr);
int32_t function_100003ed0(int32_t x);
int64_t * function_100003edc(int32_t size);
int32_t function_100003ee8(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _abs(int32_t a1);
float64_t _atof(char * a1);
void _free(int64_t * a1);
int32_t _labs(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003690 - 0x100003eac
int64_t entry_point(void) {
    // 0x100003690
    int64_t v1; // 0x100003690
    int32_t v2 = v1; // 0x1000036a0
    if (v2 == 1) {
        // 0x1000036c8
        _printf("Usage : %s <Vector component coefficients seperated by single space>", (char *)v1);
        // 0x100003e94
        int64_t v3; // 0x100003690
        _free((int64_t *)v3);
        return 0;
    }
    // 0x1000036e8
    _printf("Vector for [");
    int32_t v4 = 1 - v2;
    if (v4 < 0 != (v4 & v2) < 0) {
        int32_t v5 = 1; // 0x100003740
        _printf("%s,", (char *)v1);
        v5++;
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003718
            _printf("%s,", (char *)v1);
            v5++;
        }
    }
    // 0x10000374c
    _printf("\b] -> ");
    int64_t v6 = (int64_t)_malloc(8 * v2 - 8); // 0x100003774
    int32_t v7 = 1; // 0x100003798
    int128_t v8; // 0x100003690
    int64_t v9 = v8; // 0x100003798
    int32_t v10 = -1; // 0x100003798
    int32_t v11 = 0; // 0x100003798
    if (v4 == 0 || v4 < 0 != (v4 & v2) < 0) {
        int32_t v12 = v10;
        float64_t v13 = _atof((char *)*(int64_t *)(8 * (int64_t)v7 + v1)); // 0x1000037ac
        int64_t v14 = (int64_t)(8 * v7 - 8) + v6; // 0x1000037bc
        float64_t v15; // 0x100003690
        *(int64_t *)v14 = (int64_t)v15;
        float64_t v16 = *(float64_t *)v14; // 0x1000037cc
        v11 += (int32_t)(v16 == 0.0);
        v10 = v12 == -1 == (v16 != 0.0) ? v7 - 1 : v12;
        v7++;
        int32_t v17 = v7 - v2; // 0x100003790
        v15 = v16;
        while (v17 == 0 || v17 < 0 != ((v17 ^ v7) & (v7 ^ v2)) < 0) {
            // 0x1000037a0
            v12 = v10;
            v13 = _atof((char *)*(int64_t *)(8 * (int64_t)v7 + v1));
            v14 = (int64_t)(8 * v7 - 8) + v6;
            *(int64_t *)v14 = (int64_t)v15;
            v16 = *(float64_t *)v14;
            v11 += (int32_t)(v16 == 0.0);
            v10 = v12 == -1 == (v16 != 0.0) ? v7 - 1 : v12;
            v7++;
            v17 = v7 - v2;
            v15 = v16;
        }
        // 0x100003788
        v9 = (float32_t)v13;
    }
    // 0x100003848
    if (v11 == v2) {
        // 0x100003860
        _printf("0");
        // 0x100003e94
        _free((int64_t *)v6);
        return 0;
    }
    int32_t v18 = -v2; // 0x100003880
    if (v18 < 0 == (v18 & v2) < 0) {
        // 0x100003e94
        _free((int64_t *)v6);
        return 0;
    }
    int32_t v19 = v1;
    char v20 = v1;
    float64_t * v21 = (float64_t *)(8 * (int64_t)v10 + v6);
    int32_t v22 = 0; // 0x100003e80
    int32_t v23; // 0x100003690
    while (true) {
      lab_0x100003890:
        // 0x100003890
        v23 = v22;
        if (v23 == v10) {
            float64_t v24 = *v21; // 0x1000038b0
            if (v24 == 1.0) {
                // 0x1000038c8
                _printf("e%d ", v1);
                goto lab_0x100003e7c;
            } else {
                if (v24 == -1.0) {
                    // 0x100003924
                    _printf("- e%d ", v1);
                    goto lab_0x100003e7c;
                } else {
                    if (v24 > 0.0) {
                        float64_t v25 = fabs(v24) - (float64_t)_abs((int32_t)v24); // 0x1000039ac
                        if (v25 == 0.0) {
                            goto lab_0x100003a10;
                        } else {
                            if (v25 > 0.0 == v25 >= 0.0 == v25 <= 0.0) {
                                // 0x1000039c0
                                _printf("- %lf e%d ", (float64_t)v9, v1);
                                goto lab_0x100003e7c;
                            } else {
                                goto lab_0x100003a10;
                            }
                        }
                    } else {
                        goto lab_0x100003a10;
                    }
                }
            }
        } else {
            goto lab_0x100003c04;
        }
    }
  lab_0x100003e94:
    // 0x100003e94
    _free((int64_t *)v6);
    return 0;
  lab_0x100003c04:;
    float64_t * v26 = (float64_t *)(8 * (int64_t)v23 + v6); // 0x100003c0c
    float64_t v27 = *v26; // 0x100003c0c
    float64_t v28 = fabs(v27); // 0x100003c10
    if (v23 == 0 || v28 != 1.0) {
        if (v23 == 0) {
            goto lab_0x100003e7c;
        } else {
            if (v27 == 0.0) {
                goto lab_0x100003d84;
            } else {
                float64_t v29 = v28 - (float64_t)_abs((int32_t)v27); // 0x100003cf4
                if (v29 == 0.0) {
                    goto lab_0x100003d84;
                } else {
                    if (v29 > 0.0 == v29 >= 0.0 == v29 <= 0.0) {
                        // 0x100003d08
                        _printf("%c %lf e%d ", v20, (float64_t)v9, v1);
                        goto lab_0x100003e7c;
                    } else {
                        goto lab_0x100003d84;
                    }
                }
            }
        }
    } else {
        // 0x100003c3c
        _printf("%c e%d ", v20, v1);
        goto lab_0x100003e7c;
    }
  lab_0x100003e7c:
    // 0x100003e7c
    v22 = v23 + 1;
    int32_t v30 = v22 - v2; // 0x100003880
    if (v30 < 0 == ((v30 ^ v22) & (v22 ^ v2)) < 0) {
        // break -> 0x100003e94
        goto lab_0x100003e94;
    }
    goto lab_0x100003890;
  lab_0x100003a10:;
    float64_t v31 = *v21; // 0x100003a18
    float64_t v32 = v31; // 0x100003a1c
    if (v31 > 0.0) {
        float64_t v33 = fabs(v31); // 0x100003a38
        int32_t v34 = _abs((int32_t)v31); // 0x100003a50
        float64_t v35 = *v21;
        v32 = v35;
        if (v33 - (float64_t)v34 == 0.0) {
            // 0x100003a70
            _labs((int32_t)(int64_t)v35);
            _printf("- %ld e%d ", v19, v1);
            goto lab_0x100003e7c;
        } else {
            goto lab_0x100003ac4;
        }
    } else {
        goto lab_0x100003ac4;
    }
  lab_0x100003d84:;
    float64_t v36 = *v26; // 0x100003d8c
    if (v36 != 0.0) {
        // 0x100003d9c
        if (fabs(v36) - (float64_t)_abs((int32_t)v36) == 0.0) {
            // 0x100003de4
            _labs((int32_t)(int64_t)*v26);
            _printf("%c %ld e%d ", v20, (int32_t)v1, v1);
        }
    }
    goto lab_0x100003e7c;
  lab_0x100003ac4:;
    float64_t v37 = v32; // 0x100003ae8
    if (v37 == 0.0) {
        goto lab_0x100003b70;
    } else {
        if (v37 > 0.0 == v37 >= 0.0 == v37 <= 0.0) {
            float64_t v38 = fabs(v37) - (float64_t)_abs((int32_t)v37); // 0x100003b10
            if (v38 == 0.0) {
                goto lab_0x100003b70;
            } else {
                if (v38 > 0.0 == v38 >= 0.0 == v38 <= 0.0) {
                    // 0x100003b24
                    _printf("%lf e%d ", (float64_t)v9, v1);
                    goto lab_0x100003e7c;
                } else {
                    goto lab_0x100003b70;
                }
            }
        } else {
            goto lab_0x100003b70;
        }
    }
  lab_0x100003b70:;
    float64_t v39 = *v21; // 0x100003b78
    if (v39 == 0.0) {
        goto lab_0x100003c04;
    } else {
        if (v39 > 0.0 == v39 >= 0.0 == v39 <= 0.0) {
            // 0x100003b8c
            if (fabs(v39) - (float64_t)_abs((int32_t)v39) == 0.0) {
                // 0x100003bd0
                _printf("%ld e%d ", v19, v1);
                goto lab_0x100003e7c;
            } else {
                goto lab_0x100003c04;
            }
        } else {
            goto lab_0x100003c04;
        }
    }
}

// Address range: 0x100003eac - 0x100003eb8
int32_t function_100003eac(int32_t x) {
    // 0x100003eac
    return _abs(x);
}

// Address range: 0x100003eb8 - 0x100003ec4
float64_t function_100003eb8(char * nptr) {
    // 0x100003eb8
    return _atof(nptr);
}

// Address range: 0x100003ec4 - 0x100003ed0
void function_100003ec4(int64_t * ptr) {
    // 0x100003ec4
    _free(ptr);
}

// Address range: 0x100003ed0 - 0x100003edc
int32_t function_100003ed0(int32_t x) {
    // 0x100003ed0
    return _labs(x);
}

// Address range: 0x100003edc - 0x100003ee8
int64_t * function_100003edc(int32_t size) {
    // 0x100003edc
    return _malloc(size);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * format, ...) {
    // 0x100003ee8
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>

#define N 10000000
#define CS N	/* cache size */

typedef unsigned long ulong;
ulong cache[CS] = {0};

ulong hailstone(ulong n)
{
	int x;
	if (n == 1) return 1;
	if (n < CS && cache[n]) return cache[n];

	x = 1 + hailstone((n & 1) ? 3 * n + 1 : n / 2);
	if (n < CS) cache[n] = x;
	return x;
}

int main()
{
	int i, l, max = 0, mi;
	for (i = 1; i < N; i++) {
		if ((l = hailstone(i)) > max) {
			max = l;
			mi = i;
		}
	}
	printf("max below %d: %d, length %d\n", N, mi, max);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d88(void);
int32_t function_100003f7c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d88 - 0x100003eac
int64_t function_100003d88(void) {
    // 0x100003d88
    int64_t v1; // 0x100003d88
    uint64_t v2 = v1;
    if (v2 == 1) {
        // 0x100003e9c
        return 1;
    }
    if (v2 >= 0x989680) {
        // 0x100003e9c
        return (int32_t)function_100003d88() + 1;
    }
    int64_t * v3 = (int64_t *)(8 * v2 + (int64_t)&g1);
    int64_t v4 = *v3; // 0x100003de0
    int32_t result; // 0x100003d88
    if (v4 == 0) {
        int32_t v5 = (int32_t)function_100003d88() + 1; // 0x100003e58
        *v3 = (int64_t)v5;
        result = v5;
    } else {
        // 0x100003df4
        result = v4;
    }
    // 0x100003e9c
    return result;
}

// Address range: 0x100003eac - 0x100003f7c
int64_t entry_point(void) {
    int32_t v1 = 1;
    function_100003d88();
    int32_t v2 = v1 + 1; // 0x100003f2c
    while (v1 < 0x98967f != (0x98967e - v1 & v2) < 0) {
        // 0x100003ee8
        v1 = v2;
        function_100003d88();
        v2 = v1 + 1;
    }
    // 0x100003f38
    int64_t v3; // 0x100003eac
    _printf("max below %d: %d, length %d\n", v3, v3, v3);
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

// m-th on the reversed kill list; m = 0 is final survivor
int jos(int n, int k, int m) {
	int a;
	for (a = m + 1; a <= n; a++)
		m = (m + k) % a;
	return m;
}

typedef unsigned long long xint;

// same as jos(), useful if n is large and k is not
xint jos_large(xint n, xint k, xint m) {
	if (k <= 1) return n - m - 1;

	xint a = m;
	while (a < n) {
		xint q = (a - m + k - 2) / (k - 1);

		if (a + q > n)	q = n - a;
		else if (!q)	q = 1;

		m = (m + q * k) % (a += q);
	}

	return m;
}

int main(void) {
	xint n, k, i;

	n = 41;
	k = 3;
	printf("n = %llu, k = %llu, final survivor: %d\n", n, k, jos(n, k, 0));

	n = 9876543210987654321ULL;
	k = 12031;
	printf("n = %llu, k = %llu, three survivors:", n, k);

	for (i = 3; i--; )
		printf(" %llu", jos_large(n, k, i));
	putchar('\n');

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c6c(void);
int64_t function_100003ce4(void);
int32_t function_100003f2c(char * format, ...);
int32_t function_100003f38(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c6c - 0x100003ce4
int64_t function_100003c6c(void) {
    // 0x100003c6c
    int64_t v1; // 0x100003c6c
    int32_t v2 = v1; // 0x100003c70
    int32_t result = v1; // 0x100003c78
    int32_t v3 = result + 1;
    int32_t v4 = v3 - v2; // 0x100003c94
    int32_t v5 = v3; // 0x100003c9c
    if (v4 != 0 && v4 < 0 == ((v4 ^ v3) & (v3 ^ v2)) < 0) {
        // 0x100003cd8
        return result;
    }
    int32_t result2 = result; // 0x100003c9c
    result2 = (result2 + (int32_t)v1) % v5;
    v5++;
    int32_t v6 = v5 - v2; // 0x100003c94
    while (v6 == 0 || v6 < 0 != ((v6 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003ca4
        result2 = (result2 + (int32_t)v1) % v5;
        v5++;
        v6 = v5 - v2;
    }
    // 0x100003cd8
    return result2;
}

// Address range: 0x100003ce4 - 0x100003e14
int64_t function_100003ce4(void) {
    // 0x100003ce4
    int64_t v1; // 0x100003ce4
    uint64_t v2 = v1;
    int64_t v3 = v1;
    uint64_t v4 = v1;
    if (v3 != 0 != v3 != 1) {
        // 0x100003e08
        return v4 + -1 - v2;
    }
    if (v4 <= v2) {
        // 0x100003e08
        int64_t result; // 0x100003ce4
        return result;
    }
    uint64_t v5 = v3 - 1; // 0x100003d60
    int64_t v6; // 0x100003ce4
    int64_t v7; // 0x100003ce4
    uint64_t v8 = v3 - 2 + v7 - v6; // 0x100003d58
    uint64_t v9 = v8 / v5; // 0x100003d64
    uint64_t v10 = v9 + v7; // 0x100003d74
    int64_t v11 = v5 > v8 ? 1 : v9;
    int64_t v12 = v10 == v4 | v10 < v4 ? v11 : v4 - v7;
    uint64_t v13 = v12 + v7; // 0x100003de0
    int64_t result2 = (v12 * v3 + v6) % v13;
    while (v4 > v13) {
        // 0x100003d44
        v8 = v3 - 2 + v13 - result2;
        v9 = v8 / v5;
        v10 = v9 + v13;
        v12 = v10 == v4 | v10 < v4 ? v5 > v8 ? 1 : v9 : v4 - v13;
        v13 += v12;
        result2 = (v12 * v3 + result2) % v13;
    }
    // 0x100003e08
    return result2;
}

// Address range: 0x100003e14 - 0x100003f2c
int64_t entry_point(void) {
    // 0x100003e14
    function_100003c6c();
    int64_t v1; // 0x100003e14
    _printf("n = %llu, k = %llu, final survivor: %d\n", 3, 0, v1);
    _printf("n = %llu, k = %llu, three survivors:", 3, 0);
    int64_t v2 = 3; // 0x100003ed4
    v2--;
    function_100003ce4();
    _printf(" %llu", 0x2eff);
    while (v2 != 0) {
        // 0x100003eec
        v2--;
        function_100003ce4();
        _printf(" %llu", 0x2eff);
    }
    // 0x100003f14
    _putchar(10);
    return 0;
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * format, ...) {
    // 0x100003f2c
    return _printf(format);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(int32_t c) {
    // 0x100003f38
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>

int count = 0;
void solve(int n, int col, int *hist)
{
	if (col == n) {
		printf("\nNo. %d\n-----\n", ++count);
		for (int i = 0; i < n; i++, putchar('\n'))
			for (int j = 0; j < n; j++)
				putchar(j == hist[i] ? 'Q' : ((i + j) & 1) ? ' ' : '.');

		return;
	}

#	define attack(i, j) (hist[j] == i || abs(hist[j] - i) == col - j)
	for (int i = 0, j = 0; i < n; i++) {
		for (j = 0; j < col && !attack(i, j); j++);
		if (j < col) continue;

		hist[col] = i;
		solve(n, col + 1, hist);
	}
}

int main(int n, char **argv)
{
	if (n <= 1 || (n = atoi(argv[1])) <= 0) n = 8;
	int hist[n];
	solve(n, 0, hist);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c00(void);
int64_t function_100003ef8(void);
int64_t function_100003f5c(int64_t a1);
int32_t function_100003f68(int32_t x);
int32_t function_100003f74(char * nptr);
int32_t function_100003f80(char * format, ...);
int32_t function_100003f8c(int32_t c);

// --------------------- Global Variables ---------------------

int32_t g1 = -0x1120531; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _abs(int32_t a1);
int32_t _atoi(char * a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c00 - 0x100003e68
int64_t function_100003c00(void) {
    // 0x100003c00
    int64_t v1; // 0x100003c00
    int32_t v2 = v1; // 0x100003c0c
    int32_t v3 = v1; // 0x100003c10
    if (v3 == v2) {
        // 0x100003c30
        g1++;
        int32_t v4 = -v2;
        int32_t result = _printf("\nNo. %d\n-----\n", v1); // 0x100003c70
        if (v4 < 0 != (v4 & v2) < 0) {
            int32_t v5 = 0;
            int32_t v6 = 0;
            int32_t v7 = 81; // 0x100003cb0
            if (v6 != *(int32_t *)(4 * (int64_t)v5 + v1)) {
                // 0x100003cc4
                v7 = (v6 + v5) % 2 == 0 ? 46 : 32;
            }
            // 0x100003cf4
            _putchar(v7);
            int32_t v8 = v6 + 1; // 0x100003d04
            while (v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
                // 0x100003c98
                v6 = v8;
                v7 = 81;
                if (v6 != *(int32_t *)(4 * (int64_t)v5 + v1)) {
                    // 0x100003cc4
                    v7 = (v6 + v5) % 2 == 0 ? 46 : 32;
                }
                // 0x100003cf4
                _putchar(v7);
                v8 = v6 + 1;
            }
            int32_t v9 = v5 + 1; // 0x100003d18
            int32_t v10 = v9 - v2; // 0x100003c68
            int32_t v11 = v9; // 0x100003c70
            result = _putchar(10);
            while (v10 < 0 != ((v10 ^ v9) & (v9 ^ v2)) < 0) {
                // 0x100003c98
                v5 = v11;
                v6 = 0;
                v7 = 81;
                if (v6 != *(int32_t *)(4 * (int64_t)v5 + v1)) {
                    // 0x100003cc4
                    v7 = (v6 + v5) % 2 == 0 ? 46 : 32;
                }
                // 0x100003cf4
                _putchar(v7);
                v8 = v6 + 1;
                while (v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
                    // 0x100003c98
                    v6 = v8;
                    v7 = 81;
                    if (v6 != *(int32_t *)(4 * (int64_t)v5 + v1)) {
                        // 0x100003cc4
                        v7 = (v6 + v5) % 2 == 0 ? 46 : 32;
                    }
                    // 0x100003cf4
                    _putchar(v7);
                    v8 = v6 + 1;
                }
                // 0x100003d14
                v9 = v5 + 1;
                v10 = v9 - v2;
                v11 = v9;
                result = _putchar(10);
            }
        }
        // 0x100003e5c
        return result;
    }
    int32_t v12 = -v2; // 0x100003d44
    if (v12 < 0 == (v12 & v2) < 0) {
        // 0x100003e5c
        int64_t result2; // 0x100003c00
        return result2;
    }
    int32_t v13 = -v3; // 0x100003d64
    int32_t v14 = 0;
    int32_t v15; // 0x100003c00
    int32_t v16; // 0x100003c00
    int32_t v17; // 0x100003c00
    int32_t v18; // 0x100003d84
    int32_t v19; // 0x100003db8
    int64_t v20; // 0x100003db8
    int32_t v21; // 0x100003dfc
    int32_t v22; // 0x100003d64
    int32_t v23; // 0x100003d84
    int64_t v24; // 0x100003c00
    int64_t result3; // 0x100003c00
    if (v13 < 0 == (v13 & v3) < 0) {
        // 0x100003e24
        *(int32_t *)((0x100000000 * v1 >> 30) + v1) = v14;
        result3 = function_100003c00();
    } else {
        // 0x100003d7c
        v18 = *(int32_t *)v1;
        v15 = v18;
        result3 = v24;
        if (v18 != v14) {
            v17 = 0;
            v19 = _abs(v15 - v14);
            v20 = v19;
            result3 = v20;
            while (v19 != v3 - v17) {
                // 0x100003d5c
                v21 = v17 + 1;
                v22 = v21 - v3;
                if (v22 < 0 == ((v22 ^ v21) & (v21 ^ v3)) < 0) {
                    goto lab_0x100003e24;
                }
                // 0x100003d7c
                v23 = *(int32_t *)(4 * (int64_t)v21 + v1);
                v15 = v23;
                v16 = v21;
                result3 = v20;
                if (v23 == v14) {
                    // break -> 0x100003e4c
                    break;
                }
                v17 = v16;
                v19 = _abs(v15 - v14);
                v20 = v19;
                result3 = v20;
            }
        }
    }
    int32_t v25 = v14 + 1; // 0x100003e50
    int32_t v26 = v25 - v2; // 0x100003d44
    v24 = result3;
    while (v26 < 0 != ((v26 ^ v25) & (v25 ^ v2)) < 0) {
        // 0x100003d5c
        v14 = v25;
        if (v13 < 0 == (v13 & v3) < 0) {
            // 0x100003e24
            *(int32_t *)((0x100000000 * v1 >> 30) + v1) = v14;
            result3 = function_100003c00();
        } else {
            // 0x100003d7c
            v18 = *(int32_t *)v1;
            v15 = v18;
            result3 = v24;
            if (v18 != v14) {
                v17 = 0;
                v19 = _abs(v15 - v14);
                v20 = v19;
                result3 = v20;
                while (v19 != v3 - v17) {
                    // 0x100003d5c
                    v21 = v17 + 1;
                    v22 = v21 - v3;
                    if (v22 < 0 == ((v22 ^ v21) & (v21 ^ v3)) < 0) {
                        goto lab_0x100003e24;
                    }
                    // 0x100003d7c
                    v23 = *(int32_t *)(4 * (int64_t)v21 + v1);
                    v15 = v23;
                    v16 = v21;
                    result3 = v20;
                    if (v23 == v14) {
                        // break -> 0x100003e4c
                        break;
                    }
                    v17 = v16;
                    v19 = _abs(v15 - v14);
                    v20 = v19;
                    result3 = v20;
                }
            }
        }
        // 0x100003e4c
        v25 = v14 + 1;
        v26 = v25 - v2;
        v24 = result3;
    }
    // 0x100003e5c
    return result3;
}

// Address range: 0x100003e68 - 0x100003ef8
int64_t entry_point(void) {
    // 0x100003e68
    int64_t v1; // 0x100003e68
    int32_t v2 = v1; // 0x100003e88
    int32_t v3 = v2 - 1; // 0x100003e94
    if (v3 != 0 && v3 < 0 == (v2 & -v2) < 0) {
        // 0x100003ea4
        _atoi((char *)*(int64_t *)(v1 + 8));
    }
    // 0x100003ed0
    return ___chkstk_darwin();
}

// Address range: 0x100003ef8 - 0x100003f5c
int64_t function_100003ef8(void) {
    int64_t v1 = function_100003c00(); // 0x100003f14
    int64_t v2; // 0x100003ef8
    int32_t v3 = *(int32_t *)(v2 - 12); // 0x100003f20
    int32_t * v4 = (int32_t *)(v2 - 44); // 0x100003f24
    *v4 = v3;
    int32_t result = v3; // 0x100003f40
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003f48
        ___stack_chk_fail(v1);
        result = *v4;
    }
    // 0x100003f4c
    return result;
}

// Address range: 0x100003f5c - 0x100003f68
int64_t function_100003f5c(int64_t a1) {
    // 0x100003f5c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(int32_t x) {
    // 0x100003f68
    return _abs(x);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * nptr) {
    // 0x100003f74
    return _atoi(nptr);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * format, ...) {
    // 0x100003f80
    return _printf(format);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(int32_t c) {
    // 0x100003f8c
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
int main (int argc, char *argv[]) {
//here we check arguments
	if (argc < 2) {
        printf("Enter an argument. Example 1234 or dcba:\n");
        return 0;
	}
//it calculates an array's length
        int x;
        for (x = 0; argv[1][x] != '\0'; x++);
//buble sort the array
	int f, v, m;
	 for(f=0; f < x; f++) {
    	 for(v = x-1; v > f; v-- ) {
     	 if (argv[1][v-1] > argv[1][v]) {
	m=argv[1][v-1];
	argv[1][v-1]=argv[1][v];
	argv[1][v]=m;
    }
  }
}

//it calculates a factorial to stop the algorithm
    char a[x];
	int k=0;
	int fact=k+1;
             while (k!=x) {
                   a[k]=argv[1][k];
               	   k++;
		  fact = k*fact;
                   }
                   a[k]='\0';
//Main part: here we permutate
           int i, j;
           int y=0;
           char c;
          while (y != fact) {
          printf("%s\n", a);
          i=x-2;
          while(a[i] > a[i+1] ) i--;
          j=x-1;
          while(a[j] < a[i] ) j--;
      c=a[j];
      a[j]=a[i];
      a[i]=c;
i++;
for (j = x-1; j > i; i++, j--) {
  c = a[i];
  a[i] = a[j];
  a[j] = c;
      }
y++;
   }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cc0(void);
int64_t function_100003f24(int64_t a1);
int64_t function_100003f60(void);
int32_t function_100003f6c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b0c - 0x100003cc0
int64_t entry_point(void) {
    // 0x100003b0c
    int64_t v1; // 0x100003b0c
    int32_t v2 = v1; // 0x100003b2c
    if (v2 < 2 != (1 - v2 & v2) < 0) {
        // 0x100003b48
        return function_100003f24((int64_t)_printf("Enter an argument. Example 1234 or dcba:\n"));
    }
    int64_t * v3 = (int64_t *)(v1 + 8);
    int32_t v4 = 0;
    while (*(char *)(*v3 + (int64_t)v4) != 0) {
        // 0x100003b64
        v4++;
    }
    int32_t v5 = -v4; // 0x100003ba8
    if (v5 < 0 == (v4 & v5) < 0) {
        // 0x100003c98
        return ___chkstk_darwin();
    }
    int32_t v6 = v4 - 1;
    int32_t v7 = 0;
    int32_t v8 = v6 - v7; // 0x100003bd0
    int32_t v9; // 0x100003b0c
    int32_t v10; // 0x100003b0c
    int32_t v11; // 0x100003b0c
    int64_t v12; // 0x100003be4
    int32_t v13; // 0x100003bec
    char v14; // 0x100003bf0
    int32_t v15; // 0x100003bf0
    int64_t v16; // 0x100003bfc
    char v17; // 0x100003c00
    int32_t v18; // 0x100003c04
    int32_t v19; // 0x100003bd0
    if (v8 != 0 && v8 < 0 == ((v8 ^ v6) & (v7 ^ v6)) < 0) {
        v12 = *v3;
        v13 = v4 - 2;
        v14 = *(char *)(v12 + (int64_t)v13);
        v15 = v14;
        v16 = v6;
        v17 = *(char *)(v12 + v16);
        v18 = v15 - (int32_t)v17;
        if (v18 != 0 && v18 < 0 == ((v18 ^ v15) & (int32_t)(v17 ^ v14)) < 0) {
            // 0x100003c14
            *(char *)(v12 + (int64_t)v13) = v17;
            *(char *)(*v3 + v16) = v14;
        }
        // 0x100003c74
        v9 = v6 - 1;
        v19 = v9 - v7;
        v11 = v6;
        while (v19 != 0 && v19 < 0 == ((v19 ^ v9) & (v9 ^ v7)) < 0) {
            // 0x100003be0
            v10 = v9;
            v12 = *v3;
            v13 = v11 - 2;
            v14 = *(char *)(v12 + (int64_t)v13);
            v15 = v14;
            v16 = v10;
            v17 = *(char *)(v12 + v16);
            v18 = v15 - (int32_t)v17;
            if (v18 != 0 && v18 < 0 == ((v18 ^ v15) & (int32_t)(v17 ^ v14)) < 0) {
                // 0x100003c14
                *(char *)(v12 + (int64_t)v13) = v17;
                *(char *)(*v3 + v16) = v14;
            }
            // 0x100003c74
            v9 = v10 - 1;
            v19 = v9 - v7;
            v11 = v10;
        }
    }
    int32_t v20 = v7 + 1; // 0x100003c8c
    while (v20 - v4 < 0 != ((v20 - v4 ^ v20) & (v20 ^ v4)) < 0) {
        // 0x100003bc8
        v7 = v20;
        v8 = v6 - v7;
        if (v8 != 0 && v8 < 0 == ((v8 ^ v6) & (v7 ^ v6)) < 0) {
            v12 = *v3;
            v13 = v4 - 2;
            v14 = *(char *)(v12 + (int64_t)v13);
            v15 = v14;
            v16 = v6;
            v17 = *(char *)(v12 + v16);
            v18 = v15 - (int32_t)v17;
            if (v18 != 0 && v18 < 0 == ((v18 ^ v15) & (int32_t)(v17 ^ v14)) < 0) {
                // 0x100003c14
                *(char *)(v12 + (int64_t)v13) = v17;
                *(char *)(*v3 + v16) = v14;
            }
            // 0x100003c74
            v9 = v6 - 1;
            v19 = v9 - v7;
            v11 = v6;
            while (v19 != 0 && v19 < 0 == ((v19 ^ v9) & (v9 ^ v7)) < 0) {
                // 0x100003be0
                v10 = v9;
                v12 = *v3;
                v13 = v11 - 2;
                v14 = *(char *)(v12 + (int64_t)v13);
                v15 = v14;
                v16 = v10;
                v17 = *(char *)(v12 + v16);
                v18 = v15 - (int32_t)v17;
                if (v18 != 0 && v18 < 0 == ((v18 ^ v15) & (int32_t)(v17 ^ v14)) < 0) {
                    // 0x100003c14
                    *(char *)(v12 + (int64_t)v13) = v17;
                    *(char *)(*v3 + v16) = v14;
                }
                // 0x100003c74
                v9 = v10 - 1;
                v19 = v9 - v7;
                v11 = v10;
            }
        }
        // 0x100003c88
        v20 = v7 + 1;
    }
    // 0x100003c98
    return ___chkstk_darwin();
}

// Address range: 0x100003cc0 - 0x100003f24
int64_t function_100003cc0(void) {
    // 0x100003cc0
    int64_t v1; // 0x100003cc0
    int64_t v2; // 0x100003cc0
    int64_t v3 = (int64_t)&v1 - *(int64_t *)(v2 - 96); // 0x100003cc8
    int64_t * v4 = (int64_t *)(v2 - 88); // 0x100003cd0
    *v4 = v3;
    int32_t * v5 = (int32_t *)(v2 - 60); // 0x100003cd8
    *v5 = 0;
    int32_t * v6 = (int32_t *)(v2 - 64); // 0x100003ce4
    *v6 = 1;
    int32_t v7 = *v5; // 0x100003cec
    int32_t * v8 = (int32_t *)(v2 - 28); // 0x100003cf0
    int64_t v9 = *v4;
    int32_t v10 = v7; // 0x100003cfc
    int64_t v11 = v9; // 0x100003cfc
    if (v7 != *v8) {
        int64_t v12 = v7; // 0x100003d10
        char v13 = *(char *)(*(int64_t *)(*(int64_t *)(v2 - 24) + 8) + v12); // 0x100003d18
        *(char *)(v9 + v12) = v13;
        int32_t v14 = *v5 + 1; // 0x100003d2c
        *v5 = v14;
        *v6 = *v6 * v14;
        int32_t v15 = *v5; // 0x100003cec
        int64_t v16 = *v4;
        v10 = v15;
        v11 = v16;
        while (v15 != *v8) {
            // 0x100003d04
            v12 = v15;
            v13 = *(char *)(*(int64_t *)(*(int64_t *)(v2 - 24) + 8) + v12);
            *(char *)(v16 + v12) = v13;
            v14 = *v5 + 1;
            *v5 = v14;
            *v6 = *v6 * v14;
            v15 = *v5;
            v16 = *v4;
            v10 = v15;
            v11 = v16;
        }
    }
    // 0x100003d48
    *(char *)(v11 + (int64_t)v10) = 0;
    int32_t * v17 = (int32_t *)(v2 - 76); // 0x100003d58
    *v17 = 0;
    if (*v6 == 0) {
        // 0x100003f18
        int64_t v18; // 0x100003cc0
        return function_100003f24(v18);
    }
    int32_t * v19 = (int32_t *)(v2 - 68);
    int32_t * v20 = (int32_t *)(v2 - 72);
    char * v21 = (char *)(v2 - 77);
    *(int64_t *)(v3 - 16) = *v4;
    int32_t v22 = _printf("%s\n", (char *)v2); // 0x100003d90
    int32_t v23 = *v8 - 2; // 0x100003da4
    *v19 = v23;
    int64_t v24 = *v4; // 0x100003da8
    char v25 = *(char *)(v24 + (int64_t)v23); // 0x100003db0
    int32_t v26 = v25; // 0x100003db0
    char v27 = *(char *)(v24 + (int64_t)(v23 + 1)); // 0x100003dbc
    int32_t v28 = v26 - (int32_t)v27; // 0x100003dc0
    v23--;
    while (v28 != 0 && v28 < 0 == ((v28 ^ v26) & (int32_t)(v27 ^ v25)) < 0) {
        // 0x100003da8
        *v19 = v23;
        v24 = *v4;
        v25 = *(char *)(v24 + (int64_t)v23);
        v26 = v25;
        v27 = *(char *)(v24 + (int64_t)(v23 + 1));
        v28 = v26 - (int32_t)v27;
        v23--;
    }
    int32_t v29 = *v8; // 0x100003dec
    v29--;
    *v20 = v29;
    int64_t v30 = *v4; // 0x100003df0
    char v31 = *(char *)(v30 + (int64_t)v29); // 0x100003df8
    int32_t v32 = v31; // 0x100003df8
    char v33 = *(char *)(v30 + (int64_t)*v19); // 0x100003e00
    while (v32 - (int32_t)v33 < 0 != ((v32 - (int32_t)v33 ^ v32) & (int32_t)(v33 ^ v31)) < 0) {
        // 0x100003df0
        v29--;
        *v20 = v29;
        v30 = *v4;
        v31 = *(char *)(v30 + (int64_t)v29);
        v32 = v31;
        v33 = *(char *)(v30 + (int64_t)*v19);
    }
    // 0x100003e24
    *v21 = v31;
    char v34 = *(char *)(v30 + (int64_t)*v19); // 0x100003e48
    *(char *)(v30 + (int64_t)*v20) = v34;
    *(char *)(v30 + (int64_t)*v19) = *v21;
    *v19 = *v19 + 1;
    int32_t v35 = *v8 - 1;
    *v20 = v35;
    int32_t v36 = *v19; // 0x100003e8c
    int64_t v37; // 0x100003ea0
    char v38; // 0x100003ec4
    while (v35 - v36 != 0 && v35 - v36 < 0 == ((v35 - v36 ^ v35) & (v36 ^ v35)) < 0) {
        // 0x100003ea0
        v37 = *v4;
        *v21 = *(char *)(v37 + (int64_t)v36);
        v38 = *(char *)(v37 + (int64_t)*v20);
        *(char *)(v37 + (int64_t)*v19) = v38;
        *(char *)(v37 + (int64_t)*v20) = *v21;
        *v19 = *v19 + 1;
        v35 = *v20 - 1;
        *v20 = v35;
        v36 = *v19;
    }
    int32_t v39 = *v17 + 1; // 0x100003f0c
    *v17 = v39;
    while (v39 != *v6) {
        // 0x100003d78
        *(int64_t *)(v3 - 16) = *v4;
        v22 = _printf("%s\n", (char *)v2);
        v23 = *v8 - 2;
        *v19 = v23;
        v24 = *v4;
        v25 = *(char *)(v24 + (int64_t)v23);
        v26 = v25;
        v27 = *(char *)(v24 + (int64_t)(v23 + 1));
        v28 = v26 - (int32_t)v27;
        v23--;
        while (v28 != 0 && v28 < 0 == ((v28 ^ v26) & (int32_t)(v27 ^ v25)) < 0) {
            // 0x100003da8
            *v19 = v23;
            v24 = *v4;
            v25 = *(char *)(v24 + (int64_t)v23);
            v26 = v25;
            v27 = *(char *)(v24 + (int64_t)(v23 + 1));
            v28 = v26 - (int32_t)v27;
            v23--;
        }
        // 0x100003de0
        v29 = *v8;
        v29--;
        *v20 = v29;
        v30 = *v4;
        v31 = *(char *)(v30 + (int64_t)v29);
        v32 = v31;
        v33 = *(char *)(v30 + (int64_t)*v19);
        while (v32 - (int32_t)v33 < 0 != ((v32 - (int32_t)v33 ^ v32) & (int32_t)(v33 ^ v31)) < 0) {
            // 0x100003df0
            v29--;
            *v20 = v29;
            v30 = *v4;
            v31 = *(char *)(v30 + (int64_t)v29);
            v32 = v31;
            v33 = *(char *)(v30 + (int64_t)*v19);
        }
        // 0x100003e24
        *v21 = v31;
        v34 = *(char *)(v30 + (int64_t)*v19);
        *(char *)(v30 + (int64_t)*v20) = v34;
        *(char *)(v30 + (int64_t)*v19) = *v21;
        *v19 = *v19 + 1;
        v35 = *v8 - 1;
        *v20 = v35;
        v36 = *v19;
        while (v35 - v36 != 0 && v35 - v36 < 0 == ((v35 - v36 ^ v35) & (v36 ^ v35)) < 0) {
            // 0x100003ea0
            v37 = *v4;
            *v21 = *(char *)(v37 + (int64_t)v36);
            v38 = *(char *)(v37 + (int64_t)*v20);
            *(char *)(v37 + (int64_t)*v19) = v38;
            *(char *)(v37 + (int64_t)*v20) = *v21;
            *v19 = *v19 + 1;
            v35 = *v20 - 1;
            *v20 = v35;
            v36 = *v19;
        }
        // 0x100003f08
        v39 = *v17 + 1;
        *v17 = v39;
    }
    // 0x100003f18
    return function_100003f24((int64_t)v22);
}

// Address range: 0x100003f24 - 0x100003f60
int64_t function_100003f24(int64_t a1) {
    // 0x100003f24
    int64_t v1; // 0x100003f24
    int32_t v2 = *(int32_t *)(v1 - 12); // 0x100003f24
    int32_t * v3 = (int32_t *)(v1 - 100); // 0x100003f28
    *v3 = v2;
    int32_t result = v2; // 0x100003f44
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v1 - 8)) {
        // 0x100003f4c
        ___stack_chk_fail();
        result = *v3;
    }
    // 0x100003f50
    return result;
}

// Address range: 0x100003f60 - 0x100003f6c
int64_t function_100003f60(void) {
    // 0x100003f60
    return ___stack_chk_fail();
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>

int dot_product(int *, int *, size_t);

int
main(void)
{
        int a[3] = {1, 3, -5};
        int b[3] = {4, -2, -1};

        printf("%d\n", dot_product(a, b, sizeof(a) / sizeof(a[0])));

        return EXIT_SUCCESS;
}

int
dot_product(int *a, int *b, size_t n)
{
        int sum = 0;
        size_t i;

        for (i = 0; i < n; i++) {
                sum += a[i] * b[i];
        }

        return sum;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ef0(void);
int64_t function_100003f6c(int64_t a1);
int32_t function_100003f78(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = -0x1fffffffc; // 0x100003f90

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e44 - 0x100003ef0
int64_t entry_point(void) {
    int64_t v1 = g1; // bp-56, 0x100003e90
    function_100003ef0();
    int32_t v2 = _printf("%d\n", (int64_t)&v1); // 0x100003eb8
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ec8
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003edc
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003ee0
    return 0;
}

// Address range: 0x100003ef0 - 0x100003f6c
int64_t function_100003ef0(void) {
    int64_t v1 = 0; // 0x100003f1c
    int64_t v2; // 0x100003ef0
    if (v2 == 0) {
        // 0x100003f60
        return 0;
    }
    int32_t result = 0; // 0x100003f1c
    int64_t v3 = 4 * v1; // 0x100003f2c
    result += *(int32_t *)(v3 + v2) * *(int32_t *)(v3 + v2);
    v1++;
    while (v1 != v2) {
        // 0x100003f24
        v3 = 4 * v1;
        result += *(int32_t *)(v3 + v2) * *(int32_t *)(v3 + v2);
        v1++;
    }
    // 0x100003f60
    return result;
}

// Address range: 0x100003f6c - 0x100003f78
int64_t function_100003f6c(int64_t a1) {
    // 0x100003f6c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>

#define MAX_BRIGHTNESS 255

// C99 doesn't define M_PI (GNU-C99 does)
#define M_PI 3.14159265358979323846264338327

/*
 * Loading part taken from
 * http://www.vbforums.com/showthread.php?t=261522
 * BMP info:
 * http://en.wikipedia.org/wiki/BMP_file_format
 *
 * Note: the magic number has been removed from the bmpfile_header_t
 * structure since it causes alignment problems
 *     bmpfile_magic_t should be written/read first
 * followed by the
 *     bmpfile_header_t
 * [this avoids compiler-specific alignment pragmas etc.]
 */

typedef struct {
    uint8_t magic[2];
} bmpfile_magic_t;

typedef struct {
    uint32_t filesz;
    uint16_t creator1;
    uint16_t creator2;
    uint32_t bmp_offset;
} bmpfile_header_t;

typedef struct {
    uint32_t header_sz;
    int32_t  width;
    int32_t  height;
    uint16_t nplanes;
    uint16_t bitspp;
    uint32_t compress_type;
    uint32_t bmp_bytesz;
    int32_t  hres;
    int32_t  vres;
    uint32_t ncolors;
    uint32_t nimpcolors;
} bitmap_info_header_t;

typedef struct {
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t nothing;
} rgb_t;

// Use short int instead unsigned char' so that we can
// store negative values.
typedef short int pixel_t;

pixel_t *load_bmp(const char *filename,
                  bitmap_info_header_t *bitmapInfoHeader)
{
    FILE *filePtr = fopen(filename, "rb");
    if (filePtr == NULL) {
        perror("fopen()");
        return NULL;
    }

    bmpfile_magic_t mag;
    if (fread(&mag, sizeof(bmpfile_magic_t), 1, filePtr) != 1) {
        fclose(filePtr);
        return NULL;
    }

    // verify that this is a bmp file by check bitmap id
    // warning: dereferencing type-punned pointer will break
    // strict-aliasing rules [-Wstrict-aliasing]
    if (*((uint16_t*)mag.magic) != 0x4D42) {
        fprintf(stderr, "Not a BMP file: magic=%c%c\n",
                mag.magic[0], mag.magic[1]);
        fclose(filePtr);
        return NULL;
    }

    bmpfile_header_t bitmapFileHeader; // our bitmap file header
    // read the bitmap file header
    if (fread(&bitmapFileHeader, sizeof(bmpfile_header_t),
              1, filePtr) != 1) {
        fclose(filePtr);
        return NULL;
    }

    // read the bitmap info header
    if (fread(bitmapInfoHeader, sizeof(bitmap_info_header_t),
              1, filePtr) != 1) {
        fclose(filePtr);
        return NULL;
    }

    if (bitmapInfoHeader->compress_type != 0)
        fprintf(stderr, "Warning, compression is not supported.\n");

    // move file point to the beginning of bitmap data
    if (fseek(filePtr, bitmapFileHeader.bmp_offset, SEEK_SET)) {
        fclose(filePtr);
        return NULL;
    }

    // allocate enough memory for the bitmap image data
    pixel_t *bitmapImage = malloc(bitmapInfoHeader->bmp_bytesz *
                                  sizeof(pixel_t));

    // verify memory allocation
    if (bitmapImage == NULL) {
        fclose(filePtr);
        return NULL;
    }

    // read in the bitmap image data
    size_t pad, count=0;
    unsigned char c;
    pad = 4*ceil(bitmapInfoHeader->bitspp*bitmapInfoHeader->width/32.) - bitmapInfoHeader->width;
    for(size_t i=0; i<bitmapInfoHeader->height; i++){
	    for(size_t j=0; j<bitmapInfoHeader->width; j++){
		    if (fread(&c, sizeof(unsigned char), 1, filePtr) != 1) {
			    fclose(filePtr);
			    return NULL;
		    }
		    bitmapImage[count++] = (pixel_t) c;
	    }
	    fseek(filePtr, pad, SEEK_CUR);
    }

    // If we were using unsigned char as pixel_t, then:
    // fread(bitmapImage, 1, bitmapInfoHeader->bmp_bytesz, filePtr);

    // close file and return bitmap image data
    fclose(filePtr);
    return bitmapImage;
}

// Return: true on error.
bool save_bmp(const char *filename, const bitmap_info_header_t *bmp_ih,
              const pixel_t *data)
{
    FILE* filePtr = fopen(filename, "wb");
    if (filePtr == NULL)
        return true;

    bmpfile_magic_t mag = {{0x42, 0x4d}};
    if (fwrite(&mag, sizeof(bmpfile_magic_t), 1, filePtr) != 1) {
        fclose(filePtr);
        return true;
    }

    const uint32_t offset = sizeof(bmpfile_magic_t) +
                            sizeof(bmpfile_header_t) +
                            sizeof(bitmap_info_header_t) +
                            ((1U << bmp_ih->bitspp) * 4);

    const bmpfile_header_t bmp_fh = {
        .filesz = offset + bmp_ih->bmp_bytesz,
        .creator1 = 0,
        .creator2 = 0,
        .bmp_offset = offset
    };

    if (fwrite(&bmp_fh, sizeof(bmpfile_header_t), 1, filePtr) != 1) {
        fclose(filePtr);
        return true;
    }
    if (fwrite(bmp_ih, sizeof(bitmap_info_header_t), 1, filePtr) != 1) {
        fclose(filePtr);
        return true;
    }

    // Palette
    for (size_t i = 0; i < (1U << bmp_ih->bitspp); i++) {
        const rgb_t color = {(uint8_t)i, (uint8_t)i, (uint8_t)i};
        if (fwrite(&color, sizeof(rgb_t), 1, filePtr) != 1) {
            fclose(filePtr);
            return true;
        }
    }

    // We use int instead of uchar, so we can't write img
    // in 1 call any more.
    // fwrite(data, 1, bmp_ih->bmp_bytesz, filePtr);

    // Padding: http://en.wikipedia.org/wiki/BMP_file_format#Pixel_storage
    size_t pad = 4*ceil(bmp_ih->bitspp*bmp_ih->width/32.) - bmp_ih->width;
    unsigned char c;
    for(size_t i=0; i < bmp_ih->height; i++) {
	    for(size_t j=0; j < bmp_ih->width; j++) {
		    c = (unsigned char) data[j + bmp_ih->width*i];
		    if (fwrite(&c, sizeof(char), 1, filePtr) != 1) {
			    fclose(filePtr);
			    return true;
		    }
	    }
	    c = 0;
	    for(size_t j=0; j<pad; j++)
		    if (fwrite(&c, sizeof(char), 1, filePtr) != 1) {
			    fclose(filePtr);
			    return true;
		    }
    }

    fclose(filePtr);
    return false;
}

// if normalize is true, map pixels to range 0..MAX_BRIGHTNESS
void convolution(const pixel_t *in, pixel_t *out, const float *kernel,
                 const int nx, const int ny, const int kn,
                 const bool normalize)
{
    assert(kn % 2 == 1);
    assert(nx > kn && ny > kn);
    const int khalf = kn / 2;
    float min = FLT_MAX, max = -FLT_MAX;

    if (normalize)
        for (int m = khalf; m < nx - khalf; m++)
            for (int n = khalf; n < ny - khalf; n++) {
                float pixel = 0.0;
                size_t c = 0;
                for (int j = -khalf; j <= khalf; j++)
                    for (int i = -khalf; i <= khalf; i++) {
                        pixel += in[(n - j) * nx + m - i] * kernel[c];
                        c++;
                    }
                if (pixel < min)
                    min = pixel;
                if (pixel > max)
                    max = pixel;
                }

    for (int m = khalf; m < nx - khalf; m++)
        for (int n = khalf; n < ny - khalf; n++) {
            float pixel = 0.0;
            size_t c = 0;
            for (int j = -khalf; j <= khalf; j++)
                for (int i = -khalf; i <= khalf; i++) {
                    pixel += in[(n - j) * nx + m - i] * kernel[c];
                    c++;
                }

            if (normalize)
                pixel = MAX_BRIGHTNESS * (pixel - min) / (max - min);
            out[n * nx + m] = (pixel_t)pixel;
        }
}

/*
 * gaussianFilter:
 * http://www.songho.ca/dsp/cannyedge/cannyedge.html
 * determine size of kernel (odd #)
 * 0.0 <= sigma < 0.5 : 3
 * 0.5 <= sigma < 1.0 : 5
 * 1.0 <= sigma < 1.5 : 7
 * 1.5 <= sigma < 2.0 : 9
 * 2.0 <= sigma < 2.5 : 11
 * 2.5 <= sigma < 3.0 : 13 ...
 * kernelSize = 2 * int(2*sigma) + 3;
 */
void gaussian_filter(const pixel_t *in, pixel_t *out,
                     const int nx, const int ny, const float sigma)
{
    const int n = 2 * (int)(2 * sigma) + 3;
    const float mean = (float)floor(n / 2.0);
    float kernel[n * n]; // variable length array

    fprintf(stderr, "gaussian_filter: kernel size %d, sigma=%g\n",
            n, sigma);
    size_t c = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            kernel[c] = exp(-0.5 * (pow((i - mean) / sigma, 2.0) +
                                    pow((j - mean) / sigma, 2.0)))
                        / (2 * M_PI * sigma * sigma);
            c++;
        }

    convolution(in, out, kernel, nx, ny, n, true);
}

/*
 * Links:
 * http://en.wikipedia.org/wiki/Canny_edge_detector
 * http://www.tomgibara.com/computer-vision/CannyEdgeDetector.java
 * http://fourier.eng.hmc.edu/e161/lectures/canny/node1.html
 * http://www.songho.ca/dsp/cannyedge/cannyedge.html
 *
 * Note: T1 and T2 are lower and upper thresholds.
 */
pixel_t *canny_edge_detection(const pixel_t *in,
                              const bitmap_info_header_t *bmp_ih,
                              const int tmin, const int tmax,
                              const float sigma)
{
    const int nx = bmp_ih->width;
    const int ny = bmp_ih->height;

    pixel_t *G = calloc(nx * ny * sizeof(pixel_t), 1);
    pixel_t *after_Gx = calloc(nx * ny * sizeof(pixel_t), 1);
    pixel_t *after_Gy = calloc(nx * ny * sizeof(pixel_t), 1);
    pixel_t *nms = calloc(nx * ny * sizeof(pixel_t), 1);
    pixel_t *out = malloc(bmp_ih->bmp_bytesz * sizeof(pixel_t));

    if (G == NULL || after_Gx == NULL || after_Gy == NULL ||
        nms == NULL || out == NULL) {
        fprintf(stderr, "canny_edge_detection:"
                " Failed memory allocation(s).\n");
        exit(1);
    }

    gaussian_filter(in, out, nx, ny, sigma);

    const float Gx[] = {-1, 0, 1,
                        -2, 0, 2,
                        -1, 0, 1};

    convolution(out, after_Gx, Gx, nx, ny, 3, false);

    const float Gy[] = { 1, 2, 1,
                         0, 0, 0,
                        -1,-2,-1};

    convolution(out, after_Gy, Gy, nx, ny, 3, false);

    for (int i = 1; i < nx - 1; i++)
        for (int j = 1; j < ny - 1; j++) {
            const int c = i + nx * j;
            // G[c] = abs(after_Gx[c]) + abs(after_Gy[c]);
            G[c] = (pixel_t)hypot(after_Gx[c], after_Gy[c]);
        }

    // Non-maximum suppression, straightforward implementation.
    for (int i = 1; i < nx - 1; i++)
        for (int j = 1; j < ny - 1; j++) {
            const int c = i + nx * j;
            const int nn = c - nx;
            const int ss = c + nx;
            const int ww = c + 1;
            const int ee = c - 1;
            const int nw = nn + 1;
            const int ne = nn - 1;
            const int sw = ss + 1;
            const int se = ss - 1;

            const float dir = (float)(fmod(atan2(after_Gy[c],
                                                 after_Gx[c]) + M_PI,
                                           M_PI) / M_PI) * 8;

            if (((dir <= 1 || dir > 7) && G[c] > G[ee] &&
                 G[c] > G[ww]) || // 0 deg
                ((dir > 1 && dir <= 3) && G[c] > G[nw] &&
                 G[c] > G[se]) || // 45 deg
                ((dir > 3 && dir <= 5) && G[c] > G[nn] &&
                 G[c] > G[ss]) || // 90 deg
                ((dir > 5 && dir <= 7) && G[c] > G[ne] &&
                 G[c] > G[sw]))   // 135 deg
                nms[c] = G[c];
            else
                nms[c] = 0;
        }

    // Reuse array
    // used as a stack. nx*ny/2 elements should be enough.
    int *edges = (int*) after_Gy;
    memset(out, 0, sizeof(pixel_t) * nx * ny);
    memset(edges, 0, sizeof(pixel_t) * nx * ny);

    // Tracing edges with hysteresis . Non-recursive implementation.
    size_t c = 1;
    for (int j = 1; j < ny - 1; j++)
        for (int i = 1; i < nx - 1; i++) {
            if (nms[c] >= tmax && out[c] == 0) { // trace edges
                out[c] = MAX_BRIGHTNESS;
                int nedges = 1;
                edges[0] = c;

                do {
                    nedges--;
                    const int t = edges[nedges];

                    int nbs[8]; // neighbours
                    nbs[0] = t - nx;     // nn
                    nbs[1] = t + nx;     // ss
                    nbs[2] = t + 1;      // ww
                    nbs[3] = t - 1;      // ee
                    nbs[4] = nbs[0] + 1; // nw
                    nbs[5] = nbs[0] - 1; // ne
                    nbs[6] = nbs[1] + 1; // sw
                    nbs[7] = nbs[1] - 1; // se

                    for (int k = 0; k < 8; k++)
                        if (nms[nbs[k]] >= tmin && out[nbs[k]] == 0) {
                            out[nbs[k]] = MAX_BRIGHTNESS;
                            edges[nedges] = nbs[k];
                            nedges++;
                        }
                } while (nedges > 0);
            }
            c++;
        }

    free(after_Gx);
    free(after_Gy);
    free(G);
    free(nms);

    return out;
}

int main(const int argc, const char ** const argv)
{
    if (argc < 2) {
        printf("Usage: %s image.bmp\n", argv[0]);
        return 1;
    }

    static bitmap_info_header_t ih;
    const pixel_t *in_bitmap_data = load_bmp(argv[1], &ih);
    if (in_bitmap_data == NULL) {
        fprintf(stderr, "main: BMP image not loaded.\n");
        return 1;
    }

    printf("Info: %d x %d x %d\n", ih.width, ih.height, ih.bitspp);

    const pixel_t *out_bitmap_data =
        canny_edge_detection(in_bitmap_data, &ih, 45, 50, 1.0f);
    if (out_bitmap_data == NULL) {
        fprintf(stderr, "main: failed canny_edge_detection.\n");
        return 1;
    }

    if (save_bmp("out.bmp", &ih, out_bitmap_data)) {
        fprintf(stderr, "main: BMP image not saved.\n");
        return 1;
    }

    free((pixel_t*)in_bitmap_data);
    free((pixel_t*)out_bitmap_data);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002310(void);
int64_t function_100002638(void);
int64_t function_100002a0c(void);
int64_t function_100002ec4(void);
int64_t function_100002f6c(void);
int64_t function_100003138(void);
int64_t function_100003d04(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003d10(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003d1c(int64_t a1);
float64_t function_100003d28(float64_t a1, float64_t a2);
int64_t * function_100003d34(int32_t nmemb, int32_t size);
void function_100003d40(int32_t status);
float64_t function_100003d4c(float64_t a1);
int32_t function_100003d58(struct _IO_FILE * stream);
float64_t function_100003d64(float64_t a1, float64_t a2);
struct _IO_FILE * function_100003d70(char * filename, char * modes);
int32_t function_100003d7c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003d88(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void function_100003d94(int64_t * ptr);
int32_t function_100003da0(struct _IO_FILE * stream, int32_t off, int32_t whence);
int32_t function_100003dac(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
float64_t function_100003db8(float64_t a1, float64_t a2);
int64_t * function_100003dc4(int32_t size);
int64_t * function_100003dd0(int64_t * s, int32_t c, int32_t n);
void function_100003ddc(char * s);
float64_t function_100003de8(float64_t a1, float64_t a2);
int32_t function_100003df4(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t g1 = 32.0; // 0x100003e00
float64_t g2 = 6.2831853071795862; // 0x100003e08
float64_t g3 = 3.1415926535897931; // 0x100003e10
int64_t g4 = 0; // 0x100008000
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___chkstk_darwin(void);
int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
float64_t _atan2(float64_t a1, float64_t a2);
int64_t * _calloc(int32_t a1, int32_t a2);
float64_t _exp(float64_t a1);
int32_t _fclose(struct _IO_FILE * a1);
float64_t _fmod(float64_t a1, float64_t a2);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
void _free(int64_t * a1);
int32_t _fseek(struct _IO_FILE * a1, int32_t a2, int32_t a3);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
float64_t _hypot(float64_t a1, float64_t a2);
int64_t * _malloc(int32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
void _perror(char * a1);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100002310 - 0x100002638
int64_t function_100002310(void) {
    // 0x100002310
    int64_t v1; // 0x100002310
    struct _IO_FILE * v2 = _fopen((char *)v1, "rb"); // 0x100002330
    if (v2 == NULL) {
        // 0x10000234c
        _perror("fopen()");
        // 0x100002628
        return 0;
    }
    // 0x100002360
    int64_t v3; // bp-50, 0x100002310
    if (_fread(&v3, 2, 1, v2) != 1) {
        // 0x100002384
        _fclose(v2);
        // 0x100002628
        return 0;
    }
    // 0x100002394
    if (v3 % 0x10000 != 0x4d42) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004028; // 0x1000023b4
        _fprintf((struct _IO_FILE *)v4, "Not a BMP file: magic=%c%c\n", 1, (char)(int64_t)v2);
        _fclose(v2);
        // 0x100002628
        return 0;
    }
    // 0x1000023f0
    int64_t v5; // bp-64, 0x100002310
    if (_fread(&v5, 12, 1, v2) != 1 || _fread((int64_t *)v1, 40, 1, v2) != 1) {
        // 0x100002414
        _fclose(v2);
        // 0x100002628
        return 0;
    }
    // 0x100002458
    if (*(int32_t *)(v1 + 16) != 0) {
        int64_t v6 = *(int64_t *)*(int64_t *)0x100004028; // 0x100002478
        _fprintf((struct _IO_FILE *)v6, "Warning, compression is not supported.\n");
    }
    // 0x10000248c
    int32_t v7; // 0x100002310
    if (_fseek(v2, v7, 0) != 0) {
        // 0x1000024b0
        _fclose(v2);
        // 0x100002628
        return 0;
    }
    int64_t * v8 = _malloc(2 * *(int32_t *)(v1 + 20)); // 0x1000024cc
    if (v8 == NULL) {
        // 0x1000024e8
        _fclose(v2);
        // 0x100002628
        return 0;
    }
    int64_t v9 = (int64_t)v8; // 0x1000024cc
    int32_t * v10 = (int32_t *)(v1 + 4); // 0x100002508
    float64_t v11 = (float64_t)(*v10 * (int32_t)*(int16_t *)(v1 + 14)) / g1; // 0x10000251c
    float64_t v12 = __asm_frintp(v11); // 0x100002520
    __asm_sshll(0.0f, 0);
    int32_t * v13 = (int32_t *)(v1 + 8); // 0x100002558
    int64_t v14 = 0; // 0x100002564
    int64_t v15 = 0; // 0x100002564
    int64_t result; // 0x100002310
    if (*v13 != 0) {
        int64_t v16 = v15; // 0x100002588
        int64_t v17; // bp-89, 0x100002310
        int64_t v18; // 0x100002310
        int64_t v19; // 0x1000025d0
        int64_t v20; // 0x1000025e4
        if (*v10 != 0) {
            if (_fread(&v17, 1, 1, v2) != 1) {
                // 0x1000025b4
                _fclose(v2);
                result = 0;
                return result;
            }
            // 0x1000025c4
            v19 = v16 + 1;
            *(int16_t *)(2 * v16 + v9) = (int16_t)v17 % 256;
            v20 = 1;
            v18 = v20;
            v16 = v19;
            v15 = v19;
            while (v20 < (int64_t)*v10) {
                // 0x100002590
                if (_fread(&v17, 1, 1, v2) != 1) {
                    // 0x1000025b4
                    _fclose(v2);
                    result = 0;
                    return result;
                }
                // 0x1000025c4
                v19 = v16 + 1;
                *(int16_t *)(2 * v16 + v9) = (int16_t)v17 % 256;
                v20 = v18 + 1;
                v18 = v20;
                v16 = v19;
                v15 = v19;
            }
        }
        // 0x1000025f0
        _fseek(v2, (int32_t)(int64_t)-((v11 - 4.0 * v12)), 1);
        v14++;
        while (v14 < (int64_t)*v13) {
            // 0x100002574
            v16 = v15;
            if (*v10 != 0) {
                if (_fread(&v17, 1, 1, v2) != 1) {
                    // 0x1000025b4
                    _fclose(v2);
                    result = 0;
                    return result;
                }
                // 0x1000025c4
                v19 = v16 + 1;
                *(int16_t *)(2 * v16 + v9) = (int16_t)v17 % 256;
                v20 = 1;
                v18 = v20;
                v16 = v19;
                v15 = v19;
                while (v20 < (int64_t)*v10) {
                    // 0x100002590
                    if (_fread(&v17, 1, 1, v2) != 1) {
                        // 0x1000025b4
                        _fclose(v2);
                        result = 0;
                        return result;
                    }
                    // 0x1000025c4
                    v19 = v16 + 1;
                    *(int16_t *)(2 * v16 + v9) = (int16_t)v17 % 256;
                    v20 = v18 + 1;
                    v18 = v20;
                    v16 = v19;
                    v15 = v19;
                }
            }
            // 0x1000025f0
            _fseek(v2, (int32_t)(int64_t)-((v11 - 4.0 * v12)), 1);
            v14++;
        }
    }
    // 0x100002614
    _fclose(v2);
    result = v9;
  lab_0x100002628:
    // 0x100002628
    return result;
}

// Address range: 0x100002638 - 0x100002a0c
int64_t function_100002638(void) {
    // 0x100002638
    int64_t v1; // 0x100002638
    struct _IO_FILE * v2 = _fopen((char *)v1, "wb"); // 0x10000265c
    if (v2 == NULL) {
        // 0x1000029f8
        return 1;
    }
    int64_t v3 = 0x4d42; // bp-58, 0x10000269c
    if (_fwrite(&v3, 2, 1, v2) != 1) {
        // 0x1000026c0
        _fclose(v2);
        // 0x1000029f8
        return 1;
    }
    int16_t * v4 = (int16_t *)(v1 + 14); // 0x1000026e0
    int32_t v5 = *(int32_t *)(v1 + 20); // 0x100002704
    int64_t v6 = v5 + 54 + (4 << (int32_t)*v4); // bp-76, 0x100002710
    if (_fwrite(&v6, 12, 1, v2) != 1) {
        // 0x100002744
        _fclose(v2);
        // 0x1000029f8
        return 1;
    }
    int32_t v7 = 0; // 0x10000277c
    int64_t result; // 0x100002638
    if (_fwrite((int64_t *)v1, 40, 1, v2) != 1) {
        // 0x100002784
        _fclose(v2);
        result = 1;
      lab_0x1000029f8:
        // 0x1000029f8
        return result;
    }
    int64_t v8 = 0x100000000000000 * (int64_t)v7 >> 56; // bp-92, 0x1000027d8
    int64_t v9; // 0x100002638
    int32_t * v10; // 0x10000284c
    int32_t * v11; // 0x10000289c
    uint64_t v12; // 0x100002884
    while (_fwrite(&v8, 4, 1, v2) == 1) {
        // 0x1000027a8
        v7++;
        uint32_t v13 = (int32_t)*v4; // 0x1000027b0
        if ((int64_t)v7 >= (int64_t)(1 << v13)) {
            // 0x100002840
            v10 = (int32_t *)(v1 + 4);
            float64_t v14 = (float64_t)(*v10 * v13) / g1; // 0x100002860
            float64_t v15 = __asm_frintp(v14); // 0x100002864
            __asm_sshll(0.0f, 0);
            v11 = (int32_t *)(v1 + 8);
            if (*v11 == 0) {
                // 0x1000029dc
                _fclose(v2);
                result = 0;
                return result;
            } else {
                // 0x1000028b8
                v12 = (int64_t)-((v14 - 4.0 * v15));
                v9 = 0;
                goto lab_0x1000028b8_2;
            }
        }
        v8 = 0x100000000000000 * (int64_t)v7 >> 56;
    }
    // 0x100002810
    _fclose(v2);
    // 0x1000029f8
    return 1;
  lab_0x1000028b8_2:;
    int64_t v16 = v9;
    int32_t v17 = *v10; // 0x1000028c0
    int64_t v18; // 0x100002638
    int64_t v19; // 0x100002638
    if (v17 == 0) {
        goto lab_0x100002950;
    } else {
        // 0x1000028d4
        v18 = v17;
        v19 = 0;
        goto lab_0x1000028d4_2;
    }
  lab_0x100002950:;
    int64_t v20 = 0; // bp-105, 0x100002950
    int64_t v21 = 0; // 0x10000296c
    if (v12 == 0) {
        goto lab_0x1000029cc;
    } else {
        goto lab_0x100002974;
    }
  lab_0x1000029cc:;
    int64_t v22 = v16 + 1; // 0x1000029d0
    v9 = v22;
    if (v22 < (int64_t)*v11) {
        goto lab_0x1000028b8_2;
    } else {
        // 0x1000029dc
        _fclose(v2);
        result = 0;
        return result;
    }
  lab_0x100002974:
    // 0x100002974
    if (_fwrite(&v20, 1, 1, v2) == 1) {
        int64_t v23 = v21 + 1; // 0x1000029bc
        v21 = v23;
        if (v23 < v12) {
            goto lab_0x100002974;
        } else {
            goto lab_0x1000029cc;
        }
    } else {
        // 0x100002998
        _fclose(v2);
        result = 1;
        return result;
    }
  lab_0x1000028d4_2:;
    uint16_t v24 = *(int16_t *)(2 * (v18 * v16 + v19) + v1); // 0x1000028f4
    v20 = 0x100000000000000 * (int64_t)v24 >> 56;
    if (_fwrite(&v20, 1, 1, v2) == 1) {
        int64_t v25 = v19 + 1; // 0x100002944
        int64_t v26 = (int64_t)*v10; // 0x1000028c0
        v18 = v26;
        v19 = v25;
        if (v25 < v26) {
            goto lab_0x1000028d4_2;
        } else {
            goto lab_0x100002950;
        }
    } else {
        // 0x100002920
        _fclose(v2);
        result = 1;
        return result;
    }
}

// Address range: 0x100002a0c - 0x100002ec4
int64_t function_100002a0c(void) {
    // 0x100002a0c
    int64_t v1; // 0x100002a0c
    uint64_t v2 = v1;
    int32_t v3 = v1; // 0x100002a2c
    int32_t v4 = v3 / 2; // 0x100002a44
    int64_t v5; // 0x100002a0c
    if (-1 - 2 * v4 != -v3) {
        // 0x100002a6c
        v5 = ___assert_rtn("convolution", "canny-edge-detector.c", 223, "kn % 2 == 1");
    }
    int32_t v6 = v1; // 0x100002a24
    int32_t v7 = v1; // 0x100002a28
    int32_t v8 = v6 - v3; // 0x100002a98
    int64_t result; // 0x100002a0c
    if (v8 == 0 || v8 < 0 != ((v8 ^ v6) & (int32_t)(v1 ^ v1)) < 0) {
        // 0x100002ae4
        result = ___assert_rtn("convolution", "canny-edge-detector.c", 224, "nx > kn && ny > kn");
        goto lab_0x100002b08;
    } else {
        int32_t v9 = v7 - v3; // 0x100002ab8
        result = v5;
        if (v9 == 0 || v9 < 0 != ((v9 ^ v7) & (int32_t)(v1 ^ v1)) < 0) {
            // 0x100002ae4
            result = ___assert_rtn("convolution", "canny-edge-detector.c", 224, "nx > kn && ny > kn");
            goto lab_0x100002b08;
        } else {
            goto lab_0x100002b08;
        }
    }
  lab_0x100002b08:;
    float32_t v10 = 3.40282347e+38f; // bp-64, 0x100002b20
    float32_t v11 = -3.40282347e+38f; // 0x100002b28
    float32_t v12 = -3.40282347e+38f; // bp-68, 0x100002b2c
    int32_t v13 = v6 - v4;
    int32_t v14 = v4 - v13;
    int32_t v15 = (v14 ^ v4) & (v13 ^ v4);
    float32_t v16; // 0x100002a0c
    if (v2 % 2 != 0) {
        if (v14 < 0 != v15 < 0) {
            int32_t v17 = v7 - v4; // 0x100002b80
            int32_t v18 = v4 - v17; // 0x100002b84
            int32_t v19 = -v4;
            int32_t v20 = v19 - v4;
            float32_t v21 = -3.40282347e+38f;
            float32_t v22 = 3.40282347e+38f;
            int32_t v23 = -0x800001;
            int32_t v24 = v4; // 0x100002ce0
            float32_t v25 = v21; // 0x100002b8c
            float32_t v26 = v22; // 0x100002b8c
            int32_t v27 = v23; // 0x100002b8c
            float32_t v28; // 0x100002a0c
            float32_t v29 = v28; // 0x100002b8c
            float32_t v30 = v21; // 0x100002b8c
            float32_t v31 = v22; // 0x100002b8c
            int32_t v32 = v23; // 0x100002b8c
            float32_t v33 = v28; // 0x100002b8c
            float32_t v34; // 0x100002a0c
            float32_t v35; // 0x100002a0c
            int32_t v36; // 0x100002a0c
            float32_t v37; // 0x100002a0c
            float32_t v38; // 0x100002a0c
            float32_t v39; // 0x100002a0c
            int32_t v40; // 0x100002a0c
            float32_t v41; // 0x100002ca4
            int32_t v42; // 0x100002a0c
            float32_t v43; // 0x100002ca0
            float32_t v44; // 0x100002a0c
            float32_t v45; // 0x100002a0c
            int64_t v46; // 0x100002a0c
            int32_t v47; // 0x100002a0c
            int32_t v48; // 0x100002a0c
            float32_t v49; // 0x100002c38
            float32_t v50; // 0x100002c40
            int64_t v51; // 0x100002c4c
            int32_t v52; // 0x100002c5c
            int32_t v53; // 0x100002be8
            int32_t v54; // 0x100002c70
            int32_t v55; // 0x100002bbc
            int32_t v56; // 0x100002ccc
            int32_t v57; // 0x100002b84
            if (v18 < 0 != ((v18 ^ v4) & (v17 ^ v4)) < 0) {
                v41 = v25;
                v34 = v27;
                v44 = v29;
                v36 = v27;
                v37 = v27;
                if (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v4 ^ v19)) < 0) {
                    v52 = v19;
                    v46 = 0;
                    __asm_sshll_5(0, 0);
                    v49 = *(float32_t *)(4 * v46 + v1);
                    v50 = v34 + v44 * v49;
                    v51 = v46 + 1;
                    v52++;
                    v53 = v52 - v4;
                    v35 = v50;
                    v45 = v49;
                    v46 = v51;
                    while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                        // 0x100002bf8
                        __asm_sshll_5(0, 0);
                        v49 = *(float32_t *)(4 * v46 + v1);
                        v50 = v35 + v45 * v49;
                        v51 = v46 + 1;
                        v52++;
                        v53 = v52 - v4;
                        v35 = v50;
                        v45 = v49;
                        v46 = v51;
                    }
                    // 0x100002c6c
                    v54 = v19 + 1;
                    v55 = v54 - v4;
                    v47 = v54;
                    while (v55 == 0 || v55 < 0 != ((v55 ^ v54) & (v54 ^ v4)) < 0) {
                        // 0x100002bf8
                        v52 = v19;
                        v45 = v49;
                        __asm_sshll_5(0, 0);
                        v49 = *(float32_t *)(4 * v51 + v1);
                        v50 += v45 * v49;
                        v51++;
                        v52++;
                        v53 = v52 - v4;
                        v35 = v50;
                        v45 = v49;
                        v46 = v51;
                        while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                            // 0x100002bf8
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v46 + v1);
                            v50 = v35 + v45 * v49;
                            v51 = v46 + 1;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                        }
                        // 0x100002c6c
                        v54 = v47 + 1;
                        v55 = v54 - v4;
                        v47 = v54;
                    }
                    // 0x100002c7c
                    v36 = v50;
                    v37 = v50;
                }
                // 0x100002c7c
                v43 = v37;
                v42 = v36;
                v38 = v26;
                if (v43 > v26) {
                    // 0x100002c94
                    v10 = v42;
                    v38 = v42;
                }
                // 0x100002ca0
                v11 = v43;
                v39 = v41;
                v40 = v43;
                if (v43 != v41) {
                    v39 = v41;
                    v40 = v43;
                    if (v43 > v41 == v43 >= v41 == v43 <= v41) {
                        // 0x100002cb8
                        v11 = v42;
                        v12 = v42;
                        v39 = v42;
                        v40 = v42;
                    }
                }
                // 0x100002cc8
                v56 = v4 + 1;
                v57 = v56 - v17;
                v26 = v38;
                v27 = v40;
                v48 = v56;
                v29 = v41;
                v30 = v39;
                v31 = v38;
                v32 = v40;
                v33 = v41;
                while (v57 < 0 != ((v57 ^ v56) & (v56 ^ v17)) < 0) {
                    // 0x100002b94
                    v41 = v39;
                    v34 = v27;
                    v44 = v29;
                    v36 = v27;
                    v37 = v27;
                    if (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v4 ^ v19)) < 0) {
                        v52 = v19;
                        v46 = 0;
                        __asm_sshll_5(0, 0);
                        v49 = *(float32_t *)(4 * v46 + v1);
                        v50 = v34 + v44 * v49;
                        v51 = v46 + 1;
                        v52++;
                        v53 = v52 - v4;
                        v35 = v50;
                        v45 = v49;
                        v46 = v51;
                        while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                            // 0x100002bf8
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v46 + v1);
                            v50 = v35 + v45 * v49;
                            v51 = v46 + 1;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                        }
                        // 0x100002c6c
                        v54 = v19 + 1;
                        v55 = v54 - v4;
                        v47 = v54;
                        while (v55 == 0 || v55 < 0 != ((v55 ^ v54) & (v54 ^ v4)) < 0) {
                            // 0x100002bf8
                            v52 = v19;
                            v45 = v49;
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v51 + v1);
                            v50 += v45 * v49;
                            v51++;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                            while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                                // 0x100002bf8
                                __asm_sshll_5(0, 0);
                                v49 = *(float32_t *)(4 * v46 + v1);
                                v50 = v35 + v45 * v49;
                                v51 = v46 + 1;
                                v52++;
                                v53 = v52 - v4;
                                v35 = v50;
                                v45 = v49;
                                v46 = v51;
                            }
                            // 0x100002c6c
                            v54 = v47 + 1;
                            v55 = v54 - v4;
                            v47 = v54;
                        }
                        // 0x100002c7c
                        v36 = v50;
                        v37 = v50;
                    }
                    // 0x100002c7c
                    v43 = v37;
                    v42 = v36;
                    v38 = v26;
                    if (v43 > v26) {
                        // 0x100002c94
                        v10 = v42;
                        v38 = v42;
                    }
                    // 0x100002ca0
                    v11 = v43;
                    v39 = v41;
                    v40 = v43;
                    if (v43 != v41) {
                        v39 = v41;
                        v40 = v43;
                        if (v43 > v41 == v43 >= v41 == v43 <= v41) {
                            // 0x100002cb8
                            v11 = v42;
                            v12 = v42;
                            v39 = v42;
                            v40 = v42;
                        }
                    }
                    // 0x100002cc8
                    v56 = v48 + 1;
                    v57 = v56 - v17;
                    v26 = v38;
                    v27 = v40;
                    v48 = v56;
                    v29 = v41;
                    v30 = v39;
                    v31 = v38;
                    v32 = v40;
                    v33 = v41;
                }
            }
            // 0x100002cdc
            v23 = v32;
            v22 = v31;
            v21 = v30;
            v24++;
            int32_t v58 = v24 - v13; // 0x100002b58
            v28 = v33;
            v16 = v33;
            while (v58 < 0 != ((v58 ^ v24) & (v24 ^ v13)) < 0) {
                // 0x100002b74
                v25 = v21;
                v26 = v22;
                v27 = v23;
                v29 = v28;
                v30 = v21;
                v31 = v22;
                v32 = v23;
                v33 = v28;
                if (v18 < 0 != ((v18 ^ v4) & (v17 ^ v4)) < 0) {
                    v41 = v25;
                    v34 = v27;
                    v44 = v29;
                    v36 = v27;
                    v37 = v27;
                    if (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v4 ^ v19)) < 0) {
                        v52 = v19;
                        v46 = 0;
                        __asm_sshll_5(0, 0);
                        v49 = *(float32_t *)(4 * v46 + v1);
                        v50 = v34 + v44 * v49;
                        v51 = v46 + 1;
                        v52++;
                        v53 = v52 - v4;
                        v35 = v50;
                        v45 = v49;
                        v46 = v51;
                        while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                            // 0x100002bf8
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v46 + v1);
                            v50 = v35 + v45 * v49;
                            v51 = v46 + 1;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                        }
                        // 0x100002c6c
                        v54 = v19 + 1;
                        v55 = v54 - v4;
                        v47 = v54;
                        while (v55 == 0 || v55 < 0 != ((v55 ^ v54) & (v54 ^ v4)) < 0) {
                            // 0x100002bf8
                            v52 = v19;
                            v45 = v49;
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v51 + v1);
                            v50 += v45 * v49;
                            v51++;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                            while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                                // 0x100002bf8
                                __asm_sshll_5(0, 0);
                                v49 = *(float32_t *)(4 * v46 + v1);
                                v50 = v35 + v45 * v49;
                                v51 = v46 + 1;
                                v52++;
                                v53 = v52 - v4;
                                v35 = v50;
                                v45 = v49;
                                v46 = v51;
                            }
                            // 0x100002c6c
                            v54 = v47 + 1;
                            v55 = v54 - v4;
                            v47 = v54;
                        }
                        // 0x100002c7c
                        v36 = v50;
                        v37 = v50;
                    }
                    // 0x100002c7c
                    v43 = v37;
                    v42 = v36;
                    v38 = v26;
                    if (v43 > v26) {
                        // 0x100002c94
                        v10 = v42;
                        v38 = v42;
                    }
                    // 0x100002ca0
                    v11 = v43;
                    v39 = v41;
                    v40 = v43;
                    if (v43 != v41) {
                        v39 = v41;
                        v40 = v43;
                        if (v43 > v41 == v43 >= v41 == v43 <= v41) {
                            // 0x100002cb8
                            v11 = v42;
                            v12 = v42;
                            v39 = v42;
                            v40 = v42;
                        }
                    }
                    // 0x100002cc8
                    v56 = v4 + 1;
                    v57 = v56 - v17;
                    v26 = v38;
                    v27 = v40;
                    v48 = v56;
                    v29 = v41;
                    v30 = v39;
                    v31 = v38;
                    v32 = v40;
                    v33 = v41;
                    while (v57 < 0 != ((v57 ^ v56) & (v56 ^ v17)) < 0) {
                        // 0x100002b94
                        v41 = v39;
                        v34 = v27;
                        v44 = v29;
                        v36 = v27;
                        v37 = v27;
                        if (v20 == 0 || v20 < 0 != ((v20 ^ v19) & (v4 ^ v19)) < 0) {
                            v52 = v19;
                            v46 = 0;
                            __asm_sshll_5(0, 0);
                            v49 = *(float32_t *)(4 * v46 + v1);
                            v50 = v34 + v44 * v49;
                            v51 = v46 + 1;
                            v52++;
                            v53 = v52 - v4;
                            v35 = v50;
                            v45 = v49;
                            v46 = v51;
                            while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                                // 0x100002bf8
                                __asm_sshll_5(0, 0);
                                v49 = *(float32_t *)(4 * v46 + v1);
                                v50 = v35 + v45 * v49;
                                v51 = v46 + 1;
                                v52++;
                                v53 = v52 - v4;
                                v35 = v50;
                                v45 = v49;
                                v46 = v51;
                            }
                            // 0x100002c6c
                            v54 = v19 + 1;
                            v55 = v54 - v4;
                            v47 = v54;
                            while (v55 == 0 || v55 < 0 != ((v55 ^ v54) & (v54 ^ v4)) < 0) {
                                // 0x100002bf8
                                v52 = v19;
                                v45 = v49;
                                __asm_sshll_5(0, 0);
                                v49 = *(float32_t *)(4 * v51 + v1);
                                v50 += v45 * v49;
                                v51++;
                                v52++;
                                v53 = v52 - v4;
                                v35 = v50;
                                v45 = v49;
                                v46 = v51;
                                while (v53 == 0 || v53 < 0 != ((v53 ^ v52) & (v52 ^ v4)) < 0) {
                                    // 0x100002bf8
                                    __asm_sshll_5(0, 0);
                                    v49 = *(float32_t *)(4 * v46 + v1);
                                    v50 = v35 + v45 * v49;
                                    v51 = v46 + 1;
                                    v52++;
                                    v53 = v52 - v4;
                                    v35 = v50;
                                    v45 = v49;
                                    v46 = v51;
                                }
                                // 0x100002c6c
                                v54 = v47 + 1;
                                v55 = v54 - v4;
                                v47 = v54;
                            }
                            // 0x100002c7c
                            v36 = v50;
                            v37 = v50;
                        }
                        // 0x100002c7c
                        v43 = v37;
                        v42 = v36;
                        v38 = v26;
                        if (v43 > v26) {
                            // 0x100002c94
                            v10 = v42;
                            v38 = v42;
                        }
                        // 0x100002ca0
                        v11 = v43;
                        v39 = v41;
                        v40 = v43;
                        if (v43 != v41) {
                            v39 = v41;
                            v40 = v43;
                            if (v43 > v41 == v43 >= v41 == v43 <= v41) {
                                // 0x100002cb8
                                v11 = v42;
                                v12 = v42;
                                v39 = v42;
                                v40 = v42;
                            }
                        }
                        // 0x100002cc8
                        v56 = v48 + 1;
                        v57 = v56 - v17;
                        v26 = v38;
                        v27 = v40;
                        v48 = v56;
                        v29 = v41;
                        v30 = v39;
                        v31 = v38;
                        v32 = v40;
                        v33 = v41;
                    }
                }
                // 0x100002cdc
                v23 = v32;
                v22 = v31;
                v21 = v30;
                v24++;
                v58 = v24 - v13;
                v28 = v33;
                v16 = v33;
            }
        }
    }
    if (v14 < 0 == v15 < 0) {
        // 0x100002eb8
        return result;
    }
    int32_t v59 = v7 - v4; // 0x100002d34
    int32_t v60 = v4 - v59; // 0x100002d38
    int32_t v61 = -v4;
    int32_t v62 = v61 - v4;
    float32_t v63 = v16; // 0x100002d40
    float32_t v64; // 0x100002a0c
    float32_t v65; // 0x100002a0c
    float32_t v66; // 0x100002a0c
    float32_t v67; // 0x100002a0c
    float32_t v68; // 0x100002a0c
    float32_t v69; // 0x100002a0c
    float32_t v70; // 0x100002a0c
    float32_t v71; // 0x100002a0c
    float32_t v72; // 0x100002a0c
    int64_t v73; // 0x100002a0c
    int32_t v74; // 0x100002a0c
    int32_t v75; // 0x100002a0c
    float32_t v76; // 0x100002dec
    float32_t v77; // 0x100002df4
    int64_t v78; // 0x100002e00
    int32_t v79; // 0x100002e10
    int32_t v80; // 0x100002d9c
    int32_t v81; // 0x100002e98
    int32_t v82; // 0x100002d38
    float32_t v83; // 0x100002e5c
    int32_t v84; // 0x100002e24
    int32_t v85; // 0x100002d70
    if (v60 < 0 != ((v60 ^ v4) & (v59 ^ v4)) < 0) {
        v64 = v11;
        v66 = v11;
        v71 = v16;
        if (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v4 ^ v61)) < 0) {
            v79 = v61;
            v73 = 0;
            __asm_sshll_5(0, 0);
            v76 = *(float32_t *)(4 * v73 + v1);
            v77 = v64 + v16 * v76;
            v78 = v73 + 1;
            v79++;
            v80 = v79 - v4;
            v65 = v77;
            v72 = v76;
            v73 = v78;
            while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                // 0x100002dac
                __asm_sshll_5(0, 0);
                v76 = *(float32_t *)(4 * v73 + v1);
                v77 = v65 + v72 * v76;
                v78 = v73 + 1;
                v79++;
                v80 = v79 - v4;
                v65 = v77;
                v72 = v76;
                v73 = v78;
            }
            // 0x100002e20
            v84 = v61 + 1;
            v85 = v84 - v4;
            v74 = v84;
            v66 = v77;
            v71 = v76;
            while (v85 == 0 || v85 < 0 != ((v85 ^ v84) & (v84 ^ v4)) < 0) {
                // 0x100002dac
                v79 = v61;
                v72 = v76;
                __asm_sshll_5(0, 0);
                v76 = *(float32_t *)(4 * v78 + v1);
                v77 += v72 * v76;
                v78++;
                v79++;
                v80 = v79 - v4;
                v65 = v77;
                v72 = v76;
                v73 = v78;
                while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                    // 0x100002dac
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v73 + v1);
                    v77 = v65 + v72 * v76;
                    v78 = v73 + 1;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                }
                // 0x100002e20
                v84 = v74 + 1;
                v85 = v84 - v4;
                v74 = v84;
                v66 = v77;
                v71 = v76;
            }
        }
        // 0x100002e30
        v68 = v66;
        v67 = v68;
        v83 = v71;
        if (v2 % 2 != 0) {
            // 0x100002e3c
            v83 = v12 - v10;
            v67 = 255.0f * (v68 - v10) / v83;
        }
        // 0x100002e6c
        v11 = v67;
        *(int16_t *)(v1 + (int64_t)(2 * (v4 * v6 + v4))) = (int16_t)(int32_t)v67;
        v81 = v4 + 1;
        v82 = v81 - v59;
        v75 = v81;
        v69 = v83;
        v63 = v83;
        while (v82 < 0 != ((v82 ^ v81) & (v81 ^ v59)) < 0) {
            // 0x100002d48
            v64 = v11;
            v70 = v69;
            v66 = v11;
            v71 = v69;
            if (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v4 ^ v61)) < 0) {
                v79 = v61;
                v73 = 0;
                __asm_sshll_5(0, 0);
                v76 = *(float32_t *)(4 * v73 + v1);
                v77 = v64 + v70 * v76;
                v78 = v73 + 1;
                v79++;
                v80 = v79 - v4;
                v65 = v77;
                v72 = v76;
                v73 = v78;
                while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                    // 0x100002dac
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v73 + v1);
                    v77 = v65 + v72 * v76;
                    v78 = v73 + 1;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                }
                // 0x100002e20
                v84 = v61 + 1;
                v85 = v84 - v4;
                v74 = v84;
                v66 = v77;
                v71 = v76;
                while (v85 == 0 || v85 < 0 != ((v85 ^ v84) & (v84 ^ v4)) < 0) {
                    // 0x100002dac
                    v79 = v61;
                    v72 = v76;
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v78 + v1);
                    v77 += v72 * v76;
                    v78++;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                    while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                        // 0x100002dac
                        __asm_sshll_5(0, 0);
                        v76 = *(float32_t *)(4 * v73 + v1);
                        v77 = v65 + v72 * v76;
                        v78 = v73 + 1;
                        v79++;
                        v80 = v79 - v4;
                        v65 = v77;
                        v72 = v76;
                        v73 = v78;
                    }
                    // 0x100002e20
                    v84 = v74 + 1;
                    v85 = v84 - v4;
                    v74 = v84;
                    v66 = v77;
                    v71 = v76;
                }
            }
            // 0x100002e30
            v68 = v66;
            v67 = v68;
            v83 = v71;
            if (v2 % 2 != 0) {
                // 0x100002e3c
                v83 = v12 - v10;
                v67 = 255.0f * (v68 - v10) / v83;
            }
            // 0x100002e6c
            v11 = v67;
            *(int16_t *)(v1 + (int64_t)(2 * (v75 * v6 + v4))) = (int16_t)(int32_t)v67;
            v81 = v75 + 1;
            v82 = v81 - v59;
            v75 = v81;
            v69 = v83;
            v63 = v83;
        }
    }
    int32_t v86 = v4 + 1; // 0x100002eac
    int32_t v87 = v86 - v13; // 0x100002d0c
    float32_t v88 = v63; // 0x100002d14
    while (v87 < 0 != ((v87 ^ v86) & (v86 ^ v13)) < 0) {
        int32_t v89 = v86;
        v69 = v88;
        v63 = v88;
        if (v60 < 0 != ((v60 ^ v4) & (v59 ^ v4)) < 0) {
            v64 = v11;
            v70 = v69;
            v66 = v11;
            v71 = v69;
            if (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v4 ^ v61)) < 0) {
                v79 = v61;
                v73 = 0;
                __asm_sshll_5(0, 0);
                v76 = *(float32_t *)(4 * v73 + v1);
                v77 = v64 + v70 * v76;
                v78 = v73 + 1;
                v79++;
                v80 = v79 - v4;
                v65 = v77;
                v72 = v76;
                v73 = v78;
                while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                    // 0x100002dac
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v73 + v1);
                    v77 = v65 + v72 * v76;
                    v78 = v73 + 1;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                }
                // 0x100002e20
                v84 = v61 + 1;
                v85 = v84 - v4;
                v74 = v84;
                v66 = v77;
                v71 = v76;
                while (v85 == 0 || v85 < 0 != ((v85 ^ v84) & (v84 ^ v4)) < 0) {
                    // 0x100002dac
                    v79 = v61;
                    v72 = v76;
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v78 + v1);
                    v77 += v72 * v76;
                    v78++;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                    while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                        // 0x100002dac
                        __asm_sshll_5(0, 0);
                        v76 = *(float32_t *)(4 * v73 + v1);
                        v77 = v65 + v72 * v76;
                        v78 = v73 + 1;
                        v79++;
                        v80 = v79 - v4;
                        v65 = v77;
                        v72 = v76;
                        v73 = v78;
                    }
                    // 0x100002e20
                    v84 = v74 + 1;
                    v85 = v84 - v4;
                    v74 = v84;
                    v66 = v77;
                    v71 = v76;
                }
            }
            // 0x100002e30
            v68 = v66;
            v67 = v68;
            v83 = v71;
            if (v2 % 2 != 0) {
                // 0x100002e3c
                v83 = v12 - v10;
                v67 = 255.0f * (v68 - v10) / v83;
            }
            // 0x100002e6c
            v11 = v67;
            *(int16_t *)(v1 + (int64_t)(2 * (v4 * v6 + v89))) = (int16_t)(int32_t)v67;
            v81 = v4 + 1;
            v82 = v81 - v59;
            v75 = v81;
            v69 = v83;
            v63 = v83;
            while (v82 < 0 != ((v82 ^ v81) & (v81 ^ v59)) < 0) {
                // 0x100002d48
                v64 = v11;
                v70 = v69;
                v66 = v11;
                v71 = v69;
                if (v62 == 0 || v62 < 0 != ((v62 ^ v61) & (v4 ^ v61)) < 0) {
                    v79 = v61;
                    v73 = 0;
                    __asm_sshll_5(0, 0);
                    v76 = *(float32_t *)(4 * v73 + v1);
                    v77 = v64 + v70 * v76;
                    v78 = v73 + 1;
                    v79++;
                    v80 = v79 - v4;
                    v65 = v77;
                    v72 = v76;
                    v73 = v78;
                    while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                        // 0x100002dac
                        __asm_sshll_5(0, 0);
                        v76 = *(float32_t *)(4 * v73 + v1);
                        v77 = v65 + v72 * v76;
                        v78 = v73 + 1;
                        v79++;
                        v80 = v79 - v4;
                        v65 = v77;
                        v72 = v76;
                        v73 = v78;
                    }
                    // 0x100002e20
                    v84 = v61 + 1;
                    v85 = v84 - v4;
                    v74 = v84;
                    v66 = v77;
                    v71 = v76;
                    while (v85 == 0 || v85 < 0 != ((v85 ^ v84) & (v84 ^ v4)) < 0) {
                        // 0x100002dac
                        v79 = v61;
                        v72 = v76;
                        __asm_sshll_5(0, 0);
                        v76 = *(float32_t *)(4 * v78 + v1);
                        v77 += v72 * v76;
                        v78++;
                        v79++;
                        v80 = v79 - v4;
                        v65 = v77;
                        v72 = v76;
                        v73 = v78;
                        while (v80 == 0 || v80 < 0 != ((v80 ^ v79) & (v79 ^ v4)) < 0) {
                            // 0x100002dac
                            __asm_sshll_5(0, 0);
                            v76 = *(float32_t *)(4 * v73 + v1);
                            v77 = v65 + v72 * v76;
                            v78 = v73 + 1;
                            v79++;
                            v80 = v79 - v4;
                            v65 = v77;
                            v72 = v76;
                            v73 = v78;
                        }
                        // 0x100002e20
                        v84 = v74 + 1;
                        v85 = v84 - v4;
                        v74 = v84;
                        v66 = v77;
                        v71 = v76;
                    }
                }
                // 0x100002e30
                v68 = v66;
                v67 = v68;
                v83 = v71;
                if (v2 % 2 != 0) {
                    // 0x100002e3c
                    v83 = v12 - v10;
                    v67 = 255.0f * (v68 - v10) / v83;
                }
                // 0x100002e6c
                v11 = v67;
                *(int16_t *)(v1 + (int64_t)(2 * (v75 * v6 + v89))) = (int16_t)(int32_t)v67;
                v81 = v75 + 1;
                v82 = v81 - v59;
                v75 = v81;
                v69 = v83;
                v63 = v83;
            }
        }
        // 0x100002ea8
        v86 = v89 + 1;
        v87 = v86 - v13;
        v88 = v63;
    }
    // 0x100002eb8
    return result;
}

// Address range: 0x100002ec4 - 0x100002f6c
int64_t function_100002ec4(void) {
    // 0x100002ec4
    __asm_sshll(0.0f, 0);
    float64_t v1; // 0x100002ec4
    __asm_frintm(0.5 * v1);
    return ___chkstk_darwin();
}

// Address range: 0x100002f6c - 0x100003138
int64_t function_100002f6c(void) {
    // 0x100002f6c
    int64_t v1; // 0x100002f6c
    int64_t v2 = v1;
    int64_t v3; // 0x100002f6c
    int64_t v4 = (int64_t)&v3 - *(int64_t *)(v2 - 96); // 0x100002f74
    int64_t * v5 = (int64_t *)(v2 - 88); // 0x100002f7c
    *v5 = v4;
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004028; // 0x100002f8c
    int32_t * v7 = (int32_t *)(v2 - 40); // 0x100002f90
    float32_t * v8 = (float32_t *)(v2 - 36); // 0x100002f98
    *(int64_t *)(v4 - 16) = (int64_t)*v7;
    *(float64_t *)(v4 - 8) = (float64_t)*v8;
    int128_t v9; // 0x100002f6c
    int64_t v10 = v9; // 0x100002fb8
    _fprintf((struct _IO_FILE *)v6, "gaussian_filter: kernel size %d, sigma=%g\n", v1, (float64_t)v10);
    int64_t * v11 = (int64_t *)(v2 - 72); // 0x100002fc0
    *v11 = 0;
    int64_t v12 = v2 - 76; // 0x100002fc4
    int32_t * v13 = (int32_t *)v12; // 0x100002fc4
    *v13 = 0;
    int32_t v14 = *v7; // 0x100002fd0
    int32_t v15 = -v14; // 0x100002fd4
    if (v15 < 0 != (v14 & v15) < 0) {
        int64_t v16 = v2 - 80; // 0x100002fe4
        int32_t * v17 = (int32_t *)v16; // 0x100002fe4
        float32_t * v18 = (float32_t *)(v2 - 44);
        float64_t * v19 = (float64_t *)(v2 - 104);
        *v17 = 0;
        int32_t v20 = *v7; // 0x100002ff0
        int32_t v21 = -v20; // 0x100002ff4
        int64_t v22 = v10; // 0x100002ffc
        int64_t v23; // 0x100002f6c
        int64_t v24; // 0x100002f6c
        float64_t v25; // 0x100003028
        float32_t v26; // 0x100003034
        float32_t v27; // 0x10000303c
        float32_t v28; // 0x100003044
        float64_t v29; // 0x100003050
        float64_t v30; // 0x100003058
        float64_t v31; // 0x100003068
        int64_t v32; // 0x10000306c
        float64_t v33; // 0x100003074
        int64_t v34; // 0x100003098
        int32_t v35; // 0x1000030b4
        int32_t v36; // 0x100002ff0
        int32_t v37; // 0x100002ff4
        if (v21 < 0 != (v20 & v21) < 0) {
            *(float64_t *)(v2 - 112) = 2.0;
            v25 = _pow((float64_t)v10, (float64_t)(int64_t)v9);
            *v19 = (float64_t)((*(float32_t *)v12 - *v18) / *v8);
            v26 = *(float32_t *)v16;
            v27 = *v18;
            v28 = *v8;
            v29 = _pow(v25, (float64_t)(int64_t)v9);
            v30 = *v19;
            v31 = _exp(v29);
            v32 = *v5;
            v33 = (float64_t)*v8;
            v34 = *v11;
            *(float32_t *)(4 * v34 + v32) = (float32_t)(-0.5 * (v30 + (float64_t)((v26 - v27) / v28)) / (g2 * v33 * v33));
            *v11 = *v11 + 1;
            v35 = *v17 + 1;
            *v17 = v35;
            v23 = (float32_t)v31;
            v36 = *v7;
            v37 = v35 - v36;
            v24 = v23;
            v22 = v23;
            while (v37 < 0 != ((v37 ^ v35) & (v36 ^ v35)) < 0) {
                // 0x100003004
                *(float64_t *)(v2 - 112) = 2.0;
                v25 = _pow((float64_t)v24, (float64_t)(int64_t)v9);
                *v19 = (float64_t)((*(float32_t *)v12 - *v18) / *v8);
                v26 = *(float32_t *)v16;
                v27 = *v18;
                v28 = *v8;
                v29 = _pow(v25, (float64_t)(int64_t)v9);
                v30 = *v19;
                v31 = _exp(v29);
                v32 = *v5;
                v33 = (float64_t)*v8;
                v34 = *v11;
                *(float32_t *)(4 * v34 + v32) = (float32_t)(-0.5 * (v30 + (float64_t)((v26 - v27) / v28)) / (g2 * v33 * v33));
                *v11 = *v11 + 1;
                v35 = *v17 + 1;
                *v17 = v35;
                v23 = (float32_t)v31;
                v36 = *v7;
                v37 = v35 - v36;
                v24 = v23;
                v22 = v23;
            }
        }
        int64_t v38 = v22;
        int32_t v39 = *v13 + 1; // 0x1000030c8
        *v13 = v39;
        int32_t v40 = *v7; // 0x100002fd0
        while (v39 - v40 < 0 != ((v39 - v40 ^ v39) & (v40 ^ v39)) < 0) {
            // 0x100002fe4
            *v17 = 0;
            v20 = *v7;
            v21 = -v20;
            v24 = v38;
            v22 = v38;
            if (v21 < 0 != (v20 & v21) < 0) {
                *(float64_t *)(v2 - 112) = 2.0;
                v25 = _pow((float64_t)v24, (float64_t)(int64_t)v9);
                *v19 = (float64_t)((*(float32_t *)v12 - *v18) / *v8);
                v26 = *(float32_t *)v16;
                v27 = *v18;
                v28 = *v8;
                v29 = _pow(v25, (float64_t)(int64_t)v9);
                v30 = *v19;
                v31 = _exp(v29);
                v32 = *v5;
                v33 = (float64_t)*v8;
                v34 = *v11;
                *(float32_t *)(4 * v34 + v32) = (float32_t)(-0.5 * (v30 + (float64_t)((v26 - v27) / v28)) / (g2 * v33 * v33));
                *v11 = *v11 + 1;
                v35 = *v17 + 1;
                *v17 = v35;
                v23 = (float32_t)v31;
                v36 = *v7;
                v37 = v35 - v36;
                v24 = v23;
                v22 = v23;
                while (v37 < 0 != ((v37 ^ v35) & (v36 ^ v35)) < 0) {
                    // 0x100003004
                    *(float64_t *)(v2 - 112) = 2.0;
                    v25 = _pow((float64_t)v24, (float64_t)(int64_t)v9);
                    *v19 = (float64_t)((*(float32_t *)v12 - *v18) / *v8);
                    v26 = *(float32_t *)v16;
                    v27 = *v18;
                    v28 = *v8;
                    v29 = _pow(v25, (float64_t)(int64_t)v9);
                    v30 = *v19;
                    v31 = _exp(v29);
                    v32 = *v5;
                    v33 = (float64_t)*v8;
                    v34 = *v11;
                    *(float32_t *)(4 * v34 + v32) = (float32_t)(-0.5 * (v30 + (float64_t)((v26 - v27) / v28)) / (g2 * v33 * v33));
                    *v11 = *v11 + 1;
                    v35 = *v17 + 1;
                    *v17 = v35;
                    v23 = (float32_t)v31;
                    v36 = *v7;
                    v37 = v35 - v36;
                    v24 = v23;
                    v22 = v23;
                }
            }
            // 0x1000030c4
            v38 = v22;
            v39 = *v13 + 1;
            *v13 = v39;
            v40 = *v7;
        }
    }
    int64_t v41 = function_100002a0c(); // 0x1000030f4
    *(int64_t *)(v2 - 120) = *(int64_t *)(v2 - 56);
    int64_t result = v41; // 0x100003118
    if (*(int64_t *)*(int64_t *)0x100004020 != *(int64_t *)(v2 - 8)) {
        // 0x100003120
        result = ___stack_chk_fail(v41);
    }
    // 0x100003124
    return result;
}

// Address range: 0x100003138 - 0x100003b60
int64_t function_100003138(void) {
    // 0x100003138
    int128_t v1; // 0x100003138
    int128_t v2 = v1;
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004020; // 0x100003158
    int64_t v4; // 0x100003138
    int32_t v5 = *(int32_t *)(v4 + 4); // 0x100003178
    int32_t v6 = *(int32_t *)(v4 + 8); // 0x100003184
    int32_t v7 = 2 * v5 * v6; // 0x1000031a0
    int64_t v8 = (int64_t)_calloc(v7, 1); // bp-192, 0x1000031b8
    int64_t * v9 = _calloc(v7, 1); // 0x1000031d4
    int64_t * v10 = _calloc(v7, 1); // 0x1000031f8
    int64_t * v11 = _calloc(v7, 1); // 0x10000321c
    int32_t v12 = *(int32_t *)(*(int64_t *)((int64_t)&v8 + 32) + 20); // 0x10000322c
    int64_t * v13 = _malloc(2 * v12); // 0x100003234
    if (v13 == NULL || v11 == NULL || v10 == NULL || v9 == NULL || v8 == 0) {
        int64_t v14 = *(int64_t *)*(int64_t *)0x100004028; // 0x1000032ac
        _fprintf((struct _IO_FILE *)v14, "canny_edge_detection: Failed memory allocation(s).\n");
        _exit(1);
        // UNREACHABLE
    }
    int64_t v15 = (int64_t)v10; // 0x1000031f8
    int64_t v16 = (int64_t)v11; // 0x10000321c
    function_100002ec4();
    int64_t v17; // bp-76, 0x100003138
    _memset(&v17, 0, 36);
    v17 = -0x4010000000000000;
    function_100002a0c();
    int64_t v18; // bp-112, 0x100003138
    _memset(&v18, 0, 36);
    v18 = 0x3ff0000000000000;
    function_100002a0c();
    int32_t v19 = v5 - 1; // 0x1000033d8
    int32_t v20 = 2 - v5;
    int32_t v21; // 0x100003138
    int32_t v22; // 0x100003138
    int32_t v23; // 0x100003138
    int32_t v24; // 0x100003138
    int64_t v25; // 0x100003138
    int64_t v26; // 0x100003138
    int32_t v27; // 0x100003400
    int32_t v28; // 0x1000034fc
    int64_t v29; // 0x100003574
    float64_t v30; // 0x1000035b0
    float32_t v31; // 0x1000035c4
    if (v20 < 0 == (v20 & v19) < 0) {
        int32_t v32 = v6 - 1; // 0x1000038c8
        int32_t v33 = 2 - v6; // 0x1000038cc
        v22 = v33 & v32;
        v21 = v33;
        v23 = v32;
    } else {
        // 0x1000033f8
        v27 = v6 - 1;
        int32_t v34 = 2 - v6; // 0x100003404
        int32_t v35 = v34 & v27; // 0x100003404
        int64_t v36 = v1;
        int32_t v37 = 1;
        int32_t v38 = 1; // 0x10000340c
        int64_t v39 = v36; // 0x10000340c
        int64_t v40 = v36; // 0x10000340c
        int64_t v41; // 0x100003138
        int64_t v42; // 0x100003434
        int16_t v43; // 0x100003438
        float64_t v44; // 0x10000345c
        int32_t v45; // 0x10000347c
        int32_t v46; // 0x100003404
        if (v34 < 0 != v35 < 0) {
            v42 = 2 * (int64_t)(v38 * v5 + v37);
            v43 = *(int16_t *)(v42 + (int64_t)v9);
            v44 = _hypot((float64_t)v39, (float64_t)(int64_t)v2);
            *(int16_t *)(v8 + v42) = v43;
            v45 = v38 + 1;
            v41 = (float32_t)v44;
            v46 = v45 - v27;
            v38 = v45;
            v39 = v41;
            v40 = v41;
            while (v46 < 0 != ((v46 ^ v45) & (v45 ^ v27)) < 0) {
                // 0x100003414
                v42 = 2 * (int64_t)(v38 * v5 + v37);
                v43 = *(int16_t *)(v42 + (int64_t)v9);
                v44 = _hypot((float64_t)v39, (float64_t)(int64_t)v2);
                *(int16_t *)(v8 + v42) = v43;
                v45 = v38 + 1;
                v41 = (float32_t)v44;
                v46 = v45 - v27;
                v38 = v45;
                v39 = v41;
                v40 = v41;
            }
        }
        // 0x10000348c
        v36 = v40;
        int32_t v47 = v37 + 1; // 0x100003490
        int32_t v48 = v47 - v19; // 0x1000033dc
        int32_t v49 = 1; // 0x1000033e4
        int64_t v50 = v36; // 0x1000033e4
        while (v48 < 0 != ((v48 ^ v47) & (v47 ^ v19)) < 0) {
            // 0x1000033f8
            v37 = v47;
            v38 = 1;
            v39 = v36;
            v40 = v36;
            if (v34 < 0 != v35 < 0) {
                v42 = 2 * (int64_t)(v38 * v5 + v37);
                v43 = *(int16_t *)(v42 + (int64_t)v9);
                v44 = _hypot((float64_t)v39, (float64_t)(int64_t)v2);
                *(int16_t *)(v8 + v42) = v43;
                v45 = v38 + 1;
                v41 = (float32_t)v44;
                v46 = v45 - v27;
                v38 = v45;
                v39 = v41;
                v40 = v41;
                while (v46 < 0 != ((v46 ^ v45) & (v45 ^ v27)) < 0) {
                    // 0x100003414
                    v42 = 2 * (int64_t)(v38 * v5 + v37);
                    v43 = *(int16_t *)(v42 + (int64_t)v9);
                    v44 = _hypot((float64_t)v39, (float64_t)(int64_t)v2);
                    *(int16_t *)(v8 + v42) = v43;
                    v45 = v38 + 1;
                    v41 = (float32_t)v44;
                    v46 = v45 - v27;
                    v38 = v45;
                    v39 = v41;
                    v40 = v41;
                }
            }
            // 0x10000348c
            v36 = v40;
            v47 = v37 + 1;
            v48 = v47 - v19;
            v49 = 1;
            v50 = v36;
        }
        while (true) {
            int32_t v51 = v49;
            v24 = 1;
            v25 = v50;
            v26 = v50;
            if (v34 < 0 != v35 < 0) {
                while (true) {
                  lab_0x1000034ec:
                    // 0x1000034ec
                    v28 = v24 * v5 + v51;
                    v29 = 2 * (int64_t)v28;
                    int16_t v52 = *(int16_t *)(v29 + v15); // 0x100003578
                    float64_t v53 = g3; // 0x1000035a4
                    v30 = _fmod(_atan2((float64_t)v25, (float64_t)(int64_t)v2), (float64_t)(int64_t)v2);
                    v31 = 8.0f * (float32_t)((v53 + (float64_t)v52) / v53);
                    if (v31 == 1.0f || v31 > 1.0f) {
                        goto lab_0x1000035fc;
                    } else {
                        if (v31 == 7.0f) {
                            goto lab_0x100003654;
                        } else {
                            if (v31 > 7.0f == v31 >= 7.0f == v31 <= 7.0f) {
                                goto lab_0x1000035fc;
                            } else {
                                goto lab_0x100003654;
                            }
                        }
                    }
                }
            }
          lab_0x100003840:;
            int32_t v54 = v51 + 1; // 0x100003844
            int32_t v55 = v54 - v19; // 0x1000034b4
            v49 = v54;
            v50 = v26;
            v22 = v35;
            v21 = v34;
            v23 = v27;
            if (v55 < 0 == ((v55 ^ v54) & (v54 ^ v19)) < 0) {
                // break -> 0x100003850
                break;
            }
        }
    }
    int64_t result = (int64_t)v13; // 0x100003234
    int64_t v56 = 2 * (int64_t)v5 * (int64_t)v6; // 0x100003870
    ___memset_chk(result, 0, v56, -1);
    ___memset_chk(v15, 0, v56, -1);
    if (v21 < 0 != v22 < 0) {
        int32_t v57 = v4; // 0x100003168
        int32_t v58 = v4; // 0x10000316c
        int32_t v59; // bp-144, 0x100003138
        int64_t v60 = &v59;
        int32_t v61 = 1; // 0x100003af0
        int32_t v62 = 1;
        int32_t v63 = v62; // 0x1000038fc
        int32_t v64 = v62; // 0x1000038fc
        int64_t v65; // 0x100003138
        int32_t v66; // 0x100003138
        int32_t v67; // 0x100003138
        int32_t v68; // 0x100003138
        int32_t v69; // 0x100003138
        int32_t v70; // 0x100003138
        int64_t v71; // 0x10000390c
        int32_t v72; // 0x10000390c
        int32_t v73; // 0x100003914
        int16_t * v74; // 0x10000392c
        int32_t v75; // 0x100003acc
        int32_t v76; // 0x100003adc
        int32_t v77; // 0x1000038f4
        int32_t v78; // 0x100003970
        int32_t * v79; // 0x100003a18
        int64_t v80; // 0x100003a1c
        int32_t v81; // 0x100003a1c
        int32_t v82; // 0x100003a24
        int16_t * v83; // 0x100003a44
        if (v20 < 0 != (v20 & v19) < 0) {
            v66 = v63;
            v71 = 2 * (int64_t)v66;
            v72 = (int32_t)*(int16_t *)(v71 + v16);
            v73 = v72 - v58;
            if (v73 < 0 == ((v73 ^ v72) & (v72 ^ v58)) < 0) {
                // 0x100003924
                v74 = (int16_t *)(v71 + result);
                if (*v74 == 0) {
                    // 0x100003940
                    *v74 = 255;
                    *(int32_t *)v10 = v66;
                    v78 = 0;
                    v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                    v65 = 0;
                    v67 = v78;
                    v79 = (int32_t *)(4 * v65 + v60);
                    v80 = 2 * (int64_t)*v79;
                    v81 = (int32_t)*(int16_t *)(v80 + v16);
                    v82 = v81 - v57;
                    v68 = v67;
                    if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                        // 0x100003a34
                        v83 = (int16_t *)(v80 + result);
                        v68 = v67;
                        if (*v83 == 0) {
                            // 0x100003a58
                            *v83 = 255;
                            *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                            v68 = v67 + 1;
                        }
                    }
                    // 0x100003a9c
                    v69 = v68;
                    v65++;
                    while (v65 != 8) {
                        // 0x100003a0c
                        v67 = v69;
                        v79 = (int32_t *)(4 * v65 + v60);
                        v80 = 2 * (int64_t)*v79;
                        v81 = (int32_t)*(int16_t *)(v80 + v16);
                        v82 = v81 - v57;
                        v68 = v67;
                        if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                            // 0x100003a34
                            v83 = (int16_t *)(v80 + result);
                            v68 = v67;
                            if (*v83 == 0) {
                                // 0x100003a58
                                *v83 = 255;
                                *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                v68 = v67 + 1;
                            }
                        }
                        // 0x100003a9c
                        v69 = v68;
                        v65++;
                    }
                    // 0x100003ab0
                    while (v69 >= 1) {
                        // 0x10000396c
                        v78 = v69 - 1;
                        v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                        v65 = 0;
                        v67 = v78;
                        v79 = (int32_t *)(4 * v65 + v60);
                        v80 = 2 * (int64_t)*v79;
                        v81 = (int32_t)*(int16_t *)(v80 + v16);
                        v82 = v81 - v57;
                        v68 = v67;
                        if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                            // 0x100003a34
                            v83 = (int16_t *)(v80 + result);
                            v68 = v67;
                            if (*v83 == 0) {
                                // 0x100003a58
                                *v83 = 255;
                                *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                v68 = v67 + 1;
                            }
                        }
                        // 0x100003a9c
                        v69 = v68;
                        v65++;
                        while (v65 != 8) {
                            // 0x100003a0c
                            v67 = v69;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                        }
                    }
                }
            }
            // 0x100003ac8
            v75 = v66 + 1;
            v76 = 2;
            v77 = v76 - v19;
            v70 = v76;
            v64 = v75;
            while (v77 < 0 != ((v77 ^ v76) & (v76 ^ v19)) < 0) {
                // 0x100003904
                v66 = v75;
                v71 = 2 * (int64_t)v66;
                v72 = (int32_t)*(int16_t *)(v71 + v16);
                v73 = v72 - v58;
                if (v73 < 0 == ((v73 ^ v72) & (v72 ^ v58)) < 0) {
                    // 0x100003924
                    v74 = (int16_t *)(v71 + result);
                    if (*v74 == 0) {
                        // 0x100003940
                        *v74 = 255;
                        *(int32_t *)v10 = v66;
                        v78 = 0;
                        v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                        v65 = 0;
                        v67 = v78;
                        v79 = (int32_t *)(4 * v65 + v60);
                        v80 = 2 * (int64_t)*v79;
                        v81 = (int32_t)*(int16_t *)(v80 + v16);
                        v82 = v81 - v57;
                        v68 = v67;
                        if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                            // 0x100003a34
                            v83 = (int16_t *)(v80 + result);
                            v68 = v67;
                            if (*v83 == 0) {
                                // 0x100003a58
                                *v83 = 255;
                                *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                v68 = v67 + 1;
                            }
                        }
                        // 0x100003a9c
                        v69 = v68;
                        v65++;
                        while (v65 != 8) {
                            // 0x100003a0c
                            v67 = v69;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                        }
                        // 0x100003ab0
                        while (v69 >= 1) {
                            // 0x10000396c
                            v78 = v69 - 1;
                            v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                            v65 = 0;
                            v67 = v78;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                            while (v65 != 8) {
                                // 0x100003a0c
                                v67 = v69;
                                v79 = (int32_t *)(4 * v65 + v60);
                                v80 = 2 * (int64_t)*v79;
                                v81 = (int32_t)*(int16_t *)(v80 + v16);
                                v82 = v81 - v57;
                                v68 = v67;
                                if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                    // 0x100003a34
                                    v83 = (int16_t *)(v80 + result);
                                    v68 = v67;
                                    if (*v83 == 0) {
                                        // 0x100003a58
                                        *v83 = 255;
                                        *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                        v68 = v67 + 1;
                                    }
                                }
                                // 0x100003a9c
                                v69 = v68;
                                v65++;
                            }
                        }
                    }
                }
                // 0x100003ac8
                v75 = v66 + 1;
                v76 = v70 + 1;
                v77 = v76 - v19;
                v70 = v76;
                v64 = v75;
            }
        }
        // 0x100003aec
        v62 = v64;
        v61++;
        while (v61 - v23 < 0 != ((v61 - v23 ^ v61) & (v61 ^ v23)) < 0) {
            // 0x1000038e8
            v63 = v62;
            v64 = v62;
            if (v20 < 0 != (v20 & v19) < 0) {
                v66 = v63;
                v71 = 2 * (int64_t)v66;
                v72 = (int32_t)*(int16_t *)(v71 + v16);
                v73 = v72 - v58;
                if (v73 < 0 == ((v73 ^ v72) & (v72 ^ v58)) < 0) {
                    // 0x100003924
                    v74 = (int16_t *)(v71 + result);
                    if (*v74 == 0) {
                        // 0x100003940
                        *v74 = 255;
                        *(int32_t *)v10 = v66;
                        v78 = 0;
                        v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                        v65 = 0;
                        v67 = v78;
                        v79 = (int32_t *)(4 * v65 + v60);
                        v80 = 2 * (int64_t)*v79;
                        v81 = (int32_t)*(int16_t *)(v80 + v16);
                        v82 = v81 - v57;
                        v68 = v67;
                        if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                            // 0x100003a34
                            v83 = (int16_t *)(v80 + result);
                            v68 = v67;
                            if (*v83 == 0) {
                                // 0x100003a58
                                *v83 = 255;
                                *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                v68 = v67 + 1;
                            }
                        }
                        // 0x100003a9c
                        v69 = v68;
                        v65++;
                        while (v65 != 8) {
                            // 0x100003a0c
                            v67 = v69;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                        }
                        // 0x100003ab0
                        while (v69 >= 1) {
                            // 0x10000396c
                            v78 = v69 - 1;
                            v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                            v65 = 0;
                            v67 = v78;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                            while (v65 != 8) {
                                // 0x100003a0c
                                v67 = v69;
                                v79 = (int32_t *)(4 * v65 + v60);
                                v80 = 2 * (int64_t)*v79;
                                v81 = (int32_t)*(int16_t *)(v80 + v16);
                                v82 = v81 - v57;
                                v68 = v67;
                                if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                    // 0x100003a34
                                    v83 = (int16_t *)(v80 + result);
                                    v68 = v67;
                                    if (*v83 == 0) {
                                        // 0x100003a58
                                        *v83 = 255;
                                        *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                        v68 = v67 + 1;
                                    }
                                }
                                // 0x100003a9c
                                v69 = v68;
                                v65++;
                            }
                        }
                    }
                }
                // 0x100003ac8
                v75 = v66 + 1;
                v76 = 2;
                v77 = v76 - v19;
                v70 = v76;
                v64 = v75;
                while (v77 < 0 != ((v77 ^ v76) & (v76 ^ v19)) < 0) {
                    // 0x100003904
                    v66 = v75;
                    v71 = 2 * (int64_t)v66;
                    v72 = (int32_t)*(int16_t *)(v71 + v16);
                    v73 = v72 - v58;
                    if (v73 < 0 == ((v73 ^ v72) & (v72 ^ v58)) < 0) {
                        // 0x100003924
                        v74 = (int16_t *)(v71 + result);
                        if (*v74 == 0) {
                            // 0x100003940
                            *v74 = 255;
                            *(int32_t *)v10 = v66;
                            v78 = 0;
                            v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                            v65 = 0;
                            v67 = v78;
                            v79 = (int32_t *)(4 * v65 + v60);
                            v80 = 2 * (int64_t)*v79;
                            v81 = (int32_t)*(int16_t *)(v80 + v16);
                            v82 = v81 - v57;
                            v68 = v67;
                            if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                // 0x100003a34
                                v83 = (int16_t *)(v80 + result);
                                v68 = v67;
                                if (*v83 == 0) {
                                    // 0x100003a58
                                    *v83 = 255;
                                    *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                    v68 = v67 + 1;
                                }
                            }
                            // 0x100003a9c
                            v69 = v68;
                            v65++;
                            while (v65 != 8) {
                                // 0x100003a0c
                                v67 = v69;
                                v79 = (int32_t *)(4 * v65 + v60);
                                v80 = 2 * (int64_t)*v79;
                                v81 = (int32_t)*(int16_t *)(v80 + v16);
                                v82 = v81 - v57;
                                v68 = v67;
                                if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                    // 0x100003a34
                                    v83 = (int16_t *)(v80 + result);
                                    v68 = v67;
                                    if (*v83 == 0) {
                                        // 0x100003a58
                                        *v83 = 255;
                                        *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                        v68 = v67 + 1;
                                    }
                                }
                                // 0x100003a9c
                                v69 = v68;
                                v65++;
                            }
                            // 0x100003ab0
                            while (v69 >= 1) {
                                // 0x10000396c
                                v78 = v69 - 1;
                                v59 = *(int32_t *)(4 * (int64_t)v78 + v15) - v5;
                                v65 = 0;
                                v67 = v78;
                                v79 = (int32_t *)(4 * v65 + v60);
                                v80 = 2 * (int64_t)*v79;
                                v81 = (int32_t)*(int16_t *)(v80 + v16);
                                v82 = v81 - v57;
                                v68 = v67;
                                if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                    // 0x100003a34
                                    v83 = (int16_t *)(v80 + result);
                                    v68 = v67;
                                    if (*v83 == 0) {
                                        // 0x100003a58
                                        *v83 = 255;
                                        *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                        v68 = v67 + 1;
                                    }
                                }
                                // 0x100003a9c
                                v69 = v68;
                                v65++;
                                while (v65 != 8) {
                                    // 0x100003a0c
                                    v67 = v69;
                                    v79 = (int32_t *)(4 * v65 + v60);
                                    v80 = 2 * (int64_t)*v79;
                                    v81 = (int32_t)*(int16_t *)(v80 + v16);
                                    v82 = v81 - v57;
                                    v68 = v67;
                                    if (v82 < 0 == ((v82 ^ v81) & (v81 ^ v57)) < 0) {
                                        // 0x100003a34
                                        v83 = (int16_t *)(v80 + result);
                                        v68 = v67;
                                        if (*v83 == 0) {
                                            // 0x100003a58
                                            *v83 = 255;
                                            *(int32_t *)(4 * (int64_t)v67 + v15) = *v79;
                                            v68 = v67 + 1;
                                        }
                                    }
                                    // 0x100003a9c
                                    v69 = v68;
                                    v65++;
                                }
                            }
                        }
                    }
                    // 0x100003ac8
                    v75 = v66 + 1;
                    v76 = v70 + 1;
                    v77 = v76 - v19;
                    v70 = v76;
                    v64 = v75;
                }
            }
            // 0x100003aec
            v62 = v64;
            v61++;
        }
    }
    // 0x100003afc
    _free(v9);
    _free(v10);
    _free((int64_t *)v8);
    _free(v11);
    if (*(int64_t *)*(int64_t *)0x100004020 != v3) {
        // 0x100003b48
        ___stack_chk_fail((int64_t)&g5);
    }
    // 0x100003b4c
    return result;
  lab_0x1000035fc:;
    int16_t v84 = *(int16_t *)(v8 + v29); // 0x100003608
    int32_t v85 = v84; // 0x100003608
    int16_t v86 = *(int16_t *)(v8 + 2 * (int64_t)(v28 - 1)); // 0x100003614
    int32_t v87 = v85 - (int32_t)v86; // 0x100003618
    int16_t v88; // 0x100003138
    if (v87 == 0 || v87 < 0 != ((v87 ^ v85) & (int32_t)(v86 ^ v84)) < 0) {
        goto lab_0x100003654;
    } else {
        int16_t v89 = *(int16_t *)(v8 + 2 * (int64_t)(v28 + 1)); // 0x100003640
        int32_t v90 = v85 - (int32_t)v89; // 0x100003644
        v88 = v84;
        if (v90 == 0 || v90 < 0 != ((v90 ^ v85) & (int32_t)(v89 ^ v84)) < 0) {
            goto lab_0x100003654;
        } else {
            // 0x1000037ec
            *(int16_t *)(v29 + v16) = v88;
            goto lab_0x10000382c;
        }
    }
  lab_0x100003654:;
    int32_t v91 = v28 - v5; // 0x10000350c
    int32_t v92 = v28 + v5; // 0x10000351c
    if (v31 == 1.0f) {
        goto lab_0x1000036dc;
    } else {
        if (v31 > 1.0f == v31 >= 1.0f == v31 <= 1.0f) {
            if (v31 <= 3.0f == (v31 != 3.0f)) {
                goto lab_0x1000036dc;
            } else {
                int16_t v93 = *(int16_t *)(v8 + v29); // 0x100003690
                int32_t v94 = v93; // 0x100003690
                int16_t v95 = *(int16_t *)(v8 + 2 * (int64_t)(v91 + 1)); // 0x10000369c
                int32_t v96 = v94 - (int32_t)v95; // 0x1000036a0
                if (v96 == 0 || v96 < 0 != ((v96 ^ v94) & (int32_t)(v95 ^ v93)) < 0) {
                    goto lab_0x1000036dc;
                } else {
                    int16_t v97 = *(int16_t *)(v8 + 2 * (int64_t)(v92 - 1)); // 0x1000036c8
                    int32_t v98 = v94 - (int32_t)v97; // 0x1000036cc
                    v88 = v93;
                    if (v98 == 0 || v98 < 0 != ((v98 ^ v94) & (int32_t)(v97 ^ v93)) < 0) {
                        goto lab_0x1000036dc;
                    } else {
                        // 0x1000037ec
                        *(int16_t *)(v29 + v16) = v88;
                        goto lab_0x10000382c;
                    }
                }
            }
        } else {
            goto lab_0x1000036dc;
        }
    }
  lab_0x1000036dc:
    if (v31 == 3.0f) {
        goto lab_0x100003764;
    } else {
        if (v31 > 3.0f == v31 >= 3.0f == v31 <= 3.0f) {
            if (v31 <= 5.0f == (v31 != 5.0f)) {
                goto lab_0x100003764;
            } else {
                int16_t v99 = *(int16_t *)(v8 + v29); // 0x100003718
                int32_t v100 = v99; // 0x100003718
                int16_t v101 = *(int16_t *)(v8 + 2 * (int64_t)v91); // 0x100003724
                int32_t v102 = v100 - (int32_t)v101; // 0x100003728
                if (v102 == 0 || v102 < 0 != ((v102 ^ v100) & (int32_t)(v101 ^ v99)) < 0) {
                    goto lab_0x100003764;
                } else {
                    int16_t v103 = *(int16_t *)(v8 + 2 * (int64_t)v92); // 0x100003750
                    int32_t v104 = v100 - (int32_t)v103; // 0x100003754
                    v88 = v99;
                    if (v104 == 0 || v104 < 0 != ((v104 ^ v100) & (int32_t)(v103 ^ v99)) < 0) {
                        goto lab_0x100003764;
                    } else {
                        // 0x1000037ec
                        *(int16_t *)(v29 + v16) = v88;
                        goto lab_0x10000382c;
                    }
                }
            }
        } else {
            goto lab_0x100003764;
        }
    }
  lab_0x100003764:
    if (v31 == 5.0f) {
        // 0x100003814
        *(int16_t *)(v29 + v16) = 0;
        goto lab_0x10000382c;
    } else {
        if (v31 > 5.0f == v31 >= 5.0f == v31 <= 5.0f) {
            if (v31 <= 7.0f == (v31 != 7.0f)) {
                // 0x100003814
                *(int16_t *)(v29 + v16) = 0;
                goto lab_0x10000382c;
            } else {
                int16_t v105 = *(int16_t *)(v8 + v29); // 0x1000037a0
                int32_t v106 = v105; // 0x1000037a0
                int16_t v107 = *(int16_t *)(v8 + 2 * (int64_t)(v91 - 1)); // 0x1000037ac
                int32_t v108 = v106 - (int32_t)v107; // 0x1000037b0
                if (v108 == 0 || v108 < 0 != ((v108 ^ v106) & (int32_t)(v107 ^ v105)) < 0) {
                    // 0x100003814
                    *(int16_t *)(v29 + v16) = 0;
                    goto lab_0x10000382c;
                } else {
                    int16_t v109 = *(int16_t *)(v8 + 2 * (int64_t)(v92 + 1)); // 0x1000037d8
                    int32_t v110 = v106 - (int32_t)v109; // 0x1000037dc
                    v88 = v105;
                    if (v110 == 0 || v110 < 0 != ((v110 ^ v106) & (int32_t)(v109 ^ v105)) < 0) {
                        // 0x100003814
                        *(int16_t *)(v29 + v16) = 0;
                        goto lab_0x10000382c;
                    } else {
                        // 0x1000037ec
                        *(int16_t *)(v29 + v16) = v88;
                        goto lab_0x10000382c;
                    }
                }
            }
        } else {
            // 0x100003814
            *(int16_t *)(v29 + v16) = 0;
            goto lab_0x10000382c;
        }
    }
  lab_0x10000382c:;
    int32_t v111 = v24 + 1; // 0x100003830
    int64_t v112 = (float32_t)v30;
    int32_t v113 = v111 - v27; // 0x1000034dc
    v24 = v111;
    v25 = v112;
    v26 = v112;
    if (v113 < 0 == ((v113 ^ v111) & (v111 ^ v27)) < 0) {
        // break -> 0x100003840
        goto lab_0x100003840;
    }
    goto lab_0x1000034ec;
}

// Address range: 0x100003b60 - 0x100003d04
int64_t entry_point(void) {
    // 0x100003b60
    int64_t v1; // 0x100003b60
    int32_t v2 = v1; // 0x100003b70
    if (v2 < 2 != (1 - v2 & v2) < 0) {
        // 0x100003b8c
        _printf("Usage: %s image.bmp\n", (char *)v1);
        // 0x100003cf4
        return 1;
    }
    int64_t v3 = function_100002310(); // 0x100003bc4
    if (v3 == 0) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004028; // 0x100003be8
        _fprintf((struct _IO_FILE *)v4, "main: BMP image not loaded.\n");
        // 0x100003cf4
        return 1;
    }
    // 0x100003c04
    _printf("Info: %d x %d x %d\n", (int64_t)&g4, v1, v1);
    int64_t v5 = function_100003138(); // 0x100003c58
    if (v5 == 0) {
        int64_t v6 = *(int64_t *)*(int64_t *)0x100004028; // 0x100003c7c
        _fprintf((struct _IO_FILE *)v6, "main: failed canny_edge_detection.\n");
        // 0x100003cf4
        return 1;
    }
    // 0x100003c98
    int64_t result; // 0x100003b60
    if (function_100002638() % 2 == 0) {
        // 0x100003cdc
        _free((int64_t *)v3);
        _free((int64_t *)v5);
        result = 0;
    } else {
        int64_t v7 = *(int64_t *)*(int64_t *)0x100004028; // 0x100003cc0
        _fprintf((struct _IO_FILE *)v7, "main: BMP image not saved.\n");
        result = 1;
    }
    // 0x100003cf4
    return result;
}

// Address range: 0x100003d04 - 0x100003d10
int64_t function_100003d04(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003d04
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003d10 - 0x100003d1c
int64_t function_100003d10(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003d10
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003d1c - 0x100003d28
int64_t function_100003d1c(int64_t a1) {
    // 0x100003d1c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003d28 - 0x100003d34
float64_t function_100003d28(float64_t a1, float64_t a2) {
    // 0x100003d28
    return _atan2(a1, a2);
}

// Address range: 0x100003d34 - 0x100003d40
int64_t * function_100003d34(int32_t nmemb, int32_t size) {
    // 0x100003d34
    return _calloc(nmemb, size);
}

// Address range: 0x100003d40 - 0x100003d4c
void function_100003d40(int32_t status) {
    // 0x100003d40
    _exit(status);
}

// Address range: 0x100003d4c - 0x100003d58
float64_t function_100003d4c(float64_t a1) {
    // 0x100003d4c
    return _exp(a1);
}

// Address range: 0x100003d58 - 0x100003d64
int32_t function_100003d58(struct _IO_FILE * stream) {
    // 0x100003d58
    return _fclose(stream);
}

// Address range: 0x100003d64 - 0x100003d70
float64_t function_100003d64(float64_t a1, float64_t a2) {
    // 0x100003d64
    return _fmod(a1, a2);
}

// Address range: 0x100003d70 - 0x100003d7c
struct _IO_FILE * function_100003d70(char * filename, char * modes) {
    // 0x100003d70
    return _fopen(filename, modes);
}

// Address range: 0x100003d7c - 0x100003d88
int32_t function_100003d7c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003d7c
    return _fprintf(stream, format);
}

// Address range: 0x100003d88 - 0x100003d94
int32_t function_100003d88(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003d88
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003d94 - 0x100003da0
void function_100003d94(int64_t * ptr) {
    // 0x100003d94
    _free(ptr);
}

// Address range: 0x100003da0 - 0x100003dac
int32_t function_100003da0(struct _IO_FILE * stream, int32_t off, int32_t whence) {
    // 0x100003da0
    return _fseek(stream, off, whence);
}

// Address range: 0x100003dac - 0x100003db8
int32_t function_100003dac(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003dac
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003db8 - 0x100003dc4
float64_t function_100003db8(float64_t a1, float64_t a2) {
    // 0x100003db8
    return _hypot(a1, a2);
}

// Address range: 0x100003dc4 - 0x100003dd0
int64_t * function_100003dc4(int32_t size) {
    // 0x100003dc4
    return _malloc(size);
}

// Address range: 0x100003dd0 - 0x100003ddc
int64_t * function_100003dd0(int64_t * s, int32_t c, int32_t n) {
    // 0x100003dd0
    return _memset(s, c, n);
}

// Address range: 0x100003ddc - 0x100003de8
void function_100003ddc(char * s) {
    // 0x100003ddc
    _perror(s);
}

// Address range: 0x100003de8 - 0x100003df4
float64_t function_100003de8(float64_t a1, float64_t a2) {
    // 0x100003de8
    return _pow(a1, a2);
}

// Address range: 0x100003df4 - 0x100003e00
int32_t function_100003df4(char * format, ...) {
    // 0x100003df4
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 28

`
`#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct bit_array_tag {
    uint32_t size;
    uint32_t* array;
} bit_array;

bool bit_array_create(bit_array* b, uint32_t size) {
    uint32_t* array = calloc((size + 31)/32, sizeof(uint32_t));
    if (array == NULL)
        return false;
    b->size = size;
    b->array = array;
    return true;
}

void bit_array_destroy(bit_array* b) {
    free(b->array);
    b->array = NULL;
}

void bit_array_set(bit_array* b, uint32_t index, bool value) {
    assert(index < b->size);
    uint32_t* p = &b->array[index >> 5];
    uint32_t bit = 1 << (index & 31);
    if (value)
        *p |= bit;
    else
        *p &= ~bit;
}

bool bit_array_get(const bit_array* b, uint32_t index) {
    assert(index < b->size);
    uint32_t bit = 1 << (index & 31);
    return (b->array[index >> 5] & bit) != 0;
}

typedef struct sieve_tag {
    uint32_t limit;
    bit_array not_prime;
} sieve;

bool sieve_create(sieve* s, uint32_t limit) {
    if (!bit_array_create(&s->not_prime, limit + 1))
        return false;
    bit_array_set(&s->not_prime, 0, true);
    bit_array_set(&s->not_prime, 1, true);
    for (uint32_t p = 2; p * p <= limit; ++p) {
        if (bit_array_get(&s->not_prime, p) == false) {
            for (uint32_t q = p * p; q <= limit; q += p)
                bit_array_set(&s->not_prime, q, true);
        }
    }
    s->limit = limit;
    return true;
}

void sieve_destroy(sieve* s) {
    bit_array_destroy(&s->not_prime);
}

bool is_prime(const sieve* s, uint32_t n) {
    assert(n <= s->limit);
    return bit_array_get(&s->not_prime, n) == false;
}

bool find_prime_partition(const sieve* s, uint32_t number, uint32_t count,
                          uint32_t min_prime, uint32_t* p) {
    if (count == 1) {
        if (number >= min_prime && is_prime(s, number)) {
            *p = number;
            return true;
        }
        return false;
    }
    for (uint32_t prime = min_prime; prime < number; ++prime) {
        if (!is_prime(s, prime))
            continue;
        if (find_prime_partition(s, number - prime, count - 1,
                                 prime + 1, p + 1)) {
            *p = prime;
            return true;
        }
    }
    return false;
}

void print_prime_partition(const sieve* s, uint32_t number, uint32_t count) {
    assert(count > 0);
    uint32_t* primes = malloc(count * sizeof(uint32_t));
    if (primes == NULL) {
        fprintf(stderr, "Out of memory\n");
        return;
    }
    if (!find_prime_partition(s, number, count, 2, primes)) {
        printf("%u cannot be partitioned into %u primes.\n", number, count);
    } else {
        printf("%u = %u", number, primes[0]);
        for (uint32_t i = 1; i < count; ++i)
            printf(" + %u", primes[i]);
        printf("\n");
    }
    free(primes);
}

int main() {
    const uint32_t limit = 100000;
    sieve s = { 0 };
    if (!sieve_create(&s, limit)) {
        fprintf(stderr, "Out of memory\n");
        return 1;
    }
    print_prime_partition(&s, 99809, 1);
    print_prime_partition(&s, 18, 2);
    print_prime_partition(&s, 19, 3);
    print_prime_partition(&s, 20, 4);
    print_prime_partition(&s, 2017, 24);
    print_prime_partition(&s, 22699, 1);
    print_prime_partition(&s, 22699, 2);
    print_prime_partition(&s, 22699, 3);
    print_prime_partition(&s, 22699, 4);
    print_prime_partition(&s, 40355, 3);
    sieve_destroy(&s);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000035ec(void);
int64_t function_10000368c(int64_t a1);
int64_t function_1000036bc(void);
int64_t function_10000379c(void);
int64_t function_100003840(void);
int64_t function_1000039ac(int64_t a1);
int64_t function_1000039d4(void);
int64_t function_100003a5c(void);
int64_t function_100003bbc(void);
int64_t function_100003e8c(char * a1, char * a2, int64_t a3, char * a4);
int64_t * function_100003e98(int32_t nmemb, int32_t size);
int32_t function_100003ea4(struct _IO_FILE * stream, char * format, ...);
void function_100003eb0(int64_t * ptr);
int64_t * function_100003ebc(int32_t size);
int32_t function_100003ec8(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000035ec - 0x10000368c
int64_t function_1000035ec(void) {
    // 0x1000035ec
    int64_t v1; // 0x1000035ec
    int32_t v2 = v1; // 0x1000035fc
    int64_t * v3 = _calloc((v2 + 31) / 32, 4); // 0x10000361c
    int64_t result = 0; // 0x100003630
    if (v3 != NULL) {
        // 0x10000364c
        *(int32_t *)v1 = v2;
        *(int64_t *)(v1 + 8) = (int64_t)v3;
        result = 1;
    }
    // 0x100003678
    return result;
}

// Address range: 0x10000368c - 0x1000036bc
int64_t function_10000368c(int64_t a1) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x1000036a0
    _free((int64_t *)*v1);
    *v1 = 0;
    return &g1;
}

// Address range: 0x1000036bc - 0x10000379c
int64_t function_1000036bc(void) {
    // 0x1000036bc
    int64_t v1; // 0x1000036bc
    uint32_t v2 = (int32_t)v1; // 0x1000036cc
    int64_t result; // 0x1000036bc
    if ((int32_t)v1 <= v2) {
        // 0x100003704
        result = ___assert_rtn("bit_array_set", "partition-an-integer-x-into-n-primes.c", 27, "index < b->size");
    }
    int32_t * v3 = (int32_t *)(*(int64_t *)(v1 + 8) + (v1 / 8 & 0x1ffffffc)); // 0x10000373c
    int32_t v4 = 1 << v2 % 32; // 0x10000374c
    int32_t v5 = *v3;
    *v3 = (uint64_t)v1 % 2 == 0 ? v5 & -1 - v4 : v5 | v4;
    return result;
}

// Address range: 0x10000379c - 0x100003840
int64_t function_10000379c(void) {
    // 0x10000379c
    int64_t v1; // 0x10000379c
    uint64_t v2 = v1;
    uint32_t v3 = (int32_t)v2; // 0x1000037ac
    if ((int32_t)v1 <= v3) {
        // 0x1000037d8
        ___assert_rtn("bit_array_get", "partition-an-integer-x-into-n-primes.c", 37, "index < b->size");
    }
    int32_t v4 = *(int32_t *)(*(int64_t *)(v1 + 8) + (v2 / 8 & 0x1ffffffc)); // 0x100003820
    return (v4 & 1 << v3 % 32) != 0;
}

// Address range: 0x100003840 - 0x1000039ac
int64_t function_100003840(void) {
    // 0x100003840
    if (function_1000035ec() % 2 == 0) {
        // 0x100003998
        return 0;
    }
    // 0x100003884
    int64_t v1; // 0x100003840
    uint32_t v2 = (int32_t)v1; // 0x100003850
    function_1000036bc();
    function_1000036bc();
    if (v2 <= 4 == (v2 != 4)) {
        // 0x100003978
        *(int32_t *)v1 = v2;
        // 0x100003998
        return 1;
    }
    int32_t v3 = 2;
    int32_t v4; // 0x100003840
    int32_t v5; // 0x100003840
    int32_t v6; // 0x100003954
    if (function_10000379c() % 2 == 0) {
        // 0x100003918
        v4 = 4;
        v5 = v4;
        if (v4 >= v2 != v4 != v2) {
            function_1000036bc();
            v6 = v5 + v3;
            v5 = v6;
            while (v6 >= v2 != v6 != v2) {
                // 0x100003930
                function_1000036bc();
                v6 = v5 + v3;
                v5 = v6;
            }
        }
    }
    int32_t v7 = v3 + 1; // 0x10000396c
    int32_t v8 = v7 * v7; // 0x1000038cc
    int32_t v9 = v8; // 0x1000038dc
    while (v8 >= v2 != v8 != v2) {
        // 0x1000038e4
        v3 = v7;
        if (function_10000379c() % 2 == 0) {
            // 0x100003918
            v4 = v9;
            v5 = v4;
            if (v4 >= v2 != v4 != v2) {
                function_1000036bc();
                v6 = v5 + v3;
                v5 = v6;
                while (v6 >= v2 != v6 != v2) {
                    // 0x100003930
                    function_1000036bc();
                    v6 = v5 + v3;
                    v5 = v6;
                }
            }
        }
        // 0x100003968
        v7 = v3 + 1;
        v8 = v7 * v7;
        v9 = v8;
    }
    // 0x100003978
    *(int32_t *)v1 = v2;
    // 0x100003998
    return 1;
}

// Address range: 0x1000039ac - 0x1000039d4
int64_t function_1000039ac(int64_t a1) {
    // 0x1000039ac
    return function_10000368c(a1 + 8);
}

// Address range: 0x1000039d4 - 0x100003a5c
int64_t function_1000039d4(void) {
    // 0x1000039d4
    int64_t v1; // 0x1000039d4
    uint32_t v2 = (int32_t)v1; // 0x1000039e4
    uint32_t v3 = (int32_t)v1;
    if (v3 <= v2 == (v3 != v2)) {
        // 0x100003a10
        ___assert_rtn("is_prime", "partition-an-integer-x-into-n-primes.c", 67, "n <= s->limit");
    }
    // 0x100003a34
    return function_10000379c() % 2 == 0;
}

// Address range: 0x100003a5c - 0x100003bbc
int64_t function_100003a5c(void) {
    // 0x100003a5c
    int64_t v1; // 0x100003a5c
    uint32_t v2 = (int32_t)v1; // 0x100003a6c
    uint32_t v3 = (int32_t)v1; // 0x100003a74
    int32_t * v4 = (int32_t *)v1; // 0x100003a78
    int64_t result; // 0x100003a5c
    if ((int32_t)v1 == 1) {
        // 0x100003a90
        if (v2 < v3) {
            // 0x100003ba8
            return 0;
        }
        // 0x100003aa8
        result = 0;
        if (function_1000039d4() % 2 != 0) {
            // 0x100003abc
            *v4 = v2;
            result = 1;
        }
    } else {
        // 0x100003afc
        if (v3 >= v2) {
            // 0x100003ba8
            return 0;
        }
        // 0x100003afc
        if (function_1000039d4() % 2 != 0) {
            // 0x100003b2c
            if (function_100003a5c() % 2 != 0) {
                // 0x100003b60
                *v4 = v3;
                result = 1;
                return result;
            }
        }
        int32_t v5 = v3 + 1; // 0x100003b88
        result = 0;
        while (v5 < v2) {
            int32_t v6 = v5;
            if (function_1000039d4() % 2 != 0) {
                // 0x100003b2c
                if (function_100003a5c() % 2 != 0) {
                    // 0x100003b60
                    *v4 = v6;
                    result = 1;
                    return result;
                }
            }
            // 0x100003b84
            v5 = v6 + 1;
            result = 0;
        }
    }
  lab_0x100003ba8:
    // 0x100003ba8
    return result;
}

// Address range: 0x100003bbc - 0x100003d54
int64_t function_100003bbc(void) {
    // 0x100003bbc
    int64_t v1; // 0x100003bbc
    uint32_t v2 = (int32_t)v1; // 0x100003bd0
    if (v2 == 0) {
        // 0x100003bf4
        ___assert_rtn("print_prime_partition", "partition-an-integer-x-into-n-primes.c", 93, "count > 0");
    }
    int64_t * v3 = _malloc(4 * v2); // 0x100003c20
    if (v3 == NULL) {
        int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003c44
        // 0x100003d48
        return _fprintf((struct _IO_FILE *)v4, "Out of memory\n");
    }
    int32_t v5 = v1;
    if (function_100003a5c() % 2 == 0) {
        // 0x100003c78
        _printf("%u cannot be partitioned into %u primes.\n", v5, v2);
        // 0x100003d3c
        _free(v3);
        // 0x100003d48
        return &g1;
    }
    // 0x100003ca4
    _printf("%u = %u", v5, v2);
    int32_t v6 = 1; // 0x100003cec
    if (v2 > 1) {
        _printf(" + %u", v5);
        v6++;
        while (v6 != v2) {
            // 0x100003cf4
            _printf(" + %u", v5);
            v6++;
        }
    }
    // 0x100003d2c
    _printf((char *)0x100003fa5);
    // 0x100003d3c
    _free(v3);
    // 0x100003d48
    return &g1;
}

// Address range: 0x100003d54 - 0x100003e8c
int64_t entry_point(void) {
    int64_t v1 = 0; // bp-48, 0x100003d74
    int64_t result; // 0x100003d54
    if (function_100003840() % 2 == 0) {
        // 0x100003d8c
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004008, "Out of memory\n");
        result = 1;
    } else {
        // 0x100003db0
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_100003bbc();
        function_1000039ac((int64_t)&v1);
        result = 0;
    }
    // 0x100003e7c
    return result;
}

// Address range: 0x100003e8c - 0x100003e98
int64_t function_100003e8c(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003e8c
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int32_t nmemb, int32_t size) {
    // 0x100003e98
    return _calloc(nmemb, size);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ea4
    return _fprintf(stream, format);
}

// Address range: 0x100003eb0 - 0x100003ebc
void function_100003eb0(int64_t * ptr) {
    // 0x100003eb0
    _free(ptr);
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t * function_100003ebc(int32_t size) {
    // 0x100003ebc
    return _malloc(size);
}

// Address range: 0x100003ec8 - 0x100003ed4
int32_t function_100003ec8(char * format, ...) {
    // 0x100003ec8
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>
#include <string.h>

typedef struct { unsigned char r, g, b; } rgb_t;
typedef struct {
	int w, h;
	rgb_t **pix;
} image_t, *image;

typedef struct {
	int r[256], g[256], b[256];
	int n;
} color_histo_t;

int write_ppm(image im, char *fn)
{
	FILE *fp = fopen(fn, "w");
	if (!fp) return 0;
	fprintf(fp, "P6\n%d %d\n255\n", im->w, im->h);
	fwrite(im->pix[0], 1, sizeof(rgb_t) * im->w * im->h, fp);
	fclose(fp);
	return 1;
}

image img_new(int w, int h)
{
	int i;
	image im = malloc(sizeof(image_t) + h * sizeof(rgb_t*)
			+ sizeof(rgb_t) * w * h);
	im->w = w; im->h = h;
	im->pix = (rgb_t**)(im + 1);
	for (im->pix[0] = (rgb_t*)(im->pix + h), i = 1; i < h; i++)
		im->pix[i] = im->pix[i - 1] + w;
	return im;
}

int read_num(FILE *f)
{
	int n;
	while (!fscanf(f, "%d ", &n)) {
		if ((n = fgetc(f)) == '#') {
			while ((n = fgetc(f)) != '\n')
				if (n == EOF) break;
			if (n == '\n') continue;
		} else return 0;
	}
	return n;
}

image read_ppm(char *fn)
{
	FILE *fp = fopen(fn, "r");
	int w, h, maxval;
	image im = 0;
	if (!fp) return 0;

	if (fgetc(fp) != 'P' || fgetc(fp) != '6' || !isspace(fgetc(fp)))
		goto bail;

	w = read_num(fp);
	h = read_num(fp);
	maxval = read_num(fp);
	if (!w || !h || !maxval) goto bail;

	im = img_new(w, h);
	fread(im->pix[0], 1, sizeof(rgb_t) * w * h, fp);
bail:
	if (fp) fclose(fp);
	return im;
}

void del_pixels(image im, int row, int col, int size, color_histo_t *h)
{
	int i;
	rgb_t *pix;

	if (col < 0 || col >= im->w) return;
	for (i = row - size; i <= row + size && i < im->h; i++) {
		if (i < 0) continue;
		pix = im->pix[i] + col;
		h->r[pix->r]--;
		h->g[pix->g]--;
		h->b[pix->b]--;
		h->n--;
	}
}

void add_pixels(image im, int row, int col, int size, color_histo_t *h)
{
	int i;
	rgb_t *pix;

	if (col < 0 || col >= im->w) return;
	for (i = row - size; i <= row + size && i < im->h; i++) {
		if (i < 0) continue;
		pix = im->pix[i] + col;
		h->r[pix->r]++;
		h->g[pix->g]++;
		h->b[pix->b]++;
		h->n++;
	}
}

void init_histo(image im, int row, int size, color_histo_t*h)
{
	int j;

	memset(h, 0, sizeof(color_histo_t));

	for (j = 0; j < size && j < im->w; j++)
		add_pixels(im, row, j, size, h);
}

int median(const int *x, int n)
{
	int i;
	for (n /= 2, i = 0; i < 256 && (n -= x[i]) > 0; i++);
	return i;
}

void median_color(rgb_t *pix, const color_histo_t *h)
{
	pix->r = median(h->r, h->n);
	pix->g = median(h->g, h->n);
	pix->b = median(h->b, h->n);
}

image median_filter(image in, int size)
{
	int row, col;
	image out = img_new(in->w, in->h);
	color_histo_t h;

	for (row = 0; row < in->h; row ++) {
		for (col = 0; col < in->w; col++) {
			if (!col) init_histo(in, row, size, &h);
			else {
				del_pixels(in, row, col - size, size, &h);
				add_pixels(in, row, col + size, size, &h);
			}
			median_color(out->pix[row] + col, &h);
		}
	}

	return out;
}

int main(int c, char **v)
{
	int size;
	image in, out;
	if (c <= 3) {
		printf("Usage: %s size ppm_in ppm_out\n", v[0]);
		return 0;
	}
	size = atoi(v[1]);
	printf("filter size %d\n", size);
	if (size < 0) size = 1;

	in = read_ppm(v[2]);
	out = median_filter(in, size);
	write_ppm(out, v[3]);
	free(in);
	free(out);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003374(void);
int64_t function_100003444(void);
int64_t function_100003544(void);
int64_t function_100003620(void);
int64_t function_100003794(void);
int64_t function_100003908(void);
int64_t function_100003a7c(void);
int64_t function_100003b34(void);
int64_t function_100003bc8(void);
int64_t function_100003c38(void);
int64_t function_100003ea4(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003eb0(char * nptr);
int32_t function_100003ebc(struct _IO_FILE * stream);
int32_t function_100003ec8(struct _IO_FILE * stream);
struct _IO_FILE * function_100003ed4(char * filename, char * modes);
int32_t function_100003ee0(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003eec(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void function_100003ef8(int64_t * ptr);
int32_t function_100003f04(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f10(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int32_t function_100003f1c(int32_t c);
int64_t * function_100003f28(int32_t size);
int32_t function_100003f34(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _atoi(char * a1);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int32_t _isspace(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003374 - 0x100003444
int64_t function_100003374(void) {
    // 0x100003374
    int64_t v1; // 0x100003374
    int64_t v2 = v1;
    struct _IO_FILE * v3 = _fopen((char *)v1, "w"); // 0x100003394
    int64_t result = 0; // 0x1000033a8
    if (v3 != NULL) {
        // 0x1000033b8
        _fprintf(v3, "P6\n%d %d\n255\n", v1, v1);
        int64_t v4 = *(int64_t *)*(int64_t *)(v2 + 8); // 0x1000033f4
        _fwrite((int64_t *)v4, 1, 3 * (int32_t)v2 * *(int32_t *)(v2 + 4), v3);
        _fclose(v3);
        result = 1;
    }
    // 0x100003434
    return result;
}

// Address range: 0x100003444 - 0x100003544
int64_t function_100003444(void) {
    // 0x100003444
    int64_t v1; // 0x100003444
    int32_t v2 = v1; // 0x100003454
    int64_t v3 = 3 * (0x100000000 * v1 >> 32); // 0x10000346c
    int64_t v4 = 0x100000000 * v1;
    int64_t * v5 = _malloc((int32_t)(8 * v1 + 16 + v3 * (v4 >> 32))); // 0x10000347c
    int64_t result = (int64_t)v5; // 0x10000347c
    *(int32_t *)v5 = (int32_t)v1;
    *(int32_t *)(result + 4) = v2;
    int64_t v6 = result + 16; // 0x1000034a4
    int64_t * v7 = (int64_t *)(result + 8); // 0x1000034a8
    *v7 = v6;
    *(int64_t *)v6 = v6 + (v4 >> 29);
    int32_t v8 = 1 - v2; // 0x1000034dc
    if (v8 < 0 == (v8 & v2) < 0) {
        // 0x100003534
        return result;
    }
    int32_t v9 = 1; // 0x1000034e4
    int64_t v10 = *v7; // 0x1000034f0
    int64_t v11 = *(int64_t *)(v10 + (int64_t)(8 * v9 - 8)); // 0x1000034fc
    *(int64_t *)(8 * (int64_t)v9 + v10) = v11 + v3;
    v9++;
    while (v9 - v2 < 0 != ((v9 - v2 ^ v9) & (v9 ^ v2)) < 0) {
        // 0x1000034ec
        v10 = *v7;
        v11 = *(int64_t *)(v10 + (int64_t)(8 * v9 - 8));
        *(int64_t *)(8 * (int64_t)v9 + v10) = v11 + v3;
        v9++;
    }
    // 0x100003534
    return result;
}

// Address range: 0x100003544 - 0x100003620
int64_t function_100003544(void) {
    // 0x100003544
    int64_t v1; // 0x100003544
    struct _IO_FILE * v2 = (struct _IO_FILE *)v1; // 0x100003550
    int32_t result; // 0x100003544
    if (_fscanf(v2, "%d ", (int64_t *)v1) != 0) {
        // 0x100003610
        return result;
    }
    while (true) {
        // 0x100003584
        if (_fgetc(v2) != 35) {
            // break -> 0x100003610
            break;
        }
        int32_t v3; // 0x1000035a8
        while (true) {
          lab_0x1000035a4:
            // 0x1000035a4
            v3 = _fgetc(v2);
            switch (v3) {
                case -1: {
                    goto lab_0x100003558;
                }
                case 10: {
                    goto lab_0x100003558;
                }
                default: {
                    goto lab_0x1000035a4;
                }
            }
        }
      lab_0x100003558:
        // 0x100003558
        result = v3;
        if (_fscanf(v2, "%d ", (int64_t *)v1) != 0) {
            return result;
        }
    }
    // 0x100003610
    return 0;
}

// Address range: 0x100003620 - 0x100003794
int64_t function_100003620(void) {
    // 0x100003620
    int64_t v1; // 0x100003620
    struct _IO_FILE * v2 = _fopen((char *)v1, "r"); // 0x10000363c
    if (v2 == NULL) {
        // 0x100003784
        return 0;
    }
    // 0x100003664
    if (_fgetc(v2) != 80 || _fgetc(v2) != 54 || _isspace(_fgetc(v2)) == 0) {
        // 0x10000376c
        _fclose(v2);
        // 0x100003784
        return 0;
    }
    int32_t v3 = function_100003544(); // 0x1000036bc
    int32_t v4 = function_100003544(); // 0x1000036c8
    int64_t result = 0; // 0x1000036e4
    if (!((v3 == 0 | v4 == 0 | (int32_t)function_100003544() == 0))) {
        // 0x100003718
        result = function_100003444();
        int64_t v5 = *(int64_t *)*(int64_t *)(result + 8); // 0x100003730
        _fread((int64_t *)v5, 1, 3 * v3 * v4, v2);
    }
    // 0x10000376c
    _fclose(v2);
    // 0x100003784
    return result;
}

// Address range: 0x100003794 - 0x100003908
int64_t function_100003794(void) {
    // 0x100003794
    int64_t result; // 0x100003794
    int32_t v1 = result; // 0x1000037a0
    if (v1 < 0) {
        // 0x100003900
        return result;
    }
    int32_t v2 = v1 - (int32_t)result; // 0x1000037cc
    if (v2 < 0 == ((v2 ^ v1) & (int32_t)(result ^ result)) < 0) {
        // 0x100003900
        return result;
    }
    int32_t v3 = result; // 0x10000379c
    int32_t v4 = result; // 0x1000037a4
    int32_t v5 = v3 - v4; // 0x1000037e8
    int32_t v6 = v3 + v4; // 0x100003800
    int32_t v7 = v5 - v6; // 0x100003804
    if (v7 != 0 && v7 < 0 == ((v7 ^ v5) & (v5 ^ v6)) < 0) {
        // 0x100003900
        return result;
    }
    int32_t * v8 = (int32_t *)(result + 3072);
    int32_t v9 = v5;
    int32_t v10 = *(int32_t *)(result + 4); // 0x100003824
    while (v9 - v10 < 0 != ((v9 - v10 ^ v9) & (v10 ^ v9)) < 0) {
        if (v9 >= 0) {
            int64_t v11 = *(int64_t *)(*(int64_t *)(result + 8) + 8 * (int64_t)v9); // 0x100003868
            int64_t v12 = v11 + 3 * (0x100000000 * result >> 32); // 0x100003878
            int32_t * v13 = (int32_t *)(4 * (int64_t)*(char *)v12 + result); // 0x100003890
            *v13 = *v13 - 1;
            int32_t * v14 = (int32_t *)(result + 1024 + 4 * (int64_t)*(char *)(v12 + 1)); // 0x1000038b0
            *v14 = *v14 - 1;
            int32_t * v15 = (int32_t *)(result + 2048 + 4 * (int64_t)*(char *)(v12 + 2)); // 0x1000038d0
            *v15 = *v15 - 1;
            *v8 = *v8 - 1;
        }
        int32_t v16 = v9 + 1; // 0x1000038f4
        int32_t v17 = v16 - v6; // 0x100003804
        if (v17 != 0 && v17 < 0 == ((v17 ^ v16) & (v16 ^ v6)) < 0) {
            // break -> 0x100003900
            break;
        }
        v9 = v16;
        v10 = *(int32_t *)(result + 4);
    }
    // 0x100003900
    return result;
}

// Address range: 0x100003908 - 0x100003a7c
int64_t function_100003908(void) {
    // 0x100003908
    int64_t result; // 0x100003908
    int32_t v1 = result; // 0x100003914
    if (v1 < 0) {
        // 0x100003a74
        return result;
    }
    int32_t v2 = v1 - (int32_t)result; // 0x100003940
    if (v2 < 0 == ((v2 ^ v1) & (int32_t)(result ^ result)) < 0) {
        // 0x100003a74
        return result;
    }
    int32_t v3 = result; // 0x100003910
    int32_t v4 = result; // 0x100003918
    int32_t v5 = v3 - v4; // 0x10000395c
    int32_t v6 = v3 + v4; // 0x100003974
    int32_t v7 = v5 - v6; // 0x100003978
    if (v7 != 0 && v7 < 0 == ((v7 ^ v5) & (v5 ^ v6)) < 0) {
        // 0x100003a74
        return result;
    }
    int32_t * v8 = (int32_t *)(result + 3072);
    int32_t v9 = v5;
    int32_t v10 = *(int32_t *)(result + 4); // 0x100003998
    while (v9 - v10 < 0 != ((v9 - v10 ^ v9) & (v10 ^ v9)) < 0) {
        if (v9 >= 0) {
            int64_t v11 = *(int64_t *)(*(int64_t *)(result + 8) + 8 * (int64_t)v9); // 0x1000039dc
            int64_t v12 = v11 + 3 * (0x100000000 * result >> 32); // 0x1000039ec
            int32_t * v13 = (int32_t *)(4 * (int64_t)*(char *)v12 + result); // 0x100003a04
            *v13 = *v13 + 1;
            int32_t * v14 = (int32_t *)(result + 1024 + 4 * (int64_t)*(char *)(v12 + 1)); // 0x100003a24
            *v14 = *v14 + 1;
            int32_t * v15 = (int32_t *)(result + 2048 + 4 * (int64_t)*(char *)(v12 + 2)); // 0x100003a44
            *v15 = *v15 + 1;
            *v8 = *v8 + 1;
        }
        int32_t v16 = v9 + 1; // 0x100003a68
        int32_t v17 = v16 - v6; // 0x100003978
        if (v17 != 0 && v17 < 0 == ((v17 ^ v16) & (v16 ^ v6)) < 0) {
            // break -> 0x100003a74
            break;
        }
        v9 = v16;
        v10 = *(int32_t *)(result + 4);
    }
    // 0x100003a74
    return result;
}

// Address range: 0x100003a7c - 0x100003b34
int64_t function_100003a7c(void) {
    // 0x100003a7c
    int64_t v1; // 0x100003a7c
    int32_t v2 = v1; // 0x100003a90
    int64_t result = ___memset_chk(v1, 0, 3076, -1); // 0x100003aa8
    int32_t v3 = -v2; // 0x100003abc
    int64_t result2 = result; // 0x100003acc
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003b28
        return result;
    }
    int32_t v4 = 0; // 0x100003b1c
    int32_t v5 = result2; // 0x100003adc
    while (v4 - v5 < 0 != ((v4 - v5 ^ v4) & (v4 ^ v5)) < 0) {
        // 0x100003afc
        result2 = function_100003908();
        v4++;
        int32_t v6 = v4 - v2; // 0x100003abc
        if (v6 < 0 == ((v6 ^ v4) & (v4 ^ v2)) < 0) {
            // break -> 0x100003b28
            break;
        }
        v5 = result2;
    }
    // 0x100003b28
    return result2;
}

// Address range: 0x100003b34 - 0x100003bc8
int64_t function_100003b34(void) {
    // 0x100003b34
    int64_t v1; // 0x100003b34
    int32_t v2 = (int32_t)v1 / 2; // 0x100003b84
    int32_t v3 = 0;
    v2 -= *(int32_t *)(4 * (int64_t)v3 + v1);
    int32_t result = v3; // 0x100003ba0
    while (v2 >= 1) {
        int32_t v4 = v3 + 1; // 0x100003bb0
        result = v4;
        if (v3 < 255 == (254 - v3 & v4) < 0) {
            // break -> 0x100003bbc
            break;
        }
        v3 = v4;
        v2 -= *(int32_t *)(4 * (int64_t)v3 + v1);
        result = v3;
    }
    // 0x100003bbc
    return result;
}

// Address range: 0x100003bc8 - 0x100003c38
int64_t function_100003bc8(void) {
    // 0x100003bc8
    int64_t v1; // 0x100003bc8
    *(char *)v1 = (char)function_100003b34();
    *(char *)(v1 + 1) = (char)function_100003b34();
    int64_t result = function_100003b34(); // 0x100003c20
    *(char *)(v1 + 2) = (char)result;
    return result;
}

// Address range: 0x100003c38 - 0x100003db0
int64_t function_100003c38(void) {
    int64_t result = function_100003444(); // 0x100003c68
    int64_t result2 = result; // bp-56, 0x100003c70
    int64_t * v1 = (int64_t *)((int64_t)&result2 + 24); // 0x100003c84
    int64_t v2 = *v1; // 0x100003c84
    int32_t v3 = *(int32_t *)(v2 + 4); // 0x100003c88
    int32_t v4 = -v3; // 0x100003c8c
    if (v4 < 0 == (v3 & v4) < 0) {
        // 0x100003d98
        return result;
    }
    int32_t v5 = 0; // 0x100003c94
    int32_t v6 = *(int32_t *)v2; // 0x100003cb0
    int32_t v7 = -v6; // 0x100003cb4
    int32_t v8 = 0; // 0x100003cbc
    int64_t v9 = v2; // 0x100003cbc
    int32_t v10; // 0x100003d78
    int64_t v11; // 0x100003cac
    int32_t v12; // 0x100003cb0
    int32_t v13; // 0x100003cb4
    if (v7 < 0 != (v6 & v7) < 0) {
        if (v8 == 0) {
            // 0x100003cd8
            function_100003a7c();
        } else {
            // 0x100003cf4
            function_100003794();
            function_100003908();
        }
        // 0x100003d44
        function_100003bc8();
        v10 = v8 + 1;
        v11 = *v1;
        v12 = *(int32_t *)v11;
        v13 = v10 - v12;
        v8 = v10;
        v9 = v11;
        while (v13 < 0 != ((v13 ^ v10) & (v12 ^ v10)) < 0) {
            // 0x100003cc4
            if (v8 == 0) {
                // 0x100003cd8
                function_100003a7c();
            } else {
                // 0x100003cf4
                function_100003794();
                function_100003908();
            }
            // 0x100003d44
            function_100003bc8();
            v10 = v8 + 1;
            v11 = *v1;
            v12 = *(int32_t *)v11;
            v13 = v10 - v12;
            v8 = v10;
            v9 = v11;
        }
    }
    int64_t v14 = v9; // 0x100003c84
    v5++;
    int32_t v15 = *(int32_t *)(v14 + 4); // 0x100003c88
    while (v5 - v15 < 0 != ((v5 - v15 ^ v5) & (v15 ^ v5)) < 0) {
        // 0x100003ca4
        v6 = *(int32_t *)v14;
        v7 = -v6;
        v8 = 0;
        v9 = v14;
        if (v7 < 0 != (v6 & v7) < 0) {
            if (v8 == 0) {
                // 0x100003cd8
                function_100003a7c();
            } else {
                // 0x100003cf4
                function_100003794();
                function_100003908();
            }
            // 0x100003d44
            function_100003bc8();
            v10 = v8 + 1;
            v11 = *v1;
            v12 = *(int32_t *)v11;
            v13 = v10 - v12;
            v8 = v10;
            v9 = v11;
            while (v13 < 0 != ((v13 ^ v10) & (v12 ^ v10)) < 0) {
                // 0x100003cc4
                if (v8 == 0) {
                    // 0x100003cd8
                    function_100003a7c();
                } else {
                    // 0x100003cf4
                    function_100003794();
                    function_100003908();
                }
                // 0x100003d44
                function_100003bc8();
                v10 = v8 + 1;
                v11 = *v1;
                v12 = *(int32_t *)v11;
                v13 = v10 - v12;
                v8 = v10;
                v9 = v11;
            }
        }
        // 0x100003d88
        v14 = v9;
        v5++;
        v15 = *(int32_t *)(v14 + 4);
    }
    // 0x100003d98
    return result2;
}

// Address range: 0x100003db0 - 0x100003ea4
int64_t entry_point(void) {
    // 0x100003db0
    int64_t v1; // 0x100003db0
    int32_t v2 = v1; // 0x100003dc0
    int32_t v3 = v2 - 3; // 0x100003dcc
    if (v3 == 0 || v3 < 0 != (2 - v2 & v2) < 0) {
        // 0x100003ddc
        _printf("Usage: %s size ppm_in ppm_out\n", (char *)v1);
    } else {
        // 0x100003e00
        _atoi((char *)*(int64_t *)(v1 + 8));
        _printf("filter size %d\n", v1);
        int64_t v4 = function_100003620(); // 0x100003e54
        int64_t v5 = function_100003c38(); // 0x100003e64
        function_100003374();
        _free((int64_t *)v4);
        _free((int64_t *)v5);
    }
    // 0x100003e94
    return 0;
}

// Address range: 0x100003ea4 - 0x100003eb0
int64_t function_100003ea4(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003ea4
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(char * nptr) {
    // 0x100003eb0
    return _atoi(nptr);
}

// Address range: 0x100003ebc - 0x100003ec8
int32_t function_100003ebc(struct _IO_FILE * stream) {
    // 0x100003ebc
    return _fclose(stream);
}

// Address range: 0x100003ec8 - 0x100003ed4
int32_t function_100003ec8(struct _IO_FILE * stream) {
    // 0x100003ec8
    return _fgetc(stream);
}

// Address range: 0x100003ed4 - 0x100003ee0
struct _IO_FILE * function_100003ed4(char * filename, char * modes) {
    // 0x100003ed4
    return _fopen(filename, modes);
}

// Address range: 0x100003ee0 - 0x100003eec
int32_t function_100003ee0(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003ee0
    return _fprintf(stream, format);
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003eec
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003ef8 - 0x100003f04
void function_100003ef8(int64_t * ptr) {
    // 0x100003ef8
    _free(ptr);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f04
    return _fscanf(stream, format);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003f10
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(int32_t c) {
    // 0x100003f1c
    return _isspace(c);
}

// Address range: 0x100003f28 - 0x100003f34
int64_t * function_100003f28(int32_t size) {
    // 0x100003f28
    return _malloc(size);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 24

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int main(void) {
    int nprimes =  1000000;
    int nmax =    ceil(nprimes*(log(nprimes)+log(log(nprimes))-0.9385));
      // should be larger than the last prime wanted; See
      // https://www.maa.org/sites/default/files/jaroma03200545640.pdf
    int i, j, m, k; int *a;
    k = (nmax-2)/2;
    a = (int *)calloc(k + 1, sizeof(int));
    for(i = 0; i <= k; i++)a[i] = 2*i+1;
    for (i = 1; (i+1)*i*2 <= k; i++)
        for (j = i; j <= (k-i)/(2*i+1); j++) {
            m = i + j + 2*i*j;
            if(a[m]) a[m] = 0;
            }

    for (i = 1, j = 0; i <= k; i++)
       if (a[i]) {
           if(j%10 == 0 && j <= 100)printf("\n");
           j++;
           if(j <= 100)printf("%3d ", a[i]);
           else if(j == nprimes){
               printf("\n%d th prime is %d\n",j,a[i]);
               break;
               }
           }
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t * function_100003f5c(int32_t nmemb, int32_t size);
float64_t function_100003f68(float64_t a1);
int32_t function_100003f74(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t g1 = 0.9385; // 0x100003f80

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
float64_t _log(float64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c18 - 0x100003f5c
int64_t entry_point(void) {
    // 0x100003c18
    float64_t v1; // 0x100003c18
    float64_t v2 = v1;
    __asm_sshll(0.0f, 0);
    _log((float64_t)(int64_t)__asm_sshll(0.0f, 0));
    _log(_log((float64_t)(int64_t)__asm_sshll(0.0f, 0)));
    int32_t v3 = __asm_fcvtps(v2 * (2 * v2 - g1)); // 0x100003c98
    int32_t v4 = v3 - 2; // 0x100003ca8
    int32_t v5 = v4 / 2; // 0x100003cac
    int64_t v6 = (int64_t)_calloc(v5 + 1, 4); // 0x100003cc8
    if (v3 < 4 || v4 > 1 != (v5 & -v5) < 0) {
        int32_t v7 = 0;
        *(int32_t *)(4 * (int64_t)v7 + v6) = 2 * v7 | 1;
        int32_t v8 = v7 + 1; // 0x100003d14
        while (v8 - v5 == 0 || v8 - v5 < 0 != ((v8 - v5 ^ v8) & (v8 ^ v5)) < 0) {
            // 0x100003cf0
            v7 = v8;
            *(int32_t *)(4 * (int64_t)v7 + v6) = 2 * v7 | 1;
            v8 = v7 + 1;
        }
    }
    // 0x100003d2c
    if (v4 < 8 == (3 - v5 & v5) < 0) {
        int32_t v9 = 1;
        int32_t v10 = 2;
        int32_t v11 = 2 * v9; // 0x100003d74
        int32_t v12 = (v5 - v9) / (v11 | 1); // 0x100003d7c
        int32_t v13 = v9 - v12; // 0x100003d80
        int32_t v14 = v9; // 0x100003d88
        int32_t v15; // 0x100003c18
        int32_t * v16; // 0x100003dc0
        int32_t v17; // 0x100003df0
        int32_t v18; // 0x100003d80
        if (v13 == 0 || v13 < 0 != ((v13 ^ v9) & (v9 ^ v12)) < 0) {
            v15 = v14;
            v16 = (int32_t *)(4 * (int64_t)(v15 + v9 + v15 * v11) + v6);
            if (*v16 != 0) {
                // 0x100003dd4
                *v16 = 0;
            }
            // 0x100003dec
            v17 = v15 + 1;
            v18 = v17 - v12;
            while (v18 == 0 || v18 < 0 != ((v18 ^ v17) & (v17 ^ v12)) < 0) {
                // 0x100003d90
                v15 = v17;
                v16 = (int32_t *)(4 * (int64_t)(v15 + v9 + v15 * v11) + v6);
                if (*v16 != 0) {
                    // 0x100003dd4
                    *v16 = 0;
                }
                // 0x100003dec
                v17 = v15 + 1;
                v18 = v17 - v12;
            }
        }
        int32_t v19 = v10 + 1; // 0x100003d30
        int32_t v20 = 2 * v10 * v19; // 0x100003d40
        while (v5 - v20 < 0 == ((v5 - v20 ^ v5) & (v20 ^ v5)) < 0) {
            // 0x100003d5c
            v9 = v10;
            v10 = v19;
            v11 = 2 * v9;
            v12 = (v5 - v9) / (v11 | 1);
            v13 = v9 - v12;
            v14 = v9;
            if (v13 == 0 || v13 < 0 != ((v13 ^ v9) & (v9 ^ v12)) < 0) {
                v15 = v14;
                v16 = (int32_t *)(4 * (int64_t)(v15 + v9 + v15 * v11) + v6);
                if (*v16 != 0) {
                    // 0x100003dd4
                    *v16 = 0;
                }
                // 0x100003dec
                v17 = v15 + 1;
                v18 = v17 - v12;
                while (v18 == 0 || v18 < 0 != ((v18 ^ v17) & (v17 ^ v12)) < 0) {
                    // 0x100003d90
                    v15 = v17;
                    v16 = (int32_t *)(4 * (int64_t)(v15 + v9 + v15 * v11) + v6);
                    if (*v16 != 0) {
                        // 0x100003dd4
                        *v16 = 0;
                    }
                    // 0x100003dec
                    v17 = v15 + 1;
                    v18 = v17 - v12;
                }
            }
            // 0x100003d2c
            v19 = v10 + 1;
            v20 = 2 * v10 * v19;
        }
    }
    int32_t v21 = 1 - v5; // 0x100003e28
    if (v21 != 0 && v21 < 0 == (v21 & v5) < 0) {
        // 0x100003f4c
        return 0;
    }
    int32_t v22 = 1; // 0x100003e30
    int32_t v23 = 0;
    int32_t v24 = v23; // 0x100003e4c
    int64_t v25; // 0x100003c18
    int32_t v26; // 0x100003e7c
    int32_t v27; // 0x100003ea0
    int32_t v28; // 0x100003eac
    if (*(int32_t *)(4 * (int64_t)v22 + v6) != 0) {
        if (v23 % 10 == 0) {
            // 0x100003e78
            v26 = v23 - 100;
            if (v26 == 0 || v26 < 0 != (99 - v23 & v23) < 0) {
                // 0x100003e8c
                _printf("\n");
            }
        }
        // 0x100003e9c
        v27 = v23 + 1;
        v28 = v23 - 99;
        if (v28 == 0 || v28 < 0 != (v27 & 98 - v23) < 0) {
            // 0x100003ebc
            _printf("%3d ", 4);
            v24 = v27;
        } else {
            // 0x100003ee4
            v24 = v27;
            if (v27 == 0xf4240) {
                // 0x100003efc
                _printf("\n%d th prime is %d\n", 4, v25);
                return 0;
            }
        }
    }
    // 0x100003f3c
    v22++;
    while (v22 - v5 == 0 || v22 - v5 < 0 != ((v22 - v5 ^ v22) & (v22 ^ v5)) < 0) {
        // 0x100003e38
        v23 = v24;
        v24 = v23;
        if (*(int32_t *)(4 * (int64_t)v22 + v6) != 0) {
            if (v23 % 10 == 0) {
                // 0x100003e78
                v26 = v23 - 100;
                if (v26 == 0 || v26 < 0 != (99 - v23 & v23) < 0) {
                    // 0x100003e8c
                    _printf("\n");
                }
            }
            // 0x100003e9c
            v27 = v23 + 1;
            v28 = v23 - 99;
            if (v28 == 0 || v28 < 0 != (v27 & 98 - v23) < 0) {
                // 0x100003ebc
                _printf("%3d ", 4);
                v24 = v27;
            } else {
                // 0x100003ee4
                v24 = v27;
                if (v27 == 0xf4240) {
                    // 0x100003efc
                    _printf("\n%d th prime is %d\n", 4, v25);
                    return 0;
                }
            }
        }
        // 0x100003f3c
        v22++;
    }
    // 0x100003f4c
    return 0;
}

// Address range: 0x100003f5c - 0x100003f68
int64_t * function_100003f5c(int32_t nmemb, int32_t size) {
    // 0x100003f5c
    return _calloc(nmemb, size);
}

// Address range: 0x100003f68 - 0x100003f74
float64_t function_100003f68(float64_t a1) {
    // 0x100003f68
    return _log(a1);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BASE_MIN 2
#define BASE_MAX 94

void selfdesc(unsigned long);

const char *ref = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{|}~";
char *digs;
unsigned long *nums, *inds, inds_sum, inds_val, base;

int main(int argc, char *argv[]) {
int used[BASE_MAX];
unsigned long digs_n, i;
	if (argc != 2) {
		fprintf(stderr, "Usage is %s <digits>\n", argv[0]);
		return EXIT_FAILURE;
	}
	digs = argv[1];
	digs_n = strlen(digs);
	if (digs_n < BASE_MIN || digs_n > BASE_MAX) {
		fprintf(stderr, "Invalid number of digits\n");
		return EXIT_FAILURE;
	}
	for (i = 0; i < BASE_MAX; i++) {
		used[i] = 0;
	}
	for (i = 0; i < digs_n && strchr(ref, digs[i]) && !used[digs[i]-*ref]; i++) {
		used[digs[i]-*ref] = 1;
	}
	if (i < digs_n) {
		fprintf(stderr, "Invalid digits\n");
		return EXIT_FAILURE;
	}
	nums = calloc(digs_n, sizeof(unsigned long));
	if (!nums) {
		fprintf(stderr, "Could not allocate memory for nums\n");
		return EXIT_FAILURE;
	}
	inds = malloc(sizeof(unsigned long)*digs_n);
	if (!inds) {
		fprintf(stderr, "Could not allocate memory for inds\n");
		free(nums);
		return EXIT_FAILURE;
	}
	inds_sum = 0;
	inds_val = 0;
	for (base = BASE_MIN; base <= digs_n; base++) {
		selfdesc(base);
	}
	free(inds);
	free(nums);
	return EXIT_SUCCESS;
}

void selfdesc(unsigned long i) {
unsigned long diff_sum, upper_min, j, lower, upper, k;
	if (i) {
		diff_sum = base-inds_sum;
		upper_min = inds_sum ? diff_sum:base-1;
		j = i-1;
		if (j) {
			lower = 0;
			upper = (base-inds_val)/j;
		}
		else {
			lower = diff_sum;
			upper = diff_sum;
		}
		if (upper < upper_min) {
			upper_min = upper;
		}
		for (inds[j] = lower; inds[j] <= upper_min; inds[j]++) {
			nums[inds[j]]++;
			inds_sum += inds[j];
			inds_val += inds[j]*j;
			for (k = base-1; k > j && nums[k] <= inds[k] && inds[k]-nums[k] <= i; k--);
			if (k == j) {
				selfdesc(i-1);
			}
			inds_val -= inds[j]*j;
			inds_sum -= inds[j];
			nums[inds[j]]--;
		}
	}
	else {
		for (j = 0; j < base; j++) {
			putchar(digs[inds[j]]);
		}
		puts("");
	}
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003a60(void);
int64_t function_100003e4c(int64_t a1);
int64_t * function_100003e58(int32_t nmemb, int32_t size);
int32_t function_100003e64(struct _IO_FILE * stream, char * format, ...);
void function_100003e70(int64_t * ptr);
int64_t * function_100003e7c(int32_t size);
int32_t function_100003e88(int32_t c);
int32_t function_100003e94(char * s);
char * function_100003ea0(char * s, int32_t c);
int32_t function_100003eac(char * s);

// --------------------- Global Variables ---------------------

char * g1 = "\xb8>"; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x100008008
char * g3; // 0x100008010
int64_t g4 = 0x50800000012; // 0x100008018
int64_t g5 = 0x200085; // 0x100008020
int64_t g6 = 0x4800000019; // 0x100008028
char g7[9] = "__PAGEZE"; // 0x100008030
int32_t g8;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);
char * _strchr(char * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003684 - 0x100003a60
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x10000369c
    int64_t result; // 0x100003684
    int64_t v2; // 0x100003684
    int64_t v3; // 0x100003684
    if ((int32_t)v2 == 2) {
        int64_t v4 = *(int64_t *)(v2 + 8); // 0x1000036fc
        *(int64_t *)&g3 = v4;
        uint32_t v5 = _strlen((char *)v4); // 0x100003710
        if (v5 < 2) {
            goto lab_0x100003740;
        } else {
            if (v5 == 94 || v5 < 94) {
                // 0x10000376c
                int64_t v6; // bp-416, 0x100003684
                int64_t v7 = &v6;
                for (int64_t i = 0; i < 94; i++) {
                    // 0x100003780
                    *(int32_t *)(4 * i + v7) = 0;
                }
                uint64_t v8 = (int64_t)v5; // 0x1000037b0
                int64_t v9 = 0; // 0x1000037c4
                if (v5 == 0) {
                  lab_0x1000038cc:;
                    int64_t * v10 = _calloc(v5, 8); // 0x1000038d4
                    *(int64_t *)&g7 = (int64_t)v10;
                    if (v10 == NULL) {
                        int64_t v11 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003900
                        v3 = _fprintf((struct _IO_FILE *)v11, "Could not allocate memory for nums\n");
                        result = 1;
                    } else {
                        int64_t * v12 = _malloc(8 * v5); // 0x100003928
                        int64_t v13 = (int64_t)v12; // 0x100003928
                        g4 = v13;
                        if (v12 == NULL) {
                            int64_t v14 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003954
                            _fprintf((struct _IO_FILE *)v14, "Could not allocate memory for inds\n");
                            _free((int64_t *)*(int64_t *)&g7);
                            v3 = &g8;
                            result = 1;
                        } else {
                            // 0x100003980
                            g5 = 0;
                            g6 = 0;
                            g2 = 2;
                            int64_t v15 = v13; // 0x1000039c4
                            if (v5 <= 2 != v5 != 2) {
                                function_100003a60();
                                int64_t v16 = g2 + 1; // 0x1000039ec
                                g2 = v16;
                                while (v16 >= v8 != v16 != v8) {
                                    // 0x1000039cc
                                    function_100003a60();
                                    v16 = g2 + 1;
                                    g2 = v16;
                                }
                                // 0x1000039ac
                                v15 = g4;
                            }
                            // 0x1000039f8
                            _free((int64_t *)v15);
                            _free((int64_t *)*(int64_t *)&g7);
                            v3 = &g8;
                            result = 0;
                        }
                    }
                } else {
                    char v17 = *(char *)(v9 + (int64_t)g3); // 0x1000037e4
                    while (_strchr(g1, (int32_t)v17) != NULL) {
                        char v18 = *(char *)(v9 + (int64_t)g3); // 0x100003814
                        char v19 = *g1; // 0x100003820
                        int32_t * v20 = (int32_t *)((4 * ((int64_t)v18 - (int64_t)v19) & 0xfffffffc) + v7);
                        if (*v20 != 0) {
                            // break -> 0x1000038a8
                            break;
                        }
                        // 0x10000384c
                        *v20 = 1;
                        int64_t v21 = v9 + 1; // 0x100003884
                        v9 = v21;
                        if (v21 >= v8) {
                            goto lab_0x1000038cc;
                        }
                        v17 = *(char *)(v9 + (int64_t)g3);
                    }
                    int64_t v22 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000038b0
                    v3 = _fprintf((struct _IO_FILE *)v22, "Invalid digits\n");
                    result = 1;
                }
                goto lab_0x100003a20;
            } else {
                goto lab_0x100003740;
            }
        }
    } else {
        int64_t v23 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000036cc
        v3 = _fprintf((struct _IO_FILE *)v23, "Usage is %s <digits>\n", (char *)v2);
        result = 1;
        goto lab_0x100003a20;
    }
  lab_0x100003740:;
    int64_t v24 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003748
    v3 = _fprintf((struct _IO_FILE *)v24, "Invalid number of digits\n");
    result = 1;
    goto lab_0x100003a20;
  lab_0x100003a20:
    // 0x100003a20
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003a48
        ___stack_chk_fail(v3);
    }
    // 0x100003a4c
    return result;
}

// Address range: 0x100003a60 - 0x100003e4c
int64_t function_100003a60(void) {
    // 0x100003a60
    int64_t v1; // 0x100003a60
    uint64_t v2 = v1;
    if (v2 == 0) {
        int64_t v3 = 0; // 0x100003dec
        if (g2 != 0) {
            int64_t v4 = *(int64_t *)(g4 + 8 * v3); // 0x100003e10
            _putchar((int32_t)*(char *)(v4 + (int64_t)g3));
            int64_t v5 = v3 + 1; // 0x100003e24
            v3 = v5;
            while (v5 < g2) {
                // 0x100003df4
                v4 = *(int64_t *)(g4 + 8 * v3);
                _putchar((int32_t)*(char *)(v4 + (int64_t)g3));
                v5 = v3 + 1;
                v3 = v5;
            }
        }
        // 0x100003e40
        return _puts((char *)0x100003f9f);
    }
    int64_t v6 = g2 - g5; // 0x100003a9c
    uint64_t v7 = v2 - 1; // 0x100003ae8
    int64_t v8 = v6; // 0x100003afc
    int64_t v9 = v6; // 0x100003afc
    if (v7 != 0) {
        // 0x100003b04
        v8 = 0;
        v9 = (g2 - g6) / v7;
    }
    uint64_t v10 = g5 == 0 ? g2 - 1 : v6;
    uint64_t v11 = v9;
    uint64_t v12 = v11 < v10 ? v11 : v10;
    int64_t v13 = 8 * v7; // 0x100003b80
    *(int64_t *)(g4 + v13) = v8;
    uint64_t v14 = *(int64_t *)(g4 + v13); // 0x100003b98
    int64_t result; // 0x100003a60
    if (v14 >= v12 == (v14 != v12)) {
        // 0x100003e40
        return result;
    }
    uint64_t v15 = v14; // 0x100003ba8
    while (true) {
        // 0x100003bb0
        int64_t v16; // 0x100003a60
        int64_t v17 = v16;
        int64_t * v18 = (int64_t *)(*(int64_t *)&g7 + 8 * v15); // 0x100003bd4
        *v18 = *v18 + 1;
        int64_t * v19 = (int64_t *)(g4 + v13);
        int64_t v20 = g5 + *v19; // 0x100003bf8
        g5 = v20;
        int64_t v21 = g6 + *v19 * v7; // 0x100003c20
        g6 = v21;
        int64_t v22 = g2 - 1;
        int64_t * v23; // 0x100003a60
        int64_t v24; // 0x100003a60
        int64_t v25; // 0x100003a60
        int64_t v26; // 0x100003a60
        while (v22 != v7 && v22 >= v7) {
            int64_t v27 = 8 * v22; // 0x100003c70
            uint64_t v28 = *(int64_t *)(*(int64_t *)&g7 + v27); // 0x100003c70
            uint64_t v29 = *(int64_t *)(v27 + g4); // 0x100003c84
            v23 = v19;
            v24 = v20;
            v25 = v21;
            v26 = v17;
            if (v29 <= v28 == (v29 != v28)) {
                goto lab_0x100003d28_2;
            }
            uint64_t v30 = v29 - v28; // 0x100003cc8
            int64_t v31 = v22; // 0x100003ce4
            v23 = v19;
            v24 = v20;
            v25 = v21;
            v26 = v17;
            if (v30 != v2 && v30 >= v2) {
                goto lab_0x100003d28_2;
            }
            v22 = v31 - 1;
        }
        // 0x100003d00
        v23 = v19;
        v24 = v20;
        v25 = v21;
        v26 = v17;
        if (v22 == v7) {
            int64_t v32 = function_100003a60(); // 0x100003d20
            v23 = (int64_t *)(g4 + v13);
            v24 = g5;
            v25 = g6;
            v26 = v32;
        }
      lab_0x100003d28_2:
        // 0x100003d28
        g6 = v25 - *v23 * v7;
        g5 = v24 - *v23;
        int64_t * v33 = (int64_t *)(8 * *v23 + *(int64_t *)&g7); // 0x100003d94
        *v33 = *v33 - 1;
        int64_t * v34 = (int64_t *)(g4 + v13); // 0x100003db8
        *v34 = *v34 + 1;
        v15 = *(int64_t *)(g4 + v13);
        v16 = v26;
        result = v26;
        if (v15 >= v12 == (v15 != v12)) {
            // break -> 0x100003e40
            break;
        }
    }
    // 0x100003e40
    return result;
}

// Address range: 0x100003e4c - 0x100003e58
int64_t function_100003e4c(int64_t a1) {
    // 0x100003e4c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e58 - 0x100003e64
int64_t * function_100003e58(int32_t nmemb, int32_t size) {
    // 0x100003e58
    return _calloc(nmemb, size);
}

// Address range: 0x100003e64 - 0x100003e70
int32_t function_100003e64(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e64
    return _fprintf(stream, format);
}

// Address range: 0x100003e70 - 0x100003e7c
void function_100003e70(int64_t * ptr) {
    // 0x100003e70
    _free(ptr);
}

// Address range: 0x100003e7c - 0x100003e88
int64_t * function_100003e7c(int32_t size) {
    // 0x100003e7c
    return _malloc(size);
}

// Address range: 0x100003e88 - 0x100003e94
int32_t function_100003e88(int32_t c) {
    // 0x100003e88
    return _putchar(c);
}

// Address range: 0x100003e94 - 0x100003ea0
int32_t function_100003e94(char * s) {
    // 0x100003e94
    return _puts(s);
}

// Address range: 0x100003ea0 - 0x100003eac
char * function_100003ea0(char * s, int32_t c) {
    // 0x100003ea0
    return _strchr(s, c);
}

// Address range: 0x100003eac - 0x100003eb8
int32_t function_100003eac(char * s) {
    // 0x100003eac
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <stdlib.h>
#include <math.h>
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

double drand()   /* uniform distribution, (0..1] */
{
  return (rand()+1.0)/(RAND_MAX+1.0);
}
double random_normal()  /* normal distribution, centered on 0, std dev 1 */
{
  return sqrt(-2*log(drand())) * cos(2*M_PI*drand());
}
int main()
{
  int i;
  double rands[1000];
  for (i=0; i<1000; i++)
    rands[i] = 1.0 + 0.5*random_normal();
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e18(int64_t a1);
int64_t function_100003e44(void);
int64_t function_100003eb8(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f60(void);
float64_t function_100003f6c(float64_t a1);
float64_t function_100003f78(float64_t a1);
int32_t function_100003f84(void);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(void);
float64_t _cos(float64_t a1);
float64_t _log(float64_t a1);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003e18 - 0x100003e44
int64_t function_100003e18(int64_t a1) {
    // 0x100003e18
    return _rand();
}

// Address range: 0x100003e44 - 0x100003e9c
int64_t function_100003e44(void) {
    // 0x100003e44
    int64_t v1; // 0x100003e44
    function_100003e18(v1);
    int128_t v2; // 0x100003e44
    float64_t v3 = _log((float64_t)(int64_t)v2); // 0x100003e54
    float64_t v4; // 0x100003e44
    function_100003e18((int64_t)sqrt(-2.0 * v4));
    return _cos(v3);
}

// Address range: 0x100003e9c - 0x100003eb8
int64_t entry_point(void) {
    // 0x100003e9c
    return ___chkstk_darwin();
}

// Address range: 0x100003eb8 - 0x100003f60
int64_t function_100003eb8(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003eb8
    int64_t v1; // 0x100003eb8
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003ecc
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    int64_t v3; // bp-8008, 0x100003eb8
    int64_t v4 = &v3;
    int32_t v5 = 0;
    function_100003e44();
    float64_t v6; // 0x100003eb8
    float64_t v7 = 0.5 * v6 + 1.0; // 0x100003f00
    *(float64_t *)(8 * (int64_t)v5 + v4) = v7;
    int32_t v8 = v5 + 1; // 0x100003f18
    while (v5 < 999 != (998 - v5 & v8) < 0) {
        // 0x100003ef0
        v5 = v8;
        function_100003e44();
        v7 = 0.5 * v7 + 1.0;
        *(float64_t *)(8 * (int64_t)v5 + v4) = v7;
        v8 = v5 + 1;
    }
    // 0x100003f24
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003f44
        ___stack_chk_fail();
    }
    // 0x100003f48
    return 0;
}

// Address range: 0x100003f60 - 0x100003f6c
int64_t function_100003f60(void) {
    // 0x100003f60
    return ___stack_chk_fail();
}

// Address range: 0x100003f6c - 0x100003f78
float64_t function_100003f6c(float64_t a1) {
    // 0x100003f6c
    return _cos(a1);
}

// Address range: 0x100003f78 - 0x100003f84
float64_t function_100003f78(float64_t a1) {
    // 0x100003f78
    return _log(a1);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(void) {
    // 0x100003f84
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
#include <stdlib.h>

// row starts with 1; col < row
size_t bellIndex(int row, int col) {
    return row * (row - 1) / 2 + col;
}

int getBell(int *bellTri, int row, int col) {
    size_t index = bellIndex(row, col);
    return bellTri[index];
}

void setBell(int *bellTri, int row, int col, int value) {
    size_t index = bellIndex(row, col);
    bellTri[index] = value;
}

int *bellTriangle(int n) {
    size_t length = n * (n + 1) / 2;
    int *tri = calloc(length, sizeof(int));
    int i, j;

    setBell(tri, 1, 0, 1);
    for (i = 2; i <= n; ++i) {
        setBell(tri, i, 0, getBell(tri, i - 1, i - 2));
        for (j = 1; j < i; ++j) {
            int value = getBell(tri, i, j - 1) + getBell(tri, i - 1, j - 1);
            setBell(tri, i, j, value);
        }
    }

    return tri;
}

int main() {
    const int rows = 15;
    int *bt = bellTriangle(rows);
    int i, j;

    printf("First fifteen Bell numbers:\n");
    for (i = 1; i <= rows; ++i) {
        printf("%2d: %d\n", i, getBell(bt, i, 0));
    }

    printf("\nThe first ten rows of Bell's triangle:\n");
    for (i = 1; i <= 10; ++i) {
        printf("%d", getBell(bt, i, 0));
        for (j = 1; j < i; ++j) {
            printf(", %d", getBell(bt, i, j));
        }
        printf("\n");
    }

    free(bt);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b58(void);
int64_t function_100003b94(int64_t a1, int32_t a2, int32_t a3);
int64_t function_100003bd4(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003c1c(void);
int64_t * function_100003f20(int32_t nmemb, int32_t size);
void function_100003f2c(int64_t * ptr);
int32_t function_100003f38(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b58 - 0x100003b94
int64_t function_100003b58(void) {
    // 0x100003b58
    int64_t v1; // 0x100003b58
    int32_t v2 = v1; // 0x100003b5c
    return (v2 - 1) * v2 / 2 + (int32_t)v1;
}

// Address range: 0x100003b94 - 0x100003bd4
int64_t function_100003b94(int64_t a1, int32_t a2, int32_t a3) {
    // 0x100003b94
    return (int64_t)*(int32_t *)(4 * function_100003b58() + a1);
}

// Address range: 0x100003bd4 - 0x100003c1c
int64_t function_100003bd4(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t result = function_100003b58(); // 0x100003bf8
    *(int32_t *)(4 * result + a1) = (int32_t)a4;
    return result;
}

// Address range: 0x100003c1c - 0x100003d98
int64_t function_100003c1c(void) {
    // 0x100003c1c
    int64_t v1; // 0x100003c1c
    int32_t v2 = v1; // 0x100003c28
    int64_t result = (int64_t)_calloc((v2 + 1) * v2 / 2, 4); // 0x100003c64
    function_100003bd4(result, 1, 0, 1);
    int32_t v3 = 2 - v2; // 0x100003c94
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003d88
        return result;
    }
    uint32_t v4 = 2;
    int32_t v5 = v4 - 1; // 0x100003cc4
    int64_t v6 = function_100003b94(result, v5, v4 - 2); // 0x100003cd0
    int64_t v7 = v4; // 0x100003cd4
    function_100003bd4(result, v7, 0, v6);
    int32_t v8 = 1 - v4; // 0x100003cfc
    int32_t v9 = 1; // 0x100003d04
    int32_t v10; // 0x100003d18
    int64_t v11; // 0x100003d1c
    int32_t v12; // 0x100003d68
    int32_t v13; // 0x100003cfc
    if (v8 < 0 != (v8 & v4) < 0) {
        v10 = v9 - 1;
        v11 = function_100003b94(result, v4, v10);
        function_100003bd4(result, v7, (int64_t)v9, function_100003b94(result, v5, v10) + v11 & 0xffffffff);
        v12 = v9 + 1;
        v13 = v12 - v4;
        v9 = v12;
        while (v13 < 0 != ((v13 ^ v12) & (v12 ^ v4)) < 0) {
            // 0x100003d0c
            v10 = v9 - 1;
            v11 = function_100003b94(result, v4, v10);
            function_100003bd4(result, v7, (int64_t)v9, function_100003b94(result, v5, v10) + v11 & 0xffffffff);
            v12 = v9 + 1;
            v13 = v12 - v4;
            v9 = v12;
        }
    }
    int32_t v14 = v4 + 1; // 0x100003d7c
    while (v14 - v2 == 0 || v14 - v2 < 0 != ((v14 - v2 ^ v14) & (v14 ^ v2)) < 0) {
        // 0x100003ca4
        v4 = v14;
        v5 = v4 - 1;
        v6 = function_100003b94(result, v5, v4 - 2);
        v7 = v4;
        function_100003bd4(result, v7, 0, v6);
        v8 = 1 - v4;
        v9 = 1;
        if (v8 < 0 != (v8 & v4) < 0) {
            v10 = v9 - 1;
            v11 = function_100003b94(result, v4, v10);
            function_100003bd4(result, v7, (int64_t)v9, function_100003b94(result, v5, v10) + v11 & 0xffffffff);
            v12 = v9 + 1;
            v13 = v12 - v4;
            v9 = v12;
            while (v13 < 0 != ((v13 ^ v12) & (v12 ^ v4)) < 0) {
                // 0x100003d0c
                v10 = v9 - 1;
                v11 = function_100003b94(result, v4, v10);
                function_100003bd4(result, v7, (int64_t)v9, function_100003b94(result, v5, v10) + v11 & 0xffffffff);
                v12 = v9 + 1;
                v13 = v12 - v4;
                v9 = v12;
            }
        }
        // 0x100003d78
        v14 = v4 + 1;
    }
    // 0x100003d88
    return result;
}

// Address range: 0x100003d98 - 0x100003f20
int64_t entry_point(void) {
    int64_t v1 = function_100003c1c(); // 0x100003db0
    _printf("First fifteen Bell numbers:\n");
    uint32_t v2 = 1;
    function_100003b94(v1, v2, 0);
    _printf("%2d: %d\n", (int64_t)v2, 0);
    int32_t v3 = v2 + 1; // 0x100003e28
    while (v2 == 14 || v2 < 14 != (13 - v2 & v3) < 0) {
        // 0x100003de4
        v2 = v3;
        function_100003b94(v1, v2, 0);
        _printf("%2d: %d\n", (int64_t)v2, 0);
        v3 = v2 + 1;
    }
    // 0x100003e34
    _printf("\nThe first ten rows of Bell's triangle:\n");
    uint32_t v4 = 1;
    int64_t v5 = v4; // 0x100003e64
    function_100003b94(v1, v4, 0);
    _printf("%d", v5);
    int32_t v6 = 1 - v4; // 0x100003e9c
    int32_t v7 = 1; // 0x100003ea4
    int32_t v8; // 0x100003edc
    int32_t v9; // 0x100003e9c
    if (v6 < 0 != (v6 & v4) < 0) {
        function_100003b94(v1, v4, v7);
        _printf(", %d", v5);
        v8 = v7 + 1;
        v9 = v8 - v4;
        v7 = v8;
        while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v4)) < 0) {
            // 0x100003eac
            function_100003b94(v1, v4, v7);
            _printf(", %d", v5);
            v8 = v7 + 1;
            v9 = v8 - v4;
            v7 = v8;
        }
    }
    // 0x100003ee8
    _printf((char *)0x100003f9b);
    int32_t v10 = v4 + 1; // 0x100003efc
    while (v4 == 9 || v4 < 9 != (8 - v4 & v10) < 0) {
        // 0x100003e60
        v4 = v10;
        v5 = v4;
        function_100003b94(v1, v4, 0);
        _printf("%d", v5);
        v6 = 1 - v4;
        v7 = 1;
        if (v6 < 0 != (v6 & v4) < 0) {
            function_100003b94(v1, v4, v7);
            _printf(", %d", v5);
            v8 = v7 + 1;
            v9 = v8 - v4;
            v7 = v8;
            while (v9 < 0 != ((v9 ^ v8) & (v8 ^ v4)) < 0) {
                // 0x100003eac
                function_100003b94(v1, v4, v7);
                _printf(", %d", v5);
                v8 = v7 + 1;
                v9 = v8 - v4;
                v7 = v8;
            }
        }
        // 0x100003ee8
        _printf((char *)0x100003f9b);
        v10 = v4 + 1;
    }
    // 0x100003f08
    _free((int64_t *)v1);
    return 0;
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t * function_100003f20(int32_t nmemb, int32_t size) {
    // 0x100003f20
    return _calloc(nmemb, size);
}

// Address range: 0x100003f2c - 0x100003f38
void function_100003f2c(int64_t * ptr) {
    // 0x100003f2c
    _free(ptr);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * format, ...) {
    // 0x100003f38
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
