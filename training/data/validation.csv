`#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void talk(const char *s)
{
	pid_t pid;
	int status;

	pid = fork();
	if (pid < 0) {
		perror("fork");
		exit(1);
	}

	if (pid == 0) {
		execlp("espeak", "espeak", s, (void*)0);
		perror("espeak");
		_exit(1);
	}

	waitpid(pid, &status, 0);
	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
		exit(1);
}

int main()
{
	talk("This is an example of speech synthesis.");
	return 0;
}
`,`#include "speech-synthesis.h"



pid_t _talk(undefined8 param_1)

{
  pid_t pVar1;
  uint local_20;
  pid_t local_1c;
  undefined8 local_18;
  
  local_18 = param_1;
  local_1c = _fork();
  if (local_1c < 0) {
    _perror("fork");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  if (local_1c != 0) {
    pVar1 = _waitpid(local_1c,(int *)&local_20,0);
    if (((local_20 & 0x7f) == 0) && (((int)local_20 >> 8 & 0xffU) == 0)) {
      return pVar1;
    }
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  _execlp("espeak","espeak");
  _perror("espeak");
                    // WARNING: Subroutine does not return
  __exit(1);
}



undefined4 entry(void)

{
  _talk("This is an example of speech synthesis.");
  return 0;
}



void __exit(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR___exit_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _execlp(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__execlp_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

pid_t _fork(void)

{
  pid_t pVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pVar1 = (*(code *)PTR__fork_100004018)();
  return pVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _perror(char *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__perror_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

pid_t _waitpid(pid_t param_1,int *param_2,int param_3)

{
  pid_t pVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  pVar1 = (*(code *)PTR__waitpid_100004028)(param_1,param_2,param_3);
  return pVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

char chr_legal[] = "abcdefghijklmnopqrstuvwxyz0123456789_-./";
int  chr_idx[256] = {0};
char idx_chr[256] = {0};

#define FNAME 0
typedef struct trie_t *trie, trie_t;
struct trie_t {
    trie next[sizeof(chr_legal)]; /* next letter; slot 0 is for file name */
    int eow;
};

trie trie_new() { return calloc(sizeof(trie_t), 1); }

#define find_word(r, w) trie_trav(r, w, 1)
/* tree traversal: returns node if end of word and matches string, optionally
 * create node if doesn't exist
 */
trie trie_trav(trie root, const char * str, int no_create)
{
    int c;
    while (root) {
        if ((c = str[0]) == '\0') {
            if (!root->eow && no_create) return 0;
            break;
        }
        if (! (c = chr_idx[c]) ) {
            str++;
            continue;
        }

        if (!root->next[c]) {
            if (no_create) return 0;
            root->next[c] = trie_new();
        }
        root = root->next[c];
        str++;
    }
    return root;
}

/*  complete traversal of whole tree, calling callback at each end of word node.
 *  similar method can be used to free nodes, had we wanted to do that.
 */
int trie_all(trie root, char path[], int depth, int (*callback)(char *))
{
    int i;
    if (root->eow && !callback(path)) return 0;

    for (i = 1; i < sizeof(chr_legal); i++) {
        if (!root->next[i]) continue;

        path[depth] = idx_chr[i];
        path[depth + 1] = '\0';
        if (!trie_all(root->next[i], path, depth + 1, callback))
            return 0;
    }
    return 1;
}

void add_index(trie root, const char *word, const char *fname)
{
    trie x = trie_trav(root, word, 0);
    x->eow = 1;

    if (!x->next[FNAME])
        x->next[FNAME] = trie_new();
    x = trie_trav(x->next[FNAME], fname, 0);
    x->eow = 1;
}

int print_path(char *path)
{
    printf(" %s", path);
    return 1;
}

/*  pretend we parsed text files and got lower cased words: dealing     *
 *  with text file is a whole other animal and would make code too long */
const char *files[] = { "f1.txt", "source/f2.txt", "other_file" };
const char *text[][5] ={{ "it", "is", "what", "it", "is" },
                { "what", "is", "it", 0 },
                { "it", "is", "a", "banana", 0 }};

trie init_tables()
{
    int i, j;
    trie root = trie_new();
    for (i = 0; i < sizeof(chr_legal); i++) {
        chr_idx[(int)chr_legal[i]] = i + 1;
        idx_chr[i + 1] = chr_legal[i];
    }

/* Enable USE_ADVANCED_FILE_HANDLING to use advanced file handling.
 * You need to have files named like above files[], with words in them
 * like in text[][].  Case doesn't matter (told you it's advanced).
 */
#define USE_ADVANCED_FILE_HANDLING 0
#if USE_ADVANCED_FILE_HANDLING
    void read_file(const char * fname) {
        char cmd[1024];
        char word[1024];
        sprintf(cmd, "perl -p -e 'while(/(\\w+)/g) {print lc($1),\"\\n\"}' %s", fname);
        FILE *in = popen(cmd, "r");
        while (!feof(in)) {
            fscanf(in, "%1000s", word);
            add_index(root, word, fname);
        }
        pclose(in);
    };

    read_file("f1.txt");
    read_file("source/f2.txt");
    read_file("other_file");
#else
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 5; j++) {
            if (!text[i][j]) break;
            add_index(root, text[i][j], files[i]);
        }
    }
#endif /*USE_ADVANCED_FILE_HANDLING*/

    return root;
}

void search_index(trie root, const char *word)
{
    char path[1024];
    printf("Search for \"%s\": ", word);
    trie found = find_word(root, word);

    if (!found) printf("not found\n");
    else {
        trie_all(found->next[FNAME], path, 0, print_path);
        printf("\n");
    }
}

int main()
{
    trie root = init_tables();

    search_index(root, "what");
    search_index(root, "is");
    search_index(root, "banana");
    search_index(root, "boo");
    return 0;
}
`,`#include "inverted-index-1.h"



void _trie_new(void)

{
  _calloc(0x150,1);
  return;
}



long _trie_trav(long param_1,char *param_2,int param_3)

{
  int iVar1;
  undefined8 uVar2;
  char *local_28;
  long local_20;
  
  local_28 = param_2;
  local_20 = param_1;
  while( true ) {
    if (local_20 == 0) {
      return 0;
    }
    if (*local_28 == 0) break;
    iVar1 = *(int *)(&_chr_idx + (long)(int)*local_28 * 4);
    if (iVar1 == 0) {
      local_28 = local_28 + 1;
    }
    else {
      if (*(long *)(local_20 + (long)iVar1 * 8) == 0) {
        if (param_3 != 0) {
          return 0;
        }
        uVar2 = _trie_new();
        *(undefined8 *)(local_20 + (long)iVar1 * 8) = uVar2;
      }
      local_20 = *(long *)(local_20 + (long)iVar1 * 8);
      local_28 = local_28 + 1;
    }
  }
  if (*(int *)(local_20 + 0x148) != 0) {
    return local_20;
  }
  if (param_3 == 0) {
    return local_20;
  }
  return 0;
}



undefined4 _trie_all(long param_1,long param_2,int param_3,code *param_4)

{
  int iVar1;
  uint local_3c;
  undefined4 local_14;
  
  if ((*(int *)(param_1 + 0x148) == 0) || (iVar1 = (*param_4)(param_2), iVar1 != 0)) {
    for (local_3c = 1; local_3c < 0x29; local_3c = local_3c + 1) {
      if (*(long *)(param_1 + (long)(int)local_3c * 8) != 0) {
        *(undefined *)(param_2 + param_3) = (&_idx_chr)[(int)local_3c];
        *(undefined *)(param_2 + (param_3 + 1)) = 0;
        iVar1 = _trie_all(*(undefined8 *)(param_1 + (long)(int)local_3c * 8),param_2,param_3 + 1,
                          param_4);
        if (iVar1 == 0) {
          return 0;
        }
      }
    }
    local_14 = 1;
  }
  else {
    local_14 = 0;
  }
  return local_14;
}



void _add_index(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  long *plVar1;
  long lVar2;
  
  plVar1 = (long *)_trie_trav(param_1,param_2,0);
  *(undefined4 *)(plVar1 + 0x29) = 1;
  if (*plVar1 == 0) {
    lVar2 = _trie_new();
    *plVar1 = lVar2;
  }
  lVar2 = _trie_trav(*plVar1,param_3,0);
  *(undefined4 *)(lVar2 + 0x148) = 1;
  return;
}



undefined8 _print_path(void)

{
  _printf(" %s");
  return 1;
}



undefined8 _init_tables(void)

{
  undefined8 uVar1;
  int local_18;
  uint local_14;
  
  uVar1 = _trie_new();
  for (local_14 = 0; local_14 < 0x29; local_14 = local_14 + 1) {
    *(uint *)(&_chr_idx + (long)_chr_legal[(int)local_14] * 4) = local_14 + 1;
    (&_idx_chr)[(int)(local_14 + 1)] = _chr_legal[(int)local_14];
  }
  for (local_14 = 0; (int)local_14 < 3; local_14 = local_14 + 1) {
    local_18 = 0;
    while ((local_18 < 5 && ((&_text)[(long)(int)local_14 * 5 + (long)local_18] != (undefined *)0x0)
           )) {
      _add_index(uVar1,(&_text)[(long)(int)local_14 * 5 + (long)local_18],(&_files)[(int)local_14]);
      local_18 = local_18 + 1;
    }
  }
  return uVar1;
}



void _search_index(undefined8 param_1,undefined8 param_2)

{
  int iVar1;
  undefined8 *puVar2;
  undefined auStack_428 [1024];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _printf("Search for \"%s\": ");
  puVar2 = (undefined8 *)_trie_trav(param_1,param_2,1);
  if (puVar2 == (undefined8 *)0x0) {
    iVar1 = _printf("not found\n");
  }
  else {
    _trie_all(*puVar2,auStack_428,0,_print_path);
    iVar1 = _printf("\n");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined4 entry(void)

{
  undefined8 uVar1;
  
  uVar1 = _init_tables();
  _search_index(uVar1,"what");
  _search_index(uVar1,"is");
  _search_index(uVar1,"banana");
  _search_index(uVar1,"boo");
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

/* let us declare our functions; indeed here we need
   really only M declaration, so that F can "see" it
   and the compiler won't complain with a warning */
int F(const int n);
int M(const int n);

int F(const int n)
{
  return (n == 0) ? 1 : n - M(F(n - 1));
}

int M(const int n)
{
  return (n == 0) ? 0 : n - F(M(n - 1));
}

int main(void)
{
  int i;
  for (i = 0; i < 20; i++)
    printf("%2d ", F(i));
  printf("\n");
  for (i = 0; i < 20; i++)
    printf("%2d ", M(i));
  printf("\n");
  return EXIT_SUCCESS;
}
`,`#include "mutual-recursion.h"



int _F(int param_1)

{
  undefined4 local_18;
  
  if (param_1 == 0) {
    local_18 = 1;
  }
  else {
    _F(param_1 + -1);
    local_18 = _M();
    local_18 = param_1 - local_18;
  }
  return local_18;
}



int _M(int param_1)

{
  undefined4 local_18;
  
  if (param_1 == 0) {
    local_18 = 0;
  }
  else {
    _M(param_1 + -1);
    local_18 = _F();
    local_18 = param_1 - local_18;
  }
  return local_18;
}



undefined8 entry(void)

{
  int local_18;
  
  for (local_18 = 0; local_18 < 0x14; local_18 = local_18 + 1) {
    _F(local_18);
    _printf("%2d ");
  }
  _printf("\n");
  for (local_18 = 0; local_18 < 0x14; local_18 = local_18 + 1) {
    _M(local_18);
    _printf("%2d ");
  }
  _printf("\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>


#define MAXLEN 100
typedef char TWord[MAXLEN];


typedef struct Node {
    TWord word;
    struct Node *next;
} Node;


int is_ordered_word(const TWord word) {
    assert(word != NULL);
    int i;

    for (i = 0; word[i] != '\0'; i++)
        if (word[i] > word[i + 1] && word[i + 1] != '\0')
            return 0;

    return 1;
}


Node* list_prepend(Node* words_list, const TWord new_word) {
    assert(new_word != NULL);
    Node *new_node = malloc(sizeof(Node));
    if (new_node == NULL)
        exit(EXIT_FAILURE);

    strcpy(new_node->word, new_word);
    new_node->next = words_list;
    return new_node;
}


Node* list_destroy(Node *words_list) {
    while (words_list != NULL) {
        Node *temp = words_list;
        words_list = words_list->next;
        free(temp);
    }

    return words_list;
}


void list_print(Node *words_list) {
    while (words_list != NULL) {
        printf("\n%s", words_list->word);
        words_list = words_list->next;
    }
}


int main() {
    FILE *fp = fopen("unixdict.txt", "r");
    if (fp == NULL)
        return EXIT_FAILURE;

    Node *words = NULL;
    TWord line;
    unsigned int max_len = 0;

    while (fscanf(fp, "%99s\n", line) != EOF) {
        if (strlen(line) > max_len && is_ordered_word(line)) {
            max_len = strlen(line);
            words = list_destroy(words);
            words = list_prepend(words, line);
        } else if (strlen(line) == max_len && is_ordered_word(line)) {
            words = list_prepend(words, line);
        }
    }

    fclose(fp);
    list_print(words);

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ac4(void);
int64_t function_100003bc0(void);
int64_t function_100003c6c(void);
int64_t function_100003cc4(void);
int64_t function_100003ebc(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003ec8(void);
int64_t function_100003ed4(int64_t a1, int64_t a2, int64_t a3);
void function_100003ee0(int32_t status);
int32_t function_100003eec(struct _IO_FILE * stream);
struct _IO_FILE * function_100003ef8(char * filename, char * modes);
void function_100003f04(int64_t * ptr);
int32_t function_100003f10(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f1c(int32_t size);
int32_t function_100003f28(char * format, ...);
int32_t function_100003f34(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(void);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
void _free(int64_t * a1);
int32_t _fscanf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ac4 - 0x100003bc0
int64_t function_100003ac4(void) {
    // 0x100003ac4
    int64_t v1; // 0x100003ac4
    if (v1 == 0) {
        // 0x100003af4
        ___assert_rtn("is_ordered_word", "ordered-words-1.c", 18, "word != NULL");
    }
    int32_t v2 = 0; // 0x100003b1c
    char v3 = *(char *)(v1 + (int64_t)v2); // 0x100003b28
    int64_t result = 1; // 0x100003b34
    while (v3 != 0) {
        int32_t v4 = v3; // 0x100003b44
        v2++;
        char v5 = *(char *)(v1 + (int64_t)v2); // 0x100003b54
        int32_t v6 = v4 - (int32_t)v5; // 0x100003b58
        result = 0;
        if (v5 != 0 && v6 != 0 && v6 < 0 == ((v6 ^ v4) & (int32_t)(v5 ^ v3)) < 0) {
            // break -> 0x100003bb0
            break;
        }
        v3 = *(char *)(v1 + (int64_t)v2);
        result = 1;
    }
    // 0x100003bb0
    return result;
}

// Address range: 0x100003bc0 - 0x100003c6c
int64_t function_100003bc0(void) {
    // 0x100003bc0
    int64_t v1; // 0x100003bc0
    if (v1 == 0) {
        // 0x100003bf4
        ___assert_rtn("list_prepend", "ordered-words-1.c", 30, "new_word != NULL");
    }
    int64_t * v2 = _malloc(112); // 0x100003c1c
    if (v2 == NULL) {
        // 0x100003c38
        _exit(1);
        // UNREACHABLE
    }
    int64_t result = (int64_t)v2; // 0x100003c1c
    ___strcpy_chk(result, v1, 100);
    return result;
}

// Address range: 0x100003c6c - 0x100003cc4
int64_t function_100003c6c(void) {
    // 0x100003c6c
    int64_t v1; // 0x100003c6c
    if (v1 == 0) {
        // 0x100003cb4
        return 0;
    }
    int64_t v2; // 0x100003c6c
    int64_t v3 = *(int64_t *)(v2 + 104); // 0x100003ca0
    _free((int64_t *)v2);
    v2 = v3;
    while (v3 != 0) {
        // 0x100003c94
        v3 = *(int64_t *)(v2 + 104);
        _free((int64_t *)v2);
        v2 = v3;
    }
    // 0x100003cb4
    return 0;
}

// Address range: 0x100003cc4 - 0x100003d20
int64_t function_100003cc4(void) {
    // 0x100003cc4
    int64_t v1; // 0x100003cc4
    if (v1 == 0) {
        // 0x100003d14
        return 0;
    }
    int32_t result = _printf("\n%s", (char *)v1); // 0x100003d00
    int64_t v2; // 0x100003cc4
    int64_t v3 = *(int64_t *)(v2 + 104); // 0x100003d08
    // 0x100003cec
    while (v3 != 0) {
        // 0x100003cec
        result = _printf("\n%s", (char *)v1);
        v3 += 104;
    }
    // 0x100003d14
    return result;
}

// Address range: 0x100003d20 - 0x100003ebc
int64_t entry_point(void) {
    struct _IO_FILE * v1 = _fopen("unixdict.txt", "r"); // 0x100003d50
    int64_t result = 1; // 0x100003d64
    int64_t v2; // bp-124, 0x100003d20
    int32_t v3; // 0x100003d20
    int32_t v4; // 0x100003d20
    int32_t v5; // 0x100003d20
    uint64_t v6; // 0x100003db8
    char ** v7; // 0x100003d9c
    if (v1 != NULL) {
        // 0x100003d84
        int64_t v8; // 0x100003d20
        v7 = (char **)v8;
        if (_fscanf(v1, "%99s\n", v7) != -1) {
            // 0x100003db0
            v3 = 0;
            while (true) {
              lab_0x100003db0:
                // 0x100003db0
                v4 = v3;
                uint64_t v9 = (int64_t)_strlen((char *)&v2); // 0x100003db4
                v6 = (int64_t)v4;
                if (v9 == v6 || v9 < v6) {
                    goto lab_0x100003e18;
                } else {
                    // 0x100003dcc
                    if ((int32_t)function_100003ac4() == 0) {
                        goto lab_0x100003e18;
                    } else {
                        int32_t v10 = _strlen((char *)&v2); // 0x100003dec
                        function_100003c6c();
                        function_100003bc0();
                        v5 = v10;
                        goto lab_0x100003e64;
                    }
                }
            }
        }
      lab_0x100003e68:
        // 0x100003e68
        _fclose(v1);
        function_100003cc4();
        result = 0;
    }
    int64_t v11 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003e94
    if (v11 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003ea8
        ___stack_chk_fail();
    }
    // 0x100003eac
    return result;
  lab_0x100003e18:;
    int32_t v12 = _strlen((char *)&v2); // 0x100003e1c
    v5 = v4;
    if ((int64_t)v12 == v6) {
        // 0x100003e34
        v5 = v4;
        if ((int32_t)function_100003ac4() != 0) {
            // 0x100003e4c
            function_100003bc0();
            v5 = v4;
        }
    }
    goto lab_0x100003e64;
  lab_0x100003e64:
    // 0x100003e64
    v3 = v5;
    if (_fscanf(v1, "%99s\n", v7) == -1) {
        // break -> 0x100003e68
        goto lab_0x100003e68;
    }
    goto lab_0x100003db0;
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t function_100003ebc(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003ebc
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t function_100003ec8(void) {
    // 0x100003ec8
    return ___stack_chk_fail();
}

// Address range: 0x100003ed4 - 0x100003ee0
int64_t function_100003ed4(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003ed4
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003ee0 - 0x100003eec
void function_100003ee0(int32_t status) {
    // 0x100003ee0
    _exit(status);
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(struct _IO_FILE * stream) {
    // 0x100003eec
    return _fclose(stream);
}

// Address range: 0x100003ef8 - 0x100003f04
struct _IO_FILE * function_100003ef8(char * filename, char * modes) {
    // 0x100003ef8
    return _fopen(filename, modes);
}

// Address range: 0x100003f04 - 0x100003f10
void function_100003f04(int64_t * ptr) {
    // 0x100003f04
    _free(ptr);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f10
    return _fscanf(stream, format);
}

// Address range: 0x100003f1c - 0x100003f28
int64_t * function_100003f1c(int32_t size) {
    // 0x100003f1c
    return _malloc(size);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(char * format, ...) {
    // 0x100003f28
    return _printf(format);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * s) {
    // 0x100003f34
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`#include <stdio.h>
#include <stdlib.h>

unsigned long long sum35(unsigned long long limit)
{
    unsigned long long sum = 0;
    for (unsigned long long i = 0; i < limit; i++)
        if (!(i % 3) || !(i % 5))
            sum += i;
    return sum;
}

int main(int argc, char **argv)
{
    unsigned long long limit;

    if (argc == 2)
        limit = strtoull(argv[1], NULL, 10);
    else
        limit = 1000;

    printf("%lld\n", sum35(limit));
    return 0;
}
`,`#include "sum-multiples-of-3-and-5-1.h"



long _sum35(ulong param_1)

{
  ulong local_18;
  long local_10;
  
  local_10 = 0;
  for (local_18 = 0; local_18 < param_1; local_18 = local_18 + 1) {
    if ((local_18 % 3 == 0) || (local_18 % 5 == 0)) {
      local_10 = local_10 + local_18;
    }
  }
  return local_10;
}



undefined8 entry(int param_1,long param_2)

{
  ulonglong local_28;
  
  if (param_1 == 2) {
    local_28 = _strtoull(*(char **)(param_2 + 8),(char **)0x0,10);
  }
  else {
    local_28 = 1000;
  }
  _sum35(local_28);
  _printf("%lld\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulonglong _strtoull(char *param_1,char **param_2,int param_3)

{
  ulonglong uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__strtoull_100004008)(param_1,param_2,param_3);
  return uVar1;
}


`
`//FormAI DATASET v1.0 Category: Intrusion detection system ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 1024
#define MAX_IP_LENGTH 16
#define MAX_TIME_LENGTH 9

typedef struct{
    char ip[MAX_IP_LENGTH];
    char time[MAX_TIME_LENGTH];
} LogEntry;

typedef struct{
    LogEntry *entries;
    int size;
    int capacity;
} Log;

void log_append(Log *log, LogEntry new_entry){
    if(log->size >= log->capacity){
        log->capacity *= 2;
        log->entries = realloc(log->entries, log->capacity * sizeof(LogEntry));
    }
    log->entries[log->size++] = new_entry;
}

void parse_line(char *line, LogEntry *entry){
    int i, j;

    // parse IP address
    for(i = 0; i < MAX_IP_LENGTH - 1 && line[i] != ' '; i++){
        entry->ip[i] = line[i];
    }
    entry->ip[i] = '\0';

    // parse time
    for(i++; i < MAX_LINE_LENGTH - 1 && line[i] != '\n' && line[i] != '\r'; i++){
        entry->time[j++] = line[i];
    }
    entry->time[j] = '\0';
}

int is_suspect(const Log *log, const char *ip){
    int i, count = 0;

    for(i = log->size - 1; i >= 0 && count < 10; i--){
        if(strcmp(log->entries[i].ip, ip) == 0){
            count++;
            if(count == 10){
                return 1;
            }
        }
    }

    return 0;
}

int main(){
    Log log = {.entries = malloc(16 * sizeof(LogEntry)), .size = 0, .capacity = 16};
    char line[MAX_LINE_LENGTH];

    while(fgets(line, MAX_LINE_LENGTH, stdin)){
        LogEntry entry;
        parse_line(line, &entry);

        if(is_suspect(&log, entry.ip)){
            printf("Intruder detected: %s\n", entry.ip);
        }

        log_append(&log, entry);
    }

    free(log.entries);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall log_append(_QWORD, _QWORD); // weak
__int64 __fastcall parse_line(_QWORD, _QWORD); // weak
__int64 __fastcall is_suspect(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400017B1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  __int64 v5[3]; // [rsp+20h] [rbp-60h] BYREF
  char v6; // [rsp+38h] [rbp-48h]
  __int64 v7[3]; // [rsp+40h] [rbp-40h] BYREF
  char v8; // [rsp+58h] [rbp-28h]
  char Buffer[1024]; // [rsp+60h] [rbp-20h] BYREF
  void *Block; // [rsp+460h] [rbp+3E0h] BYREF
  int v11; // [rsp+468h] [rbp+3E8h]
  int v12; // [rsp+46Ch] [rbp+3ECh]

  _main(argc, argv, envp);
  Block = malloc(0x190ui64);
  v11 = 0;
  v12 = 16;
  while ( 1 )
  {
    v3 = __acrt_iob_func(0);
    if ( !fgets(Buffer, 1024, v3) )
      break;
    parse_line(Buffer, v7);
    if ( (unsigned int)is_suspect(&Block, v7) )
      printf("Intruder detected: %s\n", (const char *)v7);
    v5[0] = v7[0];
    v5[1] = v7[1];
    v5[2] = v7[2];
    v6 = v8;
    log_append(&Block, v5);
  }
  free(Block);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall log_append(_QWORD, _QWORD);
// 140001653: using guessed type __int64 __fastcall parse_line(_QWORD, _QWORD);
// 140001727: using guessed type __int64 __fastcall is_suspect(_QWORD, _QWORD);
// 140001960: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Editor ; Style: puzzling
#include <stdio.h>

int main() {
  char image[10][10] = {
    {'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X'},
    {'X', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'X', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'X', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'X', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'X'},
    {'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X'}
  };
  
  printf("Image Editor Program\n");
  printf("Original Image:\n");
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
      printf("%c", image[i][j]);
    }
    printf("\n");
  }
  
  // Task 1: Flip the image vertically
  for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 10; j++) {
      char temp = image[i][j];
      image[i][j] = image[9-i][j];
      image[9-i][j] = temp;
    }
  }
  printf("\nTask 1: Flipped Image Vertically:\n");
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
      printf("%c", image[i][j]);
    }
    printf("\n");
  }
  
  // Task 2: Flip the image horizontally
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 5; j++) {
      char temp = image[i][j];
      image[i][j] = image[i][9-j];
      image[i][9-j] = temp;
    }
  }
  printf("\nTask 2: Flipped Image Horizontally:\n");
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
      printf("%c", image[i][j]);
    }
    printf("\n");
  }
  
  // Task 3: Invert the colors of the image
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
      if (image[i][j] == 'X') {
        image[i][j] = 'O';
      } else {
        image[i][j] = 'X';
      }
    }
  }
  printf("\nTask 3: Inverted Colors Image:\n");
  for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
      printf("%c", image[i][j]);
    }
    printf("\n");
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _BYTE v4[100]; // [rsp+20h] [rbp-A0h] BYREF
  char v5; // [rsp+86h] [rbp-3Ah]
  char v6; // [rsp+87h] [rbp-39h]
  int i4; // [rsp+88h] [rbp-38h]
  int i3; // [rsp+8Ch] [rbp-34h]
  int i2; // [rsp+90h] [rbp-30h]
  int i1; // [rsp+94h] [rbp-2Ch]
  int nn; // [rsp+98h] [rbp-28h]
  int mm; // [rsp+9Ch] [rbp-24h]
  int kk; // [rsp+A0h] [rbp-20h]
  int jj; // [rsp+A4h] [rbp-1Ch]
  int ii; // [rsp+A8h] [rbp-18h]
  int n; // [rsp+ACh] [rbp-14h]
  int m; // [rsp+B0h] [rbp-10h]
  int k; // [rsp+B4h] [rbp-Ch]
  int j; // [rsp+B8h] [rbp-8h]
  int i; // [rsp+BCh] [rbp-4h]
  __int64 savedregs; // [rsp+C0h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  qmemcpy(
    v4,
    "XXXXXXXXXXXOOOOOOOOXXOOXOOOOOXXOOXOOOOOXXOOXOOOOOXXOOOOOOOOXXOOOOOOOOXXOOOOOOOOXXOOOOOOOOXXXXXXXXXXX",
    sizeof(v4));
  printf("Image Editor Program\n");
  printf("Original Image:\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      printf("%c", (unsigned int)*((char *)&savedregs + 10 * i + j - 160));
    printf("\n");
  }
  for ( k = 0; k <= 4; ++k )
  {
    for ( m = 0; m <= 9; ++m )
    {
      v5 = *((_BYTE *)&savedregs + 10 * k + m - 160);
      *((_BYTE *)&savedregs + 10 * k + m - 160) = *((_BYTE *)&savedregs + 10 * (9 - k) + m - 160);
      *((_BYTE *)&savedregs + 10 * (9 - k) + m - 160) = v5;
    }
  }
  printf("\nTask 1: Flipped Image Vertically:\n");
  for ( n = 0; n <= 9; ++n )
  {
    for ( ii = 0; ii <= 9; ++ii )
      printf("%c", (unsigned int)*((char *)&savedregs + 10 * n + ii - 160));
    printf("\n");
  }
  for ( jj = 0; jj <= 9; ++jj )
  {
    for ( kk = 0; kk <= 4; ++kk )
    {
      v6 = *((_BYTE *)&savedregs + 10 * jj + kk - 160);
      *((_BYTE *)&savedregs + 10 * jj + kk - 160) = *((_BYTE *)&savedregs + 10 * jj + 9 - kk - 160);
      *((_BYTE *)&savedregs + 10 * jj + 9 - kk - 160) = v6;
    }
  }
  printf("\nTask 2: Flipped Image Horizontally:\n");
  for ( mm = 0; mm <= 9; ++mm )
  {
    for ( nn = 0; nn <= 9; ++nn )
      printf("%c", (unsigned int)*((char *)&savedregs + 10 * mm + nn - 160));
    printf("\n");
  }
  for ( i1 = 0; i1 <= 9; ++i1 )
  {
    for ( i2 = 0; i2 <= 9; ++i2 )
    {
      if ( *((_BYTE *)&savedregs + 10 * i1 + i2 - 160) == 88 )
        *((_BYTE *)&savedregs + 10 * i1 + i2 - 160) = 79;
      else
        *((_BYTE *)&savedregs + 10 * i1 + i2 - 160) = 88;
    }
  }
  printf("\nTask 3: Inverted Colors Image:\n");
  for ( i3 = 0; i3 <= 9; ++i3 )
  {
    for ( i4 = 0; i4 <= 9; ++i4 )
      printf("%c", (unsigned int)*((char *)&savedregs + 10 * i3 + i4 - 160));
    printf("\n");
  }
  return 0;
}
// 140001B80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include<stdlib.h>
#include<stdio.h>
#include<time.h>

typedef struct genome{
    char base;
    struct genome *next;
}genome;

typedef struct{
    char mutation;
    int position;
}genomeChange;

typedef struct{
    int adenineCount,thymineCount,cytosineCount,guanineCount;
}baseCounts;

genome *strand;
baseCounts baseData;
int genomeLength = 100, lineLength = 50;

int numDigits(int num){
    int len = 1;

    while(num>10){
        num /= 10;
        len++;
    }
    return len;
}

void generateStrand(){

    int baseChoice = rand()%4, i;
    genome *strandIterator, *newStrand;

    baseData.adenineCount = 0;
    baseData.thymineCount = 0;
    baseData.cytosineCount = 0;
    baseData.guanineCount = 0;

    strand = (genome*)malloc(sizeof(genome));
    strand->base = baseChoice==0?'A':(baseChoice==1?'T':(baseChoice==2?'C':'G'));
    baseChoice==0?baseData.adenineCount++:(baseChoice==1?baseData.thymineCount++:(baseChoice==2?baseData.cytosineCount++:baseData.guanineCount++));
    strand->next = NULL;

    strandIterator = strand;

    for(i=1;i<genomeLength;i++){
        baseChoice = rand()%4;

        newStrand = (genome*)malloc(sizeof(genome));
        newStrand->base = baseChoice==0?'A':(baseChoice==1?'T':(baseChoice==2?'C':'G'));
        baseChoice==0?baseData.adenineCount++:(baseChoice==1?baseData.thymineCount++:(baseChoice==2?baseData.cytosineCount++:baseData.guanineCount++));
        newStrand->next = NULL;

        strandIterator->next = newStrand;
        strandIterator = newStrand;
    }
}

genomeChange generateMutation(int swapWeight, int insertionWeight, int deletionWeight){
    int mutationChoice = rand()%(swapWeight + insertionWeight + deletionWeight);

    genomeChange mutationCommand;

    mutationCommand.mutation = mutationChoice<swapWeight?'S':((mutationChoice>=swapWeight && mutationChoice<swapWeight+insertionWeight)?'I':'D');
    mutationCommand.position = rand()%genomeLength;

    return mutationCommand;
}

void printGenome(){
    int rows, width = numDigits(genomeLength), len = 0,i,j;
	lineLength = (genomeLength<lineLength)?genomeLength:lineLength;
	
	rows = genomeLength/lineLength + (genomeLength%lineLength!=0);
	
    genome* strandIterator = strand;

    printf("\n\nGenome : \n--------\n");

    for(i=0;i<rows;i++){
        printf("\n%*d%3s",width,len,":");

        for(j=0;j<lineLength && strandIterator!=NULL;j++){
                printf("%c",strandIterator->base);
                strandIterator = strandIterator->next;
        }
        len += lineLength;
    }

    while(strandIterator!=NULL){
            printf("%c",strandIterator->base);
            strandIterator = strandIterator->next;
    }

    printf("\n\nBase Counts\n-----------");

    printf("\n%*c%3s%*d",width,'A',":",width,baseData.adenineCount);
    printf("\n%*c%3s%*d",width,'T',":",width,baseData.thymineCount);
    printf("\n%*c%3s%*d",width,'C',":",width,baseData.cytosineCount);
    printf("\n%*c%3s%*d",width,'G',":",width,baseData.guanineCount);
	
	printf("\n\nTotal:%*d",width,baseData.adenineCount + baseData.thymineCount + baseData.cytosineCount + baseData.guanineCount);

    printf("\n");
}

void mutateStrand(int numMutations, int swapWeight, int insertionWeight, int deletionWeight){
    int i,j,width,baseChoice;
    genomeChange newMutation;
    genome *strandIterator, *strandFollower, *newStrand;

    for(i=0;i<numMutations;i++){
        strandIterator = strand;
        strandFollower = strand;
        newMutation = generateMutation(swapWeight,insertionWeight,deletionWeight);
        width = numDigits(genomeLength);

        for(j=0;j<newMutation.position;j++){
            strandFollower = strandIterator;
            strandIterator = strandIterator->next;
        }

        if(newMutation.mutation=='S'){
            if(strandIterator->base=='A'){
                strandIterator->base='T';
                printf("\nSwapping A at position : %*d with T",width,newMutation.position);
            }
            else if(strandIterator->base=='A'){
                strandIterator->base='T';
                printf("\nSwapping A at position : %*d with T",width,newMutation.position);
            }
            else if(strandIterator->base=='C'){
                strandIterator->base='G';
                printf("\nSwapping C at position : %*d with G",width,newMutation.position);
            }
            else{
                strandIterator->base='C';
                printf("\nSwapping G at position : %*d with C",width,newMutation.position);
            }
        }

        else if(newMutation.mutation=='I'){
            baseChoice = rand()%4;

            newStrand = (genome*)malloc(sizeof(genome));
            newStrand->base = baseChoice==0?'A':(baseChoice==1?'T':(baseChoice==2?'C':'G'));
            printf("\nInserting %c at position : %*d",newStrand->base,width,newMutation.position);
            baseChoice==0?baseData.adenineCount++:(baseChoice==1?baseData.thymineCount++:(baseChoice==2?baseData.cytosineCount++:baseData.guanineCount++));
            newStrand->next = strandIterator;
            strandFollower->next = newStrand;
            genomeLength++;
        }

        else{
            strandFollower->next = strandIterator->next;
            strandIterator->next = NULL;
            printf("\nDeleting %c at position : %*d",strandIterator->base,width,newMutation.position);
            free(strandIterator);
            genomeLength--;
        }
    }
}

int main(int argc,char* argv[])
{
    int numMutations = 10, swapWeight = 10, insertWeight = 10, deleteWeight = 10;

    if(argc==1||argc>6){
                printf("Usage : %s <Genome Length> <Optional number of mutations> <Optional Swapping weight> <Optional Insertion weight> <Optional Deletion weight>\n",argv[0]);
                return 0;
    }

    switch(argc){
        case 2: genomeLength = atoi(argv[1]);
                break;
        case 3: genomeLength = atoi(argv[1]);
                numMutations = atoi(argv[2]);
                break;
        case 4: genomeLength = atoi(argv[1]);
                numMutations = atoi(argv[2]);
                swapWeight   = atoi(argv[3]);
                break;
        case 5: genomeLength = atoi(argv[1]);
                numMutations = atoi(argv[2]);
                swapWeight   = atoi(argv[3]);
                insertWeight = atoi(argv[4]);
                break;
        case 6: genomeLength = atoi(argv[1]);
                numMutations = atoi(argv[2]);
                swapWeight   = atoi(argv[3]);
                insertWeight = atoi(argv[4]);
                deleteWeight = atoi(argv[5]);
                break;
    };

    srand(time(NULL));
    generateStrand();
	
	printf("\nOriginal:");
    printGenome();
    mutateStrand(numMutations,swapWeight,insertWeight,deleteWeight);

	printf("\n\nMutated:");
	printGenome();

    return 0;
}
`,`#include "bioinformatics-sequence-mutation.h"



int _numDigits(int param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 1;
  for (local_4 = param_1; 10 < local_4; local_4 = local_4 / 10) {
    local_8 = local_8 + 1;
  }
  return local_8;
}



void _generateStrand(void)

{
  int iVar1;
  undefined *puVar2;
  undefined local_34;
  undefined local_2c;
  undefined *local_20;
  int local_18;
  
  iVar1 = _rand();
  iVar1 = iVar1 % 4;
  _baseData = 0;
  DAT_10000800c = 0;
  DAT_100008010 = 0;
  DAT_100008014 = 0;
  _strand = (undefined *)_malloc(0x10);
  if (iVar1 == 0) {
    local_2c = 0x41;
  }
  else if (iVar1 == 1) {
    local_2c = 0x54;
  }
  else {
    local_2c = 0x43;
    if (iVar1 != 2) {
      local_2c = 0x47;
    }
  }
  *_strand = local_2c;
  if (iVar1 == 0) {
    _baseData = _baseData + 1;
  }
  else if (iVar1 == 1) {
    DAT_10000800c = DAT_10000800c + 1;
  }
  else if (iVar1 == 2) {
    DAT_100008010 = DAT_100008010 + 1;
  }
  else {
    DAT_100008014 = DAT_100008014 + 1;
  }
  *(undefined8 *)(_strand + 8) = 0;
  local_20 = _strand;
  for (local_18 = 1; local_18 < _genomeLength; local_18 = local_18 + 1) {
    iVar1 = _rand();
    iVar1 = iVar1 % 4;
    puVar2 = (undefined *)_malloc(0x10);
    if (iVar1 == 0) {
      local_34 = 0x41;
    }
    else if (iVar1 == 1) {
      local_34 = 0x54;
    }
    else {
      local_34 = 0x43;
      if (iVar1 != 2) {
        local_34 = 0x47;
      }
    }
    *puVar2 = local_34;
    if (iVar1 == 0) {
      _baseData = _baseData + 1;
    }
    else if (iVar1 == 1) {
      DAT_10000800c = DAT_10000800c + 1;
    }
    else if (iVar1 == 2) {
      DAT_100008010 = DAT_100008010 + 1;
    }
    else {
      DAT_100008014 = DAT_100008014 + 1;
    }
    *(undefined8 *)(puVar2 + 8) = 0;
    *(undefined **)(local_20 + 8) = puVar2;
    local_20 = puVar2;
  }
  return;
}



undefined8 _generateMutation(int param_1,int param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  undefined local_2c;
  undefined4 local_18;
  
  iVar3 = _rand();
  param_3 = param_1 + param_2 + param_3;
  iVar2 = 0;
  if (param_3 != 0) {
    iVar2 = iVar3 / param_3;
  }
  iVar3 = iVar3 - iVar2 * param_3;
  if (iVar3 < param_1) {
    local_2c = 0x53;
  }
  else {
    bVar1 = false;
    if (param_1 <= iVar3) {
      bVar1 = iVar3 < param_1 + param_2;
    }
    local_2c = 0x49;
    if (!bVar1) {
      local_2c = 0x44;
    }
  }
  local_18 = CONCAT31(local_18._1_3_,local_2c);
  iVar3 = _rand();
  iVar2 = 0;
  if (_genomeLength != 0) {
    iVar2 = iVar3 / _genomeLength;
  }
  return CONCAT44(iVar3 - iVar2 * _genomeLength,local_18);
}



int _printGenome(void)

{
  int iVar1;
  bool bVar2;
  int iVar3;
  int local_3c;
  long local_30;
  int local_24;
  int local_20;
  
  _numDigits(_genomeLength);
  if (_genomeLength < _lineLength) {
    local_3c = _genomeLength;
  }
  else {
    local_3c = _lineLength;
  }
  _lineLength = local_3c;
  iVar3 = 0;
  if (local_3c != 0) {
    iVar3 = _genomeLength / local_3c;
  }
  iVar1 = 0;
  if (local_3c != 0) {
    iVar1 = _genomeLength / local_3c;
  }
  bVar2 = _genomeLength != iVar1 * local_3c;
  local_30 = _strand;
  _printf("\n\nGenome : \n--------\n");
  for (local_20 = 0; local_20 < (int)(iVar3 + (uint)bVar2); local_20 = local_20 + 1) {
    _printf("\n%*d%3s");
    for (local_24 = 0; local_24 < _lineLength && local_30 != 0; local_24 = local_24 + 1) {
      _printf("%c");
      local_30 = *(long *)(local_30 + 8);
    }
  }
  for (; local_30 != 0; local_30 = *(long *)(local_30 + 8)) {
    _printf("%c");
  }
  _printf("\n\nBase Counts\n-----------");
  _printf("\n%*c%3s%*d");
  _printf("\n%*c%3s%*d");
  _printf("\n%*c%3s%*d");
  _printf("\n%*c%3s%*d");
  _printf("\n\nTotal:%*d");
  iVar3 = _printf("\n");
  return iVar3;
}



void _mutateStrand(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  int iVar1;
  undefined8 uVar2;
  undefined *puVar3;
  undefined local_5c;
  char *local_48;
  char *local_40;
  char local_38;
  int iStack_34;
  int local_28;
  int local_24;
  
  for (local_24 = 0; local_24 < param_1; local_24 = local_24 + 1) {
    local_40 = _strand;
    local_48 = _strand;
    uVar2 = _generateMutation(param_2,param_3,param_4);
    _numDigits(_genomeLength);
    for (local_28 = 0; iStack_34 = (int)((ulong)uVar2 >> 0x20), local_28 < iStack_34;
        local_28 = local_28 + 1) {
      local_48 = local_40;
      local_40 = *(char **)(local_40 + 8);
    }
    local_38 = (char)uVar2;
    if (local_38 == 'S') {
      if (*local_40 == 'A') {
        *local_40 = 'T';
        _printf("\nSwapping A at position : %*d with T");
      }
      else if (*local_40 == 'A') {
        *local_40 = 'T';
        _printf("\nSwapping A at position : %*d with T");
      }
      else if (*local_40 == 'C') {
        *local_40 = 'G';
        _printf("\nSwapping C at position : %*d with G");
      }
      else {
        *local_40 = 'C';
        _printf("\nSwapping G at position : %*d with C");
      }
    }
    else if (local_38 == 'I') {
      iVar1 = _rand();
      iVar1 = iVar1 % 4;
      puVar3 = (undefined *)_malloc(0x10);
      if (iVar1 == 0) {
        local_5c = 0x41;
      }
      else if (iVar1 == 1) {
        local_5c = 0x54;
      }
      else {
        local_5c = 0x43;
        if (iVar1 != 2) {
          local_5c = 0x47;
        }
      }
      *puVar3 = local_5c;
      _printf("\nInserting %c at position : %*d");
      if (iVar1 == 0) {
        _baseData = _baseData + 1;
      }
      else if (iVar1 == 1) {
        DAT_10000800c = DAT_10000800c + 1;
      }
      else if (iVar1 == 2) {
        DAT_100008010 = DAT_100008010 + 1;
      }
      else {
        DAT_100008014 = DAT_100008014 + 1;
      }
      *(char **)(puVar3 + 8) = local_40;
      *(undefined **)(local_48 + 8) = puVar3;
      _genomeLength = _genomeLength + 1;
    }
    else {
      *(undefined8 *)(local_48 + 8) = *(undefined8 *)(local_40 + 8);
      local_40[8] = '\0';
      local_40[9] = '\0';
      local_40[10] = '\0';
      local_40[0xb] = '\0';
      local_40[0xc] = '\0';
      local_40[0xd] = '\0';
      local_40[0xe] = '\0';
      local_40[0xf] = '\0';
      _printf("\nDeleting %c at position : %*d");
      _free(local_40);
      _genomeLength = _genomeLength + -1;
    }
  }
  return;
}



undefined4 entry(int param_1,long param_2)

{
  int iVar1;
  time_t tVar2;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  
  local_24 = 10;
  local_28 = 10;
  local_2c = 10;
  local_30 = 10;
  if ((param_1 == 1) || (6 < param_1)) {
    _printf(
           "Usage : %s <Genome Length> <Optional number of mutations> <Optional Swapping weight> <Optional Insertion weight> <Optional Deletion weight>\n"
           );
  }
  else {
    switch(param_1) {
    case 2:
      _genomeLength = _atoi(*(char **)(param_2 + 8));
      break;
    case 3:
      _genomeLength = _atoi(*(char **)(param_2 + 8));
      local_24 = _atoi(*(char **)(param_2 + 0x10));
      break;
    case 4:
      _genomeLength = _atoi(*(char **)(param_2 + 8));
      local_24 = _atoi(*(char **)(param_2 + 0x10));
      local_28 = _atoi(*(char **)(param_2 + 0x18));
      break;
    case 5:
      _genomeLength = _atoi(*(char **)(param_2 + 8));
      local_24 = _atoi(*(char **)(param_2 + 0x10));
      local_28 = _atoi(*(char **)(param_2 + 0x18));
      local_2c = _atoi(*(char **)(param_2 + 0x20));
      break;
    case 6:
      _genomeLength = _atoi(*(char **)(param_2 + 8));
      local_24 = _atoi(*(char **)(param_2 + 0x10));
      local_28 = _atoi(*(char **)(param_2 + 0x18));
      local_2c = _atoi(*(char **)(param_2 + 0x20));
      local_30 = _atoi(*(char **)(param_2 + 0x28));
    }
    tVar2 = _time((time_t *)0x0);
    _srand((uint)tVar2);
    _generateStrand();
    iVar1 = _printf("\nOriginal:");
    _printGenome(iVar1);
    _mutateStrand(local_24,local_28,local_2c,local_30);
    iVar1 = _printf("\n\nMutated:");
    _printGenome(iVar1);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003da4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003db0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dbc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dc8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dd4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004020)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003de0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004028)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dec. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004030)();
  return tVar1;
}


`
`#include <stdio.h>
#include <wchar.h>

int main(void)
{
   wchar_t *s = L"\x304A\x306F\x3088\x3046"; /* Japanese hiragana ohayou */
   size_t length;

   length = wcslen(s);
   printf("Length in characters = %d\n", length);
   printf("Length in bytes      = %d\n", sizeof(s) * sizeof(wchar_t));

   return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f44(char * format, ...);
int32_t function_100003f50(int16_t * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _wcslen(int16_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ed4 - 0x100003f44
int64_t entry_point(void) {
    // 0x100003ed4
    _wcslen((int16_t *)"J0");
    int64_t v1; // 0x100003ed4
    _printf("Length in characters = %d\n", v1);
    _printf("Length in bytes      = %d\n", v1);
    return 0;
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * format, ...) {
    // 0x100003f44
    return _printf(format);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(int16_t * s) {
    // 0x100003f50
    return _wcslen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`//FormAI DATASET v1.0 Category: A* Pathfinding Algorithm ; Style: surprised
#include <stdio.h>
#define ROW 10
#define COL 10
int visit[ROW][COL];
int grid[ROW][COL];
int shortestPath = 0;

// structure for holding coordinates
struct point {
    int x; 
    int y; 
};

void AStarPathFinding(struct point start, struct point dest) {

    // initialization
    struct point q[ROW * COL];
    int f = 0, r = 0;
    q[r++] = start;
    visit[start.x][start.y] = 1;

    // directions: right, up, left, down
    int dx[4] = {0, -1, 0, 1};
    int dy[4] = {1, 0, -1, 0};
    while (f < r) {

        int k = 0;
        int minDist = ROW * COL + 1;

        // get the closest neighbors to the goal
        for (int i = 0; i < 4; i++) {

            struct point cur = q[f];
            struct point next = {cur.x + dx[i], cur.y + dy[i]};

            if (next.x < 0 || next.x >= ROW || next.y < 0 || next.y >= COL) {
                continue;
            }

            // find Manhattan distance
            int dist = abs(next.x - dest.x) + abs(next.y - dest.y);

            // update shortest path
            if (dist < minDist && !visit[next.x][next.y] && grid[next.x][next.y]) {
                k = i;
                minDist = dist;
            }
        }

        // record the visit and add the next point to the queue
        struct point cur = q[f];
        f++;
        visit[cur.x][cur.y] = 1;

        // update shortest path
        shortestPath += minDist;

        if (cur.x == dest.x && cur.y == dest.y) {
            return;
        }

        q[r++] = (struct point){cur.x + dx[k], cur.y + dy[k]};

    }
}

int main() {

    // create grid map example
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < COL; j++) {
            grid[i][j] = 1;
        }
    }

    // mark obstacles
    grid[3][3] = 0;
    grid[4][3] = 0;
    grid[5][3] = 0;

    // mark start and end points
    struct point start = {0, 0};
    struct point dest = {9, 9};

    // run A* pathfinding algorithm
    AStarPathFinding(start, dest);

    // print shortest path
    printf("Shortest path: %d\n", shortestPath);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall AStarPathFinding(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_DWORD grid[33]; // weak
int dword_14000F264; // weak
int dword_14000F28C; // weak
int dword_14000F2B4; // weak
int shortestPath; // weak


//----- (0000000140001884) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      grid[10 * i + j] = 1;
  }
  dword_14000F264 = 0;
  dword_14000F28C = 0;
  dword_14000F2B4 = 0;
  AStarPathFinding(0i64, 0x900000009i64);
  printf("Shortest path: %d\n", (unsigned int)shortestPath);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall AStarPathFinding(_QWORD, _QWORD);
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F1E0: using guessed type _DWORD grid[33];
// 14000F264: using guessed type int dword_14000F264;
// 14000F28C: using guessed type int dword_14000F28C;
// 14000F2B4: using guessed type int dword_14000F2B4;
// 14000F370: using guessed type int shortestPath;

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>

void divisor_count_and_sum(unsigned int n, unsigned int* pcount,
                           unsigned int* psum) {
    unsigned int divisor_count = 1;
    unsigned int divisor_sum = 1;
    unsigned int power = 2;
    for (; (n & 1) == 0; power <<= 1, n >>= 1) {
        ++divisor_count;
        divisor_sum += power;
    }
    for (unsigned int p = 3; p * p <= n; p += 2) {
        unsigned int count = 1, sum = 1;
        for (power = p; n % p == 0; power *= p, n /= p) {
            ++count;
            sum += power;
        }
        divisor_count *= count;
        divisor_sum *= sum;
    }
    if (n > 1) {
        divisor_count *= 2;
        divisor_sum *= n + 1;
    }
    *pcount = divisor_count;
    *psum = divisor_sum;
}

int main() {
    unsigned int arithmetic_count = 0;
    unsigned int composite_count = 0;

    for (unsigned int n = 1; arithmetic_count <= 1000000; ++n) {
        unsigned int divisor_count;
        unsigned int divisor_sum;
        divisor_count_and_sum(n, &divisor_count, &divisor_sum);
        if (divisor_sum % divisor_count != 0)
            continue;
        ++arithmetic_count;
        if (divisor_count > 2)
            ++composite_count;
        if (arithmetic_count <= 100) {
            printf("%3u ", n);
            if (arithmetic_count % 10 == 0)
                printf("\n");
        }
        if (arithmetic_count == 1000 || arithmetic_count == 10000 ||
            arithmetic_count == 100000 || arithmetic_count == 1000000) {
            printf("\n%uth arithmetic number is %u\n", arithmetic_count, n);
            printf("Number of composite arithmetic numbers <= %u: %u\n", n,
                   composite_count);
        }
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ba0(void);
int32_t function_100003f3c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ba0 - 0x100003d50
int64_t function_100003ba0(void) {
    // 0x100003ba0
    int64_t result; // 0x100003ba0
    int32_t v1 = result; // 0x100003ba4
    int32_t v2 = 1; // 0x100003bd4
    int32_t v3 = 1; // 0x100003bd4
    int32_t v4 = v1; // 0x100003bd4
    int32_t v5 = 2; // 0x100003bd4
    int32_t v6 = 1; // 0x100003bd4
    int32_t v7 = 1; // 0x100003bd4
    if (v1 % 2 == 0) {
        uint32_t v8 = v1;
        v7++;
        v6 += v5;
        int32_t v9 = v8 / 2; // 0x100003c0c
        v2 = v7;
        v3 = v6;
        v4 = v9;
        v5 *= 2;
        while ((v8 & 2) == 0) {
            // 0x100003bdc
            v8 = v9;
            v7++;
            v6 += v5;
            v9 = v8 / 2;
            v2 = v7;
            v3 = v6;
            v4 = v9;
            v5 *= 2;
        }
    }
    int32_t v10 = v4;
    int32_t v11 = v3; // 0x100003c3c
    int32_t v12 = v2; // 0x100003c3c
    int32_t v13 = v2; // 0x100003c3c
    int32_t v14 = v3; // 0x100003c3c
    int32_t v15 = v10; // 0x100003c3c
    if (v10 <= 9 != v10 != 9) {
        uint32_t v16 = 3;
        int32_t v17 = v16; // 0x100003c78
        int32_t v18 = 1; // 0x100003c78
        int32_t v19 = v10; // 0x100003c78
        int32_t v20 = 1; // 0x100003c78
        int32_t v21; // 0x100003ba0
        int32_t v22; // 0x100003ba0
        int32_t v23; // 0x100003ba0
        int32_t v24; // 0x100003c94
        int32_t v25; // 0x100003cb8
        int32_t v26; // 0x100003c84
        if (v10 % v16 == 0) {
            v26 = 2;
            v24 = v17 + 1;
            v25 = v10 / v16;
            v22 = v24;
            v23 = v25;
            v21 = v26;
            v17 *= v16;
            v18 = v26;
            v19 = v25;
            v20 = v24;
            while (v25 % v16 == 0) {
                // 0x100003c80
                v26 = v21 + 1;
                v24 = v17 + v22;
                v25 = v23 / v16;
                v22 = v24;
                v23 = v25;
                v21 = v26;
                v17 *= v16;
                v18 = v26;
                v19 = v25;
                v20 = v24;
            }
        }
        int32_t v27 = v19;
        v12 *= v18;
        v11 *= v20;
        int32_t v28 = v16 + 2; // 0x100003cec
        uint32_t v29 = v28 * v28; // 0x100003c2c
        v13 = v12;
        v14 = v11;
        v15 = v27;
        while (v29 >= v27 != v29 != v27) {
            // 0x100003c5c
            v16 = v28;
            v23 = v27;
            v17 = v16;
            v18 = 1;
            v19 = v27;
            v20 = 1;
            if (v27 % v16 == 0) {
                v26 = 2;
                v24 = v17 + 1;
                v25 = v23 / v16;
                v22 = v24;
                v23 = v25;
                v21 = v26;
                v17 *= v16;
                v18 = v26;
                v19 = v25;
                v20 = v24;
                while (v25 % v16 == 0) {
                    // 0x100003c80
                    v26 = v21 + 1;
                    v24 = v17 + v22;
                    v25 = v23 / v16;
                    v22 = v24;
                    v23 = v25;
                    v21 = v26;
                    v17 *= v16;
                    v18 = v26;
                    v19 = v25;
                    v20 = v24;
                }
            }
            // 0x100003cc4
            v27 = v19;
            v12 *= v18;
            v11 *= v20;
            v28 = v16 + 2;
            v29 = v28 * v28;
            v13 = v12;
            v14 = v11;
            v15 = v27;
        }
    }
    int32_t v30 = v15;
    int32_t v31 = v13; // 0x100003d04
    int32_t v32 = v14; // 0x100003d04
    if (v30 != 1 && v30 != 0) {
        // 0x100003d0c
        v31 = 2 * v13;
        v32 = (v30 + 1) * v14;
    }
    // 0x100003d30
    *(int32_t *)result = v31;
    *(int32_t *)result = v32;
    return result;
}

// Address range: 0x100003d50 - 0x100003f3c
int64_t entry_point(void) {
    // 0x100003d50
    int32_t v1; // bp-36, 0x100003d50
    int32_t v2 = &v1;
    int32_t v3; // bp-40, 0x100003d50
    int32_t v4 = &v3;
    int32_t v5 = 0;
    function_100003ba0();
    int32_t v6 = v5; // 0x100003dbc
    int32_t v7; // 0x100003dcc
    if (v3 % v1 == 0) {
        // 0x100003dc8
        v7 = v5 + 1;
        if (v7 >= 100 != v7 != 100) {
            // 0x100003e0c
            _printf("%3u ", v2);
            if (v7 % 10 == 0) {
                // 0x100003e4c
                _printf("\n");
            }
        }
        // 0x100003e60
        v6 = v7;
        switch (v5) {
            case 0xf423f: {
            }
            case 0x1869f: {
            }
            case 0x270f: {
            }
            case 999: {
                // 0x100003ec4
                _printf("\n%uth arithmetic number is %u\n", v2, v4);
                _printf("Number of composite arithmetic numbers <= %u: %u\n", v2, v4);
                v6 = v7;
                // break -> 0x100003f1c
                break;
            }
        }
    }
    // 0x100003f1c
    while (v6 >= 0xf4240 != v6 != 0xf4240) {
        // 0x100003d90
        v5 = v6;
        function_100003ba0();
        v6 = v5;
        if (v3 % v1 == 0) {
            // 0x100003dc8
            v7 = v5 + 1;
            if (v7 >= 100 != v7 != 100) {
                // 0x100003e0c
                _printf("%3u ", v2);
                if (v7 % 10 == 0) {
                    // 0x100003e4c
                    _printf("\n");
                }
            }
            // 0x100003e60
            v6 = v7;
            switch (v5) {
                case 0xf423f: {
                }
                case 0x1869f: {
                }
                case 0x270f: {
                }
                case 999: {
                    // 0x100003ec4
                    _printf("\n%uth arithmetic number is %u\n", v2, v4);
                    _printf("Number of composite arithmetic numbers <= %u: %u\n", v2, v4);
                    v6 = v7;
                    // break -> 0x100003f1c
                    break;
                }
            }
        }
    }
    // 0x100003f2c
    return 0;
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdlib.h>

int main()
{
    system("ls");
    return 0;
}
`,`#include "execute-a-system-command.h"



undefined4 entry(void)

{
  _system("ls");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _system(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__system_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main (int argc, char *argv[])
{
  printf("Signed 32-bit:\n");
  printf("%d\n", -(-2147483647-1));
  printf("%d\n", 2000000000 + 2000000000);
  printf("%d\n", -2147483647 - 2147483647);
  printf("%d\n", 46341 * 46341);
  printf("%d\n", (-2147483647-1) / -1);
  printf("Signed 64-bit:\n");
  printf("%ld\n", -(-9223372036854775807-1));
  printf("%ld\n", 5000000000000000000+5000000000000000000);
  printf("%ld\n", -9223372036854775807 - 9223372036854775807);
  printf("%ld\n", 3037000500 * 3037000500);
  printf("%ld\n", (-9223372036854775807-1) / -1);
  printf("Unsigned 32-bit:\n");
  printf("%u\n", -4294967295U);
  printf("%u\n", 3000000000U + 3000000000U);
  printf("%u\n", 2147483647U - 4294967295U);
  printf("%u\n", 65537U * 65537U);
  printf("Unsigned 64-bit:\n");
  printf("%lu\n", -18446744073709551615LU);
  printf("%lu\n", 10000000000000000000LU + 10000000000000000000LU);
  printf("%lu\n", 9223372036854775807LU - 18446744073709551615LU);
  printf("%lu\n", 4294967296LU * 4294967296LU);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f44(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d28 - 0x100003f44
int64_t entry_point(void) {
    // 0x100003d28
    _printf("Signed 32-bit:\n");
    int64_t v1; // 0x100003d28
    _printf("%d\n", v1);
    _printf("%d\n", v1);
    _printf("%d\n", v1);
    _printf("%d\n", v1);
    _printf("%d\n", v1);
    _printf("Signed 64-bit:\n");
    int32_t v2 = v1; // 0x100003df8
    _printf("%ld\n", v2);
    _printf("%ld\n", v2);
    _printf("%ld\n", v2);
    _printf("%ld\n", v2);
    _printf("%ld\n", v2);
    _printf("Unsigned 32-bit:\n");
    _printf("%u\n", v2);
    _printf("%u\n", v2);
    _printf("%u\n", v2);
    _printf("%u\n", v2);
    _printf("Unsigned 64-bit:\n");
    _printf("%lu\n", v2);
    _printf("%lu\n", v2);
    _printf("%lu\n", v2);
    _printf("%lu\n", v2);
    return 0;
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * format, ...) {
    // 0x100003f44
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`//FormAI DATASET v1.0 Category: System administration ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define ADMIN "root"

int main(){
    char username[20];
    char password[20];
    int tries = 0;

    printf("Please login to the system.\n");

    while(tries < 3){
        printf("Username: ");
        scanf("%s", username);

        printf("Password: ");
        scanf("%s", password);

        if(strcmp(username, ADMIN) == 0 && strcmp(password, "pUzzl3m3Plz!") == 0){
            printf("Welcome, %s!\n", username);
            printf("You have unlocked the secret program.\n");

            // code to run the secret program goes here.
            printf("The secret program is running...\n");

            for(int i = 0; i < 10; i++){
                char command[20];
                sprintf(command, "echo 'Puzzle piece #%d'", i+1);
                system(command);
                sleep(1);
            }

            printf("Program complete. Exiting...\n");

            return 0;
        }

        printf("Invalid username or password. Please try again.\n");
        tries++;
    }

    printf("Too many attempts. Exiting...\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// int __cdecl system(const char *Command);
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[32]; // [rsp+20h] [rbp-60h] BYREF
  char v5[32]; // [rsp+40h] [rbp-40h] BYREF
  char Str1[24]; // [rsp+60h] [rbp-20h] BYREF
  int i; // [rsp+78h] [rbp-8h]
  int v8; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 0;
  printf("Please login to the system.\n");
  while ( 1 )
  {
    if ( v8 > 2 )
    {
      printf("Too many attempts. Exiting...\n");
      return 0;
    }
    printf("Username: ");
    scanf("%s", Str1);
    printf("Password: ");
    scanf("%s", v5);
    if ( !strcmp(Str1, "root") && !strcmp(v5, "pUzzl3m3Plz!") )
      break;
    printf("Invalid username or password. Please try again.\n");
    ++v8;
  }
  printf("Welcome, %s!\n", Str1);
  printf("You have unlocked the secret program.\n");
  printf("The secret program is running...\n");
  for ( i = 0; i <= 9; ++i )
  {
    sprintf(Buffer, "echo 'Puzzle piece #%d'", (unsigned int)(i + 1));
    system(Buffer);
    sleep(1i64);
  }
  printf("Program complete. Exiting...\n");
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400028B0: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: careful
#include<stdio.h>

#define ROW 10
#define COL 10

//function to check if the given indices are within the maze bounds
int isSafe(int maze[][COL], int i, int j, int n, int m){
    if(i>=0 && i<n && j>=0 && j<m && maze[i][j]==1)
        return 1;
    return 0;
}

//function to print the path
void printSolution(int sol[][COL], int n, int m){
    printf("\nPath:\n");
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            printf("%d ", sol[i][j]);
        }
        printf("\n");
    }
}

//function to find the path from starting position to ending position in the given maze
int mazePath(int maze[][COL], int i, int j, int n, int m, int sol[][COL], int x, int y){

    if(i==x && j==y){
        sol[i][j]=1;
        return 1;
    }

    if(isSafe(maze, i, j, n, m)){
        sol[i][j]=1;

        if(mazePath(maze, i+1, j, n, m, sol, x, y)==1)
            return 1;

        if(mazePath(maze, i, j+1, n, m, sol, x, y)==1)
            return 1;

        sol[i][j]=0; 
   		//backtracking
    }

    return 0;
}

int main(){
    int maze[ROW][COL]={
        {1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
        {1, 0, 1, 0, 1, 1, 1, 0, 1, 1},
        {1, 1, 1, 0, 1, 1, 0, 1, 0, 1},
        {0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
        {1, 1, 1, 0, 1, 1, 1, 0, 1, 0},
        {1, 0, 1, 1, 1, 1, 0, 1, 0, 0},
        {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {1, 0, 1, 1, 1, 1, 0, 1, 1, 1},
        {1, 1, 0, 0, 0, 0, 1, 0, 0, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    };

    int sol[ROW][COL]={0}; //initialize all values of sol[][] as 0

    int startX=0, startY=0, endX=9, endY=9; //starting and ending positions in the maze

    printf("Maze:\n");
    for(int i=0;i<ROW;i++){
        for(int j=0;j<COL;j++){
            printf("%d ", maze[i][j]);
        }
        printf("\n");
    }

    if(mazePath(maze, startX, startY, ROW, COL, sol, endX, endY)==1)
        printSolution(sol, ROW, COL);
    else
        printf("No path found");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printSolution(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall mazePath(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, _DWORD, _DWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (0000000140001804) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[400]; // [rsp+40h] [rbp-40h] BYREF
  int v5[102]; // [rsp+1D0h] [rbp+150h] BYREF
  int v6; // [rsp+368h] [rbp+2E8h]
  int v7; // [rsp+36Ch] [rbp+2ECh]
  int v8; // [rsp+370h] [rbp+2F0h]
  int v9; // [rsp+374h] [rbp+2F4h]
  int j; // [rsp+378h] [rbp+2F8h]
  int i; // [rsp+37Ch] [rbp+2FCh]

  _main(argc, argv, envp);
  qmemcpy(v5, &unk_14000A020, 0x190ui64);
  memset(v4, 0, sizeof(v4));
  v9 = 0;
  v8 = 0;
  v7 = 9;
  v6 = 9;
  printf("Maze:\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      printf("%d ", (unsigned int)v5[10 * i + j]);
    printf("\n");
  }
  if ( (unsigned int)mazePath((unsigned int)v5, v9, v8, 10, 10, (__int64)v4, v7, v6) == 1 )
    printSolution(v4, 10i64, 10i64);
  else
    printf("No path found");
  return 0;
}
// 1400015F9: using guessed type __int64 __fastcall printSolution(_QWORD, _QWORD, _QWORD);
// 140001693: using guessed type __int64 __fastcall mazePath(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, _DWORD, _DWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001804: using guessed type int var_1C0[102];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include<string.h>
#include<stdlib.h>
#include<ctype.h>
#include<stdio.h>

#define UNITS_LENGTH 13

int main(int argC,char* argV[])
{
	int i,reference;
	char *units[UNITS_LENGTH] = {"kilometer","meter","centimeter","tochka","liniya","diuym","vershok","piad","fut","arshin","sazhen","versta","milia"};
    double factor, values[UNITS_LENGTH] = {1000.0,1.0,0.01,0.000254,0.00254,0.0254,0.04445,0.1778,0.3048,0.7112,2.1336,1066.8,7467.6};
	
	if(argC!=3)
		printf("Usage : %s followed by length as <value> <unit>");
	else{
		for(i=0;argV[2][i]!=00;i++)
			argV[2][i] = tolower(argV[2][i]);
		
		for(i=0;i<UNITS_LENGTH;i++){
			if(strstr(argV[2],units[i])!=NULL){
				reference = i;
				factor = atof(argV[1])*values[i];
				break;
			}
		}
		
		printf("%s %s is equal in length to : \n",argV[1],argV[2]);
		
		for(i=0;i<UNITS_LENGTH;i++){
			if(i!=reference)
				printf("\n%lf %s",factor/values[i],units[i]);
		}
	}
	
	return 0;
}
`,`#include "old-russian-measure-of-length.h"



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  char *pcVar2;
  int local_110;
  int local_10c;
  undefined auStack_f8 [104];
  undefined8 auStack_90 [13];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_90,&PTR_s_kilometer_100004038,0x68);
  _memcpy(auStack_f8,&DAT_100003f40,0x68);
  if (param_1 == 3) {
    for (local_10c = 0; *(char *)(*(long *)(param_2 + 0x10) + (long)local_10c) != '\0';
        local_10c = local_10c + 1) {
      iVar1 = _tolower((int)*(char *)(*(long *)(param_2 + 0x10) + (long)local_10c));
      *(char *)(*(long *)(param_2 + 0x10) + (long)local_10c) = (char)iVar1;
    }
    for (local_10c = 0; local_10c < 0xd; local_10c = local_10c + 1) {
      pcVar2 = _strstr(*(char **)(param_2 + 0x10),(char *)auStack_90[local_10c]);
      if (pcVar2 != (char *)0x0) {
        local_110 = local_10c;
        _atof(*(char **)(param_2 + 8));
        break;
      }
    }
    iVar1 = _printf("%s %s is equal in length to : \n");
    for (local_10c = 0; local_10c < 0xd; local_10c = local_10c + 1) {
      if (local_10c != local_110) {
        iVar1 = _printf("\n%lf %s");
      }
    }
  }
  else {
    iVar1 = _printf("Usage : %s followed by length as <value> <unit>");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar1);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double _atof(char *param_1)

{
  double dVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e58. Too many branches
                    // WARNING: Treating indirect jump as call
  dVar1 = (double)(*(code *)PTR__atof_100004010)();
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e64. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strstr(char *param_1,char *param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strstr_100004028)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tolower(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tolower_100004030)(_c);
  return iVar1;
}


`
`#include <stdio.h>

int main(int argc, char const *argv[]) {
  for (char c = 0x41; c < 0x5b; c ++) putchar(c);
  putchar('\n');
  for (char c = 0x61; c < 0x7b; c ++) putchar(c);
  putchar('\n');
  return 0;
}
`,`#include "idiomatically-determine-all-the-lowercase-and-uppercase-letters.h"



undefined8 entry(void)

{
  undefined local_22;
  undefined local_21;
  
  for (local_21 = 'A'; local_21 < '['; local_21 = local_21 + '\x01') {
    _putchar((int)local_21);
  }
  _putchar(10);
  for (local_22 = 'a'; local_22 < '{'; local_22 = local_22 + '\x01') {
    _putchar((int)local_22);
  }
  _putchar(10);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004000)(param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Temperature monitor ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// function to generate random temperature for each sensor
float generateTemp() {
    float temp = (float)rand()/(float)(RAND_MAX/100);
    return temp;
}

// data structure to hold information about each temperature sensor
struct Sensor {
    char name[50];
    float temperature;
    char location[50];
    int status; // 1 - Active, 0 - Inactive
};

// function to print details of each sensor
void printSensorDetails(struct Sensor sensor) {
    printf("Sensor Name: %s\n", sensor.name);
    printf("Temperature: %.2f\n", sensor.temperature);
    printf("Location: %s\n", sensor.location);
    printf("Status: %s\n", (sensor.status == 1) ? "Active" : "Inactive");
}

int main() {
    // array to hold all the temperature sensors
    struct Sensor sensors[5];
    
    // initialize values for each sensor
    sprintf(sensors[0].name, "Sensor 1");
    sensors[0].temperature = generateTemp();
    sprintf(sensors[0].location, "Room A");
    sensors[0].status = 1;
    
    sprintf(sensors[1].name, "Sensor 2");
    sensors[1].temperature = generateTemp();
    sprintf(sensors[1].location, "Room B");
    sensors[1].status = 1;
    
    sprintf(sensors[2].name, "Sensor 3");
    sensors[2].temperature = generateTemp();
    sprintf(sensors[2].location, "Room A");
    sensors[2].status = 0;
    
    sprintf(sensors[3].name, "Sensor 4");
    sensors[3].temperature = generateTemp();
    sprintf(sensors[3].location, "Room C");
    sensors[3].status = 1;
    
    sprintf(sensors[4].name, "Sensor 5");
    sensors[4].temperature = generateTemp();
    sprintf(sensors[4].location, "Room B");
    sensors[4].status = 0;
    
    // printing details of each sensor
    for(int i = 0; i < 5; i++) {
        printSensorDetails(sensors[i]);
        printf("\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
double generateTemp(void); // weak
__int64 __fastcall printSensorDetails(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001699) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  __int64 *v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rbx
  __int64 v10; // rbx
  __int64 v11; // rdx
  __int64 v13[12]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v14[2]; // [rsp+80h] [rbp+0h] BYREF
  char Buffer[52]; // [rsp+90h] [rbp+10h] BYREF
  int v16; // [rsp+C4h] [rbp+44h]
  char v17[52]; // [rsp+C8h] [rbp+48h] BYREF
  int v18; // [rsp+FCh] [rbp+7Ch]
  char v19[52]; // [rsp+100h] [rbp+80h] BYREF
  int v20; // [rsp+134h] [rbp+B4h]
  char v21[52]; // [rsp+138h] [rbp+B8h] BYREF
  int v22; // [rsp+16Ch] [rbp+ECh]
  char v23[52]; // [rsp+170h] [rbp+F0h] BYREF
  int v24; // [rsp+1A4h] [rbp+124h]
  char v25[52]; // [rsp+1A8h] [rbp+128h] BYREF
  int v26; // [rsp+1DCh] [rbp+15Ch]
  char v27[52]; // [rsp+1E0h] [rbp+160h] BYREF
  int v28; // [rsp+214h] [rbp+194h]
  char v29[52]; // [rsp+218h] [rbp+198h] BYREF
  int v30; // [rsp+24Ch] [rbp+1CCh]
  char v31[52]; // [rsp+250h] [rbp+1D0h] BYREF
  int v32; // [rsp+284h] [rbp+204h]
  char v33[52]; // [rsp+288h] [rbp+208h] BYREF
  int v34; // [rsp+2BCh] [rbp+23Ch]
  int i; // [rsp+2CCh] [rbp+24Ch]

  _main(argc, argv, envp);
  sprintf(Buffer, "Sensor 1");
  *(double *)v3.m128i_i64 = generateTemp();
  v16 = _mm_cvtsi128_si32(v3);
  sprintf(v17, "Room A");
  v18 = 1;
  sprintf(v19, "Sensor 2");
  *(double *)v3.m128i_i64 = generateTemp();
  v20 = _mm_cvtsi128_si32(v3);
  sprintf(v21, "Room B");
  v22 = 1;
  sprintf(v23, "Sensor 3");
  *(double *)v3.m128i_i64 = generateTemp();
  v24 = _mm_cvtsi128_si32(v3);
  sprintf(v25, "Room A");
  v26 = 0;
  sprintf(v27, "Sensor 4");
  *(double *)v3.m128i_i64 = generateTemp();
  v28 = _mm_cvtsi128_si32(v3);
  sprintf(v29, "Room C");
  v30 = 1;
  sprintf(v31, "Sensor 5");
  *(double *)v3.m128i_i64 = generateTemp();
  v32 = _mm_cvtsi128_si32(v3);
  sprintf(v33, "Room B");
  v34 = 0;
  for ( i = 0; i <= 4; ++i )
  {
    v4 = &v14[14 * i + 2];
    v5 = v4[1];
    v13[0] = *v4;
    v13[1] = v5;
    v6 = v4[3];
    v13[2] = v4[2];
    v13[3] = v6;
    v7 = v4[5];
    v13[4] = v4[4];
    v13[5] = v7;
    v8 = v4[7];
    v13[6] = v4[6];
    v13[7] = v8;
    v9 = v4[9];
    v13[8] = v4[8];
    v13[9] = v9;
    v10 = v4[11];
    v13[10] = v4[10];
    v13[11] = v10;
    v11 = v4[13];
    v14[0] = v4[12];
    v14[1] = v11;
    printSensorDetails(v13);
    printf("\n");
  }
  return 0;
}
// 1400016C7: variable 'v3' is possibly undefined
// 1400015D4: using guessed type double generateTemp(void);
// 140001605: using guessed type __int64 __fastcall printSensorDetails(_QWORD);
// 1400019B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001699: using guessed type char Buffer[52];
// 140001699: using guessed type char anonymous_0[52];
// 140001699: using guessed type char anonymous_1[52];
// 140001699: using guessed type char anonymous_2[52];
// 140001699: using guessed type char anonymous_3[52];
// 140001699: using guessed type char anonymous_4[52];
// 140001699: using guessed type char anonymous_5[52];
// 140001699: using guessed type char anonymous_6[52];
// 140001699: using guessed type char anonymous_7[52];
// 140001699: using guessed type char anonymous_8[52];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdint.h> /* intptr_t */
#include <stdio.h>
#include <stdlib.h> /* bsearch */
#include <string.h>
#include <search.h> /* lfind */

#define LEN(x) (sizeof(x) / sizeof(x[0]))

struct cd {
    char *name;
    double population;
};

/* Return -1 if name could not be found */
int search_get_index_by_name(const char *name, const struct cd *data, const size_t data_length,
        int (*cmp_func)(const void *, const void *))
{
    struct cd key = { (char *) name, 0 };
    struct cd *match = bsearch(&key, data, data_length,
            sizeof(struct cd), cmp_func);

    if (match == NULL)
        return -1;
    else
        return ((intptr_t) match - (intptr_t) data) / sizeof(struct cd);
}

/* Return -1 if no matching record can be found */
double search_get_pop_by_name(const char *name, const struct cd *data, size_t data_length,
        int (*cmp_func)(const void *, const void *))
{
    struct cd key = { (char *) name, 0 };
    struct cd *match = lfind(&key, data, &data_length,
            sizeof(struct cd), cmp_func);

    if (match == NULL)
        return -1;
    else
        return match->population;
}

/* Return NULL if no value satisfies threshold */
char* search_get_pop_threshold(double pop_threshold, const struct cd *data, size_t data_length,
        int (*cmp_func)(const void *, const void *))
{
    struct cd key = { NULL, pop_threshold };
    struct cd *match = lfind(&key, data, &data_length,
            sizeof(struct cd), cmp_func);

    if (match == NULL)
        return NULL;
    else
        return match->name;
}

int cd_nameChar_cmp(const void *a, const void *b)
{
    struct cd *aa = (struct cd *) a;
    struct cd *bb = (struct cd *) b;
	
	int i,len = strlen(aa->name);

	for(i=0;i<len;i++)
		if(bb->name[i]!=aa->name[i])
			return -1;
	return 0;
}

int cd_name_cmp(const void *a, const void *b)
{
    struct cd *aa = (struct cd *) a;
    struct cd *bb = (struct cd *) b;
    return strcmp(bb->name, aa->name);
}

int cd_pop_cmp(const void *a, const void *b)
{
    struct cd *aa = (struct cd *) a;
    struct cd *bb = (struct cd *) b;
    return bb->population >= aa->population;
}

int main(void)
{
    const struct cd citydata[] = {
        { "Lagos", 21 },
        { "Cairo", 15.2 },
        { "Kinshasa-Brazzaville", 11.3 },
        { "Greater Johannesburg", 7.55 },
        { "Mogadishu", 5.85 },
        { "Khartoum-Omdurman", 4.98 },
        { "Dar Es Salaam", 4.7 },
        { "Alexandria", 4.58 },
        { "Abidjan", 4.4 },
        { "Casablanca", 3.98 }
    };

    const size_t citydata_length = LEN(citydata);

    printf("%d\n", search_get_index_by_name("Dar Es Salaam", citydata, citydata_length, cd_name_cmp));
    printf("%s\n", search_get_pop_threshold(5, citydata, citydata_length, cd_pop_cmp));
    printf("%lf\n", search_get_pop_by_name("A", citydata, citydata_length, cd_nameChar_cmp));

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ad0(void);
int64_t function_100003b64(void);
int64_t function_100003bf0(void);
int64_t function_100003c74(void);
int64_t function_100003d34(void);
int64_t function_100003d78(void);
int64_t function_100003ebc(int64_t a1);
int64_t * function_100003ec8(int64_t * key, int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int64_t * function_100003ed4(int64_t * key, int64_t * base, int32_t * nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int64_t * function_100003ee0(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003eec(char * format, ...);
int32_t function_100003ef8(char * s1, char * s2);
int32_t function_100003f04(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x20000000003f10; // 0x100004040

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _bsearch(int64_t * a1, int64_t * a2, int32_t a3, int32_t a4, int32_t (*a5)(int64_t *, int64_t *));
int64_t * _lfind(int64_t * a1, int64_t * a2, int32_t * a3, int32_t a4, int32_t (*a5)(int64_t *, int64_t *));
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003ad0 - 0x100003b64
int64_t function_100003ad0(void) {
    // 0x100003ad0
    int64_t v1; // bp-72, 0x100003ad0
    int64_t v2; // 0x100003ad0
    int64_t * v3 = _bsearch(&v1, (int64_t *)v2, (int32_t)v2, 16, (int32_t (*)(int64_t *, int64_t *))v2); // 0x100003b10
    int64_t result = 0xffffffff; // 0x100003b24
    if (v3 != NULL) {
        // 0x100003b38
        result = ((int64_t)v3 - v2) / 16 & 0xffffffff;
    }
    // 0x100003b54
    return result;
}

// Address range: 0x100003b64 - 0x100003bf0
int64_t function_100003b64(void) {
    // 0x100003b64
    int64_t v1; // bp-48, 0x100003b64
    int64_t v2; // bp-72, 0x100003b64
    int64_t v3; // 0x100003b64
    int64_t * v4 = _lfind(&v2, (int64_t *)v3, (int32_t *)&v1, 16, (int32_t (*)(int64_t *, int64_t *))v3); // 0x100003ba8
    return (int64_t)v4;
}

// Address range: 0x100003bf0 - 0x100003c74
int64_t function_100003bf0(void) {
    int64_t v1 = 0; // bp-72, 0x100003c18
    int64_t v2; // bp-48, 0x100003bf0
    int64_t v3; // 0x100003bf0
    int64_t * v4 = _lfind(&v1, (int64_t *)v3, (int32_t *)&v2, 16, (int32_t (*)(int64_t *, int64_t *))v3); // 0x100003c30
    int64_t result = 0; // 0x100003c44
    if (v4 != NULL) {
        // 0x100003c54
        result = *v4;
    }
    // 0x100003c64
    return result;
}

// Address range: 0x100003c74 - 0x100003d34
int64_t function_100003c74(void) {
    // 0x100003c74
    int64_t v1; // 0x100003c74
    int32_t v2 = _strlen((char *)v1); // 0x100003ca0
    int32_t v3 = -v2; // 0x100003cbc
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100003d24
        return 0;
    }
    int32_t v4 = 0; // 0x100003cc4
    int64_t v5 = v4; // 0x100003cd4
    int64_t result = 0xffffffff; // 0x100003cf4
    while (*(char *)(v1 + v5) == *(char *)(v5 + (int64_t)v2)) {
        // 0x100003cb4
        v4++;
        int32_t v6 = v4 - v2; // 0x100003cbc
        result = 0;
        if (v6 < 0 == ((v6 ^ v4) & (v4 ^ v2)) < 0) {
            // break -> 0x100003d24
            break;
        }
        v5 = v4;
        result = 0xffffffff;
    }
    // 0x100003d24
    return result;
}

// Address range: 0x100003d34 - 0x100003d78
int64_t function_100003d34(void) {
    // 0x100003d34
    int64_t v1; // 0x100003d34
    char * v2 = (char *)v1; // 0x100003d68
    return _strcmp(v2, v2);
}

// Address range: 0x100003d78 - 0x100003db8
int64_t function_100003d78(void) {
    // 0x100003d78
    int64_t v1; // 0x100003d78
    float64_t v2 = *(float64_t *)(v1 + 8); // 0x100003d98
    float64_t v3 = *(float64_t *)(v1 + 8); // 0x100003da0
    bool v4 = false; // 0x100003da4
    bool v5 = false; // 0x100003da4
    if (v2 != v3) {
        v4 = v2 > v3;
        v5 = v2 >= v3 == v2 <= v3;
    }
    return v4 == v5;
}

// Address range: 0x100003db8 - 0x100003ebc
int64_t entry_point(void) {
    // 0x100003db8
    int64_t v1; // bp-184, 0x100003db8
    _memcpy(&v1, &g1, 160);
    function_100003ad0();
    _printf("%d\n", (int64_t)&v1);
    function_100003bf0();
    _printf("%s\n", (char *)10);
    function_100003b64();
    int128_t v2; // 0x100003db8
    int32_t v3 = _printf("%lf\n", (float64_t)(int64_t)v2); // 0x100003e84
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e94
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003ea8
        ___stack_chk_fail((int64_t)v3);
    }
    // 0x100003eac
    return 0;
}

// Address range: 0x100003ebc - 0x100003ec8
int64_t function_100003ebc(int64_t a1) {
    // 0x100003ebc
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ec8 - 0x100003ed4
int64_t * function_100003ec8(int64_t * key, int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003ec8
    return _bsearch(key, base, nmemb, size, compar);
}

// Address range: 0x100003ed4 - 0x100003ee0
int64_t * function_100003ed4(int64_t * key, int64_t * base, int32_t * nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003ed4
    return _lfind(key, base, nmemb, size, compar);
}

// Address range: 0x100003ee0 - 0x100003eec
int64_t * function_100003ee0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003ee0
    return _memcpy(dest, src, n);
}

// Address range: 0x100003eec - 0x100003ef8
int32_t function_100003eec(char * format, ...) {
    // 0x100003eec
    return _printf(format);
}

// Address range: 0x100003ef8 - 0x100003f04
int32_t function_100003ef8(char * s1, char * s2) {
    // 0x100003ef8
    return _strcmp(s1, s2);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(char * s) {
    // 0x100003f04
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`#include<string.h>
#include<stdlib.h>
#include<stdio.h>

void cartesianProduct(int** sets, int* setLengths, int* currentSet, int numSets, int times){
	int i,j;
	
	if(times==numSets){
		printf("(");
		for(i=0;i<times;i++){
			printf("%d,",currentSet[i]);
		}
		printf("\b),");
	}
	else{
		for(j=0;j<setLengths[times];j++){
			currentSet[times] = sets[times][j];
			cartesianProduct(sets,setLengths,currentSet,numSets,times+1);
		}
	}
}

void printSets(int** sets, int* setLengths, int numSets){
	int i,j;
	
	printf("\nNumber of sets : %d",numSets);
	
	for(i=0;i<numSets+1;i++){
		printf("\nSet %d : ",i+1);
		for(j=0;j<setLengths[i];j++){
			printf(" %d ",sets[i][j]);
		}
	}
}

void processInputString(char* str){
	int **sets, *currentSet, *setLengths, setLength, numSets = 0, i,j,k,l,start,counter=0;
	char *token,*holder,*holderToken;
	
	for(i=0;str[i]!=00;i++)
		if(str[i]=='x')
			numSets++;
		
	if(numSets==0){
			printf("\n%s",str);
			return;
	}
		
	currentSet = (int*)calloc(sizeof(int),numSets + 1);
	
	setLengths = (int*)calloc(sizeof(int),numSets + 1);
	
	sets = (int**)malloc((numSets + 1)*sizeof(int*));
	
	token = strtok(str,"x");
	
	while(token!=NULL){
		holder = (char*)malloc(strlen(token)*sizeof(char));
		
		j = 0;
		
		for(i=0;token[i]!=00;i++){
			if(token[i]>='0' && token[i]<='9')
				holder[j++] = token[i];
			else if(token[i]==',')
				holder[j++] = ' ';
		}
		holder[j] = 00;
		
		setLength = 0;
		
		for(i=0;holder[i]!=00;i++)
			if(holder[i]==' ')
				setLength++;
			
		if(setLength==0 && strlen(holder)==0){
			printf("\n{}");
			return;
		}
		
		setLengths[counter] = setLength+1;
		
		sets[counter] = (int*)malloc((1+setLength)*sizeof(int));
		
		k = 0;
		
		start = 0;
		
		for(l=0;holder[l]!=00;l++){
			if(holder[l+1]==' '||holder[l+1]==00){
				holderToken = (char*)malloc((l+1-start)*sizeof(char));
				strncpy(holderToken,holder + start,l+1-start);
				sets[counter][k++] = atoi(holderToken);
				start = l+2;
			}
		}
		
		counter++;
		token = strtok(NULL,"x");
	}
	
	printf("\n{");
	cartesianProduct(sets,setLengths,currentSet,numSets + 1,0);
	printf("\b}");
	
}

int main(int argC,char* argV[])
{
	if(argC!=2)
		printf("Usage : %s <Set product expression enclosed in double quotes>",argV[0]);
	else
		processInputString(argV[1]);
	
	return 0;
}
`,`#include "cartesian-product-of-two-or-more-lists.h"



ulong _cartesianProduct(ulong param_1,long param_2,long param_3,int param_4,int param_5)

{
  uint uVar1;
  ulong uVar2;
  int local_38;
  int local_34;
  
  if (param_5 == param_4) {
    _printf("(");
    for (local_34 = 0; local_34 < param_5; local_34 = local_34 + 1) {
      _printf("%d,");
    }
    uVar1 = _printf("\b),");
    uVar2 = (ulong)uVar1;
  }
  else {
    uVar2 = param_1;
    for (local_38 = 0; local_38 < *(int *)(param_2 + (long)param_5 * 4); local_38 = local_38 + 1) {
      *(undefined4 *)(param_3 + (long)param_5 * 4) =
           *(undefined4 *)(*(long *)(param_1 + (long)param_5 * 8) + (long)local_38 * 4);
      uVar2 = _cartesianProduct(param_1,param_2,param_3,param_4,param_5 + 1);
    }
  }
  return uVar2;
}



int _printSets(undefined8 param_1,long param_2,int param_3)

{
  int iVar1;
  int local_2c;
  int local_28;
  
  iVar1 = _printf("\nNumber of sets : %d");
  for (local_28 = 0; local_28 < param_3 + 1; local_28 = local_28 + 1) {
    iVar1 = _printf("\nSet %d : ");
    for (local_2c = 0; local_2c < *(int *)(param_2 + (long)local_28 * 4); local_2c = local_2c + 1) {
      iVar1 = _printf(" %d ");
    }
  }
  return iVar1;
}



int _processInputString(char *param_1)

{
  int iVar1;
  void *pvVar2;
  void *pvVar3;
  void *pvVar4;
  size_t sVar5;
  char *pcVar6;
  void *pvVar7;
  char *pcVar8;
  long lVar9;
  char *local_58;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  
  local_38 = 0;
  local_50 = 0;
  for (local_3c = 0; param_1[local_3c] != '\0'; local_3c = local_3c + 1) {
    if (param_1[local_3c] == 'x') {
      local_38 = local_38 + 1;
    }
  }
  if (local_38 == 0) {
    iVar1 = _printf("\n%s");
  }
  else {
    pvVar2 = _calloc(4,(long)(local_38 + 1));
    pvVar3 = _calloc(4,(long)(local_38 + 1));
    pvVar4 = _malloc((long)(local_38 + 1) << 3);
    local_58 = _strtok(param_1,"x");
    while (local_58 != (char *)0x0) {
      sVar5 = _strlen(local_58);
      pcVar6 = (char *)_malloc(sVar5);
      local_40 = 0;
      for (local_3c = 0; local_58[local_3c] != '\0'; local_3c = local_3c + 1) {
        if ((local_58[local_3c] < '0') || ('9' < local_58[local_3c])) {
          if (local_58[local_3c] == ',') {
            lVar9 = (long)local_40;
            local_40 = local_40 + 1;
            pcVar6[lVar9] = ' ';
          }
        }
        else {
          lVar9 = (long)local_40;
          local_40 = local_40 + 1;
          pcVar6[lVar9] = local_58[local_3c];
        }
      }
      pcVar6[local_40] = '\0';
      local_34 = 0;
      for (local_3c = 0; pcVar6[local_3c] != '\0'; local_3c = local_3c + 1) {
        if (pcVar6[local_3c] == ' ') {
          local_34 = local_34 + 1;
        }
      }
      if ((local_34 == 0) && (sVar5 = _strlen(pcVar6), sVar5 == 0)) {
        iVar1 = _printf("\n{}");
        return iVar1;
      }
      *(int *)((long)pvVar3 + (long)local_50 * 4) = local_34 + 1;
      pvVar7 = _malloc((long)(local_34 + 1) << 2);
      *(void **)((long)pvVar4 + (long)local_50 * 8) = pvVar7;
      local_44 = 0;
      local_4c = 0;
      for (local_48 = 0; pcVar6[local_48] != '\0'; local_48 = local_48 + 1) {
        if ((pcVar6[local_48 + 1] == ' ') || (pcVar6[local_48 + 1] == '\0')) {
          pcVar8 = (char *)_malloc((long)((local_48 + 1) - local_4c));
          ___strncpy_chk(pcVar8,pcVar6 + local_4c,(long)((local_48 + 1) - local_4c),
                         0xffffffffffffffff);
          iVar1 = _atoi(pcVar8);
          lVar9 = (long)local_44;
          local_44 = local_44 + 1;
          *(int *)(*(long *)((long)pvVar4 + (long)local_50 * 8) + lVar9 * 4) = iVar1;
          local_4c = local_48 + 2;
        }
      }
      local_50 = local_50 + 1;
      local_58 = _strtok((char *)0x0,"x");
    }
    _printf("\n{");
    _cartesianProduct(pvVar4,pvVar3,pvVar2,local_38 + 1,0);
    iVar1 = _printf("\b}");
  }
  return iVar1;
}



undefined8 entry(int param_1,long param_2)

{
  if (param_1 == 2) {
    _processInputString(*(undefined8 *)(param_2 + 8));
  }
  else {
    _printf("Usage : %s <Set product expression enclosed in double quotes>");
  }
  return 0;
}



void ___strncpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strncpy_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004028)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strtok(char *param_1,char *param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strtok_100004030)();
  return pcVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(){
   char array[] = { 'a', 'b', 'c','d','e','f','g','h','i','j' };
   int i;
   time_t t;
   srand((unsigned)time(&t));

   for(i=0;i<30;i++){
		printf("%c\n", array[rand()%10]);
   }

   return 0;
}
`,`#include "pick-random-element.h"



undefined8 entry(void)

{
  time_t tVar1;
  time_t tStack_38;
  int local_30;
  undefined4 local_2c;
  undefined8 local_28;
  undefined2 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_2c = 0;
  local_28 = 0x6867666564636261;
  local_20 = 0x6a69;
  tVar1 = _time(&tStack_38);
  _srand((uint)tVar1);
  for (local_30 = 0; local_30 < 0x1e; local_30 = local_30 + 1) {
    _rand();
    _printf("%c\n");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004018)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004028)();
  return tVar1;
}


`
`#include <stdio.h>
#include <string.h>

#define FOR(x, y) for(x = 0; x < y; x++)
char *best_shuffle(const char *s, int *diff)
{
	int i, j = 0, max = 0, l = strlen(s), cnt[128] = {0};
	char buf[256] = {0}, *r;

	FOR(i, l) if (++cnt[(int)s[i]] > max) max = cnt[(int)s[i]];
	FOR(i, 128) while (cnt[i]--) buf[j++] = i;

	r = strdup(s);
	FOR(i, l) FOR(j, l)
		if (r[i] == buf[j]) {
			r[i] = buf[(j + max) % l] & ~128;
			buf[j] |= 128;
			break;
		}

	*diff = 0;
	FOR(i, l) *diff += r[i] == s[i];

	return r;
}

int main()
{
	int i, d;
	const char *r, *t[] = {"abracadabra", "seesaw", "elk", "grrrrrr", "up", "a", 0};
	for (i = 0; t[i]; i++) {
		r = best_shuffle(t[i], &d);
		printf("%s %s (%d)\n", t[i], r, d);
	}
	return 0;
}
`,`#include "best-shuffle-4.h"



char * _best_shuffle(char *param_1,int *param_2)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  int iVar4;
  long lVar5;
  int local_344;
  int local_340;
  int local_33c;
  byte abStack_328 [256];
  int aiStack_228 [128];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_340 = 0;
  local_344 = 0;
  sVar2 = _strlen(param_1);
  iVar4 = (int)sVar2;
  _bzero(aiStack_228,0x200);
  _memset(abStack_328,0,0x100);
  for (local_33c = 0; local_33c < iVar4; local_33c = local_33c + 1) {
    iVar1 = aiStack_228[param_1[local_33c]] + 1;
    aiStack_228[param_1[local_33c]] = iVar1;
    if (local_344 < iVar1) {
      local_344 = aiStack_228[param_1[local_33c]];
    }
  }
  for (local_33c = 0; local_33c < 0x80; local_33c = local_33c + 1) {
    while (iVar1 = aiStack_228[local_33c], aiStack_228[local_33c] = iVar1 + -1, iVar1 != 0) {
      lVar5 = (long)local_340;
      local_340 = local_340 + 1;
      abStack_328[lVar5] = (byte)local_33c;
    }
  }
  pcVar3 = _strdup(param_1);
  local_33c = 0;
  do {
    if (iVar4 <= local_33c) {
      *param_2 = 0;
      for (local_33c = 0; local_33c < iVar4; local_33c = local_33c + 1) {
        *param_2 = *param_2 + (uint)(pcVar3[local_33c] == param_1[local_33c]);
      }
      if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
        return pcVar3;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    for (local_340 = 0; local_340 < iVar4; local_340 = local_340 + 1) {
      if (pcVar3[local_33c] == abStack_328[local_340]) {
        iVar1 = 0;
        if (iVar4 != 0) {
          iVar1 = (local_340 + local_344) / iVar4;
        }
        pcVar3[local_33c] = abStack_328[(local_340 + local_344) - iVar1 * iVar4] & 0x7f;
        abStack_328[local_340] = abStack_328[local_340] | 0x80;
        break;
      }
    }
    local_33c = local_33c + 1;
  } while( true );
}



undefined8 entry(void)

{
  uint uVar1;
  void *pvVar2;
  undefined local_5c [4];
  int local_58;
  undefined4 local_54;
  long alStack_50 [7];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_54 = 0;
  pvVar2 = _memcpy(alStack_50,&PTR_s_abracadabra_100004040,0x38);
  for (local_58 = 0; alStack_50[local_58] != 0; local_58 = local_58 + 1) {
    _best_shuffle(alStack_50[local_58],local_5c);
    uVar1 = _printf("%s %s (%d)\n");
    pvVar2 = (void *)(ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pvVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _bzero(void *param_1,size_t param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__bzero_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004020)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004030)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004038)();
  return sVar1;
}


`
`//FormAI DATASET v1.0 Category: Temperature Converter ; Style: systematic
#include <stdio.h>

int celsius_to_fahrenheit(int celsius) {
  return (celsius * 9/5) + 32;
}

int fahrenheit_to_celsius(int fahrenheit) {
  return (fahrenheit - 32) * 5/9;
}

int main() {
  int choice, temp;

  printf("Welcome to the temperature converter!\n");
  printf("1. Convert Celsius to Fahrenheit\n");
  printf("2. Convert Fahrenheit to Celsius\n");
  printf("Enter your choice: ");
  scanf("%d", &choice);

  switch (choice) {
    case 1:
      printf("Enter temperature in Celsius: ");
      scanf("%d", &temp);
      printf("%d degrees Celsius is %d degrees Fahrenheit.\n", temp, celsius_to_fahrenheit(temp));
      break;
    case 2:
      printf("Enter temperature in Fahrenheit: ");
      scanf("%d", &temp);
      printf("%d degrees Fahrenheit is %d degrees Celsius.\n", temp, fahrenheit_to_celsius(temp));
      break;
    default:
      printf("Invalid choice. Please try again.\n");
      break;
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall celsius_to_fahrenheit(_QWORD); // weak
__int64 __fastcall fahrenheit_to_celsius(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001640) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v6; // [rsp+28h] [rbp-8h] BYREF
  int v7; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the temperature converter!\n");
  printf("1. Convert Celsius to Fahrenheit\n");
  printf("2. Convert Fahrenheit to Celsius\n");
  printf("Enter your choice: ");
  scanf("%d", &v7);
  if ( v7 == 1 )
  {
    printf("Enter temperature in Celsius: ");
    scanf("%d", &v6);
    v3 = celsius_to_fahrenheit(v6);
    printf("%d degrees Celsius is %d degrees Fahrenheit.\n", v6, v3);
  }
  else if ( v7 == 2 )
  {
    printf("Enter temperature in Fahrenheit: ");
    scanf("%d", &v6);
    v4 = fahrenheit_to_celsius(v6);
    printf("%d degrees Fahrenheit is %d degrees Celsius.\n", v6, v4);
  }
  else
  {
    printf("Invalid choice. Please try again.\n");
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall celsius_to_fahrenheit(_QWORD);
// 140001611: using guessed type __int64 __fastcall fahrenheit_to_celsius(_QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>
struct node
{
    int data;
    struct node *next;
};

struct node *head1 = NULL;
struct node *head2 = NULL;

///// MAIN ALGORITHMIC FUNCTION to MERGE the two input linked lists ///////

void merge()
{
    struct node *temp1 = head1;
    struct node *temp2 = head2;

    struct node *holder1 = NULL;
    struct node *holder2 = NULL;
    // Temporary pointer variables to store the address of next node of the two
    // input linked list

    while (temp1 != NULL && temp2 != NULL)
    {
        holder1 = temp1->next;
        // Storing the address of next node of first linked list
        temp1->next = temp2;
        // Making the first node of first linked list point to first node of
        // second linked list

        if (holder1 != NULL)
        {
            // Making the first node of second linked list point to second node
            // of first linked list
            holder2 = temp2->next;
            temp2->next = holder1;
        }
        temp1 = holder1;
        temp2 = holder2;
        // Updating the address location of two pointer variables temp1 and
        // temp2
    }
}

void printlist(struct node *temp)
{
    printf("%d", temp->data);
    temp = temp->next;
    while (temp != NULL)
    {
        printf("->%d", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main()
{
    // Linked List 1: 1->3->5->7   :   Linked List 2: 2->4->6
    //  making lists
    struct node *one = (struct node *)malloc(sizeof(struct node));
    struct node *two = (struct node *)malloc(sizeof(struct node));
    struct node *three = (struct node *)malloc(sizeof(struct node));
    struct node *four = (struct node *)malloc(sizeof(struct node));
    struct node *five = (struct node *)malloc(sizeof(struct node));
    struct node *six = (struct node *)malloc(sizeof(struct node));
    struct node *seven = (struct node *)malloc(sizeof(struct node));
    // Seven nodes are created

    head1 = one;
    head2 = two;
    // head1 points to first node of first linked list
    // head2 points to first node of second linked list

    one->data = 1;
    one->next = three;

    two->data = 2;
    two->next = four;

    three->data = 3;
    three->next = five;

    four->data = 4;
    four->next = six;

    five->data = 5;
    five->next = seven;

    six->data = 6;
    six->next = NULL;
    // Last node of second input linked list

    seven->data = 7;
    seven->next = NULL;
    // Last node of first input linked list

    printf("Linked List 1: ");
    printlist(head1);
    printf("\nLinked List 2: ");
    printlist(head2);

    // Merging the two linked list into single linked list
    merge();

    printf("\nMerged Linked List: ");
    printlist(head1);  // list one has been modified

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c3c(void);
int64_t function_100003d04(void);
int64_t * function_100003f44(int32_t size);
int32_t function_100003f50(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
int64_t g2 = 0x200000000; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c3c - 0x100003d04
int64_t function_100003c3c(void) {
    // 0x100003c3c
    int64_t result; // 0x100003c3c
    if (g1 != 0 != g2 != 0) {
        // 0x100003cfc
        return result;
    }
    int64_t v1 = g2; // 0x100003c98
    int64_t * v2 = (int64_t *)(g1 + 8); // 0x100003ca4
    int64_t v3 = *v2; // 0x100003ca4
    *v2 = v1;
    while (v3 != 0) {
        int64_t * v4 = (int64_t *)(v1 + 8); // 0x100003cd0
        v1 = *v4;
        *v4 = v3;
        if (v1 == 0) {
            // break -> 0x100003cfc
            break;
        }
        v2 = (int64_t *)(v3 + 8);
        v3 = *v2;
        *v2 = v1;
    }
    // 0x100003cfc
    return result;
}

// Address range: 0x100003d04 - 0x100003da0
int64_t function_100003d04(void) {
    // 0x100003d04
    int64_t v1; // 0x100003d04
    _printf("%d", v1);
    int64_t v2 = *(int64_t *)(v1 + 8);
    if (v2 == 0) {
        // 0x100003d88
        return _printf("\n");
    }
    int64_t v3 = v2; // 0x100003d50
    _printf("->%d", v1);
    v3 += 8;
    while (v3 != 0) {
        // 0x100003d58
        _printf("->%d", v1);
        v3 += 8;
    }
    // 0x100003d88
    return _printf("\n");
}

// Address range: 0x100003da0 - 0x100003f44
int64_t entry_point(void) {
    int64_t * v1 = _malloc(16); // 0x100003dc0
    int64_t v2 = (int64_t)v1; // 0x100003dc0
    int64_t * v3 = _malloc(16); // 0x100003dd0
    int64_t v4 = (int64_t)v3; // 0x100003dd0
    int64_t * v5 = _malloc(16); // 0x100003de0
    int64_t v6 = (int64_t)v5; // 0x100003de0
    int64_t * v7 = _malloc(16); // 0x100003df0
    int64_t v8 = (int64_t)v7; // 0x100003df0
    int64_t * v9 = _malloc(16); // 0x100003e00
    int64_t v10 = (int64_t)v9; // 0x100003e00
    int64_t * v11 = _malloc(16); // 0x100003e10
    int64_t v12 = (int64_t)v11; // 0x100003e10
    int64_t * v13 = _malloc(16); // 0x100003e20
    int64_t v14 = (int64_t)v13; // 0x100003e20
    g1 = v2;
    g2 = v4;
    *(int32_t *)v1 = 1;
    *(int64_t *)(v2 + 8) = v6;
    *(int32_t *)v3 = 2;
    *(int64_t *)(v4 + 8) = v8;
    *(int32_t *)v5 = 3;
    *(int64_t *)(v6 + 8) = v10;
    *(int32_t *)v7 = 4;
    *(int64_t *)(v8 + 8) = v12;
    *(int32_t *)v9 = 5;
    *(int64_t *)(v10 + 8) = v14;
    *(int32_t *)v11 = 6;
    *(int64_t *)(v12 + 8) = 0;
    *(int32_t *)v13 = 7;
    *(int64_t *)(v14 + 8) = 0;
    _printf("Linked List 1: ");
    function_100003d04();
    _printf("\nLinked List 2: ");
    function_100003d04();
    function_100003c3c();
    _printf("\nMerged Linked List: ");
    function_100003d04();
    return 0;
}

// Address range: 0x100003f44 - 0x100003f50
int64_t * function_100003f44(int32_t size) {
    // 0x100003f44
    return _malloc(size);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * format, ...) {
    // 0x100003f50
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

#define SIDE 600
#define NUM_PARTICLES 10000

bool W[SIDE][SIDE];

int main() {
    srand((unsigned)time(NULL));
    W[SIDE / 2][SIDE / 2] = true;

    for (int i = 0; i < NUM_PARTICLES; i++) {
        unsigned int x, y;
        OVER: do {
            x = rand() % (SIDE - 2) + 1;
            y = rand() % (SIDE - 2) + 1;
        } while (W[y][x]);

        while (W[y-1][x-1] + W[y-1][x] + W[y-1][x+1] +
               W[y][x-1]               + W[y][x+1] +
               W[y+1][x-1] + W[y+1][x] + W[y+1][x+1] == 0) {
            unsigned int dxy = rand() % 8;
            if (dxy > 3) dxy++;
            x += (dxy % 3) - 1;
            y += (dxy / 3) - 1;
            if (x < 1 || x >= SIDE - 1 || y < 1 || y >= SIDE - 1)
                goto OVER;
        }

        W[y][x] = true;
    }

    printf("P1\n%d %d\n", SIDE, SIDE);
    for (int r = 0; r < SIDE; r++) {
        for (int c = 0; c < SIDE; c++)
            printf("%d ", W[r][c]);
        putchar('\n');
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f5c(char * format, ...);
int32_t function_100003f68(int32_t c);
int32_t function_100003f74(void);
void function_100003f80(int32_t seed);
int32_t function_100003f8c(int32_t * timer);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000
char * g2; // 0x10003404c

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b30 - 0x100003f5c
int64_t entry_point(void) {
    // 0x100003b30
    _srand(_time(NULL));
    *(char *)&g2 = 1;
    int32_t v1 = 0; // 0x100003e80
    int32_t v2; // 0x100003b30
    while (true) {
      lab_0x100003b8c_2:
        // 0x100003b8c
        v2 = v1;
        goto lab_0x100003b8c;
    }
  lab_0x100003e8c:;
    // 0x100003e8c
    int64_t v3; // 0x100003b30
    _printf("P1\n%d %d\n", v3, v3);
    int32_t v4 = 0;
    int32_t v5 = 0;
    _printf("%d ", v3);
    int32_t v6 = v5 + 1; // 0x100003f24
    while (v5 < 599 != (598 - v5 & v6) < 0) {
        // 0x100003ee0
        v5 = v6;
        _printf("%d ", v3);
        v6 = v5 + 1;
    }
    // 0x100003f30
    _putchar(10);
    int32_t v7 = v4 + 1; // 0x100003f40
    while (v4 < 599 != (598 - v4 & v7) < 0) {
        // 0x100003ecc
        v4 = v7;
        v5 = 0;
        _printf("%d ", v3);
        v6 = v5 + 1;
        while (v5 < 599 != (598 - v5 & v6) < 0) {
            // 0x100003ee0
            v5 = v6;
            _printf("%d ", v3);
            v6 = v5 + 1;
        }
        // 0x100003f30
        _putchar(10);
        v7 = v4 + 1;
    }
    // 0x100003f4c
    return 0;
  lab_0x100003c00:;
    // 0x100003c00
    int32_t v8; // 0x100003b30
    uint32_t v9 = v8 - 1;
    int64_t v10 = 600 * (int64_t)v9 + (int64_t)&g1; // 0x100003c20
    int32_t v11; // 0x100003b30
    uint32_t v12 = v11 - 1;
    int64_t v13 = v12; // 0x100003c2c
    unsigned char v14 = *(char *)(v10 + v13); // 0x100003c34
    int64_t v15 = v11; // 0x100003c50
    unsigned char v16 = *(char *)(v10 + v15); // 0x100003c58
    int64_t v17 = v11 + 1; // 0x100003c80
    unsigned char v18 = *(char *)(v10 + v17); // 0x100003c88
    int64_t v19 = 600 * (int64_t)v8 + (int64_t)&g1; // 0x100003ca0
    unsigned char v20 = *(char *)(v19 + v13); // 0x100003cb4
    unsigned char v21 = *(char *)(v19 + v17); // 0x100003ce0
    int64_t v22 = 600 * (int64_t)(v8 + 1) + (int64_t)&g1; // 0x100003cfc
    unsigned char v23 = *(char *)(v22 + v13); // 0x100003d10
    unsigned char v24 = *(char *)(v22 + v15); // 0x100003d38
    unsigned char v25 = *(char *)(v22 + v17); // 0x100003d64
    if ((int32_t)(v16 % 2 + v14 % 2 + v18 % 2 + v20 % 2 + v21 % 2 + v23 % 2 + v24 % 2) == -(int32_t)(v25 % 2)) {
        int32_t v26 = _rand(); // 0x100003d80
        uint32_t v27 = v26 - 8 * v26 / 8; // 0x100003d90
        uint32_t v28 = v27 + (int32_t)(v27 != 3 == v27 >= 3);
        int32_t v29 = v28 % 3 + v12; // 0x100003dd8
        int32_t v30 = v28 / 3 + v9; // 0x100003df0
        v8 = v30;
        v11 = v29;
        if (v30 < 599 == v29 < 599) {
            goto lab_0x100003c00;
        } else {
            goto lab_0x100003b8c;
        }
    } else {
        goto lab_0x100003e50;
    }
  lab_0x100003b8c:
    while (true) {
        while (true) {
            int32_t v31 = _rand() % 598 + 1; // 0x100003ba8
            int32_t v32 = _rand() % 598 + 1; // 0x100003bc4
            unsigned char v33 = *(char *)((int64_t)v31 + (int64_t)&g1 + 600 * (int64_t)v32); // 0x100003bf0
            v8 = v32;
            v11 = v31;
            if (v33 % 2 == 0) {
                goto lab_0x100003c00;
            }
        }
    }
    goto lab_0x100003e50;
  lab_0x100003e50:
    // 0x100003e50
    *(char *)(v19 + v15) = 1;
    v1 = v2 + 1;
    if (v2 < 0x270f == (0x270e - v2 & v1) < 0) {
        // break -> 0x100003e8c
        goto lab_0x100003e8c;
    }
    goto lab_0x100003b8c_2;
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(int32_t c) {
    // 0x100003f68
    return _putchar(c);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(void) {
    // 0x100003f74
    return _rand();
}

// Address range: 0x100003f80 - 0x100003f8c
void function_100003f80(int32_t seed) {
    // 0x100003f80
    _srand(seed);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(int32_t * timer) {
    // 0x100003f8c
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdbool.h>
#include <stdio.h>
#include <string.h>

int inv(int a) {
    return a ^ -1;
}

struct Zeckendorf {
    int dVal, dLen;
};

void a(struct Zeckendorf *self, int n) {
    void b(struct Zeckendorf *, int); // forward declare

    int i = n;
    while (true) {
        if (self->dLen < i) self->dLen = i;
        int j = (self->dVal >> (i * 2)) & 3;
        switch (j) {
        case 0:
        case 1:
            return;
        case 2:
            if (((self->dVal >> ((i + 1) * 2)) & 1) != 1) return;
            self->dVal += 1 << (i * 2 + 1);
            return;
        case 3:
            self->dVal = self->dVal & inv(3 << (i * 2));
            b(self, (i + 1) * 2);
            break;
        default:
            break;
        }
        i++;
    }
}

void b(struct Zeckendorf *self, int pos) {
    void increment(struct Zeckendorf *); // forward declare

    if (pos == 0) {
        increment(self);
        return;
    }
    if (((self->dVal >> pos) & 1) == 0) {
        self->dVal += 1 << pos;
        a(self, pos / 2);
        if (pos > 1) a(self, pos / 2 - 1);
    } else {
        self->dVal = self->dVal & inv(1 << pos);
        b(self, pos + 1);
        b(self, pos - (pos > 1 ? 2 : 1));
    }
}

void c(struct Zeckendorf *self, int pos) {
    if (((self->dVal >> pos) & 1) == 1) {
        self->dVal = self->dVal & inv(1 << pos);
        return;
    }
    c(self, pos + 1);
    if (pos > 0) {
        b(self, pos - 1);
    } else {
        increment(self);
    }
}

struct Zeckendorf makeZeckendorf(char *x) {
    struct Zeckendorf z = { 0, 0 };
    int i = strlen(x) - 1;
    int q = 1;

    z.dLen = i / 2;
    while (i >= 0) {
        z.dVal += (x[i] - '0') * q;
        q *= 2;
        i--;
    }

    return z;
}

void increment(struct Zeckendorf *self) {
    self->dVal++;
    a(self, 0);
}

void addAssign(struct Zeckendorf *self, struct Zeckendorf rhs) {
    int gn;
    for (gn = 0; gn < (rhs.dLen + 1) * 2; gn++) {
        if (((rhs.dVal >> gn) & 1) == 1) {
            b(self, gn);
        }
    }
}

void subAssign(struct Zeckendorf *self, struct Zeckendorf rhs) {
    int gn;
    for (gn = 0; gn < (rhs.dLen + 1) * 2; gn++) {
        if (((rhs.dVal >> gn) & 1) == 1) {
            c(self, gn);
        }
    }
    while ((((self->dVal >> self->dLen * 2) & 3) == 0) || (self->dLen == 0)) {
        self->dLen--;
    }
}

void mulAssign(struct Zeckendorf *self, struct Zeckendorf rhs) {
    struct Zeckendorf na = rhs;
    struct Zeckendorf nb = rhs;
    struct Zeckendorf nr = makeZeckendorf("0");
    struct Zeckendorf nt;
    int i;

    for (i = 0; i < (self->dLen + 1) * 2; i++) {
        if (((self->dVal >> i) & 1) > 0) addAssign(&nr, nb);
        nt = nb;
        addAssign(&nb, na);
        na = nt;
    }

    *self = nr;
}

void printZeckendorf(struct Zeckendorf z) {
    static const char *const dig[3] = { "00", "01", "10" };
    static const char *const dig1[3] = { "", "1", "10" };

    if (z.dVal == 0) {
        printf("0");
        return;
    } else {
        int idx = (z.dVal >> (z.dLen * 2)) & 3;
        int i;

        printf(dig1[idx]);
        for (i = z.dLen - 1; i >= 0; i--) {
            idx = (z.dVal >> (i * 2)) & 3;
            printf(dig[idx]);
        }
    }
}

int main() {
    struct Zeckendorf g;

    printf("Addition:\n");
    g = makeZeckendorf("10");
    addAssign(&g, makeZeckendorf("10"));
    printZeckendorf(g);
    printf("\n");
    addAssign(&g, makeZeckendorf("10"));
    printZeckendorf(g);
    printf("\n");
    addAssign(&g, makeZeckendorf("1001"));
    printZeckendorf(g);
    printf("\n");
    addAssign(&g, makeZeckendorf("1000"));
    printZeckendorf(g);
    printf("\n");
    addAssign(&g, makeZeckendorf("10101"));
    printZeckendorf(g);
    printf("\n\n");

    printf("Subtraction:\n");
    g = makeZeckendorf("1000");
    subAssign(&g, makeZeckendorf("101"));
    printZeckendorf(g);
    printf("\n");
    g = makeZeckendorf("10101010");
    subAssign(&g, makeZeckendorf("1010101"));
    printZeckendorf(g);
    printf("\n\n");

    printf("Multiplication:\n");
    g = makeZeckendorf("1001");
    mulAssign(&g, makeZeckendorf("101"));
    printZeckendorf(g);
    printf("\n");
    g = makeZeckendorf("101010");
    addAssign(&g, makeZeckendorf("101"));
    printZeckendorf(g);
    printf("\n");

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000351c(void);
int64_t function_100003534(void);
int64_t function_1000036a4(void);
int64_t function_1000037d4(int64_t a1);
int64_t function_10000380c(void);
int64_t function_1000038c4(void);
int64_t function_100003968(void);
int64_t function_1000039f0(void);
int64_t function_100003ae4(void);
int64_t function_100003bb8(void);
int32_t function_100003f1c(char * format, ...);
int32_t function_100003f28(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x10000351c - 0x100003534
int64_t function_10000351c(void) {
    // 0x10000351c
    int64_t v1; // 0x10000351c
    return v1 & 0xffffffff ^ 0xffffffff;
}

// Address range: 0x100003534 - 0x1000036a4
int64_t function_100003534(void) {
    // 0x100003534
    int64_t v1; // 0x100003534
    int32_t * v2 = (int32_t *)v1; // 0x100003540
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x100003558
    int32_t v4 = v1;
    int32_t v5 = *v3; // 0x100003558
    int32_t v6 = v5 - v4; // 0x100003560
    int32_t v7 = v1; // 0x100003568
    int64_t result; // 0x100003534
    if (v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0) {
        // 0x100003570
        *v3 = v4;
        v7 = *(int32_t *)&result;
    }
    int32_t v8 = v7; // 0x100003584
    uint32_t v9 = 2 * v4; // 0x10000358c
    uint32_t v10 = (v8 >> v9) % 4; // 0x100003594
    while (v10 != 1 && v10 != 0) {
        int32_t v11 = v8; // 0x100003534
        switch (v10) {
            case 2: {
                if ((v8 & 1 << v9 + 2) != 0) {
                    // 0x100003614
                    *v2 = v8 + (1 << (v9 | 1));
                }
                // 0x100003698
                return result;
            }
            case 3: {
                // 0x10000363c
                *v2 = v8 & (int32_t)function_10000351c();
                int64_t v12 = function_1000036a4(); // 0x10000367c
                result = v12;
                v11 = v12;
                // break -> 0x100003688
                break;
            }
        }
        // 0x100003688
        v4++;
        v5 = *v3;
        v6 = v5 - v4;
        v7 = v11;
        if (v6 < 0 != ((v6 ^ v5) & (v5 ^ v4)) < 0) {
            // 0x100003570
            *v3 = v4;
            v7 = *(int32_t *)&result;
        }
        // 0x100003580
        v8 = v7;
        v9 = 2 * v4;
        v10 = (v8 >> v9) % 4;
    }
    // 0x100003698
    return result;
}

// Address range: 0x1000036a4 - 0x1000037d4
int64_t function_1000036a4(void) {
    // 0x1000036a4
    int64_t v1; // 0x1000036a4
    uint32_t v2 = (int32_t)v1; // 0x1000036b4
    if (v2 == 0) {
        // 0x1000037c8
        return function_1000037d4(v1);
    }
    int32_t * v3 = (int32_t *)v1; // 0x1000036b0
    int32_t v4 = v1;
    int32_t v5 = 1 << v2;
    if ((v5 & v4) != 0) {
        // 0x10000375c
        *v3 = (int32_t)(function_10000351c() & v1);
        function_1000036a4();
        // 0x1000037c8
        return function_1000036a4();
    }
    // 0x1000036f8
    *v3 = v5 + v4;
    int32_t v6 = v2 - 1; // 0x10000372c
    int64_t result = function_100003534(); // 0x100003734
    if (v6 != 0 && v6 < 0 == (v2 & -v2) < 0) {
        // 0x10000373c
        result = function_100003534();
    }
    // 0x1000037c8
    return result;
}

// Address range: 0x1000037d4 - 0x10000380c
int64_t function_1000037d4(int64_t a1) {
    // 0x1000037d4
    int64_t v1; // 0x1000037d4
    *(int32_t *)a1 = (int32_t)v1 + 1;
    return function_100003534();
}

// Address range: 0x10000380c - 0x1000038c4
int64_t function_10000380c(void) {
    // 0x10000380c
    int64_t v1; // 0x10000380c
    int64_t v2 = v1;
    int32_t v3 = v1; // 0x10000381c
    if ((1 << v3 & (int32_t)v2) != 0) {
        int64_t result = function_10000351c(); // 0x10000385c
        *(int32_t *)v2 = (int32_t)(result & v2);
        // 0x1000038b8
        return result;
    }
    // 0x100003874
    function_10000380c();
    int64_t result2; // 0x10000380c
    if (v3 < 1) {
        // 0x1000038ac
        result2 = function_1000037d4(v2);
    } else {
        // 0x100003898
        result2 = function_1000036a4();
    }
    // 0x1000038b8
    return result2;
}

// Address range: 0x1000038c4 - 0x100003968
int64_t function_1000038c4(void) {
    // 0x1000038c4
    int64_t v1; // 0x1000038c4
    int32_t v2 = _strlen((char *)v1) - 1;
    if (v2 < 0) {
        // 0x100003958
        return 0;
    }
    int64_t v3 = v2; // 0x1000038c4
    int32_t v4 = v2;
    int32_t v5 = 1; // 0x1000038c4
    int32_t result = 0; // 0x100003934
    char v6 = *(char *)(v3 + v1); // 0x100003920
    result += ((int32_t)v6 - 48) * v5;
    v4--;
    v3--;
    v5 *= 2;
    while (v4 >= 0) {
        // 0x100003918
        v6 = *(char *)(v3 + v1);
        result += ((int32_t)v6 - 48) * v5;
        v4--;
        v3--;
        v5 *= 2;
    }
    // 0x100003958
    return result;
}

// Address range: 0x100003968 - 0x1000039f0
int64_t function_100003968(void) {
    // 0x100003968
    int32_t v1; // 0x100003968
    int32_t v2 = 2 * v1; // 0x10000398c
    int32_t v3 = v2 + 2; // 0x100003990
    int32_t v4 = -2 - v2; // 0x100003990
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x1000039e4
        int64_t result; // 0x100003968
        return result;
    }
    int32_t v5 = 0; // 0x100003998
    int64_t v6; // 0x100003968
    int64_t result2 = v6; // 0x1000039b8
    int64_t v7; // 0x100003968
    if ((1 << v5 & (int32_t)v7) != 0) {
        // 0x1000039c0
        result2 = function_1000036a4();
    }
    // 0x1000039d4
    v5++;
    int32_t v8 = v5 - v3; // 0x100003990
    while (v8 < 0 != ((v8 ^ v5) & (v5 ^ v3)) < 0) {
        // 0x1000039a0
        if ((1 << v5 & (int32_t)v7) != 0) {
            // 0x1000039c0
            result2 = function_1000036a4();
        }
        // 0x1000039d4
        v5++;
        v8 = v5 - v3;
    }
    // 0x1000039e4
    return result2;
}

// Address range: 0x1000039f0 - 0x100003ae4
int64_t function_1000039f0(void) {
    // 0x1000039f0
    int32_t v1; // 0x1000039f0
    int32_t v2 = 2 * v1; // 0x100003a14
    int32_t v3 = v2 + 2; // 0x100003a18
    int32_t v4 = -2 - v2; // 0x100003a18
    int32_t v5 = 0; // 0x100003a20
    int64_t result; // 0x1000039f0
    int64_t v6; // 0x1000039f0
    int64_t result2; // 0x1000039f0
    if (v4 < 0 != (v4 & v3) < 0) {
        int64_t v7; // 0x1000039f0
        int64_t v8 = v7; // 0x100003a40
        if ((1 << v5 & (int32_t)v6) != 0) {
            // 0x100003a48
            v8 = function_10000380c();
        }
        int64_t v9 = v8;
        v5++;
        int32_t v10 = v5 - v3; // 0x100003a18
        while (v10 < 0 != ((v10 ^ v5) & (v5 ^ v3)) < 0) {
            // 0x100003a28
            v8 = v9;
            if ((1 << v5 & (int32_t)v6) != 0) {
                // 0x100003a48
                v8 = function_10000380c();
            }
            // 0x100003a5c
            v9 = v8;
            v5++;
            v10 = v5 - v3;
        }
        // 0x100003a0c
        result2 = v9;
        result = v9;
    }
    int32_t * v11 = (int32_t *)(v6 + 4); // 0x100003a7c
    int32_t v12 = *v11; // 0x100003a7c
    if (v12 != 0 == (((int32_t)result >> 2 * v12) % 4 != 0)) {
        // 0x100003ad8
        return result;
    }
    int32_t v13 = v12; // 0x100003a98
    v13--;
    *v11 = v13;
    while (v13 != 0 != (*(int32_t *)&result2 >> 2 * v13) % 4 != 0) {
        // 0x100003ac4
        v13--;
        *v11 = v13;
    }
    // 0x100003ad8
    return result2;
}

// Address range: 0x100003ae4 - 0x100003bb8
int64_t function_100003ae4(void) {
    int64_t result = function_1000038c4(); // 0x100003b10
    int64_t v1; // 0x100003ae4
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x100003b28
    int32_t v3 = 2 * *v2; // 0x100003b2c
    int32_t v4 = -2 - v3; // 0x100003b30
    int32_t v5 = 0; // 0x100003b38
    if (v4 < 0 == (v4 & v3 + 2) < 0) {
        // 0x100003ba0
        *(int64_t *)v1 = result;
        return result;
    }
    if ((1 << v5 & (int32_t)result) != 0) {
        // 0x100003b60
        function_100003968();
    }
    int64_t result2 = function_100003968(); // 0x100003b80
    v5++;
    int32_t v6 = 2 * *v2 + 2; // 0x100003b30
    int32_t v7 = v5 - v6; // 0x100003b30
    while (v7 < 0 != ((v7 ^ v5) & (v6 ^ v5)) < 0) {
        // 0x100003b40
        if ((1 << v5 & (int32_t)result2) != 0) {
            // 0x100003b60
            function_100003968();
        }
        // 0x100003b70
        result2 = function_100003968();
        v5++;
        v6 = 2 * *v2 + 2;
        v7 = v5 - v6;
    }
    // 0x100003ba0
    *(int64_t *)v1 = result;
    return result2;
}

// Address range: 0x100003bb8 - 0x100003c8c
int64_t function_100003bb8(void) {
    // 0x100003bb8
    int64_t v1; // 0x100003bb8
    int32_t v2 = v1; // 0x100003bc4
    if (v2 == 0) {
        // 0x100003c80
        return _printf("0");
    }
    // 0x100003bec
    int32_t v3; // 0x100003bb8
    int64_t v4 = *(int64_t *)((int64_t)(8 * (v2 >> 2 * v3) & 24) + (int64_t)"??"); // 0x100003c10
    int32_t v5 = v3 - 1;
    int32_t v6 = v5; // 0x100003c34
    int32_t result = _printf((char *)v4); // 0x100003c34
    if (v5 < 0) {
        // 0x100003c80
        return result;
    }
    int64_t v7 = *(int64_t *)((int64_t)(8 * (v2 >> 2 * v6) & 24) + (int64_t)"6?"); // 0x100003c60
    v6--;
    result = _printf((char *)v7);
    while (v6 >= 0) {
        // 0x100003c3c
        v7 = *(int64_t *)((int64_t)(8 * (v2 >> 2 * v6) & 24) + (int64_t)"6?");
        v6--;
        result = _printf((char *)v7);
    }
    // 0x100003c80
    return result;
}

// Address range: 0x100003c8c - 0x100003f1c
int64_t entry_point(void) {
    // 0x100003c8c
    _printf("Addition:\n");
    function_1000038c4();
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n\n");
    _printf("Subtraction:\n");
    function_1000038c4();
    function_1000038c4();
    function_1000039f0();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_1000038c4();
    function_1000039f0();
    function_100003bb8();
    _printf("\n\n");
    _printf("Multiplication:\n");
    function_1000038c4();
    function_1000038c4();
    function_100003ae4();
    function_100003bb8();
    _printf("\n");
    function_1000038c4();
    function_1000038c4();
    function_100003968();
    function_100003bb8();
    _printf("\n");
    return 0;
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(char * format, ...) {
    // 0x100003f1c
    return _printf(format);
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(char * s) {
    // 0x100003f28
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>

#define MAXN 1000000
int maxl, maxr;

int is_prime(int n)
{
	int p;
	if (n % 3 == 0) return 0;

	for (p = 6; p * p <= n; p += 6)
		if (!(n % (p + 1) && n % (p + 5)))
			return 0;
	return 1;
}

void left(int n, int tens)
{
	int i, nn;

	if (n > maxl) maxl = n;
	if (n < MAXN / 10)
		for (tens *= 10, i = 1; i < 10; i++)
			if (is_prime(nn = i * tens + n))
				left(nn, tens);
}

void right(int n)
{
	int i, nn;
	static int d[] = {1,3,7,9};

	if (n > maxr) maxr = n;
	if (n < MAXN / 10)
		for (i = 1; i < 4; i++)
			if (is_prime(nn = n * 10 + d[i])) right(nn);
}

int main(void)
{
	left(3, 1); left(7, 1);
	right(3); right(5); right(7);

	printf("%d %d\n", maxl, maxr);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c30(void);
int64_t function_100003d14(void);
int64_t function_100003e08(void);
int32_t function_100003f8c(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008010
int32_t * g2; // 0x100008014

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003c30 - 0x100003d14
int64_t function_100003c30(void) {
    // 0x100003c30
    int64_t v1; // 0x100003c30
    int32_t v2 = v1; // 0x100003c34
    if (v2 % 3 == 0) {
        // 0x100003d08
        return 0;
    }
    int32_t v3 = 36 - v2; // 0x100003c80
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003d08
        return 1;
    }
    int32_t v4 = 6; // 0x100003c88
    int64_t result = 0; // 0x100003cb0
    while (v2 % (v4 | 1) != 0) {
        // 0x100003cb8
        result = 0;
        if (v2 % (v4 + 5) == 0) {
            // break -> 0x100003d08
            break;
        }
        // 0x100003c70
        v4 += 6;
        int32_t v5 = v4 * v4; // 0x100003c78
        int32_t v6 = v5 - v2; // 0x100003c80
        result = 1;
        if (v6 != 0 && v6 < 0 == ((v6 ^ v5) & (v5 ^ v2)) < 0) {
            // break -> 0x100003d08
            break;
        }
        result = 0;
    }
    // 0x100003d08
    return result;
}

// Address range: 0x100003d14 - 0x100003e08
int64_t function_100003d14(void) {
    // 0x100003d14
    int64_t v1; // 0x100003d14
    int32_t v2 = v1; // 0x100003d20
    int32_t v3 = *(int32_t *)&g1; // 0x100003d34
    int32_t v4 = v2 - v3; // 0x100003d38
    if (v4 != 0 && v4 < 0 == ((v4 ^ v2) & (v3 ^ v2)) < 0) {
        // 0x100003d48
        *(int32_t *)&g1 = v2;
    }
    // 0x100003d5c
    if (v2 < 0x186a0 == (0x1869f - v2 & v2) < 0) {
        // 0x100003dfc
        int64_t result; // 0x100003d14
        return result;
    }
    int32_t v5 = 1; // 0x100003d70
    int64_t v6 = function_100003c30(); // 0x100003dc0
    int64_t result2 = v6; // 0x100003dcc
    if ((int32_t)v6 != 0) {
        // 0x100003dd4
        result2 = function_100003d14();
    }
    // 0x100003de8
    v5++;
    while (v5 != 10) {
        // 0x100003da8
        v6 = function_100003c30();
        result2 = v6;
        if ((int32_t)v6 != 0) {
            // 0x100003dd4
            result2 = function_100003d14();
        }
        // 0x100003de8
        v5++;
    }
    // 0x100003dfc
    return result2;
}

// Address range: 0x100003e08 - 0x100003ef0
int64_t function_100003e08(void) {
    // 0x100003e08
    int64_t v1; // 0x100003e08
    int32_t v2 = v1; // 0x100003e14
    int32_t v3 = *(int32_t *)&g2; // 0x100003e24
    int32_t v4 = v2 - v3; // 0x100003e28
    if (v4 != 0 && v4 < 0 == ((v4 ^ v2) & (v3 ^ v2)) < 0) {
        // 0x100003e38
        *(int32_t *)&g2 = v2;
    }
    // 0x100003e4c
    if (v2 < 0x186a0 == (0x1869f - v2 & v2) < 0) {
        // 0x100003ee4
        int64_t result; // 0x100003e08
        return result;
    }
    int32_t v5 = 1; // 0x100003e60
    int64_t v6 = function_100003c30(); // 0x100003eac
    int64_t result2 = v6; // 0x100003eb8
    if ((int32_t)v6 != 0) {
        // 0x100003ec0
        result2 = function_100003e08();
    }
    // 0x100003ed0
    v5++;
    while (v5 != 4) {
        // 0x100003e88
        v6 = function_100003c30();
        result2 = v6;
        if ((int32_t)v6 != 0) {
            // 0x100003ec0
            result2 = function_100003e08();
        }
        // 0x100003ed0
        v5++;
    }
    // 0x100003ee4
    return result2;
}

// Address range: 0x100003ef0 - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003ef0
    function_100003d14();
    function_100003d14();
    function_100003e08();
    function_100003e08();
    function_100003e08();
    int64_t v1; // 0x100003ef0
    _printf("%d %d\n", 1, v1);
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: energetic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define constants for maximum size of XML tags and attributes
#define MAX_TAG_SIZE 50
#define MAX_ATTR_SIZE 50

// Define a struct to hold information about a single XML tag
typedef struct {
  char name[MAX_TAG_SIZE];
  char attributes[MAX_ATTR_SIZE][2][MAX_ATTR_SIZE];
  int num_attributes;
  char value[MAX_TAG_SIZE];
} xml_tag;

// Function to parse an XML tag and extract its information
xml_tag parse_tag(char* tag) {
  xml_tag parsed;
  parsed.num_attributes = 0;
  char* token = strtok(tag, " ");
  strcpy(parsed.name, token);
  token = strtok(NULL, "\"");
  while (token != NULL) {
    strcpy(parsed.attributes[parsed.num_attributes][0], token);
    token = strtok(NULL, "\"");
    strcpy(parsed.attributes[parsed.num_attributes][1], token);
    parsed.num_attributes++;
    token = strtok(NULL, "\"");
  }
  return parsed;
}

int main() {
  // Example XML document to parse
  char* document = "<note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>";

  // Parse the document and extract the tags and their information
  xml_tag tags[10];
  int num_tags = 0;
  char* token = strtok(document, "<>");
  while (token != NULL) {
    if (token[0] != '/') {
      tags[num_tags] = parse_tag(token);
      num_tags++;
    }
    token = strtok(NULL, "<>");
  }

  // Print out the extracted information for each tag
  for (int i = 0; i < num_tags; i++) {
    printf("Tag name: %s\n", tags[i].name);
    printf("Tag value: %s\n", tags[i].value);
    printf("Tag attributes:\n");
    for (int j = 0; j < tags[i].num_attributes; j++) {
      printf("%s: %s\n", tags[i].attributes[j][0], tags[i].attributes[j][1]);
    }
    printf("\n");
  }

  // Exit the program
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall parse_tag(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);


//----- (0000000140001751) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _QWORD *v3; // rbx
  _QWORD v5[12]; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v6[56112]; // [rsp+80h] [rbp+0h] BYREF
  char *String; // [rsp+DBB0h] [rbp+DB30h]
  int k; // [rsp+DBB8h] [rbp+DB38h]
  int j; // [rsp+DBBCh] [rbp+DB3Ch]
  char *i; // [rsp+DBC0h] [rbp+DB40h]
  int v11; // [rsp+DBCCh] [rbp+DB4Ch]

  _main(argc, argv, envp);
  String = "<note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>";
  v11 = 0;
  for ( i = strtok(
              "<note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>",
              "<>"); i; i = strtok(0i64, "<>") )
  {
    if ( *i != 47 )
    {
      v3 = &v6[5108 * v11 + 5024];
      parse_tag(v5, i);
      *v3 = v5[0];
      *(_QWORD *)((char *)v3 + 5100) = *(_QWORD *)&v6[5004];
      qmemcpy(
        (void *)((unsigned __int64)(v3 + 1) & 0xFFFFFFFFFFFFFFF8ui64),
        (const void *)((char *)v5 - ((char *)v3 - ((unsigned __int64)(v3 + 1) & 0xFFFFFFFFFFFFFFF8ui64))),
        8i64 * ((((_DWORD)v3 - (((_DWORD)v3 + 8) & 0xFFFFFFF8) + 5108) & 0xFFFFFFF8) >> 3));
      ++v11;
    }
  }
  for ( j = 0; j < v11; ++j )
  {
    printf("Tag name: %s\n", &v6[5108 * j + 5024]);
    printf("Tag value: %s\n", &v6[5108 * j + 10080]);
    printf("Tag attributes:\n");
    for ( k = 0; k < *(_DWORD *)&v6[5108 * j + 10076]; ++k )
      printf("%s: %s\n", &v6[5108 * j + 5074 + 100 * k], &v6[5108 * j + 5124 + 100 * k]);
    printf("\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall parse_tag(_QWORD, _QWORD);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001751: using guessed type _QWORD var_DBD0[12];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <string.h>

typedef struct node_t {
	struct node_t *left, *right;
	int freq;
	char c;
} *node;

struct node_t pool[256] = {{0}};
node qqq[255], *q = qqq - 1;
int n_nodes = 0, qend = 1;
char *code[128] = {0}, buf[1024];

node new_node(int freq, char c, node a, node b)
{
	node n = pool + n_nodes++;
	if (freq) n->c = c, n->freq = freq;
	else {
		n->left = a, n->right = b;
		n->freq = a->freq + b->freq;
	}
	return n;
}

/* priority queue */
void qinsert(node n)
{
	int j, i = qend++;
	while ((j = i / 2)) {
		if (q[j]->freq <= n->freq) break;
		q[i] = q[j], i = j;
	}
	q[i] = n;
}

node qremove()
{
	int i, l;
	node n = q[i = 1];

	if (qend < 2) return 0;
	qend--;
	while ((l = i * 2) < qend) {
		if (l + 1 < qend && q[l + 1]->freq < q[l]->freq) l++;
		q[i] = q[l], i = l;
	}
	q[i] = q[qend];
	return n;
}

/* walk the tree and put 0s and 1s */
void build_code(node n, char *s, int len)
{
	static char *out = buf;
	if (n->c) {
		s[len] = 0;
		strcpy(out, s);
		code[n->c] = out;
		out += len + 1;
		return;
	}

	s[len] = '0'; build_code(n->left,  s, len + 1);
	s[len] = '1'; build_code(n->right, s, len + 1);
}

void init(const char *s)
{
	int i, freq[128] = {0};
	char c[16];

	while (*s) freq[(int)*s++]++;

	for (i = 0; i < 128; i++)
		if (freq[i]) qinsert(new_node(freq[i], i, 0, 0));

	while (qend > 2)
		qinsert(new_node(0, 0, qremove(), qremove()));

	build_code(q[1], c, 0);
}

void encode(const char *s, char *out)
{
	while (*s) {
		strcpy(out, code[*s]);
		out += strlen(code[*s++]);
	}
}

void decode(const char *s, node t)
{
	node n = t;
	while (*s) {
		if (*s++ == '0') n = n->left;
		else n = n->right;

		if (n->c) putchar(n->c), n = t;
	}

	putchar('\n');
	if (t != n) printf("garbage input\n");
}

int main(void)
{
	int i;
	const char *str = "this is an example for huffman encoding";
        char buf[1024];

	init(str);
	for (i = 0; i < 128; i++)
		if (code[i]) printf("'%c': %s\n", i, code[i]);

	encode(str, buf);
	printf("encoded: %s\n", buf);

	printf("decoded: ");
	decode(buf, q[1]);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003728(void);
int64_t function_1000037dc(void);
int64_t function_100003890(void);
int64_t function_1000039cc(void);
int64_t function_100003ac0(void);
int64_t function_100003c38(void);
int64_t function_100003cc4(void);
int64_t function_100003ee8(int64_t a1);
int64_t function_100003ef4(int64_t a1, int64_t a2, int64_t a3);
void function_100003f00(int64_t * s, int32_t n);
int32_t function_100003f0c(char * format, ...);
int32_t function_100003f18(int32_t c);
int32_t function_100003f24(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x2000000000a018; // 0x100008000
int32_t g2 = 1; // 0x100008008
int64_t g3 = 0x9c20; // 0x100008010
int64_t g4 = 0x100000cfeedfacf; // 0x100008018
int32_t g5 = 0; // 0x100009818
int64_t g6 = 0; // 0x100009820

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
void _bzero(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003728 - 0x1000037dc
int64_t function_100003728(void) {
    // 0x100003728
    int64_t v1; // 0x100003728
    int32_t v2 = v1; // 0x10000372c
    int32_t v3 = g5; // 0x100003740
    g5 = v3 + 1;
    int64_t v4 = 24 * (int64_t)v3; // 0x100003754
    if (v2 == 0) {
        int32_t v5 = *(int32_t *)(v1 + 16); // 0x1000037b4
        int32_t v6 = *(int32_t *)(v1 + 16); // 0x1000037bc
        *(int32_t *)(v4 + (int64_t)&g4 + 16) = v6 + v5;
    } else {
        // 0x10000377c
        *(char *)(v4 + (int64_t)&g4 + 20) = (char)v1;
        *(int32_t *)(v4 + (int64_t)&g4 + 16) = v2;
    }
    // 0x1000037d0
    return v4 + (int64_t)&g4;
}

// Address range: 0x1000037dc - 0x100003890
int64_t function_1000037dc(void) {
    int32_t v1 = g2; // 0x1000037e8
    int32_t v2 = v1 + 1;
    g2 = v2;
    int64_t result; // 0x1000037dc
    if (v2 < 3) {
        // 0x100003874
        return result;
    }
    int32_t v3 = v1;
    int32_t v4 = v3 / 2;
    int64_t v5 = *(int64_t *)(8 * (int64_t)v4 + g1); // 0x100003828
    int32_t v6 = *(int32_t *)(v5 + 16); // 0x10000382c
    int32_t v7 = *(int32_t *)(result + 16); // 0x100003834
    while (v6 - v7 != 0 && v6 - v7 < 0 == ((v6 - v7 ^ v6) & (v7 ^ v6)) < 0) {
        // 0x10000384c
        *(int64_t *)(8 * (int64_t)v3 + g1) = v5;
        if (v4 < 2) {
            // break -> 0x100003874
            break;
        }
        v3 = v4;
        v4 = v3 / 2;
        v5 = *(int64_t *)(8 * (int64_t)v4 + g1);
        v6 = *(int32_t *)(v5 + 16);
        v7 = *(int32_t *)(result + 16);
    }
    // 0x100003874
    return result;
}

// Address range: 0x100003890 - 0x1000039cc
int64_t function_100003890(void) {
    int32_t v1 = g2; // 0x1000038b0
    if (v1 < 2 != (1 - v1 & v1) < 0) {
        // 0x1000039c0
        return 0;
    }
    int32_t v2 = v1 - 1; // 0x1000038d4
    g2 = v2;
    int32_t v3 = 3 - v1; // 0x1000038f4
    int64_t v4 = g1; // 0x1000038fc
    int32_t v5 = 1; // 0x1000038fc
    if (v3 < 0 != (v3 & v2) < 0) {
        int32_t v6 = 1;
        int32_t v7 = 2;
        int32_t v8 = v7 | 1; // 0x100003908
        int32_t v9 = v8 - v2; // 0x100003914
        int32_t v10 = v7; // 0x10000391c
        int64_t v11; // 0x100003934
        int32_t v12; // 0x100003938
        int32_t v13; // 0x100003948
        int32_t v14; // 0x10000394c
        if (v9 < 0 != ((v9 ^ v7) & (v2 ^ 2)) < 0) {
            // 0x100003924
            v11 = *(int64_t *)(g1 + (int64_t)(16 * v6 | 8));
            v12 = *(int32_t *)(v11 + 16);
            v13 = *(int32_t *)(*(int64_t *)(g1 + 8 * (int64_t)v7) + 16);
            v14 = v12 - v13;
            v10 = v14 < 0 == ((v14 ^ v12) & (v13 ^ v12)) < 0 ? v7 : v8;
        }
        int32_t v15 = v10;
        int64_t v16 = *(int64_t *)(8 * (int64_t)v15 + g1); // 0x100003978
        *(int64_t *)(8 * (int64_t)v6 + g1) = v16;
        int32_t v17 = 2 * v15; // 0x1000038e4
        int32_t v18 = v17 - v2; // 0x1000038f4
        int32_t v19 = v17 ^ v2; // 0x1000038f4
        v4 = g1;
        v5 = v15;
        while (v18 < 0 != ((v18 ^ v17) & v19) < 0) {
            // 0x100003904
            v6 = v15;
            v7 = v17;
            v8 = v7 | 1;
            v9 = v8 - v2;
            v10 = v7;
            if (v9 < 0 != ((v9 ^ v7) & v19) < 0) {
                // 0x100003924
                v11 = *(int64_t *)(g1 + (int64_t)(16 * v6 | 8));
                v12 = *(int32_t *)(v11 + 16);
                v13 = *(int32_t *)(*(int64_t *)(g1 + 8 * (int64_t)v7) + 16);
                v14 = v12 - v13;
                v10 = v14 < 0 == ((v14 ^ v12) & (v13 ^ v12)) < 0 ? v7 : v8;
            }
            // 0x10000396c
            v15 = v10;
            v16 = *(int64_t *)(8 * (int64_t)v15 + g1);
            *(int64_t *)(8 * (int64_t)v6 + g1) = v16;
            v17 = 2 * v15;
            v18 = v17 - v2;
            v19 = v17 ^ v2;
            v4 = g1;
            v5 = v15;
        }
    }
    int64_t v20 = *(int64_t *)(v4 + 8 * (int64_t)v2); // 0x1000039a4
    *(int64_t *)(8 * (int64_t)v5 + v4) = v20;
    // 0x1000039c0
    return *(int64_t *)(g1 + 8);
}

// Address range: 0x1000039cc - 0x100003ac0
int64_t function_1000039cc(void) {
    // 0x1000039cc
    int64_t v1; // 0x1000039cc
    char * v2 = (char *)(v1 + 20); // 0x1000039e8
    int64_t v3 = 0x100000000 * v1;
    char * v4 = (char *)((v3 >> 32) + v1);
    int64_t result; // 0x1000039cc
    if (*v2 == 0) {
        // 0x100003a58
        *v4 = 48;
        function_1000039cc();
        *v4 = 49;
        result = function_1000039cc();
    } else {
        // 0x1000039fc
        *v4 = 0;
        int64_t v5 = ___strcpy_chk(g3, v1, -1); // 0x100003a20
        char v6 = *v2; // 0x100003a30
        *(int64_t *)(8 * (int64_t)v6 + (int64_t)&g6) = g3;
        g3 += (v3 + 0x100000000 >> 32);
        result = v5;
    }
    // 0x100003ab4
    return result;
}

// Address range: 0x100003ac0 - 0x100003c38
int64_t function_100003ac0(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ad8
    int64_t v2; // bp-544, 0x100003ac0
    _bzero(&v2, 512);
    int64_t v3; // 0x100003ac0
    char v4 = *(char *)v3; // 0x100003af8
    int64_t v5 = &v2;
    if (v4 != 0) {
        int64_t v6; // 0x100003ac0
        int64_t v7 = v6 + 1; // 0x100003b10
        int32_t * v8 = (int32_t *)(4 * (int64_t)v4 + v5); // 0x100003b24
        *v8 = *v8 + 1;
        char v9 = *(char *)v7; // 0x100003af8
        v6 = v7;
        while (v9 != 0) {
            // 0x100003b0c
            v7 = v6 + 1;
            v8 = (int32_t *)(4 * (int64_t)v9 + v5);
            *v8 = *v8 + 1;
            v9 = *(char *)v7;
            v6 = v7;
        }
    }
    int32_t v10 = 0;
    if (*(int32_t *)(4 * (int64_t)v10 + v5) != 0) {
        // 0x100003b6c
        function_100003728();
        function_1000037dc();
    }
    int32_t v11 = v10 + 1; // 0x100003b9c
    while (v10 < 127 != (126 - v10 & v11) < 0) {
        // 0x100003b50
        v10 = v11;
        if (*(int32_t *)(4 * (int64_t)v10 + v5) != 0) {
            // 0x100003b6c
            function_100003728();
            function_1000037dc();
        }
        // 0x100003b98
        v11 = v10 + 1;
    }
    int32_t v12 = g2; // 0x100003bb0
    int32_t v13 = v12 - 2; // 0x100003bb4
    if (v13 != 0 && v13 < 0 == (1 - v12 & v12) < 0) {
        function_100003890();
        function_100003890();
        function_100003728();
        function_1000037dc();
        int32_t v14 = g2; // 0x100003bb0
        while (v14 != 2 && v14 < 2 == (1 - v14 & v14) < 0) {
            // 0x100003bc4
            function_100003890();
            function_100003890();
            function_100003728();
            function_1000037dc();
            v14 = g2;
        }
    }
    int64_t v15 = function_1000039cc(); // 0x100003c00
    int64_t result = v15; // 0x100003c1c
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003c24
        result = ___stack_chk_fail(v15);
    }
    // 0x100003c28
    return result;
}

// Address range: 0x100003c38 - 0x100003cc4
int64_t function_100003c38(void) {
    // 0x100003c38
    int64_t v1; // 0x100003c38
    char * v2 = (char *)v1;
    char v3 = *v2; // 0x100003c54
    if (v3 == 0) {
        // 0x100003cb8
        int64_t result; // 0x100003c38
        return result;
    }
    int64_t v4 = *(int64_t *)(8 * (int64_t)v3 + (int64_t)&g6); // 0x100003c80
    int64_t v5; // 0x100003c38
    ___strcpy_chk(v5, v4, -1);
    int64_t v6; // 0x100003c38
    int64_t v7 = v6 + 1; // 0x100003c94
    char v8 = *v2; // 0x100003c9c
    int64_t v9 = *(int64_t *)(8 * (int64_t)v8 + (int64_t)&g6); // 0x100003ca0
    int64_t result2 = _strlen((char *)v9); // 0x100003ca4
    char * v10 = (char *)v7;
    char v11 = *v10; // 0x100003c54
    v5 += result2;
    while (v11 != 0) {
        // 0x100003c68
        v4 = *(int64_t *)(8 * (int64_t)v11 + (int64_t)&g6);
        ___strcpy_chk(v5, v4, -1);
        v7++;
        v8 = *v10;
        v9 = *(int64_t *)(8 * (int64_t)v8 + (int64_t)&g6);
        result2 = _strlen((char *)v9);
        v10 = (char *)v7;
        v11 = *v10;
        v5 += result2;
    }
    // 0x100003cb8
    return result2;
}

// Address range: 0x100003cc4 - 0x100003dac
int64_t function_100003cc4(void) {
    // 0x100003cc4
    int64_t v1; // 0x100003cc4
    char v2 = *(char *)v1; // 0x100003ce8
    if (v2 == 0) {
        // 0x100003da0
        return _putchar(10);
    }
    int64_t v3; // 0x100003cc4
    int64_t v4 = v3;
    int64_t v5 = v2 == 48 ? v4 : v4 + 8;
    int64_t v6 = *(int64_t *)v5;
    char v7 = *(char *)(v6 + 20); // 0x100003d40
    if (v7 != 0) {
        // 0x100003d54
        _putchar((int32_t)v7);
    }
    // 0x100003d6c
    int64_t v8; // 0x100003cc4
    int64_t v9 = v8 + 1; // 0x100003d00
    int64_t v10 = v6;
    char v11 = *(char *)v9; // 0x100003ce8
    while (v11 != 0) {
        // 0x100003cfc
        v4 = v10;
        v5 = v11 == 48 ? v4 : v4 + 8;
        v6 = *(int64_t *)v5;
        v7 = *(char *)(v6 + 20);
        if (v7 != 0) {
            // 0x100003d54
            _putchar((int32_t)v7);
        }
        // 0x100003d6c
        v9++;
        v10 = v6;
        v11 = *(char *)v9;
    }
    int32_t result = _putchar(10); // 0x100003d88
    if (v1 != v10) {
        // 0x100003d90
        result = _printf("garbage input\n");
    }
    // 0x100003da0
    return result;
}

// Address range: 0x100003dac - 0x100003ee8
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dc4
    function_100003ac0();
    int32_t v2 = 0;
    int64_t v3 = *(int64_t *)(8 * (int64_t)v2 + (int64_t)&g6); // 0x100003e0c
    int64_t v4; // 0x100003dac
    if (v3 != 0) {
        // 0x100003e20
        _printf("'%c': %s\n", (char)v4, (char *)v4);
    }
    int32_t v5 = v2 + 1; // 0x100003e5c
    while (v2 < 127 != (126 - v2 & v5) < 0) {
        // 0x100003e00
        v2 = v5;
        v3 = *(int64_t *)(8 * (int64_t)v2 + (int64_t)&g6);
        if (v3 != 0) {
            // 0x100003e20
            _printf("'%c': %s\n", (char)v4, (char *)v4);
        }
        // 0x100003e58
        v5 = v2 + 1;
    }
    // 0x100003e68
    function_100003c38();
    int64_t v6; // bp-1056, 0x100003dac
    _printf("encoded: %s\n", &v6);
    _printf("decoded: ");
    int64_t v7 = function_100003cc4(); // 0x100003eac
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ed0
        ___stack_chk_fail(v7);
    }
    // 0x100003ed4
    return 0;
}

// Address range: 0x100003ee8 - 0x100003ef4
int64_t function_100003ee8(int64_t a1) {
    // 0x100003ee8
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003ef4
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003f00 - 0x100003f0c
void function_100003f00(int64_t * s, int32_t n) {
    // 0x100003f00
    _bzero(s, n);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(char * format, ...) {
    // 0x100003f0c
    return _printf(format);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(int32_t c) {
    // 0x100003f18
    return _putchar(c);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * s) {
    // 0x100003f24
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: recursive
#include <stdio.h>
#include <stdbool.h>

#define MAX_ROWS 10
#define MAX_COLS 10

// 2D Array representing the maze
int maze[MAX_ROWS][MAX_COLS] = {
    {1, 0, 1, 1, 0, 1, 0, 1, 1, 1},
    {1, 1, 1, 0, 1, 1, 1, 1, 0, 1},
    {0, 0, 0, 1, 1, 1, 1, 0, 1, 1},
    {1, 1, 1, 0, 1, 0, 1, 0, 0, 1},
    {1, 0, 1, 0, 1, 1, 1, 1, 0, 0},
    {1, 0, 0, 1, 1, 0, 0, 1, 0, 1},
    {1, 1, 0, 1, 0, 0, 1, 1, 1, 1},
    {0, 0, 1, 1, 1, 0, 1, 0, 0, 1},
    {1, 0, 1, 0, 1, 0, 0, 1, 1, 0},
    {0, 1, 0, 1, 0, 1, 1, 1, 0, 1},
};

// Function to check if a given row and column is a valid move
bool isValidMove(int row, int col) {
    return (row >= 0) && (row < MAX_ROWS) && 
           (col >= 0) && (col < MAX_COLS) && 
           (maze[row][col] == 1);
}

// Function to solve the maze using recursion
bool solveMaze(int row, int col) {
    // If we have reached the end of the maze, return true
    if (row == MAX_ROWS - 1 && col == MAX_COLS - 1) {
        return true;
    }

    // Check if the current row and col is a valid move
    if (isValidMove(row, col)) {
        // Mark the current cell as visited
        maze[row][col] = 2;

        // Check if we can move down
        if (solveMaze(row + 1, col)) {
            return true;
        }

        // Check if we can move right
        if (solveMaze(row, col + 1)) {
            return true;
        }

        // Check if we can move up
        if (solveMaze(row - 1, col)) {
            return true;
        }

        // Check if we can move left
        if (solveMaze(row, col - 1)) {
            return true;
        }

        // If we reach this point, that means we can't move in any direction
        // so we need to backtrack and mark the current cell as unvisited
        maze[row][col] = 1;
        return false;
    }

    // If we reach this point, that means the current cell is not a valid move
    // so we need to backtrack
    return false;
}

int main() {
    // Print the initial maze
    printf("The initial maze :\n");
    for(int i = 0; i < MAX_ROWS; i++) {
        for(int j = 0; j < MAX_COLS; j++) {
            printf("%d ", maze[i][j]);
        }
        printf("\n");
    }

    // Solve the maze
    if (solveMaze(0, 0)) {
        // Print the final maze with the path
        printf("\nThe path with the maze :\n");
        for(int i = 0; i < MAX_ROWS; i++) {
            for(int j = 0; j < MAX_COLS; j++) {
                if (maze[i][j] == 2) {
                    printf("* ");
                } else {
                    printf("%d ", maze[i][j]);   
                }
            }
            printf("\n");
        }
    } else {
        printf("There is no possible path.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall solveMaze(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

unsigned int maze[104] =
{
  1u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u
}; // weak


//----- (0000000140001715) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int m; // [rsp+20h] [rbp-10h]
  int k; // [rsp+24h] [rbp-Ch]
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("The initial maze :\n");
  for ( i = 0; i <= 9; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      printf("%d ", maze[10 * i + j]);
    printf("\n");
  }
  if ( (unsigned __int8)solveMaze(0i64, 0i64) )
  {
    printf("\nThe path with the maze :\n");
    for ( k = 0; k <= 9; ++k )
    {
      for ( m = 0; m <= 9; ++m )
      {
        if ( maze[10 * k + m] == 2 )
          printf("* ");
        else
          printf("%d ", maze[10 * k + m]);
      }
      printf("\n");
    }
  }
  else
  {
    printf("There is no possible path.\n");
  }
  return 0;
}
// 1400015F7: using guessed type __int64 __fastcall solveMaze(_QWORD, _QWORD);
// 140001960: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A020: using guessed type unsigned int maze[104];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text processing ; Style: Sherlock Holmes
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

struct word_frequency {
    char *word;
    int frequency;
};

void remove_punctuation(char *word) {
    int i, j = 0;
    for(i = 0; word[i] != '\0'; i++) {
        if(isalpha(word[i])) {
            word[j++] = tolower(word[i]);
        }
    }
    word[j] = '\0';
}

void print_frequencies(struct word_frequency *frequencies, int count) {
    int i;
    printf("Word Frequencies:\n");
    for(i = 0; i < count; i++) {
        printf("%s: %d\n", frequencies[i].word, frequencies[i].frequency);
    }
}

const char *SHERLOCK = "It is a capital mistake to theorize before one has data. Insensibly one begins to twist facts to suit theories, instead of theories to suit facts.";

int main() {
    char *text = strdup(SHERLOCK);
    char *word = strtok(text, " ");
    struct word_frequency *frequencies = NULL;
    int count = 0;
    while(word) {
        remove_punctuation(word);
        int i;
        for(i = 0; i < count; i++) {
            if(strcmp(frequencies[i].word, word) == 0) {
                frequencies[i].frequency++;
                break;
            }
        }
        if(i == count) {
            count++;
            frequencies = realloc(frequencies, count * sizeof(struct word_frequency));
            frequencies[count-1].word = strdup(word);
            frequencies[count-1].frequency = 1;
        }
        word = strtok(NULL, " ");
    }
    print_frequencies(frequencies, count);
    free(text);
    int i;
    for(i = 0; i < count; i++) {
        free(frequencies[i].word);
    }
    free(frequencies);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall remove_punctuation(_QWORD); // weak
__int64 __fastcall print_frequencies(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strdup(const char *String);
// char *__cdecl strtok(char *String, const char *Delimiter);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl realloc(void *Block, size_t Size);
// void __cdecl free(void *Block);

//-------------------------------------------------------------------------
// Data declarations

char *SHERLOCK = "It is a capital mistake to theorize before one has data. Insensibly one begins to twist facts to suit theories, instead of theories to suit facts."; // idb


//----- (00000001400016B1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *String; // [rsp+28h] [rbp-28h]
  int j; // [rsp+34h] [rbp-1Ch]
  int i; // [rsp+38h] [rbp-18h]
  signed int v7; // [rsp+3Ch] [rbp-14h]
  _DWORD *Block; // [rsp+40h] [rbp-10h]
  const char *Str2; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  String = strdup(SHERLOCK);
  Str2 = strtok(String, " ");
  Block = 0i64;
  v7 = 0;
  while ( Str2 )
  {
    remove_punctuation(Str2);
    for ( i = 0; i < v7; ++i )
    {
      if ( !strcmp(*(const char **)&Block[4 * i], Str2) )
      {
        ++Block[4 * i + 2];
        break;
      }
    }
    if ( i == v7 )
    {
      Block = realloc(Block, 16i64 * ++v7);
      *(_QWORD *)&Block[4 * v7 - 4] = strdup(Str2);
      Block[4 * v7 - 2] = 1;
    }
    Str2 = strtok(0i64, " ");
  }
  print_frequencies(Block, (unsigned int)v7);
  free(String);
  for ( j = 0; j < v7; ++j )
    free(*(void **)&Block[4 * j]);
  free(Block);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall remove_punctuation(_QWORD);
// 140001635: using guessed type __int64 __fastcall print_frequencies(_QWORD, _QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define BOARD_SIZE 4

void print_board(int game_board[][BOARD_SIZE], int revealed[][BOARD_SIZE]);
void update_stats(int game_board[][BOARD_SIZE], int revealed[][BOARD_SIZE], int x1, int y1, int x2, int y2, int *score, int *remaining_count);
int check_win(int remaining_count);

int main() {
    int game_board[BOARD_SIZE][BOARD_SIZE] = {0};
    int revealed[BOARD_SIZE][BOARD_SIZE] = {0};
    int score = 0;
    int remaining_count = BOARD_SIZE * BOARD_SIZE / 2;

    srand(time(NULL));

    // Initialize the board with random values from 1 to BOARD_SIZE^2/2
    for (int i = 1; i <= BOARD_SIZE * BOARD_SIZE / 2; i++) {
        int count = 0;
        while (count < 2) {
            int x = rand() % BOARD_SIZE;
            int y = rand() % BOARD_SIZE;

            if (game_board[x][y] == 0) {
                game_board[x][y] = i;
                count++;
            }
        }
    }

    // Game loop
    while (1) {
        print_board(game_board, revealed);

        printf("Enter the coordinates of the first card (x y): ");
        int x1, y1;
        scanf("%d %d", &x1, &y1);

        // Ensure that the coordinates are valid
        if (x1 < 0 || x1 >= BOARD_SIZE || y1 < 0 || y1 >= BOARD_SIZE || revealed[x1][y1]) {
            printf("Invalid coordinates.\n");
            continue;
        }

        revealed[x1][y1] = 1;
        print_board(game_board, revealed);

        printf("Enter the coordinates of the second card (x y): ");
        int x2, y2;
        scanf("%d %d", &x2, &y2);

        // Ensure that the coordinates are valid
        if (x2 < 0 || x2 >= BOARD_SIZE || y2 < 0 || y2 >= BOARD_SIZE || revealed[x2][y2]) {
            printf("Invalid coordinates.\n");
            revealed[x1][y1] = 0;
            continue;
        }

        revealed[x2][y2] = 1;

        // Update the score and remaining count
        update_stats(game_board, revealed, x1, y1, x2, y2, &score, &remaining_count);

        // Check if the game has been won
        if (check_win(remaining_count)) {
            printf("Congratulations, you won! Your final score is %d.\n", score);
            break;
        }
    }

    return 0;
}

void print_board(int game_board[][BOARD_SIZE], int revealed[][BOARD_SIZE]) {
    printf("    0 1 2 3\n");
    printf("   ---------\n");
    for (int i = 0; i < BOARD_SIZE; i++) {
        printf("%d | ", i);
        for (int j = 0; j < BOARD_SIZE; j++) {
            if (revealed[i][j]) {
                printf("%d ", game_board[i][j]);
            } else {
                printf("  ");
            }
        }
        printf("\n");
    }
    printf("\n");
}

void update_stats(int game_board[][BOARD_SIZE], int revealed[][BOARD_SIZE], int x1, int y1, int x2, int y2, int *score, int *remaining_count) {
    if (game_board[x1][y1] == game_board[x2][y2]) {
        printf("Match found! You earned 10 points.\n");
        *score += 10;
        *remaining_count -= 1;
    } else {
        printf("No match found. You lost 2 points.\n");
        *score -= 2;
        revealed[x1][y1] = 0;
        revealed[x2][y2] = 0;
    }
}

int check_win(int remaining_count) {
    return remaining_count == 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall print_board(_QWORD, _QWORD); // weak
__int64 __fastcall update_stats(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64); // weak
__int64 __fastcall check_win(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+48h] [rbp-A8h] BYREF
  unsigned int v6; // [rsp+4Ch] [rbp-A4h] BYREF
  unsigned int v7; // [rsp+50h] [rbp-A0h] BYREF
  unsigned int v8; // [rsp+54h] [rbp-9Ch] BYREF
  unsigned int v9; // [rsp+58h] [rbp-98h] BYREF
  unsigned int v10; // [rsp+5Ch] [rbp-94h] BYREF
  __int64 v11[8]; // [rsp+60h] [rbp-90h] BYREF
  __int64 v12[8]; // [rsp+A0h] [rbp-50h] BYREF
  int v13; // [rsp+E0h] [rbp-10h]
  int v14; // [rsp+E4h] [rbp-Ch]
  int v15; // [rsp+E8h] [rbp-8h]
  int i; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  memset(v12, 0, sizeof(v12));
  memset(v11, 0, sizeof(v11));
  v10 = 0;
  v9 = 8;
  v3 = time(0i64);
  srand(v3);
  for ( i = 1; i <= 8; ++i )
  {
    v15 = 0;
    while ( v15 <= 1 )
    {
      v14 = rand() % 4;
      v13 = rand() % 4;
      if ( !*((_DWORD *)&v12[2 * v14] + v13) )
      {
        *((_DWORD *)&v12[2 * v14] + v13) = i;
        ++v15;
      }
    }
  }
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        print_board(v12, v11);
        printf("Enter the coordinates of the first card (x y): ");
        scanf("%d %d", &v8, &v7);
        if ( v8 <= 3 && v7 <= 3 && !*((_DWORD *)&v11[2 * (int)v8] + (int)v7) )
          break;
        printf("Invalid coordinates.\n");
      }
      *((_DWORD *)&v11[2 * (int)v8] + (int)v7) = 1;
      print_board(v12, v11);
      printf("Enter the coordinates of the second card (x y): ");
      scanf("%d %d", &v6, &v5);
      if ( v6 <= 3 && v5 <= 3 && !*((_DWORD *)&v11[2 * (int)v6] + (int)v5) )
        break;
      printf("Invalid coordinates.\n");
      *((_DWORD *)&v11[2 * (int)v8] + (int)v7) = 0;
    }
    *((_DWORD *)&v11[2 * (int)v6] + (int)v5) = 1;
    update_stats((unsigned int)v12, (unsigned int)v11, v8, v7, v6, v5, (__int64)&v10, (__int64)&v9);
  }
  while ( !(unsigned int)check_win(v9) );
  printf("Congratulations, you won! Your final score is %d.\n", v10);
  return 0;
}
// 140001986: using guessed type __int64 __fastcall print_board(_QWORD, _QWORD);
// 140001A76: using guessed type __int64 __fastcall update_stats(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);
// 140001B5A: using guessed type __int64 __fastcall check_win(_QWORD);
// 140001C20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

int main() { /* permissions are before umask */
  int fd = open("output.txt", O_WRONLY|O_CREAT|O_TRUNC, 0640); /* rights 0640 for rw-r----- */
  /* or equivalently:
     int fd = creat("output.txt", 0640); */ /* rights 0640 for rw-r----- */
  close(fd);

  mkdir("docs", 0750); /* rights 0750 for rwxr-x--- */

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <windows.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f74(int32_t fd);
int32_t function_100003f80(char * path, int32_t mode);
int32_t function_100003f8c(char * file, int32_t oflag, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _close(int32_t a1);
int32_t _mkdir(char * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003f14 - 0x100003f74
int64_t entry_point(void) {
    // 0x100003f14
    _close(_open("output.txt", 1537));
    _mkdir("docs", 488);
    return 0;
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(int32_t fd) {
    // 0x100003f74
    return _close(fd);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * path, int32_t mode) {
    // 0x100003f80
    return _mkdir(path, mode);
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * file, int32_t oflag, ...) {
    // 0x100003f8c
    return _open(file, oflag);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdlib.h>
#include <stdio.h>

int main(void)
{
  const int dimx = 800, dimy = 800;
  int i, j;
  FILE *fp = fopen("first.ppm", "wb"); /* b - binary mode */
  (void) fprintf(fp, "P6\n%d %d\n255\n", dimx, dimy);
  for (j = 0; j < dimy; ++j)
  {
    for (i = 0; i < dimx; ++i)
    {
      static unsigned char color[3];
      color[0] = i % 256;  /* red */
      color[1] = j % 256;  /* green */
      color[2] = (i * j) % 256;  /* blue */
      (void) fwrite(color, 1, 3, fp);
    }
  }
  (void) fclose(fp);
  return EXIT_SUCCESS;
}
`,`#include "bitmap-write-a-ppm-file-1.h"



undefined8 entry(void)

{
  FILE *pFVar1;
  int local_24;
  int local_20;
  
  pFVar1 = _fopen("first.ppm","wb");
  _fprintf(pFVar1,"P6\n%d %d\n255\n");
  for (local_24 = 0; local_24 < 800; local_24 = local_24 + 1) {
    for (local_20 = 0; local_20 < 800; local_20 = local_20 + 1) {
      DAT_100008000 = (char)local_20;
      DAT_100008001 = (char)local_24;
      DAT_100008002 = DAT_100008000 * DAT_100008001;
      _fwrite(&DAT_100008000,1,3,pFVar1);
    }
  }
  _fclose(pFVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004008)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fwrite(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fwrite_100004018)();
  return sVar1;
}


`
`#include <stdio.h>
#include <math.h>
#include <string.h>

#define N 2200

int main(int argc, char **argv){
   int a,b,c,d;
   int r[N+1];
   memset(r,0,sizeof(r));	// zero solution array
   for(a=1; a<=N; a++){
      for(b=a; b<=N; b++){
	 int aabb;
	 if(a&1 && b&1) continue;  // for positive odd a and b, no solution.
	 aabb=a*a + b*b;
	 for(c=b; c<=N; c++){
	    int aabbcc=aabb + c*c;
	    d=(int)sqrt((float)aabbcc);
	    if(aabbcc == d*d && d<=N) r[d]=1;	// solution
	 }
      }
   }
   for(a=1; a<=N; a++)
      if(!r[a]) printf("%d ",a);	// print non solution
   printf("\n");
}
`,`#include "pythagorean-quadruples-1.h"



undefined4 entry(void)

{
  int iVar1;
  int iVar2;
  uint local_22ac;
  uint local_22a8;
  uint local_22a4;
  int aiStack_228c [2201];
  long local_28;
  
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _bzero(aiStack_228c,0x2264);
  for (local_22a4 = 1; (int)local_22a4 < 0x899; local_22a4 = local_22a4 + 1) {
    for (local_22a8 = local_22a4; (int)local_22a8 < 0x899; local_22a8 = local_22a8 + 1) {
      if (((local_22a4 & 1) == 0) || ((local_22a8 & 1) == 0)) {
        for (local_22ac = local_22a8; (int)local_22ac < 0x899; local_22ac = local_22ac + 1) {
          iVar1 = local_22a4 * local_22a4 + local_22a8 * local_22a8 + local_22ac * local_22ac;
          iVar2 = (int)SQRT((float)iVar1);
          if ((iVar1 == iVar2 * iVar2) && (iVar2 < 0x899)) {
            aiStack_228c[iVar2] = 1;
          }
        }
      }
    }
  }
  for (local_22a4 = 1; (int)local_22a4 < 0x899; local_22a4 = local_22a4 + 1) {
    if (aiStack_228c[(int)local_22a4] == 0) {
      _printf("%d ");
    }
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar1);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _bzero(void *param_1,size_t param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__bzero_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_FLOORS 10
#define MAX_PASSENGERS 5

int elevatorPosition = 0; // Current floor of the elevator
int passengerDestinations[MAX_PASSENGERS] = {0}; // Array of passenger destinations
int numPassengers = 0; // Number of passengers in the elevator

// Function to generate a random number between min and max (inclusive)
int getRandomNumber(int min, int max) {
    return (rand() % (max - min + 1)) + min; 
}

// Function to simulate the elevator movement
void moveElevator(int floor) {
    printf("The elevator is on floor %d\n", floor);
    elevatorPosition = floor;
}

// Function to add a passenger to the elevator
void addPassenger(int destination) {
    if (numPassengers < MAX_PASSENGERS) {
        printf("A passenger has entered the elevator and wants to go to floor %d\n", destination);
        passengerDestinations[numPassengers] = destination;
        numPassengers++;
    } else {
        printf("The elevator is at full capacity\n");
    }
}

// Function to remove a passenger from the elevator
void removePassenger(int index) {
    printf("A passenger has reached their destination and has left the elevator on floor %d\n", elevatorPosition);
    numPassengers--;
    for (int i = index; i < numPassengers; i++) {
        passengerDestinations[i] = passengerDestinations[i+1];
    }
}

int main() {
    srand(time(NULL)); // Seed the random number generato

    while (1) {
        // Generate a random floor to simulate a passenger call button press
        int pressedFloor = getRandomNumber(1, MAX_FLOORS);
        printf("Someone has pressed the elevator button on floor %d\n", pressedFloor);

        // Determine the direction the elevator needs to travel to reach the passenger
        int direction = pressedFloor - elevatorPosition;
        if (direction > 0) {
            printf("The elevator is moving up\n");
            for (int i = elevatorPosition + 1; i <= pressedFloor; i++) {
                moveElevator(i);
            }
        } else if (direction < 0) {
            printf("The elevator is moving down\n");
            for (int i = elevatorPosition - 1; i >= pressedFloor; i--) {
                moveElevator(i);
            }
        } else {
            printf("The elevator is already on the requested floor\n");
        }

        // Generate a random number of passengers to simulate entering the elevator
        int numNewPassengers = getRandomNumber(1, MAX_PASSENGERS - numPassengers);
        for (int i = 0; i < numNewPassengers; i++) {
            int destination = getRandomNumber(1, MAX_FLOORS);
            addPassenger(destination);
        }

        // Drop off passengers whose destination is the current floor
        for (int i = 0; i < numPassengers; i++) {
            if (passengerDestinations[i] == elevatorPosition) {
                removePassenger(i);
            }
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall getRandomNumber(_QWORD, _QWORD); // weak
__int64 __fastcall moveElevator(_QWORD); // weak
__int64 __fastcall addPassenger(_QWORD); // weak
__int64 __fastcall removePassenger(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

int elevatorPosition; // weak
_DWORD passengerDestinations[5]; // weak
int numPassengers; // weak


//----- (00000001400016F5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+20h] [rbp-20h]
  int v6; // [rsp+24h] [rbp-1Ch]
  int RandomNumber; // [rsp+2Ch] [rbp-14h]
  int m; // [rsp+30h] [rbp-10h]
  int k; // [rsp+34h] [rbp-Ch]
  int i; // [rsp+38h] [rbp-8h]
  int j; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  while ( 1 )
  {
    RandomNumber = getRandomNumber(1i64, 10i64);
    printf("Someone has pressed the elevator button on floor %d\n", (unsigned int)RandomNumber);
    if ( RandomNumber - elevatorPosition <= 0 )
    {
      if ( RandomNumber - elevatorPosition >= 0 )
      {
        printf("The elevator is already on the requested floor\n");
      }
      else
      {
        printf("The elevator is moving down\n");
        for ( i = elevatorPosition - 1; i >= RandomNumber; --i )
          moveElevator((unsigned int)i);
      }
    }
    else
    {
      printf("The elevator is moving up\n");
      for ( j = elevatorPosition + 1; j <= RandomNumber; ++j )
        moveElevator((unsigned int)j);
    }
    v6 = getRandomNumber(1i64, (unsigned int)(5 - numPassengers));
    for ( k = 0; k < v6; ++k )
    {
      v5 = getRandomNumber(1i64, 10i64);
      addPassenger(v5);
    }
    for ( m = 0; m < numPassengers; ++m )
    {
      if ( passengerDestinations[m] == elevatorPosition )
        removePassenger((unsigned int)m);
    }
  }
}
// 1400015B0: using guessed type __int64 __fastcall getRandomNumber(_QWORD, _QWORD);
// 1400015DA: using guessed type __int64 __fastcall moveElevator(_QWORD);
// 140001607: using guessed type __int64 __fastcall addPassenger(_QWORD);
// 140001673: using guessed type __int64 __fastcall removePassenger(_QWORD);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type int elevatorPosition;
// 14000F050: using guessed type _DWORD passengerDestinations[5];
// 14000F064: using guessed type int numPassengers;

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

/* Returns true' if element e' is in array a'. Otherwise, returns false'.
 * Checks only the first n' elements. Pure, O(n).
 */
bool elem(int *a, size_t n, int e)
{
    for (size_t i = 0; i < n; ++i)
        if (a[i] == e)
            return true;

    return false;
}

/* Removes the duplicates in array a' of given length n'. Returns the number
 * of unique elements. In-place, order preserving, O(n ^ 2).
 */
size_t nub(int *a, size_t n)
{
    size_t m = 0;

    for (size_t i = 0; i < n; ++i)
        if (!elem(a, m, a[i]))
            a[m++] = a[i];

    return m;
}

/* Out-place version of nub'. Pure, order preserving, alloc < n * sizeof(int)
 * bytes, O(n ^ 2).
 */
size_t nub_new(int **b, int *a, size_t n)
{
    int *c = malloc(n * sizeof(int));
    memcpy(c, a, n * sizeof(int));
    int m = nub(c, n);
    *b = malloc(m * sizeof(int));
    memcpy(*b, c, m * sizeof(int));
    free(c);
    return m;
}

int main(void)
{
    int a[] = {1, 2, 1, 4, 5, 2, 15, 1, 3, 4};
    int *b;

    size_t n = nub_new(&b, a, sizeof(a) / sizeof(a[0]));

    for (size_t i = 0; i < n; ++i)
        printf("%d ", b[i]);
    puts("");

    free(b);
    return 0;
}
`,`#include "remove-duplicate-elements-2.h"



undefined _elem(long param_1,ulong param_2,int param_3)

{
  ulong local_28;
  
  local_28 = 0;
  while( true ) {
    if (param_2 <= local_28) {
      return 0;
    }
    if (*(int *)(param_1 + local_28 * 4) == param_3) break;
    local_28 = local_28 + 1;
  }
  return 1;
}



long _nub(long param_1,ulong param_2)

{
  ulong uVar1;
  undefined8 local_30;
  undefined8 local_28;
  
  local_28 = 0;
  for (local_30 = 0; local_30 < param_2; local_30 = local_30 + 1) {
    uVar1 = _elem(param_1,local_28,*(undefined4 *)(param_1 + local_30 * 4));
    if ((uVar1 & 1) == 0) {
      *(undefined4 *)(param_1 + local_28 * 4) = *(undefined4 *)(param_1 + local_30 * 4);
      local_28 = local_28 + 1;
    }
  }
  return local_28;
}



long _nub_new(undefined8 *param_1,undefined8 param_2,long param_3)

{
  int iVar1;
  void *pvVar2;
  void *pvVar3;
  
  pvVar2 = _malloc(param_3 << 2);
  ___memcpy_chk(pvVar2,param_2,param_3 << 2);
  iVar1 = _nub(pvVar2,param_3);
  pvVar3 = _malloc((long)iVar1 << 2);
  *param_1 = pvVar3;
  ___memcpy_chk(*param_1,pvVar2,(long)iVar1 << 2,0xffffffffffffffff);
  _free(pvVar2);
  return (long)iVar1;
}



undefined8 entry(void)

{
  ulong uVar1;
  ulong local_60;
  void *local_50;
  undefined4 local_44;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_44 = 0;
  _memcpy(auStack_40,&DAT_100003f70,0x28);
  uVar1 = _nub_new(&local_50,auStack_40,10);
  for (local_60 = 0; local_60 < uVar1; local_60 = local_60 + 1) {
    _printf("%d ");
  }
  _puts("");
  _free(local_50);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004038)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    char name[50];
    printf("Welcome to the Automated Fortune Teller! Please enter your name: ");
    scanf("%s", name);
    
    time_t now = time(NULL);
    
    srand(now);

    int fortune = rand() % 5;

    switch(fortune) {
        case 0:
            printf("\n%s, a great opportunity awaits you in the near future. Keep your eyes open!\n", name);
            break;
        case 1:
            printf("\n%s, your hard work will pay off soon. Stay focused!\n", name);
            break;
        case 2:
            printf("\n%s, be careful of making impulsive decisions. Take time to think things through.\n", name);
            break;
        case 3:
            printf("\n%s, a new person will enter your life and bring positivity and happiness.\n", name);
            break;
        case 4:
            printf("\n%s, let go of your worries and enjoy the present moment. Everything will fall into place.\n", name);
            break;
        default:
            printf("\n%s, the future is uncertain. Focus on the present and make the most of every opportunity.\n", name);
            break;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[52]; // [rsp+20h] [rbp-40h] BYREF
  int v5; // [rsp+54h] [rbp-Ch]
  unsigned int Seed[2]; // [rsp+58h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to the Automated Fortune Teller! Please enter your name: ");
  scanf("%s", v4);
  *(_QWORD *)Seed = time(0i64);
  srand(Seed[0]);
  v5 = rand() % 5;
  switch ( v5 )
  {
    case 0:
      printf("\n%s, a great opportunity awaits you in the near future. Keep your eyes open!\n", v4);
      break;
    case 1:
      printf("\n%s, your hard work will pay off soon. Stay focused!\n", v4);
      break;
    case 2:
      printf("\n%s, be careful of making impulsive decisions. Take time to think things through.\n", v4);
      break;
    case 3:
      printf("\n%s, a new person will enter your life and bring positivity and happiness.\n", v4);
      break;
    case 4:
      printf("\n%s, let go of your worries and enjoy the present moment. Everything will fall into place.\n", v4);
      break;
    default:
      printf("\n%s, the future is uncertain. Focus on the present and make the most of every opportunity.\n", v4);
      break;
  }
  return 0;
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>

#define S 10
typedef struct { double v; int fixed; } node;

#define each(i, x) for(i = 0; i < x; i++)
node **alloc2(int w, int h)
{
	int i;
	node **a = calloc(1, sizeof(node*)*h + sizeof(node)*w*h);
	each(i, h) a[i] = i ? a[i-1] + w : (node*)(a + h);
	return a;
}

void set_boundary(node **m)
{
	m[1][1].fixed =  1; m[1][1].v =  1;
	m[6][7].fixed = -1; m[6][7].v = -1;
}

double calc_diff(node **m, node **d, int w, int h)
{
	int i, j, n;
	double v, total = 0;
	each(i, h) each(j, w) {
		v = 0; n = 0;
		if (i) v += m[i-1][j].v, n++;
		if (j) v += m[i][j-1].v, n++;
		if (i+1 < h) v += m[i+1][j].v, n++;
		if (j+1 < w) v += m[i][j+1].v, n++;

		d[i][j].v = v = m[i][j].v - v / n;
		if (!m[i][j].fixed) total += v * v;
	}
	return total;
}

double iter(node **m, int w, int h)
{
	node **d = alloc2(w, h);
	int i, j;
	double diff = 1e10;
	double cur[] = {0, 0, 0};

	while (diff > 1e-24) {
		set_boundary(m);
		diff = calc_diff(m, d, w, h);
		each(i,h) each(j, w) m[i][j].v -= d[i][j].v;
	}

	each(i, h) each(j, w)
		cur[ m[i][j].fixed + 1 ] += d[i][j].v *
				(!!i + !!j + (i < h-1) + (j < w -1));

	free(d);
	return (cur[2] - cur[0])/2;
}

int main()
{
	node **mesh = alloc2(S, S);
	printf("R = %g\n", 2 / iter(mesh, S, S));
	return 0;
}
`,`#include "resistor-mesh.h"



void * _alloc2(int param_1,int param_2)

{
  void *pvVar1;
  undefined8 local_30;
  undefined4 local_1c;
  
  pvVar1 = _calloc(1,(long)param_2 * 8 + (long)param_1 * 0x10 * (long)param_2);
  for (local_1c = 0; local_1c < param_2; local_1c = local_1c + 1) {
    if (local_1c == 0) {
      local_30 = (void *)((long)pvVar1 + (long)param_2 * 8);
    }
    else {
      local_30 = (void *)(*(long *)((long)pvVar1 + (long)(local_1c + -1) * 8) + (long)param_1 * 0x10
                         );
    }
    *(void **)((long)pvVar1 + (long)local_1c * 8) = local_30;
  }
  return pvVar1;
}



void _set_boundary(long param_1)

{
  *(undefined4 *)(*(long *)(param_1 + 8) + 0x18) = 1;
  *(undefined8 *)(*(long *)(param_1 + 8) + 0x10) = 0x3ff0000000000000;
  *(undefined4 *)(*(long *)(param_1 + 0x30) + 0x78) = 0xffffffff;
  *(undefined8 *)(*(long *)(param_1 + 0x30) + 0x70) = 0xbff0000000000000;
  return;
}



undefined  [16] _calc_diff(long param_1,long param_2,int param_3,int param_4)

{
  byte bVar1;
  double dVar2;
  undefined auVar3 [16];
  undefined8 local_38;
  undefined8 local_30;
  undefined4 local_20;
  undefined4 local_1c;
  
  local_38 = 0;
  for (local_1c = 0; local_1c < param_4; local_1c = local_1c + 1) {
    for (local_20 = 0; local_20 < param_3; local_20 = local_20 + 1) {
      local_30 = 0.0;
      bVar1 = local_1c != 0;
      if ((bool)bVar1) {
        local_30 = *(double *)
                    (*(long *)(param_1 + (long)(local_1c + -1) * 8) + (long)local_20 * 0x10) + 0.0;
      }
      if (local_20 != 0) {
        local_30 = local_30 +
                   *(double *)
                    (*(long *)(param_1 + (long)local_1c * 8) + (long)(local_20 + -1) * 0x10);
        bVar1 = bVar1 + 1;
      }
      if (local_1c + 1 < param_4) {
        local_30 = local_30 +
                   *(double *)
                    (*(long *)(param_1 + (long)(local_1c + 1) * 8) + (long)local_20 * 0x10);
        bVar1 = bVar1 + 1;
      }
      if (local_20 + 1 < param_3) {
        local_30 = local_30 +
                   *(double *)
                    (*(long *)(param_1 + (long)local_1c * 8) + (long)(local_20 + 1) * 0x10);
        bVar1 = bVar1 + 1;
      }
      dVar2 = *(double *)(*(long *)(param_1 + (long)local_1c * 8) + (long)local_20 * 0x10) -
              local_30 / (double)bVar1;
      *(double *)(*(long *)(param_2 + (long)local_1c * 8) + (long)local_20 * 0x10) = dVar2;
      if (*(int *)(*(long *)(param_1 + (long)local_1c * 8) + (long)local_20 * 0x10 + 8) == 0) {
        local_38 = NEON_fmadd(dVar2,dVar2,local_38);
      }
    }
  }
  auVar3._8_8_ = 0;
  auVar3._0_8_ = local_38;
  return auVar3;
}



undefined  [16] _iter(long param_1,int param_2,int param_3)

{
  double *pdVar1;
  void *pvVar2;
  double dVar3;
  undefined auVar4 [16];
  double local_58;
  int local_50;
  int local_4c;
  double local_30 [3];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar2 = (void *)_alloc2(param_2,param_3);
  local_58 = 10000000000.0;
  local_30[0] = 0.0;
  local_30[1] = 0.0;
  local_30[2] = 0.0;
  while (1e-24 < local_58) {
    _set_boundary(param_1);
    local_58 = (double)_calc_diff(param_1,pvVar2,param_2,param_3);
    for (local_4c = 0; local_4c < param_3; local_4c = local_4c + 1) {
      for (local_50 = 0; local_50 < param_2; local_50 = local_50 + 1) {
        pdVar1 = (double *)(*(long *)(param_1 + (long)local_4c * 8) + (long)local_50 * 0x10);
        *pdVar1 = *pdVar1 - *(double *)
                             (*(long *)((long)pvVar2 + (long)local_4c * 8) + (long)local_50 * 0x10);
      }
    }
  }
  for (local_4c = 0; local_4c < param_3; local_4c = local_4c + 1) {
    for (local_50 = 0; local_50 < param_2; local_50 = local_50 + 1) {
      dVar3 = (double)NEON_fmadd(*(undefined8 *)
                                  (*(long *)((long)pvVar2 + (long)local_4c * 8) +
                                  (long)local_50 * 0x10),
                                 (double)(byte)((local_4c != 0) + (local_50 != 0) +
                                                (local_4c < param_3 + -1) +
                                               (local_50 < param_2 + -1)),
                                 local_30[*(int *)(*(long *)(param_1 + (long)local_4c * 8) +
                                                   (long)local_50 * 0x10 + 8) + 1]);
      local_30[*(int *)(*(long *)(param_1 + (long)local_4c * 8) + (long)local_50 * 0x10 + 8) + 1] =
           dVar3;
    }
  }
  _free(pvVar2);
  auVar4._0_8_ = (local_30[2] - local_30[0]) / 2.0;
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    auVar4._8_8_ = 0;
    return auVar4;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined4 entry(void)

{
  undefined8 uVar1;
  
  uVar1 = _alloc2(10);
  _iter(uVar1,10);
  _printf("R = %g\n");
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`/*
  compilation and test in bash
  $ a=./c && make $a && $a ball bell ball ball YUP YEP     ball BELL ball BALL YUP yep
  cc -Wall -c -o c.o c.c
  	eq , ne , gt , lt , ge , le
  ball 0 1 0 1 0 1 bell
  ball 0 1 0 1 0 1 bell ignoring case
  ball 1 0 0 0 1 1 ball
  ball 1 0 0 0 1 1 ball ignoring case
  YUP 0 1 1 0 1 0 YEP
  YUP 0 1 1 0 1 0 YEP ignoring case
  ball 0 1 1 0 1 0 BELL
  ball 0 1 0 1 0 1 BELL ignoring case
  ball 0 1 1 0 1 0 BALL
  ball 1 0 0 0 1 1 BALL ignoring case
  YUP 0 1 0 1 0 1 yep
  YUP 0 1 1 0 1 0 yep ignoring case
*/

#include<string.h>

#define STREQ(A,B) (0==strcmp((A),(B)))
#define STRNE(A,B) (!STREQ(A,B))
#define STRLT(A,B) (strcmp((A),(B))<0)
#define STRLE(A,B) (strcmp((A),(B))<=0)
#define STRGT(A,B) STRLT(B,A)
#define STRGE(A,B) STRLE(B,A)

#define STRCEQ(A,B) (0==strcasecmp((A),(B)))
#define STRCNE(A,B) (!STRCEQ(A,B))
#define STRCLT(A,B) (strcasecmp((A),(B))<0)
#define STRCLE(A,B) (strcasecmp((A),(B))<=0)
#define STRCGT(A,B) STRCLT(B,A)
#define STRCGE(A,B) STRCLE(B,A)

#include<stdio.h>

void compare(const char*a, const char*b) {
  printf("%s%2d%2d%2d%2d%2d%2d %s\n",
	 a,
	 STREQ(a,b), STRNE(a,b), STRGT(a,b), STRLT(a,b), STRGE(a,b), STRLE(a,b),
	 b
	 );
}
void comparecase(const char*a, const char*b) {
  printf("%s%2d%2d%2d%2d%2d%2d %s ignoring case\n",
	 a,
	 STRCEQ(a,b), STRCNE(a,b), STRCGT(a,b), STRCLT(a,b), STRCGE(a,b), STRCLE(a,b),
	 b
	 );
}
int main(int ac, char*av[]) {
  char*a,*b;
  puts("\teq , ne , gt , lt , ge , le");
  while (0 < (ac -= 2)) {
    a = *++av, b = *++av;
    compare(a, b);
    comparecase(a, b);
  }
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c04(void);
int64_t function_100003d40(void);
int32_t function_100003f18(char * format, ...);
int32_t function_100003f24(char * s);
int32_t function_100003f30(char * s1, char * s2);
int32_t function_100003f3c(char * s1, char * s2);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);
int32_t _strcasecmp(char * a1, char * a2);
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003c04 - 0x100003d40
int64_t function_100003c04(void) {
    // 0x100003c04
    int64_t v1; // 0x100003c04
    char * v2 = (char *)v1; // 0x100003c28
    char * v3 = (char *)v1; // 0x100003c28
    _strcmp(v2, v3);
    _strcmp(v2, v3);
    _strcmp(v3, v2);
    _strcmp(v2, v3);
    _strcmp(v3, v2);
    _strcmp(v2, v3);
    return _printf("%s%2d%2d%2d%2d%2d%2d %s\n", v3, v1, v1, v1, v1, v1, v1, v2);
}

// Address range: 0x100003d40 - 0x100003e7c
int64_t function_100003d40(void) {
    // 0x100003d40
    int64_t v1; // 0x100003d40
    char * v2 = (char *)v1; // 0x100003d64
    char * v3 = (char *)v1; // 0x100003d64
    _strcasecmp(v2, v3);
    _strcasecmp(v2, v3);
    _strcasecmp(v3, v2);
    _strcasecmp(v2, v3);
    _strcasecmp(v3, v2);
    _strcasecmp(v2, v3);
    return _printf("%s%2d%2d%2d%2d%2d%2d %s ignoring case\n", v3, v1, v1, v1, v1, v1, v1, v2);
}

// Address range: 0x100003e7c - 0x100003f18
int64_t entry_point(void) {
    // 0x100003e7c
    int64_t v1; // 0x100003e7c
    int32_t v2 = v1; // 0x100003e8c
    _puts("\teq , ne , gt , lt , ge , le");
    int32_t v3 = v2 - 2; // 0x100003ea8
    int32_t v4 = 2 - v2; // 0x100003eb4
    if (v4 < 0 == (v3 & v4) < 0) {
        // 0x100003f08
        return 0;
    }
    int32_t v5 = v3;
    function_100003c04();
    function_100003d40();
    int32_t v6 = v5 - 2; // 0x100003ea8
    while (-v5 < -2 != (v6 & 2 - v5) < 0) {
        // 0x100003ec4
        v5 = v6;
        function_100003c04();
        function_100003d40();
        v6 = v5 - 2;
    }
    // 0x100003f08
    return 0;
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(char * format, ...) {
    // 0x100003f18
    return _printf(format);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * s) {
    // 0x100003f24
    return _puts(s);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * s1, char * s2) {
    // 0x100003f30
    return _strcasecmp(s1, s2);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * s1, char * s2) {
    // 0x100003f3c
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: Linus Torvalds
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<time.h>

#define MAX_FLOORS 10
#define MAX_PASSENGERS 15

// Define the structure for elevator
typedef struct {
    int current_floor;
    int passengers;
    int direction; // 1 for up, -1 for down, 0 for idle
    int dest_floor[MAX_FLOORS];
    int dest_count;
} Elevator;

// Define the structure for passenger
typedef struct {
    int current_floor;
    int dest_floor;
    int id;
} Passenger;

// Define the function to move the elevator
void move_elevator(Elevator *elevator, int floor) {
    elevator -> current_floor = floor;
    printf("Elevator reached floor %d\n", floor);
    int i, temp_dest_floor[MAX_FLOORS], count=0;
    for(i=0; i<elevator->dest_count; i++) {
        if(floor == elevator->dest_floor[i]) {
            printf("Passenger %d exited on floor %d\n", elevator->passengers, floor);
            elevator->passengers--;
        } else {
            temp_dest_floor[count++] = elevator->dest_floor[i];
        }
    }
    if(count<elevator->dest_count) {
        elevator->dest_count = count;
        for(i=0; i<count; i++) {
            elevator->dest_floor[i] = temp_dest_floor[i];
        }
    }
    if(elevator->direction == 1) { // Going up
        if(floor == MAX_FLOORS) {
            elevator->direction = -1; // Change direction when elevator reaches last floor
        } else if(count > 0 && elevator->dest_floor[0]>floor) { // Any passengers going up?
            return;
        } else { // Otherwise, go to next upper floor
            move_elevator(elevator, floor+1);
        }
    } else if(elevator->direction == -1) { // Going down
        if(floor == 1) {
            elevator->direction = 1; // Change direction when elevator reaches first floor
        } else if(count > 0 && elevator->dest_floor[0]<floor) { // Any passengers going down?
            return;
        } else { // Otherwise, go to next lower floor
            move_elevator(elevator, floor-1);
        }
    } else { // Elevator is idle
        if(count > 0) {
            elevator->direction = (elevator->dest_floor[0]>floor ? 1 : -1); // Set direction based on first passenger's destination
            move_elevator(elevator, floor+(elevator->direction)); // Start moving towards first passenger's destination
        }
    }  
}

// Define the main function
int main() {
    srand(time(0));
    Elevator elevator = {1, 0, 0, {0}, 0};
    Passenger passengers[MAX_PASSENGERS];
    int i;
    for(i=0; i<MAX_PASSENGERS; i++) { // Randomly generate passengers with destinations
        passengers[i].id = i+1;
        passengers[i].current_floor = rand()%MAX_FLOORS + 1;
        passengers[i].dest_floor = rand()%MAX_FLOORS + 1;
        printf("Passenger %d is on floor %d and wants to go to floor %d\n", passengers[i].id, passengers[i].current_floor, passengers[i].dest_floor);
    }
    printf("Elevator starts at floor %d\n", elevator.current_floor);
    while(1) { // Keep running the simulation until stopped
        if(elevator.dest_count == 0) { // If no passengers inside, check for any waiting at current floor
            for(i=0; i<MAX_PASSENGERS; i++) {
                if(passengers[i].current_floor == elevator.current_floor) {
                    elevator.dest_floor[elevator.dest_count++] = passengers[i].dest_floor;
                    elevator.passengers++;
                    printf("Passenger %d entered elevator on floor %d\n", passengers[i].id, elevator.current_floor);
                }
            }            
        } else {
            move_elevator(&elevator, elevator.current_floor); // Move the elevator to next floor
        }
        usleep(500000); // Wait for 500ms before moving again
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall move_elevator(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall usleep(_QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001779) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // edx
  _BYTE v6[96]; // [rsp+80h] [rbp+0h] BYREF
  __int64 v7[6]; // [rsp+E0h] [rbp+60h] BYREF
  __int64 v8; // [rsp+110h] [rbp+90h]
  int i; // [rsp+11Ch] [rbp+9Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v7[0] = 1i64;
  memset(&v7[1], 0, 40);
  v8 = 0i64;
  for ( i = 0; i <= 14; ++i )
  {
    *(_DWORD *)&v6[12 * i - 88] = i + 1;
    *(_DWORD *)&v6[12 * i - 96] = rand() % 10 + 1;
    *(_DWORD *)&v6[12 * i - 92] = rand() % 10 + 1;
    printf(
      "Passenger %d is on floor %d and wants to go to floor %d\n",
      *(unsigned int *)&v6[12 * i - 88],
      *(unsigned int *)&v6[12 * i - 96],
      *(unsigned int *)&v6[12 * i - 92]);
  }
  printf("Elevator starts at floor %d\n", LODWORD(v7[0]));
  while ( 1 )
  {
    if ( HIDWORD(v8) )
    {
      move_elevator(v7, LODWORD(v7[0]));
    }
    else
    {
      for ( i = 0; i <= 14; ++i )
      {
        if ( *(_DWORD *)&v6[12 * i - 96] == LODWORD(v7[0]) )
        {
          v4 = HIDWORD(v8)++;
          *((_DWORD *)&v7[1] + v4 + 1) = *(_DWORD *)&v6[12 * i - 92];
          ++HIDWORD(v7[0]);
          printf("Passenger %d entered elevator on floor %d\n", *(unsigned int *)&v6[12 * i - 88], LODWORD(v7[0]));
        }
      }
    }
    usleep(500000i64);
  }
}
// 1400015B0: using guessed type __int64 __fastcall move_elevator(_QWORD, _QWORD);
// 140001B60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002BC0: using guessed type __int64 __fastcall usleep(_QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const char * lang_url = "http://www.rosettacode.org/w/api.php?action=query&"
		"list=categorymembers&cmtitle=Category:Programming_Languages&"
		"cmlimit=500&format=json";
const char * cat_url = "http://www.rosettacode.org/w/index.php?title=Special:Categories&limit=5000";

#define BLOCK 1024
char *get_page(const char *url)
{
	char cmd[1024];
	char *ptr, *buf;
	int bytes_read = 1, len = 0;
	sprintf(cmd, "wget -q \"%s\" -O -", url);
	FILE *fp = popen(cmd, "r");
	if (!fp) return 0;
	for (ptr = buf = 0; bytes_read > 0; ) {
		buf = realloc(buf, 1 + (len += BLOCK));
		if (!ptr) ptr = buf;
		bytes_read = fread(ptr, 1, BLOCK, fp);
		if (bytes_read <= 0) break;
		ptr += bytes_read;
	}
	*++ptr = '\0';
	return buf;
}

char ** get_langs(char *buf, int *l)
{
	char **arr = 0;
	for (*l = 0; (buf = strstr(buf, "Category:")) && (buf += 9); ++*l)
		for (	(*l)[arr = realloc(arr, sizeof(char*)*(1 + *l))] = buf;
			*buf != '"' || (*buf++ = 0);
			buf++);

	return arr;
}

typedef struct { const char *name; int count; } cnt_t;
cnt_t * get_cats(char *buf, char ** langs, int len, int *ret_len)
{
	char str[1024], *found;
	cnt_t *list = 0;
	int i, llen = 0;
	for (i = 0; i < len; i++) {
		sprintf(str, "/wiki/Category:%s", langs[i]);
		if (!(found = strstr(buf, str))) continue;
		buf = found + strlen(str);

		if (!(found = strstr(buf, "</a> ("))) continue;
		list = realloc(list, sizeof(cnt_t) * ++llen);
		list[llen - 1].name = langs[i];
		list[llen - 1].count = strtol(found + 6, 0, 10);
	}
	*ret_len = llen;
	return list;
}

int _scmp(const void *a, const void *b)
{
	int x = ((const cnt_t*)a)->count, y = ((const cnt_t*)b)->count;
	return x < y ? -1 : x > y;
}

int main()
{
	int len, clen;
	char ** langs = get_langs(get_page(lang_url), &len);
	cnt_t *cats = get_cats(get_page(cat_url), langs, len, &clen);
	qsort(cats, clen, sizeof(cnt_t), _scmp);
	while (--clen >= 0)
		printf("%4d %s\n", cats[clen].count, cats[clen].name);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003810(void);
int64_t function_1000039a0(void);
int64_t function_100003af4(void);
int64_t function_100003cc8(void);
int64_t function_100003e08(int64_t * a1, int64_t a2, int64_t a3, char * a4);
int64_t function_100003e14(void);
int32_t function_100003e20(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
struct _IO_FILE * function_100003e2c(char * command, char * modes);
int32_t function_100003e38(char * format, ...);
void function_100003e44(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
int64_t * function_100003e50(int64_t * ptr, int32_t size);
int32_t function_100003e5c(char * s);
char * function_100003e68(char * haystack, char * needle);
int32_t function_100003e74(char * nptr, char ** endptr, int32_t base);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(int64_t * a1, int64_t a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(void);
int32_t _fread(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
struct _IO_FILE * _popen(char * a1, char * a2);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);
char * _strstr(char * a1, char * a2);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003810 - 0x1000039a0
int64_t function_100003810(void) {
    // 0x100003810
    int64_t v1; // bp-1056, 0x100003810
    ___sprintf_chk(&v1, 0, 1024, "wget -q \"%s\" -O -");
    struct _IO_FILE * v2 = _popen((char *)&v1, "r"); // 0x100003874
    int64_t result = 0; // 0x100003888
    if (v2 != NULL) {
        int64_t * v3 = _realloc(NULL, 1025); // 0x1000038d4
        int64_t v4 = (int64_t)v3; // 0x1000038d4
        int32_t v5 = _fread(v3, 1, 1024, v2); // 0x10000390c
        int32_t v6 = 0; // 0x100003924
        result = v4;
        int64_t v7 = v4; // 0x100003924
        if (v5 >= 1) {
            int64_t v8 = v4 + (int64_t)v5; // 0x100003938
            int64_t v9 = (int64_t)_realloc((int64_t *)v4, v6 + 2049);
            int64_t v10 = v8 == 0 ? v9 : v8;
            int32_t v11 = _fread((int64_t *)v10, 1, 1024, v2); // 0x10000390c
            int64_t v12 = v9; // 0x100003924
            v6 += 1024;
            result = v9;
            v7 = v10;
            while (v11 >= 1) {
                // 0x100003930
                v8 = v10 + (int64_t)v11;
                v9 = (int64_t)_realloc((int64_t *)v12, v6 + 2049);
                v10 = v8 == 0 ? v9 : v8;
                v11 = _fread((int64_t *)v10, 1, 1024, v2);
                v12 = v9;
                v6 += 1024;
                result = v9;
                v7 = v10;
            }
        }
        // 0x100003944
        *(char *)(v7 + 1) = 0;
    }
    int64_t v13 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003974
    if (v13 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003988
        ___stack_chk_fail();
    }
    // 0x10000398c
    return result;
}

// Address range: 0x1000039a0 - 0x100003af4
int64_t function_1000039a0(void) {
    // 0x1000039a0
    int64_t v1; // 0x1000039a0
    int32_t * v2 = (int32_t *)v1; // 0x1000039b0
    *v2 = 0;
    char * v3 = _strstr((char *)v1, "Category:"); // 0x1000039d0
    if (v3 == NULL) {
        // 0x100003ae4
        return 0;
    }
    int64_t result = 0;
    int64_t v4 = (int64_t)v3 + 9; // 0x1000039f8
    while (v4 != 0) {
        // 0x100003a20
        int64_t v5; // 0x1000039a0
        int32_t v6 = *(int32_t *)&v5;
        result = (int64_t)_realloc((int64_t *)result, 8 * v6 + 8);
        *(int64_t *)(8 * (int64_t)v6 + result) = v4;
        char * v7 = (char *)v4;
        int64_t v8 = v4 + 1;
        int64_t v9 = v8; // 0x100003a88
        while (*v7 != 34) {
            // 0x100003a70
            v7 = (char *)v9;
            v8 = v9 + 1;
            v9 = v8;
        }
        // 0x100003ad0
        *v7 = 0;
        *v2 = *(int32_t *)&v5 + 1;
        char * v10 = _strstr((char *)v8, "Category:"); // 0x1000039d0
        if (v10 == NULL) {
            // break -> 0x100003ae4
            break;
        }
        v4 = (int64_t)v10 + 9;
    }
    // 0x100003ae4
    return result;
}

// Address range: 0x100003af4 - 0x100003cc8
int64_t function_100003af4(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003b0c
    int64_t v2; // 0x100003af4
    int32_t v3 = v2; // 0x100003b1c
    int32_t v4 = -v3; // 0x100003b3c
    int64_t result = 0; // 0x100003b44
    int32_t v5 = 0; // 0x100003b44
    if (v4 < 0 != (v4 & v3) < 0) {
        char * v6 = (char *)v2;
        int64_t v7 = 0;
        int32_t v8 = 0;
        int32_t v9 = 0;
        int64_t v10; // bp-1056, 0x100003af4
        ___sprintf_chk(&v10, 0, 1024, "/wiki/Category:%s");
        char * v11 = _strstr(v6, (char *)&v10); // 0x100003b84
        int64_t v12 = v7; // 0x100003b98
        int32_t v13 = v8; // 0x100003b98
        char * v14 = v6; // 0x100003b98
        int32_t v15; // 0x100003bb0
        char * v16; // 0x100003bbc
        char * v17; // 0x100003bcc
        int32_t v18; // 0x100003bf4
        int64_t v19; // 0x100003c0c
        int64_t v20; // 0x100003c38
        if (v11 != NULL) {
            // 0x100003ba4
            v15 = _strlen((char *)&v10);
            v16 = (char *)((int64_t)v15 + (int64_t)v11);
            v17 = _strstr(v16, "</a> (");
            v12 = v7;
            v13 = v8;
            v14 = v16;
            if (v17 != NULL) {
                // 0x100003bec
                v18 = v8 + 1;
                v19 = (int64_t)_realloc((int64_t *)v7, 16 * v18);
                v20 = 16 * (int64_t)v8 + v19;
                *(int64_t *)v20 = *(int64_t *)(8 * (int64_t)v9 + v2);
                *(int32_t *)(v20 + 8) = _strtol((char *)((int64_t)v17 + 6), NULL, 10);
                v12 = v19;
                v13 = v18;
                v14 = v16;
            }
        }
        // 0x100003c6c
        v6 = v14;
        int32_t v21 = v13;
        int64_t v22 = v12;
        int32_t v23 = v9 + 1; // 0x100003c70
        int32_t v24 = v23 - v3; // 0x100003b3c
        result = v22;
        v5 = v21;
        while (v24 < 0 != ((v24 ^ v23) & (v23 ^ v3)) < 0) {
            // 0x100003b4c
            v7 = v22;
            v8 = v21;
            v9 = v23;
            ___sprintf_chk(&v10, 0, 1024, "/wiki/Category:%s");
            v11 = _strstr(v6, (char *)&v10);
            v12 = v7;
            v13 = v8;
            v14 = v6;
            if (v11 != NULL) {
                // 0x100003ba4
                v15 = _strlen((char *)&v10);
                v16 = (char *)((int64_t)v15 + (int64_t)v11);
                v17 = _strstr(v16, "</a> (");
                v12 = v7;
                v13 = v8;
                v14 = v16;
                if (v17 != NULL) {
                    // 0x100003bec
                    v18 = v8 + 1;
                    v19 = (int64_t)_realloc((int64_t *)v7, 16 * v18);
                    v20 = 16 * (int64_t)v8 + v19;
                    *(int64_t *)v20 = *(int64_t *)(8 * (int64_t)v9 + v2);
                    *(int32_t *)(v20 + 8) = _strtol((char *)((int64_t)v17 + 6), NULL, 10);
                    v12 = v19;
                    v13 = v18;
                    v14 = v16;
                }
            }
            // 0x100003c6c
            v6 = v14;
            v21 = v13;
            v22 = v12;
            v23 = v9 + 1;
            v24 = v23 - v3;
            result = v22;
            v5 = v21;
        }
    }
    // 0x100003c7c
    *(int32_t *)v2 = v5;
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003cb0
        ___stack_chk_fail();
    }
    // 0x100003cb4
    return result;
}

// Address range: 0x100003cc8 - 0x100003d38
int64_t function_100003cc8(void) {
    // 0x100003cc8
    int64_t v1; // 0x100003cc8
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x100003cd8
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x100003ce4
    int32_t v4 = v2 - v3; // 0x100003cf4
    return v4 < 0 == ((v4 ^ v2) & (v3 ^ v2)) < 0 ? (int64_t)(v4 != 0) : 0xffffffff;
}

// Address range: 0x100003d38 - 0x100003e08
int64_t entry_point(void) {
    // 0x100003d38
    function_100003810();
    function_1000039a0();
    function_100003810();
    int32_t v1; // 0x100003d38
    _qsort((int64_t *)function_100003af4(), v1, 16, (int32_t (*)(int64_t *, int64_t *))0x100003cc8);
    int32_t v2 = v1 - 1; // 0x100003da0
    if (v2 < 0) {
        // 0x100003df8
        return 0;
    }
    for (int32_t i = v2; i >= 0; i--) {
        // 0x100003db8
        _printf("%4d %s\n", (int64_t)v1, (char *)16);
    }
    // 0x100003df8
    return 0;
}

// Address range: 0x100003e08 - 0x100003e14
int64_t function_100003e08(int64_t * a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003e08
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003e14 - 0x100003e20
int64_t function_100003e14(void) {
    // 0x100003e14
    return ___stack_chk_fail();
}

// Address range: 0x100003e20 - 0x100003e2c
int32_t function_100003e20(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x100003e20
    return _fread(ptr, size, n, stream);
}

// Address range: 0x100003e2c - 0x100003e38
struct _IO_FILE * function_100003e2c(char * command, char * modes) {
    // 0x100003e2c
    return _popen(command, modes);
}

// Address range: 0x100003e38 - 0x100003e44
int32_t function_100003e38(char * format, ...) {
    // 0x100003e38
    return _printf(format);
}

// Address range: 0x100003e44 - 0x100003e50
void function_100003e44(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003e44
    _qsort(base, nmemb, size, compar);
}

// Address range: 0x100003e50 - 0x100003e5c
int64_t * function_100003e50(int64_t * ptr, int32_t size) {
    // 0x100003e50
    return _realloc(ptr, size);
}

// Address range: 0x100003e5c - 0x100003e68
int32_t function_100003e5c(char * s) {
    // 0x100003e5c
    return _strlen(s);
}

// Address range: 0x100003e68 - 0x100003e74
char * function_100003e68(char * haystack, char * needle) {
    // 0x100003e68
    return _strstr(haystack, needle);
}

// Address range: 0x100003e74 - 0x100003e80
int32_t function_100003e74(char * nptr, char ** endptr, int32_t base) {
    // 0x100003e74
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`//FormAI DATASET v1.0 Category: Procedural Space Adventure ; Style: shocked
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

// Function prototypes
void title_screen();
void prologue();
void random_planet();
void space_battle();

int main()
{
    // Seed the random number generator
    srand(time(NULL));
    
    // Title screen
    title_screen();
    
    // Prologue
    prologue();
    
    // Random planet
    random_planet();
    
    // Space battle
    space_battle();
    
    printf("Congratulations! You have completed the space adventure!\n");
    
    return 0;
}

// Prints the title screen
void title_screen()
{
    printf("******************\n");
    printf("** SPACE ADVENTURE **\n");
    printf("******************\n\n");
}

// Prints the prologue
void prologue()
{
    printf("You are a space adventurer, traveling through the galaxy in search of riches and adventure.\n");
    printf("Your ship is the fastest in the galaxy, equipped with powerful weapons and shields.\n");
    printf("As you travel through space, you receive a distress signal from a nearby planet...\n\n");
}

// Generates a random planet for the player to explore
void random_planet()
{
    // Generate a random number between 1 and 4
    int planet_choice = rand()%4 + 1;
    
    printf("You have arrived at planet %d!\n", planet_choice);
    
    switch(planet_choice)
    {
        case 1:
            printf("This planet is covered in ice and snow. There may be hidden treasures buried beneath the ice...\n");
            break;
        case 2:
            printf("This planet is a desert wasteland. The scorching heat will be a challenge to overcome...\n");
            break;
        case 3:
            printf("This planet is a lush forest world, full of dangerous predators and hidden caves...\n");
            break;
        case 4:
            printf("This planet is a volcanic hellscape. The extreme heat and deadly lava flows will test your skills...\n");
            break;
    }
    
    printf("\n");
}

// Simulates a space battle with an alien ship
void space_battle()
{
    printf("As you leave the planet, you are attacked by an alien ship!\n");
    printf("You must use your ship's weapons and shields to defeat the alien.\n");
    
    // Player's ship health
    int player_health = 100;
    
    // Alien ship health
    int alien_health = 50;
    
    // Loop until one ship's health reaches 0
    while(player_health > 0 && alien_health > 0)
    {
        printf("Your ship health: %d\n", player_health);
        printf("Alien ship health: %d\n\n", alien_health);
        
        // Player attacks first
        int player_attack = rand()%20 + 10;
        printf("You fire your ship's weapons and deal %d damage to the alien!\n", player_attack);
        alien_health -= player_attack;
        
        // Check if alien ship has been destroyed
        if(alien_health <= 0)
        {
            printf("The alien ship has been destroyed! You have emerged victorious!\n");
            return;
        }
        
        // Alien attacks next
        int alien_attack = rand()%15 + 5;
        printf("The alien ship fires its weapons and deals %d damage to your ship!\n", alien_attack);
        player_health -= alien_attack;
        
        // Check if player's ship has been destroyed
        if(player_health <= 0)
        {
            printf("Your ship has been destroyed! Game over.\n");
            exit(0);
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 title_screen(void); // weak
__int64 prologue(void); // weak
__int64 random_planet(void); // weak
__int64 space_battle(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  title_screen();
  prologue();
  random_planet();
  space_battle();
  printf("Congratulations! You have completed the space adventure!\n");
  return 0;
}
// 1400015FC: using guessed type __int64 title_screen(void);
// 140001638: using guessed type __int64 prologue(void);
// 140001674: using guessed type __int64 random_planet(void);
// 140001725: using guessed type __int64 space_battle(void);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STRING_LENGTH 100

int min(int a, int b, int c) {
    if(a < b && a < c)
        return a;
    else if(b < c)
        return b;
    else
        return c;
}

int calculateLevenshteinDistance(char *str1, char *str2, int len1, int len2) {
    int cost = 0;
    int i, j;
    int **matrix = (int **) malloc((len1+1) * sizeof(int *));
    for(i = 0; i <= len1; i++)
        matrix[i] = (int *) malloc((len2+1) * sizeof(int));

    for(i = 0; i <= len1; i++)
        matrix[i][0] = i;

    for(j = 0; j <= len2; j++)
        matrix[0][j] = j;

    for(i = 1; i <= len1; i++) {
        for(j = 1; j <= len2; j++) {
            cost = (str1[i-1] == str2[j-1]) ? 0 : 1;
            matrix[i][j] = min(matrix[i-1][j] + 1, matrix[i][j-1] + 1, matrix[i-1][j-1] + cost);
        }
    }
    int dist = matrix[len1][len2];

    for(i = 0; i <= len1; i++)
        free(matrix[i]);
    free(matrix);

    return dist;
}

int main() {
    char str1[MAX_STRING_LENGTH], str2[MAX_STRING_LENGTH];
    int len1, len2;

    printf("Enter the first string: ");
    fgets(str1, MAX_STRING_LENGTH, stdin);
    len1 = strlen(str1);
    str1[len1-1] = '\0';
    len1 -= 1;

    printf("Enter the second string: ");
    fgets(str2, MAX_STRING_LENGTH, stdin);
    len2 = strlen(str2);
    str2[len2-1] = '\0';
    len2 -= 1;

    int dist = calculateLevenshteinDistance(str1, str2, len1, len2);
    printf("The Levenshtein distance between '%s' and '%s' is %d.\n", str1, str2, dist);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall calculateLevenshteinDistance(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000182E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Str[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[100]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v8; // [rsp+F4h] [rbp+74h]
  unsigned int v9; // [rsp+F8h] [rbp+78h]
  unsigned int v10; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter the first string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  v10 = strlen(Buffer);
  Buffer[--v10] = 0;
  printf("Enter the second string: ");
  v4 = __acrt_iob_func(0);
  fgets(Str, 100, v4);
  v9 = strlen(Str);
  Str[--v9] = 0;
  v8 = calculateLevenshteinDistance(Buffer, Str, v10, v9);
  printf("The Levenshtein distance between '%s' and '%s' is %d.\n", Buffer, Str, v8);
  return 0;
}
// 1400015C6: using guessed type __int64 __fastcall calculateLevenshteinDistance(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400019F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000182E: using guessed type char Buffer[100];
// 14000182E: using guessed type char Str[112];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]){
	char sequence[256+1] = "0";
	char inverse[256+1] = "1";
	char buffer[256+1];
	int i;
	
	for(i = 0; i < 8; i++){
		strcpy(buffer, sequence);
		strcat(sequence, inverse);
		strcat(inverse, buffer);
	}
	
	puts(sequence);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f6c(int64_t a1);
int64_t function_100003f78(int64_t a1, int64_t * a2, int64_t a3);
int64_t function_100003f84(int64_t * a1, int64_t * a2);
void function_100003f90(int64_t * s, int32_t n);
int32_t function_100003f9c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcat_chk(int64_t a1, int64_t * a2, int64_t a3);
int64_t ___strcpy_chk(int64_t * a1, int64_t * a2);
void _bzero(int64_t * a1, int32_t a2);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e64 - 0x100003f6c
int64_t entry_point(void) {
    // 0x100003e64
    int64_t v1; // bp-289, 0x100003e64
    _bzero(&v1, 257);
    v1 = 48;
    int64_t v2; // bp-546, 0x100003e64
    _bzero(&v2, 257);
    v2 = 49;
    for (int32_t i = 0; i < 8; i++) {
        // 0x100003ed8
        int64_t v3; // bp-803, 0x100003e64
        ___strcpy_chk(&v3, &v1);
        ___strcat_chk((int64_t)&v1, &v2, 257);
        ___strcat_chk((int64_t)&v2, &v3, 257);
    }
    int32_t v4 = _puts((char *)&v1); // 0x100003f30
    int64_t v5 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f40
    if (v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f54
        ___stack_chk_fail((int64_t)v4);
    }
    // 0x100003f58
    return 0;
}

// Address range: 0x100003f6c - 0x100003f78
int64_t function_100003f6c(int64_t a1) {
    // 0x100003f6c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f78 - 0x100003f84
int64_t function_100003f78(int64_t a1, int64_t * a2, int64_t a3) {
    // 0x100003f78
    return ___strcat_chk(a1, a2, a3);
}

// Address range: 0x100003f84 - 0x100003f90
int64_t function_100003f84(int64_t * a1, int64_t * a2) {
    // 0x100003f84
    return ___strcpy_chk(a1, a2);
}

// Address range: 0x100003f90 - 0x100003f9c
void function_100003f90(int64_t * s, int32_t n) {
    // 0x100003f90
    _bzero(s, n);
}

// Address range: 0x100003f9c - 0x100003fa8
int32_t function_100003f9c(char * s) {
    // 0x100003f9c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

typedef int bool;
typedef enum { ENCRYPT, DECRYPT } cmode;

const char *l_alphabet = "HXUCZVAMDSLKPEFJRIGTWOBNYQ";
const char *r_alphabet = "PTLNBQDEOYSFAVZKGJRIHWXUMC";

void chao(const char *in, char *out, cmode mode, bool show_steps) {
    int i, j, index;
    char store;
    size_t len = strlen(in);
    char left[27], right[27], temp[27];
    strcpy(left, l_alphabet);
    strcpy(right, r_alphabet);
    temp[26] = '\0';

    for (i = 0; i < len; ++i ) {
        if (show_steps) printf("%s  %s\n", left, right);
        if (mode == ENCRYPT) {
            index = strchr(right, in[i]) - right;
            out[i] = left[index];
        }
        else {
            index = strchr(left, in[i]) - left;
            out[i] = right[index];
        }
        if (i == len - 1) break;

        /* permute left */

        for (j = index; j < 26; ++j) temp[j - index] = left[j];
        for (j = 0; j < index; ++j) temp[26 - index + j] = left[j];
        store = temp[1];
        for (j = 2; j < 14; ++j) temp[j - 1] = temp[j];
        temp[13] = store;
        strcpy(left, temp);

        /* permute right */

        for (j = index; j < 26; ++j) temp[j - index] = right[j];
        for (j = 0; j < index; ++j) temp[26 - index + j] = right[j];
        store = temp[0];
        for (j = 1; j < 26; ++j) temp[j - 1] = temp[j];
        temp[25] = store;
        store = temp[2];
        for (j = 3; j < 14; ++j) temp[j - 1] = temp[j];
        temp[13] = store;
        strcpy(right, temp);
    }
}

int main() {
    const char *plain_text = "WELLDONEISBETTERTHANWELLSAID";
    char *cipher_text = malloc(strlen(plain_text) + 1);
    char *plain_text2 = malloc(strlen(plain_text) + 1);
    printf("The original plaintext is : %s\n", plain_text);
    printf("\nThe left and right alphabets after each permutation"
           " during encryption are :\n\n");
    chao(plain_text, cipher_text, ENCRYPT, TRUE);
    printf("\nThe ciphertext is : %s\n", cipher_text);
    chao(cipher_text, plain_text2, DECRYPT, FALSE);
    printf("\nThe recovered plaintext is : %s\n", plain_text2);
    free(cipher_text);
    free(plain_text2);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038c0(void);
int64_t function_100003e4c(int64_t a1);
int64_t function_100003e58(int64_t * a1, int64_t a2, int64_t a3);
void function_100003e64(int64_t * ptr);
int64_t * function_100003e70(int32_t size);
int32_t function_100003e7c(char * format, ...);
char * function_100003e88(char * s, int32_t c);
int32_t function_100003e94(char * s);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x10000000003ea0; // 0x100008000
char * g2 = "\xbb>"; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcpy_chk(int64_t * a1, int64_t a2, int64_t a3);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
char * _strchr(char * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000038c0 - 0x100003d60
int64_t function_1000038c0(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x1000038d4
    int64_t v2; // 0x1000038c0
    int32_t v3 = _strlen((char *)v2); // 0x1000038f0
    int64_t v4; // bp-51, 0x1000038c0
    ___strcpy_chk(&v4, g1, 27);
    int64_t v5 = (int64_t)g2; // 0x100003918
    int64_t v6; // bp-78, 0x1000038c0
    int64_t v7 = ___strcpy_chk(&v6, v5, 27); // 0x100003940
    int64_t v8; // 0x1000038c0
    int32_t v9; // 0x1000038c0
    int64_t v10; // 0x1000038c0
    int64_t v11; // 0x1000038c0
    int64_t v12; // 0x1000038c0
    if (v3 != 0) {
        int64_t v13 = &v4;
        int64_t v14 = &v6;
        int32_t v15; // bp-105, 0x1000038c0
        v10 = &v15;
        v11 = v10 - 1;
        v9 = 0;
        v12 = v5;
        while (true) {
          lab_0x100003948:
            // 0x100003948
            if ((int32_t)v2 != 0) {
                // 0x10000395c
                _printf("%s  %s\n", (char *)v12, (char *)27);
            }
            int64_t v16 = v9;
            int32_t v17 = (int32_t)*(char *)(v2 + v16);
            int64_t v18; // 0x1000038c0
            int64_t v19; // 0x1000038c0
            if ((int32_t)v2 == 0) {
                int64_t v20 = (int64_t)_strchr((char *)&v6, v17); // 0x1000039a8
                int64_t v21 = v20 - v14; // 0x1000039b0
                *(char *)(v2 + v16) = *(char *)((0x100000000 * v21 >> 32) + v13);
                v18 = v21;
                v19 = v20;
            } else {
                int64_t v22 = (int64_t)_strchr((char *)&v4, v17); // 0x1000039f0
                int64_t v23 = v22 - v13; // 0x1000039f8
                *(char *)(v2 + v16) = *(char *)((0x100000000 * v23 >> 32) + v14);
                v18 = v23;
                v19 = v22;
            }
            // 0x100003a24
            v7 = v19;
            if ((int64_t)v3 - 1 == v16) {
                // break -> 0x100003d30
                break;
            }
            int32_t v24 = v18;
            int32_t v25 = v24; // 0x100003a5c
            if (v24 < 26 != (25 - v24 & v24) < 0) {
                int32_t v26 = v25;
                char v27 = *(char *)((int64_t)v26 + v13); // 0x100003a70
                *(char *)((int64_t)(v26 - v24) + v10) = v27;
                int32_t v28 = v26 + 1; // 0x100003a94
                while (v26 < 25 != (24 - v26 & v28) < 0) {
                    // 0x100003a64
                    v26 = v28;
                    v27 = *(char *)((int64_t)v26 + v13);
                    *(char *)((int64_t)(v26 - v24) + v10) = v27;
                    v28 = v26 + 1;
                }
            }
            int32_t v29 = -v24;
            if (v29 < 0 != (v29 & v24) < 0) {
                int32_t v30 = 0; // 0x100003af8
                char v31 = *(char *)((int64_t)v30 + v13); // 0x100003acc
                *(char *)((int64_t)(26 - v24 + v30) + v10) = v31;
                v30++;
                while (v30 - v24 < 0 != ((v30 - v24 ^ v30) & (v30 ^ v24)) < 0) {
                    // 0x100003ac0
                    v31 = *(char *)((int64_t)v30 + v13);
                    *(char *)((int64_t)(26 - v24 + v30) + v10) = v31;
                    v30++;
                }
            }
            int64_t v32 = 2;
            *(char *)(v11 + v32) = *(char *)(v32 + v10);
            int64_t v33 = v32 + 1;
            while (v33 != 14) {
                // 0x100003b2c
                v32 = v33;
                *(char *)(v11 + v32) = *(char *)(v32 + v10);
                v33 = v32 + 1;
            }
            // 0x100003b64
            ___strcpy_chk(&v4, v10, 27);
            int32_t v34 = v24; // 0x100003b94
            if (v24 < 26 != (25 - v24 & v24) < 0) {
                int32_t v35 = v34;
                char v36 = *(char *)((int64_t)v35 + v14); // 0x100003ba8
                *(char *)((int64_t)(v35 - v24) + v10) = v36;
                int32_t v37 = v35 + 1; // 0x100003bcc
                while (v35 < 25 != (24 - v35 & v37) < 0) {
                    // 0x100003b9c
                    v35 = v37;
                    v36 = *(char *)((int64_t)v35 + v14);
                    *(char *)((int64_t)(v35 - v24) + v10) = v36;
                    v37 = v35 + 1;
                }
            }
            if (v29 < 0 != (v29 & v24) < 0) {
                int32_t v38 = 0; // 0x100003c30
                char v39 = *(char *)((int64_t)v38 + v14); // 0x100003c04
                *(char *)((int64_t)(26 - v24 + v38) + v10) = v39;
                v38++;
                while (v38 - v24 < 0 != ((v38 - v24 ^ v38) & (v38 ^ v24)) < 0) {
                    // 0x100003bf8
                    v39 = *(char *)((int64_t)v38 + v14);
                    *(char *)((int64_t)(26 - v24 + v38) + v10) = v39;
                    v38++;
                }
            }
            int64_t v40 = 1;
            while (true) {
                int64_t v41 = v40;
                *(char *)(v11 + v41) = *(char *)(v41 + v10);
                v40 = v41 + 1;
                v8 = 3;
                if (v40 == 26) {
                    goto lab_0x100003ccc;
                }
            }
            goto lab_0x100003d04;
        }
    }
  lab_0x100003d30:;
    int64_t result = v7; // 0x100003d48
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003d50
        result = ___stack_chk_fail(v7);
    }
    // 0x100003d54
    return result;
  lab_0x100003ccc:;
    int64_t v42 = v8;
    *(char *)(v11 + v42) = *(char *)(v42 + v10);
    int64_t v43 = v42 + 1;
    v8 = v43;
    if (v43 == 14) {
        goto lab_0x100003d04;
    } else {
        goto lab_0x100003ccc;
    }
  lab_0x100003d04:;
    int64_t v44 = ___strcpy_chk(&v6, v10, 27); // 0x100003d18
    int32_t v45 = v9 + 1; // 0x100003d24
    v9 = v45;
    v12 = v10;
    v7 = v44;
    if (v3 <= v45) {
        // break -> 0x100003d30
        goto lab_0x100003d30;
    }
    goto lab_0x100003948;
}

// Address range: 0x100003d60 - 0x100003e4c
int64_t entry_point(void) {
    int64_t * v1 = _malloc(_strlen("WELLDONEISBETTERTHANWELLSAID") + 1); // 0x100003d90
    int64_t * v2 = _malloc(_strlen("WELLDONEISBETTERTHANWELLSAID") + 1); // 0x100003da4
    int64_t v3; // 0x100003d60
    _printf("The original plaintext is : %s\n", (char *)v3);
    _printf("\nThe left and right alphabets after each permutation during encryption are :\n\n");
    function_1000038c0();
    _printf("\nThe ciphertext is : %s\n", v1);
    function_1000038c0();
    _printf("\nThe recovered plaintext is : %s\n", v2);
    _free(v1);
    _free(v2);
    return 0;
}

// Address range: 0x100003e4c - 0x100003e58
int64_t function_100003e4c(int64_t a1) {
    // 0x100003e4c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e58 - 0x100003e64
int64_t function_100003e58(int64_t * a1, int64_t a2, int64_t a3) {
    // 0x100003e58
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003e64 - 0x100003e70
void function_100003e64(int64_t * ptr) {
    // 0x100003e64
    _free(ptr);
}

// Address range: 0x100003e70 - 0x100003e7c
int64_t * function_100003e70(int32_t size) {
    // 0x100003e70
    return _malloc(size);
}

// Address range: 0x100003e7c - 0x100003e88
int32_t function_100003e7c(char * format, ...) {
    // 0x100003e7c
    return _printf(format);
}

// Address range: 0x100003e88 - 0x100003e94
char * function_100003e88(char * s, int32_t c) {
    // 0x100003e88
    return _strchr(s, c);
}

// Address range: 0x100003e94 - 0x100003ea0
int32_t function_100003e94(char * s) {
    // 0x100003e94
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include<time.h>
#include<stdio.h>
#include<stdlib.h>
int main(){
  time_t my_time = time(NULL);
  printf("%s", ctime(&my_time));
  return 0;
}
`,`#include "system-time.h"



undefined4 entry(void)

{
  time_t local_20;
  undefined4 local_14;
  
  local_14 = 0;
  local_20 = _time((time_t *)0x0);
  _ctime(&local_20);
  _printf("%s");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _ctime(time_t *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__ctime_100004000)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004010)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h> // atoi()
#include <math.h> // pow()

int main(int argc, char* argv[])
{
  int i, count=0;
  double f, sum=0.0, prod=1.0, resum=0.0;

  for (i=1; i<argc; ++i) {
    f = atof(argv[i]);
    count++;
    sum += f;
    prod *= f;
    resum += (1.0/f);
  }
  //printf(" c:%d\n s:%f\n p:%f\n r:%f\n",count,sum,prod,resum);
  printf("Arithmetic mean = %f\n",sum/count);
  printf("Geometric mean = %f\n",pow(prod,(1.0/count)));
  printf("Harmonic mean = %f\n",count/resum);

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
float64_t function_100003f44(char * nptr);
float64_t function_100003f50(float64_t a1, float64_t a2);
int32_t function_100003f5c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

float64_t _atof(char * a1);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003de8 - 0x100003f44
int64_t entry_point(void) {
    // 0x100003de8
    int64_t v1; // 0x100003de8
    int32_t v2 = v1; // 0x100003df8
    int32_t v3 = 1 - v2; // 0x100003e2c
    int32_t v4 = 1; // 0x100003e34
    int128_t v5; // 0x100003de8
    int64_t v6 = v5; // 0x100003e34
    if (v3 < 0 != (v3 & v2) < 0) {
        float64_t v7 = _atof((char *)*(int64_t *)(8 * (int64_t)v4 + v1)); // 0x100003e48
        v4++;
        while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
            // 0x100003e3c
            v7 = _atof((char *)*(int64_t *)(8 * (int64_t)v4 + v1));
            v4++;
        }
        // 0x100003e24
        v6 = (float32_t)v7;
    }
    // 0x100003ea8
    __asm_sshll(0.0f, 0);
    _printf("Arithmetic mean = %f\n", (float64_t)v6);
    int128_t v8 = __asm_sshll(0.0f, 0); // 0x100003ee0
    _printf("Geometric mean = %f\n", _pow((float64_t)v6, (float64_t)(int64_t)v8));
    _printf("Harmonic mean = %f\n", (float64_t)(int64_t)__asm_sshll(0.0f, 0));
    return 0;
}

// Address range: 0x100003f44 - 0x100003f50
float64_t function_100003f44(char * nptr) {
    // 0x100003f44
    return _atof(nptr);
}

// Address range: 0x100003f50 - 0x100003f5c
float64_t function_100003f50(float64_t a1, float64_t a2) {
    // 0x100003f50
    return _pow(a1, a2);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * format, ...) {
    // 0x100003f5c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <math.h>

// https://webspace.science.uu.nl/~gent0113/calendar/isocalendar.htm

int p(int year) {
	return (int)((double)year + floor(year/4) - floor(year/100) + floor(year/400)) % 7;
}

int is_long_year(int year) {
	return p(year) == 4 || p(year - 1) == 3;
}

void print_long_years(int from, int to) {
	for (int year = from; year <= to; ++year) {
		if (is_long_year(year)) {
			printf("%d ", year);
		}
	}
}

int main() {

	printf("Long (53 week) years between 1800 and 2100\n\n");
	print_long_years(1800, 2100);
	printf("\n");
	return 0;
}
`,`#include "long-year.h"



int _p(int param_1)

{
  return (int)((((double)(long)param_1 + (double)(long)(double)(param_1 / 4)) -
               (double)(long)(double)(param_1 / 100)) + (double)(long)(double)(param_1 / 400)) % 7;
}



bool _is_long_year(int param_1)

{
  bool bVar1;
  int iVar2;
  
  iVar2 = _p(param_1);
  bVar1 = true;
  if (iVar2 != 4) {
    iVar2 = _p(param_1 + -1);
    bVar1 = iVar2 == 3;
  }
  return bVar1;
}



ulong _print_long_years(ulong param_1,int param_2)

{
  uint uVar1;
  int local_1c;
  
  for (local_1c = (int)param_1; local_1c <= param_2; local_1c = local_1c + 1) {
    param_1 = _is_long_year(local_1c);
    if ((int)param_1 != 0) {
      uVar1 = _printf("%d ");
      param_1 = (ulong)uVar1;
    }
  }
  return param_1;
}



undefined4 entry(void)

{
  _printf("Long (53 week) years between 1800 and 2100\n\n");
  _print_long_years(0x708,0x834);
  _printf("\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stdbool.h>

#define N_COLS 15
#define N_ROWS 15

// Probability granularity 0.0, 0.1, ... 1.0
#define N_STEPS 11

// Simulation tries
#define N_TRIES 100

typedef unsigned char Cell;
enum { EMPTY_CELL   = ' ',
       FILLED_CELL  = '#',
       VISITED_CELL = '.' };
typedef Cell Grid[N_ROWS][N_COLS];

void initialize(Grid grid, const double probability) {
    for (size_t r = 0; r < N_ROWS; r++)
        for (size_t c = 0; c < N_COLS; c++) {
            const double rnd = rand() / (double)RAND_MAX;
            grid[r][c] = (rnd < probability) ? EMPTY_CELL : FILLED_CELL;
        }
}

void show(Grid grid) {
    char line[N_COLS + 3];
    memset(&line[0], '-', N_COLS + 2);
    line[0] = '+';
    line[N_COLS + 1] = '+';
    line[N_COLS + 2] = '\0';

    printf("%s\n", line);
    for (size_t r = 0; r < N_ROWS; r++) {
        putchar('|');
        for (size_t c = 0; c < N_COLS; c++)
            putchar(grid[r][c]);
        puts("|");
    }
    printf("%s\n", line);
}

bool walk(Grid grid, const size_t r, const size_t c) {
    const size_t bottom = N_ROWS - 1;
    grid[r][c] = VISITED_CELL;

    if (r < bottom && grid[r + 1][c] == EMPTY_CELL) { // Down.
        if (walk(grid, r + 1, c))
            return true;
    } else if (r == bottom)
        return true;

    if (c && grid[r][c - 1] == EMPTY_CELL) // Left.
        if (walk(grid, r, c - 1))
            return true;

    if (c < N_COLS - 1 && grid[r][c + 1] == EMPTY_CELL) // Right.
        if (walk(grid, r, c + 1))
            return true;

    if (r && grid[r - 1][c] == EMPTY_CELL) // Up.
        if (walk(grid, r - 1, c))
            return true;

    return false;
}

bool percolate(Grid grid) {
    const size_t startR = 0;
    for (size_t c = 0; c < N_COLS; c++)
        if (grid[startR][c] == EMPTY_CELL)
            if (walk(grid, startR, c))
                return true;
    return false;
}

typedef struct {
    double prob;
    size_t count;
} Counter;

int main() {
    const double probability_step = 1.0 / (N_STEPS - 1);
    Counter counters[N_STEPS];
    for (size_t i = 0; i < N_STEPS; i++)
        counters[i] = (Counter){ i * probability_step, 0 };

    bool sample_shown = false;
    static Grid grid;
    srand(time(NULL));

    for (size_t i = 0; i < N_STEPS; i++) {
        for (size_t t = 0; t < N_TRIES; t++) {
            initialize(grid, counters[i].prob);
            if (percolate(grid)) {
                counters[i].count++;
                if (!sample_shown) {
                    printf("Percolating sample (%dx%d,"
                           " probability =%5.2f):\n",
                           N_COLS, N_ROWS, counters[i].prob);
                    show(grid);
                    sample_shown = true;
                }
            }
        }
    }

    printf("\nFraction of %d tries that percolate through:\n", N_TRIES);
    for (size_t i = 0; i < N_STEPS; i++)
        printf("%1.1f %1.3f\n", counters[i].prob,
               counters[i].count / (double)N_TRIES);

    return 0;
}
`,`#include "percolation-site-percolation-2.h"



void _initialize(double param_1,long param_2)

{
  int iVar1;
  undefined uVar2;
  undefined8 local_30;
  undefined8 local_28;
  
  for (local_28 = 0; local_28 < 0xf; local_28 = local_28 + 1) {
    for (local_30 = 0; local_30 < 0xf; local_30 = local_30 + 1) {
      iVar1 = _rand();
      uVar2 = 0x20;
      if (param_1 <= (double)iVar1 / 2147483647.0) {
        uVar2 = 0x23;
      }
      *(undefined *)(param_2 + local_28 * 0xf + local_30) = uVar2;
    }
  }
  return;
}



void _show(long param_1)

{
  int iVar1;
  long lVar2;
  ulong local_48;
  ulong local_40;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004008;
  _printf("%s\n");
  for (local_40 = 0; local_40 < 0xf; local_40 = local_40 + 1) {
    _putchar(0x7c);
    for (local_48 = 0; local_48 < 0xf; local_48 = local_48 + 1) {
      _putchar((uint)*(byte *)(param_1 + local_40 * 0xf + local_48));
    }
    _puts("|");
  }
  iVar1 = _printf("%s\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined _walk(long param_1,ulong param_2,ulong param_3)

{
  ulong uVar1;
  undefined local_11;
  
  *(undefined *)(param_1 + param_2 * 0xf + param_3) = 0x2e;
  if ((param_2 < 0xe) && (*(char *)(param_1 + (param_2 + 1) * 0xf + param_3) == ' ')) {
    uVar1 = _walk(param_1,param_2 + 1,param_3);
    if ((uVar1 & 1) != 0) {
      return 1;
    }
  }
  else if (param_2 == 0xe) {
    return 1;
  }
  if (((param_3 == 0) || (*(char *)(param_1 + param_2 * 0xf + (param_3 - 1)) != ' ')) ||
     (uVar1 = _walk(param_1,param_2,param_3 - 1), (uVar1 & 1) == 0)) {
    if (((param_3 < 0xe) && (*(char *)(param_1 + param_2 * 0xf + param_3 + 1) == ' ')) &&
       (uVar1 = _walk(param_1,param_2,param_3 + 1), (uVar1 & 1) != 0)) {
      local_11 = 1;
    }
    else if (((param_2 == 0) || (*(char *)(param_1 + (param_2 - 1) * 0xf + param_3) != ' ')) ||
            (uVar1 = _walk(param_1,param_2 - 1,param_3), (uVar1 & 1) == 0)) {
      local_11 = 0;
    }
    else {
      local_11 = 1;
    }
  }
  else {
    local_11 = 1;
  }
  return local_11;
}



undefined _percolate(long param_1)

{
  ulong uVar1;
  ulong local_30;
  
  local_30 = 0;
  while( true ) {
    if (0xe < local_30) {
      return 0;
    }
    if ((*(char *)(param_1 + local_30) == ' ') &&
       (uVar1 = _walk(param_1,0,local_30), (uVar1 & 1) != 0)) break;
    local_30 = local_30 + 1;
  }
  return 1;
}



undefined8 entry(void)

{
  bool bVar1;
  int iVar2;
  time_t tVar3;
  ulong uVar4;
  double dVar5;
  ulong local_120;
  ulong local_118;
  ulong local_110;
  ulong local_f0;
  double adStack_d8 [22];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_f0 = 0; local_f0 < 0xb; local_f0 = local_f0 + 1) {
    dVar5 = (double)NEON_ucvtf(local_f0);
    adStack_d8[local_f0 * 2 + 1] = 0.0;
    adStack_d8[local_f0 * 2] = dVar5 * 0.1;
  }
  bVar1 = false;
  tVar3 = _time((time_t *)0x0);
  _srand((uint)tVar3);
  for (local_110 = 0; local_110 < 0xb; local_110 = local_110 + 1) {
    for (local_118 = 0; local_118 < 100; local_118 = local_118 + 1) {
      _initialize(adStack_d8[local_110 * 2]);
      uVar4 = _percolate(0x100008000);
      if (((uVar4 & 1) != 0) &&
         (adStack_d8[local_110 * 2 + 1] = (double)((long)adStack_d8[local_110 * 2 + 1] + 1), !bVar1)
         ) {
        _printf("Percolating sample (%dx%d, probability =%5.2f):\n");
        _show(0x100008000);
        bVar1 = true;
      }
    }
  }
  iVar2 = _printf("\nFraction of %d tries that percolate through:\n");
  for (local_120 = 0; local_120 < 0xb; local_120 = local_120 + 1) {
    NEON_ucvtf(adStack_d8[local_120 * 2 + 1]);
    iVar2 = _printf("%1.1f %1.3f\n");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar2);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004028)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004030)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004038)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// In column order, print out the given positions in chess notation.
// For example, when N = 8, the first solution printed is:
// "a1 b5 c8 d6 e3 f7 g2 h4"
static void print_positions(int x[], const size_t n) {
	static const char alphabet[] = "abcdefghijklmnopqrstuvwxyz";

	// There are only 26 letters in the ASCII alphabet, so
	// so don't bother with chess notation above 26.
	if (n <= 26) {
		for (size_t i = 0; i < n; ++i)
			printf("%c%u ", alphabet[i], x[i] + 1);
	} else {
		for (size_t i = 0; i < n; ++i)
			printf("%u ", x[i] + 1);
	}
    putchar('\n');
}

// Print all solutions to the N queens problem, holding the results in
// the intermediate array x, and with the auxiliary boolean arrays a, b, and c.
// x and a are both N elements long, while b and c are 2*N-1 elements long.
// It is assumed that these arrays are zeroed before this routine is called.
static void queens(int x[], bool a[], bool b[], bool c[], const size_t n) {
	size_t col, row = 0;

advance_row:
	if (row >= n) {
		print_positions(x, n);
		goto backtrack;
	}
	col = 0;
try_column:
	if (!a[col] && !b[col+row-1] && !c[col-row+n]) {
		a[col] = true;
		b[col+row-1] = true;
		c[col-row+n] = true;
		x[row] = col;
		row++;
		goto advance_row;
	}
try_again:
	if (col < n-1) {
		col++;
		goto try_column;
	}
backtrack:
	if (row != 0) {
		--row;
		col = x[row];
		c[col-row+n] = false;
		b[col+row-1] = false;
		a[col] = false;
		goto try_again;
	}
}

static void *calloc_wrapper(size_t count, size_t bytesize) {
	void *r;
	if ((r = calloc(count, bytesize)) == NULL) {
		exit(EXIT_FAILURE);
	}
	return r;
}

int main(int argc, char **argv) {
	bool *a, *b, *c;
	int n, *x;
	
	if (argc != 2 || (n = atoi(argv[1])) <= 0) {
		printf("%s: specify a natural number argument\n", argv[0]);
		return 1;
	}

	x = calloc_wrapper(n, sizeof(x[0]));
	a = calloc_wrapper(n, sizeof(a[0]));
	b = calloc_wrapper((2 * n - 1), sizeof(b[0]));
	c = calloc_wrapper((2 * n - 1), sizeof(c[0]));

	queens(x, a, b, c, n);

	// Don't bother freeing before exiting.
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bd0(void);
int64_t function_100003c20(void);
int64_t function_100003e0c(void);
int32_t function_100003f20(char * nptr);
int64_t * function_100003f2c(int32_t nmemb, int32_t size);
void function_100003f38(int32_t status);
int32_t function_100003f44(char * format, ...);
int32_t function_100003f50(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _atoi(char * a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003abc - 0x100003bd0
int64_t entry_point(void) {
    // 0x100003abc
    int64_t v1; // 0x100003abc
    if ((int32_t)v1 != 2 || _atoi((char *)*(int64_t *)(v1 + 8)) < 1) {
        // 0x100003b08
        _printf("%s: specify a natural number argument\n", (char *)v1);
        // 0x100003bc0
        return 1;
    }
    // 0x100003b30
    function_100003bd0();
    function_100003bd0();
    function_100003bd0();
    function_100003bd0();
    function_100003c20();
    // 0x100003bc0
    return 0;
}

// Address range: 0x100003bd0 - 0x100003c20
int64_t function_100003bd0(void) {
    // 0x100003bd0
    int64_t v1; // 0x100003bd0
    int64_t * v2 = _calloc((int32_t)v1, (int32_t)v1); // 0x100003bec
    if (v2 != NULL) {
        // 0x100003c10
        return (int64_t)v2;
    }
    // 0x100003c08
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100003c20 - 0x100003e0c
int64_t function_100003c20(void) {
    // 0x100003c20
    int64_t v1; // 0x100003c20
    uint64_t v2 = v1;
    int64_t v3 = v1 - 1;
    int64_t v4 = v1 + v2;
    int64_t v5 = 0; // 0x100003c44
    int64_t v6; // 0x100003c20
    int64_t v7; // 0x100003c20
    int32_t v8; // 0x100003c20
    int64_t v9; // 0x100003c20
    int64_t v10; // 0x100003c20
    int64_t v11; // 0x100003c20
    while (true) {
      lab_0x100003c48:;
        int64_t v12 = v5;
        v6 = v12;
        v10 = v9;
        v8 = 0;
        if (v12 < v2) {
            goto lab_0x100003c78;
        } else {
            // 0x100003c60
            v7 = v12;
            v11 = function_100003e0c();
            goto lab_0x100003d80;
        }
    }
  lab_0x100003e00:;
    // 0x100003e00
    int64_t result; // 0x100003c20
    return result;
  lab_0x100003c78:;
    int32_t v13 = v8;
    int64_t v14 = v10;
    int64_t v15 = v6;
    int64_t v16 = v13; // 0x100003c7c
    char * v17 = (char *)(v1 + v16); // 0x100003c84
    if (*v17 % 2 == 0) {
        char * v18 = (char *)(v15 + v3 + v16); // 0x100003ca8
        if (*v18 % 2 == 0) {
            char * v19 = (char *)(v4 - v15 + v16); // 0x100003cd0
            if (*v19 % 2 == 0) {
                // 0x100003cdc
                *v17 = 1;
                *v18 = 1;
                *v19 = 1;
                *(int32_t *)(4 * v15 + v1) = v13;
                v9 = v14;
                v5 = v15 + 1;
                goto lab_0x100003c48;
            } else {
                goto lab_0x100003d4c;
            }
        } else {
            goto lab_0x100003d4c;
        }
    } else {
        goto lab_0x100003d4c;
    }
  lab_0x100003d4c:;
    int64_t v20 = v15; // 0x100003d4c
    int32_t v21 = v13; // 0x100003d4c
    int64_t v22 = v14; // 0x100003d4c
    goto lab_0x100003d50;
  lab_0x100003d80:
    // 0x100003d80
    result = v11;
    if (v7 == 0) {
        // break -> 0x100003e00
        goto lab_0x100003e00;
    }
    int64_t v26 = v7 - 1; // 0x100003d98
    int32_t v27 = *(int32_t *)(4 * v26 + v1); // 0x100003da8
    int64_t v28 = v27; // 0x100003da8
    *(char *)(v4 + 1 - v7 + v28) = 0;
    *(char *)(v26 + v3 + v28) = 0;
    *(char *)(v1 + v28) = 0;
    v20 = v26;
    v21 = v27;
    v22 = result;
    goto lab_0x100003d50;
  lab_0x100003d50:;
    int64_t v23 = v22;
    int32_t v24 = v21;
    int64_t v25 = v20;
    v7 = v25;
    v11 = v23;
    if (v2 - 1 > (int64_t)v24) {
        // 0x100003d6c
        v6 = v25;
        v10 = v23;
        v8 = v24 + 1;
        goto lab_0x100003c78;
    } else {
        goto lab_0x100003d80;
    }
}

// Address range: 0x100003e0c - 0x100003f20
int64_t function_100003e0c(void) {
    // 0x100003e0c
    int64_t v1; // 0x100003e0c
    uint64_t v2 = v1;
    if (v2 >= 26 == (v2 != 26)) {
        if (v2 == 0) {
            // 0x100003f0c
            return _putchar(10);
        }
        int64_t v3 = 0; // 0x100003efc
        _printf("%u ", (int32_t)v2);
        while (v3 + 1 != v2) {
            // 0x100003ecc
            v3++;
            _printf("%u ", (int32_t)v2);
        }
        // 0x100003f0c
        return _putchar(10);
    }
    if (v2 == 0) {
        // 0x100003f0c
        return _putchar(10);
    }
    int64_t v4 = 0; // 0x100003e9c
    _printf("%c%u ", (char)v2, (int32_t)v1);
    while (v4 + 1 != v2) {
        // 0x100003e54
        v4++;
        _printf("%c%u ", (char)v2, (int32_t)v1);
    }
    // 0x100003f0c
    return _putchar(10);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(char * nptr) {
    // 0x100003f20
    return _atoi(nptr);
}

// Address range: 0x100003f2c - 0x100003f38
int64_t * function_100003f2c(int32_t nmemb, int32_t size) {
    // 0x100003f2c
    return _calloc(nmemb, size);
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int32_t status) {
    // 0x100003f38
    _exit(status);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * format, ...) {
    // 0x100003f44
    return _printf(format);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(int32_t c) {
    // 0x100003f50
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: unmistakable
#include <stdio.h>

#define ROW 6
#define COL 6

char maze[ROW][COL] = {
    {'#', '#', '#', '#', '#', '#'},
    {'#', ' ', ' ', ' ', ' ', '#'},
    {'#', '#', ' ', '#', '#', '#'},
    {'#', ' ', ' ', ' ', ' ', '#'},
    {'#', '#', '#', ' ', '#', '#'},
    {'#', '#', '#', '#', '#', '#'}
};  

struct Point {
    int x;
    int y;
};

void printMaze() {
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < COL; j++) {
            printf("%c", maze[i][j]);
        }
        printf("\n");
    }
}

int isSafe(int x, int y) {
    if (x >= 0 && x < ROW && y >= 0 && y < COL && maze[x][y] != '#') {
        return 1;
    }
    return 0;
}

int findRoute(int x, int y, struct Point* path) {
    if (x < 0 || x >= ROW || y < 0 || y >= COL) {
        return 0;
    }

    if (maze[x][y] == 'E') {
        path->x = x;
        path->y = y;
        return 1;
    }

    if (isSafe(x, y) == 0) {
        return 0;
    }

    maze[x][y] = '#';

    if (findRoute(x-1, y, path) == 1) {
        path++;
        path->x = x;
        path->y = y;
        return 1;
    }

    if (findRoute(x+1, y, path) == 1) {
        path++;
        path->x = x;
        path->y = y;
        return 1;
    }

    if (findRoute(x, y-1, path) == 1) {
        path++;
        path->x = x;
        path->y = y;
        return 1;
    }

    if (findRoute(x, y+1, path) == 1) {
        path++;
        path->x = x;
        path->y = y;
        return 1;
    }

    return 0;
}

int main() {
    struct Point path[ROW*COL];
    int start_x = 1;
    int start_y = 1;

    maze[start_x][start_y] = '#';

    int found = findRoute(start_x, start_y, path);

    if (found == 1) {
        printMaze();
        printf("\nRoute: ");
        for (int i = ROW*COL-1; i >= 0; i--) {
            printf("(%d,%d) ", path[i].x, path[i].y);
        }
        printf("\n");
    } else {
        printf("No route found.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 printMaze(void); // weak
__int64 __fastcall findRoute(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char maze[37] = "#######    ### ####    #### ########"; // weak


//----- (000000014000182C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[72]; // [rsp+20h] [rbp-60h] BYREF
  int Route; // [rsp+140h] [rbp+C0h]
  unsigned int v6; // [rsp+144h] [rbp+C4h]
  unsigned int v7; // [rsp+148h] [rbp+C8h]
  int i; // [rsp+14Ch] [rbp+CCh]

  _main(argc, argv, envp);
  v7 = 1;
  v6 = 1;
  maze[7] = 35;
  Route = findRoute(v7, v6, v4);
  if ( Route == 1 )
  {
    printMaze();
    printf("\nRoute: ");
    for ( i = 35; i >= 0; --i )
      printf("(%d,%d) ", (unsigned int)v4[2 * i], (unsigned int)v4[2 * i + 1]);
    printf("\n");
  }
  else
  {
    printf("No route found.\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 printMaze(void);
// 140001670: using guessed type __int64 __fastcall findRoute(_QWORD, _QWORD, _QWORD);
// 1400019F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h> // For time

enum { empty = 0, tree = 1, fire = 2 };
const char *disp[] = {"  ", "\033[32m/\\\033[m", "\033[07;31m/\\\033[m"};
double tree_prob = 0.01, burn_prob = 0.0001;

#define for_x for (int x = 0; x < w; x++)
#define for_y for (int y = 0; y < h; y++)
#define for_yx for_y for_x
#define chance(x) (rand() < RAND_MAX * x)
void evolve(int w, int h)
{
	unsigned univ[h][w], new[h][w];
	for_yx new[y][x] = univ[y][x] = chance(tree_prob) ? tree : empty;

show:	printf("\033[H");
	for_y {
		for_x printf("%s",disp[univ[y][x]]);
		printf("\033[E");
	}
	fflush(stdout);

	for_yx {
		switch (univ[y][x]) {
		case fire:	new[y][x] = empty;
				break;
		case empty:	if (chance(tree_prob)) new[y][x] = tree;
				break;
		default:
			for (int y1 = y - 1; y1 <= y + 1; y1++) {
				if (y1 < 0 || y1 >= h) continue;
				for (int x1 = x - 1; x1 <= x + 1; x1++) {
					if (x1 < 0 || x1 >= w) continue;
					if (univ[y1][x1] != fire) continue;

					new[y][x] = fire;
					goto burn;
				}
			}

			burn:
			if (new[y][x] == tree && chance(burn_prob))
				new[y][x] = fire;
		}
	}

	for_yx { univ[y][x] = new[y][x]; }
	//usleep(100000);
	goto show;
}

int main(int c, char **v)
{
	//srand(time(0));
	int w = 0, h = 0;

	if (c > 1) w = atoi(v[1]);
	if (c > 2) h = atoi(v[2]);
	if (w <= 0) w = 30;
	if (h <= 0) h = 30;

	evolve(w, h);
}
`,`#include "forest-fire-2.h"



void _evolve(uint param_1,uint param_2)

{
  uint uVar1;
  long lVar2;
  int iVar3;
  undefined8 auStack_c0 [2];
  undefined auStack_b0 [4];
  int local_ac;
  ulong local_a8;
  ulong local_a0;
  ulong local_98;
  undefined *local_90;
  ulong local_88;
  ulong local_80;
  ulong local_78;
  long local_70;
  int local_68;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  ulong local_38;
  ulong local_28;
  undefined *local_20;
  uint local_18;
  uint local_14;
  
  local_20 = auStack_b0;
  local_98 = (ulong)param_2;
  local_a8 = (ulong)param_1;
  local_a0 = local_98 * local_a8 * 4 + 0xf & 0xfffffffffffffff0;
  local_18 = param_2;
  local_14 = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  lVar2 = -local_a0;
  local_28 = local_98;
  local_78 = (ulong)local_18;
  local_88 = (ulong)local_14;
  local_80 = local_78 * local_88 * 4 + 0xf & 0xfffffffffffffff0;
  local_90 = auStack_b0 + lVar2;
  (*(code *)PTR____chkstk_darwin_100004000)();
  lVar2 = (long)(auStack_b0 + lVar2) - local_80;
  local_38 = local_78;
  local_70 = lVar2;
  for (local_44 = 0; local_44 < (int)local_18; local_44 = local_44 + 1) {
    for (local_48 = 0; local_48 < (int)local_14; local_48 = local_48 + 1) {
      iVar3 = _rand();
      uVar1 = (uint)((double)iVar3 < _tree_prob * 2147483647.0);
      *(uint *)(local_90 + (long)local_48 * 4 + (long)local_44 * local_a8 * 4) = uVar1;
      *(uint *)(local_70 + (long)local_44 * local_88 * 4 + (long)local_48 * 4) = uVar1;
    }
  }
  do {
    _printf("\x1b[H");
    for (local_4c = 0; local_4c < (int)local_18; local_4c = local_4c + 1) {
      for (local_50 = 0; local_50 < (int)local_14; local_50 = local_50 + 1) {
        *(undefined **)(lVar2 + -0x10) =
             (&_disp)[*(uint *)(local_90 + (long)local_50 * 4 + (long)local_4c * local_a8 * 4)];
        _printf("%s");
      }
      _printf("\x1b[E");
    }
    _fflush(*(FILE **)PTR____stdoutp_100004008);
    for (local_54 = 0; local_54 < (int)local_18; local_54 = local_54 + 1) {
      for (local_58 = 0; local_58 < (int)local_14; local_58 = local_58 + 1) {
        local_ac = *(int *)(local_90 + (long)local_58 * 4 + (long)local_54 * local_a8 * 4);
        if (local_ac == 0) {
          iVar3 = _rand();
          if ((double)iVar3 < _tree_prob * 2147483647.0) {
            *(undefined4 *)(local_70 + (long)local_54 * local_88 * 4 + (long)local_58 * 4) = 1;
          }
        }
        else if (local_ac == 2) {
          *(undefined4 *)(local_70 + (long)local_54 * local_88 * 4 + (long)local_58 * 4) = 0;
        }
        else {
          for (local_5c = local_54 + -1; local_5c <= local_54 + 1; local_5c = local_5c + 1) {
            if ((-1 < local_5c) && (local_5c < (int)local_18)) {
              for (local_60 = local_58 + -1; local_60 <= local_58 + 1; local_60 = local_60 + 1) {
                if (((-1 < local_60) && (local_60 < (int)local_14)) &&
                   (*(int *)(local_90 + (long)local_60 * 4 + (long)local_5c * local_a8 * 4) == 2)) {
                  *(undefined4 *)(local_70 + (long)local_54 * local_88 * 4 + (long)local_58 * 4) = 2
                  ;
                  goto LAB_100003d30;
                }
              }
            }
          }
LAB_100003d30:
          if ((*(int *)(local_70 + (long)local_54 * local_88 * 4 + (long)local_58 * 4) == 1) &&
             (iVar3 = _rand(), (double)iVar3 < _burn_prob * 2147483647.0)) {
            *(undefined4 *)(local_70 + (long)local_54 * local_88 * 4 + (long)local_58 * 4) = 2;
          }
        }
      }
    }
    for (local_64 = 0; local_64 < (int)local_18; local_64 = local_64 + 1) {
      for (local_68 = 0; local_68 < (int)local_14; local_68 = local_68 + 1) {
        *(undefined4 *)(local_90 + (long)local_68 * 4 + (long)local_64 * local_a8 * 4) =
             *(undefined4 *)(local_70 + (long)local_64 * local_88 * 4 + (long)local_68 * 4);
      }
    }
  } while( true );
}



undefined4 entry(int param_1,long param_2)

{
  undefined4 local_28;
  undefined4 local_24;
  
  local_24 = 0;
  local_28 = 0;
  if (1 < param_1) {
    local_24 = _atoi(*(char **)(param_2 + 8));
  }
  if (2 < param_1) {
    local_28 = _atoi(*(char **)(param_2 + 0x10));
  }
  if (local_24 < 1) {
    local_24 = 0x1e;
  }
  if (local_28 < 1) {
    local_28 = 0x1e;
  }
  _evolve(local_24,local_28);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004028)();
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/stat.h>

// Letter lookup by frequency.  This is to reduce word insertion time.
const char *freq = "zqxjkvbpygfwmucldrhsnioate";
int char_to_idx[128];

// Trie structure of sorts
struct word {
	const char *w;
	struct word *next;
};

union node {
	union node *down[10];
	struct word *list[10];
};

int deranged(const char *s1, const char *s2)
{
	int i;
	for (i = 0; s1[i]; i++)
		if (s1[i] == s2[i]) return 0;
	return 1;
}

int count_letters(const char *s, unsigned char *c)
{
	int i, len;
	memset(c, 0, 26);
	for (len = i = 0; s[i]; i++) {
		if (s[i] < 'a' || s[i] > 'z')
			return 0;
		len++, c[char_to_idx[(unsigned char)s[i]]]++;
	}
	return len;
}

const char * insert(union node *root, const char *s, unsigned char *cnt)
{
	int i;
	union node *n;
	struct word *v, *w = 0;

	for (i = 0; i < 25; i++, root = n) {
		if (!(n = root->down[cnt[i]]))
			root->down[cnt[i]] = n = calloc(1, sizeof(union node));
	}

	w = malloc(sizeof(struct word));
	w->w = s;
	w->next = root->list[cnt[25]];
	root->list[cnt[25]] = w;

	for (v = w->next; v; v = v->next) {
		if (deranged(w->w, v->w))
			return v->w;
	}
	return 0;
}

int main(int c, char **v)
{
	int i, j = 0;
	char *words;
	struct stat st;

	int fd = open(c < 2 ? "unixdict.txt" : v[1], O_RDONLY);
	if (fstat(fd, &st) < 0) return 1;

	words = malloc(st.st_size);
	read(fd, words, st.st_size);
	close(fd);

	union node root = {{0}};
	unsigned char cnt[26];
	int best_len = 0;
	const char *b1, *b2;

	for (i = 0; freq[i]; i++)
		char_to_idx[(unsigned char)freq[i]] = i;

	/* count words, change newline to null */
	for (i = j = 0; i < st.st_size; i++) {
		if (words[i] != '\n') continue;
		words[i] = '\0';

		if (i - j > best_len) {
			count_letters(words + j, cnt);
			const char *match = insert(&root, words + j, cnt);

			if (match) {
				best_len = i - j;
				b1 = words + j;
				b2 = match;
			}
		}

		j = ++i;
	}

	if (best_len) printf("longest derangement: %s %s\n", b1, b2);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003910(void);
int64_t function_1000039a0(void);
int64_t function_100003aa0(void);
int64_t function_100003edc(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003ee8(void);
int64_t * function_100003ef4(int32_t nmemb, int32_t size);
int32_t function_100003f00(int32_t fd);
int32_t function_100003f0c(int32_t fd, struct stat * buf);
int64_t * function_100003f18(int32_t size);
int64_t * function_100003f24(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f30(char * file, int32_t oflag, ...);
int32_t function_100003f3c(char * format, ...);
int32_t function_100003f48(int32_t fd, int64_t * buf, int32_t nbytes);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008008

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(void);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _close(int32_t a1);
int32_t _fstat(int32_t a1, struct stat * a2);
int64_t * _malloc(int32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003910 - 0x1000039a0
int64_t function_100003910(void) {
    // 0x100003910
    int64_t v1; // 0x100003910
    char v2 = *(char *)v1; // 0x100003930
    char v3 = v2; // 0x10000393c
    int64_t v4 = 0; // 0x10000393c
    if (v2 == 0) {
        // 0x100003994
        return 1;
    }
    int32_t v5 = 0; // 0x10000393c
    int64_t result = 0; // 0x100003964
    while (v3 != *(char *)(v4 + v1)) {
        // 0x100003924
        v5++;
        v4 = v5;
        v3 = *(char *)(v1 + v4);
        result = 1;
        if (v3 == 0) {
            // break -> 0x100003994
            break;
        }
        result = 0;
    }
    // 0x100003994
    return result;
}

// Address range: 0x1000039a0 - 0x100003aa0
int64_t function_1000039a0(void) {
    // 0x1000039a0
    int64_t v1; // 0x1000039a0
    ___memset_chk(v1, 0, 26, -1);
    char v2 = *(char *)v1; // 0x1000039e0
    char v3 = v2; // 0x1000039ec
    if (v2 == 0) {
        // 0x100003a90
        return 0;
    }
    int32_t v4 = 0; // 0x1000039ec
    int32_t v5 = v3; // 0x1000039fc
    int64_t result = 0; // 0x100003a08
    while (v3 < 97 == (96 - v5 & v5) < 0) {
        int32_t v6 = v5 - 122; // 0x100003a1c
        result = 0;
        if (v6 != 0 && v6 < 0 == (121 - v5 & v5) < 0) {
            // break -> 0x100003a90
            break;
        }
        // 0x100003a34
        v4++;
        int32_t v7 = *(int32_t *)(4 * (int64_t)v3 + (int64_t)&g1); // 0x100003a5c
        char * v8 = (char *)(v1 + (int64_t)v7); // 0x100003a64
        *v8 = *v8 + 1;
        v3 = *(char *)(v1 + (int64_t)v4);
        if (v3 == 0) {
            // 0x1000039d4
            result = v4;
            return result;
        }
        v5 = v3;
        result = 0;
    }
  lab_0x100003a90:
    // 0x100003a90
    return result;
}

// Address range: 0x100003aa0 - 0x100003c14
int64_t function_100003aa0(void) {
    int64_t v1 = 0;
    int64_t v2; // 0x100003aa0
    char * v3 = (char *)(v1 + v2); // 0x100003ae4
    int64_t v4; // 0x100003aa0
    int64_t v5 = *(int64_t *)(8 * (int64_t)*v3 + v4); // 0x100003ae8
    int64_t v6 = v5; // 0x100003afc
    if (v5 == 0) {
        // 0x100003b04
        v6 = (int64_t)_calloc(1, 80);
        *(int64_t *)(8 * (int64_t)*v3 + v4) = v6;
    }
    int64_t v7 = v6;
    v1++;
    while (v1 != 25) {
        int64_t v8 = v7;
        v3 = (char *)(v1 + v2);
        v5 = *(int64_t *)(8 * (int64_t)*v3 + v8);
        v6 = v5;
        if (v5 == 0) {
            // 0x100003b04
            v6 = (int64_t)_calloc(1, 80);
            *(int64_t *)(8 * (int64_t)*v3 + v8) = v6;
        }
        // 0x100003b34
        v7 = v6;
        v1++;
    }
    int64_t v9 = (int64_t)_malloc(16); // 0x100003b50
    char * v10 = (char *)(v2 + 25); // 0x100003b6c
    int64_t v11 = *(int64_t *)(8 * (int64_t)*v10 + v7); // 0x100003b70
    *(int64_t *)(v9 + 8) = v11;
    *(int64_t *)(8 * (int64_t)*v10 + v7) = v9;
    int64_t v12 = v9; // 0x100003b9c
    v12 += 8;
    int64_t result = 0; // 0x100003bac
    while (v12 != 0) {
        // 0x100003bb4
        if ((int32_t)function_100003910() != 0) {
            // 0x100003bd8
            result = *(int64_t *)v12;
            return result;
        }
        v12 += 8;
        result = 0;
    }
  lab_0x100003c04:
    // 0x100003c04
    return result;
}

// Address range: 0x100003c14 - 0x100003edc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c2c
    int64_t v2; // 0x100003c14
    int32_t v3 = v2; // 0x100003c38
    char * v4 = "unixdict.txt"; // 0x100003c50
    if (v3 < 2 == (1 - v3 & v3) < 0) {
        // 0x100003c68
        v4 = (char *)*(int64_t *)(v2 + 8);
    }
    int32_t v5 = _open(v4, 0); // 0x100003c80
    int64_t v6; // bp-248, 0x100003c14
    uint32_t v7 = _fstat(v5, (struct stat *)&v6); // 0x100003c90
    int64_t result = 1; // 0x100003c9c
    if (v7 >= 0) {
        // 0x100003cb0
        int32_t v8; // 0x100003c14
        int64_t * v9 = _malloc(v8); // 0x100003cb4
        _read(v5, v9, v8);
        _close(v5);
        int64_t v10; // bp-336, 0x100003c14
        _memset(&v10, 0, 80);
        char v11 = *(char *)0x3f54; // 0x100003d00
        int32_t v12 = 0; // 0x100003d0c
        if (v11 != 0) {
            *(int32_t *)(4 * (int64_t)v11 + (int64_t)&g1) = v12;
            int32_t v13 = v12 + 1; // 0x100003d40
            char v14 = *(char *)((int64_t)v13 + 0x3f54); // 0x100003d00
            v12 = v13;
            while (v14 != 0) {
                // 0x100003d14
                *(int32_t *)(4 * (int64_t)v14 + (int64_t)&g1) = v12;
                v13 = v12 + 1;
                v14 = *(char *)((int64_t)v13 + 0x3f54);
                v12 = v13;
            }
        }
        int64_t v15 = v8;
        result = 0;
        if (v8 > 0 != (-v15 & v15) < 0) {
            int64_t v16 = (int64_t)v9; // 0x100003cb4
            int32_t v17 = 0;
            int32_t v18 = 0;
            int64_t v19 = 0;
            int64_t v20 = 80;
            int32_t v21 = 0;
            char * v22 = (char *)v16; // 0x100003d78
            int32_t v23 = v18; // 0x100003d84
            int32_t v24 = v21; // 0x100003d84
            int64_t v25 = v19; // 0x100003d84
            int64_t v26 = v20; // 0x100003d84
            int32_t v27; // 0x100003c14
            int64_t v28; // bp-66, 0x100003c14
            int32_t v29; // 0x100003da8
            int32_t v30; // 0x100003db0
            int64_t v31; // 0x100003c14
            int64_t v32; // 0x100003c14
            if (*v22 == 10) {
                // 0x100003d90
                *v22 = 0;
                v29 = v21 - v17;
                v30 = v29 - v18;
                v27 = v18;
                v31 = v19;
                v32 = v20;
                if (v30 != 0 && v30 < 0 == ((v30 ^ v29) & (v29 ^ v18)) < 0) {
                    // 0x100003dc0
                    function_1000039a0();
                    v27 = function_100003aa0() == 0 ? v18 : v29;
                    v31 = (int64_t)v17 + v16;
                    v32 = &v28;
                }
                // 0x100003e38
                v24 = v21 + 1;
                v23 = v27;
                v25 = v31;
                v26 = v32;
            }
            int64_t v33 = v26;
            int64_t v34 = v25;
            int32_t v35 = v23;
            int32_t v36 = v24 + 1; // 0x100003e50
            int64_t v37 = v36; // 0x100003d58
            int64_t v38 = v37 - v15; // 0x100003d60
            while (v38 < 0 != ((v38 ^ v37) & (int64_t)(v36 ^ v8)) < 0) {
                // 0x100003d70
                v17 = v24;
                v18 = v35;
                v19 = v34;
                v20 = v33;
                v21 = v36;
                v22 = (char *)(v37 + v16);
                v23 = v18;
                v24 = v21;
                v25 = v19;
                v26 = v20;
                if (*v22 == 10) {
                    // 0x100003d90
                    *v22 = 0;
                    v29 = v21 - v17;
                    v30 = v29 - v18;
                    v27 = v18;
                    v31 = v19;
                    v32 = v20;
                    if (v30 != 0 && v30 < 0 == ((v30 ^ v29) & (v29 ^ v18)) < 0) {
                        // 0x100003dc0
                        function_1000039a0();
                        v27 = function_100003aa0() == 0 ? v18 : v29;
                        v31 = (int64_t)v17 + v16;
                        v32 = &v28;
                    }
                    // 0x100003e38
                    v24 = v21 + 1;
                    v23 = v27;
                    v25 = v31;
                    v26 = v32;
                }
                // 0x100003e4c
                v33 = v26;
                v34 = v25;
                v35 = v23;
                v36 = v24 + 1;
                v37 = v36;
                v38 = v37 - v15;
            }
            // 0x100003e5c
            result = 0;
            if (v35 != 0) {
                // 0x100003e70
                _printf("longest derangement: %s %s\n", (char *)v34, (char *)v33);
                result = 0;
            }
        }
    }
    // 0x100003e9c
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003ec4
        ___stack_chk_fail();
    }
    // 0x100003ec8
    return result;
}

// Address range: 0x100003edc - 0x100003ee8
int64_t function_100003edc(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003edc
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ee8 - 0x100003ef4
int64_t function_100003ee8(void) {
    // 0x100003ee8
    return ___stack_chk_fail();
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t * function_100003ef4(int32_t nmemb, int32_t size) {
    // 0x100003ef4
    return _calloc(nmemb, size);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(int32_t fd) {
    // 0x100003f00
    return _close(fd);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(int32_t fd, struct stat * buf) {
    // 0x100003f0c
    return _fstat(fd, buf);
}

// Address range: 0x100003f18 - 0x100003f24
int64_t * function_100003f18(int32_t size) {
    // 0x100003f18
    return _malloc(size);
}

// Address range: 0x100003f24 - 0x100003f30
int64_t * function_100003f24(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f24
    return _memset(s, c, n);
}

// Address range: 0x100003f30 - 0x100003f3c
int32_t function_100003f30(char * file, int32_t oflag, ...) {
    // 0x100003f30
    return _open(file, oflag);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x100003f48
    return _read(fd, buf, nbytes);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <limits.h>

#define DEBUG

void best_shuffle(const char* txt, char* result) {
    const size_t len = strlen(txt);
    if (len == 0)
        return;

#ifdef DEBUG
    // txt and result must have the same length
    assert(len == strlen(result));
#endif

    // how many of each character?
    size_t counts[UCHAR_MAX];
    memset(counts, '\0', UCHAR_MAX * sizeof(int));
    size_t fmax = 0;
    for (size_t i = 0; i < len; i++) {
        counts[(unsigned char)txt[i]]++;
        const size_t fnew = counts[(unsigned char)txt[i]];
        if (fmax < fnew)
             fmax = fnew;
    }
    assert(fmax > 0 && fmax <= len);

    // all character positions, grouped by character
    size_t *ndx1 = malloc(len * sizeof(size_t));
    if (ndx1 == NULL)
        exit(EXIT_FAILURE);
    for (size_t ch = 0, i = 0; ch < UCHAR_MAX; ch++)
       if (counts[ch])
            for (size_t j = 0; j < len; j++)
                if (ch == (unsigned char)txt[j]) {
                    ndx1[i] = j;
                    i++;
                }

    // regroup them for cycles
    size_t *ndx2 = malloc(len * sizeof(size_t));
    if (ndx2 == NULL)
        exit(EXIT_FAILURE);
    for (size_t i = 0, n = 0, m = 0; i < len; i++) {
        ndx2[i] = ndx1[n];
        n += fmax;
        if (n >= len) {
            m++;
            n = m;
        }
    }

    // how long can our cyclic groups be?
    const size_t grp = 1 + (len - 1) / fmax;
    assert(grp > 0 && grp <= len);

    // how many of them are full length?
    const size_t lng = 1 + (len - 1) % fmax;
    assert(lng > 0 && lng <= len);

    // rotate each group
    for (size_t i = 0, j = 0; i < fmax; i++) {
        const size_t first = ndx2[j];
        const size_t glen = grp - (i < lng ? 0 : 1);
        for (size_t k = 1; k < glen; k++)
            ndx1[j + k - 1] = ndx2[j + k];
        ndx1[j + glen - 1] = first;
        j += glen;
    }

    // result is original permuted according to our cyclic groups
    result[len] = '\0';
    for (size_t i = 0; i < len; i++)
        result[ndx2[i]] = txt[ndx1[i]];

    free(ndx1);
    free(ndx2);
}

void display(const char* txt1, const char* txt2) {
    const size_t len = strlen(txt1);
    assert(len == strlen(txt2));
    int score = 0;
    for (size_t i = 0; i < len; i++)
        if (txt1[i] == txt2[i])
            score++;
    (void)printf("%s, %s, (%u)\n", txt1, txt2, score);
}

int main() {
    const char* data[] = {"abracadabra", "seesaw", "elk", "grrrrrr",
                          "up", "a", "aabbbbaa", "", "xxxxx"};
    const size_t data_len = sizeof(data) / sizeof(data[0]);
    for (size_t i = 0; i < data_len; i++) {
        const size_t shuf_len = strlen(data[i]) + 1;
        char shuf[shuf_len];

#ifdef DEBUG
        memset(shuf, 0xFF, sizeof shuf);
        shuf[shuf_len - 1] = '\0';
#endif

        best_shuffle(data[i], shuf);
        display(data[i], shuf);
    }

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int64_t function_1000035a4(void);
int64_t function_100003bec(void);
int64_t function_100003e50(char * a1, char * a2, int64_t a3, char * a4);
int64_t function_100003e5c(void);
int64_t function_100003e68(int64_t a1);
void function_100003e74(int64_t * s, int32_t n);
void function_100003e80(int32_t status);
void function_100003e8c(int64_t * ptr);
int64_t * function_100003e98(int32_t size);
int64_t * function_100003ea4(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003eb0(char * format, ...);
int32_t function_100003ebc(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, char * a4);
int64_t ___chkstk_darwin(int64_t a1);
int64_t ___memset_chk(void);
int64_t ___stack_chk_fail(int64_t a1);
void _bzero(int64_t * a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000035a4 - 0x100003bec
int64_t function_1000035a4(void) {
    // 0x1000035a4
    int64_t v1; // 0x1000035a4
    int32_t v2 = _strlen((char *)v1); // 0x1000035d0
    int64_t v3 = 0; // 0x1000035e4
    uint64_t v4; // 0x1000035a4
    uint64_t v5; // 0x1000035d0
    int64_t v6; // 0x100003684
    if (v2 == 0) {
        goto lab_0x100003bb8;
    } else {
        // 0x1000035f0
        if (v2 != _strlen((char *)v1)) {
            // 0x100003620
            ___assert_rtn("best_shuffle", "best-shuffle-1.c", 16, "len == strlen(result)");
        }
        // 0x100003674
        v5 = (int64_t)v2;
        int64_t v7; // bp-2072, 0x1000035a4
        _bzero(&v7, 1020);
        v6 = &v7;
        int64_t v8 = 0; // 0x1000036dc
        uint64_t v9 = 0;
        char * v10 = (char *)(v8 + v1); // 0x10000367c
        int64_t * v11 = (int64_t *)(8 * (int64_t)*v10 + v6); // 0x100003690
        *v11 = *v11 + 1;
        uint64_t v12 = *(int64_t *)(8 * (int64_t)*v10 + v6); // 0x1000036a8
        v4 = v9 < v12 ? v12 : v9;
        v8++;
        while (v8 < v5) {
            // 0x100003674
            v9 = v4;
            v10 = (char *)(v8 + v1);
            v11 = (int64_t *)(8 * (int64_t)*v10 + v6);
            *v11 = *v11 + 1;
            v12 = *(int64_t *)(8 * (int64_t)*v10 + v6);
            v4 = v9 < v12 ? v12 : v9;
            v8++;
        }
        if (v4 == 0) {
            // 0x100003738
            ___assert_rtn("best_shuffle", "best-shuffle-1.c", 29, "fmax > 0 && fmax <= len");
            goto lab_0x10000375c;
        } else {
            if (v4 != v5 && v4 >= v5) {
                // 0x100003738
                ___assert_rtn("best_shuffle", "best-shuffle-1.c", 29, "fmax > 0 && fmax <= len");
                goto lab_0x10000375c;
            } else {
                goto lab_0x10000375c;
            }
        }
    }
  lab_0x100003bb8:;
    int64_t v13 = *(int64_t *)*(int64_t *)0x100004020; // 0x100003bc4
    int64_t result = v3; // 0x100003bd0
    if (v13 != *(int64_t *)*(int64_t *)0x100004020) {
        // 0x100003bd8
        result = ___stack_chk_fail(v3);
    }
    // 0x100003bdc
    return result;
  lab_0x10000375c:;
    int32_t v14 = 8 * v2; // 0x100003764
    int64_t * v15 = _malloc(v14); // 0x100003764
    int64_t v16 = (int64_t)v15; // 0x100003764
    int64_t v17 = 0; // 0x100003778
    if (v15 == NULL) {
        // 0x100003780
        _exit(1);
        // UNREACHABLE
    }
    int64_t v18 = 0;
    int64_t v19 = v17; // 0x1000037bc
    int64_t v20 = v17; // 0x1000037bc
    int64_t v21; // 0x1000035a4
    int64_t v22; // 0x1000035a4
    int64_t v23; // 0x1000035a4
    int64_t v24; // 0x10000382c
    if (*(int64_t *)(8 * v18 + v6) != 0) {
        v21 = v19;
        v23 = 0;
        v22 = v21;
        if (v18 == (int64_t)*(char *)(v23 + v1)) {
            // 0x100003804
            *(int64_t *)(8 * v21 + v16) = v23;
            v22 = v21 + 1;
        }
        // 0x100003828
        v24 = v23 + 1;
        v20 = v22;
        while (v24 < v5) {
            // 0x1000037e4
            v21 = v22;
            v23 = v24;
            v22 = v21;
            if (v18 == (int64_t)*(char *)(v23 + v1)) {
                // 0x100003804
                *(int64_t *)(8 * v21 + v16) = v23;
                v22 = v21 + 1;
            }
            // 0x100003828
            v24 = v23 + 1;
            v20 = v22;
        }
    }
    int64_t v25 = v18 + 1; // 0x100003844
    v17 = v20;
    while (v25 != 255) {
        // 0x1000037a8
        v18 = v25;
        v19 = v17;
        v20 = v17;
        if (*(int64_t *)(8 * v18 + v6) != 0) {
            v21 = v19;
            v23 = 0;
            v22 = v21;
            if (v18 == (int64_t)*(char *)(v23 + v1)) {
                // 0x100003804
                *(int64_t *)(8 * v21 + v16) = v23;
                v22 = v21 + 1;
            }
            // 0x100003828
            v24 = v23 + 1;
            v20 = v22;
            while (v24 < v5) {
                // 0x1000037e4
                v21 = v22;
                v23 = v24;
                v22 = v21;
                if (v18 == (int64_t)*(char *)(v23 + v1)) {
                    // 0x100003804
                    *(int64_t *)(8 * v21 + v16) = v23;
                    v22 = v21 + 1;
                }
                // 0x100003828
                v24 = v23 + 1;
                v20 = v22;
            }
        }
        // 0x100003840
        v25 = v18 + 1;
        v17 = v20;
    }
    int64_t * v26 = _malloc(v14); // 0x100003858
    int64_t v27 = (int64_t)v26; // 0x100003858
    int64_t v28 = 0; // 0x10000386c
    int64_t v29 = 0; // 0x10000386c
    int64_t v30 = 0; // 0x10000386c
    if (v26 == NULL) {
        // 0x100003874
        _exit(1);
        // UNREACHABLE
    }
    int64_t v31 = *(int64_t *)(8 * v29 + v16); // 0x1000038ac
    *(int64_t *)(8 * v30 + v27) = v31;
    uint64_t v32 = v29 + v4; // 0x1000038c4
    int64_t v33 = v28 + 1;
    int64_t v34 = v30 + 1; // 0x100003904
    v28 = v32 < v5 ? v28 : v33;
    v29 = v32 < v5 ? v32 : v33;
    v30 = v34;
    while (v34 < v5) {
        // 0x1000038a4
        v31 = *(int64_t *)(8 * v29 + v16);
        *(int64_t *)(8 * v30 + v27) = v31;
        v32 = v29 + v4;
        v33 = v28 + 1;
        v34 = v30 + 1;
        v28 = v32 < v5 ? v28 : v33;
        v29 = v32 < v5 ? v32 : v33;
        v30 = v34;
    }
    uint64_t v35 = v5 - 1; // 0x100003914
    uint64_t v36 = v35 / v4 + 1; // 0x100003920
    if (v36 == 0) {
        // 0x100003978
        ___assert_rtn("best_shuffle", "best-shuffle-1.c", 58, "grp > 0 && grp <= len");
        goto lab_0x10000399c;
    } else {
        if (v36 != v5 && v36 >= v5) {
            // 0x100003978
            ___assert_rtn("best_shuffle", "best-shuffle-1.c", 58, "grp > 0 && grp <= len");
            goto lab_0x10000399c;
        } else {
            goto lab_0x10000399c;
        }
    }
  lab_0x10000399c:;
    uint64_t v37 = v35 % v4 + 1; // 0x1000039b4
    if (v37 == 0) {
        // 0x100003a0c
        ___assert_rtn("best_shuffle", "best-shuffle-1.c", 62, "lng > 0 && lng <= len");
        goto lab_0x100003a30;
    } else {
        if (v37 != v5 && v37 >= v5) {
            // 0x100003a0c
            ___assert_rtn("best_shuffle", "best-shuffle-1.c", 62, "lng > 0 && lng <= len");
            goto lab_0x100003a30;
        } else {
            goto lab_0x100003a30;
        }
    }
  lab_0x100003a30:
    if (v4 != 0) {
        int64_t v38 = v16 - 8;
        int64_t v39 = 0; // 0x100003b24
        int64_t v40 = 0;
        int64_t v41 = *(int64_t *)(8 * v40 + v27); // 0x100003a5c
        uint64_t v42 = v36 - (int64_t)(v39 >= v37); // 0x100003a84
        int64_t v43 = 1; // 0x100003aa8
        int64_t v44; // 0x100003ac0
        int64_t v45; // 0x100003ae4
        if (v42 > 1) {
            v44 = 8 * (v43 + v40);
            *(int64_t *)(v44 + v38) = *(int64_t *)(v44 + v27);
            v45 = v43 + 1;
            v43 = v45;
            while (v45 != v42) {
                // 0x100003ab0
                v44 = 8 * (v43 + v40);
                *(int64_t *)(v44 + v38) = *(int64_t *)(v44 + v27);
                v45 = v43 + 1;
                v43 = v45;
            }
        }
        int64_t v46 = v42 + v40; // 0x100003b00
        *(int64_t *)(8 * v46 + v38) = v41;
        v39++;
        while (v39 != v4) {
            // 0x100003a54
            v40 = v46;
            v41 = *(int64_t *)(8 * v40 + v27);
            v42 = v36 - (int64_t)(v39 >= v37);
            v43 = 1;
            if (v42 > 1) {
                v44 = 8 * (v43 + v40);
                *(int64_t *)(v44 + v38) = *(int64_t *)(v44 + v27);
                v45 = v43 + 1;
                v43 = v45;
                while (v45 != v42) {
                    // 0x100003ab0
                    v44 = 8 * (v43 + v40);
                    *(int64_t *)(v44 + v38) = *(int64_t *)(v44 + v27);
                    v45 = v43 + 1;
                    v43 = v45;
                }
            }
            // 0x100003af0
            v46 = v42 + v40;
            *(int64_t *)(8 * v46 + v38) = v41;
            v39++;
        }
    }
    // 0x100003b60
    *(char *)(v1 + v5) = 0;
    int64_t v47 = 0; // 0x1000035a4
    int64_t v48 = 8 * v47; // 0x100003b6c
    char v49 = *(char *)(*(int64_t *)(v48 + v16) + v1); // 0x100003b74
    *(char *)(*(int64_t *)(v48 + v27) + v1) = v49;
    int64_t v50 = v47 + 1; // 0x100003b98
    v47 = v50;
    while (v50 < v5) {
        // 0x100003b60
        v48 = 8 * v47;
        v49 = *(char *)(*(int64_t *)(v48 + v16) + v1);
        *(char *)(*(int64_t *)(v48 + v27) + v1) = v49;
        v50 = v47 + 1;
        v47 = v50;
    }
    // 0x100003ba4
    _free(v15);
    _free(v26);
    v3 = &g1;
    goto lab_0x100003bb8;
}

// Address range: 0x100003bec - 0x100003d08
int64_t function_100003bec(void) {
    // 0x100003bec
    int64_t v1; // 0x100003bec
    int64_t v2; // 0x100003bec
    int64_t v3; // 0x100003bec
    int64_t v4; // 0x100003bec
    if (_strlen((char *)v1) != _strlen((char *)v1)) {
        // 0x100003c3c
        ___assert_rtn("display", "best-shuffle-1.c", 85, "len == strlen(txt2)");
        v2 = (int64_t)"best-shuffle-1.c";
        v3 = 85;
        v4 = (int64_t)"len == strlen(txt2)";
    }
    // 0x100003c60
    return _printf("%s, %s, (%u)\n", (char *)v2, (char *)v3, (int32_t)v4);
}

// Address range: 0x100003d08 - 0x100003e50
int64_t entry_point(int64_t a1) {
    // 0x100003d08
    int64_t v1; // bp-88, 0x100003d08
    _memcpy(&v1, (int64_t *)"j?", 72);
    return ___chkstk_darwin((int64_t)_strlen((char *)v1));
}

// Address range: 0x100003e50 - 0x100003e5c
int64_t function_100003e50(char * a1, char * a2, int64_t a3, char * a4) {
    // 0x100003e50
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003e5c - 0x100003e68
int64_t function_100003e5c(void) {
    // 0x100003e5c
    return ___memset_chk();
}

// Address range: 0x100003e68 - 0x100003e74
int64_t function_100003e68(int64_t a1) {
    // 0x100003e68
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e74 - 0x100003e80
void function_100003e74(int64_t * s, int32_t n) {
    // 0x100003e74
    _bzero(s, n);
}

// Address range: 0x100003e80 - 0x100003e8c
void function_100003e80(int32_t status) {
    // 0x100003e80
    _exit(status);
}

// Address range: 0x100003e8c - 0x100003e98
void function_100003e8c(int64_t * ptr) {
    // 0x100003e8c
    _free(ptr);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int32_t size) {
    // 0x100003e98
    return _malloc(size);
}

// Address range: 0x100003ea4 - 0x100003eb0
int64_t * function_100003ea4(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003ea4
    return _memcpy(dest, src, n);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(char * format, ...) {
    // 0x100003eb0
    return _printf(format);
}

// Address range: 0x100003ebc - 0x100003ec8
int32_t function_100003ebc(char * s) {
    // 0x100003ebc
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double *cholesky(double *A, int n) {
    double *L = (double*)calloc(n * n, sizeof(double));
    if (L == NULL)
        exit(EXIT_FAILURE);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < (i+1); j++) {
            double s = 0;
            for (int k = 0; k < j; k++)
                s += L[i * n + k] * L[j * n + k];
            L[i * n + j] = (i == j) ?
                           sqrt(A[i * n + i] - s) :
                           (1.0 / L[j * n + j] * (A[i * n + j] - s));
        }

    return L;
}

void show_matrix(double *A, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            printf("%2.5f ", A[i * n + j]);
        printf("\n");
    }
}

int main() {
    int n = 3;
    double m1[] = {25, 15, -5,
                   15, 18,  0,
                   -5,  0, 11};
    double *c1 = cholesky(m1, n);
    show_matrix(c1, n);
    printf("\n");
    free(c1);

    n = 4;
    double m2[] = {18, 22,  54,  42,
                   22, 70,  86,  62,
                   54, 86, 174, 134,
                   42, 62, 134, 106};
    double *c2 = cholesky(m2, n);
    show_matrix(c2, n);
    free(c2);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ac8(void);
int64_t function_100003cd0(void);
int64_t function_100003e84(int64_t a1);
int64_t * function_100003e90(int32_t nmemb, int32_t size);
void function_100003e9c(int32_t status);
void function_100003ea8(int64_t * ptr);
int64_t * function_100003eb4(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003ec0(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4039000000000000; // 0x100003ed8
int64_t g2 = 0x4032000000000000; // 0x100003f20
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ac8 - 0x100003cd0
int64_t function_100003ac8(void) {
    // 0x100003ac8
    int64_t v1; // 0x100003ac8
    int32_t v2 = v1; // 0x100003ad8
    int64_t * v3 = _calloc(v2 * v2, 8); // 0x100003af4
    if (v3 == NULL) {
        // 0x100003b10
        _exit(1);
        // UNREACHABLE
    }
    int64_t result = (int64_t)v3; // 0x100003af4
    int32_t v4 = -v2; // 0x100003b28
    if (v4 < 0 == (v4 & v2) < 0) {
        // 0x100003cc0
        return result;
    }
    int32_t v5 = 0;
    int32_t v6 = v5 + 1; // 0x100003b48
    int64_t v7; // 0x100003ac8
    float64_t v8; // 0x100003ac8
    float64_t v9; // 0x100003ac8
    int32_t v10; // 0x100003ac8
    float64_t v11; // 0x100003ac8
    int32_t v12; // 0x100003ac8
    int64_t v13; // 0x100003ac8
    float64_t * v14; // 0x100003ac8
    int32_t v15; // 0x100003b74
    float64_t v16; // 0x100003c3c
    int64_t v17; // 0x100003ac8
    float64_t v18; // 0x100003bb8
    float64_t v19; // 0x100003bc0
    int32_t v20; // 0x100003bd0
    int32_t v21; // 0x100003b74
    int32_t v22; // 0x100003ca0
    if (v5 > -1 != (v6 & -v5) < 0) {
        // 0x100003b6c
        v12 = v5 * v2;
        v13 = 8 * (v12 + v5);
        v14 = (float64_t *)(v1 + v13);
        v10 = 0;
        v15 = -v10;
        v8 = 0.0;
        if (v15 < 0 != (v10 & v15) < 0) {
            // 0x100003b84
            v20 = 0;
            v19 = 0.0;
            v18 = *(float64_t *)((int64_t)(8 * (v20 + v10 * v2)) + result);
            v19 += *(float64_t *)((int64_t)(8 * (v20 + v12)) + result) * v18;
            v20++;
            v21 = v20 - v10;
            v8 = v19;
            while (v21 < 0 != ((v21 ^ v20) & (v20 ^ v10)) < 0) {
                // 0x100003b84
                v18 = *(float64_t *)((int64_t)(8 * (v20 + v10 * v2)) + result);
                v19 += *(float64_t *)((int64_t)(8 * (v20 + v12)) + result) * v18;
                v20++;
                v21 = v20 - v10;
                v8 = v19;
            }
        }
        // 0x100003bdc
        v9 = v8;
        if (v5 == v10) {
            // 0x100003bf4
            v7 = v13;
            v11 = sqrt(*v14 - v9);
        } else {
            // 0x100003c24
            v16 = *(float64_t *)((int64_t)(8 * (v10 * v2 + v10)) + result);
            v17 = 8 * (v10 + v12);
            v7 = v17;
            v11 = 1.0 / v16 * (*(float64_t *)(v1 + v17) - v9);
        }
        // 0x100003c78
        *(int64_t *)(v7 + result) = (int64_t)v11;
        v22 = v10 + 1;
        while (v22 - v6 < 0 != ((v22 - v6 ^ v22) & (v22 ^ v6)) < 0) {
            // 0x100003b6c
            v10 = v22;
            v15 = -v10;
            v8 = 0.0;
            if (v15 < 0 != (v10 & v15) < 0) {
                // 0x100003b84
                v20 = 0;
                v19 = 0.0;
                v18 = *(float64_t *)((int64_t)(8 * (v20 + v10 * v2)) + result);
                v19 += *(float64_t *)((int64_t)(8 * (v20 + v12)) + result) * v18;
                v20++;
                v21 = v20 - v10;
                v8 = v19;
                while (v21 < 0 != ((v21 ^ v20) & (v20 ^ v10)) < 0) {
                    // 0x100003b84
                    v18 = *(float64_t *)((int64_t)(8 * (v20 + v10 * v2)) + result);
                    v19 += *(float64_t *)((int64_t)(8 * (v20 + v12)) + result) * v18;
                    v20++;
                    v21 = v20 - v10;
                    v8 = v19;
                }
            }
            // 0x100003bdc
            v9 = v8;
            if (v5 == v10) {
                // 0x100003bf4
                v7 = v13;
                v11 = sqrt(*v14 - v9);
            } else {
                // 0x100003c24
                v16 = *(float64_t *)((int64_t)(8 * (v10 * v2 + v10)) + result);
                v17 = 8 * (v10 + v12);
                v7 = v17;
                v11 = 1.0 / v16 * (*(float64_t *)(v1 + v17) - v9);
            }
            // 0x100003c78
            *(int64_t *)(v7 + result) = (int64_t)v11;
            v22 = v10 + 1;
        }
    }
    while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
        // 0x100003b20
        v5 = v6;
        v6 = v5 + 1;
        if (v5 > -1 != (v6 & -v5) < 0) {
            // 0x100003b6c
            v12 = v5 * v2;
            v13 = 8 * (v12 + v5);
            v14 = (float64_t *)(v1 + v13);
            v10 = 0;
            v15 = -v10;
            v8 = 0.0;
            if (v15 < 0 != (v10 & v15) < 0) {
                // 0x100003b84
                v20 = 0;
                v19 = 0.0;
                v18 = *(float64_t *)((int64_t)(8 * (v20 + v10 * v2)) + result);
                v19 += *(float64_t *)((int64_t)(8 * (v20 + v12)) + result) * v18;
                v20++;
                v21 = v20 - v10;
                v8 = v19;
                while (v21 < 0 != ((v21 ^ v20) & (v20 ^ v10)) < 0) {
                    // 0x100003b84
                    v18 = *(float64_t *)((int64_t)(8 * (v20 + v10 * v2)) + result);
                    v19 += *(float64_t *)((int64_t)(8 * (v20 + v12)) + result) * v18;
                    v20++;
                    v21 = v20 - v10;
                    v8 = v19;
                }
            }
            // 0x100003bdc
            v9 = v8;
            if (v5 == v10) {
                // 0x100003bf4
                v7 = v13;
                v11 = sqrt(*v14 - v9);
            } else {
                // 0x100003c24
                v16 = *(float64_t *)((int64_t)(8 * (v10 * v2 + v10)) + result);
                v17 = 8 * (v10 + v12);
                v7 = v17;
                v11 = 1.0 / v16 * (*(float64_t *)(v1 + v17) - v9);
            }
            // 0x100003c78
            *(int64_t *)(v7 + result) = (int64_t)v11;
            v22 = v10 + 1;
            while (v22 - v6 < 0 != ((v22 - v6 ^ v22) & (v22 ^ v6)) < 0) {
                // 0x100003b6c
                v10 = v22;
                v15 = -v10;
                v8 = 0.0;
                if (v15 < 0 != (v10 & v15) < 0) {
                    // 0x100003b84
                    v20 = 0;
                    v19 = 0.0;
                    v18 = *(float64_t *)((int64_t)(8 * (v20 + v10 * v2)) + result);
                    v19 += *(float64_t *)((int64_t)(8 * (v20 + v12)) + result) * v18;
                    v20++;
                    v21 = v20 - v10;
                    v8 = v19;
                    while (v21 < 0 != ((v21 ^ v20) & (v20 ^ v10)) < 0) {
                        // 0x100003b84
                        v18 = *(float64_t *)((int64_t)(8 * (v20 + v10 * v2)) + result);
                        v19 += *(float64_t *)((int64_t)(8 * (v20 + v12)) + result) * v18;
                        v20++;
                        v21 = v20 - v10;
                        v8 = v19;
                    }
                }
                // 0x100003bdc
                v9 = v8;
                if (v5 == v10) {
                    // 0x100003bf4
                    v7 = v13;
                    v11 = sqrt(*v14 - v9);
                } else {
                    // 0x100003c24
                    v16 = *(float64_t *)((int64_t)(8 * (v10 * v2 + v10)) + result);
                    v17 = 8 * (v10 + v12);
                    v7 = v17;
                    v11 = 1.0 / v16 * (*(float64_t *)(v1 + v17) - v9);
                }
                // 0x100003c78
                *(int64_t *)(v7 + result) = (int64_t)v11;
                v22 = v10 + 1;
            }
        }
    }
    // 0x100003cc0
    return result;
}

// Address range: 0x100003cd0 - 0x100003d94
int64_t function_100003cd0(void) {
    // 0x100003cd0
    int64_t v1; // 0x100003cd0
    int32_t v2 = v1; // 0x100003ce0
    int32_t v3 = -v2;
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003d88
        int64_t result; // 0x100003cd0
        return result;
    }
    int32_t v4 = 0; // 0x100003d7c
    int32_t v5 = 0; // 0x100003d5c
    int128_t v6; // 0x100003cd0
    _printf("%2.5f ", (float64_t)(int64_t)v6);
    v5++;
    while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003d24
        _printf("%2.5f ", (float64_t)(int64_t)v6);
        v5++;
    }
    int32_t result2 = _printf((char *)0x100003ed3); // 0x100003d70
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003d24
        v5 = 0;
        _printf("%2.5f ", (float64_t)(int64_t)v6);
        v5++;
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003d24
            _printf("%2.5f ", (float64_t)(int64_t)v6);
            v5++;
        }
        // 0x100003d68
        result2 = _printf((char *)0x100003ed3);
        v4++;
    }
    // 0x100003d88
    return result2;
}

// Address range: 0x100003d94 - 0x100003e84
int64_t entry_point(void) {
    // 0x100003d94
    int64_t v1; // bp-112, 0x100003d94
    _memcpy(&v1, &g1, 72);
    int64_t v2 = function_100003ac8(); // 0x100003de0
    function_100003cd0();
    _printf("\n");
    _free((int64_t *)v2);
    int64_t v3; // bp-240, 0x100003d94
    _memcpy(&v3, &g2, 128);
    int64_t v4 = function_100003ac8(); // 0x100003e30
    function_100003cd0();
    _free((int64_t *)v4);
    int64_t v5 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e58
    if (v5 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003e6c
        ___stack_chk_fail((int64_t)&g3);
    }
    // 0x100003e70
    return 0;
}

// Address range: 0x100003e84 - 0x100003e90
int64_t function_100003e84(int64_t a1) {
    // 0x100003e84
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003e90 - 0x100003e9c
int64_t * function_100003e90(int32_t nmemb, int32_t size) {
    // 0x100003e90
    return _calloc(nmemb, size);
}

// Address range: 0x100003e9c - 0x100003ea8
void function_100003e9c(int32_t status) {
    // 0x100003e9c
    _exit(status);
}

// Address range: 0x100003ea8 - 0x100003eb4
void function_100003ea8(int64_t * ptr) {
    // 0x100003ea8
    _free(ptr);
}

// Address range: 0x100003eb4 - 0x100003ec0
int64_t * function_100003eb4(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003eb4
    return _memcpy(dest, src, n);
}

// Address range: 0x100003ec0 - 0x100003ecc
int32_t function_100003ec0(char * format, ...) {
    // 0x100003ec0
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`//FormAI DATASET v1.0 Category: Huffman Coding Implementation ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE 256

struct node {
  int freq;
  char symbol;
  struct node *left;
  struct node *right;
};

struct queue {
  int size;
  int front;
  int rear;
  struct node **array;
};

struct node *new_node(int freq, char symbol) {
  struct node *node = malloc(sizeof(struct node));

  node->freq = freq;
  node->symbol = symbol;
  node->left = NULL;
  node->right = NULL;

  return node;
}

struct queue *create_queue(int size) {
  struct queue *queue = malloc(sizeof(struct queue));

  queue->size = size;
  queue->front = 0;
  queue->rear = -1;
  queue->array = malloc(size * sizeof(struct node *));

  return queue;
}

int is_full(struct queue *queue){
  return queue->rear == queue->size - 1;
}

int is_empty(struct queue *queue) {
  return queue->front == queue->rear + 1;
}

void enqueue(struct queue *queue, struct node *node) {
  if (is_full(queue)) {
    return;
  }

  queue->rear++;
  queue->array[queue->rear] = node;
}

struct node *dequeue(struct queue *queue) {
  if (is_empty(queue)) {
    return NULL;
  }

  struct node *node = queue->array[queue->front];
  queue->front++;

  return node;
}

void print_array(int *array, int n) {
  for (int i = 0; i < n; i++) {
    printf("%d", array[i]);
  }
  printf("\n");
}

void print_codes(struct node *root, int *array, int top) {
  if (root->left) {
    array[top] = 0;
    print_codes(root->left, array, top + 1);
  }

  if (root->right) {
    array[top] = 1;
    print_codes(root->right, array, top + 1);
  }

  if (!root->left && !root->right) {
    printf("%c:", root->symbol);
    print_array(array, top);
  }
}

void huffman_coding(int *freq, char *symbols, int size) {
  struct node *left;
  struct node *right;
  struct node *top;
  struct queue *queue = create_queue(size);

  for (int i = 0; i < size; i++) {
    enqueue(queue, new_node(freq[i], symbols[i]));
  }

  while (!is_empty(queue)) {
    left = dequeue(queue);
    right = dequeue(queue);

    top = new_node(left->freq + right->freq, '-');
    top->left = left;
    top->right = right;

    enqueue(queue, top);
  }

  int array[SIZE] = { 0 };
  print_codes(top, array, 0);
}

int main() {
  int freq[SIZE] = { 6, 13, 7, 21, 14, 1, 2, 5, 12, 3 };
  char symbols[SIZE] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' };

  huffman_coding(freq, symbols, SIZE);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall huffman_coding(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A0B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[32]; // [rsp+20h] [rbp-60h] BYREF
  int v5[260]; // [rsp+120h] [rbp+A0h] BYREF

  _main(argc, argv, envp);
  memset(v5, 0, 0x400ui64);
  v5[0] = 6;
  v5[1] = 13;
  v5[2] = 7;
  v5[3] = 21;
  v5[4] = 14;
  v5[5] = 1;
  v5[6] = 2;
  v5[7] = 5;
  v5[8] = 12;
  v5[9] = 3;
  v4[0] = 0x6867666564636261i64;
  v4[1] = 27241i64;
  memset(&v4[2], 0, 240);
  huffman_coding(v5, v4, 256i64);
  return 0;
}
// 140001881: using guessed type __int64 __fastcall huffman_coding(_QWORD, _QWORD, _QWORD);
// 140001C90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#define F(x,y) printf("%s",i%x?"":#y"zz")
int main(int i){for(--i;i++^100;puts(""))F(3,Fi)|F(5,Bu)||printf("%i",i);return 0;}
`,`#include "fizzbuzz-8.h"



undefined8 entry(int param_1)

{
  int iVar1;
  int iVar2;
  int local_18;
  
  local_18 = param_1 + -1;
  while (local_18 != 100) {
    iVar1 = _printf("%s");
    iVar2 = _printf("%s");
    if (iVar1 == 0 && iVar2 == 0) {
      _printf("%i");
    }
    _puts("");
    local_18 = local_18 + 1;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* x, y: coordinates of current point; dx, dy: direction of movement.
 * Think turtle graphics.  They are divided by scale, so as to keep
 * very small coords/increments without losing precission. clen is
 * the path length travelled, which should equal to scale at the end
 * of the curve.
 */
long long x, y, dx, dy, scale, clen;
typedef struct { double r, g, b; } rgb;
rgb ** pix;

/* for every depth increase, rotate 45 degrees and scale up by sqrt(2)
 * Note how coords can still be represented by integers.
 */
void sc_up()
{
	long long tmp = dx - dy; dy = dx + dy; dx = tmp;
	scale *= 2; x *= 2; y *= 2;
}

/* Hue changes from 0 to 360 degrees over entire length of path; Value
 * oscillates along the path to give some contrast between segments
 * close to each other spatially.  RGB derived from HSV gets *added*
 * to each pixel reached; they'll be dealt with later.
 */
void h_rgb(long long x, long long y)
{
	rgb *p = &pix[y][x];

#	define SAT 1
	double h = 6.0 * clen / scale;
	double VAL = 1 - (cos(3.141592653579 * 64 * clen / scale) - 1) / 4;
	double c = SAT * VAL;
	double X = c * (1 - fabs(fmod(h, 2) - 1));

	switch((int)h) {
	case 0: p->r += c; p->g += X; return;
	case 1:	p->r += X; p->g += c; return;
	case 2: p->g += c; p->b += X; return;
	case 3: p->g += X; p->b += c; return;
	case 4: p->r += X; p->b += c; return;
	default:
		p->r += c; p->b += X;
	}
}

/* string rewriting.  No need to keep the string itself, just execute
 * its instruction recursively.
 */
void iter_string(const char * str, int d)
{
	long tmp;
#	define LEFT  tmp = -dy; dy = dx; dx = tmp
#	define RIGHT tmp = dy; dy = -dx; dx = tmp
	while (*str != '\0') {
		switch(*(str++)) {
		case 'X':	if (d) iter_string("X+YF+", d - 1); continue;
		case 'Y':	if (d) iter_string("-FX-Y", d - 1); continue;
		case '+':	RIGHT; continue;
		case '-':	LEFT;  continue;
		case 'F':
                        /* draw: increment path length; add color; move. Here
                         * is why the code does not allow user to choose arbitrary
                         * image size: if it's not a power of two, aliasing will
                         * occur and grid-like bright or dark lines will result
                         * when normalized later.  It can be gotten rid of, but that
                         * involves computing multiplicative order and would be a huge
                         * bore.
                         */
				clen ++;
				h_rgb(x/scale, y/scale);
				x += dx; y += dy;
				continue;
		}
	}
}

void dragon(long leng, int depth)
{
	long i, d = leng / 3 + 1;
	long h = leng + 3, w = leng + d * 3 / 2 + 2;

	/* allocate pixel buffer */
	rgb *buf = malloc(sizeof(rgb) * w * h);
	pix = malloc(sizeof(rgb *) * h);
	for (i = 0; i < h; i++)
		pix[i] = buf + w * i;
	memset(buf, 0, sizeof(rgb) * w * h);

        /* init coords; scale up to desired; exec string */
	x = y = d; dx = leng; dy = 0; scale = 1; clen = 0;
	for (i = 0; i < depth; i++) sc_up();
	iter_string("FX", depth);

	/* write color PNM file */
	unsigned char *fpix = malloc(w * h * 3);
	double maxv = 0, *dbuf = (double*)buf;

        /* find highest value among pixels; normalize image according
         * to it.  Highest value would be at points most travelled, so
         * this ends up giving curve edge a nice fade -- it's more apparaent
         * if we increase iteration depth by one or two.
         */
	for (i = 3 * w * h - 1; i >= 0; i--)
		if (dbuf[i] > maxv) maxv = dbuf[i];
	for (i = 3 * h * w - 1; i >= 0; i--)
		fpix[i] = 255 * dbuf[i] / maxv;

	printf("P6\n%ld %ld\n255\n", w, h);
	fflush(stdout); /* printf and fwrite may treat buffer differently */
	fwrite(fpix, h * w * 3, 1, stdout);
}

int main(int c, char ** v)
{
	int size, depth;

	depth  = (c > 1) ? atoi(v[1]) : 10;
	size = 1 << depth;

	fprintf(stderr, "size: %d depth: %d\n", size, depth);
	dragon(size, depth * 2);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003584(void);
int64_t function_100003604(int64_t a1, int64_t a2);
int64_t function_100003854(void);
int64_t function_100003ae8(void);
int64_t function_100003edc(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t function_100003ee8(char * nptr);
float64_t function_100003ef4(float64_t a1);
int32_t function_100003f00(struct _IO_FILE * stream);
float64_t function_100003f0c(float64_t a1, float64_t a2);
int32_t function_100003f18(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f24(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t * function_100003f30(int32_t size);
int32_t function_100003f3c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x406921fb5443ce28; // 0x100003f48
float64_t g2 = 255.0; // 0x100003f50
float64_t g3 = 7.2912123841084054e-304; // 0x100008000
int64_t g4 = 0x200000000; // 0x100008008
int64_t g5 = 0x50800000012; // 0x100008010
int64_t g6 = 0x200085; // 0x100008018
float64_t g7 = 1.5278369696185125e-312; // 0x100008020
char g8[11] = "__PAGEZERO"; // 0x100008028
char g9[3] = "RO"; // 0x100008030

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memset_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int32_t _atoi(char * a1);
float64_t _cos(float64_t a1);
int32_t _fflush(struct _IO_FILE * a1);
float64_t _fmod(float64_t a1, float64_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fwrite(int64_t * a1, int32_t a2, int32_t a3, struct _IO_FILE * a4);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003584 - 0x100003604
int64_t function_100003584(void) {
    int64_t v1 = g5;
    g5 = v1 + g4;
    g4 -= v1;
    g7 = 2 * (int64_t)g7;
    *(int64_t *)&g8 = 2 * *(int64_t *)&g8;
    *(int64_t *)&g9 = 2 * *(int64_t *)&g9;
    int64_t result; // 0x100003584
    return result;
}

// Address range: 0x100003604 - 0x100003840
int64_t function_100003604(int64_t a1, int64_t a2) {
    float64_t v1 = 6.0 * g3 / g7; // 0x100003668
    int128_t v2; // 0x100003604
    float64_t result = _fmod(_cos((float64_t)(int64_t)v2), (float64_t)(int64_t)v2); // 0x1000036d0
    float64_t v3 = __asm_fabd(v1, 1.0); // 0x1000036e0
    uint32_t v4 = (int32_t)v1; // 0x1000036f4
    if (v4 >= 4 != v4 != 4) {
        // 0x100003710
        return result;
    }
    // 0x100003808
    int64_t v5; // 0x100003604
    int64_t v6 = *(int64_t *)(g6 + 8 * v5) + 24 * v5; // 0x100003638
    float64_t * v7 = (float64_t *)v6; // 0x10000363c
    float64_t v8 = 1.0 - 0.25 * (g3 * (float64_t)g1 / g7 - 1.0); // 0x1000036ac
    *v7 = v8 + *v7;
    float64_t * v9 = (float64_t *)(v6 + 16); // 0x100003824
    *v9 = (1.0 - v3) * v8 + *v9;
    return result;
}

// Address range: 0x100003854 - 0x100003a2c
int64_t function_100003854(void) {
    int64_t v1; // 0x100003854
    char v2 = *(char *)v1; // 0x100003870
    // 0x100003854
    while (v2 != 0) {
        uint64_t v3 = (int64_t)v2 + 0xffffffd5 & 0xffffffff; // 0x100003898
        v1++;
        if (v3 >= 46 != v3 != 46) {
            // break -> 0x1000038ac
            break;
        }
        v2 = *(char *)v1;
    }
    // 0x1000038ac
    int64_t result; // 0x100003854
    return result;
}

// Address range: 0x100003ae8 - 0x100003e24
int64_t function_100003ae8(void) {
    // 0x100003ae8
    int64_t v1; // 0x100003ae8
    int64_t v2 = v1 / 3 + 1; // 0x100003b08
    int64_t v3 = v1 + 3; // 0x100003b14
    int64_t v4 = v1 + 2 + 3 * v2 / 2; // 0x100003b34
    int64_t v5 = v4 * v3;
    int64_t v6 = 24 * v5; // 0x100003b4c
    int32_t v7 = v6; // 0x100003b50
    int64_t v8 = (int64_t)_malloc(v7); // 0x100003b50
    int64_t * v9 = _malloc(8 * (int32_t)v3); // 0x100003b64
    g6 = (int64_t)v9;
    int64_t v10 = -3 - v1; // 0x100003b84
    if (v10 < 0 != (v10 & v3) < 0) {
        // 0x100003b94
        *v9 = v8;
        int64_t v11 = -2 - v1; // 0x100003b84
        if (v11 < 0 != (v11 & v3) < 0) {
            int64_t v12 = 1;
            *(int64_t *)(8 * v12 + g6) = 24 * v4 * v12 + v8;
            int64_t v13 = v12 + 1; // 0x100003bcc
            int64_t v14 = v13 - v3; // 0x100003b84
            while (v14 < 0 != ((v14 ^ v13) & (v13 ^ v3)) < 0) {
                // 0x100003b94
                v12 = v13;
                *(int64_t *)(8 * v12 + g6) = 24 * v4 * v12 + v8;
                v13 = v12 + 1;
                v14 = v13 - v3;
            }
        }
    }
    // 0x100003bd8
    ___memset_chk(v8, 0, v6, -1);
    *(int64_t *)&g9 = v2;
    *(int64_t *)&g8 = v2;
    g5 = 0;
    g7 = 4.9406564584124654e-324;
    g3 = 0.0;
    int64_t v15 = 0x100000000 * v1;
    int64_t v16 = v15 >> 32; // 0x100003c5c
    int64_t v17 = 0; // 0x100003c68
    if (v15 > 0 != (v16 & -v16) < 0) {
        function_100003584();
        v17++;
        while (v17 - v16 < 0 != ((v17 - v16 ^ v17) & (v17 ^ v16)) < 0) {
            // 0x100003c70
            function_100003584();
            v17++;
        }
    }
    // 0x100003c88
    function_100003854();
    int32_t v18 = 3 * (int32_t)v5; // 0x100003cb0
    int64_t * v19 = _malloc(v18); // 0x100003cb0
    float64_t v20 = 0.0; // bp-88, 0x100003cc0
    int64_t v21 = 3 * v5;
    int64_t v22 = v21 - 1;
    if (v22 >= 0) {
        int64_t v23 = (int64_t)v19; // 0x100003cb0
        int64_t v24 = v22;
        float64_t v25 = 0.0; // 0x100003d08
        float64_t v26 = 0.0;
        int64_t v27 = 8 * v24 + v8; // 0x100003d04
        float64_t v28 = *(float64_t *)v27; // 0x100003d04
        float64_t v29 = v26; // 0x100003d0c
        float64_t v30 = v25; // 0x100003d0c
        int64_t v31; // 0x100003ae8
        if (v28 != v25) {
            v29 = v26;
            v30 = v25;
            if (v28 > v25 == v28 >= v25 == v28 <= v25) {
                // 0x100003d1c
                v31 = *(int64_t *)v27;
                v20 = v31;
                v29 = v31;
                v30 = v31;
            }
        }
        float64_t v32 = v29;
        v24--;
        while (v24 >= 0) {
            // 0x100003cfc
            v25 = v30;
            v26 = v32;
            v27 = 8 * v24 + v8;
            v28 = *(float64_t *)v27;
            v29 = v26;
            v30 = v25;
            if (v28 != v25) {
                v29 = v26;
                v30 = v25;
                if (v28 > v25 == v28 >= v25 == v28 <= v25) {
                    // 0x100003d1c
                    v31 = *(int64_t *)v27;
                    v20 = v31;
                    v29 = v31;
                    v30 = v31;
                }
            }
            // 0x100003d34
            v32 = v29;
            v24--;
        }
        float64_t v33 = *(float64_t *)(8 * v22 + v8); // 0x100003d80
        *(char *)(v22 + v23) = (char)(int32_t)(v33 * g2 / v32);
        int64_t v34 = v21 - 2;
        if (v34 >= 0) {
            float64_t v35 = *(float64_t *)(8 * v34 + v8); // 0x100003d80
            *(char *)(v34 + v23) = (char)(int32_t)(v35 * g2 / v20);
            int64_t v36 = v34 - 1;
            int64_t v37 = v36; // 0x100003d70
            while (v36 >= 0) {
                // 0x100003d78
                v35 = *(float64_t *)(8 * v37 + v8);
                *(char *)(v37 + v23) = (char)(int32_t)(v35 * g2 / v20);
                v36 = v37 - 1;
                v37 = v36;
            }
        }
    }
    // 0x100003dbc
    _printf("P6\n%ld %ld\n255\n", (int32_t)v1, v7);
    int64_t * v38 = (int64_t *)*(int64_t *)0x100004010; // 0x100003de8
    _fflush((struct _IO_FILE *)*v38);
    return _fwrite(v19, v18, 1, (struct _IO_FILE *)*v38);
}

// Address range: 0x100003e24 - 0x100003edc
int64_t entry_point(void) {
    // 0x100003e24
    int64_t v1; // 0x100003e24
    int32_t v2 = v1; // 0x100003e34
    int32_t v3 = v2 - 1; // 0x100003e40
    if (v3 != 0 && v3 < 0 == (v2 & -v2) < 0) {
        // 0x100003e50
        _atoi((char *)*(int64_t *)(v1 + 8));
    }
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003e90
    _fprintf((struct _IO_FILE *)v4, "size: %d depth: %d\n", v1, v1);
    function_100003ae8();
    return 0;
}

// Address range: 0x100003edc - 0x100003ee8
int64_t function_100003edc(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003edc
    return ___memset_chk(a1, a2, a3, a4);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * nptr) {
    // 0x100003ee8
    return _atoi(nptr);
}

// Address range: 0x100003ef4 - 0x100003f00
float64_t function_100003ef4(float64_t a1) {
    // 0x100003ef4
    return _cos(a1);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(struct _IO_FILE * stream) {
    // 0x100003f00
    return _fflush(stream);
}

// Address range: 0x100003f0c - 0x100003f18
float64_t function_100003f0c(float64_t a1, float64_t a2) {
    // 0x100003f0c
    return _fmod(a1, a2);
}

// Address range: 0x100003f18 - 0x100003f24
int32_t function_100003f18(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f18
    return _fprintf(stream, format);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x100003f24
    return _fwrite(ptr, size, n, s);
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t * function_100003f30(int32_t size) {
    // 0x100003f30
    return _malloc(size);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`//FormAI DATASET v1.0 Category: Hexadecimal Converter ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char hex[17], ascii[16], binary[65] = {'\0'};
    int decimal, i, length;
    printf("Enter a hexadecimal number: ");
    scanf("%s", hex);
    
    // convert hexadecimal to decimal
    decimal = 0;
    length = strlen(hex);
    for(i = 0; i < length; i++) {
        if(hex[i] >= '0' && hex[i] <= '9') {
            decimal += (hex[i] - '0') * (int) pow(16, length - i - 1);
        } else if(hex[i] >= 'A' && hex[i] <= 'F') {
            decimal += (hex[i] - 'A' + 10) * (int) pow(16, length - i - 1);
        } else {
            printf("Invalid input.\n");
            return 1;
        }
    }
    
    // convert decimal to binary
    int j = 0;
    while(decimal > 0) {
        binary[j++] = decimal % 2 + '0';
        decimal /= 2;
    }
    
    // reverse binary string
    int k = 0;
    char temp;
    while(k < j - 1) {
        temp = binary[k];
        binary[k] = binary[j - 1];
        binary[j - 1] = temp;
        k++;
        j--;
    }
    
    // convert binary to ASCII
    length = strlen(binary);
    for(i = 0; i < length; i += 8) {
        memcpy(ascii + i / 8, binary + i, 8);
        ascii[i / 8 + 1] = '\0';
    }
    
    // output results
    printf("Hexadecimal input: %s\n", hex);
    printf("Decimal output: %d\n", decimal);
    printf("Binary output: %s\n", binary);
    printf("ASCII output: %s\n", ascii);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);
// size_t __cdecl strlen(const char *Str);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // ebx
  double v4; // xmm0_8
  int v5; // ebx
  double v6; // xmm0_8
  int v8; // eax
  char v9[8]; // [rsp+20h] [rbp-90h] BYREF
  __int64 v10; // [rsp+28h] [rbp-88h]
  __int64 v11; // [rsp+30h] [rbp-80h]
  __int64 v12; // [rsp+38h] [rbp-78h]
  __int64 v13; // [rsp+40h] [rbp-70h]
  __int64 v14; // [rsp+48h] [rbp-68h]
  __int64 v15; // [rsp+50h] [rbp-60h]
  __int64 v16; // [rsp+58h] [rbp-58h]
  char v17; // [rsp+60h] [rbp-50h]
  char v18[16]; // [rsp+70h] [rbp-40h] BYREF
  char Str[27]; // [rsp+80h] [rbp-30h] BYREF
  char v20; // [rsp+9Bh] [rbp-15h]
  int v21; // [rsp+9Ch] [rbp-14h]
  int v22; // [rsp+A0h] [rbp-10h]
  int v23; // [rsp+A4h] [rbp-Ch]
  int i; // [rsp+A8h] [rbp-8h]
  int v25; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  *(_QWORD *)v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0;
  printf("Enter a hexadecimal number: ");
  scanf("%s", Str);
  v25 = 0;
  v21 = strlen(Str);
  for ( i = 0; i < v21; ++i )
  {
    if ( Str[i] <= 47 || Str[i] > 57 )
    {
      if ( Str[i] <= 64 || Str[i] > 70 )
      {
        printf("Invalid input.\n");
        return 1;
      }
      v5 = Str[i] - 55;
      v6 = pow(16.0, (double)(v21 - i - 1));
      v25 += v5 * (int)v6;
    }
    else
    {
      v3 = Str[i] - 48;
      v4 = pow(16.0, (double)(v21 - i - 1));
      v25 += v3 * (int)v4;
    }
  }
  v23 = 0;
  while ( v25 > 0 )
  {
    v8 = v23++;
    v9[v8] = v25 % 2 + 48;
    v25 /= 2;
  }
  v22 = 0;
  while ( v22 < v23 - 1 )
  {
    v20 = v9[v22];
    v9[v22] = v9[v23 - 1];
    v9[v23 - 1] = v20;
    ++v22;
    --v23;
  }
  v21 = strlen(v9);
  for ( i = 0; i < v21; i += 8 )
  {
    *(_QWORD *)&v18[i / 8] = *(_QWORD *)&v9[i];
    v18[i / 8 + 1] = 0;
  }
  printf("Hexadecimal input: %s\n", Str);
  printf("Decimal output: %d\n", (unsigned int)v25);
  printf("Binary output: %s\n", v9);
  printf("ASCII output: %s\n", v18);
  return 0;
}
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[27];
// 1400015E2: using guessed type char var_50[16];

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define N 10 // Size of matrix

void generateMatrix(int (*matrix)[N]) {
    srand(time(NULL)); // Set random seed based on current time

    // Initialize matrix with random 0's and 1's
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            matrix[i][j] = rand() % 2;
        }
    }
}

void printMatrix(int (*matrix)[N]) {
    // Print matrix
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

void percolate(int (*matrix)[N]) {
    int flag = 1; // Flag to mark if any changes made in last iteration
    // Keep checking and changing the matrix until no further changes can be made
    while (flag) {
        flag = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (matrix[i][j] == 1) {
                    // Check if any neighboring cell is also 1, if yes, change the current cell to 1
                    if ((j < N - 1 && matrix[i][j+1] == 2) ||
                        (i < N - 1 && matrix[i+1][j] == 2) ||
                        (j > 0 && matrix[i][j-1] == 2) ||
                        (i > 0 && matrix[i-1][j] == 2)) {
                        matrix[i][j] = 2;
                        flag = 1;
                    }
                }
            }
        }
    }
}

int main() {
    int matrix[N][N];

    generateMatrix(matrix);
    printf("Initial matrix:\n");
    printMatrix(matrix);

    percolate(matrix);
    printf("Final matrix:\n");
    printMatrix(matrix);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall generateMatrix(_QWORD); // weak
__int64 __fastcall printMatrix(_QWORD); // weak
__int64 __fastcall percolate(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001856) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[400]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  generateMatrix(v4);
  printf("Initial matrix:\n");
  printMatrix(v4);
  percolate(v4);
  printf("Final matrix:\n");
  printMatrix(v4);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall generateMatrix(_QWORD);
// 14000163F: using guessed type __int64 __fastcall printMatrix(_QWORD);
// 1400016BF: using guessed type __int64 __fastcall percolate(_QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: HTML beautifier ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>

int main() {
   FILE *input_file = fopen("input.html", "r");
   FILE *output_file = fopen("output.html", "w");
   
   if (input_file == NULL) {
      printf("Error opening input file!\n");
      exit(1);
   }
   if (output_file == NULL) {
      printf("Error opening output file!\n");
      exit(1);
   }

   char c, last_c = ' ';
   while ((c = fgetc(input_file)) != EOF) {
      if (c == '<' && last_c != ' ') {
         fputc('\n', output_file);
      }
      fputc(c, output_file);
      last_c = c;
   }

   fclose(input_file);
   fclose(output_file);
   printf("Successfully beautified input.html to output.html!\n");
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl fputc(int Character, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+27h] [rbp-19h]
  FILE *Stream; // [rsp+28h] [rbp-18h]
  FILE *v6; // [rsp+30h] [rbp-10h]
  char i; // [rsp+3Fh] [rbp-1h]

  _main(argc, argv, envp);
  v6 = fopen("input.html", "r");
  Stream = fopen("output.html", "w");
  if ( !v6 )
  {
    printf("Error opening input file!\n");
    exit(1);
  }
  if ( !Stream )
  {
    printf("Error opening output file!\n");
    exit(1);
  }
  for ( i = 32; ; i = v4 )
  {
    v4 = fgetc(v6);
    if ( v4 == -1 )
      break;
    if ( v4 == 60 && i != 32 )
      fputc(10, Stream);
    fputc(v4, Stream);
  }
  fclose(v6);
  fclose(Stream);
  printf("Successfully beautified input.html to output.html!\n");
  return 0;
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`// This code is the implementation of Babbage Problem

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int main() {
	int current = 0, 	//the current number
	    square;		//the square of the current number

	//the strategy of take the rest of division by 1e06 is
	//to take the a number how 6 last digits are 269696
	while (((square=current*current) % 1000000 != 269696) && (square<INT_MAX)) {
		current++;
	}

        //output
	if (square>+INT_MAX)
	    printf("Condition not satisfied before INT_MAX reached.");
	else		
	    printf ("The smallest number whose square ends in 269696 is %d\n", current);
	
        //the end
	return 0 ;
}
`,`#include "babbage-problem.h"



undefined8 entry(void)

{
  int iVar1;
  int local_18;
  
  for (local_18 = 0; iVar1 = local_18 * local_18, iVar1 % 1000000 != 0x41d80 && iVar1 < 0x7fffffff;
      local_18 = local_18 + 1) {
  }
  if (iVar1 < -0x80000000) {
    _printf("The smallest number whose square ends in 269696 is %d\n");
  }
  else {
    _printf("Condition not satisfied before INT_MAX reached.");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: Dennis Ritchie
#include<stdio.h>
int main(){
  int rows, i, j, k;
  
  printf("Enter the number of rows: ");
  scanf("%d", &rows);
  
  // Outer loop to iterate number of rows
  for(i=1; i<=rows; i++){
    
    // Inner loop to print spaces
    for(j=i; j<=rows; j++){
      printf(" ");
    }
    
    // Inner loop to print asterisks
    for(k=i; k>=1; k--){
      printf("* ");
    }
    
    printf("\n");
  }
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-10h] BYREF
  int k; // [rsp+24h] [rbp-Ch]
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of rows: ");
  scanf("%d", &v4);
  for ( i = 1; i <= v4; ++i )
  {
    for ( j = i; j <= v4; ++j )
      printf(" ");
    for ( k = i; k > 0; --k )
      printf("* ");
    printf("\n");
  }
  return 0;
}
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Haunted House Simulator ; Style: retro
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>

/* function prototypes */
void print_boundary();
void print_intro();
void print_ghost();
void print_end();

int main() {
    char name[20];
    int choice, room_num = 1;
    int has_key = 0, has_flashlight = 0;
    int locked_room_num = rand() % 5 + 1;
    char answer;

    /* set random seed */
    srand(time(NULL));

    /* print intro */
    print_intro();

    /* get player name */
    printf("What's your name? ");
    fgets(name, 20, stdin);

    /* game loop */
    while (room_num <= 5) {
        printf("\n\nYou are in room %d.\n\n", room_num);

        /* print ghost in second room */
        if (room_num == 2) {
            print_ghost();
        }

        /* print locked door in random room */
        if (room_num == locked_room_num && !has_key) {
            printf("The door is locked. You need a key to open it.\n");
        }
        else {
            printf("There is a door to the next room.\n");
        }

        /* print flashlight in first room */
        if (room_num == 1 && !has_flashlight) {
            printf("There is a flashlight on the ground.\n");
        }

        /* get player choice */
        printf("What do you want to do?\n");
        printf("1. Go to the next room.\n");
        printf("2. Look for items.\n");
        printf("3. Quit.\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        fflush(stdin);

        /* handle player choice */
        switch (choice) {
            case 1:
                /* move to next room */
                if (room_num == locked_room_num && !has_key) {
                    printf("The door is locked. You need a key to open it.\n");
                }
                else {
                    printf("You go to the next room.\n");
                    room_num++;
                }
                break;
            case 2:
                /* search for items */
                if (room_num == 1 && !has_flashlight) {
                    printf("You pick up the flashlight.\n");
                    has_flashlight = 1;
                }
                else if (room_num == locked_room_num && !has_key) {
                    printf("You found a key!\n");
                    has_key = 1;
                }
                else {
                    printf("You didn't find anything.\n");
                }
                break;
            case 3:
                /* quit game */
                printf("Are you sure you want to quit? (y/n) ");
                scanf(" %c", &answer);
                if (tolower(answer) == 'y') {
                    printf("Thanks for playing, %s!\n", name);
                    return 0;
                }
                break;
            default:
                /* invalid input */
                printf("Invalid input. Please try again.\n");
        }
    }

    /* player reached the end */
    print_end();
    printf("Congratulations, %s! You made it out alive!\n", name);

    return 0;
}

/* function definitions */

void print_boundary() {
    printf("==============================================\n");
}

void print_intro() {
    print_boundary();
    printf("Welcome to the Haunted House Simulator!\n");
    print_boundary();
    printf("You find yourself trapped in a haunted house.\n");
    printf("Find your way out before it's too late!\n");
}

void print_ghost() {
    printf("You see a ghost standing in front of you!\n");
    printf("It vanishes as soon as you blink...\n");
}

void print_end() {
    print_boundary();
    printf("Congratulations, you made it to the END!\n");
    print_boundary();
    printf("          |         |         |\n");
    printf("        _/ \\_     _/ \\_     _/ \\_\n");
    printf("       |     |   |     |   |     |\n");
    printf("        \\_   _/     \\_   _/     \\_\n");
    printf("          | |         | |         |\n");
    printf("          | |         | |         |\n");
    printf("          | |         | |         |\n");
    printf("          | |         | |         |\n");
    printf("       ___| |_     ___| |_     ___| |_\n");
    printf("      /  _|   \\   /  _|   \\   /  _|  \\\n");
    printf("     / /      /  / /      /  / /    |\\\n");
    printf("    /_/      /_/ /_/      /_/ /_/\\_| \\\n");
    printf("                                \\____/\n");
    print_boundary();
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 print_intro(void); // weak
__int64 print_ghost(void); // weak
__int64 print_end(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fflush(FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *tolower)(int C);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  FILE *v4; // rax
  FILE *v5; // rax
  char v7; // [rsp+2Bh] [rbp-35h] BYREF
  int v8; // [rsp+2Ch] [rbp-34h] BYREF
  char Buffer[32]; // [rsp+30h] [rbp-30h] BYREF
  int v10; // [rsp+50h] [rbp-10h]
  int v11; // [rsp+54h] [rbp-Ch]
  int v12; // [rsp+58h] [rbp-8h]
  unsigned int v13; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v13 = 1;
  v12 = 0;
  v11 = 0;
  v10 = rand() % 5 + 1;
  v3 = time(0i64);
  srand(v3);
  print_intro();
  printf("What's your name? ");
  v4 = __acrt_iob_func(0);
  fgets(Buffer, 20, v4);
  while ( (int)v13 <= 5 )
  {
    printf("\n\nYou are in room %d.\n\n", v13);
    if ( v13 == 2 )
      print_ghost();
    if ( v13 != v10 || v12 )
      printf("There is a door to the next room.\n");
    else
      printf("The door is locked. You need a key to open it.\n");
    if ( v13 == 1 && !v11 )
      printf("There is a flashlight on the ground.\n");
    printf("What do you want to do?\n");
    printf("1. Go to the next room.\n");
    printf("2. Look for items.\n");
    printf("3. Quit.\n");
    printf("Enter your choice: ");
    scanf("%d", &v8);
    v5 = __acrt_iob_func(0);
    fflush(v5);
    if ( v8 == 3 )
    {
      printf("Are you sure you want to quit? (y/n) ");
      scanf(" %c", &v7);
      if ( tolower(v7) == 121 )
      {
        printf("Thanks for playing, %s!\n", Buffer);
        return 0;
      }
    }
    else
    {
      if ( v8 > 3 )
        goto LABEL_29;
      if ( v8 == 1 )
      {
        if ( v13 != v10 || v12 )
        {
          printf("You go to the next room.\n");
          ++v13;
        }
        else
        {
          printf("The door is locked. You need a key to open it.\n");
        }
      }
      else if ( v8 == 2 )
      {
        if ( v13 != 1 || v11 )
        {
          if ( v13 != v10 || v12 )
          {
            printf("You didn't find anything.\n");
          }
          else
          {
            printf("You found a key!\n");
            v12 = 1;
          }
        }
        else
        {
          printf("You pick up the flashlight.\n");
          v11 = 1;
        }
      }
      else
      {
LABEL_29:
        printf("Invalid input. Please try again.\n");
      }
    }
  }
  print_end();
  printf("Congratulations, %s! You made it out alive!\n", Buffer);
  return 0;
}
// 1400018EA: using guessed type __int64 print_intro(void);
// 140001930: using guessed type __int64 print_ghost(void);
// 14000195D: using guessed type __int64 print_end(void);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`/* Uses C99 specified complex.h, complex datatype has to be defined and operation provided if used on non-C99 compilers */

#include<stdlib.h>
#include<stdio.h>
#include<complex.h>

typedef struct
{
  int rows, cols;
  complex **z;
} matrix;

matrix
transpose (matrix a)
{
  int i, j;
  matrix b;

  b.rows = a.cols;
  b.cols = a.rows;

  b.z = malloc (b.rows * sizeof (complex *));

  for (i = 0; i < b.rows; i++)
    {
      b.z[i] = malloc (b.cols * sizeof (complex));
      for (j = 0; j < b.cols; j++)
        {
          b.z[i][j] = conj (a.z[j][i]);
        }
    }

  return b;
}

int
isHermitian (matrix a)
{
  int i, j;
  matrix b = transpose (a);

  if (b.rows == a.rows && b.cols == a.cols)
    {
      for (i = 0; i < b.rows; i++)
        {
          for (j = 0; j < b.cols; j++)
            {
              if (b.z[i][j] != a.z[i][j])
                return 0;
            }
        }
    }

  else
    return 0;

  return 1;
}

matrix
multiply (matrix a, matrix b)
{
  matrix c;
  int i, j;

  if (a.cols == b.rows)
    {
      c.rows = a.rows;
      c.cols = b.cols;

      c.z = malloc (c.rows * (sizeof (complex *)));

      for (i = 0; i < c.rows; i++)
        {
          c.z[i] = malloc (c.cols * sizeof (complex));
          c.z[i][j] = 0 + 0 * I;
          for (j = 0; j < b.cols; j++)
            {
              c.z[i][j] += a.z[i][j] * b.z[j][i];
            }
        }

    }

  return c;
}

int
isNormal (matrix a)
{
  int i, j;
  matrix a_ah, ah_a;

  if (a.rows != a.cols)
    return 0;

  a_ah = multiply (a, transpose (a));
  ah_a = multiply (transpose (a), a);

  for (i = 0; i < a.rows; i++)
    {
      for (j = 0; j < a.cols; j++)
        {
          if (a_ah.z[i][j] != ah_a.z[i][j])
            return 0;
        }
    }

  return 1;
}

int
isUnitary (matrix a)
{
  matrix b;
  int i, j;
  if (isNormal (a) == 1)
    {
      b = multiply (a, transpose(a));

      for (i = 0; i < b.rows; i++)
        {
          for (j = 0; j < b.cols; j++)
            {
              if ((i == j && b.z[i][j] != 1) || (i != j && b.z[i][j] != 0))
                return 0;
            }
        }
      return 1;
    }
  return 0;
}


int
main ()
{
  complex z = 3 + 4 * I;
  matrix a, aT;
  int i, j;
  printf ("Enter rows and columns :");
  scanf ("%d%d", &a.rows, &a.cols);

  a.z = malloc (a.rows * sizeof (complex *));
  printf ("Randomly Generated Complex Matrix A is : ");
  for (i = 0; i < a.rows; i++)
    {
      printf ("\n");
      a.z[i] = malloc (a.cols * sizeof (complex));
      for (j = 0; j < a.cols; j++)
        {
          a.z[i][j] = rand () % 10 + rand () % 10 * I;
          printf ("\t%f + %fi", creal (a.z[i][j]), cimag (a.z[i][j]));
        }
    }

  aT = transpose (a);

  printf ("\n\nTranspose of Complex Matrix A is : ");
  for (i = 0; i < aT.rows; i++)
    {
      printf ("\n");
      aT.z[i] = malloc (aT.cols * sizeof (complex));
      for (j = 0; j < aT.cols; j++)
        {
          aT.z[i][j] = rand () % 10 + rand () % 10 * I;
          printf ("\t%f + %fi", creal (aT.z[i][j]), cimag (aT.z[i][j]));
        }
    }

  printf ("\n\nComplex Matrix A %s hermitian",
          isHermitian (a) == 1 ? "is" : "is not");
  printf ("\n\nComplex Matrix A %s unitary",
          isUnitary (a) == 1 ? "is" : "is not");
  printf ("\n\nComplex Matrix A %s normal",
          isNormal (a) == 1 ? "is" : "is not");



  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000030f8(void);
int64_t function_1000031fc(void);
int64_t function_100003354(void);
int64_t function_1000035cc(void);
int64_t function_100003764(void);
int64_t function_100003e80(void);
int64_t function_100003e8c(int64_t a1);
int64_t * function_100003e98(int32_t size);
int32_t function_100003ea4(char * format, ...);
int32_t function_100003eb0(void);
int32_t function_100003ebc(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___muldc3(void);
int64_t ___mulsc3(int64_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000030f8 - 0x1000031fc
int64_t function_1000030f8(void) {
    // 0x1000030f8
    int32_t result; // 0x1000030f8
    int64_t * v1 = _malloc(8 * result); // 0x100003124
    int32_t v2 = -result; // 0x10000313c
    if (v2 < 0 == (result & v2) < 0) {
        // 0x1000031e8
        return result;
    }
    // 0x10000314c
    int64_t v3; // 0x1000030f8
    int32_t v4 = v3; // 0x100003114
    int32_t v5 = -v4;
    int32_t v6 = 0; // 0x1000031dc
    int64_t v7 = (int64_t)_malloc(16 * v4); // 0x100003154
    int64_t v8 = v6; // 0x10000315c
    int64_t * v9 = (int64_t *)(8 * v8 + (int64_t)v1); // 0x100003160
    *v9 = v7;
    int64_t v10; // 0x100003188
    int64_t v11; // 0x100003194
    int64_t v12; // 0x1000031b4
    int32_t v13; // 0x1000031c8
    if (v5 < 0 != (v5 & v4) < 0) {
        // 0x100003184
        v13 = 0;
        v10 = v13;
        v11 = *(int64_t *)(8 * v10 + v3) + 16 * v8;
        v12 = 16 * v10 + v7;
        *(int64_t *)v12 = *(int64_t *)v11;
        *(float64_t *)(v12 + 8) = -*(float64_t *)(v11 + 8);
        v13++;
        while (v13 - v4 < 0 != ((v13 - v4 ^ v13) & (v13 ^ v4)) < 0) {
            // 0x100003184
            v10 = v13;
            v11 = *(int64_t *)(8 * v10 + v3) + 16 * v8;
            v12 = 16 * v10 + *v9;
            *(int64_t *)v12 = *(int64_t *)v11;
            *(float64_t *)(v12 + 8) = -*(float64_t *)(v11 + 8);
            v13++;
        }
    }
    // 0x1000031d8
    v6++;
    while (v6 - result < 0 != ((v6 - result ^ v6) & (v6 ^ result)) < 0) {
        // 0x10000314c
        v7 = (int64_t)_malloc(16 * v4);
        v8 = v6;
        v9 = (int64_t *)(8 * v8 + (int64_t)v1);
        *v9 = v7;
        if (v5 < 0 != (v5 & v4) < 0) {
            // 0x100003184
            v13 = 0;
            v10 = v13;
            v11 = *(int64_t *)(8 * v10 + v3) + 16 * v8;
            v12 = 16 * v10 + v7;
            *(int64_t *)v12 = *(int64_t *)v11;
            *(float64_t *)(v12 + 8) = -*(float64_t *)(v11 + 8);
            v13++;
            while (v13 - v4 < 0 != ((v13 - v4 ^ v13) & (v13 ^ v4)) < 0) {
                // 0x100003184
                v10 = v13;
                v11 = *(int64_t *)(8 * v10 + v3) + 16 * v8;
                v12 = 16 * v10 + *v9;
                *(int64_t *)v12 = *(int64_t *)v11;
                *(float64_t *)(v12 + 8) = -*(float64_t *)(v11 + 8);
                v13++;
            }
        }
        // 0x1000031d8
        v6++;
    }
    // 0x1000031e8
    return result;
}

// Address range: 0x1000031fc - 0x100003354
int64_t function_1000031fc(void) {
    int32_t v1 = function_1000030f8(); // 0x10000321c
    int64_t v2; // 0x1000031fc
    if (true != (v1 == (int32_t)v2)) {
        // 0x100003344
        return 0;
    }
    int32_t v3 = -v1; // 0x100003264
    int64_t result = 1; // 0x10000326c
    if (v3 < 0 == (v3 & v1) < 0) {
      lab_0x100003344_2:
        // 0x100003344
        return result;
    }
    // 0x10000327c
    int32_t v4; // 0x1000031fc
    int32_t v5 = -v4; // 0x100003284
    int32_t v6 = 0;
    int64_t v7; // 0x1000031fc
    int64_t v8; // 0x1000032a4
    float64_t v9; // 0x1000032a8
    int64_t v10; // 0x1000031fc
    int32_t v11; // 0x10000330c
    if (v5 < 0 != (v4 & v5) < 0) {
        // 0x100003294
        v7 = *(int64_t *)(8 * (int64_t)v6 + v2);
        v11 = 0;
        v8 = 16 * (int64_t)v11 + v7;
        v9 = *(float64_t *)v8;
        result = 0;
        if (v9 != v9 || 0.0 != 0.0) {
            return result;
        }
        // 0x1000032e4
        v10 = *(int64_t *)(v8 + 8);
        result = 0;
        if ((float64_t)v10 != (float64_t)v10 || 0.0 != 0.0) {
            return result;
        }
        // 0x10000327c
        v11++;
        while (v11 - v4 < 0 != ((v11 - v4 ^ v11) & (v11 ^ v4)) < 0) {
            // 0x100003294
            v8 = 16 * (int64_t)v11 + v7;
            v9 = *(float64_t *)v8;
            result = 0;
            if (v9 != v9 || 0.0 != 0.0) {
                return result;
            }
            // 0x1000032e4
            v10 = *(int64_t *)(v8 + 8);
            result = 0;
            if ((float64_t)v10 != (float64_t)v10 || 0.0 != 0.0) {
                return result;
            }
            // 0x10000327c
            v11++;
        }
    }
    int32_t v12 = v6 + 1; // 0x100003320
    while (v12 - v1 < 0 != ((v12 - v1 ^ v12) & (v12 ^ v1)) < 0) {
        // 0x10000327c
        v6 = v12;
        if (v5 < 0 != (v4 & v5) < 0) {
            // 0x100003294
            v7 = *(int64_t *)(8 * (int64_t)v6 + v2);
            v11 = 0;
            v8 = 16 * (int64_t)v11 + v7;
            v9 = *(float64_t *)v8;
            result = 0;
            if (v9 != v9 || 0.0 != 0.0) {
                return result;
            }
            // 0x1000032e4
            v10 = *(int64_t *)(v8 + 8);
            result = 0;
            if ((float64_t)v10 != (float64_t)v10 || 0.0 != 0.0) {
                return result;
            }
            // 0x10000327c
            v11++;
            while (v11 - v4 < 0 != ((v11 - v4 ^ v11) & (v11 ^ v4)) < 0) {
                // 0x100003294
                v8 = 16 * (int64_t)v11 + v7;
                v9 = *(float64_t *)v8;
                result = 0;
                if (v9 != v9 || 0.0 != 0.0) {
                    return result;
                }
                // 0x1000032e4
                v10 = *(int64_t *)(v8 + 8);
                result = 0;
                if ((float64_t)v10 != (float64_t)v10 || 0.0 != 0.0) {
                    return result;
                }
                // 0x10000327c
                v11++;
            }
        }
        // 0x10000331c
        v12 = v6 + 1;
    }
    // 0x100003344
    return 1;
}

// Address range: 0x100003354 - 0x1000035cc
int64_t function_100003354(void) {
    // 0x100003354
    int64_t v1; // 0x100003354
    int32_t v2; // 0x100003354
    if (v2 != (int32_t)v1) {
        // 0x1000035b8
        int32_t result; // 0x100003354
        return result;
    }
    int32_t result2 = v1; // 0x100003368
    int64_t * v3 = _malloc(8 * result2); // 0x1000033a8
    int32_t v4 = -result2; // 0x1000033c0
    if (v4 < 0 == (v4 & result2) < 0) {
        // 0x1000035b8
        return result2;
    }
    // 0x1000033d0
    float32_t v5; // 0x100003354
    float64_t v6 = (float64_t)(2 * v5);
    int32_t v7 = -v2;
    int32_t v8 = 0; // 0x1000035a8
    int64_t v9 = (int64_t)_malloc(16 * v2); // 0x1000033d8
    int64_t v10 = v8; // 0x1000033e4
    int64_t v11 = 8 * v10; // 0x1000033e8
    int64_t * v12 = (int64_t *)(v11 + (int64_t)v3); // 0x1000033e8
    *v12 = v9;
    int32_t v13; // 0x100003354
    int64_t v14 = 16 * (int64_t)v13 + v9; // 0x10000346c
    *(float64_t *)v14 = v6;
    *(float64_t *)(v14 + 8) = v6;
    int32_t v15 = 0; // 0x100003490
    float64_t v16; // 0x100003354
    float64_t v17; // 0x100003354
    int64_t v18; // 0x1000034a4
    int64_t v19; // 0x1000034a8
    int64_t v20; // 0x1000034a8
    float64_t v21; // 0x1000034ac
    float64_t v22; // 0x1000034b4
    int64_t v23; // 0x1000034cc
    float64_t v24; // 0x1000034d0
    float64_t v25; // 0x1000034d8
    float64_t v26; // 0x1000034f0
    float64_t v27; // 0x1000034f8
    int64_t v28; // 0x100003570
    float64_t * v29; // 0x100003574
    float64_t * v30; // 0x100003578
    int32_t v31; // 0x100003594
    int32_t v32; // 0x100003488
    if (v7 < 0 != (v2 & v7) < 0) {
        // 0x100003498
        v31 = 0;
        v18 = v31;
        v19 = 16 * v18;
        v20 = v19 + *(int64_t *)(v11 + v1);
        v21 = *(float64_t *)v20;
        v22 = *(float64_t *)(v20 + 8);
        v23 = *(int64_t *)(8 * v18 + v1) + 16 * v10;
        v24 = *(float64_t *)v23;
        v25 = *(float64_t *)(v23 + 8);
        v26 = v21 * v24 - v22 * v25;
        v27 = v22 * v24 + v21 * v25;
        v16 = v27;
        v17 = v26;
        if ((v26 != v26 || 0.0 != 0.0) == (v27 != v27 || 0.0 != 0.0)) {
            // 0x100003538
            ___muldc3();
            v16 = v22;
            v17 = v21;
        }
        // 0x100003558
        v28 = *v12 + v19;
        v29 = (float64_t *)v28;
        v30 = (float64_t *)(v28 + 8);
        *v29 = v17 + *v29;
        *v30 = v16 + *v30;
        v31++;
        v32 = v31 - v2;
        v15 = v31;
        while (v32 < 0 != ((v32 ^ v31) & (v31 ^ v2)) < 0) {
            // 0x100003498
            v18 = v31;
            v19 = 16 * v18;
            v20 = v19 + *(int64_t *)(v11 + v1);
            v21 = *(float64_t *)v20;
            v22 = *(float64_t *)(v20 + 8);
            v23 = *(int64_t *)(8 * v18 + v1) + 16 * v10;
            v24 = *(float64_t *)v23;
            v25 = *(float64_t *)(v23 + 8);
            v26 = v21 * v24 - v22 * v25;
            v27 = v22 * v24 + v21 * v25;
            v16 = v27;
            v17 = v26;
            if ((v26 != v26 || 0.0 != 0.0) == (v27 != v27 || 0.0 != 0.0)) {
                // 0x100003538
                ___muldc3();
                v16 = v22;
                v17 = v21;
            }
            // 0x100003558
            v28 = *v12 + v19;
            v29 = (float64_t *)v28;
            v30 = (float64_t *)(v28 + 8);
            *v29 = v17 + *v29;
            *v30 = v16 + *v30;
            v31++;
            v32 = v31 - v2;
            v15 = v31;
        }
    }
    // 0x1000035a4
    v8++;
    int32_t v33 = v8 - result2; // 0x1000033c0
    while (v33 < 0 != ((v33 ^ v8) & (v8 ^ result2)) < 0) {
        // 0x1000033d0
        v9 = (int64_t)_malloc(16 * v2);
        v10 = v8;
        v11 = 8 * v10;
        v12 = (int64_t *)(v11 + (int64_t)v3);
        *v12 = v9;
        v14 = 16 * (int64_t)v15 + v9;
        *(float64_t *)v14 = v6;
        *(float64_t *)(v14 + 8) = v6;
        v15 = 0;
        if (v7 < 0 != (v2 & v7) < 0) {
            // 0x100003498
            v31 = 0;
            v18 = v31;
            v19 = 16 * v18;
            v20 = v19 + *(int64_t *)(v11 + v1);
            v21 = *(float64_t *)v20;
            v22 = *(float64_t *)(v20 + 8);
            v23 = *(int64_t *)(8 * v18 + v1) + 16 * v10;
            v24 = *(float64_t *)v23;
            v25 = *(float64_t *)(v23 + 8);
            v26 = v21 * v24 - v22 * v25;
            v27 = v22 * v24 + v21 * v25;
            v16 = v27;
            v17 = v26;
            if ((v26 != v26 || 0.0 != 0.0) == (v27 != v27 || 0.0 != 0.0)) {
                // 0x100003538
                ___muldc3();
                v16 = v22;
                v17 = v21;
            }
            // 0x100003558
            v28 = *v12 + v19;
            v29 = (float64_t *)v28;
            v30 = (float64_t *)(v28 + 8);
            *v29 = v17 + *v29;
            *v30 = v16 + *v30;
            v31++;
            v32 = v31 - v2;
            v15 = v31;
            while (v32 < 0 != ((v32 ^ v31) & (v31 ^ v2)) < 0) {
                // 0x100003498
                v18 = v31;
                v19 = 16 * v18;
                v20 = v19 + *(int64_t *)(v11 + v1);
                v21 = *(float64_t *)v20;
                v22 = *(float64_t *)(v20 + 8);
                v23 = *(int64_t *)(8 * v18 + v1) + 16 * v10;
                v24 = *(float64_t *)v23;
                v25 = *(float64_t *)(v23 + 8);
                v26 = v21 * v24 - v22 * v25;
                v27 = v22 * v24 + v21 * v25;
                v16 = v27;
                v17 = v26;
                if ((v26 != v26 || 0.0 != 0.0) == (v27 != v27 || 0.0 != 0.0)) {
                    // 0x100003538
                    ___muldc3();
                    v16 = v22;
                    v17 = v21;
                }
                // 0x100003558
                v28 = *v12 + v19;
                v29 = (float64_t *)v28;
                v30 = (float64_t *)(v28 + 8);
                *v29 = v17 + *v29;
                *v30 = v16 + *v30;
                v31++;
                v32 = v31 - v2;
                v15 = v31;
            }
        }
        // 0x1000035a4
        v8++;
        v33 = v8 - result2;
    }
    // 0x1000035b8
    return result2;
}

// Address range: 0x1000035cc - 0x100003764
int64_t function_1000035cc(void) {
    // 0x1000035cc
    int64_t v1; // 0x1000035cc
    int32_t v2; // 0x1000035cc
    if (v2 != (int32_t)v1) {
        // 0x100003754
        return 0;
    }
    // 0x100003600
    function_1000030f8();
    function_100003354();
    function_1000030f8();
    function_100003354();
    int32_t v3 = -v2;
    int32_t v4 = 0; // 0x100003688
    int64_t result = 1; // 0x100003688
    if (v3 < 0 == (v2 & v3) < 0) {
      lab_0x100003754_2:
        // 0x100003754
        return result;
    }
    int64_t v5 = 8 * (int64_t)v4; // 0x1000036b8
    int32_t v6 = 0; // 0x100003728
    int64_t v7 = 16 * (int64_t)v6; // 0x1000036c0
    int64_t v8 = v7 + *(int64_t *)(v5 + v1); // 0x1000036c0
    int64_t v9 = *(int64_t *)(v5 + v1) + v7; // 0x1000036e0
    result = 0;
    if (*(float64_t *)v8 != *(float64_t *)v9) {
        return result;
    }
    int64_t v10 = *(int64_t *)(v8 + 8);
    result = 0;
    if ((float64_t)v10 != (float64_t)*(int64_t *)(v9 + 8)) {
        return result;
    }
    // 0x100003698
    v6++;
    while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
        // 0x1000036b0
        v7 = 16 * (int64_t)v6;
        v8 = v7 + *(int64_t *)(v5 + v1);
        v9 = *(int64_t *)(v5 + v1) + v7;
        result = 0;
        if (*(float64_t *)v8 != *(float64_t *)v9) {
            return result;
        }
        // 0x100003700
        v10 = *(int64_t *)(v8 + 8);
        result = 0;
        if ((float64_t)v10 != (float64_t)*(int64_t *)(v9 + 8)) {
            return result;
        }
        // 0x100003698
        v6++;
    }
    // 0x100003738
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x1000036b0
        v5 = 8 * (int64_t)v4;
        v6 = 0;
        v7 = 16 * (int64_t)v6;
        v8 = v7 + *(int64_t *)(v5 + v1);
        v9 = *(int64_t *)(v5 + v1) + v7;
        result = 0;
        if (*(float64_t *)v8 != *(float64_t *)v9) {
            return result;
        }
        // 0x100003700
        v10 = *(int64_t *)(v8 + 8);
        result = 0;
        if ((float64_t)v10 != (float64_t)*(int64_t *)(v9 + 8)) {
            return result;
        }
        // 0x100003698
        v6++;
        while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
            // 0x1000036b0
            v7 = 16 * (int64_t)v6;
            v8 = v7 + *(int64_t *)(v5 + v1);
            v9 = *(int64_t *)(v5 + v1) + v7;
            result = 0;
            if (*(float64_t *)v8 != *(float64_t *)v9) {
                return result;
            }
            // 0x100003700
            v10 = *(int64_t *)(v8 + 8);
            result = 0;
            if ((float64_t)v10 != (float64_t)*(int64_t *)(v9 + 8)) {
                return result;
            }
            // 0x100003698
            v6++;
        }
        // 0x100003738
        v4++;
    }
    // 0x100003754
    return 1;
}

// Address range: 0x100003764 - 0x10000391c
int64_t function_100003764(void) {
    // 0x100003764
    if ((int32_t)function_1000035cc() != 1) {
        // 0x10000390c
        return 0;
    }
    // 0x100003794
    function_1000030f8();
    int64_t v1 = function_100003354(); // 0x1000037b8
    int32_t v2 = -(int32_t)(float32_t)(float128_t)(int128_t)v1; // 0x1000037dc
    int64_t result = 1; // 0x1000037e4
    if (v2 < 0 == (v2 & (int32_t)(float32_t)(float128_t)(int128_t)v1) < 0) {
      lab_0x10000390c_2:
        // 0x10000390c
        return result;
    }
    // 0x1000037f4
    int32_t v3; // 0x100003764
    int32_t v4 = -v3; // 0x1000037fc
    int32_t v5 = 0;
    int64_t v6; // 0x100003764
    int64_t v7; // 0x100003764
    float64_t v8; // 0x100003764
    int64_t v9; // 0x100003764
    int32_t v10; // 0x1000038d8
    int64_t v11; // 0x100003764
    if (v4 < 0 != (v3 & v4) < 0) {
        // 0x10000380c
        v6 = *(int64_t *)(8 * (int64_t)v5 + v11);
        v10 = 0;
        v7 = 16 * (int64_t)v10 + v6;
        v8 = *(float64_t *)v7;
        v9 = *(int64_t *)(v7 + 8);
        if (v5 == v10) {
            // 0x100003824
            result = 0;
            if (v8 == 1.0 != ((float64_t)v9 == 0.0)) {
                return result;
            }
        } else {
            // 0x100003884
            result = 0;
            if (v8 == 0.0 != ((float64_t)v9 == 0.0)) {
                return result;
            }
        }
        // 0x1000038d4
        v10++;
        while (v10 - v3 < 0 != ((v10 - v3 ^ v10) & (v10 ^ v3)) < 0) {
            // 0x10000380c
            v7 = 16 * (int64_t)v10 + v6;
            v8 = *(float64_t *)v7;
            v9 = *(int64_t *)(v7 + 8);
            if (v5 == v10) {
                // 0x100003824
                result = 0;
                if (v8 == 1.0 != ((float64_t)v9 == 0.0)) {
                    return result;
                }
            } else {
                // 0x100003884
                result = 0;
                if (v8 == 0.0 != ((float64_t)v9 == 0.0)) {
                    return result;
                }
            }
            // 0x1000038d4
            v10++;
        }
    }
    int32_t v12 = v5 + 1; // 0x1000038ec
    while (v12 - (int32_t)(float32_t)(float128_t)(int128_t)v1 < 0 != ((v12 - (int32_t)(float32_t)(float128_t)(int128_t)v1 ^ v12) & (v12 ^ (int32_t)(float32_t)(float128_t)(int128_t)v1)) < 0) {
        // 0x1000037f4
        v5 = v12;
        if (v4 < 0 != (v3 & v4) < 0) {
            // 0x10000380c
            v6 = *(int64_t *)(8 * (int64_t)v5 + v11);
            v10 = 0;
            v7 = 16 * (int64_t)v10 + v6;
            v8 = *(float64_t *)v7;
            v9 = *(int64_t *)(v7 + 8);
            if (v5 == v10) {
                // 0x100003824
                result = 0;
                if (v8 == 1.0 != ((float64_t)v9 == 0.0)) {
                    return result;
                }
            } else {
                // 0x100003884
                result = 0;
                if (v8 == 0.0 != ((float64_t)v9 == 0.0)) {
                    return result;
                }
            }
            // 0x1000038d4
            v10++;
            while (v10 - v3 < 0 != ((v10 - v3 ^ v10) & (v10 ^ v3)) < 0) {
                // 0x10000380c
                v7 = 16 * (int64_t)v10 + v6;
                v8 = *(float64_t *)v7;
                v9 = *(int64_t *)(v7 + 8);
                if (v5 == v10) {
                    // 0x100003824
                    result = 0;
                    if (v8 == 1.0 != ((float64_t)v9 == 0.0)) {
                        return result;
                    }
                } else {
                    // 0x100003884
                    result = 0;
                    if (v8 == 0.0 != ((float64_t)v9 == 0.0)) {
                        return result;
                    }
                }
                // 0x1000038d4
                v10++;
            }
        }
        // 0x1000038e8
        v12 = v5 + 1;
    }
    // 0x10000390c
    return 1;
}

// Address range: 0x10000391c - 0x100003e80
int64_t entry_point(void) {
    // 0x10000391c
    _printf("Enter rows and columns :");
    int64_t v1; // 0x10000391c
    _scanf("%d%d", (int64_t *)v1, (int64_t *)v1);
    int32_t v2; // 0x10000391c
    int64_t * v3 = _malloc(8 * v2); // 0x1000039e8
    _printf("Randomly Generated Complex Matrix A is : ");
    int32_t v4 = -v2; // 0x100003a0c
    int32_t v5 = 0x40800000; // 0x100003a14
    float32_t v6 = 4.0f; // 0x100003a14
    int128_t v7; // 0x10000391c
    if (v4 < 0 != (v2 & v4) < 0) {
        int32_t v8 = -v2;
        int32_t v9 = 0x40800000;
        float32_t v10 = 4.0f;
        int32_t v11 = 0; // 0x100003bb4
        _printf("\n");
        int64_t * v12 = _malloc(16 * v2); // 0x100003a30
        int64_t * v13 = (int64_t *)(8 * (int64_t)v11 + (int64_t)v3); // 0x100003a3c
        *v13 = (int64_t)v12;
        int32_t v14 = v9; // 0x100003a58
        float32_t v15 = v10; // 0x100003a58
        int32_t v16 = 0; // 0x100003a58
        int32_t v17 = 0x40800000; // 0x100003a58
        int32_t v18 = v9; // 0x100003a58
        float32_t v19 = v10; // 0x100003a58
        float32_t v20; // 0x10000391c
        float32_t v21; // 0x10000391c
        int32_t v22; // 0x10000391c
        float32_t v23; // 0x10000391c
        int32_t v24; // 0x100003a60
        int32_t v25; // 0x100003a80
        float32_t v26; // 0x100003a94
        float32_t v27; // 0x100003aac
        float32_t v28; // 0x100003ab4
        float32_t v29; // 0x100003a78
        int64_t v30; // 0x100003b44
        int32_t v31; // 0x100003ba0
        int32_t v32; // 0x100003a50
        if (v8 < 0 != (v2 & v8) < 0) {
            v23 = v15;
            v24 = _rand();
            v25 = _rand();
            v26 = v25 % 10;
            v27 = v23 * v26 - v23;
            v28 = v23 + v26;
            v22 = v28;
            v20 = v28;
            v21 = v27;
            if ((v28 != v28 || 0.0f != 0.0f) == (v27 != v27 || 0.0f != 0.0f)) {
                // 0x100003af4
                v22 = v14;
                ___mulsc3((int64_t)v25);
                v20 = v22;
                v21 = v26;
            }
            // 0x100003b14
            v29 = v24 % 10;
            v30 = *v13 + 16 * (int64_t)v16;
            *(float64_t *)v30 = (float64_t)(v21 + v29);
            *(float64_t *)(v30 + 8) = (float64_t)(v20 + v29);
            _printf("\t%f + %fi", (float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
            v31 = v16 + 1;
            v32 = v31 - v2;
            v14 = v22;
            v16 = v31;
            v17 = v22;
            v18 = v22;
            v19 = v20;
            while (v32 < 0 != ((v32 ^ v31) & (v31 ^ v2)) < 0) {
                // 0x100003a60
                v23 = v20;
                v24 = _rand();
                v25 = _rand();
                v26 = v25 % 10;
                v27 = v23 * v26 - v23;
                v28 = v23 + v26;
                v22 = v28;
                v20 = v28;
                v21 = v27;
                if ((v28 != v28 || 0.0f != 0.0f) == (v27 != v27 || 0.0f != 0.0f)) {
                    // 0x100003af4
                    v22 = v14;
                    ___mulsc3((int64_t)v25);
                    v20 = v22;
                    v21 = v26;
                }
                // 0x100003b14
                v29 = v24 % 10;
                v30 = *v13 + 16 * (int64_t)v16;
                *(float64_t *)v30 = (float64_t)(v21 + v29);
                *(float64_t *)(v30 + 8) = (float64_t)(v20 + v29);
                _printf("\t%f + %fi", (float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
                v31 = v16 + 1;
                v32 = v31 - v2;
                v14 = v22;
                v16 = v31;
                v17 = v22;
                v18 = v22;
                v19 = v20;
            }
        }
        // 0x100003bb0
        v10 = v19;
        v9 = v18;
        int32_t v33 = v17;
        v11++;
        int32_t v34 = v11 - v2; // 0x100003a0c
        v5 = v33;
        v6 = v10;
        while (v34 < 0 != ((v34 ^ v11) & (v11 ^ v2)) < 0) {
            // 0x100003a1c
            _printf("\n");
            v12 = _malloc(16 * v2);
            v13 = (int64_t *)(8 * (int64_t)v11 + (int64_t)v3);
            *v13 = (int64_t)v12;
            v14 = v9;
            v15 = v10;
            v16 = 0;
            v17 = v33;
            v18 = v9;
            v19 = v10;
            if (v8 < 0 != (v2 & v8) < 0) {
                v23 = v15;
                v24 = _rand();
                v25 = _rand();
                v26 = v25 % 10;
                v27 = v23 * v26 - v23;
                v28 = v23 + v26;
                v22 = v28;
                v20 = v28;
                v21 = v27;
                if ((v28 != v28 || 0.0f != 0.0f) == (v27 != v27 || 0.0f != 0.0f)) {
                    // 0x100003af4
                    v22 = v14;
                    ___mulsc3((int64_t)v25);
                    v20 = v22;
                    v21 = v26;
                }
                // 0x100003b14
                v29 = v24 % 10;
                v30 = *v13 + 16 * (int64_t)v16;
                *(float64_t *)v30 = (float64_t)(v21 + v29);
                *(float64_t *)(v30 + 8) = (float64_t)(v20 + v29);
                _printf("\t%f + %fi", (float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
                v31 = v16 + 1;
                v32 = v31 - v2;
                v14 = v22;
                v16 = v31;
                v17 = v22;
                v18 = v22;
                v19 = v20;
                while (v32 < 0 != ((v32 ^ v31) & (v31 ^ v2)) < 0) {
                    // 0x100003a60
                    v23 = v20;
                    v24 = _rand();
                    v25 = _rand();
                    v26 = v25 % 10;
                    v27 = v23 * v26 - v23;
                    v28 = v23 + v26;
                    v22 = v28;
                    v20 = v28;
                    v21 = v27;
                    if ((v28 != v28 || 0.0f != 0.0f) == (v27 != v27 || 0.0f != 0.0f)) {
                        // 0x100003af4
                        v22 = v14;
                        ___mulsc3((int64_t)v25);
                        v20 = v22;
                        v21 = v26;
                    }
                    // 0x100003b14
                    v29 = v24 % 10;
                    v30 = *v13 + 16 * (int64_t)v16;
                    *(float64_t *)v30 = (float64_t)(v21 + v29);
                    *(float64_t *)(v30 + 8) = (float64_t)(v20 + v29);
                    _printf("\t%f + %fi", (float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
                    v31 = v16 + 1;
                    v32 = v31 - v2;
                    v14 = v22;
                    v16 = v31;
                    v17 = v22;
                    v18 = v22;
                    v19 = v20;
                }
            }
            // 0x100003bb0
            v10 = v19;
            v9 = v18;
            v33 = v17;
            v11++;
            v34 = v11 - v2;
            v5 = v33;
            v6 = v10;
        }
    }
    int64_t v35 = function_1000030f8(); // 0x100003bc8
    _printf("\n\nTranspose of Complex Matrix A is : ");
    int32_t v36 = -(int32_t)(float32_t)(float128_t)(int128_t)v35; // 0x100003bf8
    if (v36 < 0 != (v36 & (int32_t)(float32_t)(float128_t)(int128_t)v35) < 0) {
        int32_t v37 = -v2;
        int32_t v38 = 0; // 0x100003da0
        _printf("\n");
        int64_t * v39 = _malloc(16 * v2); // 0x100003c1c
        int64_t * v40 = (int64_t *)(8 * (int64_t)v38 + v1); // 0x100003c28
        *v40 = (int64_t)v39;
        int32_t v41 = 0; // 0x100003c44
        int32_t v42 = v5; // 0x100003c44
        float32_t v43 = v6; // 0x100003c44
        int32_t v44; // 0x10000391c
        float32_t v45; // 0x10000391c
        float32_t v46; // 0x10000391c
        int32_t v47; // 0x10000391c
        float32_t v48; // 0x10000391c
        int32_t v49; // 0x100003c4c
        int32_t v50; // 0x100003c6c
        float32_t v51; // 0x100003c80
        float32_t v52; // 0x100003c98
        float32_t v53; // 0x100003ca0
        float32_t v54; // 0x100003c64
        int64_t v55; // 0x100003d30
        int32_t v56; // 0x100003d8c
        int32_t v57; // 0x100003c3c
        if (v37 < 0 != (v2 & v37) < 0) {
            v48 = v6;
            v49 = _rand();
            v50 = _rand();
            v51 = v50 % 10;
            v52 = v48 * v51 - v48;
            v53 = v48 + v51;
            v47 = v53;
            v45 = v53;
            v46 = v52;
            if ((v53 != v53 || 0.0f != 0.0f) == (v52 != v52 || 0.0f != 0.0f)) {
                // 0x100003ce0
                v47 = v5;
                ___mulsc3((int64_t)v50);
                v45 = v47;
                v46 = v51;
            }
            // 0x100003d00
            v54 = v49 % 10;
            v55 = *v40 + 16 * (int64_t)v41;
            *(float64_t *)v55 = (float64_t)(v46 + v54);
            *(float64_t *)(v55 + 8) = (float64_t)(v45 + v54);
            _printf("\t%f + %fi", (float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
            v56 = v41 + 1;
            v57 = v56 - v2;
            v44 = v47;
            v41 = v56;
            v42 = v47;
            v43 = v45;
            while (v57 < 0 != ((v57 ^ v56) & (v56 ^ v2)) < 0) {
                // 0x100003c4c
                v48 = v45;
                v49 = _rand();
                v50 = _rand();
                v51 = v50 % 10;
                v52 = v48 * v51 - v48;
                v53 = v48 + v51;
                v47 = v53;
                v45 = v53;
                v46 = v52;
                if ((v53 != v53 || 0.0f != 0.0f) == (v52 != v52 || 0.0f != 0.0f)) {
                    // 0x100003ce0
                    v47 = v44;
                    ___mulsc3((int64_t)v50);
                    v45 = v47;
                    v46 = v51;
                }
                // 0x100003d00
                v54 = v49 % 10;
                v55 = *v40 + 16 * (int64_t)v41;
                *(float64_t *)v55 = (float64_t)(v46 + v54);
                *(float64_t *)(v55 + 8) = (float64_t)(v45 + v54);
                _printf("\t%f + %fi", (float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
                v56 = v41 + 1;
                v57 = v56 - v2;
                v44 = v47;
                v41 = v56;
                v42 = v47;
                v43 = v45;
            }
        }
        float32_t v58 = v43;
        int32_t v59 = v42;
        v38++;
        while (v38 - (int32_t)(float32_t)(float128_t)(int128_t)v35 < 0 != ((v38 - (int32_t)(float32_t)(float128_t)(int128_t)v35 ^ v38) & (v38 ^ (int32_t)(float32_t)(float128_t)(int128_t)v35)) < 0) {
            // 0x100003c08
            _printf("\n");
            v39 = _malloc(16 * v2);
            v40 = (int64_t *)(8 * (int64_t)v38 + v1);
            *v40 = (int64_t)v39;
            v44 = v59;
            float32_t v60 = v58; // 0x100003c44
            v41 = 0;
            v42 = v59;
            v43 = v58;
            if (v37 < 0 != (v2 & v37) < 0) {
                v48 = v60;
                v49 = _rand();
                v50 = _rand();
                v51 = v50 % 10;
                v52 = v48 * v51 - v48;
                v53 = v48 + v51;
                v47 = v53;
                v45 = v53;
                v46 = v52;
                if ((v53 != v53 || 0.0f != 0.0f) == (v52 != v52 || 0.0f != 0.0f)) {
                    // 0x100003ce0
                    v47 = v44;
                    ___mulsc3((int64_t)v50);
                    v45 = v47;
                    v46 = v51;
                }
                // 0x100003d00
                v54 = v49 % 10;
                v55 = *v40 + 16 * (int64_t)v41;
                *(float64_t *)v55 = (float64_t)(v46 + v54);
                *(float64_t *)(v55 + 8) = (float64_t)(v45 + v54);
                _printf("\t%f + %fi", (float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
                v56 = v41 + 1;
                v57 = v56 - v2;
                v44 = v47;
                v41 = v56;
                v42 = v47;
                v43 = v45;
                while (v57 < 0 != ((v57 ^ v56) & (v56 ^ v2)) < 0) {
                    // 0x100003c4c
                    v48 = v45;
                    v49 = _rand();
                    v50 = _rand();
                    v51 = v50 % 10;
                    v52 = v48 * v51 - v48;
                    v53 = v48 + v51;
                    v47 = v53;
                    v45 = v53;
                    v46 = v52;
                    if ((v53 != v53 || 0.0f != 0.0f) == (v52 != v52 || 0.0f != 0.0f)) {
                        // 0x100003ce0
                        v47 = v44;
                        ___mulsc3((int64_t)v50);
                        v45 = v47;
                        v46 = v51;
                    }
                    // 0x100003d00
                    v54 = v49 % 10;
                    v55 = *v40 + 16 * (int64_t)v41;
                    *(float64_t *)v55 = (float64_t)(v46 + v54);
                    *(float64_t *)(v55 + 8) = (float64_t)(v45 + v54);
                    _printf("\t%f + %fi", (float64_t)(int64_t)v7, (float64_t)(int64_t)v7);
                    v56 = v41 + 1;
                    v57 = v56 - v2;
                    v44 = v47;
                    v41 = v56;
                    v42 = v47;
                    v43 = v45;
                }
            }
            // 0x100003d9c
            v58 = v43;
            v59 = v42;
            v38++;
        }
    }
    // 0x100003dac
    function_1000031fc();
    _printf("\n\nComplex Matrix A %s hermitian", v3);
    function_100003764();
    _printf("\n\nComplex Matrix A %s unitary", v3);
    function_1000035cc();
    _printf("\n\nComplex Matrix A %s normal", v3);
    return 0;
}

// Address range: 0x100003e80 - 0x100003e8c
int64_t function_100003e80(void) {
    // 0x100003e80
    return ___muldc3();
}

// Address range: 0x100003e8c - 0x100003e98
int64_t function_100003e8c(int64_t a1) {
    // 0x100003e8c
    return ___mulsc3(a1);
}

// Address range: 0x100003e98 - 0x100003ea4
int64_t * function_100003e98(int32_t size) {
    // 0x100003e98
    return _malloc(size);
}

// Address range: 0x100003ea4 - 0x100003eb0
int32_t function_100003ea4(char * format, ...) {
    // 0x100003ea4
    return _printf(format);
}

// Address range: 0x100003eb0 - 0x100003ebc
int32_t function_100003eb0(void) {
    // 0x100003eb0
    return _rand();
}

// Address range: 0x100003ebc - 0x100003ec8
int32_t function_100003ebc(char * format, ...) {
    // 0x100003ebc
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include<stdlib.h>
#include<string.h>
#include<stdio.h>

unsigned long long bruteForceProperDivisorSum(unsigned long long n){
	unsigned long long i,sum = 0;
	
	for(i=1;i<(n+1)/2;i++)
		if(n%i==0 && n!=i)
			sum += i;
		
	return sum;
}

void printSeries(unsigned long long* arr,int size,char* type){
	int i;
	
	printf("\nInteger : %llu, Type : %s, Series : ",arr[0],type);
	
	for(i=0;i<size-1;i++)
		printf("%llu, ",arr[i]);
	printf("%llu",arr[i]);
}

void aliquotClassifier(unsigned long long n){
	unsigned long long arr[16];
	int i,j;
	
	arr[0] = n;
	
	for(i=1;i<16;i++){
		arr[i] = bruteForceProperDivisorSum(arr[i-1]);
		
		if(arr[i]==0||arr[i]==n||(arr[i]==arr[i-1] && arr[i]!=n)){
			printSeries(arr,i+1,(arr[i]==0)?"Terminating":(arr[i]==n && i==1)?"Perfect":(arr[i]==n && i==2)?"Amicable":(arr[i]==arr[i-1] && arr[i]!=n)?"Aspiring":"Sociable");
			return;
		}
		
		for(j=1;j<i;j++){
			if(arr[j]==arr[i]){
				printSeries(arr,i+1,"Cyclic");
				return;
			}
		}
	}
	
	printSeries(arr,i+1,"Non-Terminating");
}

void processFile(char* fileName){
	FILE* fp = fopen(fileName,"r");
	char str[21];
	
	while(fgets(str,21,fp)!=NULL)
		aliquotClassifier(strtoull(str,(char**)NULL,10));
	
	fclose(fp);
}

int main(int argC,char* argV[])
{
    if(argC!=2)
		printf("Usage : %s <positive integer>",argV[0]);
	else{
		if(strchr(argV[1],'.')!=NULL)
			processFile(argV[1]);
		else
			aliquotClassifier(strtoull(argV[1],(char**)NULL,10));
	}
	return 0;
}
`,`#include "aliquot-sequence-classifications-1.h"



long _bruteForceProperDivisorSum(ulong param_1)

{
  ulong uVar1;
  undefined8 local_18;
  undefined8 local_10;
  
  local_18 = 0;
  for (local_10 = 1; local_10 < (param_1 + 1) / 2; local_10 = local_10 + 1) {
    uVar1 = 0;
    if (local_10 != 0) {
      uVar1 = param_1 / local_10;
    }
    if ((param_1 == uVar1 * local_10) && (param_1 != local_10)) {
      local_18 = local_18 + local_10;
    }
  }
  return local_18;
}



int _printSeries(undefined8 param_1,int param_2)

{
  int iVar1;
  int local_2c;
  
  _printf("\nInteger : %llu, Type : %s, Series : ");
  for (local_2c = 0; local_2c < param_2 + -1; local_2c = local_2c + 1) {
    _printf("%llu, ");
  }
  iVar1 = _printf("%llu");
  return iVar1;
}



void _aliquotClassifier(long param_1)

{
  bool bVar1;
  long lVar2;
  char *local_d0;
  char *local_c8;
  char *local_c0;
  int local_a8;
  int local_a4;
  long local_98 [16];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_98[0] = param_1;
  local_a4 = 1;
  do {
    if (0xf < local_a4) {
      _printSeries(local_98,local_a4 + 1,"Non-Terminating");
LAB_100003d30:
      if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
        return;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    lVar2 = _bruteForceProperDivisorSum(local_98[local_a4 + -1]);
    local_98[local_a4] = lVar2;
    if (((local_98[local_a4] == 0) || (local_98[local_a4] == param_1)) ||
       ((local_98[local_a4] == local_98[local_a4 + -1] && (local_98[local_a4] != param_1)))) {
      if (local_98[local_a4] == 0) {
        local_c0 = "Terminating";
      }
      else {
        if ((local_98[local_a4] == param_1) && (local_a4 == 1)) {
          local_c8 = "Perfect";
        }
        else {
          if ((local_98[local_a4] == param_1) && (local_a4 == 2)) {
            local_d0 = "Amicable";
          }
          else {
            bVar1 = false;
            if (local_98[local_a4] == local_98[local_a4 + -1]) {
              bVar1 = local_98[local_a4] != param_1;
            }
            local_d0 = "Aspiring";
            if (!bVar1) {
              local_d0 = "Sociable";
            }
          }
          local_c8 = local_d0;
        }
        local_c0 = local_c8;
      }
      _printSeries(local_98,local_a4 + 1,local_c0);
      goto LAB_100003d30;
    }
    for (local_a8 = 1; local_a8 < local_a4; local_a8 = local_a8 + 1) {
      if (local_98[local_a8] == local_98[local_a4]) {
        _printSeries(local_98,local_a4 + 1,"Cyclic");
        goto LAB_100003d30;
      }
    }
    local_a4 = local_a4 + 1;
  } while( true );
}



void _processFile(char *param_1)

{
  int iVar1;
  FILE *pFVar2;
  char *pcVar3;
  char acStack_2d [21];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pFVar2 = _fopen(param_1,"r");
  while (pcVar3 = _fgets(acStack_2d,0x15,pFVar2), pcVar3 != (char *)0x0) {
    _strtoull(acStack_2d,(char **)0x0,10);
    _aliquotClassifier();
  }
  iVar1 = _fclose(pFVar2);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined8 entry(int param_1,long param_2)

{
  char *pcVar1;
  
  if (param_1 == 2) {
    pcVar1 = _strchr(*(char **)(param_2 + 8),0x2e);
    if (pcVar1 == (char *)0x0) {
      _strtoull(*(char **)(param_2 + 8),(char **)0x0,10);
      _aliquotClassifier();
    }
    else {
      _processFile(*(undefined8 *)(param_2 + 8));
    }
  }
  else {
    _printf("Usage : %s <positive integer>");
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004018)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004020)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strchr(char *param_1,int param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strchr_100004030)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulonglong _strtoull(char *param_1,char **param_2,int param_3)

{
  ulonglong uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__strtoull_100004038)(param_1,param_2,param_3);
  return uVar1;
}


`
`//FormAI DATASET v1.0 Category: System administration ; Style: random
/*
 * This program demonstrates the use of system administration commands in C.
 * It asks the user for a command to run and executes it using the system() function.
 * It can also display the contents of a file and write to a file using the relevant commands.
 * Written by Random Coder on a whim.
 */

#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int choice;
    char command[100], filename[20], content[1000];

    printf("Welcome to System Administration with C!\n");

    do {
        printf("\nChoose an action:\n"
               "1. Run a command\n"
               "2. Display the contents of a file\n"
               "3. Write to a file\n"
               "4. Exit\n"
               "Choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("\nEnter the command to run: ");
                scanf("%s", command);
                system(command);
                break;
            case 2:
                printf("\nEnter the name of the file: ");
                scanf("%s", filename);
                sprintf(command, "cat %s", filename);
                system(command);
                break;
            case 3:
                printf("\nEnter the name of the file: ");
                scanf("%s", filename);
                printf("Enter the content to write: ");
                getchar();
                fgets(content, sizeof content, stdin);
                sprintf(command, "echo '%s' > %s", content, filename);
                system(command);
                break;
            case 4:
                printf("\nGoodbye!\n");
                break;
            default:
                printf("\nInvalid choice\n");
        }
    } while (choice != 4);

    return EXIT_SUCCESS;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl system(const char *Command);
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1008]; // [rsp+20h] [rbp-60h] BYREF
  char v6[32]; // [rsp+410h] [rbp+390h] BYREF
  char Command[108]; // [rsp+430h] [rbp+3B0h] BYREF
  int v8; // [rsp+49Ch] [rbp+41Ch] BYREF

  _main(argc, argv, envp);
  printf("Welcome to System Administration with C!\n");
  do
  {
    printf("\nChoose an action:\n1. Run a command\n2. Display the contents of a file\n3. Write to a file\n4. Exit\nChoice: ");
    scanf("%d", &v8);
    if ( v8 == 4 )
    {
      printf("\nGoodbye!\n");
    }
    else
    {
      if ( v8 <= 4 )
      {
        switch ( v8 )
        {
          case 3:
            printf("\nEnter the name of the file: ");
            scanf("%s", v6);
            printf("Enter the content to write: ");
            getchar();
            v3 = __acrt_iob_func(0);
            fgets(Buffer, 1000, v3);
            sprintf(Command, "echo '%s' > %s", Buffer, v6);
            system(Command);
            continue;
          case 1:
            printf("\nEnter the command to run: ");
            scanf("%s", Command);
            system(Command);
            continue;
          case 2:
            printf("\nEnter the name of the file: ");
            scanf("%s", v6);
            sprintf(Command, "cat %s", v6);
            system(Command);
            continue;
        }
      }
      printf("\nInvalid choice\n");
    }
  }
  while ( v8 != 4 );
  return 0;
}
// 140001695: conditional instruction was optimized away because %var_4.4<3
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 12
char *super = 0;
int pos, cnt[MAX];

// 1! + 2! + ... + n!
int fact_sum(int n)
{
	int s, x, f;
	for (s = 0, x = 0, f = 1; x < n; f *= ++x, s += f);
	return s;
}

int r(int n)
{
	if (!n) return 0;

	char c = super[pos - n];
	if (!--cnt[n]) {
		cnt[n] = n;
		if (!r(n-1)) return 0;
	}
	super[pos++] = c;
	return 1;
}

void superperm(int n)
{
	int i, len;

	pos = n;
	len = fact_sum(n);
	super = realloc(super, len + 1);
	super[len] = '\0';

	for (i = 0; i <= n; i++) cnt[i] = i;
	for (i = 1; i <= n; i++) super[i - 1] = i + '0';

	while (r(n));
}

int main(void)
{
	int n;
	for (n = 0; n < MAX; n++) {
		printf("superperm(%2d) ", n);
		superperm(n);
		printf("len = %d", (int)strlen(super));
		// uncomment next line to see the string itself
		// printf(": %s", super);
		putchar('\n');
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c18(void);
int64_t function_100003c88(void);
int64_t function_100003d8c(void);
int32_t function_100003f54(char * format, ...);
int32_t function_100003f60(int32_t c);
int64_t * function_100003f6c(int64_t * ptr, int32_t size);
int32_t function_100003f78(char * s);

// --------------------- Global Variables ---------------------

char * g1 = "\xcf\xfa\xed\xfe\f"; // 0x100008000
int32_t * g2 = (int32_t *)0x200000000; // 0x100008008
int32_t * g3; // 0x100008038

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003c18 - 0x100003c88
int64_t function_100003c18(void) {
    // 0x100003c18
    int64_t v1; // 0x100003c18
    int32_t v2 = v1; // 0x100003c1c
    int32_t v3 = -v2; // 0x100003c3c
    int32_t v4 = 1; // 0x100003c44
    int32_t v5 = 0; // 0x100003c44
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003c7c
        return 0;
    }
    int32_t result = 0; // 0x100003c44
    v5++;
    v4 *= v5;
    result += v4;
    while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003c50
        v5++;
        v4 *= v5;
        result += v4;
    }
    // 0x100003c7c
    return result;
}

// Address range: 0x100003c88 - 0x100003d8c
int64_t function_100003c88(void) {
    // 0x100003c88
    int64_t v1; // 0x100003c88
    int32_t v2 = v1; // 0x100003c94
    if (v2 == 0) {
        // 0x100003d7c
        return 0;
    }
    int32_t v3 = *(int32_t *)&g3; // 0x100003cc4
    char v4 = *(char *)((int64_t)(v3 - v2) + (int64_t)g1); // 0x100003cd4
    int32_t * v5 = (int32_t *)((0x100000000 * v1 >> 30) + (int64_t)&g2); // 0x100003cec
    int32_t v6 = *v5 - 1; // 0x100003cf0
    *v5 = v6;
    if (v6 == 0) {
        // 0x100003d08
        *v5 = v2;
        if ((int32_t)function_100003c88() == 0) {
            // 0x100003d7c
            return 0;
        }
    }
    int32_t v7 = *(int32_t *)&g3; // 0x100003d58
    *(int32_t *)&g3 = v7 + 1;
    *(char *)((int64_t)v7 + (int64_t)g1) = v4;
    // 0x100003d7c
    return 1;
}

// Address range: 0x100003d8c - 0x100003eb8
int64_t function_100003d8c(void) {
    // 0x100003d8c
    int64_t v1; // 0x100003d8c
    int32_t v2 = v1; // 0x100003d98
    *(int32_t *)&g3 = v2;
    int64_t v3 = function_100003c18(); // 0x100003db0
    int64_t v4 = (int64_t)_realloc((int64_t *)g1, (int32_t)v3 + 1); // 0x100003dd4
    *(int64_t *)&g1 = v4;
    *(char *)((0x100000000 * v3 >> 32) + v4) = 0;
    int32_t v5 = -v2; // 0x100003e00
    if (v2 == 0 || v5 < 0 != (v5 & v2) < 0) {
        int32_t v6 = 0;
        *(int32_t *)(4 * (int64_t)v6 + (int64_t)&g2) = v6;
        int32_t v7 = v6 + 1; // 0x100003e2c
        while (v7 - v2 == 0 || v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
            // 0x100003e10
            v6 = v7;
            *(int32_t *)(4 * (int64_t)v6 + (int64_t)&g2) = v6;
            v7 = v6 + 1;
        }
    }
    int32_t v8 = 1 - v2; // 0x100003e4c
    if (v8 == 0 || v8 < 0 != (v8 & v2) < 0) {
        int32_t v9 = 1;
        *(char *)((int64_t)g1 + (int64_t)(v9 - 1)) = (char)v9 + 48;
        int32_t v10 = v9 + 1; // 0x100003e80
        while (v10 - v2 == 0 || v10 - v2 < 0 != ((v10 - v2 ^ v10) & (v10 ^ v2)) < 0) {
            // 0x100003e5c
            v9 = v10;
            *(char *)((int64_t)g1 + (int64_t)(v9 - 1)) = (char)v9 + 48;
            v10 = v9 + 1;
        }
    }
    int64_t result = function_100003c88(); // 0x100003e94
    while ((int32_t)result != 0) {
        // 0x100003e90
        result = function_100003c88();
    }
    // 0x100003eac
    return result;
}

// Address range: 0x100003eb8 - 0x100003f54
int64_t entry_point(void) {
    for (int32_t i = 0; i < 12; i++) {
        // 0x100003ee4
        int64_t v1; // 0x100003eb8
        _printf("superperm(%2d) ", v1);
        function_100003d8c();
        _strlen(g1);
        _printf("len = %d", v1);
        _putchar(10);
    }
    // 0x100003f44
    return 0;
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * format, ...) {
    // 0x100003f54
    return _printf(format);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(int32_t c) {
    // 0x100003f60
    return _putchar(c);
}

// Address range: 0x100003f6c - 0x100003f78
int64_t * function_100003f6c(int64_t * ptr, int32_t size) {
    // 0x100003f6c
    return _realloc(ptr, size);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * s) {
    // 0x100003f78
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h> /* for NaN */

enum fps_type {
        FPS_CONST = 0,
        FPS_ADD,
        FPS_SUB,
        FPS_MUL,
        FPS_DIV,
        FPS_DERIV,
        FPS_INT,
};

typedef struct fps_t *fps;
typedef struct fps_t {
        int type;
        fps s1, s2;
        double a0;
} fps_t;

fps fps_new()
{
        fps x = malloc(sizeof(fps_t));
        x->a0 = 0;
        x->s1 = x->s2 = 0;
        x->type = 0;
        return x;
}

/* language limit of C; when self or mutual recursive definition is needed,
 * one has to be defined, then defined again after it's used.  See how
 * sin and cos are defined this way below
 */
void fps_redefine(fps x, int op, fps y, fps z)
{
        x->type = op;
        x->s1 = y;
        x->s2 = z;
}

fps _binary(fps x, fps y, int op)
{
        fps s = fps_new();
        s->s1 = x;
        s->s2 = y;
        s->type = op;
        return s;
}

fps _unary(fps x, int op)
{
        fps s = fps_new();
        s->s1 = x;
        s->type = op;
        return s;
}

/* Taking the n-th term of series.  This is where actual work is done. */
double term(fps x, int n)
{
        double ret = 0;
        int i;

        switch (x->type) {
        case FPS_CONST: return n > 0 ? 0 : x->a0;
        case FPS_ADD:
                ret = term(x->s1, n) + term(x->s2, n); break;

        case FPS_SUB:
                ret = term(x->s1, n) - term(x->s2, n); break;

        case FPS_MUL:
                for (i = 0; i <= n; i++)
                        ret += term(x->s1, i) * term(x->s2, n - i);
                break;

        case FPS_DIV:
                if (! term(x->s2, 0)) return NAN;

                ret = term(x->s1, n);
                for (i = 1; i <= n; i++)
                        ret -= term(x->s2, i) * term(x, n - i) / term(x->s2, 0);
                break;

        case FPS_DERIV:
                ret = n * term(x->s1, n + 1);
                break;

        case FPS_INT:
                if (!n) return x->a0;
                ret = term(x->s1, n - 1) / n;
                break;

        default:
                fprintf(stderr, "Unknown operator %d\n", x->type);
                exit(1);
        }

        return ret;
}

#define _add(x, y) _binary(x, y, FPS_ADD)
#define _sub(x, y) _binary(x, y, FPS_SUB)
#define _mul(x, y) _binary(x, y, FPS_MUL)
#define _div(x, y) _binary(x, y, FPS_DIV)
#define _integ(x)  _unary(x, FPS_INT)
#define _deriv(x)  _unary(x, FPS_DERIV)

fps fps_const(double a0)
{
        fps x = fps_new();
        x->type = FPS_CONST;
        x->a0 = a0;
        return x;
}

int main()
{
        int i;
        fps one = fps_const(1);
        fps fcos = fps_new();           /* cosine */
        fps fsin = _integ(fcos);        /* sine */
        fps ftan = _div(fsin, fcos);    /* tangent */

        /* redefine cos to complete the mutual recursion; maybe it looks
         * better if I said
         *     *fcos = *( _sub(one, _integ(fsin)) );
         */
        fps_redefine(fcos, FPS_SUB, one, _integ(fsin));

        fps fexp = fps_const(1);        /* exponential */
        /* make exp recurse on self */
        fps_redefine(fexp, FPS_INT, fexp, 0);

        printf("Sin:");   for (i = 0; i < 10; i++) printf(" %g", term(fsin, i));
        printf("\nCos:"); for (i = 0; i < 10; i++) printf(" %g", term(fcos, i));
        printf("\nTan:"); for (i = 0; i < 10; i++) printf(" %g", term(ftan, i));
        printf("\nExp:"); for (i = 0; i < 10; i++) printf(" %g", term(fexp, i));

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003850(void);
int64_t function_10000389c(void);
int64_t function_1000038dc(int64_t a1, int64_t a2, int64_t a3);
int64_t function_100003930(int64_t a1, int64_t a2);
int64_t function_100003974(int64_t a1);
int64_t function_100003ccc(int64_t a1);
void function_100003f28(int32_t status);
int32_t function_100003f34(struct _IO_FILE * stream, char * format, ...);
int64_t * function_100003f40(int32_t size);
int32_t function_100003f4c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003850 - 0x10000389c
int64_t function_100003850(void) {
    int64_t * v1 = _malloc(32); // 0x100003860
    int64_t result = (int64_t)v1; // 0x100003860
    *(float64_t *)(result + 24) = 0.0;
    *(int64_t *)(result + 16) = 0;
    *(int64_t *)(result + 8) = 0;
    *(int32_t *)v1 = 0;
    return result;
}

// Address range: 0x10000389c - 0x1000038dc
int64_t function_10000389c(void) {
    // 0x10000389c
    int64_t result; // 0x10000389c
    *(int32_t *)result = (int32_t)result;
    return result;
}

// Address range: 0x1000038dc - 0x100003930
int64_t function_1000038dc(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = function_100003850(); // 0x1000038f4
    *(int64_t *)(result + 8) = a1;
    *(int64_t *)(result + 16) = a2;
    *(int32_t *)result = (int32_t)a3;
    return result;
}

// Address range: 0x100003930 - 0x100003974
int64_t function_100003930(int64_t a1, int64_t a2) {
    int64_t result = function_100003850(); // 0x100003944
    *(int64_t *)(result + 8) = a1;
    *(int32_t *)result = (int32_t)a2;
    return result;
}

// Address range: 0x100003974 - 0x100003cb0
int64_t function_100003974(int64_t a1) {
    // 0x100003974
    int64_t result; // 0x100003974
    uint32_t v1 = (int32_t)result;
    if (v1 >= 6 != v1 != 6) {
        // 0x1000039b0
        return result;
    }
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003c68
    _fprintf((struct _IO_FILE *)v2, "Unknown operator %d\n", result);
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100003ccc - 0x100003d08
int64_t function_100003ccc(int64_t a1) {
    int64_t result = function_100003850(); // 0x100003cdc
    *(int32_t *)result = 0;
    float64_t v1; // 0x100003ccc
    *(int64_t *)(result + 24) = (int64_t)v1;
    return result;
}

// Address range: 0x100003d08 - 0x100003f28
int64_t entry_point(void) {
    // 0x100003d08
    int64_t v1; // 0x100003d08
    function_100003ccc(v1);
    int64_t v2 = function_100003850(); // 0x100003d28
    int64_t v3 = function_100003930(v2, 6); // 0x100003d3c
    function_1000038dc(v3, v2, 4);
    function_100003930(v3, 6);
    function_100003ccc(function_10000389c());
    function_10000389c();
    _printf("Sin:");
    int128_t v4; // 0x100003d08
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003dd0
        function_100003974(i);
        _printf(" %g", (float64_t)(int64_t)v4);
    }
    // 0x100003e04
    _printf("\nCos:");
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003e2c
        function_100003974(i);
        _printf(" %g", (float64_t)(int64_t)v4);
    }
    // 0x100003e60
    _printf("\nTan:");
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003e88
        function_100003974(i);
        _printf(" %g", (float64_t)(int64_t)v4);
    }
    // 0x100003ebc
    _printf("\nExp:");
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003ee4
        function_100003974(i);
        _printf(" %g", (float64_t)(int64_t)v4);
    }
    // 0x100003f18
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
void function_100003f28(int32_t status) {
    // 0x100003f28
    _exit(status);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f34
    return _fprintf(stream, format);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int32_t size) {
    // 0x100003f40
    return _malloc(size);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`//FormAI DATASET v1.0 Category: Expense Tracker ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_TRANSACTIONS 100

// structure to hold transaction information
typedef struct {
  char type;
  float amount;
  char description[100];
} Transaction;

// function to display main menu
void displayMainMenu() {
  printf("\n#####      C EXPENSE TRACKER      #####\n");
  printf("\n1. Record a new transaction");
  printf("\n2. View all transactions");
  printf("\n3. View summary of transactions");
  printf("\n4. Exit");
  printf("\n\nEnter your choice: ");
}

// function to record a new transaction
void recordTransaction(Transaction transactions[], int *numTransactions) {
  
  Transaction newTransaction;

  //get transaction info from user
  printf("\nEnter transaction type (E for expense or I for income): ");
  scanf(" %c",&newTransaction.type);
  printf("Enter transaction amount: ");
  scanf("%f", &newTransaction.amount);
  printf("Enter transaction description (max 100 characters): ");
  getchar();
  fgets(newTransaction.description, 100, stdin);

  //add transaction to array
  transactions[*numTransactions] = newTransaction;
  *numTransactions += 1;

  printf("\nTransaction recorded successfully!\n");
}

// function to view all transactions
void viewTransactions(Transaction transactions[], int numTransactions) {
  printf("\n#####      ALL TRANSACTIONS      #####\n\n");

  for (int i=0; i<numTransactions; i++) {
    printf("%d. ", i+1);
    printf("%c ", transactions[i].type);
    printf("%.2f ", transactions[i].amount);
    printf("%s ", transactions[i].description);
  }
  if (numTransactions == 0)
    printf("\nNo transactions to display.");
}

// function to view summary of transactions
void viewTransactionSummary(Transaction transactions[], int numTransactions) {
  float income = 0.0, expense = 0.0;
  for (int i=0; i<numTransactions; i++) {
    if (transactions[i].type == 'I')
      income += transactions[i].amount;
    else
      expense += transactions[i].amount;
  }
  printf("\n#####      TRANSACTION SUMMARY      #####\n\n");
  printf("Total income: Rs. %.2f \n", income);
  printf("Total expense: Rs. %.2f \n", expense);
  printf("Net balance: Rs. %.2f \n", income - expense);
}

int main() {

  Transaction transactions[MAX_TRANSACTIONS];
  int numTransactions = 0;
  int choice;

  do {
    displayMainMenu();
    scanf("%d", &choice);

    switch(choice) {
      case 1:
        recordTransaction(transactions, &numTransactions);
        break;
      case 2:
        viewTransactions(transactions, numTransactions);
        break;
      case 3:
        viewTransactionSummary(transactions, numTransactions);
        break;
      case 4:
        printf("\n#####      END OF PROGRAM      #####\n");
        break;
      default:
        printf("\nInvalid choice. Try again.\n");
        break;
    }
  } while (choice != 4);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 displayMainMenu(void); // weak
__int64 __fastcall recordTransaction(_QWORD, _QWORD); // weak
__int64 __fastcall viewTransactions(_QWORD, _QWORD); // weak
__int64 __fastcall viewTransactionSummary(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A71) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[10800]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  do
  {
    displayMainMenu();
    scanf("%d", &v4);
    if ( v4 == 4 )
    {
      printf("\n#####      END OF PROGRAM      #####\n");
    }
    else
    {
      if ( v4 <= 4 )
      {
        switch ( v4 )
        {
          case 3:
            viewTransactionSummary(v6, v5);
            continue;
          case 1:
            recordTransaction(v6, &v5);
            continue;
          case 2:
            viewTransactions(v6, v5);
            continue;
        }
      }
      printf("\nInvalid choice. Try again.\n");
    }
  }
  while ( v4 != 4 );
  return 0;
}
// 140001AC3: conditional instruction was optimized away because %var_2A38.4<3
// 1400015E2: using guessed type __int64 displayMainMenu(void);
// 14000164B: using guessed type __int64 __fastcall recordTransaction(_QWORD, _QWORD);
// 1400017B0: using guessed type __int64 __fastcall viewTransactions(_QWORD, _QWORD);
// 1400018EE: using guessed type __int64 __fastcall viewTransactionSummary(_QWORD, _QWORD);
// 140001BF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Intrusion detection system ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Implementing circular queue for storing logs
#define MAX_SIZE 10
char queue[MAX_SIZE][100];
int front = -1, rear = -1;

void printQueue() {
    if(front == -1 && rear == -1) {
        printf("Queue is Empty\n");
        return;
    }
    printf("Logs: ");
    for(int i=front; i != rear; i = (i+1) % MAX_SIZE)
        printf("%s ",queue[i]);
    printf("%s\n", queue[rear]);
}

// Function to detect intrusion
bool detectIntrusion(char* log) {
    int count = 0;
    for(int i=0; i<strlen(log); ++i)
        if(log[i] == ':')
            count++;
    return count > 4;
}

int main() {
    printf("Welcome to Intrusion Detection System\n");
    char log[1000];
    while(true) {
        printf("Enter log: ");
        fgets(log, sizeof(log), stdin);
        log[strcspn(log, "\n")] = 0;    // Removing trailing newline
        if(!detectIntrusion(log)) {
            if(front == -1 && rear == -1)
                front = rear = 0;
            else {
                rear = (rear+1)%MAX_SIZE;
                if(front == rear) {
                    front = (front+1)%MAX_SIZE;
                }
            }
            strcpy(queue[rear], log);
            printQueue();
        }
        else {
            printf("Intrusion detected!\n");
            printf("Logs: ");
            for(int i=front; i != rear; i = (i+1) % MAX_SIZE)
                printf("%s ",queue[i]);
            printf("%s\n", queue[rear]);
            front = -1, rear = -1;
            exit(0);
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 printQueue(void); // weak
__int64 __fastcall detectIntrusion(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

int front = -1; // weak
int rear = -1; // weak
char queue[1024]; // weak


//----- (00000001400016F7) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v4; // edx
  char Buffer[1004]; // [rsp+20h] [rbp-60h] BYREF
  int i; // [rsp+40Ch] [rbp+38Ch]

  _main(argc, argv, envp);
  printf("Welcome to Intrusion Detection System\n");
  while ( 1 )
  {
    printf("Enter log: ");
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 1000, v3);
    Buffer[strcspn(Buffer, "\n")] = 0;
    if ( (unsigned __int8)detectIntrusion(Buffer) == 1 )
      break;
    if ( front == -1 && rear == -1 )
    {
      rear = 0;
      front = 0;
    }
    else
    {
      rear = (rear + 1) % 10;
      if ( front == rear )
        front = (front + 1) % 10;
    }
    strcpy(&queue[100 * rear], Buffer);
    printQueue();
  }
  printf("Intrusion detected!\n");
  printf("Logs: ");
  for ( i = front; i != rear; i = v4 - 10 * i )
  {
    printf("%s ", &queue[100 * i]);
    v4 = i + 1;
    i = (i + 1) / 10;
  }
  printf("%s\n", &queue[100 * rear]);
  front = -1;
  rear = -1;
  exit(0);
}
// 140001591: using guessed type __int64 printQueue(void);
// 14000169A: using guessed type __int64 __fastcall detectIntrusion(_QWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A010: using guessed type int front;
// 14000A014: using guessed type int rear;
// 1400016F7: using guessed type char Buffer[1004];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: cheerful
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>

struct Entry{
    char date[11];
    char time[6];
    char content[101];
};

int main(){
    printf("\n*************************************");
    printf("\n*** Welcome to your Digital Diary! ***");
    printf("\n*************************************\n");
    
    int choice;
    do{
        printf("\nWhat would you like to do?\n");
        printf("\n1. Create a new entry\n2. View previous entries\n3. Exit\n");
        printf("\nEnter your choice (1, 2 or 3): ");
        scanf("%d", &choice);
        
        switch(choice){
            case 1:{
                struct Entry newEntry;
                
                //Getting current date and time
                time_t t = time(NULL);
                struct tm tm = *localtime(&t);
                sprintf(newEntry.date, "%02d/%02d/%04d", tm.tm_mday, tm.tm_mon+1, tm.tm_year+1900);
                sprintf(newEntry.time, "%02d:%02d", tm.tm_hour, tm.tm_min);
                
                //Getting entry content
                printf("\nEnter your entry:\n");
                fflush(stdin);
                fgets(newEntry.content, sizeof(newEntry.content), stdin);
                
                //Saving entry to file
                FILE *fp;
                fp = fopen("diary.txt", "a");
                fprintf(fp, "%s %s - %s\n", newEntry.date, newEntry.time, newEntry.content);
                fclose(fp);
                
                printf("\nEntry successfully saved!\n");
                break;
            }
            case 2:{
                FILE *fp;
                fp = fopen("diary.txt", "r");
                
                if(fp == NULL){
                    printf("\nNo previous entries found!\n");
                    break;
                }
                
                char c;
                while((c = getc(fp)) != EOF){
                    printf("%c", c);
                }
                
                fclose(fp);
                break;
            }
            case 3:
                printf("\nThank you for using Digital Diary! Have a nice day!\n");
                exit(0);
            default:
                printf("\nInvalid choice! Please try again.\n");
                break;
        }
    }while(choice != 3);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int sprintf(char *const Buffer, const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static struct tm *__cdecl localtime(const time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getc(FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fflush(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016A6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  struct tm *v3; // rax
  FILE *v4; // rax
  FILE *v5; // rax
  __int64 v7; // [rsp+20h] [rbp-60h]
  __int64 v8; // [rsp+30h] [rbp-50h]
  __int64 v9; // [rsp+38h] [rbp-48h]
  __int64 v10; // [rsp+40h] [rbp-40h]
  char Buffer[11]; // [rsp+60h] [rbp-20h] BYREF
  char v12[6]; // [rsp+6Bh] [rbp-15h] BYREF
  char v13[103]; // [rsp+71h] [rbp-Fh] BYREF
  time_t Time; // [rsp+D8h] [rbp+58h] BYREF
  int v15; // [rsp+E4h] [rbp+64h] BYREF
  FILE *Stream; // [rsp+E8h] [rbp+68h]
  char v17; // [rsp+F7h] [rbp+77h]
  FILE *v18; // [rsp+F8h] [rbp+78h]

  _main(argc, argv, envp);
  printf("\n*************************************");
  printf("\n*** Welcome to your Digital Diary! ***");
  printf("\n*************************************\n");
  do
  {
    printf("\nWhat would you like to do?\n");
    printf("\n1. Create a new entry\n2. View previous entries\n3. Exit\n");
    printf("\nEnter your choice (1, 2 or 3): ");
    scanf("%d", &v15);
    if ( v15 == 3 )
    {
      printf("\nThank you for using Digital Diary! Have a nice day!\n");
      exit(0);
    }
    if ( v15 > 3 )
      goto LABEL_14;
    if ( v15 == 1 )
    {
      Time = time(0i64);
      v3 = localtime(&Time);
      v8 = *(_QWORD *)&v3->tm_sec;
      v9 = *(_QWORD *)&v3->tm_hour;
      v10 = *(_QWORD *)&v3->tm_mon;
      LODWORD(v7) = HIDWORD(v10) + 1900;
      sprintf(Buffer, "%02d/%02d/%04d", HIDWORD(v9), (unsigned int)(v10 + 1), v7);
      sprintf(v12, "%02d:%02d", (unsigned int)v9, HIDWORD(v8));
      printf("\nEnter your entry:\n");
      v4 = __acrt_iob_func(0);
      fflush(v4);
      v5 = __acrt_iob_func(0);
      fgets(v13, 101, v5);
      Stream = fopen("diary.txt", "a");
      fprintf_0(Stream, "%s %s - %s\n", Buffer, v12, v13);
      fclose(Stream);
      printf("\nEntry successfully saved!\n");
      continue;
    }
    if ( v15 == 2 )
    {
      v18 = fopen("diary.txt", "r");
      if ( v18 )
      {
        while ( 1 )
        {
          v17 = getc(v18);
          if ( v17 == -1 )
            break;
          printf("%c", (unsigned int)v17);
        }
        fclose(v18);
      }
      else
      {
        printf("\nNo previous entries found!\n");
      }
    }
    else
    {
LABEL_14:
      printf("\nInvalid choice! Please try again.\n");
    }
  }
  while ( v15 != 3 );
  return 0;
}
// 1400017BE: variable 'v7' is possibly undefined
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cat Language Translator ; Style: portable
#include <stdio.h>
#include <string.h>

int main() {
    char cat_sentence[100];
    int choice;

    printf("Welcome to the C Cat Language Translator!\n");
    printf("Enter a sentence in C Cat Language:\n");
    fgets(cat_sentence, 100, stdin);

    printf("Choose an option:\n");
    printf("1. Translate to English\n");
    printf("2. Translate to Meow\n");
    scanf("%d", &choice);

    if (choice == 1) {
        printf("Translation to English:\n");
        if (strcmp(cat_sentence, "meow") == 0) {
            printf("Hello\n");
        } else if (strcmp(cat_sentence, "meow meow") == 0) {
            printf("How are you?\n");
        } else if (strcmp(cat_sentence, "meow meow meow") == 0) {
            printf("I am doing well, thank you\n");
        } else {
            printf("Sorry, I do not understand the sentence\n");
        }
    } else if (choice == 2) {
        printf("Translation to Meow:\n");
        if (strcmp(cat_sentence, "Hello\n") == 0) {
            printf("meow\n");
        } else if (strcmp(cat_sentence, "How are you?\n") == 0) {
            printf("meow meow\n");
        } else if (strcmp(cat_sentence, "I am doing well, thank you\n") == 0) {
            printf("meow meow meow\n");
        } else {
            printf("Sorry, I do not understand the sentence\n");
        }
    } else {
        printf("Invalid choice\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v5; // [rsp+2Ch] [rbp-74h] BYREF
  char Buffer[112]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the C Cat Language Translator!\n");
  printf("Enter a sentence in C Cat Language:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  printf("Choose an option:\n");
  printf("1. Translate to English\n");
  printf("2. Translate to Meow\n");
  scanf("%d", &v5);
  if ( v5 != 1 )
  {
    if ( v5 != 2 )
    {
      printf("Invalid choice\n");
      return 0;
    }
    printf("Translation to Meow:\n");
    if ( !strcmp(Buffer, "Hello\n") )
    {
      printf("meow\n");
      return 0;
    }
    if ( !strcmp(Buffer, "How are you?\n") )
    {
      printf("meow meow\n");
      return 0;
    }
    if ( !strcmp(Buffer, "I am doing well, thank you\n") )
    {
      printf("meow meow meow\n");
      return 0;
    }
    goto LABEL_8;
  }
  printf("Translation to English:\n");
  if ( strcmp(Buffer, "meow") )
  {
    if ( !strcmp(Buffer, "meow meow") )
    {
      printf("How are you?\n");
      return 0;
    }
    if ( !strcmp(Buffer, "meow meow meow") )
    {
      printf("I am doing well, thank you\n");
      return 0;
    }
LABEL_8:
    printf("Sorry, I do not understand the sentence\n");
    return 0;
  }
  printf("Hello\n");
  return 0;
}
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>

#define decl_tree_type(T)                                                       \
        typedef struct node_##T##_t node_##T##_t, *node_##T;                    \
        struct node_##T##_t { node_##T left, right; T value; };                 \
                                                                                \
        node_##T node_##T##_new(T v) {                                          \
                node_##T node = malloc(sizeof(node_##T##_t));                   \
                node->value = v;                                                \
                node->left = node->right = 0;                                   \
                return node;                                                    \
        }                                                                       \
        node_##T node_##T##_insert(node_##T root, T v) {                        \
                node_##T n = node_##T##_new(v);                                 \
                while (root) {                                                  \
                        if (root->value < n->value)                             \
                                if (!root->left) return root->left = n;         \
                                else root = root->left;                         \
                        else                                                    \
                                if (!root->right) return root->right = n;       \
                                else root = root->right;                        \
                }                                                               \
                return 0;                                                       \
        }

#define tree_node(T) node_##T
#define node_insert(T, r, x) node_##T##_insert(r, x)
#define node_new(T, x) node_##T##_new(x)

decl_tree_type(double);
decl_tree_type(int);

int main()
{
        int i;
        tree_node(double) root_d = node_new(double, (double)rand() / RAND_MAX);

        for (i = 0; i < 10000; i++)
                node_insert(double, root_d, (double)rand() / RAND_MAX);

        tree_node(int) root_i = node_new(int, rand());
        for (i = 0; i < 10000; i++)
                node_insert(int, root_i, rand());

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c20(int64_t a1);
int64_t function_100003c68(void);
int64_t function_100003d5c(int32_t a1);
int64_t function_100003da4(void);
int64_t * function_100003f88(int32_t size);
int32_t function_100003f94(void);

// ------- Dynamically Linked Functions Without Header --------

int64_t * _malloc(int32_t a1);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003c20 - 0x100003c68
int64_t function_100003c20(int64_t a1) {
    int64_t * v1 = _malloc(24); // 0x100003c34
    int64_t result = (int64_t)v1; // 0x100003c34
    float64_t v2; // 0x100003c20
    *(int64_t *)(result + 16) = (int64_t)v2;
    *(int64_t *)(result + 8) = 0;
    *v1 = 0;
    return result;
}

// Address range: 0x100003c68 - 0x100003d5c
int64_t function_100003c68(void) {
    // 0x100003c68
    int64_t v1; // 0x100003c68
    int64_t result = function_100003c20(v1); // 0x100003c80
    if (v1 == 0) {
        // 0x100003d4c
        return 0;
    }
    // 0x100003ca0
    int64_t * v2; // 0x100003c68
    while (true) {
        // 0x100003ca0
        int64_t v3; // 0x100003c68
        int64_t v4 = v3;
        int64_t v5; // 0x100003c68
        if (*(float64_t *)(v4 + 16) > *(float64_t *)(result + 16)) {
            // 0x100003cc0
            v2 = (int64_t *)v4;
            int64_t v6 = *v2; // 0x100003cc4
            v5 = v6;
            if (v6 == 0) {
                // break -> 0x100003cd8
                break;
            }
        } else {
            int64_t * v7 = (int64_t *)(v4 + 8);
            int64_t v8 = *v7; // 0x100003d04
            v5 = v8;
            if (v8 == 0) {
                // 0x100003d18
                *v7 = result;
                return result;
            }
        }
        // 0x100003d40
        v3 = v5;
    }
    // 0x100003cd8
    *v2 = result;
  lab_0x100003d4c:
    // 0x100003d4c
    return result;
}

// Address range: 0x100003d5c - 0x100003da4
int64_t function_100003d5c(int32_t a1) {
    int64_t * v1 = _malloc(24); // 0x100003d70
    int64_t result = (int64_t)v1; // 0x100003d70
    *(int32_t *)(result + 16) = a1;
    *(int64_t *)(result + 8) = 0;
    *v1 = 0;
    return result;
}

// Address range: 0x100003da4 - 0x100003e98
int64_t function_100003da4(void) {
    // 0x100003da4
    int64_t v1; // 0x100003da4
    int64_t result = function_100003d5c((int32_t)v1); // 0x100003dbc
    if (v1 == 0) {
        // 0x100003e88
        return 0;
    }
    int32_t v2 = *(int32_t *)(result + 16); // 0x100003de8
    int64_t * v3; // 0x100003da4
    while (true) {
        // 0x100003ddc
        int64_t v4; // 0x100003da4
        int64_t v5 = v4;
        int32_t v6 = *(int32_t *)(v5 + 16); // 0x100003de0
        int32_t v7 = v6 - v2; // 0x100003dec
        int64_t v8; // 0x100003da4
        if (v7 < 0 == ((v7 ^ v6) & (v6 ^ v2)) < 0) {
            // 0x100003e3c
            v3 = (int64_t *)(v5 + 8);
            int64_t v9 = *v3; // 0x100003e40
            v8 = v9;
            if (v9 == 0) {
                // break -> 0x100003e54
                break;
            }
        } else {
            int64_t * v10 = (int64_t *)v5;
            int64_t v11 = *v10; // 0x100003e00
            v8 = v11;
            if (v11 == 0) {
                // 0x100003e14
                *v10 = result;
                return result;
            }
        }
        // 0x100003e7c
        v4 = v8;
    }
    // 0x100003e54
    *v3 = result;
  lab_0x100003e88:
    // 0x100003e88
    return result;
}

// Address range: 0x100003e98 - 0x100003f88
int64_t entry_point(void) {
    // 0x100003e98
    function_100003c20((int64_t)_rand());
    _rand();
    int32_t v1 = 0;
    function_100003c68();
    int32_t v2 = v1 + 1; // 0x100003f14
    int32_t v3 = _rand();
    while (v1 < 0x270f != (0x270e - v1 & v2) < 0) {
        // 0x100003ee4
        v1 = v2;
        function_100003c68();
        v2 = v1 + 1;
        v3 = _rand();
    }
    // 0x100003f20
    function_100003d5c(v3);
    int32_t v4 = 0;
    _rand();
    function_100003da4();
    int32_t v5 = v4 + 1; // 0x100003f6c
    while (v4 < 0x270f != (0x270e - v4 & v5) < 0) {
        // 0x100003f4c
        v4 = v5;
        _rand();
        function_100003da4();
        v5 = v4 + 1;
    }
    // 0x100003f78
    return 0;
}

// Address range: 0x100003f88 - 0x100003f94
int64_t * function_100003f88(int32_t size) {
    // 0x100003f88
    return _malloc(size);
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(void) {
    // 0x100003f94
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: romantic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TAG_NAME 50
#define MAX_TAG_VALUE 100

typedef struct xml_tag {
    char *name;
    char *value;
} xml_tag;

void parse_tag(char *tag, xml_tag *xml_tag) {
    char *start_ptr, *end_ptr;
    char tag_name[MAX_TAG_NAME];
    char tag_value[MAX_TAG_VALUE];
    int tag_len, name_len, value_len;

    start_ptr = strchr(tag, '<');
    end_ptr = strchr(tag, '>');

    tag_len = end_ptr - start_ptr - 1;

    strncpy(tag_name, start_ptr + 1, tag_len);

    name_len = strchr(tag_name, ' ') - tag_name;

    strncpy(xml_tag->name, tag_name, name_len);

    tag_value[0] = '\0';

    if (strchr(tag, '"') != NULL) {
        start_ptr = strchr(tag, '"') + 1;
        end_ptr = strchr(start_ptr, '"');
        value_len = end_ptr - start_ptr;
        strncpy(tag_value, start_ptr, value_len);
        tag_value[value_len] = '\0';
        strncpy(xml_tag->value, tag_value, value_len);
    }
}

int main() {
    char tag[100];
    xml_tag *xml_tag;
    int tag_count = 0;

    while (fgets(tag, MAX_TAG_VALUE, stdin) != NULL) {
        xml_tag = malloc(sizeof(xml_tag));
        xml_tag->name = malloc(MAX_TAG_NAME);
        xml_tag->value = malloc(MAX_TAG_VALUE);

        parse_tag(tag, xml_tag);
        printf("Tag %d: %s = '%s'\n", ++tag_count, xml_tag->name, xml_tag->value);

        free(xml_tag->name);
        free(xml_tag->value);
        free(xml_tag);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall parse_tag(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016CD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rcx
  const char *v4; // rdx
  FILE *v5; // rax
  char Buffer[112]; // [rsp+20h] [rbp-80h] BYREF
  void *Block; // [rsp+90h] [rbp-10h]
  int v9; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 0;
  while ( 1 )
  {
    v5 = __acrt_iob_func(0);
    if ( !fgets(Buffer, 100, v5) )
      break;
    Block = malloc(8ui64);
    *(_QWORD *)Block = malloc(0x32ui64);
    *((_QWORD *)Block + 1) = malloc(0x64ui64);
    parse_tag(Buffer, Block);
    v3 = (const char *)*((_QWORD *)Block + 1);
    v4 = *(const char **)Block;
    printf("Tag %d: %s = '%s'\n", (unsigned int)++v9, v4, v3);
    free(*(void **)Block);
    free(*((void **)Block + 1));
    free(Block);
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall parse_tag(_QWORD, _QWORD);
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>

// returns x where (a * x) % b == 1
int mul_inv(int a, int b)
{
	int b0 = b, t, q;
	int x0 = 0, x1 = 1;
	if (b == 1) return 1;
	while (a > 1) {
		q = a / b;
		t = b, b = a % b, a = t;
		t = x0, x0 = x1 - q * x0, x1 = t;
	}
	if (x1 < 0) x1 += b0;
	return x1;
}

int chinese_remainder(int *n, int *a, int len)
{
	int p, i, prod = 1, sum = 0;

	for (i = 0; i < len; i++) prod *= n[i];

	for (i = 0; i < len; i++) {
		p = prod / n[i];
		sum += a[i] * mul_inv(p, n[i]) * p;
	}

	return sum % prod;
}

int main(void)
{
	int n[] = { 3, 5, 7 };
	int a[] = { 2, 3, 2 };

	printf("%d\n", chinese_remainder(n, a, sizeof(n)/sizeof(n[0])));
	return 0;
}
`,`#include "chinese-remainder-theorem.h"



int _mul_inv(int param_1,int param_2)

{
  int iVar1;
  int iVar2;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_c;
  undefined4 local_8;
  undefined4 local_4;
  
  local_1c = 0;
  local_20 = 1;
  local_c = param_2;
  local_8 = param_1;
  if (param_2 == 1) {
    local_4 = 1;
  }
  else {
    while (1 < local_8) {
      iVar1 = 0;
      if (local_c != 0) {
        iVar1 = local_8 / local_c;
      }
      iVar2 = 0;
      if (local_c != 0) {
        iVar2 = local_8 / local_c;
      }
      iVar2 = local_8 - iVar2 * local_c;
      iVar1 = local_20 - iVar1 * local_1c;
      local_20 = local_1c;
      local_8 = local_c;
      local_1c = iVar1;
      local_c = iVar2;
    }
    if (local_20 < 0) {
      local_20 = local_20 + param_2;
    }
    local_4 = local_20;
  }
  return local_4;
}



int _chinese_remainder(long param_1,long param_2,int param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  
  local_30 = 1;
  local_34 = 0;
  for (local_2c = 0; local_2c < param_3; local_2c = local_2c + 1) {
    local_30 = local_30 * *(int *)(param_1 + (long)local_2c * 4);
  }
  for (local_2c = 0; local_2c < param_3; local_2c = local_2c + 1) {
    iVar1 = *(int *)(param_1 + (long)local_2c * 4);
    iVar2 = 0;
    if (iVar1 != 0) {
      iVar2 = local_30 / iVar1;
    }
    iVar1 = *(int *)(param_2 + (long)local_2c * 4);
    iVar3 = _mul_inv(iVar2,*(undefined4 *)(param_1 + (long)local_2c * 4));
    local_34 = local_34 + iVar1 * iVar3 * iVar2;
  }
  iVar1 = 0;
  if (local_30 != 0) {
    iVar1 = local_34 / local_30;
  }
  return local_34 - iVar1 * local_30;
}



undefined8 entry(void)

{
  int iVar1;
  undefined8 local_38;
  undefined4 local_30;
  undefined8 local_28;
  undefined4 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_28 = 0x500000003;
  local_20 = 7;
  local_38 = 0x300000002;
  local_30 = 2;
  _chinese_remainder(&local_28,&local_38,3);
  iVar1 = _printf("%d\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    // Get a string from stdin
    char str[BUFSIZ];
    puts("Enter a string: ");
    fgets(str, sizeof(str), stdin);

    // Get 75000 from stdin
    long num;
    char buf[BUFSIZ];
    do
    {
        puts("Enter 75000: ");
        fgets(buf, sizeof(buf), stdin);
        num = strtol(buf, NULL, 10);
    } while (num != 75000);

    return EXIT_SUCCESS;
}
`,`#include "user-input-text-1.h"



undefined8 entry(void)

{
  long lVar1;
  char acStack_828 [1024];
  char acStack_428 [1024];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _puts("Enter a string: ");
  _fgets(acStack_428,0x400,*(FILE **)PTR____stdinp_100004010);
  do {
    _puts("Enter 75000: ");
    _fgets(acStack_828,0x400,*(FILE **)PTR____stdinp_100004010);
    lVar1 = _strtol(acStack_828,(char **)0x0,10);
  } while (lVar1 != 75000);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004018)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long _strtol(char *param_1,char **param_2,int param_3)

{
  long lVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  lVar1 = (*(code *)PTR__strtol_100004028)(param_1,param_2,param_3);
  return lVar1;
}


`
`#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct tPoint {
    int x, y;
} Point;

bool ccw(const Point *a, const Point *b, const Point *c) {
    return (b->x - a->x) * (c->y - a->y)
         > (b->y - a->y) * (c->x - a->x);
}

int comparePoints(const void *lhs, const void *rhs) {
    const Point* lp = lhs;
    const Point* rp = rhs;
    if (lp->x < rp->x)
        return -1;
    if (rp->x < lp->x)
        return 1;
    if (lp->y < rp->y)
        return -1;
    if (rp->y < lp->y)
        return 1;
    return 0;
}

void fatal(const char* message) {
    fprintf(stderr, "%s\n", message);
    exit(1);
}

void* xmalloc(size_t n) {
    void* ptr = malloc(n);
    if (ptr == NULL)
        fatal("Out of memory");
    return ptr;
}

void* xrealloc(void* p, size_t n) {
    void* ptr = realloc(p, n);
    if (ptr == NULL)
        fatal("Out of memory");
    return ptr;
}

void printPoints(const Point* points, int len) {
    printf("[");
    if (len > 0) {
        const Point* ptr = points;
        const Point* end = points + len;
        printf("(%d, %d)", ptr->x, ptr->y);
        ++ptr;
        for (; ptr < end; ++ptr)
            printf(", (%d, %d)", ptr->x, ptr->y);
    }
    printf("]");
}

Point* convexHull(Point p[], int len, int* hsize) {
    if (len == 0) {
        *hsize = 0;
        return NULL;
    }

    int i, size = 0, capacity = 4;
    Point* hull = xmalloc(capacity * sizeof(Point));

    qsort(p, len, sizeof(Point), comparePoints);

    /* lower hull */
    for (i = 0; i < len; ++i) {
        while (size >= 2 && !ccw(&hull[size - 2], &hull[size - 1], &p[i]))
            --size;
        if (size == capacity) {
            capacity *= 2;
            hull = xrealloc(hull, capacity * sizeof(Point));
        }
        assert(size >= 0 && size < capacity);
        hull[size++] = p[i];
    }

    /* upper hull */
    int t = size + 1;
    for (i = len - 1; i >= 0; i--) {
        while (size >= t && !ccw(&hull[size - 2], &hull[size - 1], &p[i]))
            --size;
        if (size == capacity) {
            capacity *= 2;
            hull = xrealloc(hull, capacity * sizeof(Point));
        }
        assert(size >= 0 && size < capacity);
        hull[size++] = p[i];
    }
    --size;
    assert(size >= 0);
    hull = xrealloc(hull, size * sizeof(Point));
    *hsize = size;
    return hull;
}

int main() {
    Point points[] = {
        {16,  3}, {12, 17}, { 0,  6}, {-4, -6}, {16,  6},
        {16, -7}, {16, -3}, {17, -4}, { 5, 19}, {19, -8},
        { 3, 16}, {12, 13}, { 3, -4}, {17,  5}, {-3, 15},
        {-3, -9}, { 0, 11}, {-9, -3}, {-4, -2}, {12, 10}
    };
    int hsize;
    Point* hull = convexHull(points, sizeof(points)/sizeof(Point), &hsize);
    printf("Convex Hull: ");
    printPoints(hull, hsize);
    printf("\n");
    free(hull);

    return 0;
}
`,`#include "convex-hull.h"



bool _ccw(int *param_1,int *param_2,int *param_3)

{
  return (param_2[1] - param_1[1]) * (*param_3 - *param_1) <
         (*param_2 - *param_1) * (param_3[1] - param_1[1]);
}



undefined4 _comparePoints(int *param_1,int *param_2)

{
  undefined4 local_4;
  
  if (*param_1 < *param_2) {
    local_4 = 0xffffffff;
  }
  else if (*param_2 < *param_1) {
    local_4 = 1;
  }
  else if (param_1[1] < param_2[1]) {
    local_4 = 0xffffffff;
  }
  else if (param_2[1] < param_1[1]) {
    local_4 = 1;
  }
  else {
    local_4 = 0;
  }
  return local_4;
}



void _fatal(void)

{
  _fprintf(*(FILE **)PTR____stderrp_100004018,"%s\n");
                    // WARNING: Subroutine does not return
  _exit(1);
}



void * _xmalloc(size_t param_1)

{
  void *pvVar1;
  
  pvVar1 = _malloc(param_1);
  if (pvVar1 == (void *)0x0) {
    _fatal("Out of memory");
  }
  return pvVar1;
}



void * _xrealloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
  pvVar1 = _realloc(param_1,param_2);
  if (pvVar1 == (void *)0x0) {
    _fatal("Out of memory");
  }
  return pvVar1;
}



int _printPoints(long param_1,int param_2)

{
  int iVar1;
  ulong local_28;
  
  _printf("[");
  if (0 < param_2) {
    _printf("(%d, %d)");
    for (local_28 = param_1 + 8; local_28 < (ulong)(param_1 + (long)param_2 * 8);
        local_28 = local_28 + 8) {
      _printf(", (%d, %d)");
    }
  }
  iVar1 = _printf("]");
  return iVar1;
}



undefined8 _convexHull(void *param_1,int param_2,int *param_3)

{
  int iVar1;
  long lVar2;
  uint local_5c;
  uint local_50;
  long local_48;
  int local_3c;
  int local_38;
  int local_34;
  undefined8 local_18;
  
  if (param_2 == 0) {
    *param_3 = 0;
    local_18 = 0;
  }
  else {
    local_38 = 0;
    local_3c = 4;
    local_48 = _xmalloc(0x20);
    _qsort(param_1,(long)param_2,8,(int *)_comparePoints);
    for (local_34 = 0; local_34 < param_2; local_34 = local_34 + 1) {
      while( true ) {
        local_50 = 0;
        if (1 < local_38) {
          local_50 = _ccw(local_48 + (long)(local_38 + -2) * 8,local_48 + (long)(local_38 + -1) * 8,
                          (void *)((long)param_1 + (long)local_34 * 8));
          local_50 = local_50 ^ 1;
        }
        if ((local_50 & 1) == 0) break;
        local_38 = local_38 + -1;
      }
      if (local_38 == local_3c) {
        local_3c = local_3c << 1;
        local_48 = _xrealloc(local_48,(long)local_3c << 3);
      }
      if (local_38 < 0 || local_3c <= local_38) {
                    // WARNING: Subroutine does not return
        ___assert_rtn("convexHull","convex-hull.c",0x50,"size >= 0 && size < capacity");
      }
      lVar2 = (long)local_38;
      local_38 = local_38 + 1;
      *(undefined8 *)(local_48 + lVar2 * 8) = *(undefined8 *)((long)param_1 + (long)local_34 * 8);
    }
    iVar1 = local_38 + 1;
    for (local_34 = param_2 + -1; -1 < local_34; local_34 = local_34 + -1) {
      while( true ) {
        local_5c = 0;
        if (iVar1 <= local_38) {
          local_5c = _ccw(local_48 + (long)(local_38 + -2) * 8,local_48 + (long)(local_38 + -1) * 8,
                          (void *)((long)param_1 + (long)local_34 * 8));
          local_5c = local_5c ^ 1;
        }
        if ((local_5c & 1) == 0) break;
        local_38 = local_38 + -1;
      }
      if (local_38 == local_3c) {
        local_3c = local_3c << 1;
        local_48 = _xrealloc(local_48,(long)local_3c << 3);
      }
      if (local_38 < 0 || local_3c <= local_38) {
                    // WARNING: Subroutine does not return
        ___assert_rtn("convexHull","convex-hull.c",0x5d,"size >= 0 && size < capacity");
      }
      lVar2 = (long)local_38;
      local_38 = local_38 + 1;
      *(undefined8 *)(local_48 + lVar2 * 8) = *(undefined8 *)((long)param_1 + (long)local_34 * 8);
    }
    local_38 = local_38 + -1;
    if (local_38 < 0) {
                    // WARNING: Subroutine does not return
      ___assert_rtn("convexHull","convex-hull.c",0x61,"size >= 0");
    }
    local_18 = _xrealloc(local_48,(long)local_38 << 3);
    *param_3 = local_38;
  }
  return local_18;
}



undefined8 entry(void)

{
  void *pvVar1;
  undefined4 local_c0;
  undefined4 local_bc;
  undefined auStack_b8 [160];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_bc = 0;
  _memcpy(auStack_b8,&DAT_100003ef8,0xa0);
  pvVar1 = (void *)_convexHull(auStack_b8,0x14,&local_c0);
  _printf("Convex Hull: ");
  _printPoints(pvVar1,local_c0);
  _printf("\n");
  _free(pvVar1);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e3c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e48. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e54. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004040)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004050)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e78. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004058)();
  return pvVar1;
}


`
`#include <stdio.h>
#include <string.h>

int repstr(char *str)
{
    if (!str) return 0;

    size_t sl = strlen(str) / 2;
    while (sl > 0) {
        if (strstr(str, str + sl) == str)
            return sl;
        --sl;
    }

    return 0;
}

int main(void)
{
    char *strs[] = { "1001110011", "1110111011", "0010010010", "1111111111",
        "0100101101", "0100100", "101", "11", "00", "1" };

    size_t strslen = sizeof(strs) / sizeof(strs[0]);
    size_t i;
    for (i = 0; i < strslen; ++i) {
        int n = repstr(strs[i]);
        if (n)
            printf("\"%s\" = rep-string \"%.*s\"\n", strs[i], n, strs[i]);
        else
            printf("\"%s\" = not a rep-string\n", strs[i]);
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d0c(void);
int64_t function_100003eec(int64_t a1);
int64_t * function_100003ef8(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f04(char * format, ...);
int32_t function_100003f10(char * s);
char * function_100003f1c(char * haystack, char * needle);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);
char * _strstr(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003d0c - 0x100003dc0
int64_t function_100003d0c(void) {
    // 0x100003d0c
    int64_t v1; // 0x100003d0c
    if (v1 == 0) {
        // 0x100003db0
        return 0;
    }
    char * v2 = (char *)v1; // 0x100003d18
    int32_t v3 = (int64_t)_strlen(v2) / 2; // 0x100003d48
    if (v3 == 0) {
        // 0x100003db0
        return 0;
    }
    int32_t v4 = v3; // 0x100003d5c
    char * v5 = _strstr(v2, (char *)(v1 + (int64_t)v4)); // 0x100003d74
    int32_t result = v4; // 0x100003d84
    while (v5 != v2) {
        // 0x100003d98
        v4--;
        result = 0;
        if (v4 == 0) {
            // break -> 0x100003db0
            break;
        }
        v5 = _strstr(v2, (char *)(v1 + (int64_t)v4));
        result = v4;
    }
    // 0x100003db0
    return result;
}

// Address range: 0x100003dc0 - 0x100003eec
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dd4
    int64_t v2; // bp-104, 0x100003dc0
    _memcpy(&v2, (int64_t *)"(?", 80);
    int32_t v3; // 0x100003dc0
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003e1c
        if ((int32_t)function_100003d0c() == 0) {
            // 0x100003e80
            v3 = _printf("\"%s\" = not a rep-string\n", "(?");
        } else {
            // 0x100003e44
            int64_t v4; // 0x100003dc0
            v3 = _printf("\"%s\" = rep-string \"%.*s\"\n", "(?", 80, (char *)v4);
        }
    }
    // 0x100003eb8
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ed8
        ___stack_chk_fail((int64_t)v3);
    }
    // 0x100003edc
    return 0;
}

// Address range: 0x100003eec - 0x100003ef8
int64_t function_100003eec(int64_t a1) {
    // 0x100003eec
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ef8 - 0x100003f04
int64_t * function_100003ef8(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003ef8
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(char * format, ...) {
    // 0x100003f04
    return _printf(format);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * s) {
    // 0x100003f10
    return _strlen(s);
}

// Address range: 0x100003f1c - 0x100003f28
char * function_100003f1c(char * haystack, char * needle) {
    // 0x100003f1c
    return _strstr(haystack, needle);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>
#include <stdlib.h>

/* to read expanded code, run through cpp | indent -st */
#define DECL_STACK_TYPE(type, name)					\
typedef struct stk_##name##_t{type *buf; size_t alloc,len;}*stk_##name;	\
stk_##name stk_##name##_create(size_t init_size) {			\
	stk_##name s; if (!init_size) init_size = 4;			\
	s = malloc(sizeof(struct stk_##name##_t));			\
	if (!s) return 0;						\
	s->buf = malloc(sizeof(type) * init_size);			\
	if (!s->buf) { free(s); return 0; }				\
	s->len = 0, s->alloc = init_size;				\
	return s; }							\
int stk_##name##_push(stk_##name s, type item) {			\
	type *tmp;							\
	if (s->len >= s->alloc) {					\
		tmp = realloc(s->buf, s->alloc*2*sizeof(type));		\
		if (!tmp) return -1; s->buf = tmp;			\
		s->alloc *= 2; }					\
	s->buf[s->len++] = item;					\
	return s->len; }						\
type stk_##name##_pop(stk_##name s) {					\
	type tmp;							\
	if (!s->len) abort();						\
	tmp = s->buf[--s->len];						\
	if (s->len * 2 <= s->alloc && s->alloc >= 8) {			\
		s->alloc /= 2;						\
		s->buf = realloc(s->buf, s->alloc * sizeof(type));}	\
	return tmp; }							\
void stk_##name##_delete(stk_##name s) {				\
	free(s->buf); free(s); }

#define stk_empty(s) (!(s)->len)
#define stk_size(s) ((s)->len)

DECL_STACK_TYPE(int, int)

int main(void)
{
	int i;
	stk_int stk = stk_int_create(0);

	printf("pushing: ");
	for (i = 'a'; i <= 'z'; i++) {
		printf(" %c", i);
		stk_int_push(stk, i);
	}

	printf("\nsize now: %d", stk_size(stk));
	printf("\nstack is%s empty\n", stk_empty(stk) ? "" : " not");

	printf("\npoppoing:");
	while (stk_size(stk))
		printf(" %c", stk_int_pop(stk));
	printf("\nsize now: %d", stk_size(stk));
	printf("\nstack is%s empty\n", stk_empty(stk) ? "" : " not");

	/* stk_int_pop(stk); <-- will abort() */
	stk_int_delete(stk);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003af4(void);
int64_t function_100003bbc(void);
int64_t function_100003c90(void);
int64_t function_100003d5c(void);
void function_100003f2c(void);
void function_100003f38(int64_t * ptr);
int64_t * function_100003f44(int32_t size);
int32_t function_100003f50(char * format, ...);
int64_t * function_100003f5c(int64_t * ptr, int32_t size);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

void _abort(void);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003af4 - 0x100003bbc
int64_t function_100003af4(void) {
    // 0x100003af4
    int64_t v1; // 0x100003af4
    int64_t v2 = v1;
    int64_t * v3 = _malloc(24); // 0x100003b28
    if (v3 == NULL) {
        // 0x100003bac
        return 0;
    }
    int64_t v4 = v2 == 0 ? 4 : v2;
    int64_t * v5 = _malloc(4 * (int32_t)v4); // 0x100003b58
    *v3 = (int64_t)v5;
    int64_t result; // 0x100003af4
    if (v5 == NULL) {
        // 0x100003b7c
        _free(v3);
        result = 0;
    } else {
        int64_t v6 = (int64_t)v3; // 0x100003b28
        *(int64_t *)(v6 + 16) = 0;
        *(int64_t *)(v6 + 8) = v4;
        result = v6;
    }
    // 0x100003bac
    return result;
}

// Address range: 0x100003bbc - 0x100003c90
int64_t function_100003bbc(void) {
    // 0x100003bbc
    int64_t v1; // 0x100003bbc
    int64_t * v2 = (int64_t *)(v1 + 16); // 0x100003bd4
    uint64_t v3 = *v2; // 0x100003bd4
    int64_t * v4 = (int64_t *)(v1 + 8); // 0x100003bdc
    uint64_t v5 = *v4; // 0x100003bdc
    int64_t v6 = v3; // 0x100003be8
    int64_t v7; // 0x100003bbc
    if (v3 >= v5) {
        int64_t * v8 = (int64_t *)v1; // 0x100003c08
        int64_t * v9 = _realloc(v8, 8 * (int32_t)v5); // 0x100003c08
        if (v9 == NULL) {
            // 0x100003c80
            return 0xffffffff;
        }
        int64_t v10 = (int64_t)v9; // 0x100003c08
        *v8 = v10;
        *v4 = 2 * *v4;
        v6 = *v2;
        v7 = v10;
    }
    // 0x100003c50
    *v2 = v6 + 1;
    *(int32_t *)(4 * v6 + v7) = (int32_t)v1;
    // 0x100003c80
    return *v2 & 0xffffffff;
}

// Address range: 0x100003c90 - 0x100003d5c
int64_t function_100003c90(void) {
    // 0x100003c90
    int64_t v1; // 0x100003c90
    int64_t * v2 = (int64_t *)(v1 + 16); // 0x100003ca4
    int64_t v3 = *v2; // 0x100003ca4
    int64_t v4 = v3; // 0x100003cb0
    int64_t v5; // 0x100003c90
    if (v3 == 0) {
        // 0x100003cb8
        _abort();
        v4 = *v2;
        v5 = &g1;
    }
    int64_t v6 = v4 - 1; // 0x100003ccc
    *v2 = v6;
    int64_t * v7 = (int64_t *)(v1 + 8); // 0x100003ce8
    uint64_t v8 = *v7; // 0x100003ce8
    if (v8 >= 2 * v6 && v8 >= 8) {
        uint64_t v9 = v8 / 2; // 0x100003d20
        *v7 = v9;
        int64_t * v10 = _realloc((int64_t *)v5, 4 * (int32_t)v9); // 0x100003d3c
        *(int64_t *)v1 = (int64_t)v10;
    }
    // 0x100003d4c
    return (int64_t)*(int32_t *)(4 * v6 + v5);
}

// Address range: 0x100003d5c - 0x100003d8c
int64_t function_100003d5c(void) {
    // 0x100003d5c
    int64_t v1; // 0x100003d5c
    int64_t * v2 = (int64_t *)v1; // 0x100003d74
    _free(v2);
    _free(v2);
    return &g1;
}

// Address range: 0x100003d8c - 0x100003f2c
int64_t entry_point(void) {
    int64_t v1 = function_100003af4(); // 0x100003da0
    _printf("pushing: ");
    int64_t v2 = 97;
    int64_t v3; // 0x100003d8c
    _printf(" %c", (char)v3);
    function_100003bbc();
    int64_t v4 = v2 + 1; // 0x100003e04
    int32_t v5 = v4; // 0x100003dc0
    int32_t v6 = v5 - 122; // 0x100003dc4
    v3 = v2;
    while (v6 == 0 || v6 < 0 != (121 - v5 & v5) < 0) {
        // 0x100003dd4
        v2 = v4 & 0xffffffff;
        _printf(" %c", (char)v3);
        function_100003bbc();
        v4 = v2 + 1;
        v5 = v4;
        v6 = v5 - 122;
        v3 = v2;
    }
    // 0x100003e10
    _printf("\nsize now: %d", v2);
    char * v7 = (char *)v2; // 0x100003e68
    _printf("\nstack is%s empty\n", v7);
    _printf("\npoppoing:");
    int64_t * v8 = (int64_t *)(v1 + 16); // 0x100003e80
    if (*v8 == 0) {
        // 0x100003eb8
        _printf("\nsize now: %d", v2);
        _printf("\nstack is%s empty\n", v7);
        function_100003d5c();
        return 0;
    }
    function_100003c90();
    _printf(" %c", (char)v2);
    // 0x100003e94
    while (*v8 != 0) {
        // 0x100003e94
        function_100003c90();
        _printf(" %c", (char)v2);
    }
    // 0x100003eb8
    _printf("\nsize now: %d", v2);
    _printf("\nstack is%s empty\n", v7);
    function_100003d5c();
    return 0;
}

// Address range: 0x100003f2c - 0x100003f38
void function_100003f2c(void) {
    // 0x100003f2c
    _abort();
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int64_t * ptr) {
    // 0x100003f38
    _free(ptr);
}

// Address range: 0x100003f44 - 0x100003f50
int64_t * function_100003f44(int32_t size) {
    // 0x100003f44
    return _malloc(size);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * format, ...) {
    // 0x100003f50
    return _printf(format);
}

// Address range: 0x100003f5c - 0x100003f68
int64_t * function_100003f5c(int64_t * ptr, int32_t size) {
    // 0x100003f5c
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`//FormAI DATASET v1.0 Category: Procedural Space Adventure ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int choice;
    int fuel = 100;
    int distance = 0;
    int oxygen = 100;
    int alien = 0;
    int found = 0;
    int randnum;
    srand(time(NULL));
    
    printf("Welcome to your Procedural Space Adventure!\n");
    printf("--------------------------------------------\n");
    printf("You are the captain of the spaceship U.S.S. Explorer.\n");
    printf("You are on a mission to explore uncharted parts of the galaxy.\n");
    printf("You have only 100 units of fuel and oxygen.\n");
    printf("Your mission is to find a habitable planet and return to Earth.\n");
    printf("--------------------------------------------\n");

    while (distance < 20) {
        printf("\nWhat do you want to do?\n");
        printf("1. Fly forward (costs 10 fuel, 5 oxygen)\n");
        printf("2. Scan for a planet (costs 20 fuel)\n");
        printf("3. Check your resources\n");
        printf("4. Quit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        printf("\n");

        switch (choice) {
            case 1:
                if (fuel < 10 || oxygen < 5) {
                    printf("You don't have enough resources to fly forward!\n");
                } else {
                    fuel -= 10;
                    oxygen -= 5;
                    distance++;
                    if (alien == 1) {
                        randnum = rand() % 10;
                        if (randnum > 5) {
                            printf("You encountered an alien and it attacked your ship!\n");
                            fuel -= 30;
                            oxygen -= 20;
                            alien = 0;
                        } else {
                            printf("You encountered an alien but it seems to be friendly.\n");
                        }
                    } else {
                        randnum = rand() % 10;
                        if (randnum > 7) {
                            printf("You encountered an alien!\n");
                            alien = 1;
                        }
                    }
                    printf("You have flown forward one unit.\n");
                }
                break;
            case 2:
                if (fuel < 20) {
                    printf("You don't have enough fuel to scan for a planet!\n");
                } else {
                    fuel -= 20;
                    randnum = rand() % 10;
                    if (randnum > 5) {
                        printf("You found a habitable planet!\n");
                        found = 1;
                    } else {
                        printf("You didn't find any habitable planets.\n");
                    }
                }
                break;
            case 3:
                printf("Fuel: %d\n", fuel);
                printf("Oxygen: %d\n", oxygen);
                printf("Distance from Earth: %d units\n", distance);
                if (alien == 1) {
                    printf("There is an alien aboard your ship.\n");
                }
                break;
            case 4:
                printf("Quitting...\n");
                return 0;
            default:
                printf("Invalid choice! Try again.\n");
                break;
        }

        if (found == 1) {
            break;
        }

        if (fuel <= 0 || oxygen <= 0) {
            printf("You ran out of fuel or oxygen and can't continue your mission anymore!\n");
            return 0;
        }
    }

    printf("\nCongratulations! You have successfully found a habitable planet and returned to Earth!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-1Ch] BYREF
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+2Ch] [rbp-14h]
  int v8; // [rsp+30h] [rbp-10h]
  int v9; // [rsp+34h] [rbp-Ch]
  unsigned int v10; // [rsp+38h] [rbp-8h]
  int v11; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v11 = 100;
  v10 = 0;
  v9 = 100;
  v8 = 0;
  v7 = 0;
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to your Procedural Space Adventure!\n");
  printf("--------------------------------------------\n");
  printf("You are the captain of the spaceship U.S.S. Explorer.\n");
  printf("You are on a mission to explore uncharted parts of the galaxy.\n");
  printf("You have only 100 units of fuel and oxygen.\n");
  printf("Your mission is to find a habitable planet and return to Earth.\n");
  printf("--------------------------------------------\n");
  while ( (int)v10 <= 19 )
  {
    printf("\nWhat do you want to do?\n");
    printf("1. Fly forward (costs 10 fuel, 5 oxygen)\n");
    printf("2. Scan for a planet (costs 20 fuel)\n");
    printf("3. Check your resources\n");
    printf("4. Quit\n");
    printf("Enter your choice: ");
    scanf("%d", &v5);
    printf("\n");
    if ( v5 == 4 )
    {
      printf("Quitting...\n");
      return 0;
    }
    if ( v5 > 4 )
    {
LABEL_26:
      printf("Invalid choice! Try again.\n");
      goto LABEL_27;
    }
    switch ( v5 )
    {
      case 3:
        printf("Fuel: %d\n", (unsigned int)v11);
        printf("Oxygen: %d\n", (unsigned int)v9);
        printf("Distance from Earth: %d units\n", v10);
        if ( v8 == 1 )
          printf("There is an alien aboard your ship.\n");
        break;
      case 1:
        if ( v11 > 9 && v9 > 4 )
        {
          v11 -= 10;
          v9 -= 5;
          ++v10;
          if ( v8 == 1 )
          {
            v6 = rand() % 10;
            if ( v6 <= 5 )
            {
              printf("You encountered an alien but it seems to be friendly.\n");
            }
            else
            {
              printf("You encountered an alien and it attacked your ship!\n");
              v11 -= 30;
              v9 -= 20;
              v8 = 0;
            }
          }
          else
          {
            v6 = rand() % 10;
            if ( v6 > 7 )
            {
              printf("You encountered an alien!\n");
              v8 = 1;
            }
          }
          printf("You have flown forward one unit.\n");
        }
        else
        {
          printf("You don't have enough resources to fly forward!\n");
        }
        break;
      case 2:
        if ( v11 > 19 )
        {
          v11 -= 20;
          v6 = rand() % 10;
          if ( v6 <= 5 )
          {
            printf("You didn't find any habitable planets.\n");
          }
          else
          {
            printf("You found a habitable planet!\n");
            v7 = 1;
          }
        }
        else
        {
          printf("You don't have enough fuel to scan for a planet!\n");
        }
        break;
      default:
        goto LABEL_26;
    }
LABEL_27:
    if ( v7 == 1 )
      break;
    if ( v11 <= 0 || v9 <= 0 )
    {
      printf("You ran out of fuel or oxygen and can't continue your mission anymore!\n");
      return 0;
    }
  }
  printf("\nCongratulations! You have successfully found a habitable planet and returned to Earth!\n");
  return 0;
}
// 140001750: conditional instruction was optimized away because %var_1C.4<3
// 140001A70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFFER_SIZE 128

typedef unsigned char character;
typedef character *string;

typedef struct node_t node;
struct node_t {
    enum tag_t {
        NODE_LEAF,
        NODE_TREE,
        NODE_SEQ,
    } tag;

    union {
        string str;
        node *root;
    } data;

    node *next;
};

node *allocate_node(enum tag_t tag) {
    node *n = malloc(sizeof(node));
    if (n == NULL) {
        fprintf(stderr, "Failed to allocate node for tag: %d\n", tag);
        exit(1);
    }
    n->tag = tag;
    n->next = NULL;
    return n;
}

node *make_leaf(string str) {
    node *n = allocate_node(NODE_LEAF);
    n->data.str = str;
    return n;
}

node *make_tree() {
    node *n = allocate_node(NODE_TREE);
    n->data.root = NULL;
    return n;
}

node *make_seq() {
    node *n = allocate_node(NODE_SEQ);
    n->data.root = NULL;
    return n;
}

void deallocate_node(node *n) {
    if (n == NULL) {
        return;
    }

    deallocate_node(n->next);
    n->next = NULL;

    if (n->tag == NODE_LEAF) {
        free(n->data.str);
        n->data.str = NULL;
    } else if (n->tag == NODE_TREE || n->tag == NODE_SEQ) {
        deallocate_node(n->data.root);
        n->data.root = NULL;
    } else {
        fprintf(stderr, "Cannot deallocate node with tag: %d\n", n->tag);
        exit(1);
    }

    free(n);
}

void append(node *root, node *elem) {
    if (root == NULL) {
        fprintf(stderr, "Cannot append to uninitialized node.");
        exit(1);
    }
    if (elem == NULL) {
        return;
    }

    if (root->tag == NODE_SEQ || root->tag == NODE_TREE) {
        if (root->data.root == NULL) {
            root->data.root = elem;
        } else {
            node *it = root->data.root;
            while (it->next != NULL) {
                it = it->next;
            }
            it->next = elem;
        }
    } else {
        fprintf(stderr, "Cannot append to node with tag: %d\n", root->tag);
        exit(1);
    }
}

size_t count(node *n) {
    if (n == NULL) {
        return 0;
    }

    if (n->tag == NODE_LEAF) {
        return 1;
    }
    if (n->tag == NODE_TREE) {
        size_t sum = 0;
        node *it = n->data.root;
        while (it != NULL) {
            sum += count(it);
            it = it->next;
        }
        return sum;
    }
    if (n->tag == NODE_SEQ) {
        size_t prod = 1;
        node *it = n->data.root;
        while (it != NULL) {
            prod *= count(it);
            it = it->next;
        }
        return prod;
    }

    fprintf(stderr, "Cannot count node with tag: %d\n", n->tag);
    exit(1);
}

void expand(node *n, size_t pos) {
    if (n == NULL) {
        return;
    }

    if (n->tag == NODE_LEAF) {
        printf(n->data.str);
    } else if (n->tag == NODE_TREE) {
        node *it = n->data.root;
        while (true) {
            size_t cnt = count(it);
            if (pos < cnt) {
                expand(it, pos);
                break;
            }
            pos -= cnt;
            it = it->next;
        }
    } else if (n->tag == NODE_SEQ) {
        size_t prod = pos;
        node *it = n->data.root;
        while (it != NULL) {
            size_t cnt = count(it);

            size_t rem = prod % cnt;
            expand(it, rem);

            it = it->next;
        }
    } else {
        fprintf(stderr, "Cannot expand node with tag: %d\n", n->tag);
        exit(1);
    }
}

string allocate_string(string src) {
    size_t len = strlen(src);
    string out = calloc(len + 1, sizeof(character));
    if (out == NULL) {
        fprintf(stderr, "Failed to allocate a copy of the string.");
        exit(1);
    }
    strcpy(out, src);
    return out;
}

node *parse_seq(string input, size_t *pos);

node *parse_tree(string input, size_t *pos) {
    node *root = make_tree();

    character buffer[BUFFER_SIZE] = { 0 };
    size_t bufpos = 0;
    size_t depth = 0;
    bool asSeq = false;
    bool allow = false;

    while (input[*pos] != 0) {
        character c = input[(*pos)++];
        if (c == '\\') {
            c = input[(*pos)++];
            if (c == 0) {
                break;
            }
            buffer[bufpos++] = '\\';
            buffer[bufpos++] = c;
            buffer[bufpos] = 0;
        } else if (c == '{') {
            buffer[bufpos++] = c;
            buffer[bufpos] = 0;
            asSeq = true;
            depth++;
        } else if (c == '}') {
            if (depth-- > 0) {
                buffer[bufpos++] = c;
                buffer[bufpos] = 0;
            } else {
                if (asSeq) {
                    size_t new_pos = 0;
                    node *seq = parse_seq(buffer, &new_pos);
                    append(root, seq);
                } else {
                    append(root, make_leaf(allocate_string(buffer)));
                }
                break;
            }
        } else if (c == ',') {
            if (depth == 0) {
                if (asSeq) {
                    size_t new_pos = 0;
                    node *seq = parse_seq(buffer, &new_pos);
                    append(root, seq);
                    bufpos = 0;
                    buffer[bufpos] = 0;
                    asSeq = false;
                } else {
                    append(root, make_leaf(allocate_string(buffer)));
                    bufpos = 0;
                    buffer[bufpos] = 0;
                }
            } else {
                buffer[bufpos++] = c;
                buffer[bufpos] = 0;
            }
        } else {
            buffer[bufpos++] = c;
            buffer[bufpos] = 0;
        }
    }

    return root;
}

node *parse_seq(string input, size_t *pos) {
    node *root = make_seq();

    character buffer[BUFFER_SIZE] = { 0 };
    size_t bufpos = 0;

    while (input[*pos] != 0) {
        character c = input[(*pos)++];
        if (c == '\\') {
            c = input[(*pos)++];
            if (c == 0) {
                break;
            }
            buffer[bufpos++] = c;
            buffer[bufpos] = 0;
        } else if (c == '{') {
            node *tree = parse_tree(input, pos);
            if (bufpos > 0) {
                append(root, make_leaf(allocate_string(buffer)));
                bufpos = 0;
                buffer[bufpos] = 0;
            }
            append(root, tree);
        } else {
            buffer[bufpos++] = c;
            buffer[bufpos] = 0;
        }
    }

    if (bufpos > 0) {
        append(root, make_leaf(allocate_string(buffer)));
        bufpos = 0;
        buffer[bufpos] = 0;
    }

    return root;
}

void test(string input) {
    size_t pos = 0;
    node *n = parse_seq(input, &pos);
    size_t cnt = count(n);
    size_t i;

    printf("Pattern: %s\n", input);

    for (i = 0; i < cnt; i++) {
        expand(n, i);
        printf("\n");
    }
    printf("\n");

    deallocate_node(n);
}

int main() {
    test("~/{Downloads,Pictures}/*.{jpg,gif,png}");
    test("It{{em,alic}iz,erat}e{d,}, please.");
    test("{,{,gotta have{ ,\\, again\\, }}more }cowbell!");

    //not sure how to parse this one
    //test("{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\}");

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002fb0(void);
int64_t function_100003034(int64_t a1);
int64_t function_10000306c(void);
int64_t function_10000309c(void);
int64_t function_1000030cc(void);
int64_t function_1000031d0(void);
int64_t function_100003314(void);
int64_t function_10000348c(void);
int64_t function_100003630(void);
int64_t function_1000036b4(void);
int64_t function_100003a5c(void);
int64_t function_100003ca4(void);
int64_t function_100003da4(void);
int64_t function_100003db0(int64_t a1, int64_t a2, int64_t a3);
int64_t * function_100003dbc(int32_t nmemb, int32_t size);
void function_100003dc8(int32_t status);
int32_t function_100003dd4(struct _IO_FILE * stream, char * format, ...);
void function_100003de0(int64_t * ptr);
int64_t * function_100003dec(int32_t size);
int64_t * function_100003df8(int64_t * s, int32_t c, int32_t n);
int32_t function_100003e04(char * format, ...);
int32_t function_100003e10(char * s);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100002fb0 - 0x100003034
int64_t function_100002fb0(void) {
    int64_t * v1 = _malloc(24); // 0x100002fc4
    int64_t v2; // 0x100002fb0
    if (v1 == NULL) {
        int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x100002fe8
        _fprintf((struct _IO_FILE *)v3, "Failed to allocate node for tag: %d\n", v2);
        _exit(1);
        // UNREACHABLE
    }
    // 0x100003010
    *(int32_t *)v1 = (int32_t)v2;
    int64_t result = (int64_t)v1; // 0x10000301c
    *(int64_t *)(result + 16) = 0;
    return result;
}

// Address range: 0x100003034 - 0x10000306c
int64_t function_100003034(int64_t a1) {
    int64_t result = function_100002fb0(); // 0x100003048
    *(int64_t *)(result + 8) = a1;
    return result;
}

// Address range: 0x10000306c - 0x10000309c
int64_t function_10000306c(void) {
    int64_t result = function_100002fb0(); // 0x10000307c
    *(int64_t *)(result + 8) = 0;
    return result;
}

// Address range: 0x10000309c - 0x1000030cc
int64_t function_10000309c(void) {
    int64_t result = function_100002fb0(); // 0x1000030ac
    *(int64_t *)(result + 8) = 0;
    return result;
}

// Address range: 0x1000030cc - 0x1000031d0
int64_t function_1000030cc(void) {
    // 0x1000030cc
    int64_t v1; // 0x1000030cc
    if (v1 == 0) {
        // 0x1000031c4
        return 0;
    }
    // 0x1000030f4
    function_1000030cc();
    *(int64_t *)(v1 + 16) = 0;
    int64_t v2; // 0x1000030cc
    switch (*(int32_t *)&v2) {
        case 0: {
            int64_t * v3 = (int64_t *)(v1 + 8); // 0x100003124
            _free((int64_t *)*v3);
            *v3 = 0;
            // break -> 0x1000031b8
            break;
        }
        case 1: {
        }
        case 2: {
            // 0x100003168
            function_1000030cc();
            *(int64_t *)(v1 + 8) = 0;
            // break -> 0x1000031b8
            break;
        }
        default: {
            int64_t v4 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003188
            _fprintf((struct _IO_FILE *)v4, "Cannot deallocate node with tag: %d\n", v1);
            _exit(1);
            // UNREACHABLE
        }
    }
    // 0x1000031b8
    _free((int64_t *)v1);
    v2 = &g1;
    // 0x1000031c4
    return &g1;
}

// Address range: 0x1000031d0 - 0x100003314
int64_t function_1000031d0(void) {
    // 0x1000031d0
    int64_t result; // 0x1000031d0
    if (result == 0) {
        int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003200
        _fprintf((struct _IO_FILE *)v1, "Cannot append to uninitialized node.");
        _exit(1);
        // UNREACHABLE
    }
    if (result == 0) {
        // 0x100003308
        return result;
    }
    if ((int32_t)result >= 3) {
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000032dc
        _fprintf((struct _IO_FILE *)v2, "Cannot append to node with tag: %d\n", result);
        _exit(1);
        // UNREACHABLE
    }
    int64_t v3 = *(int64_t *)(result + 8); // 0x100003264
    if (v3 == 0) {
        // 0x100003308
        return result;
    }
    int64_t v4 = v3; // 0x100003270
    v4 += 16;
    while (v4 != 0) {
        // 0x100003298
        v4 += 16;
    }
    // 0x100003308
    return result;
}

// Address range: 0x100003314 - 0x10000348c
int64_t function_100003314(void) {
    // 0x100003314
    int64_t v1; // 0x100003314
    if (v1 == 0) {
        // 0x10000347c
        return 0;
    }
    int64_t result = 1; // 0x100003314
    int64_t v2; // 0x100003314
    switch ((int32_t)v2) {
        case 1: {
            int64_t v3 = *(int64_t *)(v1 + 8);
            int64_t v4 = v3; // 0x10000339c
            if (v3 == 0) {
                // 0x10000347c
                return 0;
            }
            int64_t v5 = 0; // 0x10000339c
            v5 += function_100003314();
            v4 += 16;
            result = v5;
            while (v4 != 0) {
                // 0x1000033a4
                v5 += function_100003314();
                v4 += 16;
                result = v5;
            }
        }
        case 0: {
            // 0x10000347c
            return result;
        }
        case 2: {
            int64_t v6 = *(int64_t *)(v1 + 8);
            int64_t v7 = v6; // 0x100003410
            int64_t v8 = 1; // 0x100003410
            result = 1;
            if (v6 == 0) {
                // 0x10000347c
                return result;
            }
            v8 *= function_100003314();
            v7 += 16;
            result = v8;
            while (v7 != 0) {
                // 0x100003418
                v8 *= function_100003314();
                v7 += 16;
                result = v8;
            }
            return result;
        }
        default: {
            int64_t v9 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003450
            _fprintf((struct _IO_FILE *)v9, "Cannot count node with tag: %d\n", v1);
            _exit(1);
            // UNREACHABLE
        }
    }
}

// Address range: 0x10000348c - 0x100003630
int64_t function_10000348c(void) {
    int64_t result = 0; // 0x1000034ac
    int64_t v1; // 0x10000348c
    if (v1 == 0) {
        // 0x100003624
        return result;
    }
    int64_t v2; // 0x10000348c
    switch ((int32_t)v2) {
        case 0: {
            // 0x100003624
            return _printf((char *)*(int64_t *)(v1 + 8));
        }
        case 1: {
            int64_t v3 = function_100003314(); // 0x10000350c
            if (v1 >= v3) {
                int64_t v4; // 0x10000348c
                int64_t v5 = v4 - v3; // 0x100003544
                int64_t v6 = function_100003314(); // 0x10000350c
                v4 = v5;
                while (v5 >= v6) {
                    // 0x10000353c
                    v5 = v4 - v6;
                    v6 = function_100003314();
                    v4 = v5;
                }
            }
            // 0x100003624
            return function_10000348c();
        }
        case 2: {
            int64_t v7 = *(int64_t *)(v1 + 8);
            if (v7 == 0) {
                // 0x100003624
                return result;
            }
            int64_t v8 = v7; // 0x10000359c
            function_100003314();
            int64_t result2 = function_10000348c(); // 0x1000035d0
            v8 += 16;
            while (v8 != 0) {
                // 0x1000035a4
                function_100003314();
                result2 = function_10000348c();
                v8 += 16;
            }
            // 0x100003624
            return result2;
        }
    }
    int64_t v9 = *(int64_t *)*(int64_t *)0x100004010; // 0x1000035f0
    _fprintf((struct _IO_FILE *)v9, "Cannot expand node with tag: %d\n", v1);
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100003630 - 0x1000036b4
int64_t function_100003630(void) {
    // 0x100003630
    int64_t v1; // 0x100003630
    int64_t * v2 = _calloc(_strlen((char *)v1) + 1, 1); // 0x100003658
    if (v2 != NULL) {
        int64_t result = (int64_t)v2; // 0x100003658
        ___strcpy_chk(result, v1, -1);
        return result;
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x10000367c
    _fprintf((struct _IO_FILE *)v3, "Failed to allocate a copy of the string.");
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x1000036b4 - 0x100003a5c
int64_t function_1000036b4(void) {
    int64_t result = function_10000306c(); // 0x1000036dc
    int64_t v1; // bp-168, 0x1000036b4
    _memset(&v1, 0, 128);
    int64_t v2; // 0x1000036b4
    char * v3 = (char *)v2; // 0x100003714
    if (*v3 != 0) {
        int64_t * v4 = (int64_t *)v2; // 0x100003738
        int64_t v5 = &v1;
        int64_t v6 = 0;
        int64_t v7 = 0;
        int32_t v8 = 0;
        int64_t v9 = 0;
        int64_t v10 = v9 + 1; // 0x100003734
        *v4 = v10;
        char v11 = *v3; // 0x100003740
        int64_t v12; // 0x1000036b4
        int64_t v13; // 0x1000036b4
        int32_t v14; // 0x1000036b4
        int64_t v15; // 0x1000039e4
        char v16; // 0x100003774
        int64_t v17; // 0x1000037fc
        int64_t v18; // 0x1000036b4
        int64_t v19; // 0x1000037bc
        int64_t v20; // 0x100003870
        int64_t v21; // 0x1000039b0
        int64_t v22; // 0x10000397c
        int64_t v23; // 0x100003938
        int64_t v24; // 0x1000036b4
        switch (v11) {
            case 92: {
                // 0x10000375c
                *v4 = v10;
                v16 = *v3;
                if (v16 == 0) {
                    // break -> 0x100003a1c
                    break;
                }
                // 0x100003794
                v18 = v6 + v5;
                *(char *)v18 = 92;
                v19 = v6 + 2;
                *(char *)(v18 + 1) = v16;
                *(char *)(v19 + v5) = 0;
                v12 = v19;
                v13 = v7;
                v14 = v8;
                v24 = v9;
                // break -> 0x100003a18
                break;
            }
            case 123: {
                // 0x1000037f4
                v17 = v6 + 1;
                *(char *)(v6 + v5) = 123;
                *(char *)(v17 + v5) = 0;
                v12 = v17;
                v13 = v7 + 1;
                v14 = 1;
                v24 = v9;
                // break -> 0x100003a18
                break;
            }
            case 125: {
                if (v7 == 0) {
                    if (v8 % 2 == 0) {
                        // 0x1000038c8
                        function_100003034(function_100003630());
                        function_1000031d0();
                        goto lab_0x100003a1c;
                    } else {
                        // 0x1000038a4
                        function_100003a5c();
                        function_1000031d0();
                        goto lab_0x100003a1c;
                    }
                }
                // 0x100003868
                v20 = v6 + 1;
                *(char *)(v6 + v5) = 125;
                *(char *)(v20 + v5) = 0;
                v12 = v20;
                v13 = v7 - 1;
                v14 = v8;
                v24 = v9;
                // break -> 0x100003a18
                break;
            }
            case 44: {
                if (v7 == 0) {
                    if (v8 % 2 == 0) {
                        // 0x100003968
                        v22 = function_100003034(function_100003630());
                        function_1000031d0();
                        *(char *)&v1 = 0;
                        v12 = 0;
                        v13 = 0;
                        v14 = v8;
                        v24 = v22;
                    } else {
                        // 0x100003928
                        v23 = function_100003a5c();
                        function_1000031d0();
                        *(char *)&v1 = 0;
                        v12 = 0;
                        v13 = 0;
                        v14 = 0;
                        v24 = v23;
                    }
                } else {
                    // 0x1000039a8
                    v21 = v6 + 1;
                    *(char *)(v6 + v5) = 44;
                    *(char *)(v21 + v5) = 0;
                    v12 = v21;
                    v13 = v7;
                    v14 = v8;
                    v24 = v9;
                }
                // break -> 0x100003a18
                break;
            }
            default: {
                // 0x1000039dc
                v15 = v6 + 1;
                *(char *)(v6 + v5) = v11;
                *(char *)(v15 + v5) = 0;
                v12 = v15;
                v13 = v7;
                v14 = v8;
                v24 = v9;
                // break -> 0x100003a18
                break;
            }
        }
        int64_t v25 = v24;
        char * v26 = (char *)(v25 + v2); // 0x100003714
        while (*v26 != 0) {
            // 0x100003728
            v6 = v12;
            v7 = v13;
            v8 = v14;
            v9 = v25;
            char * v27 = v26;
            v10 = v9 + 1;
            *v4 = v10;
            v11 = *v27;
            switch (v11) {
                case 92: {
                    // 0x10000375c
                    *v4 = v10;
                    v16 = *v27;
                    if (v16 == 0) {
                        // break -> 0x100003a1c
                        break;
                    }
                    // 0x100003794
                    v18 = v6 + v5;
                    *(char *)v18 = 92;
                    v19 = v6 + 2;
                    *(char *)(v18 + 1) = v16;
                    *(char *)(v19 + v5) = 0;
                    v12 = v19;
                    v13 = v7;
                    v14 = v8;
                    v24 = v9;
                    // break -> 0x100003a18
                    break;
                }
                case 123: {
                    // 0x1000037f4
                    v17 = v6 + 1;
                    *(char *)(v6 + v5) = 123;
                    *(char *)(v17 + v5) = 0;
                    v12 = v17;
                    v13 = v7 + 1;
                    v14 = 1;
                    v24 = v9;
                    // break -> 0x100003a18
                    break;
                }
                case 125: {
                    if (v7 == 0) {
                        if (v8 % 2 == 0) {
                            // 0x1000038c8
                            function_100003034(function_100003630());
                            function_1000031d0();
                            goto lab_0x100003a1c;
                        } else {
                            // 0x1000038a4
                            function_100003a5c();
                            function_1000031d0();
                            goto lab_0x100003a1c;
                        }
                    }
                    // 0x100003868
                    v20 = v6 + 1;
                    *(char *)(v6 + v5) = 125;
                    *(char *)(v20 + v5) = 0;
                    v12 = v20;
                    v13 = v7 - 1;
                    v14 = v8;
                    v24 = v9;
                    // break -> 0x100003a18
                    break;
                }
                case 44: {
                    if (v7 == 0) {
                        if (v8 % 2 == 0) {
                            // 0x100003968
                            v22 = function_100003034(function_100003630());
                            function_1000031d0();
                            *(char *)&v1 = 0;
                            v12 = 0;
                            v13 = 0;
                            v14 = v8;
                            v24 = v22;
                        } else {
                            // 0x100003928
                            v23 = function_100003a5c();
                            function_1000031d0();
                            *(char *)&v1 = 0;
                            v12 = 0;
                            v13 = 0;
                            v14 = 0;
                            v24 = v23;
                        }
                    } else {
                        // 0x1000039a8
                        v21 = v6 + 1;
                        *(char *)(v6 + v5) = 44;
                        *(char *)(v21 + v5) = 0;
                        v12 = v21;
                        v13 = v7;
                        v14 = v8;
                        v24 = v9;
                    }
                    // break -> 0x100003a18
                    break;
                }
                default: {
                    // 0x1000039dc
                    v15 = v6 + 1;
                    *(char *)(v6 + v5) = v11;
                    *(char *)(v15 + v5) = 0;
                    v12 = v15;
                    v13 = v7;
                    v14 = v8;
                    v24 = v9;
                    // break -> 0x100003a18
                    break;
                }
            }
            // 0x100003a18
            v25 = v24;
            v26 = (char *)(v25 + v2);
        }
    }
    goto lab_0x100003a1c;
  lab_0x100003a1c:;
    int64_t v28 = *(int64_t *)0x100004008; // 0x100003a2c
    if (*(int64_t *)v28 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003a44
        ___stack_chk_fail();
    }
    // 0x100003a48
    return result;
}

// Address range: 0x100003a5c - 0x100003ca4
int64_t function_100003a5c(void) {
    int64_t result = function_10000309c(); // 0x100003a80
    int64_t v1; // bp-152, 0x100003a5c
    _memset(&v1, 0, 128);
    int64_t v2; // 0x100003a5c
    char * v3 = (char *)v2; // 0x100003aac
    if (*v3 != 0) {
        int64_t * v4 = (int64_t *)v2; // 0x100003ad0
        int64_t v5 = &v1;
        int64_t v6 = 0;
        int64_t v7 = 0;
        int64_t v8 = v7 + 1; // 0x100003acc
        *v4 = v8;
        char v9 = *v3; // 0x100003ad8
        int64_t v10; // 0x100003a5c
        int64_t v11; // 0x100003be8
        char v12; // 0x100003b0c
        int64_t v13; // 0x100003b78
        int64_t v14; // 0x100003b34
        int64_t v15; // 0x100003a5c
        switch (v9) {
            case 92: {
                // 0x100003af4
                *v4 = v8;
                v12 = *v3;
                if (v12 == 0) {
                    // break -> 0x100003c18
                    break;
                }
                // 0x100003b2c
                v14 = v6 + 1;
                *(char *)(v6 + v5) = v12;
                *(char *)(v14 + v5) = 0;
                v10 = v14;
                v15 = v7;
                // break -> 0x100003c14
                break;
            }
            case 123: {
                // 0x100003b70
                v13 = function_1000036b4();
                if (v6 != 0) {
                    // 0x100003b94
                    function_100003034(function_100003630());
                    function_1000031d0();
                    *(char *)&v1 = 0;
                }
                // 0x100003bd0
                function_1000031d0();
                v10 = 0;
                v15 = v13;
                // break -> 0x100003c14
                break;
            }
            default: {
                // 0x100003be0
                v11 = v6 + 1;
                *(char *)(v6 + v5) = v9;
                *(char *)(v11 + v5) = 0;
                v10 = v11;
                v15 = v7;
                // break -> 0x100003c14
                break;
            }
        }
        int64_t v16 = v15;
        int64_t v17 = v10;
        char * v18 = (char *)(v16 + v2); // 0x100003aac
        while (*v18 != 0) {
            // 0x100003ac0
            v6 = v17;
            v7 = v16;
            char * v19 = v18;
            v8 = v7 + 1;
            *v4 = v8;
            v9 = *v19;
            switch (v9) {
                case 92: {
                    // 0x100003af4
                    *v4 = v8;
                    v12 = *v19;
                    if (v12 == 0) {
                        // break -> 0x100003c18
                        break;
                    }
                    // 0x100003b2c
                    v14 = v6 + 1;
                    *(char *)(v6 + v5) = v12;
                    *(char *)(v14 + v5) = 0;
                    v10 = v14;
                    v15 = v7;
                    // break -> 0x100003c14
                    break;
                }
                case 123: {
                    // 0x100003b70
                    v13 = function_1000036b4();
                    if (v6 != 0) {
                        // 0x100003b94
                        function_100003034(function_100003630());
                        function_1000031d0();
                        *(char *)&v1 = 0;
                    }
                    // 0x100003bd0
                    function_1000031d0();
                    v10 = 0;
                    v15 = v13;
                    // break -> 0x100003c14
                    break;
                }
                default: {
                    // 0x100003be0
                    v11 = v6 + 1;
                    *(char *)(v6 + v5) = v9;
                    *(char *)(v11 + v5) = 0;
                    v10 = v11;
                    v15 = v7;
                    // break -> 0x100003c14
                    break;
                }
            }
            // 0x100003c14
            v16 = v15;
            v17 = v10;
            v18 = (char *)(v16 + v2);
        }
        // 0x100003c18
        if (v17 != 0) {
            // 0x100003c2c
            function_100003034(function_100003630());
            function_1000031d0();
            *(char *)&v1 = 0;
        }
    }
    int64_t v20 = *(int64_t *)0x100004008; // 0x100003c78
    if (*(int64_t *)v20 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003c90
        ___stack_chk_fail();
    }
    // 0x100003c94
    return result;
}

// Address range: 0x100003ca4 - 0x100003d58
int64_t function_100003ca4(void) {
    int64_t v1 = 0; // bp-32, 0x100003cb8
    function_100003a5c();
    int64_t v2 = function_100003314(); // 0x100003ccc
    _printf("Pattern: %s\n", &v1);
    int64_t v3 = 0; // 0x100003d04
    if (v2 == 0) {
        // 0x100003d38
        _printf("\n");
        return function_1000030cc();
    }
    function_10000348c();
    _printf("\n");
    v3++;
    while (v3 != v2) {
        // 0x100003d0c
        function_10000348c();
        _printf("\n");
        v3++;
    }
    // 0x100003d38
    _printf("\n");
    return function_1000030cc();
}

// Address range: 0x100003d58 - 0x100003da4
int64_t entry_point(void) {
    // 0x100003d58
    function_100003ca4();
    function_100003ca4();
    function_100003ca4();
    return 0;
}

// Address range: 0x100003da4 - 0x100003db0
int64_t function_100003da4(void) {
    // 0x100003da4
    return ___stack_chk_fail();
}

// Address range: 0x100003db0 - 0x100003dbc
int64_t function_100003db0(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003db0
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003dbc - 0x100003dc8
int64_t * function_100003dbc(int32_t nmemb, int32_t size) {
    // 0x100003dbc
    return _calloc(nmemb, size);
}

// Address range: 0x100003dc8 - 0x100003dd4
void function_100003dc8(int32_t status) {
    // 0x100003dc8
    _exit(status);
}

// Address range: 0x100003dd4 - 0x100003de0
int32_t function_100003dd4(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003dd4
    return _fprintf(stream, format);
}

// Address range: 0x100003de0 - 0x100003dec
void function_100003de0(int64_t * ptr) {
    // 0x100003de0
    _free(ptr);
}

// Address range: 0x100003dec - 0x100003df8
int64_t * function_100003dec(int32_t size) {
    // 0x100003dec
    return _malloc(size);
}

// Address range: 0x100003df8 - 0x100003e04
int64_t * function_100003df8(int64_t * s, int32_t c, int32_t n) {
    // 0x100003df8
    return _memset(s, c, n);
}

// Address range: 0x100003e04 - 0x100003e10
int32_t function_100003e04(char * format, ...) {
    // 0x100003e04
    return _printf(format);
}

// Address range: 0x100003e10 - 0x100003e1c
int32_t function_100003e10(char * s) {
    // 0x100003e10
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 23

`
`//FormAI DATASET v1.0 Category: System boot optimizer ; Style: creative
#include <stdio.h>

int main() {
    printf("Welcome to the C System boot optimizer!\n");
    printf("This program will optimize the boot process of your system to make it faster and more efficient.\n");

    int num_of_processes;
    printf("How many processes do you want to optimize? ");
    scanf("%d", &num_of_processes);

    int processes[num_of_processes];
    printf("Enter the process IDs to optimize:\n");
    for (int i=0; i<num_of_processes; i++) {
        printf("Process %d: ", i+1);
        scanf("%d", &processes[i]);
    }

    printf("\nOptimizing boot process...\n");
    for (int i=0; i<num_of_processes; i++) {
        printf("Killing process %d...\n", processes[i]);
        // code to kill the specified process goes here
    }
    printf("All specified processes have been optimized!\n");

    printf("\nDisabling unnecessary startup programs...\n");
    // code to disable unnecessary startup programs goes here
    printf("All unnecessary startup programs have been disabled!\n");

    printf("\nCleaning up system files...\n");
    // code to clean up system files goes here
    printf("All system files have been cleaned up!\n");

    printf("\nSystem optimization complete!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  char v5; // [rsp+20h] [rbp-20h] BYREF
  int v6; // [rsp+24h] [rbp-1Ch] BYREF
  char *v7; // [rsp+28h] [rbp-18h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the C System boot optimizer!\n");
  printf("This program will optimize the boot process of your system to make it faster and more efficient.\n");
  printf("How many processes do you want to optimize? ");
  scanf("%d", &v6);
  v8 = v6 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(4i64 * v6 + 15) >> 4));
  v7 = &v5;
  printf("Enter the process IDs to optimize:\n");
  for ( i = 0; i < v6; ++i )
  {
    printf("Process %d: ", (unsigned int)(i + 1));
    scanf("%d", &v7[4 * i]);
  }
  printf("\nOptimizing boot process...\n");
  for ( j = 0; j < v6; ++j )
    printf("Killing process %d...\n", *(unsigned int *)&v7[4 * j]);
  printf("All specified processes have been optimized!\n");
  printf("\nDisabling unnecessary startup programs...\n");
  printf("All unnecessary startup programs have been disabled!\n");
  printf("\nCleaning up system files...\n");
  printf("All system files have been cleaned up!\n");
  printf("\nSystem optimization complete!\n");
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdlib.h>
#include <stdio.h>
#include <math.h>

/* declare a typedef for a function pointer */
typedef double (*Class2Func)(double);

/*A couple of functions with the above prototype */
double functionA( double v)
{
   return v*v*v;
}
double functionB(double v)
{
   return exp(log(v)/3);
}

/* A function taking a function as an argument */
double Function1( Class2Func f2, double val )
{
    return f2(val);
}

/*A function returning a function */
Class2Func WhichFunc( int idx)
{
   return (idx < 4) ? &functionA : &functionB;
}

/* A list of functions */
Class2Func funcListA[] = {&functionA, &sin, &cos, &tan };
Class2Func funcListB[] = {&functionB, &asin, &acos, &atan };

/* Composing Functions */
double InvokeComposed( Class2Func f1, Class2Func f2, double val )
{
   return f1(f2(val));
}

typedef struct sComposition {
   Class2Func f1;
   Class2Func f2;
} *Composition;

Composition Compose( Class2Func f1, Class2Func f2)
{
   Composition comp = malloc(sizeof(struct sComposition));
   comp->f1 = f1;
   comp->f2 = f2;
   return comp;
}

double CallComposed( Composition comp, double val )
{
    return comp->f1( comp->f2(val) );
}
/** * * * * * * * * * * * * * * * * * * * * * * * * * * */

int main(int argc, char *argv[])
{
   int ix;
   Composition c;

   printf("Function1(functionA, 3.0) = %f\n", Function1(WhichFunc(0), 3.0));

   for (ix=0; ix<4; ix++) {
       c = Compose(funcListA[ix], funcListB[ix]);
       printf("Compostion %d(0.9) = %f\n", ix, CallComposed(c, 0.9));
   }

   return 0;
}
`,`#include "first-class-functions-1.h"



undefined  [16] _functionA(double param_1)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 * param_1 * param_1;
  auVar1._8_8_ = 0;
  return auVar1;
}



void _functionB(undefined8 param_1)

{
  double dVar1;
  
  dVar1 = (double)_log(param_1);
  _exp(dVar1 / 3.0);
  return;
}



void _Function1(undefined8 param_1,code *param_2)

{
  (*param_2)(param_1);
  return;
}



code * _WhichFunc(int param_1)

{
  code *pcVar1;
  
  pcVar1 = _functionA;
  if (3 < param_1) {
    pcVar1 = _functionB;
  }
  return pcVar1;
}



void _InvokeComposed(undefined8 param_1,code *param_2,code *param_3)

{
  (*param_3)(param_1);
  (*param_2)();
  return;
}



undefined8 * _Compose(undefined8 param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(0x10);
  *puVar1 = param_1;
  puVar1[1] = param_2;
  return puVar1;
}



void _CallComposed(undefined8 param_1,undefined8 *param_2)

{
  code *pcVar1;
  
  pcVar1 = (code *)*param_2;
  (*(code *)param_2[1])(param_1);
  (*pcVar1)();
  return;
}



undefined8 entry(void)

{
  undefined8 uVar1;
  int local_24;
  
  _WhichFunc(0);
  _Function1(0x4008000000000000);
  _printf("Function1(functionA, 3.0) = %f\n");
  for (local_24 = 0; local_24 < 4; local_24 = local_24 + 1) {
    uVar1 = _Compose((&_funcListA)[local_24],(&_funcListB)[local_24]);
    _CallComposed(0x3feccccccccccccd,uVar1);
    _printf("Compostion %d(0.9) = %f\n");
  }
  return 0;
}



void _exp(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exp_100004000)();
  return;
}



void _log(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__log_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <math.h>
#include <stdio.h>

const char* animals[] = { "Rat","Ox","Tiger","Rabbit","Dragon","Snake","Horse","Goat","Monkey","Rooster","Dog","Pig" };
const char* elements[] = { "Wood","Fire","Earth","Metal","Water" };

const char* getElement(int year) {
    int element = (int)floor((year - 4) % 10 / 2);
    return elements[element];
}

const char* getAnimal(int year) {
    return animals[(year - 4) % 12];
}

const char* getYY(int year) {
    if (year % 2 == 0) {
        return "yang";
    } else {
        return "yin";
    }
}

int main() {
    int years[] = { 1935, 1938, 1968, 1972, 1976, 2017 };
    int i;

    //the zodiac cycle didnt start until 4 CE, so years <4 shouldnt be valid
    for (i = 0; i < 6; ++i) {
        int year = years[i];
        printf("%d is the year of the %s %s (%s).\n", year, getElement(year), getAnimal(year), getYY(year));
    }

    return 0;
}
`,`#include "chinese-zodiac.h"



undefined * _getElement(int param_1)

{
  return (&_elements)[(int)(double)(((param_1 + -4) % 10) / 2)];
}



undefined * _getAnimal(int param_1)

{
  return (&_animals)[(param_1 + -4) % 0xc];
}



char * _getYY(int param_1)

{
  char *local_8;
  
  if (param_1 % 2 == 0) {
    local_8 = "yang";
  }
  else {
    local_8 = "yin";
  }
  return local_8;
}



undefined8 entry(ulong param_1)

{
  undefined4 uVar1;
  uint uVar2;
  int local_38;
  undefined8 local_30;
  undefined8 uStack_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_28 = 0x7b4000007b0;
  local_30 = 0x7920000078f;
  local_20 = 0x7e1000007b8;
  for (local_38 = 0; local_38 < 6; local_38 = local_38 + 1) {
    uVar1 = *(undefined4 *)((long)&local_30 + (long)local_38 * 4);
    _getElement(uVar1);
    _getAnimal(uVar1);
    _getYY(uVar1);
    uVar2 = _printf("%d is the year of the %s %s (%s).\n");
    param_1 = (ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>

#define n_bins 10

double rand01() { return rand() / (RAND_MAX + 1.0); }

double avg(int count, double *stddev, int *hist)
{
	double x[count];
	double m = 0, s = 0;

	for (int i = 0; i < n_bins; i++) hist[i] = 0;
	for (int i = 0; i < count; i++) {
		m += (x[i] = rand01());
		hist[(int)(x[i] * n_bins)] ++;
	}

	m /= count;
	for (int i = 0; i < count; i++)
		s += x[i] * x[i];
	*stddev = sqrt(s / count - m * m);
	return m;
}

void hist_plot(int *hist)
{
	int max = 0, step = 1;
	double inc = 1.0 / n_bins;

	for (int i = 0; i < n_bins; i++)
		if (hist[i] > max) max = hist[i];

	/* scale if numbers are too big */
	if (max >= 60) step = (max + 59) / 60;

	for (int i = 0; i < n_bins; i++) {
		printf("[%5.2g,%5.2g]%5d ", i * inc, (i + 1) * inc, hist[i]);
		for (int j = 0; j < hist[i]; j += step)
			printf("#");
		printf("\n");
	}
}

/*  record for moving average and stddev.  Values kept are sums and sum data^2
 *  to avoid excessive precision loss due to divisions, but some loss is inevitable
 */
typedef struct {
	uint64_t size;
	double sum, x2;
	uint64_t hist[n_bins];
} moving_rec;

void moving_avg(moving_rec *rec, double *data, int count)
{
	double sum = 0, x2 = 0;
	/* not adding data directly to the sum in case both recorded sum and
	 * count of this batch are large; slightly less likely to lose precision*/
	for (int i = 0; i < count; i++) {
		sum += data[i];
		x2 += data[i] * data[i];
		rec->hist[(int)(data[i] * n_bins)]++;
	}

	rec->sum += sum;
	rec->x2 += x2;
	rec->size += count;
}

int main()
{
	double m, stddev;
	int hist[n_bins], samples = 10;

	while (samples <= 10000) {
		m = avg(samples, &stddev, hist);
		printf("size %5d: %g %g\n", samples, m, stddev);
		samples *= 10;
	}

	printf("\nHistograph:\n");
	hist_plot(hist);

	printf("\nMoving average:\n  N     Mean    Sigma\n");
	moving_rec rec = { 0, 0, 0, {0} };
	double data[100];
	for (int i = 0; i < 10000; i++) {
		for (int j = 0; j < 100; j++) data[j] = rand01();

		moving_avg(&rec, data, 100);

		if ((i % 1000) == 999) {
			printf("%4lluk %f %f\n",
				rec.size/1000,
				rec.sum / rec.size,
				sqrt(rec.x2 * rec.size - rec.sum * rec.sum)/rec.size
			);
		}
	}
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000037e8(int64_t a1);
int64_t function_10000380c(int32_t a1, int64_t * a2, int64_t * a3);
int64_t function_10000385c(void);
int64_t function_100003a28(void);
int64_t function_100003bcc(void);
int64_t function_100003ee8(int64_t a1);
int64_t * function_100003ef4(int64_t * s, int32_t c, int32_t n);
int32_t function_100003f00(char * format, ...);
int32_t function_100003f0c(void);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000037e8 - 0x10000380c
int64_t function_1000037e8(int64_t a1) {
    // 0x1000037e8
    return _rand();
}

// Address range: 0x10000380c - 0x10000385c
int64_t function_10000380c(int32_t a1, int64_t * a2, int64_t * a3) {
    // 0x10000380c
    return ___chkstk_darwin();
}

// Address range: 0x10000385c - 0x100003a28
int64_t function_10000385c(void) {
    // 0x10000385c
    int64_t v1; // 0x10000385c
    int64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 - 88); // 0x10000386c
    int64_t v4; // 0x10000385c
    *v3 = (int64_t)&v4 - *(int64_t *)(v2 - 96);
    int64_t v5 = v2 - 56; // 0x100003878
    float64_t * v6 = (float64_t *)v5; // 0x100003878
    *v6 = 0.0;
    float64_t * v7 = (float64_t *)(v2 - 64); // 0x10000387c
    *v7 = 0.0;
    int32_t * v8 = (int32_t *)(v2 - 68); // 0x100003880
    *v8 = 0;
    int64_t * v9 = (int64_t *)(v2 - 32);
    *(int32_t *)*v9 = 0;
    int32_t v10 = *v8; // 0x1000038b0
    int32_t v11 = v10 + 1; // 0x1000038b4
    *v8 = v11;
    while (v10 < 9 != (8 - v10 & v11) < 0) {
        // 0x10000389c
        *(int32_t *)(4 * (int64_t)v11 + *v9) = 0;
        v10 = *v8;
        v11 = v10 + 1;
        *v8 = v11;
    }
    int32_t * v12 = (int32_t *)(v2 - 72); // 0x1000038c0
    *v12 = 0;
    int32_t * v13 = (int32_t *)(v2 - 12); // 0x1000038cc
    int32_t v14 = *v13; // 0x1000038cc
    int32_t v15 = -v14; // 0x1000038d0
    float64_t v16 = 0.0; // 0x1000038d8
    float64_t v17 = 0.0; // 0x1000038d8
    int64_t v18; // 0x10000385c
    if (v15 < 0 != (v14 & v15) < 0) {
        int64_t v19 = function_1000037e8((int64_t)&g1); // 0x1000038e0
        int64_t v20 = *v3; // 0x1000038e4
        *(float64_t *)(8 * (int64_t)*v12 + v20) = v16;
        *v6 = v16 + *v6;
        v16 = 10.0 * *(float64_t *)(8 * (int64_t)*v12 + v20);
        int32_t * v21 = (int32_t *)(4 * (int64_t)(int32_t)v16 + *v9); // 0x10000391c
        *v21 = *v21 + 1;
        int32_t v22 = *v12 + 1; // 0x100003930
        *v12 = v22;
        int32_t v23 = *v13; // 0x1000038cc
        int32_t v24 = v22 - v23; // 0x1000038d0
        v18 = v19;
        v17 = v16;
        while (v24 < 0 != ((v24 ^ v22) & (v23 ^ v22)) < 0) {
            // 0x1000038e0
            v19 = function_1000037e8((int64_t)&g1);
            v20 = *v3;
            *(float64_t *)(8 * (int64_t)*v12 + v20) = v16;
            *v6 = v16 + *v6;
            v16 = 10.0 * *(float64_t *)(8 * (int64_t)*v12 + v20);
            v21 = (int32_t *)(4 * (int64_t)(int32_t)v16 + *v9);
            *v21 = *v21 + 1;
            v22 = *v12 + 1;
            *v12 = v22;
            v23 = *v13;
            v24 = v22 - v23;
            v18 = v19;
            v17 = v16;
        }
    }
    // 0x10000393c
    __asm_sshll(0.0f, 0);
    *v6 = *v6 / v17;
    int32_t * v25 = (int32_t *)(v2 - 76); // 0x100003958
    *v25 = 0;
    int32_t v26 = *v13; // 0x100003964
    int32_t v27 = -v26; // 0x100003968
    float64_t v28 = v17; // 0x100003970
    if (v27 < 0 != (v26 & v27) < 0) {
        float64_t v29 = *(float64_t *)*v3; // 0x100003980
        *v7 = *v7 + v29 * v29;
        int32_t v30 = *v25 + 1; // 0x1000039a0
        *v25 = v30;
        int32_t v31 = *v13; // 0x100003964
        int32_t v32 = v30 - v31; // 0x100003968
        v28 = v29;
        while (v32 < 0 != ((v32 ^ v30) & (v31 ^ v30)) < 0) {
            // 0x100003978
            v29 = *(float64_t *)(8 * (int64_t)v30 + *v3);
            *v7 = *v7 + v29 * v29;
            v30 = *v25 + 1;
            *v25 = v30;
            v31 = *v13;
            v32 = v30 - v31;
            v28 = v29;
        }
    }
    // 0x1000039ac
    __asm_sshll(0.0f, 0);
    float64_t v33 = *v6; // 0x1000039c4
    float64_t v34 = sqrt(*v7 / v28 - v33 * v33); // 0x1000039d0
    *(float64_t *)*(int64_t *)(v2 - 24) = v34;
    *(int64_t *)(v2 - 112) = *(int64_t *)v5;
    *(int64_t *)(v2 - 104) = *(int64_t *)(v2 - 40);
    int64_t result = v18; // 0x100003a04
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003a0c
        result = ___stack_chk_fail(v18);
    }
    // 0x100003a10
    return result;
}

// Address range: 0x100003a28 - 0x100003bcc
int64_t function_100003a28(void) {
    int32_t v1 = 0;
    int64_t v2; // 0x100003a28
    for (int64_t i = 0; i < 10; i++) {
        int32_t v3 = v1;
        int32_t v4 = *(int32_t *)(4 * i + v2); // 0x100003a74
        int32_t v5 = v4 - v3; // 0x100003a7c
        v1 = v5 == 0 | v5 < 0 != ((v5 ^ v4) & (v4 ^ v3)) < 0 ? v3 : v4;
    }
    int32_t v6 = 1; // 0x100003ac0
    if (v1 < 60 == (59 - v1 & v1) < 0) {
        // 0x100003ac8
        v6 = (v1 + 59) / 60;
    }
    int32_t result; // 0x100003ba8
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003afc
        int128_t v7; // 0x100003a28
        _printf("[%5.2g,%5.2g]%5d ", (float64_t)(int64_t)__asm_sshll(0.0f, 0), (float64_t)(int64_t)v7, v2);
        int32_t * v8 = (int32_t *)(4 * i + v2); // 0x100003b68
        int32_t v9 = *v8; // 0x100003b68
        int32_t v10 = -v9; // 0x100003b6c
        if (v10 < 0 != (v9 & v10) < 0) {
            _printf("#");
            int32_t v11 = v6; // 0x100003b94
            int32_t v12 = *v8; // 0x100003b68
            int32_t v13 = v11 - v12; // 0x100003b6c
            int32_t v14 = v11; // 0x100003b74
            while (v13 < 0 != ((v13 ^ v11) & (v12 ^ v11)) < 0) {
                // 0x100003b7c
                _printf("#");
                v11 = v14 + v6;
                v12 = *v8;
                v13 = v11 - v12;
                v14 = v11;
            }
        }
        // 0x100003ba0
        result = _printf("\n");
    }
    // 0x100003bc0
    return result;
}

// Address range: 0x100003bcc - 0x100003ccc
int64_t function_100003bcc(void) {
    // 0x100003bcc
    int64_t v1; // 0x100003bcc
    int64_t result = v1;
    int32_t v2 = v1; // 0x100003bd8
    int32_t v3 = -v2; // 0x100003bf8
    float64_t v4 = 0.0; // 0x100003c00
    float64_t v5 = 0.0; // 0x100003c00
    if (v3 < 0 != (v3 & v2) < 0) {
        int32_t v6 = 0; // 0x100003c7c
        float64_t v7 = 0.0; // 0x100003c3c
        float64_t v8 = 0.0; // 0x100003c18
        float64_t v9 = *(float64_t *)(8 * (int64_t)v6 + v1); // 0x100003c10
        v8 += v9;
        v7 += v9 * v9;
        int64_t * v10 = (int64_t *)(result + 24 + 8 * (int64_t)(int32_t)(10.0 * v9)); // 0x100003c68
        *v10 = *v10 + 1;
        v6++;
        int32_t v11 = v6 - v2; // 0x100003bf8
        v4 = v8;
        v5 = v7;
        while (v11 < 0 != ((v11 ^ v6) & (v6 ^ v2)) < 0) {
            // 0x100003c08
            v9 = *(float64_t *)(8 * (int64_t)v6 + v1);
            v8 += v9;
            v7 += v9 * v9;
            v10 = (int64_t *)(result + 24 + 8 * (int64_t)(int32_t)(10.0 * v9));
            *v10 = *v10 + 1;
            v6++;
            v11 = v6 - v2;
            v4 = v8;
            v5 = v7;
        }
    }
    float64_t * v12 = (float64_t *)(result + 8); // 0x100003c90
    *v12 = v4 + *v12;
    float64_t * v13 = (float64_t *)(result + 16); // 0x100003ca4
    *v13 = v5 + *v13;
    *(int64_t *)result = result + (0x100000000 * v1 >> 32);
    return result;
}

// Address range: 0x100003ccc - 0x100003ee8
int64_t entry_point(void) {
    // 0x100003ccc
    float64_t v1; // 0x100003ccc
    float64_t v2 = v1;
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003ce4
    float64_t v4; // bp-896, 0x100003ccc
    int64_t v5 = &v4; // 0x100003d18
    int32_t v6 = 10; // 0x100003d5c
    int64_t v7; // bp-72, 0x100003ccc
    function_10000380c(v6, (int64_t *)&v4, &v7);
    int128_t v8; // 0x100003ccc
    _printf("size %5d: %g %g\n", v5, (float64_t)(int64_t)v8, (float64_t)(int64_t)v8);
    v6 *= 10;
    while (v6 == 0x2710 || v6 < 0x2710 != (0x270f - v6 & v6) < 0) {
        // 0x100003d14
        function_10000380c(v6, (int64_t *)&v4, &v7);
        _printf("size %5d: %g %g\n", v5, (float64_t)(int64_t)v8, (float64_t)(int64_t)v8);
        v6 *= 10;
    }
    float64_t v9 = (int64_t)v4;
    _printf("\nHistograph:\n");
    function_100003a28();
    _printf("\nMoving average:\n  N     Mean    Sigma\n");
    int64_t v10; // bp-1008, 0x100003ccc
    _memset(&v10, 0, 104);
    int64_t v11; // bp-872, 0x100003ccc
    int64_t v12 = &v11;
    int32_t v13 = 0;
    for (int64_t i = 0; i < 100; i++) {
        // 0x100003dd4
        function_1000037e8(i);
        *(int64_t *)(8 * i + v12) = (int64_t)v9;
    }
    int64_t v14 = function_100003bcc(); // 0x100003e24
    int64_t v15; // 0x100003ccc
    if (v13 % 1000 == 999) {
        // 0x100003e2c
        v15 = v10;
        v9 = sqrt(-((v2 * v2 - v1 * (float64_t)v15))) / (float64_t)v15;
        v14 = _printf("%4lluk %f %f\n", v12, (float64_t)(int64_t)v8, (float64_t)(int64_t)v8);
    }
    int32_t v16 = v13 + 1; // 0x100003e9c
    while (v13 < 0x270f != (0x270e - v13 & v16) < 0) {
        // 0x100003dc0
        v13 = v16;
        for (int64_t i = 0; i < 100; i++) {
            // 0x100003dd4
            function_1000037e8(i);
            *(int64_t *)(8 * i + v12) = (int64_t)v9;
        }
        // 0x100003df8
        v14 = function_100003bcc();
        if (v13 % 1000 == 999) {
            // 0x100003e2c
            v15 = v10;
            v9 = sqrt(-((v2 * v2 - v1 * (float64_t)v15))) / (float64_t)v15;
            v14 = _printf("%4lluk %f %f\n", v12, (float64_t)(int64_t)v8, (float64_t)(int64_t)v8);
        }
        // 0x100003e98
        v16 = v13 + 1;
    }
    // 0x100003ea8
    if (*(int64_t *)*(int64_t *)0x100004010 != v3) {
        // 0x100003ed0
        ___stack_chk_fail(v14);
    }
    // 0x100003ed4
    return 0;
}

// Address range: 0x100003ee8 - 0x100003ef4
int64_t function_100003ee8(int64_t a1) {
    // 0x100003ee8
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t * function_100003ef4(int64_t * s, int32_t c, int32_t n) {
    // 0x100003ef4
    return _memset(s, c, n);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * format, ...) {
    // 0x100003f00
    return _printf(format);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(void) {
    // 0x100003f0c
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv) //not sure if argv counts as input stream... certainly it is brought here via input stream.
{
   printf("%d\n", atoi(*(argv+1)) + atoi(*(argv+2)));
   return 0;
}
`,`#include "a+b-3.h"



undefined4 entry(undefined8 param_1,long param_2)

{
  _atoi(*(char **)(param_2 + 8));
  _atoi(*(char **)(param_2 + 0x10));
  _printf("%d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`   #include<stdlib.h>
   #include<ctype.h>
   #include<stdio.h>

   int** oddMagicSquare(int n) {
        if (n < 3 || n % 2 == 0)
            return NULL;

        int value = 0;
        int squareSize = n * n;
        int c = n / 2, r = 0,i;

        int** result = (int**)malloc(n*sizeof(int*));
		
		for(i=0;i<n;i++)
			result[i] = (int*)malloc(n*sizeof(int));

        while (++value <= squareSize) {
            result[r][c] = value;
            if (r == 0) {
                if (c == n - 1) {
                    r++;
                } else {
                    r = n - 1;
                    c++;
                }
            } else if (c == n - 1) {
                r--;
                c = 0;
            } else if (result[r - 1][c + 1] == 0) {
                r--;
                c++;
            } else {
                r++;
            }
        }
        return result;
    }

    int** singlyEvenMagicSquare(int n) {
        if (n < 6 || (n - 2) % 4 != 0)
            return NULL;

        int size = n * n;
        int halfN = n / 2;
        int subGridSize = size / 4, i;

        int** subGrid = oddMagicSquare(halfN);
        int gridFactors[] = {0, 2, 3, 1};
        int** result = (int**)malloc(n*sizeof(int*));
		
		for(i=0;i<n;i++)
			result[i] = (int*)malloc(n*sizeof(int));

        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                int grid = (r / halfN) * 2 + (c / halfN);
                result[r][c] = subGrid[r % halfN][c % halfN];
                result[r][c] += gridFactors[grid] * subGridSize;
            }
        }

        int nColsLeft = halfN / 2;
        int nColsRight = nColsLeft - 1;

        for (int r = 0; r < halfN; r++)
            for (int c = 0; c < n; c++) {
                if (c < nColsLeft || c >= n - nColsRight
                        || (c == nColsLeft && r == nColsLeft)) {

                    if (c == 0 && r == nColsLeft)
                        continue;

                    int tmp = result[r][c];
                    result[r][c] = result[r + halfN][c];
                    result[r + halfN][c] = tmp;
                }
            }

        return result;
    }
	
	int numDigits(int n){
		int count = 1;
		
		while(n>=10){
			n /= 10;
			count++;
		}
		
		return count;
	}
	
	void printMagicSquare(int** square,int rows){
		int i,j;
		
		for(i=0;i<rows;i++){
			for(j=0;j<rows;j++){
				printf("%*s%d",rows - numDigits(square[i][j]),"",square[i][j]);
			}
			printf("\n");
		}
		printf("\nMagic constant: %d ", (rows * rows + 1) * rows / 2);
	}
	
	int main(int argC,char* argV[])
	{
		int n;
		
		if(argC!=2||isdigit(argV[1][0])==0)
			printf("Usage : %s <integer specifying rows in magic square>",argV[0]);
		else{
			n = atoi(argV[1]);
			printMagicSquare(singlyEvenMagicSquare(n),n);
		}
		return 0;
	}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000036cc(void);
int64_t function_1000038ec(void);
int64_t function_100003ccc(void);
int64_t function_100003d20(void);
int64_t function_100003ef4(void);
int32_t function_100003f00(char * nptr);
int32_t function_100003f0c(int32_t c);
int64_t * function_100003f18(int32_t size);
int32_t function_100003f24(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 4.24399158193054463022276442972641766e-314L; // 0x100003f30

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _atoi(char * a1);
int32_t _isdigit(int32_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000036cc - 0x1000038ec
int64_t function_1000036cc(void) {
    // 0x1000036cc
    int64_t v1; // 0x1000036cc
    int32_t v2 = v1; // 0x1000036d8
    if (v2 < 3 != (2 - v2 & v2) < 0) {
        // 0x1000038dc
        return 0;
    }
    int32_t v3 = v2 / 2; // 0x1000036f8
    if (2 * v3 == v2) {
        // 0x1000038dc
        return 0;
    }
    int64_t result = (int64_t)_malloc(8 * v2); // 0x10000374c
    int32_t v4 = -v2; // 0x100003764
    if (v4 < 0 != (v4 & v2) < 0) {
        int32_t v5 = 0; // 0x100003794
        *(int64_t *)(8 * (int64_t)v5 + result) = (int64_t)_malloc(4 * v2);
        v5++;
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003774
            *(int64_t *)(8 * (int64_t)v5 + result) = (int64_t)_malloc(4 * v2);
            v5++;
        }
    }
    int32_t v6 = v2 * v2; // 0x100003728
    int32_t v7 = 1 - v6; // 0x1000037b4
    if (v7 != 0 && v7 < 0 == (v7 & v6) < 0) {
        // 0x1000038dc
        return result;
    }
    int32_t v8 = v2 - 1;
    int32_t v9 = 1; // 0x1000037a8
    int32_t v10 = v3;
    int32_t v11 = 0;
    int64_t v12 = *(int64_t *)(8 * (int64_t)v11 + result); // 0x1000037d0
    *(int32_t *)(4 * (int64_t)v10 + v12) = v9;
    int32_t v13; // 0x1000036cc
    int32_t v14; // 0x1000036cc
    int64_t v15; // 0x100003878
    if (v11 == 0) {
        // 0x1000037f0
        v13 = v10 + (int32_t)(v10 != v8);
        v14 = v10 == v8 ? 1 : v8;
    } else {
        if (v10 == v8) {
            // 0x100003858
            v13 = 0;
            v14 = v11 - 1;
        } else {
            // 0x10000386c
            v15 = *(int64_t *)((int64_t)(8 * v11 - 8) + result);
            if (*(int32_t *)(v15 + (int64_t)(4 * v10 + 4)) == 0) {
                // 0x100003898
                v13 = v10 + 1;
                v14 = v11 - 1;
            } else {
                // 0x1000038b4
                v13 = v10;
                v14 = v11 + 1;
            }
        }
    }
    // 0x1000038cc
    v9++;
    while (v9 - v6 == 0 || v9 - v6 < 0 != ((v9 - v6 ^ v9) & (v9 ^ v6)) < 0) {
        // 0x1000037c4
        v10 = v13;
        v11 = v14;
        v12 = *(int64_t *)(8 * (int64_t)v11 + result);
        *(int32_t *)(4 * (int64_t)v10 + v12) = v9;
        if (v11 == 0) {
            // 0x1000037f0
            v13 = v10 + (int32_t)(v10 != v8);
            v14 = v10 == v8 ? 1 : v8;
        } else {
            if (v10 == v8) {
                // 0x100003858
                v13 = 0;
                v14 = v11 - 1;
            } else {
                // 0x10000386c
                v15 = *(int64_t *)((int64_t)(8 * v11 - 8) + result);
                if (*(int32_t *)(v15 + (int64_t)(4 * v10 + 4)) == 0) {
                    // 0x100003898
                    v13 = v10 + 1;
                    v14 = v11 - 1;
                } else {
                    // 0x1000038b4
                    v13 = v10;
                    v14 = v11 + 1;
                }
            }
        }
        // 0x1000038cc
        v9++;
    }
    // 0x1000038dc
    return result;
}

// Address range: 0x1000038ec - 0x100003ccc
int64_t function_1000038ec(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003900
    int64_t v2; // 0x1000038ec
    int32_t v3 = v2; // 0x100003908
    if (v3 < 6 != (5 - v3 & v3) < 0) {
        // 0x100003cbc
        return 0;
    }
    int32_t v4 = v3 - 2; // 0x100003924
    if (v4 != 4 * v4 / 4) {
        // 0x100003cbc
        return 0;
    }
    int32_t v5 = v3 / 2; // 0x100003968
    int64_t v6 = function_1000036cc(); // 0x100003984
    float128_t v7 = g1; // bp-48, 0x100003998
    int64_t result = (int64_t)_malloc(8 * v3); // 0x1000039a4
    int32_t v8 = -v3;
    if (v8 < 0 != (v8 & v3) < 0) {
        int32_t v9 = 0; // 0x1000039ec
        *(int64_t *)(8 * (int64_t)v9 + result) = (int64_t)_malloc(4 * v3);
        v9++;
        while (v9 - v3 < 0 != ((v9 - v3 ^ v9) & (v9 ^ v3)) < 0) {
            // 0x1000039cc
            *(int64_t *)(8 * (int64_t)v9 + result) = (int64_t)_malloc(4 * v3);
            v9++;
        }
        int64_t v10 = &v7;
        int32_t v11 = 0; // 0x100003af0
        int64_t * v12 = (int64_t *)(8 * (int64_t)v11 + result); // 0x100003a94
        int32_t v13 = 0; // 0x100003adc
        int64_t v14 = *(int64_t *)(v6 + (int64_t)(8 * (v11 % v5))); // 0x100003a70
        int32_t v15 = *(int32_t *)(v14 + (int64_t)(4 * (v13 % v5))); // 0x100003a88
        int64_t v16 = 4 * (int64_t)v13; // 0x100003a9c
        *(int32_t *)(*v12 + v16) = v15;
        int32_t v17 = *(int32_t *)(4 * (int64_t)(v13 / v5 + 2 * v11 / v5) + v10); // 0x100003aa8
        int32_t * v18 = (int32_t *)(*v12 + v16); // 0x100003ac8
        *v18 = *v18 + v17 * v3 * v3 / 4;
        v13++;
        while (v13 - v3 < 0 != ((v13 - v3 ^ v13) & (v13 ^ v3)) < 0) {
            // 0x100003a38
            v14 = *(int64_t *)(v6 + (int64_t)(8 * (v11 % v5)));
            v15 = *(int32_t *)(v14 + (int64_t)(4 * (v13 % v5)));
            v16 = 4 * (int64_t)v13;
            *(int32_t *)(*v12 + v16) = v15;
            v17 = *(int32_t *)(4 * (int64_t)(v13 / v5 + 2 * v11 / v5) + v10);
            v18 = (int32_t *)(*v12 + v16);
            *v18 = *v18 + v17 * v3 * v3 / 4;
            v13++;
        }
        // 0x100003aec
        v11++;
        while (v11 - v3 < 0 != ((v11 - v3 ^ v11) & (v11 ^ v3)) < 0) {
            // 0x100003a38
            v12 = (int64_t *)(8 * (int64_t)v11 + result);
            v13 = 0;
            v14 = *(int64_t *)(v6 + (int64_t)(8 * (v11 % v5)));
            v15 = *(int32_t *)(v14 + (int64_t)(4 * (v13 % v5)));
            v16 = 4 * (int64_t)v13;
            *(int32_t *)(*v12 + v16) = v15;
            v17 = *(int32_t *)(4 * (int64_t)(v13 / v5 + 2 * v11 / v5) + v10);
            v18 = (int32_t *)(*v12 + v16);
            *v18 = *v18 + v17 * v3 * v3 / 4;
            v13++;
            while (v13 - v3 < 0 != ((v13 - v3 ^ v13) & (v13 ^ v3)) < 0) {
                // 0x100003a38
                v14 = *(int64_t *)(v6 + (int64_t)(8 * (v11 % v5)));
                v15 = *(int32_t *)(v14 + (int64_t)(4 * (v13 % v5)));
                v16 = 4 * (int64_t)v13;
                *(int32_t *)(*v12 + v16) = v15;
                v17 = *(int32_t *)(4 * (int64_t)(v13 / v5 + 2 * v11 / v5) + v10);
                v18 = (int32_t *)(*v12 + v16);
                *v18 = *v18 + v17 * v3 * v3 / 4;
                v13++;
            }
            // 0x100003aec
            v11++;
        }
    }
    int32_t v19; // 0x1000038ec
    int32_t v20; // 0x1000038ec
    int32_t v21; // 0x1000038ec
    int32_t v22; // 0x100003b04
    int64_t * v23; // 0x1000038ec
    int64_t * v24; // 0x1000038ec
    if (v3 > 1 != (v5 & -v5) < 0) {
        // 0x100003b40
        v22 = v3 / 4;
        int32_t v25 = v3 + 1 - v22;
        int32_t v26 = 0; // 0x100003c78
        while (true) {
            // 0x100003b40
            v21 = v26;
            if (v8 < 0 != (v8 & v3) < 0) {
                // 0x100003b58
                v23 = (int64_t *)(8 * (int64_t)v21 + result);
                v24 = (int64_t *)((int64_t)(8 * (v21 + v5)) + result);
                v19 = 0;
                while (true) {
                  lab_0x100003b58:
                    // 0x100003b58
                    v20 = v19;
                    int32_t v27 = v20 - v22; // 0x100003b60
                    if (v27 < 0 == ((v27 ^ v20) & (v20 ^ v22)) < 0) {
                        int32_t v28 = v20 - v25; // 0x100003b80
                        if (v21 == v22 == v20 == v22 || v28 < 0 == ((v28 ^ v20) & (v20 ^ v25)) < 0) {
                            goto lab_0x100003bc0;
                        } else {
                            goto lab_0x100003c60;
                        }
                    } else {
                        goto lab_0x100003bc0;
                    }
                }
            }
          lab_0x100003c74:
            // 0x100003c74
            v26 = v21 + 1;
            int32_t v29 = v26 - v5; // 0x100003b28
            if (v29 < 0 == ((v29 ^ v26) & (v26 ^ v5)) < 0) {
                // break -> 0x100003c90
                break;
            }
        }
    }
    // 0x100003c90
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003cb8
        ___stack_chk_fail();
    }
    // 0x100003cbc
    return result;
  lab_0x100003bc0:
    if (v21 == v22 != (v20 == 0)) {
        int64_t v30 = 4 * (int64_t)v20; // 0x100003c00
        int32_t * v31 = (int32_t *)(*v23 + v30); // 0x100003c00
        *v31 = *(int32_t *)(*v24 + v30);
        *(int32_t *)(*v24 + v30) = *v31;
    }
    goto lab_0x100003c60;
  lab_0x100003c60:;
    int32_t v32 = v20 + 1; // 0x100003c64
    int32_t v33 = v32 - v3; // 0x100003b48
    v19 = v32;
    if (v33 < 0 == ((v33 ^ v32) & (v32 ^ v3)) < 0) {
        // break -> 0x100003c74
        goto lab_0x100003c74;
    }
    goto lab_0x100003b58;
}

// Address range: 0x100003ccc - 0x100003d20
int64_t function_100003ccc(void) {
    // 0x100003ccc
    int64_t v1; // 0x100003ccc
    int32_t v2 = v1; // 0x100003cd0
    int32_t result = 1; // 0x100003cec
    if (v2 < 10 != (9 - v2 & v2) < 0) {
        // 0x100003d14
        return 1;
    }
    int32_t v3 = v2;
    int32_t v4 = v3 / 10; // 0x100003cfc
    result++;
    while (v3 < 100 == (9 - v4 & v4) < 0) {
        // 0x100003cf4
        v3 = v4;
        v4 = v3 / 10;
        result++;
    }
    // 0x100003d14
    return result;
}

// Address range: 0x100003d20 - 0x100003e54
int64_t function_100003d20(void) {
    // 0x100003d20
    int64_t v1; // 0x100003d20
    int32_t v2 = v1; // 0x100003d30
    int32_t v3 = -v2;
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e10
        return _printf("\nMagic constant: %d ", v1);
    }
    int32_t v4 = 0; // 0x100003e04
    int32_t v5 = 0; // 0x100003de4
    function_100003ccc();
    _printf("%*s%d", v1, (char *)v1, v1);
    v5++;
    while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003d74
        function_100003ccc();
        _printf("%*s%d", v1, (char *)v1, v1);
        v5++;
    }
    // 0x100003df0
    _printf("\n");
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003d74
        v5 = 0;
        function_100003ccc();
        _printf("%*s%d", v1, (char *)v1, v1);
        v5++;
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003d74
            function_100003ccc();
            _printf("%*s%d", v1, (char *)v1, v1);
            v5++;
        }
        // 0x100003df0
        _printf("\n");
        v4++;
    }
    // 0x100003e10
    return _printf("\nMagic constant: %d ", v1);
}

// Address range: 0x100003e54 - 0x100003ef4
int64_t entry_point(void) {
    // 0x100003e54
    int64_t v1; // 0x100003e54
    if ((int32_t)v1 != 2) {
        // 0x100003ea0
        _printf("Usage : %s <integer specifying rows in magic square>", (char *)v1);
        // 0x100003ee4
        return 0;
    }
    int64_t * v2 = (int64_t *)(v1 + 8); // 0x100003e84
    if (_isdigit((int32_t)*(char *)*v2) == 0) {
        // 0x100003ea0
        _printf("Usage : %s <integer specifying rows in magic square>", (char *)v1);
        // 0x100003ee4
        return 0;
    }
    // 0x100003ec0
    _atoi((char *)*v2);
    function_1000038ec();
    function_100003d20();
    // 0x100003ee4
    return 0;
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(void) {
    // 0x100003ef4
    return ___stack_chk_fail();
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(char * nptr) {
    // 0x100003f00
    return _atoi(nptr);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(int32_t c) {
    // 0x100003f0c
    return _isdigit(c);
}

// Address range: 0x100003f18 - 0x100003f24
int64_t * function_100003f18(int32_t size) {
    // 0x100003f18
    return _malloc(size);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(char * format, ...) {
    // 0x100003f24
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`// A doubly linked list of strings;
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct sListEntry {
    const char *value;
    struct sListEntry *next;
    struct sListEntry *prev;
} *ListEntry, *LinkedList;

typedef struct sListIterator{
    ListEntry  link;
    LinkedList head;
} *LIterator;

LinkedList NewList() {
    ListEntry le = malloc(sizeof(struct sListEntry));
    if (le) {
        le->value = NULL;
        le->next = le->prev = NULL;
    }
    return le;
}

int LL_Append(LinkedList ll, const char *newVal)
{
    ListEntry le = malloc(sizeof(struct sListEntry));
    if (le) {
        le->value = strdup(newVal);
        le->prev = ll->prev;
        le->next = NULL;
        if (le->prev)
            le->prev->next = le;
        else
            ll->next = le;
        ll->prev = le;
    }
    return (le!= NULL);
}

int LI_Insert(LIterator iter, const char *newVal)
{
    ListEntry crnt = iter->link;
    ListEntry le = malloc(sizeof(struct sListEntry));
    if (le) {
        le->value = strdup(newVal);
        if ( crnt == iter->head) {
            le->prev = NULL;
            le->next = crnt->next;
            crnt->next = le;
            if (le->next)
                le->next->prev = le;
            else
                crnt->prev = le;
        }
        else {
            le->prev = ( crnt == NULL)? iter->head->prev : crnt->prev;
            le->next = crnt;
            if (le->prev)
                le->prev->next = le;
            else
                iter->head->next = le;
            if (crnt)
                crnt->prev = le;
            else
                iter->head->prev = le;
        }
    }
    return (le!= NULL);
}

LIterator LL_GetIterator(LinkedList ll )
{
    LIterator liter = malloc(sizeof(struct sListIterator));
    liter->head = ll;
    liter->link = ll;
    return liter;
}

#define LLI_Delete( iter ) \
    {free(iter); \
    iter = NULL;}

int LLI_AtEnd(LIterator iter)
{
    return iter->link == NULL;
}
const char *LLI_Value(LIterator iter)
{
    return (iter->link)? iter->link->value: NULL;
}
int LLI_Next(LIterator iter)
{
    if (iter->link) iter->link = iter->link->next;
    return(iter->link != NULL);
}
int LLI_Prev(LIterator iter)
{
    if (iter->link) iter->link = iter->link->prev;
    return(iter->link != NULL);
}

int main()
{
    static const char *contents[] = {"Read", "Orage", "Yeller",
                                     "Glean", "Blew", "Burple"};
    int ix;
    LinkedList ll = NewList();    //new linked list
    LIterator iter;

    for (ix=0; ix<6; ix++)        //insert contents
        LL_Append(ll, contents[ix]);

    iter = LL_GetIterator(ll);    //get an iterator
    printf("forward\n");
    while(LLI_Next(iter))         //iterate forward
        printf("value=%s\n", LLI_Value(iter));
    LLI_Delete(iter);             //delete iterator

    printf("\nreverse\n");
    iter = LL_GetIterator(ll);
    while(LLI_Prev(iter))         //iterate reverse
        printf("value=%s\n", LLI_Value(iter));
    LLI_Delete(iter);
                        //uhhh-- delete list??
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039c8(void);
int64_t function_100003a20(void);
int64_t function_100003ae4(void);
int64_t function_100003ca0(int64_t a1);
int64_t function_100003ce4(void);
int64_t function_100003d08(void);
int64_t function_100003d54(void);
int64_t function_100003da8(void);
void function_100003f2c(int64_t * ptr);
int64_t * function_100003f38(int32_t size);
int32_t function_100003f44(char * format, ...);
char * function_100003f50(char * s);

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000039c8 - 0x100003a20
int64_t function_1000039c8(void) {
    int64_t * v1 = _malloc(24); // 0x1000039d8
    int64_t result = (int64_t)v1; // 0x1000039d8
    if (v1 != NULL) {
        // 0x1000039f4
        *v1 = 0;
        *(int64_t *)(result + 16) = 0;
        *(int64_t *)(result + 8) = 0;
    }
    // 0x100003a10
    return result;
}

// Address range: 0x100003a20 - 0x100003ae4
int64_t function_100003a20(void) {
    int64_t * v1 = _malloc(24); // 0x100003a38
    if (v1 == NULL) {
        // 0x100003ac8
        return v1 != NULL;
    }
    int64_t v2 = (int64_t)v1; // 0x100003a38
    int64_t v3; // 0x100003a20
    *v1 = (int64_t)_strdup((char *)v3);
    int64_t * v4 = (int64_t *)(v3 + 16); // 0x100003a68
    int64_t * v5 = (int64_t *)(v2 + 16); // 0x100003a70
    *v5 = *v4;
    *(int64_t *)(v2 + 8) = 0;
    int64_t v6 = *v5; // 0x100003a80
    if (v6 == 0) {
        // 0x100003aa8
        *(int64_t *)(v3 + 8) = v2;
    } else {
        // 0x100003a94
        *(int64_t *)(v6 + 8) = v2;
    }
    // 0x100003ab8
    *v4 = v2;
    // 0x100003ac8
    return v1 != NULL;
}

// Address range: 0x100003ae4 - 0x100003ca0
int64_t function_100003ae4(void) {
    // 0x100003ae4
    int64_t v1; // 0x100003ae4
    int64_t v2 = v1;
    int64_t * v3 = _malloc(24); // 0x100003b08
    if (v3 == NULL) {
        // 0x100003c84
        return v3 != NULL;
    }
    int64_t v4 = (int64_t)v3; // 0x100003b08
    *v3 = (int64_t)_strdup((char *)v1);
    int64_t * v5 = (int64_t *)(v2 + 8); // 0x100003b3c
    int64_t v6 = *v5; // 0x100003b3c
    if (v2 == v6) {
        // 0x100003b50
        *(int64_t *)(v4 + 16) = 0;
        int64_t * v7 = (int64_t *)(v4 + 8); // 0x100003b64
        *v7 = *v5;
        *v5 = v4;
        int64_t v8 = *v7; // 0x100003b78
        if (v8 == 0) {
            // 0x100003ba0
            *(int64_t *)(v2 + 16) = v4;
        } else {
            // 0x100003b8c
            *(int64_t *)(v8 + 16) = v4;
        }
        // 0x100003c84
        return v3 != NULL;
    }
    int64_t * v9 = (int64_t *)(v4 + 16); // 0x100003bf4
    *v9 = *(int64_t *)((v2 == 0 ? v6 : v2) + 16);
    int64_t v10 = *v9; // 0x100003c08
    if (v10 == 0) {
        // 0x100003c30
        *(int64_t *)(*v5 + 8) = v4;
    } else {
        // 0x100003c1c
        *(int64_t *)(v10 + 8) = v4;
    }
    if (v2 == 0) {
        // 0x100003c68
        *(int64_t *)(*v5 + 16) = v4;
    } else {
        // 0x100003c58
        *(int64_t *)(v2 + 16) = v4;
    }
    // 0x100003c84
    return v3 != NULL;
}

// Address range: 0x100003ca0 - 0x100003ce4
int64_t function_100003ca0(int64_t a1) {
    int64_t * v1 = _malloc(16); // 0x100003cb4
    int64_t result = (int64_t)v1; // 0x100003cb4
    *(int64_t *)(result + 8) = a1;
    *v1 = a1;
    return result;
}

// Address range: 0x100003ce4 - 0x100003d08
int64_t function_100003ce4(void) {
    // 0x100003ce4
    int64_t v1; // 0x100003ce4
    return v1 == 0;
}

// Address range: 0x100003d08 - 0x100003d54
int64_t function_100003d08(void) {
    // 0x100003d08
    int64_t result; // 0x100003d08
    return result;
}

// Address range: 0x100003d54 - 0x100003da8
int64_t function_100003d54(void) {
    // 0x100003d54
    int64_t v1; // 0x100003d54
    int64_t v2 = v1;
    if (v2 != 0) {
        // 0x100003d74
        *(int64_t *)v2 = *(int64_t *)(v2 + 8);
    }
    // 0x100003d8c
    return v2 != 0;
}

// Address range: 0x100003da8 - 0x100003dfc
int64_t function_100003da8(void) {
    // 0x100003da8
    int64_t v1; // 0x100003da8
    int64_t v2 = v1;
    if (v2 != 0) {
        // 0x100003dc8
        *(int64_t *)v2 = *(int64_t *)(v2 + 16);
    }
    // 0x100003de0
    return v2 != 0;
}

// Address range: 0x100003dfc - 0x100003f2c
int64_t entry_point(void) {
    int64_t v1 = function_1000039c8(); // 0x100003e0c
    int64_t v2; // 0x100003e40
    for (int64_t i = 0; i < 6; i++) {
        // 0x100003e30
        v2 = *(int64_t *)(8 * i + (int64_t)"\\?");
        function_100003a20();
    }
    int64_t v3 = function_100003ca0(v1); // 0x100003e60
    _printf("forward\n");
    if ((int32_t)function_100003d54() != 0) {
        function_100003d08();
        _printf("value=%s\n", (char *)v2);
        // 0x100003e90
        while ((int32_t)function_100003d54() != 0) {
            // 0x100003e90
            function_100003d08();
            _printf("value=%s\n", (char *)v2);
        }
    }
    // 0x100003eb0
    _free((int64_t *)v3);
    _printf("\nreverse\n");
    int64_t v4 = function_100003ca0(v1); // 0x100003ecc
    if ((int32_t)function_100003da8() == 0) {
        // 0x100003f10
        _free((int64_t *)v4);
        return 0;
    }
    function_100003d08();
    _printf("value=%s\n", (char *)v2);
    // 0x100003ef0
    while ((int32_t)function_100003da8() != 0) {
        // 0x100003ef0
        function_100003d08();
        _printf("value=%s\n", (char *)v2);
    }
    // 0x100003f10
    _free((int64_t *)v4);
    return 0;
}

// Address range: 0x100003f2c - 0x100003f38
void function_100003f2c(int64_t * ptr) {
    // 0x100003f2c
    _free(ptr);
}

// Address range: 0x100003f38 - 0x100003f44
int64_t * function_100003f38(int32_t size) {
    // 0x100003f38
    return _malloc(size);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(char * format, ...) {
    // 0x100003f44
    return _printf(format);
}

// Address range: 0x100003f50 - 0x100003f5c
char * function_100003f50(char * s) {
    // 0x100003f50
    return _strdup(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`//FormAI DATASET v1.0 Category: Scientific ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#define ARRAY_SIZE 1000

int main(){

   // Initialize random seed
   srand((unsigned) time(NULL));

   // Generate a random dataset of 1000 values between 0 and 99
   int dataset[ARRAY_SIZE];
   for(int i = 0; i < ARRAY_SIZE; i++){
      dataset[i] = rand() % 100;
   }

   // Calculate the mean of the dataset
   float sum = 0;
   float mean = 0;
   for(int i = 0; i < ARRAY_SIZE; i++){
      sum += dataset[i];
   }
   mean = sum / ARRAY_SIZE;
   printf("Mean: %f\n", mean);

   // Calculate the standard deviation of the dataset
   float variance = 0;
   float deviation = 0;
   for(int i = 0; i < ARRAY_SIZE; i++){
      variance += pow(dataset[i] - mean, 2);
   }
   variance /= ARRAY_SIZE;
   deviation = sqrt(variance);
   printf("Standard Deviation: %f\n", deviation);

   // Calculate the median of the dataset
   int temp = 0;
   for(int i = 0; i < ARRAY_SIZE-1; i++){
      for(int j = 0; j < ARRAY_SIZE-i-1; j++){
         if(dataset[j] > dataset[j+1]){
            temp = dataset[j];
            dataset[j] = dataset[j+1];
            dataset[j+1] = temp;
         }
      }
   }
   float median = 0;
   if(ARRAY_SIZE % 2 == 0){
      median = (dataset[ARRAY_SIZE/2] + dataset[ARRAY_SIZE/2-1]) / 2.0;
   } else{
      median = dataset[ARRAY_SIZE/2];
   }
   printf("Median: %f\n", median);

   // Calculate the mode of the dataset
   int mode = 0;
   int count = 0;
   int max_count = 0;
   for(int i = 0; i < ARRAY_SIZE; i++){
      count = 0;
      for(int j = i; j < ARRAY_SIZE; j++){
         if(dataset[j] == dataset[i]){
            count++;
         }
      }
      if(count > max_count){
         mode = dataset[i];
         max_count = count;
      }
   }
   printf("Mode: %d\n", mode);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl pow(double X, double Y);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  double v4; // xmm0_8
  float v5; // xmm0_4
  int v6; // xmm0_4
  int v8[1001]; // [rsp+20h] [rbp-60h]
  int v9; // [rsp+FC4h] [rbp+F44h]
  float v10; // [rsp+FC8h] [rbp+F48h]
  float v11; // [rsp+FCCh] [rbp+F4Ch]
  int jj; // [rsp+FD0h] [rbp+F50h]
  int ii; // [rsp+FD4h] [rbp+F54h]
  int v14; // [rsp+FD8h] [rbp+F58h]
  int v15; // [rsp+FDCh] [rbp+F5Ch]
  unsigned int v16; // [rsp+FE0h] [rbp+F60h]
  int n; // [rsp+FE4h] [rbp+F64h]
  int m; // [rsp+FE8h] [rbp+F68h]
  int k; // [rsp+FECh] [rbp+F6Ch]
  float v20; // [rsp+FF0h] [rbp+F70h]
  int j; // [rsp+FF4h] [rbp+F74h]
  float v22; // [rsp+FF8h] [rbp+F78h]
  int i; // [rsp+FFCh] [rbp+F7Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 999; ++i )
    v8[i] = rand() % 100;
  v22 = 0.0;
  v11 = 0.0;
  for ( j = 0; j <= 999; ++j )
    v22 = (float)v8[j] + v22;
  v11 = v22 / 1000.0;
  printf("Mean: %f\n", (float)(v22 / 1000.0));
  v20 = 0.0;
  v10 = 0.0;
  for ( k = 0; k <= 999; ++k )
  {
    v4 = pow((float)((float)v8[k] - v11), 2.0);
    *(float *)&v4 = v4 + v20;
    v20 = *(float *)&v4;
  }
  v20 = v20 / 1000.0;
  v5 = sqrt(v20);
  v10 = v5;
  printf("Standard Deviation: %f\n", v5);
  v9 = 0;
  for ( m = 0; m <= 998; ++m )
  {
    for ( n = 0; n < 999 - m; ++n )
    {
      if ( v8[n] > v8[n + 1] )
      {
        v9 = v8[n];
        v8[n] = v8[n + 1];
        v8[n + 1] = v9;
      }
    }
  }
  *(float *)&v6 = (double)(v8[500] + v8[499]) / 2.0;
  v8[1000] = v6;
  printf("Median: %f\n", *(float *)&v6);
  v16 = 0;
  v15 = 0;
  v14 = 0;
  for ( ii = 0; ii <= 999; ++ii )
  {
    v15 = 0;
    for ( jj = ii; jj <= 999; ++jj )
    {
      if ( v8[jj] == v8[ii] )
        ++v15;
    }
    if ( v15 > v14 )
    {
      v16 = v8[ii];
      v14 = v15;
    }
  }
  printf("Mode: %d\n", v16);
  return 0;
}
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include<string.h>
#include<stdlib.h>
#include<stdio.h>

#define COLLAPSE 0
#define SQUEEZE 1

typedef struct charList{
    char c;
    struct charList *next;
} charList;

/*
Implementing strcmpi, the case insensitive string comparator, as it is not part of the C Standard Library.

Comment this out if testing on a compiler where it is already defined.
*/

int strcmpi(char str1[100],char str2[100]){
    int len1 = strlen(str1), len2 = strlen(str2), i;

    if(len1!=len2){
        return 1;
    }

    else{
        for(i=0;i<len1;i++){
            if((str1[i]>='A'&&str1[i]<='Z')&&(str2[i]>='a'&&str2[i]<='z')&&(str2[i]-65!=str1[i]))
                return 1;
            else if((str2[i]>='A'&&str2[i]<='Z')&&(str1[i]>='a'&&str1[i]<='z')&&(str1[i]-65!=str2[i]))
                return 1;
            else if(str1[i]!=str2[i])
                return 1;
        }
    }

    return 0;
}

charList *strToCharList(char* str){
    int len = strlen(str),i;

    charList *list, *iterator, *nextChar;

    list = (charList*)malloc(sizeof(charList));
    list->c = str[0];
    list->next = NULL;

    iterator = list;

    for(i=1;i<len;i++){
        nextChar = (charList*)malloc(sizeof(charList));
        nextChar->c = str[i];
        nextChar->next = NULL;

        iterator->next = nextChar;
        iterator = nextChar;
    }

    return list;
}

char* charListToString(charList* list){
    charList* iterator = list;
    int count = 0,i;
    char* str;

    while(iterator!=NULL){
        count++;
        iterator = iterator->next;
    }

    str = (char*)malloc((count+1)*sizeof(char));
    iterator = list;

    for(i=0;i<count;i++){
        str[i] = iterator->c;
        iterator = iterator->next;
    }

    free(list);
    str[i] = '\0';

    return str;
}

char* processString(char str[100],int operation, char squeezeChar){
    charList *strList = strToCharList(str),*iterator = strList, *scout;

    if(operation==SQUEEZE){
        while(iterator!=NULL){
            if(iterator->c==squeezeChar){
                scout = iterator->next;

                while(scout!=NULL && scout->c==squeezeChar){
                        iterator->next = scout->next;
                        scout->next = NULL;
                        free(scout);
                        scout = iterator->next;
                }
            }
            iterator = iterator->next;
        }
    }

    else{
        while(iterator!=NULL && iterator->next!=NULL){
            if(iterator->c == (iterator->next)->c){
                scout = iterator->next;
                squeezeChar = iterator->c;

                while(scout!=NULL && scout->c==squeezeChar){
                        iterator->next = scout->next;
                        scout->next = NULL;
                        free(scout);
                        scout = iterator->next;
                }
            }
            iterator = iterator->next;
        }
    }

    return charListToString(strList);
}

void printResults(char originalString[100], char finalString[100], int operation, char squeezeChar){
    if(operation==SQUEEZE){
        printf("Specified Operation : SQUEEZE\nTarget Character : %c",squeezeChar);
    }

    else
        printf("Specified Operation : COLLAPSE");

    printf("\nOriginal %c%c%c%s%c%c%c\nLength : %d",174,174,174,originalString,175,175,175,(int)strlen(originalString));
    printf("\nFinal    %c%c%c%s%c%c%c\nLength : %d\n",174,174,174,finalString,175,175,175,(int)strlen(finalString));
}

int main(int argc, char** argv){
    int operation;
    char squeezeChar;

    if(argc<3||argc>4){
        printf("Usage : %s <SQUEEZE|COLLAPSE> <String to be processed> <Character to be squeezed, if operation is SQUEEZE>\n",argv[0]);
        return 0;
    }

    if(strcmpi(argv[1],"SQUEEZE")==0 && argc!=4){
        scanf("Please enter characted to be squeezed : %c",&squeezeChar);
        operation = SQUEEZE;
    }

    else if(argc==4){
        operation = SQUEEZE;
        squeezeChar = argv[3][0];
    }

    else if(strcmpi(argv[1],"COLLAPSE")==0){
        operation = COLLAPSE;
    }

    if(strlen(argv[2])<2){
        printResults(argv[2],argv[2],operation,squeezeChar);
    }

    else{
        printResults(argv[2],processString(argv[2],operation,squeezeChar),operation,squeezeChar);
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003538(void);
int64_t function_10000376c(void);
int64_t function_100003840(void);
int64_t function_100003934(void);
int64_t function_100003b68(void);
void function_100003e24(int64_t * ptr);
int64_t * function_100003e30(int32_t size);
int32_t function_100003e3c(char * format, ...);
int32_t function_100003e48(char * format, ...);
int32_t function_100003e54(char * s);

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);
int32_t _strlen(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003538 - 0x10000376c
int64_t function_100003538(void) {
    // 0x100003538
    int64_t v1; // 0x100003538
    int32_t v2 = _strlen((char *)v1); // 0x100003550
    if (v2 != _strlen((char *)v1)) {
        // 0x10000375c
        return 1;
    }
    int32_t v3 = -v2; // 0x1000035a0
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x10000375c
        return 0;
    }
    int32_t v4 = 0; // 0x1000035a8
    int64_t v5 = v4; // 0x1000035b4
    char v6 = *(char *)(v1 + v5); // 0x1000035b8
    int32_t v7 = v6;
    int32_t v8; // 0x1000035d8
    char v9; // 0x1000035f0
    int32_t v10; // 0x1000035f0
    int32_t v11; // 0x100003610
    if (v6 < 65 == (64 - v7 & v7) < 0) {
        // 0x1000035cc
        v8 = v7 - 90;
        if (v8 == 0 || v8 < 0 != (89 - v7 & v7) < 0) {
            // 0x1000035e8
            v9 = *(char *)(v1 + v5);
            v10 = v9;
            if (v9 < 97 == (96 - v10 & v10) < 0) {
                // 0x100003604
                v11 = v10 - 122;
                if (v10 - 65 != v7 && v11 != 0 != (v11 < 0 == (121 - v10 & v10) < 0)) {
                    // break -> 0x10000375c
                    break;
                }
            }
        }
    }
    char v12 = *(char *)(v1 + v5); // 0x100003660
    int32_t v13 = v12; // 0x100003660
    int32_t v14; // 0x100003680
    int32_t v15; // 0x1000036b8
    if (v12 < 65 == (64 - v13 & v13) < 0) {
        // 0x100003674
        v14 = v13 - 90;
        if (v14 == 0 || v14 < 0 != (89 - v13 & v13) < 0) {
            if (v6 < 97 == (96 - v7 & v7) < 0) {
                // 0x1000036ac
                v15 = v7 - 122;
                if (v15 != 0 != (v15 < 0 == (121 - v7 & v7) < 0) && v7 - 65 != v13) {
                    // break -> 0x10000375c
                    break;
                }
            }
        }
    }
    int64_t result = 1; // 0x100003720
    while (v6 == v12) {
        // 0x100003598
        v4++;
        int32_t v16 = v4 - v2; // 0x1000035a0
        result = 0;
        if (v16 < 0 == ((v16 ^ v4) & (v4 ^ v2)) < 0) {
            // break -> 0x10000375c
            break;
        }
        v5 = v4;
        v6 = *(char *)(v1 + v5);
        v7 = v6;
        if (v6 < 65 == (64 - v7 & v7) < 0) {
            // 0x1000035cc
            v8 = v7 - 90;
            if (v8 == 0 || v8 < 0 != (89 - v7 & v7) < 0) {
                // 0x1000035e8
                v9 = *(char *)(v1 + v5);
                v10 = v9;
                if (v9 < 97 == (96 - v10 & v10) < 0) {
                    // 0x100003604
                    v11 = v10 - 122;
                    result = 1;
                    if (v10 - 65 != v7 && v11 != 0 != (v11 < 0 == (121 - v10 & v10) < 0)) {
                        // break -> 0x10000375c
                        break;
                    }
                }
            }
        }
        // 0x100003658
        v12 = *(char *)(v1 + v5);
        v13 = v12;
        if (v12 < 65 == (64 - v13 & v13) < 0) {
            // 0x100003674
            v14 = v13 - 90;
            if (v14 == 0 || v14 < 0 != (89 - v13 & v13) < 0) {
                if (v6 < 97 == (96 - v7 & v7) < 0) {
                    // 0x1000036ac
                    v15 = v7 - 122;
                    result = 1;
                    if (v15 != 0 != (v15 < 0 == (121 - v7 & v7) < 0) && v7 - 65 != v13) {
                        // break -> 0x10000375c
                        break;
                    }
                }
            }
        }
        // 0x100003700
        result = 1;
    }
    // 0x10000375c
    return result;
}

// Address range: 0x10000376c - 0x100003840
int64_t function_10000376c(void) {
    // 0x10000376c
    int64_t v1; // 0x10000376c
    int32_t v2 = _strlen((char *)v1); // 0x100003780
    int64_t * v3 = _malloc(16); // 0x100003790
    int64_t result = (int64_t)v3; // 0x100003790
    *(char *)v3 = (char)v1;
    *(int64_t *)(result + 8) = 0;
    int32_t v4 = 1 - v2; // 0x1000037cc
    int32_t v5 = 1; // 0x1000037d4
    if (v4 < 0 == (v4 & v2) < 0) {
        // 0x100003830
        return result;
    }
    int64_t * v6 = _malloc(16); // 0x1000037e0
    int64_t v7 = (int64_t)v6; // 0x1000037e0
    *(char *)v6 = *(char *)(v1 + (int64_t)v5);
    *(int64_t *)(v7 + 8) = 0;
    *(int64_t *)(result + 8) = v7;
    v5++;
    while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
        int64_t v8 = v7;
        v6 = _malloc(16);
        v7 = (int64_t)v6;
        *(char *)v6 = *(char *)(v1 + (int64_t)v5);
        *(int64_t *)(v7 + 8) = 0;
        *(int64_t *)(v8 + 8) = v7;
        v5++;
    }
    // 0x100003830
    return result;
}

// Address range: 0x100003840 - 0x100003934
int64_t function_100003840(void) {
    int32_t v1 = 0; // 0x10000386c
    int32_t v2 = 1; // 0x10000386c
    int64_t v3; // 0x100003840
    if (v3 != 0) {
        int32_t v4 = 1;
        int64_t v5; // 0x100003840
        int64_t v6 = *(int64_t *)(v5 + 8); // 0x100003884
        int32_t v7 = v4 + 1;
        v5 = v6;
        v1 = v4;
        v2 = v7;
        while (v6 != 0) {
            // 0x100003874
            v4 = v7;
            v6 = *(int64_t *)(v5 + 8);
            v7 = v4 + 1;
            v5 = v6;
            v1 = v4;
            v2 = v7;
        }
    }
    int64_t result = (int64_t)_malloc(v2); // 0x1000038a4
    int32_t v8 = -v1; // 0x1000038c4
    int32_t v9 = 0; // 0x1000038cc
    if (v8 < 0 == (v1 & v8) < 0) {
        // 0x10000390c
        _free((int64_t *)v3);
        *(char *)result = 0;
        return result;
    }
    int64_t v10; // 0x100003840
    *(char *)((int64_t)v9 + result) = *(char *)v10;
    v9++;
    int32_t v11 = v9 - v1; // 0x1000038c4
    v10 += 8;
    while (v11 < 0 != ((v11 ^ v9) & (v9 ^ v1)) < 0) {
        // 0x1000038d4
        *(char *)((int64_t)v9 + result) = *(char *)v10;
        v9++;
        v11 = v9 - v1;
        v10 += 8;
    }
    // 0x10000390c
    _free((int64_t *)v3);
    *(char *)((int64_t)v9 + result) = 0;
    return result;
}

// Address range: 0x100003934 - 0x100003b68
int64_t function_100003934(void) {
    int64_t v1 = function_10000376c(); // 0x100003950
    char * v2 = (char *)v1; // 0x10000395c
    int64_t v3; // 0x100003934
    if ((int32_t)v3 == 1) {
        if (v1 == 0) {
            // 0x100003b54
            return function_100003840();
        }
        int32_t v4 = 0x1000000 * (int32_t)v3 >> 24; // 0x100003994
        int64_t * v5 = (int64_t *)((int64_t)v2 + 8);
        int64_t v6 = *v5;
        int64_t v7; // 0x100003934
        char * v8; // 0x100003934
        int64_t v9; // 0x100003934
        int64_t v10; // 0x100003934
        char * v11; // 0x100003934
        int64_t * v12; // 0x100003a00
        if (v4 == (int32_t)*v2) {
            // 0x1000039b8
            if (v6 == 0) {
                // break -> 0x100003b54
                break;
            }
            v10 = v6;
            v11 = (char *)v10;
            v8 = v11;
            v7 = v10;
            while (v4 == (int32_t)*v11) {
                // 0x1000039fc
                v12 = (int64_t *)(v10 + 8);
                *v5 = *v12;
                *v12 = 0;
                _free((int64_t *)v10);
                v9 = *v5;
                if (v9 == 0) {
                    return function_100003840();
                }
                v10 = v9;
                v11 = (char *)v10;
                v8 = v11;
                v7 = v10;
            }
        } else {
            // 0x10000398c
            v8 = (char *)v6;
            v7 = v6;
        }
        char * v13 = v8; // 0x100003984
        while (v7 != 0) {
            // 0x10000398c
            v5 = (int64_t *)((int64_t)v13 + 8);
            v6 = *v5;
            if (v4 == (int32_t)*v13) {
                // 0x1000039b8
                if (v6 == 0) {
                    // break -> 0x100003b54
                    break;
                }
                v10 = v6;
                v11 = (char *)v10;
                v8 = v11;
                v7 = v10;
                while (v4 == (int32_t)*v11) {
                    // 0x1000039fc
                    v12 = (int64_t *)(v10 + 8);
                    *v5 = *v12;
                    *v12 = 0;
                    _free((int64_t *)v10);
                    v9 = *v5;
                    if (v9 == 0) {
                        return function_100003840();
                    }
                    v10 = v9;
                    v11 = (char *)v10;
                    v8 = v11;
                    v7 = v10;
                }
            } else {
                // 0x10000398c
                v8 = (char *)v6;
                v7 = v6;
            }
            // 0x100003a30
            v13 = v8;
        }
      lab_0x100003b54:
        // 0x100003b54
        return function_100003840();
    }
    // 0x100003a48
    if (v1 == 0) {
        // 0x100003b54
        return function_100003840();
    }
    char * v14 = v2; // 0x100003a5c
    int64_t * v15 = (int64_t *)((int64_t)v14 + 8);
    int64_t v16 = *v15; // 0x100003a68
    while (v16 != 0) {
        char v17 = *v14; // 0x100003a8c
        char * v18 = (char *)v16;
        v14 = v18;
        int64_t v19 = v16; // 0x100003aa4
        if (v17 == *v18) {
            int64_t v20 = v16; // 0x100003adc
            int64_t v21 = 0; // 0x100003adc
            if (v16 != 0) {
                int64_t * v22 = (int64_t *)(v20 + 8); // 0x100003b10
                *v15 = *v22;
                *v22 = 0;
                _free((int64_t *)v20);
                int64_t v23 = *v15; // 0x100003b30
                v21 = 0;
                while (v23 != 0) {
                    // 0x100003b0c
                    v20 = v23;
                    v21 = v23;
                    if (v17 != *(char *)v23) {
                        // break -> 0x100003b40
                        break;
                    }
                    v22 = (int64_t *)(v20 + 8);
                    *v15 = *v22;
                    *v22 = 0;
                    _free((int64_t *)v20);
                    v23 = *v15;
                    v21 = 0;
                }
            }
            // 0x100003b40
            v19 = v21;
            v14 = (char *)v19;
        }
        // 0x100003b40
        if (v19 == 0) {
            // break -> 0x100003b54
            break;
        }
        v15 = (int64_t *)((int64_t)v14 + 8);
        v16 = *v15;
    }
    // 0x100003b54
    return function_100003840();
}

// Address range: 0x100003b68 - 0x100003c74
int64_t function_100003b68(void) {
    // 0x100003b68
    char v1; // 0x100003b68
    int64_t v2; // 0x100003b68
    if ((int32_t)v2 == 1) {
        char v3 = v2;
        _printf("Specified Operation : SQUEEZE\nTarget Character : %c", v3);
        v1 = v3;
    } else {
        // 0x100003bb8
        _printf("Specified Operation : COLLAPSE");
        v1 = v2;
    }
    // 0x100003bc8
    _strlen((char *)v2);
    char v4 = v2; // 0x100003c18
    char v5 = v2; // 0x100003c18
    char * v6 = (char *)v2; // 0x100003c18
    char v7 = v2; // 0x100003c18
    char v8 = v2; // 0x100003c18
    char v9 = v2; // 0x100003c18
    _printf("\nOriginal %c%c%c%s%c%c%c\nLength : %d", v1, v4, v5, v6, v7, v8, v9, 174);
    _strlen((char *)v2);
    return _printf("\nFinal    %c%c%c%s%c%c%c\nLength : %d\n", v1, v4, v5, v6, v7, v8, v9, 174);
}

// Address range: 0x100003c74 - 0x100003e24
int64_t entry_point(void) {
    // 0x100003c74
    int64_t v1; // 0x100003c74
    int32_t v2 = v1; // 0x100003c84
    if (v2 < 3 != (2 - v2 & v2) < 0) {
        // 0x100003cb4
        _printf("Usage : %s <SQUEEZE|COLLAPSE> <String to be processed> <Character to be squeezed, if operation is SQUEEZE>\n", (char *)v1);
        // 0x100003e14
        return 0;
    }
    int32_t v3 = v2 - 4; // 0x100003ca4
    if (v3 != 0 && v3 < 0 == (3 - v2 & v2) < 0) {
        // 0x100003cb4
        _printf("Usage : %s <SQUEEZE|COLLAPSE> <String to be processed> <Character to be squeezed, if operation is SQUEEZE>\n", (char *)v1);
        // 0x100003e14
        return 0;
    }
    // 0x100003cd8
    if (v2 == 4 | (int32_t)function_100003538() != 0) {
        if (v2 != 4) {
            // 0x100003d64
            function_100003538();
        }
    } else {
        // 0x100003d10
        _scanf("Please enter characted to be squeezed : %c", "SQUEEZE");
    }
    // 0x100003d98
    if (_strlen((char *)*(int64_t *)(v1 + 16)) < 2) {
        // 0x100003db4
        function_100003b68();
    } else {
        // 0x100003dd4
        function_100003934();
        function_100003b68();
    }
    // 0x100003e14
    return 0;
}

// Address range: 0x100003e24 - 0x100003e30
void function_100003e24(int64_t * ptr) {
    // 0x100003e24
    _free(ptr);
}

// Address range: 0x100003e30 - 0x100003e3c
int64_t * function_100003e30(int32_t size) {
    // 0x100003e30
    return _malloc(size);
}

// Address range: 0x100003e3c - 0x100003e48
int32_t function_100003e3c(char * format, ...) {
    // 0x100003e3c
    return _printf(format);
}

// Address range: 0x100003e48 - 0x100003e54
int32_t function_100003e48(char * format, ...) {
    // 0x100003e48
    return _scanf(format);
}

// Address range: 0x100003e54 - 0x100003e60
int32_t function_100003e54(char * s) {
    // 0x100003e54
    return _strlen(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define foreach(a, b, c) for (int a = b; a < c; a++)
#define for_i foreach(i, 0, n)
#define for_j foreach(j, 0, n)
#define for_k foreach(k, 0, n)
#define for_ij for_i for_j
#define for_ijk for_ij for_k
#define _dim int n
#define _swap(x, y) { typeof(x) tmp = x; x = y; y = tmp; }
#define _sum_k(a, b, c, s) { s = 0; foreach(k, a, b) s+= c; }

typedef double **mat;

#define _zero(a) mat_zero(a, n)
void mat_zero(mat x, int n) { for_ij x[i][j] = 0; }

#define _new(a) a = mat_new(n)
mat mat_new(_dim)
{
	mat x = malloc(sizeof(double*) * n);
	x[0]  = malloc(sizeof(double) * n * n);

	for_i x[i] = x[0] + n * i;
	_zero(x);

	return x;
}

#define _copy(a) mat_copy(a, n)
mat mat_copy(void *s, _dim)
{
	mat x = mat_new(n);
	for_ij x[i][j] = ((double (*)[n])s)[i][j];
	return x;
}

#define _del(x) mat_del(x)
void mat_del(mat x) { free(x[0]); free(x); }

#define _QUOT(x) #x
#define QUOTE(x) _QUOT(x)
#define _show(a) printf(QUOTE(a)" =");mat_show(a, 0, n)
void mat_show(mat x, char *fmt, _dim)
{
	if (!fmt) fmt = "%8.4g";
	for_i {
		printf(i ? "      " : " [ ");
		for_j {
			printf(fmt, x[i][j]);
			printf(j < n - 1 ? "  " : i == n - 1 ? " ]\n" : "\n");
		}
	}
}

#define _mul(a, b) mat_mul(a, b, n)
mat mat_mul(mat a, mat b, _dim)
{
	mat c = _new(c);
	for_ijk c[i][j] += a[i][k] * b[k][j];
	return c;
}

#define _pivot(a, b) mat_pivot(a, b, n)
void mat_pivot(mat a, mat p, _dim)
{
	for_ij { p[i][j] = (i == j); }
	for_i  {
		int max_j = i;
		foreach(j, i, n)
			if (fabs(a[j][i]) > fabs(a[max_j][i])) max_j = j;

		if (max_j != i)
			for_k { _swap(p[i][k], p[max_j][k]); }
	}
}

#define _LU(a, l, u, p) mat_LU(a, l, u, p, n)
void mat_LU(mat A, mat L, mat U, mat P, _dim)
{
	_zero(L); _zero(U);
	_pivot(A, P);

	mat Aprime = _mul(P, A);

	for_i  { L[i][i] = 1; }
	for_ij {
		double s;
		if (j <= i) {
			_sum_k(0, j, L[j][k] * U[k][i], s)
			U[j][i] = Aprime[j][i] - s;
		}
		if (j >= i) {
			_sum_k(0, i, L[j][k] * U[k][i], s);
			L[j][i] = (Aprime[j][i] - s) / U[i][i];
		}
	}

	_del(Aprime);
}

double A3[][3] = {{ 1, 3, 5 }, { 2, 4, 7 }, { 1, 1, 0 }};
double A4[][4] = {{11, 9, 24, 2}, {1, 5, 2, 6}, {3, 17, 18, 1}, {2, 5, 7, 1}};

int main()
{
	int n = 3;
	mat A, L, P, U;

	_new(L); _new(P); _new(U);
	A = _copy(A3);
	_LU(A, L, U, P);
	_show(A); _show(L); _show(U); _show(P);
	_del(A);  _del(L);  _del(U);  _del(P);

	printf("\n");

	n = 4;

	_new(L); _new(P); _new(U);
	A = _copy(A4);
	_LU(A, L, U, P);
	_show(A); _show(L); _show(U); _show(P);
	_del(A);  _del(L);  _del(U);  _del(P);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000033a0(void);
int64_t function_100003434(void);
int64_t function_1000034f0(void);
int64_t function_1000035bc(void);
int64_t function_1000035ec(void);
int64_t function_100003758(void);
int64_t function_100003878(void);
int64_t function_100003a8c(void);
void function_100003f48(int64_t * ptr);
int64_t * function_100003f54(int32_t size);
int32_t function_100003f60(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000033a0 - 0x100003434
int64_t function_1000033a0(void) {
    // 0x1000033a0
    int64_t result; // 0x1000033a0
    int32_t v1 = result; // 0x1000033a8
    int32_t v2 = -v1;
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x10000342c
        return result;
    }
    int32_t v3 = 0; // 0x1000033c4
    int32_t v4 = 0; // 0x10000340c
    int64_t v5 = *(int64_t *)(8 * (int64_t)v3 + result); // 0x1000033f4
    *(float64_t *)(8 * (int64_t)v4 + v5) = 0.0;
    v4++;
    while (v4 - v1 < 0 != ((v4 - v1 ^ v4) & (v4 ^ v1)) < 0) {
        // 0x1000033ec
        v5 = *(int64_t *)(8 * (int64_t)v3 + result);
        *(float64_t *)(8 * (int64_t)v4 + v5) = 0.0;
        v4++;
    }
    // 0x10000341c
    v3++;
    while (v3 - v1 < 0 != ((v3 - v1 ^ v3) & (v3 ^ v1)) < 0) {
        // 0x1000033ec
        v4 = 0;
        v5 = *(int64_t *)(8 * (int64_t)v3 + result);
        *(float64_t *)(8 * (int64_t)v4 + v5) = 0.0;
        v4++;
        while (v4 - v1 < 0 != ((v4 - v1 ^ v4) & (v4 ^ v1)) < 0) {
            // 0x1000033ec
            v5 = *(int64_t *)(8 * (int64_t)v3 + result);
            *(float64_t *)(8 * (int64_t)v4 + v5) = 0.0;
            v4++;
        }
        // 0x10000341c
        v3++;
    }
    // 0x10000342c
    return result;
}

// Address range: 0x100003434 - 0x1000034f0
int64_t function_100003434(void) {
    // 0x100003434
    int64_t v1; // 0x100003434
    int32_t v2 = v1; // 0x100003440
    int64_t * v3 = _malloc(8 * v2); // 0x100003454
    int64_t result = (int64_t)v3; // 0x100003454
    int64_t v4 = 0x100000000 * v1;
    int64_t v5 = (int64_t)_malloc((int32_t)((v4 >> 29) * (v4 >> 32))); // 0x100003470
    *v3 = v5;
    int32_t v6 = -v2; // 0x10000348c
    if (v6 < 0 == (v6 & v2) < 0) {
        // 0x1000034d4
        function_1000033a0();
        return result;
    }
    int32_t v7 = 0;
    *(int64_t *)(8 * (int64_t)v7 + result) = 8 * (int64_t)(v7 * v2) + v5;
    int32_t v8 = v7 + 1; // 0x1000034c8
    while (v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
        int64_t v9 = *v3; // 0x100003434
        v7 = v8;
        *(int64_t *)(8 * (int64_t)v7 + result) = 8 * (int64_t)(v7 * v2) + v9;
        v8 = v7 + 1;
    }
    // 0x1000034d4
    function_1000033a0();
    return result;
}

// Address range: 0x1000034f0 - 0x1000035bc
int64_t function_1000034f0(void) {
    // 0x1000034f0
    int64_t v1; // 0x1000034f0
    int32_t v2 = v1; // 0x100003500
    int64_t result = function_100003434(); // 0x100003508
    int32_t v3 = -v2;
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x1000035ac
        return result;
    }
    int32_t v4 = 0; // 0x1000035a0
    int64_t v5 = v4; // 0x10000355c
    int64_t v6 = (8 * v1 & 0x7fffffff8) * v5 + v1; // 0x100003564
    int32_t v7 = 0; // 0x10000358c
    int64_t v8 = 8 * (int64_t)v7; // 0x10000356c
    int64_t v9 = *(int64_t *)(8 * v5 + result); // 0x100003578
    *(int64_t *)(v9 + v8) = *(int64_t *)(v6 + v8);
    v7++;
    while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x100003550
        v8 = 8 * (int64_t)v7;
        v9 = *(int64_t *)(8 * v5 + result);
        *(int64_t *)(v9 + v8) = *(int64_t *)(v6 + v8);
        v7++;
    }
    // 0x10000359c
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x100003550
        v5 = v4;
        v6 = (8 * v1 & 0x7fffffff8) * v5 + v1;
        v7 = 0;
        v8 = 8 * (int64_t)v7;
        v9 = *(int64_t *)(8 * v5 + result);
        *(int64_t *)(v9 + v8) = *(int64_t *)(v6 + v8);
        v7++;
        while (v7 - v2 < 0 != ((v7 - v2 ^ v7) & (v7 ^ v2)) < 0) {
            // 0x100003550
            v8 = 8 * (int64_t)v7;
            v9 = *(int64_t *)(8 * v5 + result);
            *(int64_t *)(v9 + v8) = *(int64_t *)(v6 + v8);
            v7++;
        }
        // 0x10000359c
        v4++;
    }
    // 0x1000035ac
    return result;
}

// Address range: 0x1000035bc - 0x1000035ec
int64_t function_1000035bc(void) {
    // 0x1000035bc
    int64_t v1; // 0x1000035bc
    int64_t * v2 = (int64_t *)v1; // 0x1000035d4
    _free(v2);
    _free(v2);
    return &g1;
}

// Address range: 0x1000035ec - 0x100003758
int64_t function_1000035ec(void) {
    // 0x1000035ec
    int64_t v1; // 0x1000035ec
    int64_t v2 = v1;
    int32_t v3 = v1; // 0x100003600
    int32_t v4 = -v3;
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x10000374c
        int64_t result; // 0x1000035ec
        return result;
    }
    int32_t v5 = v3 - 1;
    int32_t v6 = 0; // 0x100003740
    _printf(v6 == 0 ? " [ " : "      ");
    char * v7 = v6 != v5 ? "\n" : " ]\n";
    int32_t v8 = 0;
    _printf(v2 == 0 ? "%8.4g" : (char *)v2);
    int32_t v9 = v8 - v5; // 0x1000036c4
    int32_t result2 = _printf(v9 < 0 == ((v9 ^ v8) & (v8 ^ v5)) < 0 ? v7 : "  "); // 0x100003720
    int32_t v10 = v8 + 1; // 0x10000372c
    while (v10 - v3 < 0 != ((v10 - v3 ^ v10) & (v10 ^ v3)) < 0) {
        // 0x100003694
        v8 = v10;
        _printf(v2 == 0 ? "%8.4g" : (char *)v2);
        v9 = v8 - v5;
        result2 = _printf(v9 < 0 == ((v9 ^ v8) & (v8 ^ v5)) < 0 ? v7 : "  ");
        v10 = v8 + 1;
    }
    // 0x10000373c
    v6++;
    while (v6 - v3 < 0 != ((v6 - v3 ^ v6) & (v6 ^ v3)) < 0) {
        // 0x100003694
        _printf(v6 == 0 ? " [ " : "      ");
        v7 = v6 != v5 ? "\n" : " ]\n";
        v8 = 0;
        _printf(v2 == 0 ? "%8.4g" : (char *)v2);
        v9 = v8 - v5;
        result2 = _printf(v9 < 0 == ((v9 ^ v8) & (v8 ^ v5)) < 0 ? v7 : "  ");
        v10 = v8 + 1;
        while (v10 - v3 < 0 != ((v10 - v3 ^ v10) & (v10 ^ v3)) < 0) {
            // 0x100003694
            v8 = v10;
            _printf(v2 == 0 ? "%8.4g" : (char *)v2);
            v9 = v8 - v5;
            result2 = _printf(v9 < 0 == ((v9 ^ v8) & (v8 ^ v5)) < 0 ? v7 : "  ");
            v10 = v8 + 1;
        }
        // 0x10000373c
        v6++;
    }
    // 0x10000374c
    return result2;
}

// Address range: 0x100003758 - 0x100003878
int64_t function_100003758(void) {
    // 0x100003758
    int64_t v1; // 0x100003758
    int32_t v2 = v1; // 0x10000376c
    int64_t result = function_100003434(); // 0x100003774
    int32_t v3 = -v2;
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003868
        return result;
    }
    int32_t v4 = 0; // 0x10000379c
    int64_t v5 = 8 * (int64_t)v4;
    int32_t v6 = 0; // 0x100003848
    int64_t v7 = 8 * (int64_t)v6; // 0x100003808
    int32_t v8 = 0; // 0x100003834
    int64_t v9 = 8 * (int64_t)v8; // 0x1000037f4
    float64_t v10 = *(float64_t *)(*(int64_t *)(v9 + v1) + v7); // 0x100003808
    float64_t * v11 = (float64_t *)(*(int64_t *)(v5 + result) + v7); // 0x100003820
    *v11 = *(float64_t *)(v9 + *(int64_t *)(v5 + v1)) * v10 + *v11;
    v8++;
    while (v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
        // 0x1000037e4
        v9 = 8 * (int64_t)v8;
        v10 = *(float64_t *)(*(int64_t *)(v9 + v1) + v7);
        v11 = (float64_t *)(*(int64_t *)(v5 + result) + v7);
        *v11 = *(float64_t *)(v9 + *(int64_t *)(v5 + v1)) * v10 + *v11;
        v8++;
    }
    // 0x100003844
    v6++;
    while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
        // 0x1000037e4
        v7 = 8 * (int64_t)v6;
        v8 = 0;
        v9 = 8 * (int64_t)v8;
        v10 = *(float64_t *)(*(int64_t *)(v9 + v1) + v7);
        v11 = (float64_t *)(*(int64_t *)(v5 + result) + v7);
        *v11 = *(float64_t *)(v9 + *(int64_t *)(v5 + v1)) * v10 + *v11;
        v8++;
        while (v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x1000037e4
            v9 = 8 * (int64_t)v8;
            v10 = *(float64_t *)(*(int64_t *)(v9 + v1) + v7);
            v11 = (float64_t *)(*(int64_t *)(v5 + result) + v7);
            *v11 = *(float64_t *)(v9 + *(int64_t *)(v5 + v1)) * v10 + *v11;
            v8++;
        }
        // 0x100003844
        v6++;
    }
    // 0x100003858
    v4++;
    while (v4 - v2 < 0 != ((v4 - v2 ^ v4) & (v4 ^ v2)) < 0) {
        // 0x1000037cc
        v5 = 8 * (int64_t)v4;
        v6 = 0;
        v7 = 8 * (int64_t)v6;
        v8 = 0;
        v9 = 8 * (int64_t)v8;
        v10 = *(float64_t *)(*(int64_t *)(v9 + v1) + v7);
        v11 = (float64_t *)(*(int64_t *)(v5 + result) + v7);
        *v11 = *(float64_t *)(v9 + *(int64_t *)(v5 + v1)) * v10 + *v11;
        v8++;
        while (v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
            // 0x1000037e4
            v9 = 8 * (int64_t)v8;
            v10 = *(float64_t *)(*(int64_t *)(v9 + v1) + v7);
            v11 = (float64_t *)(*(int64_t *)(v5 + result) + v7);
            *v11 = *(float64_t *)(v9 + *(int64_t *)(v5 + v1)) * v10 + *v11;
            v8++;
        }
        // 0x100003844
        v6++;
        while (v6 - v2 < 0 != ((v6 - v2 ^ v6) & (v6 ^ v2)) < 0) {
            // 0x1000037e4
            v7 = 8 * (int64_t)v6;
            v8 = 0;
            v9 = 8 * (int64_t)v8;
            v10 = *(float64_t *)(*(int64_t *)(v9 + v1) + v7);
            v11 = (float64_t *)(*(int64_t *)(v5 + result) + v7);
            *v11 = *(float64_t *)(v9 + *(int64_t *)(v5 + v1)) * v10 + *v11;
            v8++;
            while (v8 - v2 < 0 != ((v8 - v2 ^ v8) & (v8 ^ v2)) < 0) {
                // 0x1000037e4
                v9 = 8 * (int64_t)v8;
                v10 = *(float64_t *)(*(int64_t *)(v9 + v1) + v7);
                v11 = (float64_t *)(*(int64_t *)(v5 + result) + v7);
                *v11 = *(float64_t *)(v9 + *(int64_t *)(v5 + v1)) * v10 + *v11;
                v8++;
            }
            // 0x100003844
            v6++;
        }
        // 0x100003858
        v4++;
    }
    // 0x100003868
    return result;
}

// Address range: 0x100003878 - 0x100003a8c
int64_t function_100003878(void) {
    // 0x100003878
    int64_t result; // 0x100003878
    int32_t v1 = result; // 0x100003884
    int32_t v2 = -v1;
    if (v2 < 0 == (v2 & v1) < 0) {
        // 0x100003a84
        return result;
    }
    int32_t v3 = 0; // 0x1000038a0
    int32_t v4 = 0;
    int64_t v5 = *(int64_t *)(8 * (int64_t)v3 + result); // 0x1000038e8
    *(float64_t *)(8 * (int64_t)v4 + v5) = (float64_t)(v3 == v4);
    int32_t v6 = v4 + 1; // 0x1000038fc
    while (v6 - v1 < 0 != ((v6 - v1 ^ v6) & (v6 ^ v1)) < 0) {
        // 0x1000038c8
        v4 = v6;
        v5 = *(int64_t *)(8 * (int64_t)v3 + result);
        *(float64_t *)(8 * (int64_t)v4 + v5) = (float64_t)(v3 == v4);
        v6 = v4 + 1;
    }
    // 0x10000390c
    v3++;
    int32_t v7 = v3 - v1; // 0x100003898
    while (v7 < 0 != ((v7 ^ v3) & (v3 ^ v1)) < 0) {
        // 0x1000038c8
        v4 = 0;
        v5 = *(int64_t *)(8 * (int64_t)v3 + result);
        *(float64_t *)(8 * (int64_t)v4 + v5) = (float64_t)(v3 == v4);
        v6 = v4 + 1;
        while (v6 - v1 < 0 != ((v6 - v1 ^ v6) & (v6 ^ v1)) < 0) {
            // 0x1000038c8
            v4 = v6;
            v5 = *(int64_t *)(8 * (int64_t)v3 + result);
            *(float64_t *)(8 * (int64_t)v4 + v5) = (float64_t)(v3 == v4);
            v6 = v4 + 1;
        }
        // 0x10000390c
        v3++;
        v7 = v3 - v1;
    }
    int32_t v8 = 0;
    int32_t v9 = v8 - v1; // 0x100003958
    int32_t v10; // 0x100003878
    int32_t v11; // 0x100003878
    bool v12; // 0x100003878
    bool v13; // 0x100003878
    bool v14; // 0x100003878
    int64_t v15; // 0x100003978
    float64_t v16; // 0x10000397c
    int64_t v17; // 0x100003988
    float64_t v18; // 0x100003994
    int32_t v19; // 0x1000039bc
    int32_t v20; // 0x100003958
    int64_t * v21; // 0x100003a20
    int64_t v22; // 0x100003a10
    int64_t * v23; // 0x100003878
    int32_t v24; // 0x100003a60
    if (v9 < 0 != ((v9 ^ v8) & (v8 ^ v1)) < 0) {
        // 0x100003968
        v15 = 8 * (int64_t)v8;
        v19 = v8;
        v16 = fabs(*(float64_t *)(*(int64_t *)(8 * (int64_t)v19 + result) + v15));
        v17 = *(int64_t *)(8 * (int64_t)v8 + result);
        v18 = fabs(*(float64_t *)(v17 + v15));
        v12 = false;
        v14 = true;
        v13 = false;
        if (v16 != v18) {
            v12 = v16 > v18;
            v14 = false;
            v13 = v16 >= v18 == v16 <= v18;
        }
        // 0x1000039b8
        v10 = v14 | v12 != v13 ? v8 : v19;
        v19++;
        v20 = v19 - v1;
        v11 = v10;
        while (v20 < 0 != ((v20 ^ v19) & (v19 ^ v1)) < 0) {
            // 0x100003968
            v16 = fabs(*(float64_t *)(*(int64_t *)(8 * (int64_t)v19 + result) + v15));
            v17 = *(int64_t *)(8 * (int64_t)v11 + result);
            v18 = fabs(*(float64_t *)(v17 + v15));
            v12 = false;
            v14 = true;
            v13 = false;
            if (v16 != v18) {
                v12 = v16 > v18;
                v14 = false;
                v13 = v16 >= v18 == v16 <= v18;
            }
            // 0x1000039b8
            v10 = v14 | v12 != v13 ? v11 : v19;
            v19++;
            v20 = v19 - v1;
            v11 = v10;
        }
        if (v10 != v8) {
            // 0x100003a00
            v21 = (int64_t *)(8 * (int64_t)v10 + result);
            v24 = 0;
            v22 = 8 * (int64_t)v24;
            v23 = (int64_t *)(v22 + *(int64_t *)(v15 + result));
            *v23 = *(int64_t *)(*v21 + v22);
            *(int64_t *)(*v21 + v22) = *v23;
            v24++;
            while (v24 - v1 < 0 != ((v24 - v1 ^ v24) & (v24 ^ v1)) < 0) {
                // 0x100003a00
                v22 = 8 * (int64_t)v24;
                v23 = (int64_t *)(v22 + *(int64_t *)(v15 + result));
                *v23 = *(int64_t *)(*v21 + v22);
                *(int64_t *)(*v21 + v22) = *v23;
                v24++;
            }
        }
    }
    int32_t v25 = v8 + 1; // 0x100003a78
    int32_t v26 = v25 - v1; // 0x10000392c
    while (v26 < 0 != ((v26 ^ v25) & (v25 ^ v1)) < 0) {
        // 0x100003950
        v8 = v25;
        v9 = v8 - v1;
        if (v9 < 0 != ((v9 ^ v8) & (v8 ^ v1)) < 0) {
            // 0x100003968
            v15 = 8 * (int64_t)v8;
            v19 = v8;
            v16 = fabs(*(float64_t *)(*(int64_t *)(8 * (int64_t)v19 + result) + v15));
            v17 = *(int64_t *)(8 * (int64_t)v8 + result);
            v18 = fabs(*(float64_t *)(v17 + v15));
            v12 = false;
            v14 = true;
            v13 = false;
            if (v16 != v18) {
                v12 = v16 > v18;
                v14 = false;
                v13 = v16 >= v18 == v16 <= v18;
            }
            // 0x1000039b8
            v10 = v14 | v12 != v13 ? v8 : v19;
            v19++;
            v20 = v19 - v1;
            v11 = v10;
            while (v20 < 0 != ((v20 ^ v19) & (v19 ^ v1)) < 0) {
                // 0x100003968
                v16 = fabs(*(float64_t *)(*(int64_t *)(8 * (int64_t)v19 + result) + v15));
                v17 = *(int64_t *)(8 * (int64_t)v11 + result);
                v18 = fabs(*(float64_t *)(v17 + v15));
                v12 = false;
                v14 = true;
                v13 = false;
                if (v16 != v18) {
                    v12 = v16 > v18;
                    v14 = false;
                    v13 = v16 >= v18 == v16 <= v18;
                }
                // 0x1000039b8
                v10 = v14 | v12 != v13 ? v11 : v19;
                v19++;
                v20 = v19 - v1;
                v11 = v10;
            }
            if (v10 != v8) {
                // 0x100003a00
                v21 = (int64_t *)(8 * (int64_t)v10 + result);
                v24 = 0;
                v22 = 8 * (int64_t)v24;
                v23 = (int64_t *)(v22 + *(int64_t *)(v15 + result));
                *v23 = *(int64_t *)(*v21 + v22);
                *(int64_t *)(*v21 + v22) = *v23;
                v24++;
                while (v24 - v1 < 0 != ((v24 - v1 ^ v24) & (v24 ^ v1)) < 0) {
                    // 0x100003a00
                    v22 = 8 * (int64_t)v24;
                    v23 = (int64_t *)(v22 + *(int64_t *)(v15 + result));
                    *v23 = *(int64_t *)(*v21 + v22);
                    *(int64_t *)(*v21 + v22) = *v23;
                    v24++;
                }
            }
        }
        // 0x100003a74
        v25 = v8 + 1;
        v26 = v25 - v1;
    }
    // 0x100003a84
    return result;
}

// Address range: 0x100003a8c - 0x100003d40
int64_t function_100003a8c(void) {
    // 0x100003a8c
    int64_t v1; // 0x100003a8c
    int32_t v2 = v1; // 0x100003aa8
    function_1000033a0();
    function_1000033a0();
    function_100003878();
    int64_t v3 = function_100003758(); // 0x100003ae0
    int32_t v4 = -v2;
    if (v4 < 0 == (v4 & v2) < 0) {
        // 0x100003d2c
        return function_1000035bc();
    }
    int32_t v5 = 0; // 0x100003b00
    int64_t v6 = 8 * (int64_t)v5; // 0x100003b10
    *(float64_t *)(v6 + *(int64_t *)(v6 + v1)) = 1.0;
    v5++;
    int32_t v7 = v5 - v2; // 0x100003af8
    while (v7 < 0 != ((v7 ^ v5) & (v5 ^ v2)) < 0) {
        // 0x100003b08
        v6 = 8 * (int64_t)v5;
        *(float64_t *)(v6 + *(int64_t *)(v6 + v1)) = 1.0;
        v5++;
        v7 = v5 - v2;
    }
    int32_t v8 = 0;
    int64_t v9 = 8 * (int64_t)v8;
    int32_t v10 = -v8;
    int64_t * v11 = (int64_t *)(v9 + v1);
    int32_t v12 = 0;
    int32_t v13 = v12 - v8; // 0x100003b7c
    float64_t v14; // 0x100003a8c
    int32_t v15; // 0x100003ba4
    int64_t v16; // 0x100003a8c
    float64_t v17; // 0x100003c0c
    int64_t v18; // 0x100003c20
    int64_t v19; // 0x100003bc4
    float64_t v20; // 0x100003bd8
    float64_t v21; // 0x100003be0
    int32_t v22; // 0x100003bf0
    int32_t v23; // 0x100003ba4
    if (v13 == 0 || v13 < 0 != ((v13 ^ v12) & (v12 ^ v8)) < 0) {
        // 0x100003b9c
        v15 = -v12;
        v16 = 8 * (int64_t)v12;
        v14 = 0.0;
        if (v15 < 0 != (v12 & v15) < 0) {
            // 0x100003bb4
            v22 = 0;
            v21 = 0.0;
            v19 = 8 * (int64_t)v22;
            v20 = *(float64_t *)(*(int64_t *)(v19 + v1) + v9);
            v21 += *(float64_t *)(v19 + *(int64_t *)(v16 + v1)) * v20;
            v22++;
            v23 = v22 - v12;
            v14 = v21;
            while (v23 < 0 != ((v23 ^ v22) & (v22 ^ v12)) < 0) {
                // 0x100003bb4
                v19 = 8 * (int64_t)v22;
                v20 = *(float64_t *)(*(int64_t *)(v19 + v1) + v9);
                v21 += *(float64_t *)(v19 + *(int64_t *)(v16 + v1)) * v20;
                v22++;
                v23 = v22 - v12;
                v14 = v21;
            }
        }
        // 0x100003bfc
        v17 = *(float64_t *)(*(int64_t *)(v16 + v3) + v9);
        v18 = *(int64_t *)(v16 + v1);
        *(float64_t *)(v18 + v9) = v17 - v14;
    }
    int64_t v24; // 0x100003a8c
    float64_t v25; // 0x100003a8c
    float64_t v26; // 0x100003a8c
    int32_t v27; // 0x100003a8c
    int64_t v28; // 0x100003a8c
    float64_t v29; // 0x100003cc8
    float64_t v30; // 0x100003ce4
    int64_t v31; // 0x100003c80
    float64_t v32; // 0x100003c94
    float64_t v33; // 0x100003c9c
    int32_t v34; // 0x100003cac
    int32_t v35; // 0x100003c60
    if (v13 < 0 == ((v13 ^ v12) & (v12 ^ v8)) < 0) {
        // 0x100003c58
        v28 = 8 * (int64_t)v12;
        v24 = *(int64_t *)(v28 + v1);
        v27 = 0;
        v26 = 0.0;
        if (v10 < 0 != (v8 & v10) < 0) {
            v31 = 8 * (int64_t)v27;
            v32 = *(float64_t *)(*(int64_t *)(v31 + v1) + v9);
            v33 = *(float64_t *)(v31 + v24) * v32;
            v34 = v27 + 1;
            v35 = v34 - v8;
            v27 = v34;
            v25 = v33;
            v26 = v33;
            while (v35 < 0 != ((v35 ^ v34) & (v34 ^ v8)) < 0) {
                // 0x100003c70
                v31 = 8 * (int64_t)v27;
                v32 = *(float64_t *)(*(int64_t *)(v31 + v1) + v9);
                v33 = v25 + *(float64_t *)(v31 + v24) * v32;
                v34 = v27 + 1;
                v35 = v34 - v8;
                v27 = v34;
                v25 = v33;
                v26 = v33;
            }
        }
        // 0x100003cb8
        v29 = *(float64_t *)(*(int64_t *)(v28 + v3) + v9);
        v30 = *(float64_t *)(*v11 + v9);
        *(float64_t *)(v24 + v9) = (v29 - v26) / v30;
    }
    int32_t v36 = v12 + 1; // 0x100003d0c
    while (v36 - v2 < 0 != ((v36 - v2 ^ v36) & (v36 ^ v2)) < 0) {
        // 0x100003b74
        v12 = v36;
        v13 = v12 - v8;
        if (v13 == 0 || v13 < 0 != ((v13 ^ v12) & (v12 ^ v8)) < 0) {
            // 0x100003b9c
            v15 = -v12;
            v16 = 8 * (int64_t)v12;
            v14 = 0.0;
            if (v15 < 0 != (v12 & v15) < 0) {
                // 0x100003bb4
                v22 = 0;
                v21 = 0.0;
                v19 = 8 * (int64_t)v22;
                v20 = *(float64_t *)(*(int64_t *)(v19 + v1) + v9);
                v21 += *(float64_t *)(v19 + *(int64_t *)(v16 + v1)) * v20;
                v22++;
                v23 = v22 - v12;
                v14 = v21;
                while (v23 < 0 != ((v23 ^ v22) & (v22 ^ v12)) < 0) {
                    // 0x100003bb4
                    v19 = 8 * (int64_t)v22;
                    v20 = *(float64_t *)(*(int64_t *)(v19 + v1) + v9);
                    v21 += *(float64_t *)(v19 + *(int64_t *)(v16 + v1)) * v20;
                    v22++;
                    v23 = v22 - v12;
                    v14 = v21;
                }
            }
            // 0x100003bfc
            v17 = *(float64_t *)(*(int64_t *)(v16 + v3) + v9);
            v18 = *(int64_t *)(v16 + v1);
            *(float64_t *)(v18 + v9) = v17 - v14;
        }
        if (v13 < 0 == ((v13 ^ v12) & (v12 ^ v8)) < 0) {
            // 0x100003c58
            v28 = 8 * (int64_t)v12;
            v24 = *(int64_t *)(v28 + v1);
            v27 = 0;
            v26 = 0.0;
            if (v10 < 0 != (v8 & v10) < 0) {
                v31 = 8 * (int64_t)v27;
                v32 = *(float64_t *)(*(int64_t *)(v31 + v1) + v9);
                v33 = *(float64_t *)(v31 + v24) * v32;
                v34 = v27 + 1;
                v35 = v34 - v8;
                v27 = v34;
                v25 = v33;
                v26 = v33;
                while (v35 < 0 != ((v35 ^ v34) & (v34 ^ v8)) < 0) {
                    // 0x100003c70
                    v31 = 8 * (int64_t)v27;
                    v32 = *(float64_t *)(*(int64_t *)(v31 + v1) + v9);
                    v33 = v25 + *(float64_t *)(v31 + v24) * v32;
                    v34 = v27 + 1;
                    v35 = v34 - v8;
                    v27 = v34;
                    v25 = v33;
                    v26 = v33;
                }
            }
            // 0x100003cb8
            v29 = *(float64_t *)(*(int64_t *)(v28 + v3) + v9);
            v30 = *(float64_t *)(*v11 + v9);
            *(float64_t *)(v24 + v9) = (v29 - v26) / v30;
        }
        // 0x100003d08
        v36 = v12 + 1;
    }
    int32_t v37 = v8 + 1; // 0x100003d20
    int32_t v38 = v37 - v2; // 0x100003b44
    while (v38 < 0 != ((v38 ^ v37) & (v37 ^ v2)) < 0) {
        // 0x100003b74
        v8 = v37;
        v9 = 8 * (int64_t)v8;
        v10 = -v8;
        v11 = (int64_t *)(v9 + v1);
        v12 = 0;
        v13 = v12 - v8;
        if (v13 == 0 || v13 < 0 != ((v13 ^ v12) & (v12 ^ v8)) < 0) {
            // 0x100003b9c
            v15 = -v12;
            v16 = 8 * (int64_t)v12;
            v14 = 0.0;
            if (v15 < 0 != (v12 & v15) < 0) {
                // 0x100003bb4
                v22 = 0;
                v21 = 0.0;
                v19 = 8 * (int64_t)v22;
                v20 = *(float64_t *)(*(int64_t *)(v19 + v1) + v9);
                v21 += *(float64_t *)(v19 + *(int64_t *)(v16 + v1)) * v20;
                v22++;
                v23 = v22 - v12;
                v14 = v21;
                while (v23 < 0 != ((v23 ^ v22) & (v22 ^ v12)) < 0) {
                    // 0x100003bb4
                    v19 = 8 * (int64_t)v22;
                    v20 = *(float64_t *)(*(int64_t *)(v19 + v1) + v9);
                    v21 += *(float64_t *)(v19 + *(int64_t *)(v16 + v1)) * v20;
                    v22++;
                    v23 = v22 - v12;
                    v14 = v21;
                }
            }
            // 0x100003bfc
            v17 = *(float64_t *)(*(int64_t *)(v16 + v3) + v9);
            v18 = *(int64_t *)(v16 + v1);
            *(float64_t *)(v18 + v9) = v17 - v14;
        }
        if (v13 < 0 == ((v13 ^ v12) & (v12 ^ v8)) < 0) {
            // 0x100003c58
            v28 = 8 * (int64_t)v12;
            v24 = *(int64_t *)(v28 + v1);
            v27 = 0;
            v26 = 0.0;
            if (v10 < 0 != (v8 & v10) < 0) {
                v31 = 8 * (int64_t)v27;
                v32 = *(float64_t *)(*(int64_t *)(v31 + v1) + v9);
                v33 = *(float64_t *)(v31 + v24) * v32;
                v34 = v27 + 1;
                v35 = v34 - v8;
                v27 = v34;
                v25 = v33;
                v26 = v33;
                while (v35 < 0 != ((v35 ^ v34) & (v34 ^ v8)) < 0) {
                    // 0x100003c70
                    v31 = 8 * (int64_t)v27;
                    v32 = *(float64_t *)(*(int64_t *)(v31 + v1) + v9);
                    v33 = v25 + *(float64_t *)(v31 + v24) * v32;
                    v34 = v27 + 1;
                    v35 = v34 - v8;
                    v27 = v34;
                    v25 = v33;
                    v26 = v33;
                }
            }
            // 0x100003cb8
            v29 = *(float64_t *)(*(int64_t *)(v28 + v3) + v9);
            v30 = *(float64_t *)(*v11 + v9);
            *(float64_t *)(v24 + v9) = (v29 - v26) / v30;
        }
        // 0x100003d08
        v36 = v12 + 1;
        while (v36 - v2 < 0 != ((v36 - v2 ^ v36) & (v36 ^ v2)) < 0) {
            // 0x100003b74
            v12 = v36;
            v13 = v12 - v8;
            if (v13 == 0 || v13 < 0 != ((v13 ^ v12) & (v12 ^ v8)) < 0) {
                // 0x100003b9c
                v15 = -v12;
                v16 = 8 * (int64_t)v12;
                v14 = 0.0;
                if (v15 < 0 != (v12 & v15) < 0) {
                    // 0x100003bb4
                    v22 = 0;
                    v21 = 0.0;
                    v19 = 8 * (int64_t)v22;
                    v20 = *(float64_t *)(*(int64_t *)(v19 + v1) + v9);
                    v21 += *(float64_t *)(v19 + *(int64_t *)(v16 + v1)) * v20;
                    v22++;
                    v23 = v22 - v12;
                    v14 = v21;
                    while (v23 < 0 != ((v23 ^ v22) & (v22 ^ v12)) < 0) {
                        // 0x100003bb4
                        v19 = 8 * (int64_t)v22;
                        v20 = *(float64_t *)(*(int64_t *)(v19 + v1) + v9);
                        v21 += *(float64_t *)(v19 + *(int64_t *)(v16 + v1)) * v20;
                        v22++;
                        v23 = v22 - v12;
                        v14 = v21;
                    }
                }
                // 0x100003bfc
                v17 = *(float64_t *)(*(int64_t *)(v16 + v3) + v9);
                v18 = *(int64_t *)(v16 + v1);
                *(float64_t *)(v18 + v9) = v17 - v14;
            }
            if (v13 < 0 == ((v13 ^ v12) & (v12 ^ v8)) < 0) {
                // 0x100003c58
                v28 = 8 * (int64_t)v12;
                v24 = *(int64_t *)(v28 + v1);
                v27 = 0;
                v26 = 0.0;
                if (v10 < 0 != (v8 & v10) < 0) {
                    v31 = 8 * (int64_t)v27;
                    v32 = *(float64_t *)(*(int64_t *)(v31 + v1) + v9);
                    v33 = *(float64_t *)(v31 + v24) * v32;
                    v34 = v27 + 1;
                    v35 = v34 - v8;
                    v27 = v34;
                    v25 = v33;
                    v26 = v33;
                    while (v35 < 0 != ((v35 ^ v34) & (v34 ^ v8)) < 0) {
                        // 0x100003c70
                        v31 = 8 * (int64_t)v27;
                        v32 = *(float64_t *)(*(int64_t *)(v31 + v1) + v9);
                        v33 = v25 + *(float64_t *)(v31 + v24) * v32;
                        v34 = v27 + 1;
                        v35 = v34 - v8;
                        v27 = v34;
                        v25 = v33;
                        v26 = v33;
                    }
                }
                // 0x100003cb8
                v29 = *(float64_t *)(*(int64_t *)(v28 + v3) + v9);
                v30 = *(float64_t *)(*v11 + v9);
                *(float64_t *)(v24 + v9) = (v29 - v26) / v30;
            }
            // 0x100003d08
            v36 = v12 + 1;
        }
        // 0x100003d1c
        v37 = v8 + 1;
        v38 = v37 - v2;
    }
    // 0x100003d2c
    return function_1000035bc();
}

// Address range: 0x100003d40 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003d40
    function_100003434();
    function_100003434();
    function_100003434();
    function_1000034f0();
    function_100003a8c();
    _printf("A =");
    function_1000035ec();
    _printf("L =");
    function_1000035ec();
    _printf("U =");
    function_1000035ec();
    _printf("P =");
    function_1000035ec();
    function_1000035bc();
    function_1000035bc();
    function_1000035bc();
    function_1000035bc();
    _printf("\n");
    function_100003434();
    function_100003434();
    function_100003434();
    function_1000034f0();
    function_100003a8c();
    _printf("A =");
    function_1000035ec();
    _printf("L =");
    function_1000035ec();
    _printf("U =");
    function_1000035ec();
    _printf("P =");
    function_1000035ec();
    function_1000035bc();
    function_1000035bc();
    function_1000035bc();
    function_1000035bc();
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
void function_100003f48(int64_t * ptr) {
    // 0x100003f48
    _free(ptr);
}

// Address range: 0x100003f54 - 0x100003f60
int64_t * function_100003f54(int32_t size) {
    // 0x100003f54
    return _malloc(size);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char * format, ...) {
    // 0x100003f60
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: automated
#include <stdio.h>

#define MAX_N 100

// Greedy algorithm to find the minimum number of coins needed to make change for a given amount
int find_minimum_coins(int coins[], int n, int amount)
{
    int count = 0;

    for (int i = 0; i < n; i++)
    {
        while (amount >= coins[i])
        {
            amount -= coins[i];
            count++;
        }
    }

    return count;
}

int main(void)
{
    int coins[] = {1, 5, 10, 25};
    int n = 4;
    int amount;

    printf("Enter an amount in cents: ");
    scanf("%d", &amount);

    printf("Minimum number of coins needed to make change: %d\n", find_minimum_coins(coins, n, amount));

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall find_minimum_coins(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001652) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int minimum_coins; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-24h] BYREF
  int v6[7]; // [rsp+30h] [rbp-20h] BYREF
  unsigned int v7; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6[0] = 1;
  v6[1] = 5;
  v6[2] = 10;
  v6[3] = 25;
  v7 = 4;
  printf("Enter an amount in cents: ");
  scanf("%d", &v5);
  minimum_coins = find_minimum_coins(v6, v7, v5);
  printf("Minimum number of coins needed to make change: %d\n", minimum_coins);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall find_minimum_coins(_QWORD, _QWORD, _QWORD);
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

static int nextInt(int size) {
    return rand() % size;
}

static bool cylinder[6];

static void rshift() {
    bool t = cylinder[5];
    int i;
    for (i = 4; i >= 0; i--) {
        cylinder[i + 1] = cylinder[i];
    }
    cylinder[0] = t;
}

static void unload() {
    int i;
    for (i = 0; i < 6; i++) {
        cylinder[i] = false;
    }
}

static void load() {
    while (cylinder[0]) {
        rshift();
    }
    cylinder[0] = true;
    rshift();
}

static void spin() {
    int lim = nextInt(6) + 1;
    int i;
    for (i = 1; i < lim; i++) {
        rshift();
    }
}

static bool fire() {
    bool shot = cylinder[0];
    rshift();
    return shot;
}

static int method(const char *s) {
    unload();
    for (; *s != '\0'; s++) {
        switch (*s) {
        case 'L':
            load();
            break;
        case 'S':
            spin();
            break;
        case 'F':
            if (fire()) {
                return 1;
            }
            break;
        }
    }
    return 0;
}

static void append(char *out, const char *txt) {
    if (*out != '\0') {
        strcat(out, ", ");
    }
    strcat(out, txt);
}

static void mstring(const char *s, char *out) {
    for (; *s != '\0'; s++) {
        switch (*s) {
        case 'L':
            append(out, "load");
            break;
        case 'S':
            append(out, "spin");
            break;
        case 'F':
            append(out, "fire");
            break;
        }
    }
}

static void test(char *src) {
    char buffer[41] = "";
    const int tests = 100000;
    int sum = 0;
    int t;
    double pc;

    for (t = 0; t < tests; t++) {
        sum += method(src);
    }

    mstring(src, buffer);
    pc = 100.0 * sum / tests;

    printf("%-40s produces %6.3f%% deaths.\n", buffer, pc);
}

int main() {
    srand(time(0));

    test("LSLSFSF");
    test("LSLSFF");
    test("LLSFSF");
    test("LLSFF");

    return 0;
}
`,`#include "two-bullet-roulette.h"



undefined4 entry(void)

{
  time_t tVar1;
  
  tVar1 = _time((time_t *)0x0);
  _srand((uint)tVar1);
  FUN_1000039e8("LSLSFSF");
  FUN_1000039e8("LSLSFF");
  FUN_1000039e8("LLSFSF");
  FUN_1000039e8("LLSFF");
  return 0;
}



void FUN_1000039e8(undefined8 param_1)

{
  int iVar1;
  int local_5c;
  undefined auStack_41 [41];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memset(auStack_41,0,0x29);
  for (local_5c = 0; local_5c < 100000; local_5c = local_5c + 1) {
    FUN_100003b00(param_1);
  }
  FUN_100003bcc(param_1);
  iVar1 = _printf("%-40s produces %6.3f%% deaths.\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined4 FUN_100003b00(char *param_1)

{
  char cVar1;
  ulong uVar2;
  char *local_20;
  
  FUN_100003c9c();
  local_20 = param_1;
  do {
    if (*local_20 == '\0') {
      return 0;
    }
    cVar1 = *local_20;
    if (cVar1 == 'F') {
      uVar2 = FUN_100003e4c();
      if ((uVar2 & 1) != 0) {
        return 1;
      }
    }
    else if (cVar1 == 'L') {
      FUN_100003cec();
    }
    else if (cVar1 == 'S') {
      FUN_100003db8();
    }
    local_20 = local_20 + 1;
  } while( true );
}



void FUN_100003bcc(char *param_1,undefined8 param_2)

{
  char cVar1;
  char *local_18;
  
  for (local_18 = param_1; *local_18 != '\0'; local_18 = local_18 + 1) {
    cVar1 = *local_18;
    if (cVar1 == 'F') {
      FUN_100003e84(param_2,"fire");
    }
    else if (cVar1 == 'L') {
      FUN_100003e84(param_2,"load");
    }
    else if (cVar1 == 'S') {
      FUN_100003e84(param_2,"spin");
    }
  }
  return;
}



void FUN_100003c9c(void)

{
  int local_4;
  
  for (local_4 = 0; local_4 < 6; local_4 = local_4 + 1) {
    (&DAT_100008000)[local_4] = 0;
  }
  return;
}



void FUN_100003cec(void)

{
  while ((DAT_100008000 & 1) != 0) {
    FUN_100003d28();
  }
  DAT_100008000 = 1;
  FUN_100003d28();
  return;
}



void FUN_100003d28(void)

{
  int local_8;
  
  DAT_100008000 = DAT_100008005 & 1;
  for (local_8 = 4; -1 < local_8; local_8 = local_8 + -1) {
    (&DAT_100008000)[local_8 + 1] = (&DAT_100008000)[local_8] & 1;
  }
  return;
}



void FUN_100003db8(void)

{
  int iVar1;
  undefined4 local_18;
  
  iVar1 = FUN_100003e1c(6);
  for (local_18 = 1; local_18 < iVar1 + 1; local_18 = local_18 + 1) {
    FUN_100003d28();
  }
  return;
}



int FUN_100003e1c(int param_1)

{
  int iVar1;
  int iVar2;
  
  iVar2 = _rand();
  iVar1 = 0;
  if (param_1 != 0) {
    iVar1 = iVar2 / param_1;
  }
  return iVar2 - iVar1 * param_1;
}



byte FUN_100003e4c(void)

{
  byte bVar1;
  
  bVar1 = DAT_100008000 & 1;
  FUN_100003d28();
  return bVar1;
}



void FUN_100003e84(char *param_1,undefined8 param_2)

{
  if (*param_1 != '\0') {
    ___strcat_chk(param_1,", ",0xffffffffffffffff);
  }
  ___strcat_chk(param_1,param_2,0xffffffffffffffff);
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strcat_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcat_chk_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004018)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004028)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004030)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004038)();
  return tVar1;
}


`
`#include <stdio.h>

int kprime(int n, int k)
{
	int p, f = 0;
	for (p = 2; f < k && p*p <= n; p++)
		while (0 == n % p)
			n /= p, f++;

	return f + (n > 1) == k;
}

int main(void)
{
	int i, c, k;

	for (k = 1; k <= 5; k++) {
		printf("k = %d:", k);

		for (i = 2, c = 0; c < 10; i++)
			if (kprime(i, k)) {
				printf(" %d", i);
				c++;
			}

		putchar('\n');
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d8c(void);
int32_t function_100003f7c(char * format, ...);
int32_t function_100003f88(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d8c - 0x100003e84
int64_t function_100003d8c(void) {
    // 0x100003d8c
    int64_t v1; // 0x100003d8c
    int32_t v2 = v1; // 0x100003d90
    int32_t v3 = v1; // 0x100003d94
    int32_t v4 = -v3; // 0x100003db0
    int32_t v5 = v2; // 0x100003dc0
    int32_t v6 = 0; // 0x100003dc0
    int32_t v7; // 0x100003d8c
    int32_t v8; // 0x100003e5c
    if (v4 < 0 == (v4 & v3) < 0) {
        // 0x100003e54
        v7 = v2;
        v8 = v7 - 1;
        return (int32_t)!((v8 == 0 | v8 < 0 != (v7 & -v7) < 0)) == v3;
    }
    int32_t v9 = 2;
    int32_t v10 = v9 * v9; // 0x100003dd0
    while (v10 - v5 == 0 || v10 - v5 < 0 != ((v10 - v5 ^ v10) & (v10 ^ v5)) < 0) {
        int32_t v11 = v5; // 0x100003e18
        int32_t v12 = v6; // 0x100003e18
        int32_t v13 = v6; // 0x100003e18
        int32_t v14 = v5; // 0x100003e18
        if (v5 % v9 == 0) {
            int32_t v15 = v11 / v9; // 0x100003e28
            int32_t v16 = v12 + 1; // 0x100003e34
            v11 = v15;
            v12 = v16;
            v13 = v16;
            v14 = v15;
            while (v15 % v9 == 0) {
                // 0x100003e20
                v15 = v11 / v9;
                v16 = v12 + 1;
                v11 = v15;
                v12 = v16;
                v13 = v16;
                v14 = v15;
            }
        }
        // 0x100003e44
        v5 = v14;
        v6 = v13;
        int32_t v17 = v6 - v3; // 0x100003db0
        if (v17 < 0 == ((v17 ^ v6) & (v6 ^ v3)) < 0) {
            // break -> 0x100003e54
            break;
        }
        v9++;
        v10 = v9 * v9;
    }
    // 0x100003e54
    v7 = v5;
    v8 = v7 - 1;
    return v6 + (int32_t)!((v8 == 0 | v8 < 0 != (v7 & -v7) < 0)) == v3;
}

// Address range: 0x100003e84 - 0x100003f7c
int64_t entry_point(void) {
    uint32_t v1 = 1;
    int64_t v2; // 0x100003e84
    _printf("k = %d:", v2);
    int64_t v3 = v1; // 0x100003ef8
    int32_t v4 = 0;
    int32_t v5 = v4; // 0x100003f08
    if ((int32_t)function_100003d8c() != 0) {
        // 0x100003f10
        _printf(" %d", v3);
        v5 = v4 + 1;
    }
    int32_t v6 = v5;
    while (v6 < 10 != (9 - v6 & v6) < 0) {
        // 0x100003ef4
        v4 = v6;
        v5 = v4;
        if ((int32_t)function_100003d8c() != 0) {
            // 0x100003f10
            _printf(" %d", v3);
            v5 = v4 + 1;
        }
        // 0x100003f40
        v6 = v5;
    }
    // 0x100003f50
    _putchar(10);
    int32_t v7 = v1 + 1; // 0x100003f60
    int32_t v8 = v1 - 4; // 0x100003ea4
    while (v8 == 0 || v8 < 0 != (3 - v1 & v7) < 0) {
        // 0x100003eb4
        v1 = v7;
        _printf("k = %d:", v3);
        v3 = v1;
        v4 = 0;
        v5 = v4;
        if ((int32_t)function_100003d8c() != 0) {
            // 0x100003f10
            _printf(" %d", v3);
            v5 = v4 + 1;
        }
        // 0x100003f40
        v6 = v5;
        while (v6 < 10 != (9 - v6 & v6) < 0) {
            // 0x100003ef4
            v4 = v6;
            v5 = v4;
            if ((int32_t)function_100003d8c() != 0) {
                // 0x100003f10
                _printf(" %d", v3);
                v5 = v4 + 1;
            }
            // 0x100003f40
            v6 = v5;
        }
        // 0x100003f50
        _putchar(10);
        v7 = v1 + 1;
        v8 = v1 - 4;
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(int32_t c) {
    // 0x100003f88
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`//FormAI DATASET v1.0 Category: Log analysis ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    FILE *file;
    char line[100];
    int num_of_lines = 0;
    int num_of_errors = 0;
    int num_of_warnings = 0;
    
    // Check if the file exists
    if ((file = fopen("log.txt", "r")) == NULL) {
        printf("Error opening file.\n");
        return 1;   
    }
    
    // Read each line of the file
    while (fgets(line, sizeof(line), file)) {
        num_of_lines++;
        
        // Count the number of errors
        if (strstr(line, "ERROR") != NULL) {
            num_of_errors++;
        }
        
        // Count the number of warnings
        if (strstr(line, "WARNING") != NULL) {
            num_of_warnings++;
        }
    }
    
    // Close the file
    fclose(file);
    
    // Print the results
    printf("Number of lines: %d\n", num_of_lines);
    printf("Number of errors: %d\n", num_of_errors);
    printf("Number of warnings: %d\n", num_of_warnings);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[104]; // [rsp+20h] [rbp-80h] BYREF
  FILE *Stream; // [rsp+88h] [rbp-18h]
  unsigned int v6; // [rsp+94h] [rbp-Ch]
  unsigned int v7; // [rsp+98h] [rbp-8h]
  unsigned int v8; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 0;
  v7 = 0;
  v6 = 0;
  Stream = fopen("log.txt", "r");
  if ( Stream )
  {
    while ( fgets(Str, 100, Stream) )
    {
      ++v8;
      if ( strstr(Str, "ERROR") )
        ++v7;
      if ( strstr(Str, "WARNING") )
        ++v6;
    }
    fclose(Stream);
    printf("Number of lines: %d\n", v8);
    printf("Number of errors: %d\n", v7);
    printf("Number of warnings: %d\n", v6);
    return 0;
  }
  else
  {
    printf("Error opening file.\n");
    return 1;
  }
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>

#define JOBS 12
#define jobs(a) for (switch_to(a = 0); a < JOBS || !printf("\n"); switch_to(++a))
typedef struct { int seq, cnt; } env_t;

env_t env[JOBS] = {{0, 0}};
int *seq, *cnt;

void hail()
{
	printf("% 4d", *seq);
	if (*seq == 1) return;
	++*cnt;
	*seq = (*seq & 1) ? 3 * *seq + 1 : *seq / 2;
}

void switch_to(int id)
{
	seq = &env[id].seq;
	cnt = &env[id].cnt;
}

int main()
{
	int i;
	jobs(i) { env[i].seq = i + 1; }

again:	jobs(i) { hail(); }
	jobs(i) { if (1 != *seq) goto again; }

	printf("COUNTS:\n");
	jobs(i) { printf("% 4d", *cnt); }

	return 0;
}
`,`#include "first-class-environments.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _hail(void)

{
  int iVar1;
  uint local_1c;
  
  iVar1 = _printf("% 4d");
  if (*__seq != 1) {
    *__cnt = *__cnt + 1;
    if ((*__seq & 1) == 0) {
      local_1c = (int)*__seq / 2;
    }
    else {
      local_1c = *__seq * 3 + 1;
    }
    *__seq = local_1c;
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _switch_to(int param_1)

{
  __seq = &_env + (long)param_1 * 8;
  __cnt = (long)param_1 * 8 + 0x100008004;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(void)

{
  bool bVar1;
  int iVar2;
  int local_18;
  
  local_18 = 0;
  _switch_to(0);
  while( true ) {
    bVar1 = true;
    if (0xb < local_18) {
      iVar2 = _printf("\n");
      bVar1 = iVar2 == 0;
    }
    if (!bVar1) break;
    *(int *)(&_env + (long)local_18 * 8) = local_18 + 1;
    local_18 = local_18 + 1;
    _switch_to();
  }
  do {
    local_18 = 0;
    _switch_to(0);
    while( true ) {
      bVar1 = true;
      if (0xb < local_18) {
        iVar2 = _printf("\n");
        bVar1 = iVar2 == 0;
      }
      if (!bVar1) break;
      _hail();
      local_18 = local_18 + 1;
      _switch_to();
    }
    local_18 = 0;
    _switch_to(0);
    while( true ) {
      bVar1 = true;
      if (0xb < local_18) {
        iVar2 = _printf("\n");
        bVar1 = iVar2 == 0;
      }
      if (!bVar1) {
        _printf("COUNTS:\n");
        local_18 = 0;
        _switch_to(0);
        while( true ) {
          bVar1 = true;
          if (0xb < local_18) {
            iVar2 = _printf("\n");
            bVar1 = iVar2 == 0;
          }
          if (!bVar1) break;
          _printf("% 4d");
          local_18 = local_18 + 1;
          _switch_to();
        }
        return 0;
      }
      if (*__seq != 1) break;
      local_18 = local_18 + 1;
      _switch_to();
    }
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

/* let us declare our functions; indeed here we need
   really only M declaration, so that F can "see" it
   and the compiler won't complain with a warning */
int F(const int n);
int M(const int n);

int F(const int n)
{
  return (n == 0) ? 1 : n - M(F(n - 1));
}

int M(const int n)
{
  return (n == 0) ? 0 : n - F(M(n - 1));
}

int main(void)
{
  int i;
  for (i = 0; i < 20; i++)
    printf("%2d ", F(i));
  printf("\n");
  for (i = 0; i < 20; i++)
    printf("%2d ", M(i));
  printf("\n");
  return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003dec(void);
int64_t function_100003e54(void);
int32_t function_100003f94(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dec - 0x100003e54
int64_t function_100003dec(void) {
    int64_t result = 1; // 0x100003e08
    int64_t v1; // 0x100003dec
    if ((int32_t)v1 != 0) {
        // 0x100003e1c
        function_100003dec();
        result = v1 - function_100003e54() & 0xffffffff;
    }
    // 0x100003e44
    return result;
}

// Address range: 0x100003e54 - 0x100003ebc
int64_t function_100003e54(void) {
    int64_t result = 0; // 0x100003e70
    int64_t v1; // 0x100003e54
    if ((int32_t)v1 != 0) {
        // 0x100003e84
        function_100003e54();
        result = v1 - function_100003dec() & 0xffffffff;
    }
    // 0x100003eac
    return result;
}

// Address range: 0x100003ebc - 0x100003f94
int64_t entry_point(void) {
    int64_t v1; // 0x100003ebc
    for (int32_t i = 0; i < 20; i++) {
        // 0x100003ee8
        function_100003dec();
        _printf("%2d ", v1);
    }
    // 0x100003f1c
    _printf((char *)0x100003fa5);
    for (int32_t i = 0; i < 20; i++) {
        // 0x100003f44
        function_100003e54();
        _printf("%2d ", v1);
    }
    // 0x100003f78
    _printf("\n");
    return 0;
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(char * format, ...) {
    // 0x100003f94
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>

#define LIMIT 5000
static bool PRIMES[LIMIT];

static void prime_sieve() {
    uint64_t p;
    int i;

    PRIMES[0] = false;
    PRIMES[1] = false;
    for (i = 2; i < LIMIT; i++) {
        PRIMES[i] = true;
    }

    for (i = 4; i < LIMIT; i += 2) {
        PRIMES[i] = false;
    }

    for (p = 3;; p += 2) {
        uint64_t q = p * p;
        if (q >= LIMIT) {
            break;
        }
        if (PRIMES[p]) {
            uint64_t inc = 2 * p;
            for (; q < LIMIT; q += inc) {
                PRIMES[q] = false;
            }
        }
    }
}

uint64_t modpow(uint64_t base, uint64_t exp, uint64_t mod) {
    uint64_t result = 1;

    if (mod == 1) {
        return 0;
    }

    base %= mod;
    for (; exp > 0; exp >>= 1) {
        if ((exp & 1) == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
    }
    return result;
}

void wieferich_primes() {
    uint64_t p;

    for (p = 2; p < LIMIT; ++p) {
        if (PRIMES[p] && modpow(2, p - 1, p * p) == 1) {
            printf("%lld\n", p);
        }
    }
}

int main() {
    prime_sieve();

    printf("Wieferich primes less than %d:\n", LIMIT);
    wieferich_primes();

    return 0;
}
`,`#include "wieferich-primes.h"



long _modpow(ulong param_1,ulong param_2,ulong param_3)

{
  ulong uVar1;
  undefined8 local_28;
  undefined8 local_18;
  undefined8 local_10;
  undefined8 local_8;
  
  local_28 = 1;
  if (param_3 == 1) {
    local_8 = 0;
  }
  else {
    uVar1 = 0;
    if (param_3 != 0) {
      uVar1 = param_1 / param_3;
    }
    local_10 = param_1 - uVar1 * param_3;
    for (local_18 = param_2; local_18 != 0; local_18 = local_18 >> 1) {
      if ((local_18 & 1) == 1) {
        uVar1 = 0;
        if (param_3 != 0) {
          uVar1 = (ulong)(local_28 * local_10) / param_3;
        }
        local_28 = local_28 * local_10 - uVar1 * param_3;
      }
      uVar1 = 0;
      if (param_3 != 0) {
        uVar1 = (ulong)(local_10 * local_10) / param_3;
      }
      local_10 = local_10 * local_10 - uVar1 * param_3;
    }
    local_8 = local_28;
  }
  return local_8;
}



ulong _wieferich_primes(ulong param_1)

{
  uint uVar1;
  ulong local_18;
  
  for (local_18 = 2; local_18 < 5000; local_18 = local_18 + 1) {
    if ((((&DAT_100008000)[local_18] & 1) != 0) &&
       (param_1 = _modpow(2,local_18 - 1,local_18 * local_18), param_1 == 1)) {
      uVar1 = _printf("%lld\n");
      param_1 = (ulong)uVar1;
    }
  }
  return param_1;
}



undefined4 entry(void)

{
  int iVar1;
  
  FUN_100003de4();
  iVar1 = _printf("Wieferich primes less than %d:\n");
  _wieferich_primes(iVar1);
  return 0;
}



void FUN_100003de4(void)

{
  ulong local_18;
  int local_c;
  long local_8;
  
  DAT_100008000 = 0;
  DAT_100008001 = 0;
  for (local_c = 2; local_c < 5000; local_c = local_c + 1) {
    (&DAT_100008000)[local_c] = 1;
  }
  for (local_c = 4; local_c < 5000; local_c = local_c + 2) {
    (&DAT_100008000)[local_c] = 0;
  }
  for (local_8 = 3; local_18 = local_8 * local_8, local_18 < 5000; local_8 = local_8 + 2) {
    if (((&DAT_100008000)[local_8] & 1) != 0) {
      for (; local_18 < 5000; local_18 = local_18 + local_8 * 2) {
        (&DAT_100008000)[local_18] = 0;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Public-Key Algorithm Implementation ; Style: rigorous
#include<stdio.h> 

// Function to find gcd of two numbers
int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}

// Function to calculate pow(x, y) % p
int mod_exp(int x, int y, int p) {
    int res = 1;
    x = x % p;

    while (y > 0) {
        if (y & 1) {
            res = (res*x) % p;
        }
        y = y>>1;
        x = (x*x) % p;
    }
    return res;
}

int main() {
    int p = 13; // Public key
    int alpha = 6; // Primitive root
    int a, b, A, B; // Secret keys

    // Alice generates her secret key
    a = 5;
    A = mod_exp(alpha, a, p);

    // Bob generates his secret key
    b = 7;
    B = mod_exp(alpha, b, p);

    // Shared secret key
    int keyA = mod_exp(B, a, p);
    int keyB = mod_exp(A, b, p);

    // Check if both the secret keys are same
    if (keyA == keyB) {
        printf("Shared secret key is %d\n", keyA);
    }
    else {
        printf("Error in calculating Shared secret key\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall mod_exp(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000161D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-1Ch]
  unsigned int v5; // [rsp+28h] [rbp-18h]
  unsigned int v6; // [rsp+30h] [rbp-10h]

  _main(argc, argv, envp);
  v6 = mod_exp(6i64, 5i64, 13i64);
  v5 = mod_exp(6i64, 7i64, 13i64);
  v4 = mod_exp(v5, 5i64, 13i64);
  if ( v4 == (unsigned int)mod_exp(v6, 7i64, 13i64) )
    printf("Shared secret key is %d\n", v4);
  else
    printf("Error in calculating Shared secret key\n");
  return 0;
}
// 1400015C1: using guessed type __int64 __fastcall mod_exp(_QWORD, _QWORD, _QWORD);
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_SIZE 100

void initializeBoard(int board[MAX_SIZE][MAX_SIZE], int size);
void shuffle(int arr[MAX_SIZE], int size);
void printBoard(int board[MAX_SIZE][MAX_SIZE], int size);
int getPair(int board[MAX_SIZE][MAX_SIZE], int size, int r, int c);
int getRow();
int getColumn();

int main()
{
    int size, row, col, firstRow, firstCol, secondRow, secondCol, pairs = 0;
    int board[MAX_SIZE][MAX_SIZE];
    
    printf("Enter board size (even number between 4 and 100): ");
    scanf("%d", &size);
    
    // Validate input
    while (size < 4 || size > MAX_SIZE || size % 2 != 0) {
        printf("Invalid size! Please enter an even number between 4 and 100: ");
        scanf("%d", &size);
    }
    
    initializeBoard(board, size);
    shuffle(board[0], size * size);
    
    printf("Let's play the Memory game!\n\n");
    printBoard(board, size);
    
    while (pairs < (size * size) / 2) {
        printf("Enter first card location (row, column): ");
        firstRow = getRow();
        firstCol = getColumn();
        
        while (board[firstRow][firstCol] == -1) {
            printf("This card is already matched! Enter a different location.\n");
            printf("Enter first card location (row, column): ");
            firstRow = getRow();
            firstCol = getColumn();
        }
        
        board[firstRow][firstCol] = -1;
        printBoard(board, size);
        
        printf("Enter second card location (row, column): ");
        secondRow = getRow();
        secondCol = getColumn();
        
        while (board[secondRow][secondCol] == -1 || (firstRow == secondRow && firstCol == secondCol)) {
            if (board[secondRow][secondCol] == -1) {
                printf("This card is already matched! Enter a different location.\n");
            } else {
                printf("Can't choose the same location! Enter a different location.\n");
            }
            
            printf("Enter second card location (row, column): ");
            secondRow = getRow();
            secondCol = getColumn();
        }
        
        if (getPair(board, size, firstRow, firstCol) == getPair(board, size, secondRow, secondCol)) {
            printf("Congratulations! You found a pair.\n");
            board[secondRow][secondCol] = -1;
            pairs++;
        } else {
            printf("Sorry! Cards do not match.\n");
            board[firstRow][firstCol] = getPair(board, size, firstRow, firstCol);
        }
        
        printBoard(board, size);
    }
    
    printf("Great job! You won the game in %d moves.", pairs * 2);
    
    return 0;
}

void initializeBoard(int board[MAX_SIZE][MAX_SIZE], int size)
{
    int i, j, k = 0;
    
    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            board[i][j] = k / 2;
            k++;
        }
    }
}

void shuffle(int arr[MAX_SIZE], int size)
{
    int i, j, temp;
    srand(time(NULL));
    
    for (i = size - 1; i > 0; i--) {
        j = rand() % (i + 1);
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

void printBoard(int board[MAX_SIZE][MAX_SIZE], int size)
{
    int i, j;
    
    printf("\n    ");
    for (i = 0; i < size; i++) {
        printf("%-3d", i);
    }
    printf("\n   ");
    for (i = 0; i < size; i++) {
        printf("---");
    }
    printf("\n");
    
    for (i = 0; i < size; i++) {
        printf("%-2d |", i);
        for (j = 0; j < size; j++) {
            if (board[i][j] == -1) {
                printf(" X ");
            } else {
                printf(" - ");
            }
        }
        printf("| %d\n", i);
    }
    
    printf("   ");
    for (i = 0; i < size; i++) {
        printf("---");
    }
    printf("\n    ");
    for (i = 0; i < size; i++) {
        printf("%-3d", i);
    }
    printf("\n");
}

int getPair(int board[MAX_SIZE][MAX_SIZE], int size, int r, int c)
{
    int i, j;
    
    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            if (i != r || j != c) {
                if (board[i][j] == board[r][c]) {
                    return board[i][j];
                }
            }
        }
    }
    
    return -1;
}

int getRow()
{
    int row;
    
    printf("Enter row (0-99): ");
    scanf("%d", &row);
    
    // Validate input
    while (row < 0 || row > 99) {
        printf("Invalid row! Please enter a number between 0 and 99: ");
        scanf("%d", &row);
    }
    
    return row;
}

int getColumn()
{
    int col;
    
    printf("Enter column (0-99): ");
    scanf("%d", &col);
    
    // Validate input
    while (col < 0 || col > 99) {
        printf("Invalid column! Please enter a number between 0 and 99: ");
        scanf("%d", &col);
    }
    
    return col;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall initializeBoard(_QWORD, _QWORD); // weak
__int64 __fastcall shuffle(_QWORD, _QWORD); // weak
__int64 __fastcall printBoard(_QWORD, _QWORD); // weak
__int64 __fastcall getPair(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 getRow(void); // weak
__int64 getColumn(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int Pair; // ebx
  int v4; // eax
  int v6[10002]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v7; // [rsp+9C68h] [rbp+9BE8h] BYREF
  int v8; // [rsp+9C6Ch] [rbp+9BECh]
  unsigned int j; // [rsp+9C70h] [rbp+9BF0h]
  unsigned int v10; // [rsp+9C74h] [rbp+9BF4h]
  unsigned int i; // [rsp+9C78h] [rbp+9BF8h]
  unsigned int Row; // [rsp+9C7Ch] [rbp+9BFCh]

  _main(argc, argv, envp);
  v8 = 0;
  printf("Enter board size (even number between 4 and 100): ");
  scanf("%d", &v7);
  while ( (int)v7 <= 3 || (int)v7 > 100 || (v7 & 1) != 0 )
  {
    printf("Invalid size! Please enter an even number between 4 and 100: ");
    scanf("%d", &v7);
  }
  initializeBoard(v6, v7);
  shuffle(v6, v7 * v7);
  printf("Let's play the Memory game!\n\n");
  printBoard(v6, v7);
  while ( v8 < (int)(v7 * v7) / 2 )
  {
    printf("Enter first card location (row, column): ");
    Row = getRow();
    for ( i = getColumn(); v6[100 * Row + i] == -1; i = getColumn() )
    {
      printf("This card is already matched! Enter a different location.\n");
      printf("Enter first card location (row, column): ");
      Row = getRow();
    }
    v6[100 * Row + i] = -1;
    printBoard(v6, v7);
    printf("Enter second card location (row, column): ");
    v10 = getRow();
    for ( j = getColumn(); v6[100 * v10 + j] == -1 || Row == v10 && i == j; j = getColumn() )
    {
      if ( v6[100 * v10 + j] == -1 )
        printf("This card is already matched! Enter a different location.\n");
      else
        printf("Can't choose the same location! Enter a different location.\n");
      printf("Enter second card location (row, column): ");
      v10 = getRow();
    }
    Pair = getPair(v6, v7, Row, i);
    if ( Pair == (unsigned int)getPair(v6, v7, v10, j) )
    {
      printf("Congratulations! You found a pair.\n");
      v6[100 * v10 + j] = -1;
      ++v8;
    }
    else
    {
      printf("Sorry! Cards do not match.\n");
      v4 = getPair(v6, v7, Row, i);
      v6[100 * Row + i] = v4;
    }
    printBoard(v6, v7);
  }
  printf("Great job! You won the game in %d moves.", (unsigned int)(2 * v8));
  return 0;
}
// 140001A2B: using guessed type __int64 __fastcall initializeBoard(_QWORD, _QWORD);
// 140001AB6: using guessed type __int64 __fastcall shuffle(_QWORD, _QWORD);
// 140001B63: using guessed type __int64 __fastcall printBoard(_QWORD, _QWORD);
// 140001D1C: using guessed type __int64 __fastcall getPair(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001E23: using guessed type __int64 getRow(void);
// 140001E8F: using guessed type __int64 getColumn(void);
// 140001FB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001601: using guessed type int var_9C70[10002];

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>

#define MAX_ENQUEUED 20
#define BUF_LEN 256
#define PORT_STR "12321"

/* ------------------------------------------------------------ */
/* How to clean up after dead child processes                   */
/* ------------------------------------------------------------ */

void wait_for_zombie(int s)
{
    while(waitpid(-1, NULL, WNOHANG) > 0) ;
}

/* ------------------------------------------------------------ */
/* Core of implementation of a child process                    */
/* ------------------------------------------------------------ */

void echo_lines(int csock)
{
    char buf[BUF_LEN];
    int r;

    while( (r = read(csock, buf, BUF_LEN)) > 0 ) {
        (void)write(csock, buf, r);
    }
    exit(EXIT_SUCCESS);
}

/* ------------------------------------------------------------ */
/* Core of implementation of the parent process                 */
/* ------------------------------------------------------------ */

void take_connections_forever(int ssock)
{
    for(;;) {
        struct sockaddr addr;
        socklen_t addr_size = sizeof(addr);
        int csock;

        /* Block until we take one connection to the server socket */
        csock = accept(ssock, &addr, &addr_size);

        /* If it was a successful connection, spawn a worker process to service it */
        if ( csock == -1 ) {
            perror("accept");
        } else if ( fork() == 0 ) {
            close(ssock);
            echo_lines(csock);
        } else {
            close(csock);
        }
    }
}

/* ------------------------------------------------------------ */
/* The server process's one-off setup code                      */
/* ------------------------------------------------------------ */

int main()
{
    struct addrinfo hints, *res;
    struct sigaction sa;
    int sock;

    /* Look up the address to bind to */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ( getaddrinfo(NULL, PORT_STR, &hints, &res) != 0 ) {
        perror("getaddrinfo");
        exit(EXIT_FAILURE);
    }

    /* Make a socket */
    if ( (sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1 ) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    /* Arrange to clean up child processes (the workers) */
    sa.sa_handler = wait_for_zombie;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if ( sigaction(SIGCHLD, &sa, NULL) == -1 ) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }

    /* Associate the socket with its address */
    if ( bind(sock, res->ai_addr, res->ai_addrlen) != 0 ) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    freeaddrinfo(res);

    /* State that we've opened a server socket and are listening for connections */
    if ( listen(sock, MAX_ENQUEUED) != 0 ) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    /* Serve the listening socket until killed */
    take_connections_forever(sock);
    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _TYPEDEF_sigset_t {
    int32_t e0[1];
};

struct addrinfo {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct sockaddr * e5;
    char * e6;
    struct addrinfo * e7;
};

struct sigaction {
    void (*e0)(int32_t);
    int32_t e1;
    void (*e2)();
    struct _TYPEDEF_sigset_t e3;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003be4(void);
int64_t function_100003c28(void);
int64_t function_100003c98(void);
int64_t function_100003ea4(int64_t a1, int64_t a2);
int32_t function_100003eb4(int32_t fd, struct sockaddr * addr, int32_t * addr_len);
int32_t function_100003ec0(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_100003ecc(int32_t fd);
void function_100003ed8(int32_t status);
int32_t function_100003ee4(void);
void function_100003ef0(struct addrinfo * ai);
int32_t function_100003efc(char * name, char * service, struct addrinfo * req, struct addrinfo ** pai);
int32_t function_100003f08(int32_t fd, int32_t n);
int64_t * function_100003f14(int64_t * s, int32_t c, int32_t n);
void function_100003f20(char * s);
int32_t function_100003f2c(int32_t fd, int64_t * buf, int32_t nbytes);
int32_t function_100003f38(int32_t sig, struct sigaction * act, struct sigaction * oact);
int32_t function_100003f44(int32_t domain, int32_t type, int32_t protocol);
int32_t function_100003f50(int32_t pid, int32_t * stat_loc, int32_t options);
int32_t function_100003f5c(int32_t fd, int64_t * buf, int32_t n);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int32_t _accept(int32_t a1, struct sockaddr * a2, int32_t * a3);
int32_t _bind(int32_t a1, struct sockaddr * a2, int32_t a3);
int32_t _close(int32_t a1);
int32_t _fork(void);
void _freeaddrinfo(struct addrinfo * a1);
int32_t _getaddrinfo(char * a1, char * a2, struct addrinfo * a3, struct addrinfo ** a4);
int32_t _listen(int32_t a1, int32_t a2);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
void _perror(char * a1);
int32_t _sigaction(int32_t a1, struct sigaction * a2, struct sigaction * a3);
int32_t _socket(int32_t a1, int32_t a2, int32_t a3);
int32_t _waitpid(int32_t a1, int32_t * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003be4 - 0x100003c28
int64_t function_100003be4(void) {
    int32_t result = _waitpid(-1, NULL, 1); // 0x100003c04
    while (result >= 1) {
        // 0x100003bf8
        result = _waitpid(-1, NULL, 1);
    }
    // 0x100003c1c
    return result;
}

// Address range: 0x100003c28 - 0x100003c98
int64_t function_100003c28(void) {
    // 0x100003c28
    int64_t v1; // 0x100003c28
    int32_t v2 = v1; // 0x100003c48
    int64_t v3; // bp-296, 0x100003c28
    int32_t v4 = _read(v2, &v3, 256); // 0x100003c5c
    if (v4 < 1) {
        // 0x100003c90
        _exit(0);
        return &g1;
    }
    _write(v2, &v3, v4);
    int32_t v5 = _read(v2, &v3, 256); // 0x100003c5c
    while (v5 >= 1) {
        // 0x100003c7c
        _write(v2, &v3, v5);
        v5 = _read(v2, &v3, 256);
    }
    // 0x100003c90
    _exit(0);
    return &g1;
}

// Address range: 0x100003c98 - 0x100003d28
int64_t function_100003c98(void) {
    // 0x100003c98
    int64_t v1; // 0x100003c98
    int32_t v2 = v1; // 0x100003ca4
    while (true) {
        int64_t v3 = 16; // bp-40, 0x100003cb4
        int64_t v4; // bp-36, 0x100003c98
        int32_t v5 = _accept(v2, (struct sockaddr *)&v4, (int32_t *)&v3); // 0x100003cc0
        if (v5 == -1) {
            // 0x100003cdc
            _perror("accept");
        } else {
            // 0x100003cec
            if (_fork() == 0) {
                // break -> 0x100003d00
                break;
            }
            // 0x100003d14
            _close(v5);
        }
    }
    // 0x100003d00
    _close(v2);
    function_100003c28();
    // UNREACHABLE
}

// Address range: 0x100003d28 - 0x100003ea4
int64_t entry_point(void) {
    // 0x100003d28
    int64_t v1; // bp-72, 0x100003d28
    _memset(&v1, 0, 48);
    v1 = 1;
    struct addrinfo * v2; // bp-80, 0x100003d28
    if (_getaddrinfo(NULL, "12321", (struct addrinfo *)&v1, &v2) != 0) {
        // 0x100003d84
        _perror("getaddrinfo");
        _exit(1);
        // UNREACHABLE
    }
    int64_t v3 = (int64_t)v2; // 0x100003d98
    int32_t v4 = *(int32_t *)(v3 + 12); // 0x100003dac
    int32_t v5 = _socket(*(int32_t *)(v3 + 4), *(int32_t *)(v3 + 8), v4); // 0x100003db0
    if (v5 == -1) {
        // 0x100003dc8
        _perror("socket");
        _exit(1);
        // UNREACHABLE
    }
    int64_t v6 = 0x100003be4; // bp-96, 0x100003de8
    if (_sigaction(20, (struct sigaction *)&v6, NULL) == -1) {
        // 0x100003e14
        _perror("sigaction");
        _exit(1);
        // UNREACHABLE
    }
    int64_t v7 = (int64_t)v2; // 0x100003e2c
    int32_t v8 = *(int32_t *)(v7 + 16); // 0x100003e38
    if (_bind(v5, (struct sockaddr *)*(int64_t *)(v7 + 32), v8) != 0) {
        // 0x100003e50
        _perror("bind");
        _exit(1);
        // UNREACHABLE
    }
    // 0x100003e64
    _freeaddrinfo(v2);
    if (_listen(v5, 20) == 0) {
        // 0x100003e9c
        function_100003c98();
        // UNREACHABLE
    }
    // 0x100003e88
    _perror("listen");
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100003ea4 - 0x100003eb4
int64_t function_100003ea4(int64_t a1, int64_t a2) {
    // 0x100003ea4
    return 0;
}

// Address range: 0x100003eb4 - 0x100003ec0
int32_t function_100003eb4(int32_t fd, struct sockaddr * addr, int32_t * addr_len) {
    // 0x100003eb4
    return _accept(fd, addr, addr_len);
}

// Address range: 0x100003ec0 - 0x100003ecc
int32_t function_100003ec0(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x100003ec0
    return _bind(fd, addr, len);
}

// Address range: 0x100003ecc - 0x100003ed8
int32_t function_100003ecc(int32_t fd) {
    // 0x100003ecc
    return _close(fd);
}

// Address range: 0x100003ed8 - 0x100003ee4
void function_100003ed8(int32_t status) {
    // 0x100003ed8
    _exit(status);
}

// Address range: 0x100003ee4 - 0x100003ef0
int32_t function_100003ee4(void) {
    // 0x100003ee4
    return _fork();
}

// Address range: 0x100003ef0 - 0x100003efc
void function_100003ef0(struct addrinfo * ai) {
    // 0x100003ef0
    _freeaddrinfo(ai);
}

// Address range: 0x100003efc - 0x100003f08
int32_t function_100003efc(char * name, char * service, struct addrinfo * req, struct addrinfo ** pai) {
    // 0x100003efc
    return _getaddrinfo(name, service, req, pai);
}

// Address range: 0x100003f08 - 0x100003f14
int32_t function_100003f08(int32_t fd, int32_t n) {
    // 0x100003f08
    return _listen(fd, n);
}

// Address range: 0x100003f14 - 0x100003f20
int64_t * function_100003f14(int64_t * s, int32_t c, int32_t n) {
    // 0x100003f14
    return _memset(s, c, n);
}

// Address range: 0x100003f20 - 0x100003f2c
void function_100003f20(char * s) {
    // 0x100003f20
    _perror(s);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x100003f2c
    return _read(fd, buf, nbytes);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(int32_t sig, struct sigaction * act, struct sigaction * oact) {
    // 0x100003f38
    return _sigaction(sig, act, oact);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(int32_t domain, int32_t type, int32_t protocol) {
    // 0x100003f44
    return _socket(domain, type, protocol);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(int32_t pid, int32_t * stat_loc, int32_t options) {
    // 0x100003f50
    return _waitpid(pid, stat_loc, options);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(int32_t fd, int64_t * buf, int32_t n) {
    // 0x100003f5c
    return _write(fd, buf, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 20

`
`#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct stirling_cache_tag {
    int max;
    int* values;
} stirling_cache;

int stirling_number1(stirling_cache* sc, int n, int k) {
    if (k == 0)
        return n == 0 ? 1 : 0;
    if (n > sc->max || k > n)
        return 0;
    return sc->values[n*(n-1)/2 + k - 1];
}

bool stirling_cache_create(stirling_cache* sc, int max) {
    int* values = calloc(max * (max + 1)/2, sizeof(int));
    if (values == NULL)
        return false;
    sc->max = max;
    sc->values = values;
    for (int n = 1; n <= max; ++n) {
        for (int k = 1; k <= n; ++k) {
            int s1 = stirling_number1(sc, n - 1, k - 1);
            int s2 = stirling_number1(sc, n - 1, k);
            values[n*(n-1)/2 + k - 1] = s1 + s2 * (n - 1);
        }
    }
    return true;
}

void stirling_cache_destroy(stirling_cache* sc) {
    free(sc->values);
    sc->values = NULL;
}

void print_stirling_numbers(stirling_cache* sc, int max) {
    printf("Unsigned Stirling numbers of the first kind:\nn/k");
    for (int k = 0; k <= max; ++k)
        printf(k == 0 ? "%2d" : "%10d", k);
    printf("\n");
    for (int n = 0; n <= max; ++n) {
        printf("%2d ", n);
        for (int k = 0; k <= n; ++k)
            printf(k == 0 ? "%2d" : "%10d", stirling_number1(sc, n, k));
        printf("\n");
    }
}

int main() {
    stirling_cache sc = { 0 };
    const int max = 12;
    if (!stirling_cache_create(&sc, max)) {
        fprintf(stderr, "Out of memory\n");
        return 1;
    }
    print_stirling_numbers(&sc, max);
    stirling_cache_destroy(&sc);
    return 0;
}
`,`#include "stirling-numbers-of-the-first-kind.h"



uint _stirling_number1(int *param_1,int param_2,int param_3)

{
  uint local_4;
  
  if (param_3 == 0) {
    local_4 = (uint)(param_2 == 0);
  }
  else if ((*param_1 < param_2) || (param_2 < param_3)) {
    local_4 = 0;
  }
  else {
    local_4 = *(uint *)(*(long *)(param_1 + 2) +
                       (long)((param_2 * (param_2 + -1)) / 2 + param_3 + -1) * 4);
  }
  return local_4;
}



undefined _stirling_cache_create(int *param_1,int param_2)

{
  int iVar1;
  int iVar2;
  void *pvVar3;
  int local_38;
  int local_34;
  undefined local_11;
  
  pvVar3 = _calloc((long)((param_2 * (param_2 + 1)) / 2),4);
  if (pvVar3 == (void *)0x0) {
    local_11 = 0;
  }
  else {
    *param_1 = param_2;
    *(void **)(param_1 + 2) = pvVar3;
    for (local_34 = 1; local_34 <= param_2; local_34 = local_34 + 1) {
      for (local_38 = 1; local_38 <= local_34; local_38 = local_38 + 1) {
        iVar1 = _stirling_number1(param_1,local_34 + -1,local_38 + -1);
        iVar2 = _stirling_number1(param_1,local_34 + -1,local_38);
        *(int *)((long)pvVar3 + (long)((local_34 * (local_34 + -1)) / 2 + local_38 + -1) * 4) =
             iVar1 + iVar2 * (local_34 + -1);
      }
    }
    local_11 = 1;
  }
  return local_11;
}



void _stirling_cache_destroy(long param_1)

{
  _free(*(void **)(param_1 + 8));
  *(undefined8 *)(param_1 + 8) = 0;
  return;
}



int _print_stirling_numbers(undefined8 param_1,int param_2)

{
  char *pcVar1;
  int iVar2;
  int local_28;
  int local_24;
  int local_20;
  
  _printf("Unsigned Stirling numbers of the first kind:\nn/k");
  for (local_20 = 0; local_20 <= param_2; local_20 = local_20 + 1) {
    pcVar1 = "%2d";
    if (local_20 != 0) {
      pcVar1 = "%10d";
    }
    _printf(pcVar1);
  }
  iVar2 = _printf("\n");
  for (local_24 = 0; local_24 <= param_2; local_24 = local_24 + 1) {
    _printf("%2d ");
    for (local_28 = 0; local_28 <= local_24; local_28 = local_28 + 1) {
      pcVar1 = "%2d";
      if (local_28 != 0) {
        pcVar1 = "%10d";
      }
      _stirling_number1(param_1,local_24,local_28);
      _printf(pcVar1);
    }
    iVar2 = _printf("\n");
  }
  return iVar2;
}



bool entry(void)

{
  bool bVar1;
  ulong uVar2;
  undefined8 local_28;
  undefined8 local_20;
  undefined4 local_14;
  
  local_14 = 0;
  local_28 = 0;
  local_20 = 0;
  uVar2 = _stirling_cache_create(&local_28);
  bVar1 = (uVar2 & 1) != 0;
  if (bVar1) {
    _print_stirling_numbers(&local_28,0xc);
    _stirling_cache_destroy(&local_28);
  }
  else {
    _fprintf(*(FILE **)PTR____stderrp_100004000,"Out of memory\n");
  }
  return !bVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Intrusion detection system ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_TOLERABLE_TIME 10 // maximum time allowed for the same IP address
#define MAX_PACKETS_PER_REQUEST 3 // maximum number of packets allowed in a request

struct Packet {
    char* ip_address;
    int time_sent;
    int packet_size;
};

// Function to check if a given IP address has sent more than MAX_PACKETS_PER_REQUEST packets in the last MAX_TOLERABLE_TIME seconds
bool check_IP(struct Packet packets[], int num_packets, char* current_ip_address) {
    int count = 0;
    for (int i = 0; i < num_packets; i++) {
        if (strcmp(current_ip_address, packets[i].ip_address) == 0) {
            if (packets[num_packets - 1].time_sent - packets[i].time_sent <= MAX_TOLERABLE_TIME) {
                count++;
            }
        }
    }
    return (count > MAX_PACKETS_PER_REQUEST);
}

// Function to check if a given packet is a part of a DOS attack
bool check_dos_attack(struct Packet packets[], int num_packets, struct Packet current_packet) {
    if (current_packet.packet_size > 10000) {
        return true;
    }
    if (check_IP(packets, num_packets, current_packet.ip_address)) {
        return true;
    }
    return false;
}

int main() {
    struct Packet packets[100];
    int num_packets = 0;

    // Read packets from a file
    FILE* fp = fopen("packets.txt", "r");
    if (fp == NULL) {
        printf("Error opening file\n");
        exit(1);
    }

    while (!feof(fp)) {
        struct Packet current_packet;
        fscanf(fp, "%s %d %d", current_packet.ip_address, &current_packet.time_sent, &current_packet.packet_size);
        if (check_dos_attack(packets, num_packets, current_packet)) {
            printf("DOS attack detected\n");
            // Take appropriate action: block IP address, disconnect user, etc.
        }
        packets[num_packets] = current_packet;
        num_packets++;
    }

    fclose(fp);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall check_dos_attack(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl feof(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400016D0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 *v3; // rcx
  __int64 v4; // rdx
  __int64 v6[2]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v7; // [rsp+40h] [rbp-40h]
  __int64 v8; // [rsp+48h] [rbp-38h] BYREF
  char v9[48]; // [rsp+50h] [rbp-30h] BYREF
  __int64 v10; // [rsp+80h] [rbp+0h] BYREF
  FILE *Stream; // [rsp+690h] [rbp+610h]
  unsigned int v12; // [rsp+69Ch] [rbp+61Ch]

  _main(argc, argv, envp);
  v12 = 0;
  Stream = fopen("packets.txt", "r");
  if ( !Stream )
  {
    printf("Error opening file\n");
    exit(1);
  }
  while ( !feof(Stream) )
  {
    fscanf(Stream, "%s %d %d", v7, &v8, (char *)&v8 + 4);
    v6[0] = v7;
    v6[1] = v8;
    if ( (unsigned __int8)check_dos_attack(v9, v12, v6) )
      printf("DOS attack detected\n");
    v3 = &v10 + 2 * (int)v12 - 6;
    v4 = v8;
    *v3 = v7;
    v3[1] = v4;
    ++v12;
  }
  fclose(Stream);
  return 0;
}
// 14000166F: using guessed type __int64 __fastcall check_dos_attack(_QWORD, _QWORD, _QWORD);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016D0: using guessed type char var_650[48];

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include<stdio.h>

int main()
{
	return printf("\nHello World!");
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f8c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f64 - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003f64
    return _printf("\nHello World!");
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <string.h>

typedef int bool;
typedef unsigned long long ull;

#define TRUE 1
#define FALSE 0

/* OK for 'small' numbers. */
bool is_prime(ull n) {
    ull d;
    if (n < 2) return FALSE;
    if (!(n % 2)) return n == 2;
    if (!(n % 3)) return n == 3;
    d = 5;
    while (d * d <= n) {
        if (!(n % d)) return FALSE;
        d += 2;
        if (!(n % d)) return FALSE;
        d += 4;
    }
    return TRUE;
}

void ord(char *res, int n) {
    char suffix[3];
    int m = n % 100;
    if (m >= 4 && m <= 20) {
        sprintf(res,"%dth", n);
        return;
    }
    switch(m % 10) {
        case 1:
            strcpy(suffix, "st");
            break;
        case 2:
            strcpy(suffix, "nd");
            break;
        case 3:
            strcpy(suffix, "rd");
            break;
        default:
            strcpy(suffix, "th");
            break;
    }
    sprintf(res, "%d%s", n, suffix);
}

bool is_magnanimous(ull n) {
    ull p, q, r;
    if (n < 10) return TRUE;
    for (p = 10; ; p *= 10) {
        q = n / p;
        r = n % p;
        if (!is_prime(q + r)) return FALSE;
        if (q < 10) break;
    }
    return TRUE;
}

void list_mags(int from, int thru, int digs, int per_line) {
    ull i = 0;
    int c = 0;
    char res1[13], res2[13];
    if (from < 2) {
        printf("\nFirst %d magnanimous numbers:\n", thru);
    } else {
        ord(res1, from);
        ord(res2, thru);
        printf("\n%s through %s magnanimous numbers:\n", res1, res2);
    }
    for ( ; c < thru; ++i) {
        if (is_magnanimous(i)) {
            if (++c >= from) {
                printf("%*llu ", digs, i);
                if (!(c % per_line)) printf("\n");
            }
        }
    }
}

int main() {
    list_mags(1, 45, 3, 15);
    list_mags(241, 250, 1, 10);
    list_mags(391, 400, 1, 10);
    return 0;
}
`,`#include "magnanimous-numbers.h"



bool _is_prime(ulong param_1)

{
  ulong uVar1;
  ulong uVar2;
  bool bVar3;
  ulong local_18;
  
  if (param_1 < 2) {
    bVar3 = false;
  }
  else if (param_1 % 2 == 0) {
    bVar3 = param_1 == 2;
  }
  else if (param_1 % 3 == 0) {
    bVar3 = param_1 == 3;
  }
  else {
    for (local_18 = 5; local_18 * local_18 < param_1 || local_18 * local_18 - param_1 == 0;
        local_18 = local_18 + 6) {
      uVar1 = 0;
      if (local_18 != 0) {
        uVar1 = param_1 / local_18;
      }
      if (param_1 == uVar1 * local_18) {
        return false;
      }
      uVar1 = local_18 + 2;
      uVar2 = 0;
      if (uVar1 != 0) {
        uVar2 = param_1 / uVar1;
      }
      if (param_1 == uVar2 * uVar1) {
        return false;
      }
    }
    bVar3 = true;
  }
  return bVar3;
}



void _ord(undefined8 param_1,int param_2)

{
  int iVar1;
  undefined auStack_1f [3];
  int local_1c;
  undefined8 local_18;
  
  iVar1 = param_2 % 100;
  local_1c = param_2;
  local_18 = param_1;
  if ((iVar1 < 4) || (0x14 < iVar1)) {
    iVar1 = iVar1 % 10;
    if (iVar1 == 1) {
      ___strcpy_chk(auStack_1f,"st",3);
    }
    else if (iVar1 == 2) {
      ___strcpy_chk(auStack_1f,"nd",3);
    }
    else if (iVar1 == 3) {
      ___strcpy_chk(auStack_1f,"rd",3);
    }
    else {
      ___strcpy_chk(auStack_1f,"th",3);
    }
    ___sprintf_chk(local_18,0,0xffffffffffffffff,"%d%s");
  }
  else {
    ___sprintf_chk(param_1,0,0xffffffffffffffff,"%dth");
  }
  return;
}



undefined4 _is_magnanimous(ulong param_1)

{
  ulong uVar1;
  ulong uVar2;
  int iVar3;
  ulong local_28;
  
  if (9 < param_1) {
    local_28 = 10;
    while( true ) {
      uVar1 = 0;
      if (local_28 != 0) {
        uVar1 = param_1 / local_28;
      }
      uVar2 = 0;
      if (local_28 != 0) {
        uVar2 = param_1 / local_28;
      }
      iVar3 = _is_prime(uVar1 + (param_1 - uVar2 * local_28));
      if (iVar3 == 0) {
        return 0;
      }
      if (uVar1 < 10) break;
      local_28 = local_28 * 10;
    }
  }
  return 1;
}



void _list_mags(int param_1,int param_2,undefined8 param_3,int param_4)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  int local_54;
  long local_50;
  undefined auStack_32 [13];
  undefined auStack_25 [13];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_50 = 0;
  local_54 = 0;
  if (param_1 < 2) {
    uVar2 = _printf("\nFirst %d magnanimous numbers:\n");
  }
  else {
    _ord(auStack_25,param_1);
    _ord(auStack_32,param_2);
    uVar2 = _printf("\n%s through %s magnanimous numbers:\n");
  }
  uVar3 = (ulong)uVar2;
  while (local_54 < param_2) {
    uVar3 = _is_magnanimous(local_50);
    if (((int)uVar3 != 0) && (local_54 = local_54 + 1, param_1 <= local_54)) {
      uVar2 = _printf("%*llu ");
      iVar1 = 0;
      if (param_4 != 0) {
        iVar1 = local_54 / param_4;
      }
      if (local_54 == iVar1 * param_4) {
        uVar2 = _printf("\n");
      }
      uVar3 = (ulong)uVar2;
    }
    local_50 = local_50 + 1;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(uVar3);
}



undefined4 entry(void)

{
  _list_mags(1,0x2d,3,0xf);
  _list_mags(0xf1,0xfa,1);
  _list_mags(0x187,400,1,10);
  return 0;
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: modular
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

#define MAX_BUFFER_SIZE 1024

//Struct represents XML tag
typedef struct XMLtag {
    char* tagName;
    struct Attributes* attributeList;
    struct XMLtag* childList;
    char* text;
} XMLtag;

//Struct represents XML attribute
typedef struct Attribute {
    char* name;
    char* value;
    struct Attribute* next;
} Attribute;

//Function to parse XML string and return the root tag
XMLtag* parseXML(char* xmlString);

//Function to create new XML tag
XMLtag* createXMLtag(char* tagName, Attribute* attributeList, char* text, XMLtag* childList);

//Function to create new XML attribute
Attribute* createAttribute(char* attributeName, char* attributeValue);

//Function to print XML tag
void printXMLtag(XMLtag* tag);

//Function to print XML attribute
void printAttribute(Attribute* attr);

//Driver code
int main() {

    //Sample XML String
    char xmlString[MAX_BUFFER_SIZE] = "<person name=\"John\"><age>28</age><occupation>Software Engineer</occupation></person>";

    //Parse the xml string
    XMLtag* rootTag = parseXML(xmlString);

    //Print the root tag
    printXMLtag(rootTag);

    return 0;
}

//Function to parse the XML string recursively and return root tag
XMLtag* parseXML(char* xmlString) {
    int length = strlen(xmlString);
    int i = 0;

    //Skip until the first opening tag
    while (xmlString[i] != '<' && i < length) {
        i++;
    }

    //Find the tag name
    char* tagName = (char*)malloc(MAX_BUFFER_SIZE);
    int j = i + 1;
    while (xmlString[j] != ' ' && xmlString[j] != '>' && j < length) {
        tagName[j - i - 1] = xmlString[j];
        j++;
    }
    tagName[j - i - 1] = '\0';

    //Find the attributes
    Attribute* attributeList = NULL;
    while (xmlString[j] != '>' && j < length) {
        char* attributeName = (char*)malloc(MAX_BUFFER_SIZE);
        char* attributeValue = (char*)malloc(MAX_BUFFER_SIZE);

        while (xmlString[j] != '=' && xmlString[j] != '>' && j < length) {
            j++;
        }

        if (xmlString[j] == '>') {
            break;
        }

        j++;

        //Extract the attribute name
        int k = 0;
        while (xmlString[j] != '=' && j < length) {
            attributeName[k++] = xmlString[j++];
        }
        attributeName[k] = '\0';

        j++;

        //Extract the attribute value
        k = 0;
        while (xmlString[j] != '\"' && j < length) {
            j++;
        }

        j++;
        while (xmlString[j] != '\"' && j < length) {
            attributeValue[k++] = xmlString[j++];
        }
        attributeValue[k] = '\0';

        Attribute* newAttribute = createAttribute(attributeName, attributeValue);
        if (attributeList == NULL) {
            attributeList = newAttribute;
        }
        else {
            Attribute* temp = attributeList;
            while (temp->next != NULL) {
                temp = temp->next;
            }
            temp->next = newAttribute;
        }
        j++;
    }

    j++;

    //Find the text
    char* text = (char*)malloc(MAX_BUFFER_SIZE);
    int k = 0;
    while (xmlString[j] != '<' && j < length) {
        text[k++] = xmlString[j++];
    }
    text[k] = '\0';

    //Find the child tags
    XMLtag* childList = NULL;
    int nestedTagCounter = 0;
    int start = j;
    int end = -1;

    while (j < length) {
        if (xmlString[j] == '<') {
            if (xmlString[j + 1] == '/') {
                //End tag
                if (nestedTagCounter == 0) {
                    end = j - 1;
                    break;
                }
                else {
                    nestedTagCounter--;
                    j++;
                }
            }
            else {
                //Start tag
                if (nestedTagCounter == 0) {
                    end = j - 1;

                    char* childXMLstring = (char*)malloc(MAX_BUFFER_SIZE);
                    strncpy(childXMLstring, &xmlString[start], end - start + 1);
                    childXMLstring[end - start + 1] = '\0';
                    XMLtag* childTag = parseXML(childXMLstring);

                    if (childList == NULL) {
                        childList = childTag;
                    }
                    else {
                        XMLtag* temp = childList;
                        while (temp->childList != NULL) {
                            temp = temp->childList;
                        }
                        temp->childList = childTag;
                    }
                    start = j;
                    nestedTagCounter++;
                }
                else {
                    nestedTagCounter++;
                }
                j++;
            }
        }
        else {
            j++;
        }
    }

    //Create the tag
    char* tagText = NULL;
    if (end != -1) {
        tagText = (char*)malloc(MAX_BUFFER_SIZE);
        strncpy(tagText, &xmlString[start], end - start + 1);
        tagText[end - start + 1] = '\0';
    }
    else {
        tagText = (char*)malloc(strlen(text) + 1);
        strcpy(tagText, text);
    }

    XMLtag* tag = createXMLtag(tagName, attributeList, tagText, childList);
    return tag;
}

//Function to create new XML tag
XMLtag* createXMLtag(char* tagName, Attribute* attributeList, char* text, XMLtag* childList) {
    XMLtag* tag = (XMLtag*)malloc(sizeof(XMLtag));
    tag->tagName = (char*)malloc(strlen(tagName) + 1);
    strcpy(tag->tagName, tagName);
    tag->attributeList = attributeList;
    tag->childList = childList;
    tag->text = (char*)malloc(strlen(text) + 1);
    strcpy(tag->text, text);
    return tag;
}

//Function to create new XML attribute
Attribute* createAttribute(char* attributeName, char* attributeValue) {
    Attribute* attribute = (Attribute*)malloc(sizeof(Attribute));
    attribute->name = (char*)malloc(strlen(attributeName) + 1);
    strcpy(attribute->name, attributeName);
    attribute->value = (char*)malloc(strlen(attributeValue) + 1);
    strcpy(attribute->value, attributeValue);
    attribute->next = NULL;
    return attribute;
}

//Function to print XML tag
void printXMLtag(XMLtag* tag) {
    printf("<%s ", tag->tagName);
    Attribute* tempAttr = tag->attributeList;
    while (tempAttr != NULL) {
        printAttribute(tempAttr);
        tempAttr = tempAttr->next;
    }
    printf(">");

    if (tag->childList == NULL) {
        printf("%s", tag->text);
    }
    else {
        printf("\n");
        XMLtag* tempTag = tag->childList;
        while (tempTag != NULL) {
            printXMLtag(tempTag);
            tempTag = tempTag->childList;
        }
        printf("\n");
    }

    printf("</%s>\n", tag->tagName);
}

//Function to print XML attribute
void printAttribute(Attribute* attr) {
    printf("%s=\"%s\" ", attr->name, attr->value);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall parseXML(_QWORD, _QWORD); // weak
__int64 __fastcall printXMLtag(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _WORD v4[44]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5; // [rsp+78h] [rbp-8h]
  _BYTE v6[936]; // [rsp+80h] [rbp+0h] BYREF
  __int64 v7; // [rsp+428h] [rbp+3A8h]

  _main(argc, argv, envp);
  strcpy((char *)v4, "<person name=\"John\"><age>28</age><occupation>Software Engineer</occupation></person>");
  HIBYTE(v4[42]) = 0;
  v4[43] = 0;
  v5 = 0i64;
  memset(v6, 0, 0x3A0ui64);
  v7 = parseXML(v4, v6);
  printXMLtag(v7);
  return 0;
}
// 140001687: using guessed type __int64 __fastcall parseXML(_QWORD, _QWORD);
// 140001D0F: using guessed type __int64 __fastcall printXMLtag(_QWORD);
// 140001EF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Auction System ; Style: introspective
/* 
   A Digital Auction System using C programming language. 
   This program is an example of what the backend architecture of an auction system can look like.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BIDDERS 100
#define MAX_ITEMS 50

// Struct for storing information about an item
typedef struct {
    char name[50];
    int starting_bid;
    int current_bid;
    char highest_bidder[50];
} Item;

// Struct for storing information about a user/bidder
typedef struct {
    char name[50];
    int balance;
    int num_bids_made;
} Bidder;

// Global variables
Item items[MAX_ITEMS];
Bidder bidders[MAX_BIDDERS];
int num_items = 0;
int num_bidders = 0;

// Function for adding a new item to the auction
void add_item() {
    if (num_items == MAX_ITEMS) {
        printf("Maximum number of items reached. No more can be added.\n");
        return;
    }
    
    Item new_item;
    printf("Enter the name of the item: ");
    fgets(new_item.name, 50, stdin);
    printf("Enter the starting bid: ");
    scanf("%d", &new_item.starting_bid);
    new_item.current_bid = new_item.starting_bid;
    strcpy(new_item.highest_bidder, "None");
    getchar(); // Consume the newline character left behind by scanf
    
    items[num_items] = new_item;
    num_items++;
    printf("Item successfully added to the auction.\n");
}

// Function for displaying all items currently in the auction
void view_items() {
    printf("%-25s %-15s %-15s\n", "ITEM", "CURRENT BID", "HIGHEST BIDDER");
    for (int i = 0; i < num_items; i++) {
        printf("%-25s %-15d %-15s\n", items[i].name, items[i].current_bid, items[i].highest_bidder);
    }
}

// Function for adding a new bidder to the auction
void add_bidder() {
    if (num_bidders == MAX_BIDDERS) {
        printf("Maximum number of bidders reached. No more can be added.\n");
        return;
    }
    
    Bidder new_bidder;
    printf("Enter the name of the bidder: ");
    fgets(new_bidder.name, 50, stdin);
    printf("Enter the starting balance: ");
    scanf("%d", &new_bidder.balance);
    getchar(); // Consume the newline character left behind by scanf
    
    bidders[num_bidders] = new_bidder;
    num_bidders++;
    printf("Bidder successfully added to the auction.\n");
}

// Function for displaying all bidders currently in the auction
void view_bidders() {
    printf("%-25s %-15s %-15s\n", "BIDDER", "BALANCE", "BIDS MADE");
    for (int i = 0; i < num_bidders; i++) {
        printf("%-25s %-15d %-15d\n", bidders[i].name, bidders[i].balance, bidders[i].num_bids_made);
    }
}

// Function for a bidder to place a bid on an item
void place_bid() {
    if (num_items == 0) {
        printf("No items currently in the auction.\n");
        return;
    }
    
    char item_name[50];
    printf("Enter the name of the item: ");
    fgets(item_name, 50, stdin);
    int item_index = -1;
    for (int i = 0; i < num_items; i++) {
        if (strcmp(item_name, items[i].name) == 0) {
            item_index = i;
            break;
        }
    }
    if (item_index == -1) {
        printf("Item not found.\n");
        return;
    }
    
    int bidder_index = -1;
    char bidder_name[50];
    printf("Enter your name: ");
    fgets(bidder_name, 50, stdin);
    for (int i = 0; i < num_bidders; i++) {
        if (strcmp(bidder_name, bidders[i].name) == 0) {
            bidder_index = i;
            break;
        }
    }
    if (bidder_index == -1) {
        printf("Bidder not found.\n");
        return;
    }
    
    if (items[item_index].current_bid >= bidders[bidder_index].balance) {
        printf("You do not have enough balance to place a bid.\n");
        return;
    }
    
    int new_bid;
    printf("Enter your bid: ");
    scanf("%d", &new_bid);
    getchar(); // Consume the newline character left behind by scanf
    
    if (new_bid <= items[item_index].current_bid) {
        printf("Your bid must be higher than the current bid.\n");
        return;
    }
    
    items[item_index].current_bid = new_bid;
    strcpy(items[item_index].highest_bidder, bidder_name);
    bidders[bidder_index].balance -= new_bid;
    bidders[bidder_index].num_bids_made++;
    
    printf("Bid successfully placed.\n");
}

int main() {
    int choice;
    
    do {
        printf("\n-- DIGITAL AUCTION SYSTEM --\n");
        printf("1. Add item to the auction\n");
        printf("2. View all items in the auction\n");
        printf("3. Add bidder to the auction\n");
        printf("4. View all bidders in the auction\n");
        printf("5. Place a bid on an item\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        getchar(); // Consume the newline character left behind by scanf
        
        switch (choice) {
            case 1:
                add_item();
                break;
            case 2:
                view_items();
                break;
            case 3:
                add_bidder();
                break;
            case 4:
                view_bidders();
                break;
            case 5:
                place_bid();
                break;
            case 6:
                printf("Exiting the program.\n");
                break;
            default:
                printf("Invalid choice. Please try again.\n");
        }
    } while (choice != 6);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_item(void); // weak
__int64 view_items(void); // weak
__int64 add_bidder(void); // weak
__int64 view_bidders(void); // weak
__int64 place_bid(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();


//----- (0000000140001D4B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("\n-- DIGITAL AUCTION SYSTEM --\n");
    printf("1. Add item to the auction\n");
    printf("2. View all items in the auction\n");
    printf("3. Add bidder to the auction\n");
    printf("4. View all bidders in the auction\n");
    printf("5. Place a bid on an item\n");
    printf("6. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    getchar();
    switch ( v4 )
    {
      case 1:
        add_item();
        break;
      case 2:
        view_items();
        break;
      case 3:
        add_bidder();
        break;
      case 4:
        view_bidders();
        break;
      case 5:
        place_bid();
        break;
      case 6:
        printf("Exiting the program.\n");
        break;
      default:
        printf("Invalid choice. Please try again.\n");
        break;
    }
  }
  while ( v4 != 6 );
  return 0;
}
// 1400015E2: using guessed type __int64 add_item(void);
// 140001753: using guessed type __int64 view_items(void);
// 140001826: using guessed type __int64 add_bidder(void);
// 14000193E: using guessed type __int64 view_bidders(void);
// 140001A0A: using guessed type __int64 place_bid(void);
// 140001F20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>

// Define the maximum number of circuits and circuit elements allowed
#define MAX_NUM_CIRCUITS 10
#define MAX_NUM_ELEMENTS 100

// Define the circuit element struct
typedef struct CircuitElement {
    int fromNode;
    int toNode;
    float resistance;
    float capacitance;
    float inductance;
} CircuitElement;

// Define the circuit struct
typedef struct Circuit {
    int numElements;
    CircuitElement elements[MAX_NUM_ELEMENTS];
} Circuit;

int main() {
    Circuit circuits[MAX_NUM_CIRCUITS];
    int numCircuits = 0;

    // Take input for the circuit
    printf("Enter the number of circuits you want to simulate: ");
    scanf("%d", &numCircuits);

    // Take input for each circuit's element values
    for (int i = 0; i < numCircuits; i++) {
        printf("Enter the number of elements for circuit %d: ", i+1);
        scanf("%d", &circuits[i].numElements);

        for (int j = 0; j < circuits[i].numElements; j++) {
            printf("Enter values for element %d\n", j+1);

            printf("From node: ");
            scanf("%d", &circuits[i].elements[j].fromNode);

            printf("To node: ");
            scanf("%d", &circuits[i].elements[j].toNode);

            printf("Resistance: ");
            scanf("%f", &circuits[i].elements[j].resistance);

            printf("Capacitance: ");
            scanf("%f", &circuits[i].elements[j].capacitance);

            printf("Inductance: ");
            scanf("%f", &circuits[i].elements[j].inductance);
        }

        printf("Circuit %d input ended.\n", i+1);
    }

    // Print the circuit information
    for (int i = 0; i < numCircuits; i++) {
        printf("Circuit %d:\n", i+1);

        for (int j = 0; j < circuits[i].numElements; j++) {
            printf("Element %d: From Node=%d To Node=%d Resistance=%f Capacitance=%f Inductance=%f\n", 
                j+1, circuits[i].elements[j].fromNode, circuits[i].elements[j].toNode,
                circuits[i].elements[j].resistance, circuits[i].elements[j].capacitance, circuits[i].elements[j].inductance);
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[13]; // [rsp+4Ch] [rbp-34h] BYREF
  _BYTE v5[20000]; // [rsp+80h] [rbp+0h] BYREF
  int m; // [rsp+4EA0h] [rbp+4E20h]
  int k; // [rsp+4EA4h] [rbp+4E24h]
  int j; // [rsp+4EA8h] [rbp+4E28h]
  int i; // [rsp+4EACh] [rbp+4E2Ch]

  _main(argc, argv, envp);
  v4[0] = 0;
  printf("Enter the number of circuits you want to simulate: ");
  scanf("%d", v4);
  for ( i = 0; i < v4[0]; ++i )
  {
    printf("Enter the number of elements for circuit %d: ", (unsigned int)(i + 1));
    scanf("%d", &v4[501 * i + 1]);
    for ( j = 0; j < *(_DWORD *)&v5[2004 * i - 48]; ++j )
    {
      printf("Enter values for element %d\n", (unsigned int)(j + 1));
      printf("From node: ");
      scanf("%d", &v4[501 * i + 2 + 5 * j]);
      printf("To node: ");
      scanf("%d", &v4[501 * i + 3 + 5 * j]);
      printf("Resistance: ");
      scanf("%f", &v4[501 * i + 4 + 5 * j]);
      printf("Capacitance: ");
      scanf("%f", &v4[501 * i + 5 + 5 * j]);
      printf("Inductance: ");
      scanf("%f", &v4[501 * i + 6 + 5 * j]);
    }
    printf("Circuit %d input ended.\n", (unsigned int)(i + 1));
  }
  for ( k = 0; k < v4[0]; ++k )
  {
    printf("Circuit %d:\n", (unsigned int)(k + 1));
    for ( m = 0; m < *(_DWORD *)&v5[2004 * k - 48]; ++m )
      printf(
        "Element %d: From Node=%d To Node=%d Resistance=%f Capacitance=%f Inductance=%f\n",
        (unsigned int)(m + 1),
        *(unsigned int *)&v5[2004 * k - 44 + 20 * m],
        *(unsigned int *)&v5[2004 * k - 40 + 20 * m],
        *(float *)&v5[2004 * k - 36 + 20 * m],
        *(float *)&v5[2004 * k - 32 + 20 * m],
        *(float *)&v5[2004 * k - 28 + 20 * m]);
  }
  return 0;
}
// 140001B80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Product Inventory System ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PRODUCTS 50

typedef struct product {
    int id;
    char name[50];
    float price;
    int quantity;
} Product;

void add_product(Product products[], int *count) {
    Product p;
    printf("\nEnter ID: ");
    scanf("%d", &p.id);
    getchar();
    printf("Enter Name: ");
    fgets(p.name, 50, stdin);
    printf("Enter Price: ");
    scanf("%f", &p.price);
    printf("Enter Quantity: ");
    scanf("%d", &p.quantity);
    products[*count] = p;
    *count += 1;
}

void view_products(Product products[], int count) {
    printf("\n----- Products -----\n");
    printf("| ID | Name                     | Price | Quantity |\n");
    for(int i = 0; i < count; i++) {
        printf("| %-2d | %-23s | %.2f | %-2d |\n", products[i].id, products[i].name, products[i].price, products[i].quantity);
    }
    printf("----------------------\n");
}

int find_product(Product products[], int count, int id) {
    for(int i = 0; i < count; i++) {
        if(products[i].id == id) {
            return i;
        }
    }
    return -1;
}

void update_product(Product products[], int count) {
    int id, index;
    printf("\nEnter ID to update: ");
    scanf("%d", &id);
    getchar();
    index = find_product(products, count, id);
    if(index == -1) {
        printf("Product not found!\n");
        return;
    }
    Product p;
    printf("Enter Name: ");
    fgets(p.name, 50, stdin);
    printf("Enter Price: ");
    scanf("%f", &p.price);
    printf("Enter Quantity: ");
    scanf("%d", &p.quantity);
    products[index] = p;
}

void delete_product(Product products[], int *count) {
    int id, index;
    printf("\nEnter ID to delete: ");
    scanf("%d", &id);
    index = find_product(products, *count, id);
    if(index == -1) {
        printf("Product not found!\n");
        return;
    }
    for(int i = index; i < *count - 1; i++) {
        products[i] = products[i + 1];
    }
    *count -= 1;
}

void print_menu() {
    printf("\n===== Product Inventory System =====\n");
    printf("1. Add Product\n");
    printf("2. View Products\n");
    printf("3. Update Product\n");
    printf("4. Delete Product\n");
    printf("5. Exit\n");
}

int main() {
    int choice, count = 0;
    Product products[MAX_PRODUCTS];
    while(1) {
        print_menu();
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch(choice) {
            case 1: add_product(products, &count);
                    break;
            case 2: view_products(products, count);
                    break;
            case 3: update_product(products, count);
                    break;
            case 4: delete_product(products, &count);
                    break;
            case 5: exit(0);
            default: printf("Invalid Choice!\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_product(_QWORD, _QWORD); // weak
__int64 __fastcall view_products(_QWORD, _QWORD); // weak
__int64 __fastcall update_product(_QWORD, _QWORD); // weak
__int64 __fastcall delete_product(_QWORD, _QWORD); // weak
__int64 print_menu(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001B0A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[3208]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v5; // [rsp+CA8h] [rbp+C28h] BYREF
  int v6; // [rsp+CACh] [rbp+C2Ch] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  while ( 1 )
  {
    print_menu();
    printf("Enter your choice: ");
    scanf("%d", &v6);
    switch ( v6 )
    {
      case 1:
        add_product(v4, &v5);
        break;
      case 2:
        view_products(v4, v5);
        break;
      case 3:
        update_product(v4, v5);
        break;
      case 4:
        delete_product(v4, &v5);
        break;
      case 5:
        exit(0);
      default:
        printf("Invalid Choice!\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 __fastcall add_product(_QWORD, _QWORD);
// 140001715: using guessed type __int64 __fastcall view_products(_QWORD, _QWORD);
// 14000184D: using guessed type __int64 __fastcall update_product(_QWORD, _QWORD);
// 14000199D: using guessed type __int64 __fastcall delete_product(_QWORD, _QWORD);
// 140001AA1: using guessed type __int64 print_menu(void);
// 140001CB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

enum {
  LOWER = 0,
  UPPER = 100,
  KEY = LOWER-1 // some value that is not in the valid range
};

char dummy;
// A pointer to represent the integer 0, and the basis of our integer-as-pointer
// representation. We can't use the null pointer because bsearch() returns that
// for not found.
#define ZERO ((void *)&dummy)

int get_value(int x) {
  if (x == KEY)
    return 0;
  printf("My guess is: %d. Is it too high, too low, or correct? (H/L/C) ", x);
  char input[2] = " ";
  scanf("%1s", input);
  switch (tolower(input[0])) {
    case 'l':
      return -1;
    case 'h':
      return 1;
    case 'c':
      return 0;
  }
  fprintf(stderr, "Invalid input\n");
  exit(1);
  return 0;
}

int my_cmp(const void *x, const void *y) {
  return get_value(x - ZERO) - get_value(y - ZERO);
}

int main() {
  printf("Instructions:\n"
	 "Think of integer number from %d (inclusive) to %d (exclusive) and\n"
	 "I will guess it. After each guess, you respond with L, H, or C depending\n"
	 "on if my guess was too low, too high, or correct.\n",
	 LOWER, UPPER);
  void *result = bsearch(ZERO + KEY, ZERO + LOWER, UPPER-LOWER, 1, my_cmp);
  if (result == NULL)
    fprintf(stderr, "That is impossible.\n");
  else
    printf("Your number is %d.\n", (int)(result - ZERO));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bec(void);
int64_t function_100003cf0(void);
int64_t * function_100003e14(int64_t * key, int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
void function_100003e20(int32_t status);
int32_t function_100003e2c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003e38(char * format, ...);
int32_t function_100003e44(char * format, ...);
int32_t function_100003e50(int32_t c);

// --------------------- Global Variables ---------------------

int64_t g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t * _bsearch(int64_t * a1, int64_t * a2, int32_t a3, int32_t a4, int32_t (*a5)(int64_t *, int64_t *));
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bec - 0x100003cf0
int64_t function_100003bec(void) {
    int64_t result = 0; // 0x100003c08
    int64_t v1; // 0x100003bec
    if ((int32_t)v1 == -1) {
        // 0x100003ce0
        return result;
    }
    // 0x100003c18
    _printf("My guess is: %d. Is it too high, too low, or correct? (H/L/C) ", v1);
    _scanf("%1s", (char **)v1);
    result = 0xffffffff;
    switch (_tolower(32)) {
        case 99: {
            // 0x100003cb8
            result = 0;
        }
        case 108: {
            // 0x100003ce0
            return result;
        }
        case 104: {
            // 0x100003cac
            result = 1;
            return result;
        }
        default: {
            // 0x100003cc0
            _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000, "Invalid input\n");
            _exit(1);
            // UNREACHABLE
        }
    }
}

// Address range: 0x100003cf0 - 0x100003d50
int64_t function_100003cf0(void) {
    int64_t v1 = function_100003bec(); // 0x100003d1c
    return v1 - function_100003bec() & 0xffffffff;
}

// Address range: 0x100003d50 - 0x100003e14
int64_t entry_point(void) {
    // 0x100003d50
    int64_t v1; // 0x100003d50
    _printf("Instructions:\nThink of integer number from %d (inclusive) to %d (exclusive) and\nI will guess it. After each guess, you respond with L, H, or C depending\non if my guess was too low, too high, or correct.\n", v1, v1);
    int64_t * v2 = _bsearch((int64_t *)((int64_t)&g1 - 1), &g1, 100, 1, (int32_t (*)(int64_t *, int64_t *))0x100003cf0); // 0x100003da8
    if (v2 == NULL) {
        // 0x100003dc4
        _fprintf((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000, "That is impossible.\n");
    } else {
        // 0x100003de0
        _printf("Your number is %d.\n", (int64_t)&g1);
    }
    // 0x100003e04
    return 0;
}

// Address range: 0x100003e14 - 0x100003e20
int64_t * function_100003e14(int64_t * key, int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003e14
    return _bsearch(key, base, nmemb, size, compar);
}

// Address range: 0x100003e20 - 0x100003e2c
void function_100003e20(int32_t status) {
    // 0x100003e20
    _exit(status);
}

// Address range: 0x100003e2c - 0x100003e38
int32_t function_100003e2c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003e2c
    return _fprintf(stream, format);
}

// Address range: 0x100003e38 - 0x100003e44
int32_t function_100003e38(char * format, ...) {
    // 0x100003e38
    return _printf(format);
}

// Address range: 0x100003e44 - 0x100003e50
int32_t function_100003e44(char * format, ...) {
    // 0x100003e44
    return _scanf(format);
}

// Address range: 0x100003e50 - 0x100003e5c
int32_t function_100003e50(int32_t c) {
    // 0x100003e50
    return _tolower(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`//FormAI DATASET v1.0 Category: Checkers Game ; Style: standalone
#include <stdio.h>

int main() {
    //initialize board
    int board[8][8] = {
        {0, 2, 0, 2, 0, 2, 0, 2},
        {2, 0, 2, 0, 2, 0, 2, 0},
        {0, 2, 0, 2, 0, 2, 0, 2},
        {1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1},
        {3, 0, 3, 0, 3, 0, 3, 0},
        {0, 3, 0, 3, 0, 3, 0, 3},
        {3, 0, 3, 0, 3, 0, 3, 0}
    };
    
    //initialize players
    int player1 = 1; //1 for red, 2 for black
    int player2 = 2;
    
    //initialize turn
    int turn = player1;
    
    //initialize game loop
    int gameover = 0;
    
    while (!gameover) {
        //print board
        printf("    0 1 2 3 4 5 6 7\n");
        for (int i = 0; i < 8; i++) {
            printf("%d  ", i);
            for (int j = 0; j < 8; j++) {
                printf("%d ", board[i][j]);
            }
            printf("\n");
        }
        
        //get input
        int startx, starty, endx, endy;
        printf("Player %d, enter starting coordinates (x y): ", turn);
        scanf("%d %d", &startx, &starty);
        printf("Player %d, enter ending coordinates (x y): ", turn);
        scanf("%d %d", &endx, &endy);
        
        //validate input
        if (startx < 0 || startx > 7 || starty < 0 || starty > 7 ||
            endx < 0 || endx > 7 || endy < 0 || endy > 7) {
            printf("Invalid coordinates. Try again.\n");
            continue;
        }
        if (board[startx][starty] != turn && board[startx][starty] != turn+1) {
            printf("You don't have a piece there. Try again.\n");
            continue;
        }
        if (board[endx][endy] != 0) {
            printf("There's already a piece there. Try again.\n");
            continue;
        }
        if (abs(endx-startx) != 1 || abs(endy-starty) != 1) {
            printf("You can only move one space diagonally. Try again.\n");
            continue;
        }
        
        //make move
        board[endx][endy] = board[startx][starty];
        board[startx][starty] = 0;
        
        //check for gameover
        int redpieces = 0;
        int blackpieces = 0;
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (board[i][j] == 1 || board[i][j] == 3) {
                    redpieces++;
                } else if (board[i][j] == 2 || board[i][j] == 4) {
                    blackpieces++;
                }
            }
        }
        
        if (redpieces == 0 || blackpieces == 0) {
            gameover = 1;
            printf("Player %d wins!\n", turn);
        }
        
        //switch turn
        if (turn == player1) {
            turn = player2;
        } else {
            turn = player1;
        }
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v6; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v7; // [rsp+24h] [rbp-5Ch] BYREF
  unsigned int v8; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v9; // [rsp+2Ch] [rbp-54h] BYREF
  int v10[66]; // [rsp+30h] [rbp-50h]
  unsigned int v11; // [rsp+138h] [rbp+B8h]
  unsigned int v12; // [rsp+13Ch] [rbp+BCh]
  int m; // [rsp+140h] [rbp+C0h]
  int k; // [rsp+144h] [rbp+C4h]
  int v15; // [rsp+148h] [rbp+C8h]
  int v16; // [rsp+14Ch] [rbp+CCh]
  int j; // [rsp+150h] [rbp+D0h]
  unsigned int i; // [rsp+154h] [rbp+D4h]
  int v19; // [rsp+158h] [rbp+D8h]
  unsigned int v20; // [rsp+15Ch] [rbp+DCh]

  _main(argc, argv, envp);
  v10[0] = 0;
  v10[1] = 2;
  v10[2] = 0;
  v10[3] = 2;
  v10[4] = 0;
  v10[5] = 2;
  v10[6] = 0;
  v10[7] = 2;
  v10[8] = 2;
  v10[9] = 0;
  v10[10] = 2;
  v10[11] = 0;
  v10[12] = 2;
  v10[13] = 0;
  v10[14] = 2;
  v10[15] = 0;
  v10[16] = 0;
  v10[17] = 2;
  v10[18] = 0;
  v10[19] = 2;
  v10[20] = 0;
  v10[21] = 2;
  v10[22] = 0;
  v10[23] = 2;
  v10[24] = 1;
  v10[25] = 0;
  v10[26] = 1;
  v10[27] = 0;
  v10[28] = 1;
  v10[29] = 0;
  v10[30] = 1;
  v10[31] = 0;
  v10[32] = 0;
  v10[33] = 1;
  v10[34] = 0;
  v10[35] = 1;
  v10[36] = 0;
  v10[37] = 1;
  v10[38] = 0;
  v10[39] = 1;
  v10[40] = 3;
  v10[41] = 0;
  v10[42] = 3;
  v10[43] = 0;
  v10[44] = 3;
  v10[45] = 0;
  v10[46] = 3;
  v10[47] = 0;
  v10[48] = 0;
  v10[49] = 3;
  v10[50] = 0;
  v10[51] = 3;
  v10[52] = 0;
  v10[53] = 3;
  v10[54] = 0;
  v10[55] = 3;
  v10[56] = 3;
  v10[57] = 0;
  v10[58] = 3;
  v10[59] = 0;
  v10[60] = 3;
  v10[61] = 0;
  v10[62] = 3;
  v10[63] = 0;
  v12 = 1;
  v11 = 2;
  v20 = 1;
  v19 = 0;
  while ( !v19 )
  {
    printf("    0 1 2 3 4 5 6 7\n");
    for ( i = 0; (int)i <= 7; ++i )
    {
      printf("%d  ", i);
      for ( j = 0; j <= 7; ++j )
        printf("%d ", (unsigned int)v10[8 * i + j]);
      printf("\n");
    }
    printf("Player %d, enter starting coordinates (x y): ", v20);
    scanf("%d %d", &v9, &v8);
    printf("Player %d, enter ending coordinates (x y): ", v20);
    scanf("%d %d", &v7, &v6);
    if ( v9 <= 7 && v8 <= 7 && v7 <= 7 && v6 < 8 )
    {
      if ( v20 == v10[8 * v9 + v8] || v10[8 * v9 + v8] == v20 + 1 )
      {
        if ( v10[8 * v7 + v6] )
        {
          printf("There's already a piece there. Try again.\n");
        }
        else
        {
          v3 = v7 - v9;
          if ( (int)(v9 - v7) >= 0 )
            v3 = v9 - v7;
          if ( v3 != 1 )
            goto LABEL_24;
          v4 = v6 - v8;
          if ( (int)(v8 - v6) >= 0 )
            v4 = v8 - v6;
          if ( v4 == 1 )
          {
            v10[8 * v7 + v6] = v10[8 * v9 + v8];
            v10[8 * v9 + v8] = 0;
            v16 = 0;
            v15 = 0;
            for ( k = 0; k <= 7; ++k )
            {
              for ( m = 0; m <= 7; ++m )
              {
                if ( v10[8 * k + m] == 1 || v10[8 * k + m] == 3 )
                {
                  ++v16;
                }
                else if ( v10[8 * k + m] == 2 || v10[8 * k + m] == 4 )
                {
                  ++v15;
                }
              }
            }
            if ( !v16 || !v15 )
            {
              v19 = 1;
              printf("Player %d wins!\n", v20);
            }
            if ( v20 == v12 )
              v20 = v11;
            else
              v20 = v12;
          }
          else
          {
LABEL_24:
            printf("You can only move one space diagonally. Try again.\n");
          }
        }
      }
      else
      {
        printf("You don't have a piece there. Try again.\n");
      }
    }
    else
    {
      printf("Invalid coordinates. Try again.\n");
    }
  }
  return 0;
}
// 140001C80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include<math.h>
#include<stdio.h>

int
main ()
{
  double inputs[11], check = 400, result;
  int i;

  printf ("\nPlease enter 11 numbers :");

  for (i = 0; i < 11; i++)
    {
      scanf ("%lf", &inputs[i]);
    }

  printf ("\n\n\nEvaluating f(x) = |x|^0.5 + 5x^3 for the given inputs :");

  for (i = 10; i >= 0; i--)
    {
      result = sqrt (fabs (inputs[i])) + 5 * pow (inputs[i], 3);

      printf ("\nf(%lf) = ");

      if (result > check)
        {
          printf ("Overflow!");
        }

      else
        {
          printf ("%lf", result);
        }
    }

  return 0;
}
`,`#include "trabb-pardo-knuth-algorithm.h"



undefined8 entry(void)

{
  int iVar1;
  double dVar2;
  undefined8 uVar3;
  int local_8c;
  double adStack_70 [11];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _printf("\nPlease enter 11 numbers :");
  for (local_8c = 0; local_8c < 0xb; local_8c = local_8c + 1) {
    _scanf("%lf");
  }
  iVar1 = _printf("\n\n\nEvaluating f(x) = |x|^0.5 + 5x^3 for the given inputs :");
  for (local_8c = 10; -1 < local_8c; local_8c = local_8c + -1) {
    dVar2 = adStack_70[local_8c];
    uVar3 = _pow(adStack_70[local_8c],0x4008000000000000);
    dVar2 = (double)NEON_fmadd(0x4014000000000000,uVar3,SQRT(ABS(dVar2)));
    _printf("\nf(%lf) = ");
    if (dVar2 <= 400.0) {
      iVar1 = _printf("%lf");
    }
    else {
      iVar1 = _printf("Overflow!");
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <math.h>
#include <stdint.h>
#include <stdio.h>

static uint64_t state;
static const uint64_t STATE_MAGIC = 0x2545F4914F6CDD1D;

void seed(uint64_t num) {
    state = num;
}

uint32_t next_int() {
    uint64_t x;
    uint32_t answer;

    x = state;
    x = x ^ (x >> 12);
    x = x ^ (x << 25);
    x = x ^ (x >> 27);
    state = x;
    answer = ((x * STATE_MAGIC) >> 32);

    return answer;
}

float next_float() {
    return (float)next_int() / (1LL << 32);
}

int main() {
    int counts[5] = { 0, 0, 0, 0, 0 };
    int i;

    seed(1234567);
    printf("%u\n", next_int());
    printf("%u\n", next_int());
    printf("%u\n", next_int());
    printf("%u\n", next_int());
    printf("%u\n", next_int());
    printf("\n");

    seed(987654321);
    for (i = 0; i < 100000; i++) {
        int j = (int)floor(next_float() * 5.0);
        counts[j]++;
    }
    for (i = 0; i < 5; i++) {
        printf("%d: %d\n", i, counts[i]);
    }

    return 0;
}
`,`#include "pseudo-random-numbers-xorshift-star.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _seed(undefined8 param_1)

{
  _DAT_100008000 = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 _next_int(void)

{
  _DAT_100008000 = _DAT_100008000 ^ _DAT_100008000 >> 0xc;
  _DAT_100008000 = _DAT_100008000 ^ _DAT_100008000 << 0x19;
  _DAT_100008000 = _DAT_100008000 ^ _DAT_100008000 >> 0x1b;
  return (int)(_DAT_100008000 * 0x2545f4914f6cdd1d >> 0x20);
}



float _next_float(void)

{
  uint uVar1;
  
  uVar1 = _next_int();
  return (float)uVar1 / 4.2949673e+09;
}



undefined8 entry(void)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  float extraout_s0;
  int local_38;
  int local_30 [6];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_30[0] = 0;
  local_30[1] = 0;
  local_30[2] = 0;
  local_30[3] = 0;
  local_30[4] = 0;
  _seed(0x12d687);
  _next_int();
  iVar1 = _printf("%u\n");
  _next_int(iVar1);
  iVar1 = _printf("%u\n");
  _next_int(iVar1);
  iVar1 = _printf("%u\n");
  _next_int(iVar1);
  iVar1 = _printf("%u\n");
  _next_int(iVar1);
  _printf("%u\n");
  _printf("\n");
  uVar3 = _seed(0x3ade68b1);
  for (local_38 = 0; local_38 < 100000; local_38 = local_38 + 1) {
    uVar3 = _next_float();
    local_30[(int)(extraout_s0 * 5.0)] = local_30[(int)(extraout_s0 * 5.0)] + 1;
  }
  for (local_38 = 0; local_38 < 5; local_38 = local_38 + 1) {
    uVar2 = _printf("%d: %d\n");
    uVar3 = (ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar3);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

// returns count of non-overlapping occurrences of 'sub' in 'str'
int countSubstring(const char *str, const char *sub)
{
    int length = strlen(sub);
    if (length == 0) return 0;
    int count = 0;
    for (str = strstr(str, sub); str; str = strstr(str + length, sub))
        ++count;
    return count;
}

int main()
{
    printf("%d\n", countSubstring("the three truths", "th"));
    printf("%d\n", countSubstring("ababababab", "abab"));
    printf("%d\n", countSubstring("abaabba*bbaba*bbab", "a*b"));

    return 0;
}
`,`#include "count-occurrences-of-a-substring-2.h"



int _countSubstring(char *param_1,char *param_2)

{
  size_t sVar1;
  int local_30;
  char *local_20;
  int local_14;
  
  sVar1 = _strlen(param_2);
  if ((int)sVar1 == 0) {
    local_14 = 0;
  }
  else {
    local_30 = 0;
    for (local_20 = _strstr(param_1,param_2); local_20 != (char *)0x0;
        local_20 = _strstr(local_20 + (int)sVar1,param_2)) {
      local_30 = local_30 + 1;
    }
    local_14 = local_30;
  }
  return local_14;
}



undefined4 entry(void)

{
  _countSubstring("the three truths","th");
  _printf("%d\n");
  _countSubstring("ababababab","abab");
  _printf("%d\n");
  _countSubstring("abaabba*bbaba*bbab","a*b");
  _printf("%d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004008)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strstr(char *param_1,char *param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strstr_100004010)();
  return pcVar1;
}


`
`//FormAI DATASET v1.0 Category: File handling ; Style: excited
#include <stdio.h>

int main() {
    printf("Hello, everyone! Are you ready to learn about file handling in C?? Let's get started!\n\n");

    FILE *file_pointer;
    char file_name[100];
    printf("First, let's create a new file. What should we call it?\n");
    scanf("%s", file_name);

    file_pointer = fopen(file_name, "w");
    if (file_pointer == NULL) {
        printf("Uh oh, there was an error creating the file. Our program will now exit.\n");
        return 1;
    }
    printf("Great! We successfully created the file %s.\n\n", file_name);

    printf("Now let's write something to the file. What would you like to say?\n");
    char message[100];
    scanf(" %[^\n]s", message);
    fprintf(file_pointer, "%s", message);

    printf("Awesome! We wrote the message \"%s\" to the file %s.\n\n", message, file_name);

    printf("Next, let's read the contents of the file. Here's what's in %s:\n", file_name);
    fclose(file_pointer);
    file_pointer = fopen(file_name, "r");
    if (file_pointer == NULL) {
        printf("Uh oh, there was an error opening the file. Our program will now exit.\n");
        return 1;
    }
    char character;
    while ((character = getc(file_pointer)) != EOF) {
        printf("%c", character);
    }
    printf("\n\nWow, that was awesome! We successfully read the contents of the file %s.\n\n", file_name);

    printf("Finally, let's delete the file. Are you sure you want to delete %s? (y/n)\n", file_name);
    char response;
    scanf(" %c", &response);
    if (response == 'y') {
        remove(file_name);
        printf("The file %s has been deleted. Thanks for using our program!\n\n", file_name);
    } else {
        printf("Great! The file %s has not been deleted. Thanks for using our program!\n\n", file_name);
    }

    fclose(file_pointer);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl remove(const char *FileName);
// int __cdecl getc(FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Fh] [rbp-51h] BYREF
  char v5[112]; // [rsp+30h] [rbp-50h] BYREF
  char FileName[103]; // [rsp+A0h] [rbp+20h] BYREF
  char v7; // [rsp+107h] [rbp+87h]
  FILE *Stream; // [rsp+108h] [rbp+88h]

  _main(argc, argv, envp);
  printf("Hello, everyone! Are you ready to learn about file handling in C?? Let's get started!\n\n");
  printf("First, let's create a new file. What should we call it?\n");
  scanf("%s", FileName);
  Stream = fopen(FileName, "w");
  if ( Stream )
  {
    printf("Great! We successfully created the file %s.\n\n", FileName);
    printf("Now let's write something to the file. What would you like to say?\n");
    scanf(" %[^\n]s", v5);
    fprintf_0(Stream, "%s", v5);
    printf("Awesome! We wrote the message \"%s\" to the file %s.\n\n", v5, FileName);
    printf("Next, let's read the contents of the file. Here's what's in %s:\n", FileName);
    fclose(Stream);
    Stream = fopen(FileName, "r");
    if ( Stream )
    {
      while ( 1 )
      {
        v7 = getc(Stream);
        if ( v7 == -1 )
          break;
        printf("%c", (unsigned int)v7);
      }
      printf("\n\nWow, that was awesome! We successfully read the contents of the file %s.\n\n", FileName);
      printf("Finally, let's delete the file. Are you sure you want to delete %s? (y/n)\n", FileName);
      scanf(" %c", &v4);
      if ( v4 == 121 )
      {
        remove(FileName);
        printf("The file %s has been deleted. Thanks for using our program!\n\n", FileName);
      }
      else
      {
        printf("Great! The file %s has not been deleted. Thanks for using our program!\n\n", FileName);
      }
      fclose(Stream);
      return 0;
    }
    else
    {
      printf("Uh oh, there was an error opening the file. Our program will now exit.\n");
      return 1;
    }
  }
  else
  {
    printf("Uh oh, there was an error creating the file. Our program will now exit.\n");
    return 1;
  }
}
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: brave
#include <stdio.h>
#include <stdlib.h>

#define KB 1024
#define MB (KB * 1024)

int main() {
    char *ptr1, *ptr2, *ptr3;

    // Allocate 1 MB of memory
    ptr1 = (char*) malloc(MB);
    if (ptr1 != NULL) {
        printf("1 MB of memory has been allocated at address: %p\n", ptr1);
    } else {
        printf("Error: Failed to allocate memory\n");
        exit(1);
    }

    // Allocate 512 KB of memory
    ptr2 = (char*) malloc(512 * KB);
    if (ptr2 != NULL) {
        printf("512 KB of memory has been allocated at address: %p\n", ptr2);
    } else {
        printf("Error: Failed to allocate memory\n");
        exit(1);
    }

    // Allocate 256 KB of memory
    ptr3 = (char*) malloc(256 * KB);
    if (ptr3 != NULL) {
        printf("256 KB of memory has been allocated at address: %p\n", ptr3);
    } else {
        printf("Error: Failed to allocate memory\n");
        exit(1);
    }

    // Free allocated memory
    free(ptr1);
    free(ptr2);
    free(ptr3);

    // Allocate 2 MB of memory using calloc
    ptr1 = (char*) calloc(2, MB);
    if (ptr1 != NULL) {
        printf("2 MB of memory has been allocated using calloc at address: %p\n", ptr1);
    } else {
        printf("Error: Failed to allocate memory\n");
        exit(1);
    }

    // Reallocate memory
    ptr1 = (char*) realloc(ptr1, 3 * MB);
    if (ptr1 != NULL) {
        printf("Memory reallocated to 3 MB at address: %p\n", ptr1);
    } else {
        printf("Error: Failed to reallocate memory\n");
        exit(1);
    }

    // Free allocated memory
    free(ptr1);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void __cdecl __noreturn exit(int Code);
// void *__cdecl calloc(size_t Count, size_t Size);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rax
  void *v4; // rax
  void *v5; // rax
  void *v7; // [rsp+28h] [rbp-18h]
  void *v8; // [rsp+30h] [rbp-10h]
  void *Block; // [rsp+38h] [rbp-8h]
  void *Blocka; // [rsp+38h] [rbp-8h]
  void *Blockb; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  Block = malloc(0x100000ui64);
  if ( !Block )
  {
    printf("Error: Failed to allocate memory\n");
    exit(1);
  }
  printf("1 MB of memory has been allocated at address: %p\n", Block);
  v8 = malloc(0x80000ui64);
  if ( !v8 )
  {
    printf("Error: Failed to allocate memory\n");
    exit(1);
  }
  printf("512 KB of memory has been allocated at address: %p\n", v8);
  v3 = malloc(0x40000ui64);
  v7 = v3;
  if ( !v3 )
  {
    printf("Error: Failed to allocate memory\n");
    exit(1);
  }
  printf("256 KB of memory has been allocated at address: %p\n", v3);
  free(Block);
  free(v8);
  free(v7);
  v4 = calloc(2ui64, 0x100000ui64);
  Blocka = v4;
  if ( !v4 )
  {
    printf("Error: Failed to allocate memory\n");
    exit(1);
  }
  printf("2 MB of memory has been allocated using calloc at address: %p\n", v4);
  v5 = realloc(Blocka, 0x300000ui64);
  Blockb = v5;
  if ( !v5 )
  {
    printf("Error: Failed to reallocate memory\n");
    exit(1);
  }
  printf("Memory reallocated to 3 MB at address: %p\n", v5);
  free(Blockb);
  return 0;
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#define F(x,y) printf("%s",i%x?"":#y"zz")
int main(int i){for(--i;i++^100;puts(""))F(3,Fi)|F(5,Bu)||printf("%i",i);return 0;}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f7c(char * format, ...);
int32_t function_100003f88(char * s);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003f97

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e34 - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003e34
    int64_t v1; // 0x100003e34
    int32_t v2 = v1; // 0x100003e44
    if (v2 == 101) {
        // 0x100003f6c
        return 0;
    }
    char * v3 = (char *)v1; // 0x100003ecc
    int32_t v4 = v2;
    if ((_printf("%s", v3) | _printf("%s", v3)) == 0) {
        // 0x100003f38
        _printf("%i", v1);
    }
    // 0x100003f5c
    _puts((char *)&g1);
    while (v4 != 100) {
        // 0x100003e7c
        v4++;
        if ((_printf("%s", v3) | _printf("%s", v3)) == 0) {
            // 0x100003f38
            _printf("%i", v1);
        }
        // 0x100003f5c
        _puts((char *)&g1);
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * s) {
    // 0x100003f88
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`//FormAI DATASET v1.0 Category: Text-Based Adventure Game ; Style: invasive
#include <stdio.h>

int main() {
    printf("Welcome to Invasive Adventure!\n");
    printf("You wake up in a dark room with no memory of how you got there.\n");
    printf("As you look around, you see a door in front of you and a window to your right.\n");
    
    char choice1;
    printf("Enter 'd' to open the door or 'w' to look out the window: ");
    scanf("%c", &choice1);
    
    if (choice1 == 'd') {
        printf("You open the door and see a long hallway.\n");
        printf("As you start walking down the hallway, you feel like you are being watched.\n");
        
        char choice2;
        printf("Enter 'f' to keep walking or 'r' to turn back: ");
        scanf(" %c", &choice2);
        
        if (choice2 == 'f') {
            printf("You walk until you reach the end of the hallway.\n");
            printf("There is a locked door in front of you.\n");
            
            char choice3;
            printf("Enter 'u' to try to unlock the door or 'b' to go back: ");
            scanf(" %c", &choice3);
            
            if (choice3 == 'u') {
                printf("You try to unlock the door, but the keyhole is too small for your fingers.\n");
                printf("As you turn around, you see a figure approaching you from the other end of the hallway.\n");
                
                char choice4;
                printf("Enter 'r' to run towards the figure or 'h' to hide in a nearby room: ");
                scanf(" %c", &choice4);
                
                if (choice4 == 'r') {
                    printf("You run towards the figure, but it disappears into thin air.\n");
                    printf("Confused and scared, you turn around and see the hallway has changed.\n");
                    printf("Everything seems to be made of flesh and bone, and the walls are pulsating.\n");
                } else if (choice4 == 'h') {
                    printf("You quickly enter a nearby room and lock the door.\n");
                    printf("It's a small room with a single window, but you can't see anything odd outside.\n");
                    printf("You hear footsteps passing by the door, but they soon fade away.\n");
                } else {
                    printf("Invalid choice. Try again.\n");
                }
            } else if (choice3 == 'b') {
                printf("You turn back, but the hallway has changed.\n");
                printf("Everything seems to be made of flesh and bone, and the walls are pulsating.\n");
            } else {
                printf("Invalid choice. Try again.\n");
            }
        } else if (choice2 == 'r') {
            printf("You turn back and see the door you came through is gone.\n");
            printf("In a panic, you start running back towards where you woke up.\n");
            printf("But as you run, the walls start to close in on you.\n");
            printf("You struggle to escape, but it's no use.\n");
            printf("The walls engulf you and everything goes black.\n");
            return 0;
        } else {
            printf("Invalid choice. Try again.\n");
        }
    } else if (choice1 == 'w') {
        printf("You look out the window, but all you see is darkness.\n");
        printf("Suddenly, you feel a hand grab your shoulder from behind.\n");
        printf("You turn around to see a grotesque creature that resembles a human.\n");
        printf("It has razor-sharp claws, sharp teeth, and a massive hunchback.\n");
        
        char choice5;
        printf("Enter 'a' to fight the creature or 'r' to run: ");
        scanf(" %c", &choice5);
        
        if (choice5 == 'a') {
            printf("You try to fight the creature, but it's too strong and fast.\n");
            printf("It slashes you with its claws, causing massive damage.\n");
            printf("You struggle to stay conscious, but eventually, everything goes black.\n");
            return 0;
        } else if (choice5 == 'r') {
            printf("You run as fast as you can, but the creature is right behind you.\n");
            printf("You make a desperate move and jump out of the window.\n");
            printf("You fall for what feels like forever, but eventually, you land in a body of water.\n");
            printf("You struggle to swim to the surface, but eventually, you make it.\n");
            printf("As you take a few deep breaths, you realize you are in a swamp.\n");
            
            char choice6;
            printf("Enter 'w' to keep swimming or 's' to try to find a way out: ");
            scanf(" %c", &choice6);
            
            if (choice6 == 'w') {
                printf("You keep swimming, but the water is thick and slimy.\n");
                printf("Suddenly, you feel something wrap around your leg and pull you down.\n");
                printf("You struggle to escape, but it's too strong.\n");
                printf("You are dragged under the surface and everything goes black.\n");
                return 0;
            } else if (choice6 == 's') {
                printf("You swim to the closest edge of the swamp and climb out.\n");
                printf("As you look around, you see a dense forest in front of you.\n");
                
                char choice7;
                printf("Enter 'e' to explore the forest or 'c' to stay put: ");
                scanf(" %c", &choice7);
                
                if (choice7 == 'e') {
                    printf("You start walking into the forest, but you soon realize you are lost.\n");
                    printf("The forest seems to be alive, with roots and vines crawling around your feet.\n");
                    printf("You struggle to walk, but eventually, you come across a clearing.\n");
                    
                    char choice8;
                    printf("Enter 'p' to sit down and rest or 'f' to keep walking: ");
                    scanf(" %c", &choice8);
                    
                    if (choice8 == 'p') {
                        printf("You sit down and try to catch your breath.\n");
                        printf("As you relax, you hear a faint singing coming from the trees.\n");
                        printf("It's a beautiful melody, and it seems to be getting closer.\n");
                        printf("You stand up, but before you can do anything else, a massive bird swoops down and grabs you.\n");
                        printf("You struggle to escape, but it's too strong.");
                        printf("Eventually, you give up and everything goes black.\n");
                        return 0;
                    } else if (choice8 == 'f') {
                        printf("You keep walking, but it's getting dark.\n");
                        printf("You try to turn back, but all the trees look the same.\n");
                        printf("Suddenly, you hear a voice calling out to you.\n");
                        printf("'Hey, over here!'");
                        
                        char choice9;
                        printf("Enter 'h' to hide or 'a' to approach the voice: ");
                        scanf(" %c", &choice9);
                        
                        if (choice9 == 'h') {
                            printf("You hide behind a nearby tree, but the voice seems to be getting closer.\n");
                            printf("You peek around the tree and see a figure approaching you.\n");
                            printf("It's a beautiful woman, but she has sharp, fanged teeth and glowing eyes.\n");
                            printf("She smiles and says, 'I've been waiting for you.'\n");
                            printf("You try to run, but she grabs you and brings you in for a kiss.\n");
                            printf("You struggle to get free, but eventually, everything goes black.\n");
                            return 0;
                        } else if (choice9 == 'a') {
                            printf("You walk towards the voice, but as you get closer, you realize it's coming from a massive spider.\n");
                            printf("It's legs are covered in black fur, and its eyes seem to glow in the dark.\n");
                            printf("It creeps closer and closer, and before you can react, it pounces and bites you.\n");
                            printf("You feel a sharp pain and start to feel woozy.\n");
                            printf("The last thing you see is the spider dragging you off into the darkness.\n");
                            return 0;
                        } else {
                            printf("Invalid choice. Try again.\n");
                        }
                    } else {
                        printf("Invalid choice. Try again.\n");
                    }
                } else if (choice7 == 'c') {
                    printf("You stay near the edge of the swamp, hoping someone will find you.\n");
                    printf("You wait for what feels like hours, but no one comes.\n");
                    printf("As the night turns colder, you start to shiver.\n");
                    printf("Soon, you can't move and everything goes black.\n");
                    return 0;
                } else {
                    printf("Invalid choice. Try again.\n");
                }
            } else {
                printf("Invalid choice. Try again.\n");
            }
        } else {
            printf("Invalid choice. Try again.\n");
        }
    } else {
        printf("Invalid choice. Try again.\n");
    }
    
    printf("Congratulations, you survived Invasive Adventure!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+27h] [rbp-9h] BYREF
  char v5; // [rsp+28h] [rbp-8h] BYREF
  char v6; // [rsp+29h] [rbp-7h] BYREF
  char v7; // [rsp+2Ah] [rbp-6h] BYREF
  char v8; // [rsp+2Bh] [rbp-5h] BYREF
  char v9; // [rsp+2Ch] [rbp-4h] BYREF
  char v10; // [rsp+2Dh] [rbp-3h] BYREF
  char v11; // [rsp+2Eh] [rbp-2h] BYREF
  char v12; // [rsp+2Fh] [rbp-1h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to Invasive Adventure!\n");
  printf("You wake up in a dark room with no memory of how you got there.\n");
  printf("As you look around, you see a door in front of you and a window to your right.\n");
  printf("Enter 'd' to open the door or 'w' to look out the window: ");
  scanf("%c", &v12);
  if ( v12 == 100 )
  {
    printf("You open the door and see a long hallway.\n");
    printf("As you start walking down the hallway, you feel like you are being watched.\n");
    printf("Enter 'f' to keep walking or 'r' to turn back: ");
    scanf(" %c", &v11);
    if ( v11 == 102 )
    {
      printf("You walk until you reach the end of the hallway.\n");
      printf("There is a locked door in front of you.\n");
      printf("Enter 'u' to try to unlock the door or 'b' to go back: ");
      scanf(" %c", &v10);
      if ( v10 == 117 )
      {
        printf("You try to unlock the door, but the keyhole is too small for your fingers.\n");
        printf("As you turn around, you see a figure approaching you from the other end of the hallway.\n");
        printf("Enter 'r' to run towards the figure or 'h' to hide in a nearby room: ");
        scanf(" %c", &v9);
        if ( v9 == 114 )
        {
          printf("You run towards the figure, but it disappears into thin air.\n");
          printf("Confused and scared, you turn around and see the hallway has changed.\n");
          printf("Everything seems to be made of flesh and bone, and the walls are pulsating.\n");
        }
        else if ( v9 == 104 )
        {
          printf("You quickly enter a nearby room and lock the door.\n");
          printf("It's a small room with a single window, but you can't see anything odd outside.\n");
          printf("You hear footsteps passing by the door, but they soon fade away.\n");
        }
        else
        {
          printf("Invalid choice. Try again.\n");
        }
      }
      else if ( v10 == 98 )
      {
        printf("You turn back, but the hallway has changed.\n");
        printf("Everything seems to be made of flesh and bone, and the walls are pulsating.\n");
      }
      else
      {
        printf("Invalid choice. Try again.\n");
      }
    }
    else
    {
      if ( v11 == 114 )
      {
        printf("You turn back and see the door you came through is gone.\n");
        printf("In a panic, you start running back towards where you woke up.\n");
        printf("But as you run, the walls start to close in on you.\n");
        printf("You struggle to escape, but it's no use.\n");
        printf("The walls engulf you and everything goes black.\n");
        return 0;
      }
      printf("Invalid choice. Try again.\n");
    }
  }
  else if ( v12 == 119 )
  {
    printf("You look out the window, but all you see is darkness.\n");
    printf("Suddenly, you feel a hand grab your shoulder from behind.\n");
    printf("You turn around to see a grotesque creature that resembles a human.\n");
    printf("It has razor-sharp claws, sharp teeth, and a massive hunchback.\n");
    printf("Enter 'a' to fight the creature or 'r' to run: ");
    scanf(" %c", &v8);
    if ( v8 == 97 )
    {
      printf("You try to fight the creature, but it's too strong and fast.\n");
      printf("It slashes you with its claws, causing massive damage.\n");
      printf("You struggle to stay conscious, but eventually, everything goes black.\n");
      return 0;
    }
    if ( v8 == 114 )
    {
      printf("You run as fast as you can, but the creature is right behind you.\n");
      printf("You make a desperate move and jump out of the window.\n");
      printf("You fall for what feels like forever, but eventually, you land in a body of water.\n");
      printf("You struggle to swim to the surface, but eventually, you make it.\n");
      printf("As you take a few deep breaths, you realize you are in a swamp.\n");
      printf("Enter 'w' to keep swimming or 's' to try to find a way out: ");
      scanf(" %c", &v7);
      if ( v7 == 119 )
      {
        printf("You keep swimming, but the water is thick and slimy.\n");
        printf("Suddenly, you feel something wrap around your leg and pull you down.\n");
        printf("You struggle to escape, but it's too strong.\n");
        printf("You are dragged under the surface and everything goes black.\n");
        return 0;
      }
      if ( v7 == 115 )
      {
        printf("You swim to the closest edge of the swamp and climb out.\n");
        printf("As you look around, you see a dense forest in front of you.\n");
        printf("Enter 'e' to explore the forest or 'c' to stay put: ");
        scanf(" %c", &v6);
        if ( v6 == 101 )
        {
          printf("You start walking into the forest, but you soon realize you are lost.\n");
          printf("The forest seems to be alive, with roots and vines crawling around your feet.\n");
          printf("You struggle to walk, but eventually, you come across a clearing.\n");
          printf("Enter 'p' to sit down and rest or 'f' to keep walking: ");
          scanf(" %c", &v5);
          if ( v5 == 112 )
          {
            printf("You sit down and try to catch your breath.\n");
            printf("As you relax, you hear a faint singing coming from the trees.\n");
            printf("It's a beautiful melody, and it seems to be getting closer.\n");
            printf("You stand up, but before you can do anything else, a massive bird swoops down and grabs you.\n");
            printf("You struggle to escape, but it's too strong.");
            printf("Eventually, you give up and everything goes black.\n");
            return 0;
          }
          if ( v5 == 102 )
          {
            printf("You keep walking, but it's getting dark.\n");
            printf("You try to turn back, but all the trees look the same.\n");
            printf("Suddenly, you hear a voice calling out to you.\n");
            printf("'Hey, over here!'");
            printf("Enter 'h' to hide or 'a' to approach the voice: ");
            scanf(" %c", &v4);
            if ( v4 == 104 )
            {
              printf("You hide behind a nearby tree, but the voice seems to be getting closer.\n");
              printf("You peek around the tree and see a figure approaching you.\n");
              printf("It's a beautiful woman, but she has sharp, fanged teeth and glowing eyes.\n");
              printf("She smiles and says, 'I've been waiting for you.'\n");
              printf("You try to run, but she grabs you and brings you in for a kiss.\n");
              printf("You struggle to get free, but eventually, everything goes black.\n");
              return 0;
            }
            if ( v4 == 97 )
            {
              printf("You walk towards the voice, but as you get closer, you realize it's coming from a massive spider.\n");
              printf("It's legs are covered in black fur, and its eyes seem to glow in the dark.\n");
              printf("It creeps closer and closer, and before you can react, it pounces and bites you.\n");
              printf("You feel a sharp pain and start to feel woozy.\n");
              printf("The last thing you see is the spider dragging you off into the darkness.\n");
              return 0;
            }
            printf("Invalid choice. Try again.\n");
          }
          else
          {
            printf("Invalid choice. Try again.\n");
          }
        }
        else
        {
          if ( v6 == 99 )
          {
            printf("You stay near the edge of the swamp, hoping someone will find you.\n");
            printf("You wait for what feels like hours, but no one comes.\n");
            printf("As the night turns colder, you start to shiver.\n");
            printf("Soon, you can't move and everything goes black.\n");
            return 0;
          }
          printf("Invalid choice. Try again.\n");
        }
      }
      else
      {
        printf("Invalid choice. Try again.\n");
      }
    }
    else
    {
      printf("Invalid choice. Try again.\n");
    }
  }
  else
  {
    printf("Invalid choice. Try again.\n");
  }
  printf("Congratulations, you survived Invasive Adventure!\n");
  return 0;
}
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <unistd.h>   // for isatty()
#include <stdio.h>    // for fileno()

int main()
{
    puts(isatty(fileno(stdout))
          ? "stdout is tty"
          : "stdout is not tty");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f64(struct _IO_FILE * stream);
int32_t function_100003f70(int32_t fd);
int32_t function_100003f7c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fileno(struct _IO_FILE * a1);
int32_t _isatty(int32_t a1);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003f00 - 0x100003f64
int64_t entry_point(void) {
    int32_t v1 = _fileno((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000); // 0x100003f24
    _puts(_isatty(v1) == 0 ? "stdout is not tty" : "stdout is tty");
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(struct _IO_FILE * stream) {
    // 0x100003f64
    return _fileno(stream);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(int32_t fd) {
    // 0x100003f70
    return _isatty(fd);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * s) {
    // 0x100003f7c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
int main(){char*c="#include <stdio.h>%cint main(){char*c=%c%s%c;printf(c,10,34,c,34,10);return 0;}%c";printf(c,10,34,c,34,10);return 0;}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f48(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ee8 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003ee8
    int64_t v1; // 0x100003ee8
    _printf("#include <stdio.h>%cint main(){char*c=%c%s%c;printf(c,10,34,c,34,10);return 0;}%c", (char)v1, (char)v1, (char *)v1, (char)v1, (char)v1);
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`// From manpage for "getline"

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	FILE *stream;
	char *line = NULL;
	size_t len = 0;
	ssize_t read;

	stream = fopen("file.txt", "r");
	if (stream == NULL)
		exit(EXIT_FAILURE);

	while ((read = getline(&line, &len, stream)) != -1) {
		printf("Retrieved line of length %u :\n", read);
		printf("%s", line);
	}

	free(line);
	fclose(stream);
	exit(EXIT_SUCCESS);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
void function_100003f30(int32_t status);
int32_t function_100003f3c(struct _IO_FILE * stream);
struct _IO_FILE * function_100003f48(char * filename, char * modes);
void function_100003f54(int64_t * ptr);
int32_t function_100003f60(char ** lineptr, int32_t * n, struct _IO_FILE * stream);
int32_t function_100003f6c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
void _free(int64_t * a1);
int32_t _getline(char ** a1, int32_t * a2, struct _IO_FILE * a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e70 - 0x100003f30
int64_t entry_point(void) {
    int64_t v1 = 0; // bp-40, 0x100003e80
    int64_t v2 = 0; // bp-48, 0x100003e84
    struct _IO_FILE * v3 = _fopen("file.txt", "r"); // 0x100003e98
    if (v3 == NULL) {
        // 0x100003eb4
        _exit(1);
        // UNREACHABLE
    }
    // 0x100003ec0
    if (_getline((char **)&v1, (int32_t *)&v2, v3) == -1) {
        // 0x100003f18
        _free((int64_t *)v1);
        _fclose(v3);
        return 0;
    }
    _printf("Retrieved line of length %u :\n", (int32_t)(int64_t)&v2);
    _printf("%s", &v2);
    // 0x100003ee4
    while (_getline((char **)&v1, (int32_t *)&v2, v3) != -1) {
        // 0x100003ee4
        _printf("Retrieved line of length %u :\n", (int32_t)(int64_t)&v2);
        _printf("%s", &v2);
    }
    // 0x100003f18
    _free((int64_t *)v1);
    _fclose(v3);
    return 0;
}

// Address range: 0x100003f30 - 0x100003f3c
void function_100003f30(int32_t status) {
    // 0x100003f30
    _exit(status);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(struct _IO_FILE * stream) {
    // 0x100003f3c
    return _fclose(stream);
}

// Address range: 0x100003f48 - 0x100003f54
struct _IO_FILE * function_100003f48(char * filename, char * modes) {
    // 0x100003f48
    return _fopen(filename, modes);
}

// Address range: 0x100003f54 - 0x100003f60
void function_100003f54(int64_t * ptr) {
    // 0x100003f54
    _free(ptr);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(char ** lineptr, int32_t * n, struct _IO_FILE * stream) {
    // 0x100003f60
    return _getline(lineptr, n, stream);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdio.h>

int main()
{
	fprintf(stderr, "Goodbye, ");
	fputs("World!\n", stderr);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f7c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f88(char * s, struct _IO_FILE * stream);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _fputs(char * a1, struct _IO_FILE * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003f24 - 0x100003f7c
int64_t entry_point(void) {
    int64_t * v1 = (int64_t *)*(int64_t *)0x100004000; // 0x100003f48
    _fprintf((struct _IO_FILE *)*v1, "Goodbye, ");
    _fputs("World!\n", (struct _IO_FILE *)*v1);
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f7c
    return _fprintf(stream, format);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * s, struct _IO_FILE * stream) {
    // 0x100003f88
    return _fputs(s, stream);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>
#include <stdlib.h>

typedef struct frame
{
  int (*fn)(struct frame*);
  union { int constant; int* k; } u;
  struct frame *x1, *x2, *x3, *x4, *x5;
} FRAME;

FRAME* Frame(FRAME* f, int* k, FRAME* x1, FRAME* x2, FRAME *x3, FRAME *x4, FRAME *x5)
{
  f->u.k = k;
  f->x1 = x1;
  f->x2 = x2;
  f->x3 = x3;
  f->x4 = x4;
  f->x5 = x5;
  return f;
}

int F(FRAME* a) { return a->u.constant; }

int eval(FRAME* a) { return a->fn(a); }

int A(FRAME*);

int B(FRAME* a)
{
  int k = (*a->u.k -= 1);
  FRAME b = { B };
  return A(Frame(&b, &k, a, a->x1, a->x2, a->x3, a->x4));
}

int A(FRAME* a)
{
  return *a->u.k <= 0 ? eval(a->x4) + eval(a->x5) : B(a);
}

int main(int argc, char** argv)
{
  int k = argc == 2 ? strtol(argv[1], 0, 0) : 10;
  FRAME a = { B }, f1 = { F, { 1 } }, f0 = { F, { 0 } }, fn1 = { F, { -1 } };

  printf("%d\n", A(Frame(&a, &k, &f1, &fn1, &fn1, &f1, &f0)));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c90(void);
int64_t function_100003d04(void);
int64_t function_100003d1c(void);
int64_t function_100003d3c(int64_t a1, int64_t a2);
int64_t function_100003d48(void);
int64_t function_100003dd0(void);
int64_t * function_100003f68(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f74(char * format, ...);
int32_t function_100003f80(char * nptr, char ** endptr, int32_t base);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x70000000003d04; // 0x100004088
int64_t g2 = 0x70000000003d04; // 0x1000040c0
int64_t g3 = 0x3d04; // 0x1000040f8

// ------- Dynamically Linked Functions Without Header --------

int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003c90 - 0x100003d04
int64_t function_100003c90(void) {
    // 0x100003c90
    int64_t result; // 0x100003c90
    return result;
}

// Address range: 0x100003d04 - 0x100003d1c
int64_t function_100003d04(void) {
    // 0x100003d04
    int64_t v1; // 0x100003d04
    return (int64_t)*(int32_t *)(v1 + 8);
}

// Address range: 0x100003d1c - 0x100003d3c
int64_t function_100003d1c(void) {
    // 0x100003d1c
    int64_t result; // 0x100003d1c
    return result;
}

// Address range: 0x100003d3c - 0x100003d48
int64_t function_100003d3c(int64_t a1, int64_t a2) {
    // 0x100003d3c
    int64_t result; // 0x100003d3c
    return result;
}

// Address range: 0x100003d48 - 0x100003dd0
int64_t function_100003d48(void) {
    // 0x100003d48
    int64_t v1; // 0x100003d48
    int32_t * v2 = (int32_t *)*(int64_t *)(v1 + 8); // 0x100003d60
    *v2 = *v2 - 1;
    int64_t v3; // bp-88, 0x100003d48
    _memcpy(&v3, (int64_t *)"H=", 56);
    function_100003c90();
    return function_100003dd0();
}

// Address range: 0x100003dd0 - 0x100003e4c
int64_t function_100003dd0(void) {
    // 0x100003dd0
    int64_t v1; // 0x100003dd0
    int64_t v2; // 0x100003dd0
    if (*(int32_t *)*(int64_t *)(v2 + 8) < 1) {
        int64_t v3 = function_100003d1c(); // 0x100003e04
        v1 = function_100003d1c() + v3;
    } else {
        // 0x100003e2c
        v1 = function_100003d48();
    }
    // 0x100003e3c
    return v1 & 0xffffffff;
}

// Address range: 0x100003e4c - 0x100003f68
int64_t entry_point(void) {
    int64_t v1 = 10; // 0x100003e74
    int64_t v2; // 0x100003e4c
    if ((int32_t)v2 == 2) {
        // 0x100003e7c
        v1 = _strtol((char *)*(int64_t *)(v2 + 8), NULL, 0);
    }
    int64_t v3 = v1; // bp-52, 0x100003eb0
    int64_t v4; // bp-112, 0x100003e4c
    _memcpy(&v4, (int64_t *)"H=", 56);
    int64_t v5; // bp-168, 0x100003e4c
    _memcpy(&v5, &g1, 56);
    int64_t v6; // bp-224, 0x100003e4c
    _memcpy(&v6, &g2, 56);
    int64_t v7; // bp-280, 0x100003e4c
    _memcpy(&v7, &g3, 56);
    function_100003c90();
    function_100003dd0();
    _printf("%d\n", (int64_t)&v3);
    return 0;
}

// Address range: 0x100003f68 - 0x100003f74
int64_t * function_100003f68(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f68
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f74 - 0x100003f80
int32_t function_100003f74(char * format, ...) {
    // 0x100003f74
    return _printf(format);
}

// Address range: 0x100003f80 - 0x100003f8c
int32_t function_100003f80(char * nptr, char ** endptr, int32_t base) {
    // 0x100003f80
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>
#include <stdlib.h>

int dot_product(int *, int *, size_t);

int
main(void)
{
        int a[3] = {1, 3, -5};
        int b[3] = {4, -2, -1};

        printf("%d\n", dot_product(a, b, sizeof(a) / sizeof(a[0])));

        return EXIT_SUCCESS;
}

int
dot_product(int *a, int *b, size_t n)
{
        int sum = 0;
        size_t i;

        for (i = 0; i < n; i++) {
                sum += a[i] * b[i];
        }

        return sum;
}
`,`#include "dot-product.h"



undefined8 entry(void)

{
  int iVar1;
  undefined8 local_38;
  undefined4 local_30;
  undefined8 local_28;
  undefined4 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_28 = 0x300000001;
  local_20 = 0xfffffffb;
  local_38 = 0xfffffffe00000004;
  local_30 = 0xffffffff;
  _dot_product(&local_28,&local_38,3);
  iVar1 = _printf("%d\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



int _dot_product(long param_1,long param_2,ulong param_3)

{
  undefined8 local_28;
  undefined4 local_1c;
  
  local_1c = 0;
  for (local_28 = 0; local_28 < param_3; local_28 = local_28 + 1) {
    local_1c = local_1c + *(int *)(param_1 + local_28 * 4) * *(int *)(param_2 + local_28 * 4);
  }
  return local_1c;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <math.h>	/* HUGE_VAL */
#include <stdio.h>	/* printf() */

double inf(void) {
  return HUGE_VAL;
}

int main() {
  printf("%g\n", inf());
  return 0;
}
`,`#include "infinity-1.h"



undefined  [16] _inf(void)

{
  return ZEXT816(0x7ff0000000000000);
}



undefined4 entry(void)

{
  _inf();
  _printf("%g\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int main(void) {
    int nprimes =  1000000;
    int nmax =    ceil(nprimes*(log(nprimes)+log(log(nprimes))-0.9385));
      // should be larger than the last prime wanted; See
      // https://www.maa.org/sites/default/files/jaroma03200545640.pdf
    int i, j, m, k; int *a;
    k = (nmax-2)/2;
    a = (int *)calloc(k + 1, sizeof(int));
    for(i = 0; i <= k; i++)a[i] = 2*i+1;
    for (i = 1; (i+1)*i*2 <= k; i++)
        for (j = i; j <= (k-i)/(2*i+1); j++) {
            m = i + j + 2*i*j;
            if(a[m]) a[m] = 0;
            }

    for (i = 1, j = 0; i <= k; i++)
       if (a[i]) {
           if(j%10 == 0 && j <= 100)printf("\n");
           j++;
           if(j <= 100)printf("%3d ", a[i]);
           else if(j == nprimes){
               printf("\n%d th prime is %d\n",j,a[i]);
               break;
               }
           }
}
`,`#include "the-sieve-of-sundaram.h"



undefined4 entry(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  void *pvVar4;
  double dVar5;
  double dVar6;
  int local_24;
  int local_20;
  
  dVar5 = (double)_log(0x412e848000000000);
  _log(0x412e848000000000);
  dVar6 = (double)_log();
  iVar2 = ((int)(((dVar5 + dVar6) - 0.9385) * 1000000.0) + -2) / 2;
  pvVar4 = _calloc((long)(iVar2 + 1),4);
  for (local_20 = 0; local_20 <= iVar2; local_20 = local_20 + 1) {
    *(int *)((long)pvVar4 + (long)local_20 * 4) = local_20 * 2 + 1;
  }
  for (local_20 = 1; iVar1 = (local_20 + 1) * local_20,
      iVar2 + iVar1 * -2 < 0 == SBORROW4(iVar2,iVar1 * 2); local_20 = local_20 + 1) {
    local_24 = local_20;
    while( true ) {
      iVar1 = local_20 * 2 + 1;
      iVar3 = 0;
      if (iVar1 != 0) {
        iVar3 = (iVar2 - local_20) / iVar1;
      }
      if (iVar3 < local_24) break;
      iVar1 = local_20 + local_24 + local_20 * 2 * local_24;
      if (*(int *)((long)pvVar4 + (long)iVar1 * 4) != 0) {
        *(undefined4 *)((long)pvVar4 + (long)iVar1 * 4) = 0;
      }
      local_24 = local_24 + 1;
    }
  }
  local_20 = 1;
  local_24 = 0;
  do {
    if (iVar2 < local_20) {
      return 0;
    }
    if (*(int *)((long)pvVar4 + (long)local_20 * 4) != 0) {
      if ((local_24 % 10 == 0) && (local_24 < 0x65)) {
        _printf("\n");
      }
      local_24 = local_24 + 1;
      if (local_24 < 0x65) {
        _printf("%3d ");
      }
      else if (local_24 == 1000000) {
        _printf("\n%d th prime is %d\n");
        return 0;
      }
    }
    local_20 = local_20 + 1;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



void _log(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__log_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

__int128 imax(__int128 a, __int128 b) {
    if (a > b) {
        return a;
    }
    return b;
}

__int128 ipow(__int128 b, __int128 n) {
    __int128 res;
    if (n == 0) {
        return 1;
    }
    if (n == 1) {
        return b;
    }
    res = b;
    while (n > 1) {
        res *= b;
        n--;
    }
    return res;
}

__int128 imod(__int128 m, __int128 n) {
    __int128 result = m % n;
    if (result < 0) {
        result += n;
    }
    return result;
}

bool valid(__int128 n) {
    if (n < 0) {
        return false;
    }
    while (n > 0) {
        int r = n % 10;
        if (r > 1) {
            return false;
        }
        n /= 10;
    }
    return true;
}

__int128 mpm(const __int128 n) {
    __int128 *L;
    __int128 m, k, r, j;

    if (n == 1) {
        return 1;
    }

    L = calloc(n * n, sizeof(__int128));
    L[0] = 1;
    L[1] = 1;
    m = 0;
    while (true) {
        m++;
        if (L[(m - 1) * n + imod(-ipow(10, m), n)] == 1) {
            break;
        }
        L[m * n + 0] = 1;
        for (k = 1; k < n; k++) {
            L[m * n + k] = imax(L[(m - 1) * n + k], L[(m - 1) * n + imod(k - ipow(10, m), n)]);
        }
    }

    r = ipow(10, m);
    k = imod(-r, n);

    for (j = m - 1; j >= 1; j--) {
        if (L[(j - 1) * n + k] == 0) {
            r = r + ipow(10, j);
            k = imod(k - ipow(10, j), n);
        }
    }

    if (k == 1) {
        r++;
    }
    return r / n;
}

void print128(__int128 n) {
    char buffer[64]; // more then is needed, but is nice and round;
    int pos = (sizeof(buffer) / sizeof(char)) - 1;
    bool negative = false;

    if (n < 0) {
        negative = true;
        n = -n;
    }

    buffer[pos] = 0;
    while (n > 0) {
        int rem = n % 10;
        buffer[--pos] = rem + '0';
        n /= 10;
    }
    if (negative) {
        buffer[--pos] = '-';
    }
    printf(&buffer[pos]);
}

void test(__int128 n) {
    __int128 mult = mpm(n);
    if (mult > 0) {
        print128(n);
        printf(" * ");
        print128(mult);
        printf(" = ");
        print128(n * mult);
        printf("\n");
    } else {
        print128(n);
        printf("(no solution)\n");
    }
}

int main() {
    int i;

    // 1-10 (inclusive)
    for (i = 1; i <= 10; i++) {
        test(i);
    }
    // 95-105 (inclusive)
    for (i = 95; i <= 105; i++) {
        test(i);
    }
    test(297);
    test(576);
    test(594); // needs a larger number type (64 bits signed)
    test(891);
    test(909);
    test(999); // needs a larger number type (87 bits signed)

    // optional
    test(1998);
    test(2079);
    test(2251);
    test(2277);

    // stretch
    test(2439);
    test(2997);
    test(4878);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_10000300c(void);
int64_t function_1000030b8(void);
int64_t function_100003270(void);
int64_t function_1000032ec(void);
int64_t function_1000033b8(void);
int64_t function_100003b34(void);
int64_t function_100003c98(void);
int64_t function_100003f38(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int128_t a5);
int64_t function_100003f44(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003f50(int64_t a1);
int64_t * function_100003f5c(int32_t nmemb, int32_t size);
int32_t function_100003f68(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___divti3(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int128_t a5);
int64_t ___modti3(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x10000300c - 0x1000030b8
int64_t function_10000300c(void) {
    // 0x10000300c
    float64_t result; // 0x10000300c
    return result;
}

// Address range: 0x1000030b8 - 0x100003270
int64_t function_1000030b8(void) {
    // 0x1000030b8
    return 0;
}

// Address range: 0x100003270 - 0x1000032ec
int64_t function_100003270(void) {
    // 0x100003270
    int64_t v1; // 0x100003270
    int64_t v2 = v1;
    int64_t v3 = v1;
    return ___modti3(v1, v3, v2, v1) + (v3 > -1 ? 0 : v2);
}

// Address range: 0x1000032ec - 0x1000033b8
int64_t function_1000032ec(void) {
    // 0x1000032ec
    int64_t v1; // 0x1000032ec
    uint64_t v2 = v1;
    if (v2 <= 0xffffffffffffffff) {
        // 0x1000033a8
        return 0;
    }
    int64_t v3 = v2 - 1; // 0x10000332c
    int64_t v4 = v1 != 0; // 0x10000332c
    if (v3 + v4 < 0 != ((v3 + v4 + v4 ^ -0x8000000000000000) & v2) < 0) {
        // 0x1000033a8
        return 1;
    }
    int64_t result = 0; // 0x100003364
    int64_t v5; // 0x1000032ec
    while ((int32_t)___modti3(v5, v2, 10, 0) < 2) {
        // 0x100003378
        int128_t v6; // 0x1000032ec
        int64_t v7 = ___divti3(v5, v2, 10, 0, v6); // 0x10000338c
        int64_t v8 = v7 != 0; // 0x10000332c
        int64_t v9 = v3 + v8; // 0x10000332c
        v5 = v7;
        result = 1;
        if (v9 < 0 != ((v9 + v8 ^ -0x8000000000000000) & v2) < 0) {
            // break -> 0x1000033a8
            break;
        }
        result = 0;
    }
    // 0x1000033a8
    return result;
}

// Address range: 0x1000033b8 - 0x100003b34
int64_t function_1000033b8(void) {
    // 0x1000033b8
    float64_t v1; // 0x1000033b8
    if ((int64_t)v1 == 1) {
        // 0x100003b10
        return 0;
    }
    // 0x100003420
    _calloc(0, 16);
    while (true) {
        // 0x100003480
        function_1000030b8();
        function_100003270();
    }
}

// Address range: 0x100003b34 - 0x100003c98
int64_t function_100003b34(void) {
    // 0x100003b34
    int64_t v1; // 0x100003b34
    uint64_t v2 = v1;
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004018; // 0x100003b48
    int32_t v4 = 0; // 0x100003b6c
    int64_t v5; // 0x100003b34
    int64_t v6; // 0x100003b34
    if (v2 <= 0xffffffffffffffff) {
        // 0x100003b74
        v6 = -v1;
        v4 = 1;
        v5 = (int64_t)(v1 == 0) + -1 - v2;
    }
    // 0x100003b9c
    int64_t v7; // bp-88, 0x100003b34
    int64_t v8 = &v7; // 0x100003ba0
    *(char *)(v8 + 63) = 0;
    int64_t v9 = v5 - 1; // 0x100003bc0
    int64_t v10 = v6 != 0; // 0x100003bc0
    int64_t v11 = v9 + v10; // 0x100003bc0
    int32_t v12 = 63; // 0x100003bc8
    int64_t v13 = v6; // 0x100003bc8
    int32_t v14 = 63; // 0x100003bc8
    if (v11 < 0 == ((v11 + v10 ^ -0x8000000000000000) & v5) < 0) {
        int64_t v15 = ___modti3(v13, v5, 10, 0); // 0x100003bec
        v12--;
        *(char *)((int64_t)v12 + v8) = (char)v15 + 48;
        int128_t v16; // 0x100003b34
        v13 = ___divti3(v13, v5, 10, 0, v16);
        int64_t v17 = v13 != 0; // 0x100003bc0
        int64_t v18 = v9 + v17; // 0x100003bc0
        v14 = v12;
        while (v18 < 0 == ((v18 + v17 ^ -0x8000000000000000) & v5) < 0) {
            // 0x100003bd0
            v15 = ___modti3(v13, v5, 10, 0);
            v12--;
            *(char *)((int64_t)v12 + v8) = (char)v15 + 48;
            v13 = ___divti3(v13, v5, 10, 0, v16);
            v17 = v13 != 0;
            v18 = v9 + v17;
            v14 = v12;
        }
    }
    int32_t v19 = v14; // 0x100003c38
    if (v4 != 0) {
        // 0x100003c40
        v19 = v14 - 1;
        *(char *)((int64_t)v19 + v8) = 45;
    }
    int64_t v20 = _printf((char *)((int64_t)v19 + v8)); // 0x100003c68
    int64_t result = v20; // 0x100003c80
    if (*(int64_t *)*(int64_t *)0x100004018 != v3) {
        // 0x100003c88
        result = ___stack_chk_fail(v20);
    }
    // 0x100003c8c
    return result;
}

// Address range: 0x100003c98 - 0x100003df8
int64_t function_100003c98(void) {
    // 0x100003c98
    function_1000033b8();
    function_100003b34();
    int64_t result; // 0x100003c98
    // 0x100003d18
    _printf(" * ");
    function_100003b34();
    _printf(" = ");
    function_100003b34();
    result = _printf("\n");
    // 0x100003dec
    return result;
}

// Address range: 0x100003df8 - 0x100003f38
int64_t entry_point(void) {
    int32_t v1 = 1;
    function_100003c98();
    int32_t v2 = v1 + 1; // 0x100003e3c
    int32_t v3 = v1 - 9; // 0x100003e18
    while (v3 == 0 || v3 < 0 != (8 - v1 & v2) < 0) {
        // 0x100003e28
        v1 = v2;
        function_100003c98();
        v2 = v1 + 1;
        v3 = v1 - 9;
    }
    int32_t v4 = 95;
    int32_t v5 = v4 - 105; // 0x100003e58
    function_100003c98();
    int32_t v6 = v4 + 1; // 0x100003e60
    while (v5 == 0 || v5 < 0 != (104 - v4 & v4) < 0) {
        // 0x100003e54
        v4 = v6;
        v5 = v4 - 105;
        function_100003c98();
        v6 = v4 + 1;
    }
    // 0x100003e88
    function_100003c98();
    function_100003c98();
    function_100003c98();
    function_100003c98();
    function_100003c98();
    function_100003c98();
    function_100003c98();
    function_100003c98();
    function_100003c98();
    function_100003c98();
    function_100003c98();
    function_100003c98();
    return 0;
}

// Address range: 0x100003f38 - 0x100003f44
int64_t function_100003f38(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int128_t a5) {
    // 0x100003f38
    return ___divti3(a1, a2, a3, a4, a5);
}

// Address range: 0x100003f44 - 0x100003f50
int64_t function_100003f44(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f44
    return ___modti3(a1, a2, a3, a4);
}

// Address range: 0x100003f50 - 0x100003f5c
int64_t function_100003f50(int64_t a1) {
    // 0x100003f50
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f5c - 0x100003f68
int64_t * function_100003f5c(int32_t nmemb, int32_t size) {
    // 0x100003f5c
    return _calloc(nmemb, size);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <stdlib.h>

/* define a shuffle function. e.g. decl_shuffle(double).
 * advantage: compiler is free to optimize the swap operation without
 *            indirection with pointers, which could be much faster.
 * disadvantage: each datatype needs a separate instance of the function.
 *            for a small funciton like this, it's not very big a deal.
 */
#define decl_shuffle(type)				\
void shuffle_##type(type *list, size_t len) {		\
	int j;						\
	type tmp;					\
	while(len) {					\
		j = irand(len);				\
		if (j != len - 1) {			\
			tmp = list[j];			\
			list[j] = list[len - 1];	\
			list[len - 1] = tmp;		\
		}					\
		len--;					\
	}						\
}							\

/* random integer from 0 to n-1 */
int irand(int n)
{
	int r, rand_max = RAND_MAX - (RAND_MAX % n);
	/* reroll until r falls in a range that can be evenly
	 * distributed in n bins.  Unless n is comparable to
	 * to RAND_MAX, it's not *that* important really. */
	while ((r = rand()) >= rand_max);
	return r / (rand_max / n);
}

/* declare and define int type shuffle function from macro */
decl_shuffle(int);

int main()
{
	int i, x[20];

	for (i = 0; i < 20; i++) x[i] = i;
	for (printf("before:"), i = 0; i < 20 || !printf("\n"); i++)
		printf(" %d", x[i]);

	shuffle_int(x, 20);

	for (printf("after: "), i = 0; i < 20 || !printf("\n"); i++)
		printf(" %d", x[i]);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003c84(void);
int64_t function_100003cf4(void);
int64_t function_100003f6c(int64_t a1);
int32_t function_100003f78(char * format, ...);
int32_t function_100003f84(void);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003c84 - 0x100003cf4
int64_t function_100003c84(void) {
    // 0x100003c84
    int64_t v1; // 0x100003c84
    int32_t v2 = v1; // 0x100003c90
    int32_t v3 = 0x7fffffff % v2 ^ 0x7fffffff; // 0x100003ca0
    int32_t v4 = _rand(); // 0x100003cb4
    while ((v4 - v3) < 0 == (v4 & -((v4 - v3))) < 0) {
        // 0x100003cb4
        v4 = _rand();
    }
    // 0x100003cd4
    return v4 / (v3 / v2);
}

// Address range: 0x100003cf4 - 0x100003dac
int64_t function_100003cf4(void) {
    // 0x100003cf4
    int64_t v1; // 0x100003cf4
    if (v1 == 0) {
        // 0x100003da0
        int64_t result; // 0x100003cf4
        return result;
    }
    int64_t result2 = function_100003c84(); // 0x100003d28
    int64_t v2 = 0x100000000 * result2;
    int64_t v3; // 0x100003cf4
    int64_t v4 = v3 - 1; // 0x100003d38
    int32_t * v5; // 0x100003d54
    int32_t * v6; // 0x100003d68
    if (v2 >> 32 != v4) {
        // 0x100003d4c
        v5 = (int32_t *)((v2 >> 30) + v1);
        v6 = (int32_t *)(v1 - 4 + 4 * v3);
        *v5 = *v6;
        *v6 = *v5;
    }
    // 0x100003d20
    while (v4 != 0) {
        int64_t v7 = v4;
        result2 = function_100003c84();
        v2 = 0x100000000 * result2;
        v4 = v7 - 1;
        if (v2 >> 32 != v4) {
            // 0x100003d4c
            v5 = (int32_t *)((v2 >> 30) + v1);
            v6 = (int32_t *)(v1 - 4 + 4 * v7);
            *v5 = *v6;
            *v6 = *v5;
        }
    }
    // 0x100003da0
    return result2;
}

// Address range: 0x100003dac - 0x100003f6c
int64_t entry_point(void) {
    // 0x100003dac
    int64_t v1; // bp-104, 0x100003dac
    int64_t v2 = &v1; // 0x100003df0
    int64_t v3 = 0;
    *(int32_t *)(4 * v3 + v2) = (int32_t)v3;
    int64_t v4 = v3 + 1;
    while (v4 != 20) {
        // 0x100003de8
        v3 = v4;
        *(int32_t *)(4 * v3 + v2) = (int32_t)v3;
        v4 = v3 + 1;
    }
    // 0x100003e0c
    _printf("before:");
    int32_t v5 = 0; // 0x100003e1c
    while (true) {
        int32_t v6 = v5;
        if (v6 < 20 == (19 - v6 & v6) < 0) {
            // 0x100003e58
            if (_printf("\n") != 0) {
                // break -> 0x100003e9c
                break;
            }
        }
        // 0x100003e64
        int64_t v7; // 0x100003dac
        _printf(" %d", v7);
        v5 = v6 + 1;
    }
    // 0x100003e9c
    function_100003cf4();
    _printf("after: ");
    int32_t v8 = 0; // 0x100003eb8
    int32_t v9; // 0x100003ee0
    while (true) {
        int32_t v10 = v8;
        if (v10 < 20 == (19 - v10 & v10) < 0) {
            // 0x100003ef4
            v9 = _printf("\n");
            if (v9 != 0) {
                // break -> 0x100003f38
                break;
            }
        }
        // 0x100003f00
        _printf(" %d", 20);
        v8 = v10 + 1;
    }
    int64_t v11 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f44
    if (v11 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f58
        ___stack_chk_fail((int64_t)v9);
    }
    // 0x100003f5c
    return 0;
}

// Address range: 0x100003f6c - 0x100003f78
int64_t function_100003f6c(int64_t a1) {
    // 0x100003f6c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(void) {
    // 0x100003f84
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`//FormAI DATASET v1.0 Category: Binary Converter ; Style: relaxed
#include <stdio.h>

void printBinary(int decimal) {
    int binaryArr[32];
    int i = 0;

    while (decimal > 0) {
        binaryArr[i] = decimal % 2;
        decimal /= 2;
        i++;
    }

    for (int j = i - 1; j >= 0; j--) {
        printf("%d", binaryArr[j]);
    }
}

int main() {
    int decimal;

    printf("Enter a decimal number to convert to binary: ");
    scanf("%d", &decimal);

    printf("The binary representation of %d is: ", decimal);
    printBinary(decimal);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall printBinary(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000166B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter a decimal number to convert to binary: ");
  scanf("%d", &v4);
  printf("The binary representation of %d is: ", v4);
  printBinary(v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall printBinary(_QWORD);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <string.h>

int cmp(const char *p, const char *q)
{
	while (*p && *q) p = &p[1], q = &q[1];
	return *p;
}

int main()
{
	char line[65536];
	char buf[1000000] = {0};
	char *last = buf;
	char *next = buf;

	while (gets(line)) {
		strcat(line, "\n");
		if (cmp(last, line)) continue;
		if (cmp(line, last)) next = buf;
		last = next;
		strcpy(next, line);
		while (*next) next = &next[1];
	}

	printf("%s", buf);
	return 0;
}
`,`#include "longest-string-challenge-1.h"



long _cmp(char *param_1,char *param_2)

{
  bool bVar1;
  char *local_10;
  char *local_8;
  
  local_10 = param_2;
  local_8 = param_1;
  while( true ) {
    bVar1 = false;
    if (*local_8 != '\0') {
      bVar1 = *local_10 != '\0';
    }
    if (!bVar1) break;
    local_8 = local_8 + 1;
    local_10 = local_10 + 1;
  }
  return (long)*local_8;
}



undefined8 entry(void)

{
  int iVar1;
  char *pcVar2;
  long lVar3;
  char *pcVar4;
  char *pcVar5;
  char acStack_10028 [65544];
  
  (*(code *)PTR____chkstk_darwin_100004000)();
  lVar3 = *(long *)PTR____stack_chk_guard_100004010;
  pcVar5 = &stack0xffffffffffefbd98;
  _bzero(pcVar5,1000000);
  pcVar4 = pcVar5;
  while (pcVar2 = _gets(acStack_10028), pcVar2 != (char *)0x0) {
    ___strcat_chk(acStack_10028,"\n",0x10000);
    iVar1 = _cmp(pcVar4,acStack_10028);
    if (iVar1 == 0) {
      iVar1 = _cmp(acStack_10028,pcVar4);
      pcVar4 = pcVar5;
      if (iVar1 != 0) {
        pcVar4 = &stack0xffffffffffefbd98;
      }
      ___strcpy_chk(pcVar4,acStack_10028,0xffffffffffffffff);
      for (pcVar5 = pcVar4; *pcVar5 != '\0'; pcVar5 = pcVar5 + 1) {
      }
    }
  }
  iVar1 = _printf("%s");
  if (*(long *)PTR____stack_chk_guard_100004010 == lVar3) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar1);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void ___strcat_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcat_chk_100004018)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _bzero(void *param_1,size_t param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__bzero_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _gets(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__gets_100004030)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Email Client ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_EMAILS 10
#define MAX_LENGTH 1000
#define MAX_SENDERS 200

typedef struct{
    char sender[MAX_SENDERS];
    char subject[MAX_LENGTH];
    char message[MAX_LENGTH];
} Email;

void printMenu(){
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("               Purrfect Email Client\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("                     Main Menu\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("1 - Compose New Email\n");
    printf("2 - Check Inbox\n");
    printf("3 - Quit\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("Enter your choice : ");
}

void clearBuffer(){
    int c = 0;
    while ((c = getchar()) != '\n' && c != EOF) { }
}

void invalidChoice(){
    printf("Invalid choice. Please enter a valid choice.\n");
}

void addEmail(Email* emails, int* numEmails){
    int senderLength = 0;
    int subjectLength = 0;
    int messageLength = 0;
    
    printf("Enter sender : ");
    fgets(emails[*numEmails].sender, MAX_SENDERS, stdin);
    senderLength = strlen(emails[*numEmails].sender);
    if(senderLength > 0 && emails[*numEmails].sender[senderLength - 1] == '\n'){
        emails[*numEmails].sender[senderLength - 1] = '\0';
    }
    
    printf("Enter subject : ");
    fgets(emails[*numEmails].subject, MAX_LENGTH, stdin);
    subjectLength = strlen(emails[*numEmails].subject);
    if(subjectLength > 0 && emails[*numEmails].subject[subjectLength - 1] == '\n'){
        emails[*numEmails].subject[subjectLength - 1] = '\0';
    }
    
    printf("Enter message : ");
    fgets(emails[*numEmails].message, MAX_LENGTH, stdin);
    messageLength = strlen(emails[*numEmails].message);
    if(messageLength > 0 && emails[*numEmails].message[messageLength - 1] == '\n'){
        emails[*numEmails].message[messageLength - 1] = '\0';
    }
    
    printf("Email sent successfully!\n\n");
    *numEmails += 1;
}

void viewInbox(Email* emails, int numEmails){
    if(numEmails == 0){
        printf("You have no new emails.\n\n");
        return;
    }
    
    printf("Your inbox:\n");
    for(int i = 0; i < numEmails; i++){
        printf("Sender : %s\n", emails[i].sender);
        printf("Subject : %s\n", emails[i].subject);
        printf("Message : %s\n", emails[i].message);
        printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    }
}

int main(){
    Email emails[MAX_EMAILS];
    int numEmails = 0;
    int choice = 0;
    while(choice != 3){
        printMenu();
        if(scanf("%d", &choice) != 1){
            clearBuffer();
            invalidChoice();
            continue;
        }
        clearBuffer();
        switch(choice){
            case 1:
                addEmail(emails, &numEmails);
                break;
            case 2:
                viewInbox(emails, numEmails);
                break;
            case 3:
                printf("Thank you for using Purrfect Email Client. Goodbye!\n\n");
                break;
            default:
                invalidChoice();
                break;
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 printMenu(void); // weak
__int64 clearBuffer(void); // weak
__int64 invalidChoice(void); // weak
__int64 __fastcall addEmail(_QWORD, _QWORD); // weak
__int64 __fastcall viewInbox(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A45) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[22000]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  v4 = 0;
  while ( v4 != 3 )
  {
    printMenu();
    if ( scanf("%d", &v4) == 1 )
    {
      clearBuffer();
      if ( v4 == 3 )
      {
        printf("Thank you for using Purrfect Email Client. Goodbye!\n\n");
      }
      else
      {
        if ( v4 > 3 )
          goto LABEL_12;
        if ( v4 == 1 )
        {
          addEmail(v6, &v5);
        }
        else if ( v4 == 2 )
        {
          viewInbox(v6, v5);
        }
        else
        {
LABEL_12:
          invalidChoice();
        }
      }
    }
    else
    {
      clearBuffer();
      invalidChoice();
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 printMenu(void);
// 140001687: using guessed type __int64 clearBuffer(void);
// 1400016B2: using guessed type __int64 invalidChoice(void);
// 1400016D0: using guessed type __int64 __fastcall addEmail(_QWORD, _QWORD);
// 140001961: using guessed type __int64 __fastcall viewInbox(_QWORD, _QWORD);
// 140001BD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include<stdio.h>

typedef struct{
	int a;
}layer1;

typedef struct{
	layer1 l1;
	float b,c;
}layer2;

typedef struct{
	layer2 l2;
	layer1 l1;
	int d,e;
}layer3;

void showCake(layer3 cake){
	printf("\ncake.d = %d",cake.d);
	printf("\ncake.e = %d",cake.e);
	printf("\ncake.l1.a = %d",cake.l1.a);
	printf("\ncake.l2.b = %f",cake.l2.b);
	printf("\ncake.l2.l1.a = %d",cake.l2.l1.a);
}

int main()
{
	layer3 cake1,cake2;
	
	cake1.d = 1;
	cake1.e = 2;
	cake1.l1.a = 3;
	cake1.l2.b = 4;
	cake1.l2.l1.a = 5;
	
	printf("Cake 1 is : ");
	showCake(cake1);
	
	cake2 = cake1;
	
	cake2.l2.b += cake2.l2.l1.a;
	
	printf("\nCake 2 is : ");
	showCake(cake2);
	
	return 0;
}
`,`#include "deepcopy-1.h"



int _showCake(void)

{
  int iVar1;
  
  _printf("\ncake.d = %d");
  _printf("\ncake.e = %d");
  _printf("\ncake.l1.a = %d");
  _printf("\ncake.l2.b = %f");
  iVar1 = _printf("\ncake.l2.l1.a = %d");
  return iVar1;
}



undefined4 entry(void)

{
  undefined8 local_90;
  undefined8 uStack_88;
  undefined8 local_80;
  undefined8 local_70;
  undefined8 uStack_68;
  undefined8 local_60;
  undefined8 local_50;
  undefined8 uStack_48;
  undefined8 local_40;
  int local_2c;
  float fStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  undefined4 local_1c;
  undefined4 uStack_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_1c = 1;
  uStack_18 = 2;
  uStack_20 = 3;
  fStack_28 = 4.0;
  local_2c = 5;
  _printf("Cake 1 is : ");
  uStack_68 = CONCAT44(uStack_20,uStack_24);
  local_70 = CONCAT44(fStack_28,local_2c);
  local_60 = CONCAT44(uStack_18,local_1c);
  _showCake(&local_70);
  uStack_48 = CONCAT44(uStack_20,uStack_24);
  local_40 = CONCAT44(uStack_18,local_1c);
  local_50 = CONCAT44(fStack_28 + (float)local_2c,local_2c);
  _printf("\nCake 2 is : ");
  uStack_88 = uStack_48;
  local_90 = local_50;
  local_80 = local_40;
  _showCake(&local_90);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Temperature Converter ; Style: invasive
#include <stdio.h>
#include <stdlib.h>

float convert_to_fahrenheit(float celsius);
float convert_to_kelvin(float celsius);

int main()
{
    float celsius, fahrenheit, kelvin;
    char choice;

    do
    {
        system("cls");

        printf("    Celsius to Fahrenheit and Kelvin Converter\n\n");
        printf("Enter the temperature in Celsius: ");
        scanf("%f", &celsius);

        fahrenheit = convert_to_fahrenheit(celsius);
        kelvin = convert_to_kelvin(celsius);

        printf("\n%f Celsius = %f Fahrenheit\n", celsius, fahrenheit);
        printf("%f Celsius = %f Kelvin\n\n", celsius, kelvin);

        printf("Do you want to convert another temperature? (Y/N): ");
        scanf(" %c", &choice);

    } while (choice == 'y' || choice == 'Y');

    return 0;
}

float convert_to_fahrenheit(float celsius)
{
    float fahrenheit = ((9 * celsius) / 5) + 32;
    return fahrenheit;
}

float convert_to_kelvin(float celsius)
{
    float kelvin = celsius + 273.15;
    return kelvin;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
double convert_to_fahrenheit(void); // weak
double convert_to_kelvin(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl system(const char *Command);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  char v6; // [rsp+23h] [rbp-Dh] BYREF
  float v7; // [rsp+24h] [rbp-Ch] BYREF
  float v8; // [rsp+28h] [rbp-8h]
  float v9; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  do
  {
    do
    {
      system("cls");
      printf("    Celsius to Fahrenheit and Kelvin Converter\n\n");
      printf("Enter the temperature in Celsius: ");
      scanf("%f", &v7);
      v3 = _mm_cvtsi32_si128(LODWORD(v7));
      *(double *)v3.m128i_i64 = convert_to_fahrenheit();
      v9 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
      v4 = _mm_cvtsi32_si128(LODWORD(v7));
      *(double *)v4.m128i_i64 = convert_to_kelvin();
      v8 = COERCE_FLOAT(_mm_cvtsi128_si32(v4));
      printf("\n%f Celsius = %f Fahrenheit\n", v7, v9);
      printf("%f Celsius = %f Kelvin\n\n", v7, v8);
      printf("Do you want to convert another temperature? (Y/N): ");
      scanf(" %c", &v6);
    }
    while ( v6 == 121 );
  }
  while ( v6 == 89 );
  return 0;
}
// 140001738: using guessed type double convert_to_fahrenheit(void);
// 140001781: using guessed type double convert_to_kelvin(void);
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>

typedef struct stream_t stream_t, *stream;
struct stream_t {
	/* get function is supposed to return a byte value (0-255),
		or -1 to signify end of input */
	int (*get)(stream);
	/* put function does output, one byte at a time */
	int (*put)(stream, int);
};

/* next two structs inherit from stream_t */
typedef struct {
	int (*get)(stream);
	int (*put)(stream, int);
	char *string;
	int pos;
} string_stream;

typedef struct {
	int (*get)(stream);
	int (*put)(stream, int);
	FILE *fp;
} file_stream;

/* methods for above streams */
int sget(stream in)
{
	int c;
	string_stream* s = (string_stream*) in;
	c = (unsigned char)(s->string[s->pos]);
	if (c == '\0') return -1;
	s->pos++;
	return c;
}

int sput(stream out, int c)
{
	string_stream* s = (string_stream*) out;
	s->string[s->pos++] = (c == -1) ? '\0' : c;
	if (c == -1) s->pos = 0;
	return 0;
}

int file_put(stream out, int c)
{
	file_stream *f = (file_stream*) out;
	return fputc(c, f->fp);
}

/* helper function */
void output(stream out, unsigned char* buf, int len)
{
	int i;
	out->put(out, 128 + len);
	for (i = 0; i < len; i++)
		out->put(out, buf[i]);
}

/* Specification: encoded stream are unsigned bytes consisting of sequences.
 * First byte of each sequence is the length, followed by a number of bytes.
 * If length <=128, the next byte is to be repeated length times;
 * If length > 128, the next (length - 128) bytes are not repeated.
 * this is to improve efficiency for long non-repeating sequences.
 * This scheme can encode arbitrary byte values efficiently.
 * c.f. Adobe PDF spec RLE stream encoding (not exactly the same)
 */
void encode(stream in, stream out)
{
	unsigned char buf[256];
	int len = 0, repeat = 0, end = 0, c;
	int (*get)(stream) = in->get;
	int (*put)(stream, int) = out->put;

	while (!end) {
		end = ((c = get(in)) == -1);
		if (!end) {
			buf[len++] = c;
			if (len <= 1) continue;
		}

		if (repeat) {
			if (buf[len - 1] != buf[len - 2])
				repeat = 0;
			if (!repeat || len == 129 || end) {
				/* write out repeating bytes */
				put(out, end ? len : len - 1);
				put(out, buf[0]);
				buf[0] = buf[len - 1];
				len = 1;
			}
		} else {
			if (buf[len - 1] == buf[len - 2]) {
				repeat = 1;
				if (len > 2) {
					output(out, buf, len - 2);
					buf[0] = buf[1] = buf[len - 1];
					len = 2;
				}
				continue;
			}
			if (len == 128 || end) {
				output(out, buf, len);
				len = 0;
				repeat = 0;
			}
		}
	}
	put(out, -1);
}

void decode(stream in, stream out)
{
	int c, i, cnt;
	while (1) {
		c = in->get(in);
		if (c == -1) return;
		if (c > 128) {
			cnt = c - 128;
			for (i = 0; i < cnt; i++)
				out->put(out, in->get(in));
		} else {
			cnt = c;
			c = in->get(in);
			for (i = 0; i < cnt; i++)
				out->put(out, c);
		}
	}
}

int main()
{
	char buf[256];
	string_stream str_in = { sget, 0,
		"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW", 0};
	string_stream str_out = { sget, sput, buf, 0 };
	file_stream file = { 0, file_put, stdout };

	/* encode from str_in to str_out */
	encode((stream)&str_in, (stream)&str_out);

	/* decode from str_out to file (stdout) */
	decode((stream)&str_out, (stream)&file);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003848(void);
int64_t function_1000038b8(void);
int64_t function_100003948(void);
int64_t function_100003980(void);
int64_t function_1000039b0(int32_t a1, int32_t a2, int64_t a3);
int64_t function_100003a0c(int64_t * a1);
int64_t function_100003ce0(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003d14(void);
int64_t function_100003d3c(int64_t a1, int64_t a2);
int64_t function_100003e04(int32_t a1, int32_t a2);
int64_t function_100003e54(void);
int64_t function_100003f34(int64_t a1);
int32_t function_100003f40(int32_t c, struct _IO_FILE * stream);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _fputc(int32_t a1, struct _IO_FILE * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003848 - 0x1000038b8
int64_t function_100003848(void) {
    // 0x100003848
    int64_t v1; // 0x100003848
    int32_t * v2 = (int32_t *)(v1 + 24); // 0x100003864
    int32_t v3 = *v2; // 0x100003864
    unsigned char v4 = *(char *)(*(int64_t *)(v1 + 16) + (int64_t)v3); // 0x100003868
    int64_t result = 0xffffffff; // 0x10000387c
    if (v4 != 0) {
        // 0x100003890
        *v2 = v3 + 1;
        result = v4;
    }
    // 0x1000038ac
    return result;
}

// Address range: 0x1000038b8 - 0x100003948
int64_t function_1000038b8(void) {
    // 0x1000038b8
    int64_t v1; // 0x1000038b8
    int64_t v2 = v1;
    char v3 = (int32_t)v2 == -1 ? 0 : (char)v2;
    int32_t * v4 = (int32_t *)(v1 + 24); // 0x100003908
    int32_t v5 = *v4; // 0x100003908
    *v4 = v5 + 1;
    *(char *)(*(int64_t *)(v1 + 16) + (int64_t)v5) = v3;
    if ((int32_t)v2 == -1) {
        // 0x100003930
        *v4 = 0;
    }
    // 0x10000393c
    return 0;
}

// Address range: 0x100003948 - 0x100003980
int64_t function_100003948(void) {
    // 0x100003948
    int64_t v1; // 0x100003948
    int64_t v2 = *(int64_t *)(v1 + 16); // 0x10000396c
    return _fputc((int32_t)v1, (struct _IO_FILE *)v2);
}

// Address range: 0x100003980 - 0x1000039b0
int64_t function_100003980(void) {
    // 0x100003980
    int64_t result; // 0x100003980
    return result;
}

// Address range: 0x1000039b0 - 0x100003a0c
int64_t function_1000039b0(int32_t a1, int32_t a2, int64_t a3) {
    int32_t v1 = -a2; // 0x1000039c0
    int64_t result; // 0x1000039b0
    if (v1 < 0 == (v1 & a2) < 0) {
        // 0x100003a00
        return result;
    }
    // 0x1000039d0
    return *(int64_t *)(result - 8);
}

// Address range: 0x100003a0c - 0x100003ce0
int64_t function_100003a0c(int64_t * a1) {
    // 0x100003a0c
    int64_t result; // 0x100003a0c
    return result;
}

// Address range: 0x100003ce0 - 0x100003d14
int64_t function_100003ce0(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003ce0
    int64_t v1; // 0x100003ce0
    int64_t result; // 0x100003ce0
    if (*(int64_t *)*(int64_t *)0x100004008 != *(int64_t *)(v1 - 24)) {
        // 0x100003d00
        result = ___stack_chk_fail(v1);
    }
    // 0x100003d04
    return result;
}

// Address range: 0x100003d14 - 0x100003d3c
int64_t function_100003d14(void) {
    // 0x100003d14
    int64_t result; // 0x100003d14
    return result;
}

// Address range: 0x100003d3c - 0x100003e04
int64_t function_100003d3c(int64_t a1, int64_t a2) {
    // 0x100003d3c
    int64_t result; // 0x100003d3c
    int32_t v1 = result; // 0x100003d3c
    *(int32_t *)(result - 20) = v1;
    if (v1 == -1) {
        // 0x100003d54
        return result;
    }
    int32_t v2 = v1 - 128; // 0x100003d64
    if (v2 == 0 || v2 < 0 != (127 - v1 & v1) < 0) {
        // 0x100003dec
        return *(int64_t *)(result - 8);
    }
    int32_t v3 = 128 - v1; // 0x100003d90
    if (v3 < 0 == (v2 & v3) < 0) {
        // 0x100003de8
        return function_100003e54();
    }
    // 0x100003da0
    return *(int64_t *)(result - 8);
}

// Address range: 0x100003e04 - 0x100003e54
int64_t function_100003e04(int32_t a1, int32_t a2) {
    // 0x100003e04
    int64_t v1; // 0x100003e04
    *(int32_t *)(v1 - 20) = (int32_t)v1;
    int32_t v2 = -a1; // 0x100003e18
    if (v2 < 0 == (v2 & a1) < 0) {
        // 0x100003e50
        return function_100003e54();
    }
    // 0x100003e28
    return *(int64_t *)(v1 - 16);
}

// Address range: 0x100003e54 - 0x100003e58
int64_t function_100003e54(void) {
    // 0x100003e54
    int64_t result; // 0x100003e54
    return result;
}

// Address range: 0x100003e58 - 0x100003f34
int64_t entry_point(void) {
    int64_t v1 = 0x100003848; // bp-368, 0x100003ea8
    function_100003a0c(&v1);
    int64_t v2 = function_100003d14(); // 0x100003ef8
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f08
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f1c
        ___stack_chk_fail(v2);
    }
    // 0x100003f20
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
int64_t function_100003f34(int64_t a1) {
    // 0x100003f34
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(int32_t c, struct _IO_FILE * stream) {
    // 0x100003f40
    return _fputc(c, stream);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 14

`
`#include <stdio.h>

void recurse(unsigned int i)
{
  printf("%d\n", i);
  recurse(i+1); // 523756
}

int main()
{
  recurse(0);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f28(void);
int32_t function_100003f98(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f28 - 0x100003f6c
int64_t function_100003f28(void) {
    // 0x100003f28
    int64_t v1; // 0x100003f28
    _printf("%d\n", v1);
    return function_100003f28();
}

// Address range: 0x100003f6c - 0x100003f98
int64_t entry_point(void) {
    // 0x100003f6c
    function_100003f28();
    return 0;
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(char * format, ...) {
    // 0x100003f98
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include<string.h>
#include<stdlib.h>
#include<stdio.h>

#define COLLAPSE 0
#define SQUEEZE 1

typedef struct charList{
    char c;
    struct charList *next;
} charList;

/*
Implementing strcmpi, the case insensitive string comparator, as it is not part of the C Standard Library.

Comment this out if testing on a compiler where it is already defined.
*/

int strcmpi(char* str1,char* str2){
    int len1 = strlen(str1), len2 = strlen(str2), i;

    if(len1!=len2){
        return 1;
    }

    else{
        for(i=0;i<len1;i++){
            if((str1[i]>='A'&&str1[i]<='Z')&&(str2[i]>='a'&&str2[i]<='z')&&(str2[i]-65!=str1[i]))
                return 1;
            else if((str2[i]>='A'&&str2[i]<='Z')&&(str1[i]>='a'&&str1[i]<='z')&&(str1[i]-65!=str2[i]))
                return 1;
            else if(str1[i]!=str2[i])
                return 1;
        }
    }

    return 0;
}

charList *strToCharList(char* str){
    int len = strlen(str),i;

    charList *list, *iterator, *nextChar;

    list = (charList*)malloc(sizeof(charList));
    list->c = str[0];
    list->next = NULL;

    iterator = list;

    for(i=1;i<len;i++){
        nextChar = (charList*)malloc(sizeof(charList));
        nextChar->c = str[i];
        nextChar->next = NULL;

        iterator->next = nextChar;
        iterator = nextChar;
    }

    return list;
}

char* charListToString(charList* list){
    charList* iterator = list;
    int count = 0,i;
    char* str;

    while(iterator!=NULL){
        count++;
        iterator = iterator->next;
    }

    str = (char*)malloc((count+1)*sizeof(char));
    iterator = list;

    for(i=0;i<count;i++){
        str[i] = iterator->c;
        iterator = iterator->next;
    }

    free(list);
    str[i] = '\0';

    return str;
}

char* processString(char str[100],int operation, char squeezeChar){
    charList *strList = strToCharList(str),*iterator = strList, *scout;

    if(operation==SQUEEZE){
        while(iterator!=NULL){
            if(iterator->c==squeezeChar){
                scout = iterator->next;

                while(scout!=NULL && scout->c==squeezeChar){
                        iterator->next = scout->next;
                        scout->next = NULL;
                        free(scout);
                        scout = iterator->next;
                }
            }
            iterator = iterator->next;
        }
    }

    else{
        while(iterator!=NULL && iterator->next!=NULL){
            if(iterator->c == (iterator->next)->c){
                scout = iterator->next;
                squeezeChar = iterator->c;

                while(scout!=NULL && scout->c==squeezeChar){
                        iterator->next = scout->next;
                        scout->next = NULL;
                        free(scout);
                        scout = iterator->next;
                }
            }
            iterator = iterator->next;
        }
    }

    return charListToString(strList);
}

void printResults(char originalString[100], char finalString[100], int operation, char squeezeChar){
    if(operation==SQUEEZE){
        printf("Specified Operation : SQUEEZE\nTarget Character : %c",squeezeChar);
    }

    else
        printf("Specified Operation : COLLAPSE");

    printf("\nOriginal %c%c%c%s%c%c%c\nLength : %d",174,174,174,originalString,175,175,175,(int)strlen(originalString));
    printf("\nFinal    %c%c%c%s%c%c%c\nLength : %d\n",174,174,174,finalString,175,175,175,(int)strlen(finalString));
}

int main(int argc, char** argv){
    int operation;
    char squeezeChar;

    if(argc<3||argc>4){
        printf("Usage : %s <SQUEEZE|COLLAPSE> <String to be processed> <Character to be squeezed, if operation is SQUEEZE>\n",argv[0]);
        return 0;
    }

    if(strcmpi(argv[1],"SQUEEZE")==0 && argc!=4){
        scanf("Please enter characted to be squeezed : %c",&squeezeChar);
        operation = SQUEEZE;
    }

    else if(argc==4){
        operation = SQUEEZE;
        squeezeChar = argv[3][0];
    }

    else if(strcmpi(argv[1],"COLLAPSE")==0){
        operation = COLLAPSE;
    }

    if(strlen(argv[2])<2){
        printResults(argv[2],argv[2],operation,squeezeChar);
    }

    else{
        printResults(argv[2],processString(argv[2],operation,squeezeChar),operation,squeezeChar);
    }

    return 0;
}
`,`#include "determine-if-a-string-is-collapsible.h"



undefined4 _strcmpi(char *param_1,char *param_2)

{
  size_t sVar1;
  size_t sVar2;
  int local_34;
  undefined4 local_14;
  
  sVar1 = _strlen(param_1);
  sVar2 = _strlen(param_2);
  if ((int)sVar1 == (int)sVar2) {
    for (local_34 = 0; local_34 < (int)sVar1; local_34 = local_34 + 1) {
      if (((('@' < param_1[local_34]) && (param_1[local_34] < '[')) && ('' < param_2[local_34])) &&
         ((param_2[local_34] < '{' && (param_2[local_34] + -0x41 != (int)param_1[local_34])))) {
        return 1;
      }
      if ((('@' < param_2[local_34]) && (param_2[local_34] < '[')) &&
         (('' < param_1[local_34] &&
          ((param_1[local_34] < '{' && (param_1[local_34] + -0x41 != (int)param_2[local_34])))))) {
        return 1;
      }
      if (param_1[local_34] != param_2[local_34]) {
        return 1;
      }
    }
    local_14 = 0;
  }
  else {
    local_14 = 1;
  }
  return local_14;
}



char * _strToCharList(char *param_1)

{
  size_t sVar1;
  char *pcVar2;
  char *pcVar3;
  char *local_30;
  int local_20;
  
  sVar1 = _strlen(param_1);
  pcVar2 = (char *)_malloc(0x10);
  *pcVar2 = *param_1;
  pcVar2[8] = '\0';
  pcVar2[9] = '\0';
  pcVar2[10] = '\0';
  pcVar2[0xb] = '\0';
  pcVar2[0xc] = '\0';
  pcVar2[0xd] = '\0';
  pcVar2[0xe] = '\0';
  pcVar2[0xf] = '\0';
  local_30 = pcVar2;
  for (local_20 = 1; local_20 < (int)sVar1; local_20 = local_20 + 1) {
    pcVar3 = (char *)_malloc(0x10);
    *pcVar3 = param_1[local_20];
    pcVar3[8] = '\0';
    pcVar3[9] = '\0';
    pcVar3[10] = '\0';
    pcVar3[0xb] = '\0';
    pcVar3[0xc] = '\0';
    pcVar3[0xd] = '\0';
    pcVar3[0xe] = '\0';
    pcVar3[0xf] = '\0';
    *(char **)(local_30 + 8) = pcVar3;
    local_30 = pcVar3;
  }
  return pcVar2;
}



void * _charListToString(undefined *param_1)

{
  void *pvVar1;
  int local_28;
  int local_24;
  undefined *local_20;
  
  local_24 = 0;
  for (local_20 = param_1; local_20 != (undefined *)0x0; local_20 = *(undefined **)(local_20 + 8)) {
    local_24 = local_24 + 1;
  }
  pvVar1 = _malloc((long)(local_24 + 1));
  local_20 = param_1;
  for (local_28 = 0; local_28 < local_24; local_28 = local_28 + 1) {
    *(undefined *)((long)pvVar1 + (long)local_28) = *local_20;
    local_20 = *(undefined **)(local_20 + 8);
  }
  _free(param_1);
  *(undefined *)((long)pvVar1 + (long)local_28) = 0;
  return pvVar1;
}



void _processString(undefined8 param_1,int param_2,byte param_3)

{
  byte bVar1;
  bool bVar2;
  byte *pbVar3;
  char *local_38;
  byte *local_30;
  
  pbVar3 = (byte *)_strToCharList(param_1);
  local_30 = pbVar3;
  if (param_2 == 1) {
    for (; local_30 != (byte *)0x0; local_30 = *(byte **)(local_30 + 8)) {
      if ((int)(char)*local_30 == (uint)param_3) {
        local_38 = *(char **)(local_30 + 8);
        while( true ) {
          bVar2 = false;
          if (local_38 != (char *)0x0) {
            bVar2 = (int)*local_38 == (uint)param_3;
          }
          if (!bVar2) break;
          *(undefined8 *)(local_30 + 8) = *(undefined8 *)(local_38 + 8);
          local_38[8] = '\0';
          local_38[9] = '\0';
          local_38[10] = '\0';
          local_38[0xb] = '\0';
          local_38[0xc] = '\0';
          local_38[0xd] = '\0';
          local_38[0xe] = '\0';
          local_38[0xf] = '\0';
          _free(local_38);
          local_38 = *(char **)(local_30 + 8);
        }
      }
    }
  }
  else {
    while( true ) {
      bVar2 = false;
      if (local_30 != (byte *)0x0) {
        bVar2 = *(long *)(local_30 + 8) != 0;
      }
      if (!bVar2) break;
      if (*local_30 == **(byte **)(local_30 + 8)) {
        local_38 = *(char **)(local_30 + 8);
        bVar1 = *local_30;
        while( true ) {
          bVar2 = false;
          if (local_38 != (char *)0x0) {
            bVar2 = (int)*local_38 == (uint)bVar1;
          }
          if (!bVar2) break;
          *(undefined8 *)(local_30 + 8) = *(undefined8 *)(local_38 + 8);
          local_38[8] = '\0';
          local_38[9] = '\0';
          local_38[10] = '\0';
          local_38[0xb] = '\0';
          local_38[0xc] = '\0';
          local_38[0xd] = '\0';
          local_38[0xe] = '\0';
          local_38[0xf] = '\0';
          _free(local_38);
          local_38 = *(char **)(local_30 + 8);
        }
      }
      local_30 = *(byte **)(local_30 + 8);
    }
  }
  _charListToString(pbVar3);
  return;
}



int _printResults(char *param_1,char *param_2,int param_3)

{
  int iVar1;
  
  if (param_3 == 1) {
    _printf("Specified Operation : SQUEEZE\nTarget Character : %c");
  }
  else {
    _printf("Specified Operation : COLLAPSE");
  }
  _strlen(param_1);
  _printf("\nOriginal %c%c%c%s%c%c%c\nLength : %d");
  _strlen(param_2);
  iVar1 = _printf("\nFinal    %c%c%c%s%c%c%c\nLength : %d\n");
  return iVar1;
}



undefined4 entry(int param_1,long param_2)

{
  int iVar1;
  size_t sVar2;
  undefined8 uVar3;
  undefined8 uVar4;
  undefined local_25;
  undefined4 local_24;
  
  if ((param_1 < 3) || (4 < param_1)) {
    _printf(
           "Usage : %s <SQUEEZE|COLLAPSE> <String to be processed> <Character to be squeezed, if operation is SQUEEZE>\n"
           );
  }
  else {
    iVar1 = _strcmpi(*(undefined8 *)(param_2 + 8),"SQUEEZE");
    if ((iVar1 == 0) && (param_1 != 4)) {
      _scanf("Please enter characted to be squeezed : %c");
      local_24 = 1;
    }
    else if (param_1 == 4) {
      local_24 = 1;
      local_25 = **(undefined **)(param_2 + 0x18);
    }
    else {
      iVar1 = _strcmpi(*(undefined8 *)(param_2 + 8),"COLLAPSE");
      if (iVar1 == 0) {
        local_24 = 0;
      }
    }
    sVar2 = _strlen(*(char **)(param_2 + 0x10));
    if (sVar2 < 2) {
      _printResults(*(undefined8 *)(param_2 + 0x10),*(undefined8 *)(param_2 + 0x10),local_24,
                    local_25);
    }
    else {
      uVar4 = *(undefined8 *)(param_2 + 0x10);
      uVar3 = _processString(*(undefined8 *)(param_2 + 0x10),local_24,local_25);
      _printResults(uVar4,uVar3,local_24,local_25);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e38. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e5c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004020)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

double median(double *x, int start, int end_inclusive) {
    int size = end_inclusive - start + 1;
    if (size <= 0) {
        printf("Array slice cannot be empty\n");
        exit(1);
    }
    int m = start + size / 2;
    if (size % 2) return x[m];
    return (x[m - 1] + x[m]) / 2.0;
}

int compare (const void *a, const void *b) {
    double aa = *(double*)a;
    double bb = *(double*)b;
    if (aa > bb) return 1;
    if (aa < bb) return -1;
    return 0;
}

int fivenum(double *x, double *result, int x_len) {
    int i, m, lower_end;
    for (i = 0; i < x_len; i++) {
        if (x[i] != x[i]) {
           printf("Unable to deal with arrays containing NaN\n\n");
           return 1;
        }
    }
    qsort(x, x_len, sizeof(double), compare);
    result[0] = x[0];
    result[2] = median(x, 0, x_len - 1);
    result[4] = x[x_len - 1];
    m = x_len / 2;
    lower_end = (x_len % 2) ? m : m - 1;
    result[1] = median(x, 0, lower_end);
    result[3] = median(x, m, x_len - 1);
    return 0;
}

int show(double *result, int places) {
    int i;
    char f[7];
    sprintf(f, "%%.%dlf", places);
    printf("[");
    for (i = 0; i < 5; i++) {
        printf(f, result[i]);
        if (i < 4) printf(", ");
    }
    printf("]\n\n");
}

int main() {
    double result[5];

    double x1[11] = {15.0, 6.0, 42.0, 41.0, 7.0, 36.0, 49.0, 40.0, 39.0, 47.0, 43.0};
    if (!fivenum(x1, result, 11)) show(result, 1);

    double x2[6] = {36.0, 40.0, 7.0, 39.0, 41.0, 15.0};
    if (!fivenum(x2, result, 6)) show(result, 1);

    double x3[20] = {
         0.14082834,  0.09748790,  1.73131507,  0.87636009, -1.95059594,  0.73438555,
        -0.03035726,  1.46675970, -0.74621349, -0.72588772,  0.63905160,  0.61501527,
        -0.98983780, -1.00447874, -0.62759469,  0.66206163,  1.04312009, -0.10305385,
         0.75775634,  0.32566578
    };
    if (!fivenum(x3, result, 20)) show(result, 9);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003894(void);
int64_t function_100003974(void);
int64_t function_1000039f4(void);
int64_t function_100003b7c(void);
int64_t function_100003dcc(int64_t * a1, int64_t a2, int64_t a3, char * a4);
int64_t function_100003dd8(int64_t a1);
void function_100003de4(int32_t status);
int64_t * function_100003df0(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003dfc(int64_t * s, int32_t c, int32_t n);
int32_t function_100003e08(char * format, ...);
void function_100003e14(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));

// --------------------- Global Variables ---------------------

float64_t g1 = 41.0; // 0x100003e20
float64_t g2 = 39.0; // 0x100003e28
float64_t g3 = 40.0; // 0x100003e30
float64_t g4 = 36.0; // 0x100003e38
int64_t g5 = 0x402e000000000000; // 0x100003e40
int64_t g6 = 0x3fc206a9bd53322c; // 0x100003e98

// ------- Dynamically Linked Functions Without Header --------

int64_t ___sprintf_chk(int64_t * a1, int64_t a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));

// ------------------------ Functions -------------------------

// Address range: 0x100003894 - 0x100003974
int64_t function_100003894(void) {
    // 0x100003894
    int64_t result; // 0x100003894
    if ((int32_t)result + 1 - (int32_t)result >= 1) {
        // 0x1000038e8
        return result;
    }
    // 0x1000038d4
    _printf("Array slice cannot be empty\n");
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x100003974 - 0x1000039f4
int64_t function_100003974(void) {
    // 0x100003974
    int64_t v1; // 0x100003974
    int64_t v2 = v1;
    int64_t v3 = v1;
    if ((float64_t)v3 == (float64_t)v2) {
        // 0x1000039bc
        return (float64_t)v3 > (float64_t)v2 ? 0xffffffff : 0;
    }
    if ((float64_t)v3 > (float64_t)v2 == (float64_t)v3 >= (float64_t)v2 == (float64_t)v3 <= (float64_t)v2) {
        // 0x1000039e8
        return 1;
    }
    // 0x1000039bc
    return (float64_t)v3 > (float64_t)v2 ? 0xffffffff : 0;
}

// Address range: 0x1000039f4 - 0x100003b7c
int64_t function_1000039f4(void) {
    // 0x1000039f4
    int64_t v1; // 0x1000039f4
    int32_t v2 = v1; // 0x100003a08
    int32_t v3 = -v2; // 0x100003a1c
    int32_t v4 = 0; // 0x100003a24
    if (v3 < 0 != (v3 & v2) < 0) {
        float64_t v5 = *(float64_t *)(8 * (int64_t)v4 + v1); // 0x100003a34
        while (v5 == v5 && 0.0 == 0.0) {
            // 0x100003a14
            v4++;
            int32_t v6 = v4 - v2; // 0x100003a1c
            if (v6 < 0 == ((v6 ^ v4) & (v4 ^ v2)) < 0) {
                goto lab_0x100003a80;
            }
            v5 = *(float64_t *)(8 * (int64_t)v4 + v1);
        }
        // 0x100003a50
        _printf("Unable to deal with arrays containing NaN\n\n");
        // 0x100003b6c
        return 1;
    }
  lab_0x100003a80:
    // 0x100003a80
    _qsort((int64_t *)v1, v2, 8, (int32_t (*)(int64_t *, int64_t *))0x100003974);
    *(float64_t *)v1 = (float64_t)v1;
    function_100003894();
    *(float64_t *)(v1 + 16) = (float64_t)v1;
    int64_t v7 = *(int64_t *)((8 * v1 + 0xfffffff8 & 0xfffffff8) + v1);
    float64_t v8 = v7;
    *(int64_t *)(v1 + 32) = v7;
    function_100003894();
    *(int64_t *)(v1 + 8) = (int64_t)v8;
    function_100003894();
    *(int64_t *)(v1 + 24) = (int64_t)v8;
    // 0x100003b6c
    return 0;
}

// Address range: 0x100003b7c - 0x100003c50
int64_t function_100003b7c(void) {
    // 0x100003b7c
    int64_t v1; // bp-47, 0x100003b7c
    ___sprintf_chk(&v1, 0, 7, "%%.%dlf");
    _printf("[");
    for (int32_t i = 0; i < 5; i++) {
        // 0x100003be0
        _printf((char *)&v1);
        if (i < 4) {
            // 0x100003c10
            _printf(", ");
        }
    }
    // 0x100003c34
    _printf("]\n\n");
    int32_t v2; // 0x100003b7c
    return (uint32_t)v2;
}

// Address range: 0x100003c50 - 0x100003dcc
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c70
    int64_t v2; // bp-168, 0x100003c50
    _memcpy(&v2, &g5, 88);
    if ((int32_t)function_1000039f4() == 0) {
        // 0x100003cb4
        function_100003b7c();
    }
    // 0x100003cc4
    int64_t v3; // bp-216, 0x100003c50
    _memset(&v3, 0, 48);
    int64_t v4 = &v3; // 0x100003cdc
    v3 = g4;
    *(int64_t *)(v4 + 8) = (int64_t)g3;
    *(float64_t *)(v4 + 16) = 7.0;
    *(int64_t *)(v4 + 24) = (int64_t)g2;
    *(int64_t *)(v4 + 32) = (int64_t)g1;
    *(float64_t *)(v4 + 40) = 15.0;
    if ((int32_t)function_1000039f4() == 0) {
        // 0x100003d3c
        function_100003b7c();
    }
    // 0x100003d4c
    int64_t v5; // bp-376, 0x100003c50
    _memcpy(&v5, &g6, 160);
    int64_t v6 = function_1000039f4(); // 0x100003d70
    int64_t v7 = v6; // 0x100003d7c
    if ((int32_t)v6 == 0) {
        // 0x100003d84
        v7 = function_100003b7c();
    }
    // 0x100003d94
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003db4
        ___stack_chk_fail(v7);
    }
    // 0x100003db8
    return 0;
}

// Address range: 0x100003dcc - 0x100003dd8
int64_t function_100003dcc(int64_t * a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003dcc
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003dd8 - 0x100003de4
int64_t function_100003dd8(int64_t a1) {
    // 0x100003dd8
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003de4 - 0x100003df0
void function_100003de4(int32_t status) {
    // 0x100003de4
    _exit(status);
}

// Address range: 0x100003df0 - 0x100003dfc
int64_t * function_100003df0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003df0
    return _memcpy(dest, src, n);
}

// Address range: 0x100003dfc - 0x100003e08
int64_t * function_100003dfc(int64_t * s, int32_t c, int32_t n) {
    // 0x100003dfc
    return _memset(s, c, n);
}

// Address range: 0x100003e08 - 0x100003e14
int32_t function_100003e08(char * format, ...) {
    // 0x100003e08
    return _printf(format);
}

// Address range: 0x100003e14 - 0x100003e20
void function_100003e14(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003e14
    _qsort(base, nmemb, size, compar);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>

typedef unsigned uint;
uint is_pern(uint n)
{
        uint c = 2693408940u; // int with all prime-th bits set
        while (n) c >>= 1, n &= (n - 1); // take out lowerest set bit one by one
        return c & 1;
}

int main(void)
{
        uint i, c;
        for (i = c = 0; c < 25; i++)
                if (is_pern(i))
                        printf("%u ", i), ++c;
        putchar('\n');

        for (i = 888888877u; i <= 888888888u; i++)
                if (is_pern(i))
                        printf("%u ", i);
        putchar('\n');

        return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e04(void);
int32_t function_100003f84(char * format, ...);
int32_t function_100003f90(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e04 - 0x100003e64
int64_t function_100003e04(void) {
    // 0x100003e04
    int64_t v1; // 0x100003e04
    int32_t v2 = v1; // 0x100003e08
    if (v2 == 0) {
        // 0x100003e54
        return 0;
    }
    uint32_t v3 = -0x5f75d754; // 0x100003e28
    int32_t v4 = v2;
    v3 /= 2;
    int32_t v5 = v4 - 1 & v4; // 0x100003e48
    while (v5 != 0) {
        // 0x100003e30
        v4 = v5;
        v3 /= 2;
        v5 = v4 - 1 & v4;
    }
    // 0x100003e54
    return v3 % 2;
}

// Address range: 0x100003e64 - 0x100003f84
int64_t entry_point(void) {
    // 0x100003e64
    int64_t v1; // 0x100003e64
    int32_t v2 = v1;
    int32_t v3 = 0;
    int32_t v4 = v3; // 0x100003ea4
    if ((int32_t)function_100003e04() != 0) {
        // 0x100003eac
        _printf("%u ", v2);
        v4 = v3 + 1;
    }
    // 0x100003edc
    while (v4 < 25) {
        // 0x100003e94
        v3 = v4;
        v4 = v3;
        if ((int32_t)function_100003e04() != 0) {
            // 0x100003eac
            _printf("%u ", v2);
            v4 = v3 + 1;
        }
    }
    // 0x100003eec
    _putchar(10);
    for (int32_t i = 0x34fb5e2d; i < 0x34fb5e39; i++) {
        // 0x100003f20
        if ((int32_t)function_100003e04() != 0) {
            // 0x100003f38
            _printf("%u ", v2);
        }
    }
    // 0x100003f6c
    _putchar(10);
    return 0;
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(int32_t c) {
    // 0x100003f90
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

/* The language task, implemented with pthreads for POSIX systems. */

/* Each rendezvous_t will be accepted by a single thread, and entered
 * by one or more threads.  accept_func() only returns an integer and
 * is always run within the entering thread's context to simplify
 * handling the arguments and return value.  This somewhat unlike an
 * Ada rendezvous and is a subset of the Ada rendezvous functionality.
 * Ada's in and out parameters can be simulated via the void pointer
 * passed to accept_func() to update variables owned by both the
 * entering and accepting threads, if a suitable struct with pointers
 * to those variables is used. */
typedef struct rendezvous {
    pthread_mutex_t lock;        /* A mutex/lock to use with the CVs.        */
    pthread_cond_t cv_entering;  /* Signaled when a thread enters.           */
    pthread_cond_t cv_accepting; /* Signaled when accepting thread is ready. */
    pthread_cond_t cv_done;      /* Signaled when accept_func() finishes.    */
    int (*accept_func)(void*);   /* The function to run when accepted.       */
    int entering;                /* Number of threads trying to enter.       */
    int accepting;               /* True if the accepting thread is ready.   */
    int done;                    /* True if accept_func() is done.           */
} rendezvous_t;

/* Static initialization for rendezvous_t. */
#define RENDEZVOUS_INITILIZER(accept_function) {   \
        .lock         = PTHREAD_MUTEX_INITIALIZER, \
        .cv_entering  = PTHREAD_COND_INITIALIZER,  \
        .cv_accepting = PTHREAD_COND_INITIALIZER,  \
        .cv_done      = PTHREAD_COND_INITIALIZER,  \
        .accept_func  = accept_function,           \
        .entering     = 0,                         \
        .accepting    = 0,                         \
        .done         = 0,                         \
    }

int enter_rendezvous(rendezvous_t *rv, void* data)
{
    /* Arguments are passed in and out of the rendezvous via
     * (void*)data, and the accept_func() return value is copied and
     * returned to the caller (entering thread).  A data struct with
     * pointers to variables in both the entering and accepting
     * threads can be used to simulate Ada's in and out parameters, if
     * needed. */
    pthread_mutex_lock(&rv->lock);

    rv->entering++;
    pthread_cond_signal(&rv->cv_entering);

    while (!rv->accepting) {
        /* Nothing is accepting yet, keep waiting.  pthreads will
         * queue all waiting entries.  The loop is needed to handle
         * both race conditions and spurious wakeups. */
        pthread_cond_wait(&rv->cv_accepting, &rv->lock);
    }

    /* Call accept_func() and copy the return value before leaving
     * the mutex. */
    int ret = rv->accept_func(data);

    /* This signal is needed so that the accepting thread will wait
     * for the rendezvous to finish before trying to accept again. */
    rv->done = 1;
    pthread_cond_signal(&rv->cv_done);

    rv->entering--;
    rv->accepting = 0;
    pthread_mutex_unlock(&rv->lock);

    return ret;
}

void accept_rendezvous(rendezvous_t *rv)
{
    /* This accept function does not take in or return parameters.
     * That is handled on the entry side.  This is only for
     * synchronization. */
    pthread_mutex_lock(&rv->lock);
    rv->accepting = 1;

    while (!rv->entering) {
        /* Nothing to accept yet, keep waiting. */
        pthread_cond_wait(&rv->cv_entering, &rv->lock);
    }

    pthread_cond_signal(&rv->cv_accepting);

    while (!rv->done) {
        /* Wait for accept_func() to finish. */
        pthread_cond_wait(&rv->cv_done, &rv->lock);
    }
    rv->done = 0;

    rv->accepting = 0;
    pthread_mutex_unlock(&rv->lock);
}

/* The printer use case task implemented using the above rendezvous
 * implementation.  Since C doesn't have exceptions, return values are
 * used to signal out of ink errors. */

typedef struct printer {
    rendezvous_t rv;
    struct printer *backup;
    int id;
    int remaining_lines;
} printer_t;

typedef struct print_args {
    struct printer *printer;
    const char* line;
} print_args_t;

int print_line(printer_t *printer, const char* line) {
    print_args_t args;
    args.printer = printer;
    args.line = line;
    return enter_rendezvous(&printer->rv, &args);
}

int accept_print(void* data) {
    /* This is called within the rendezvous, so everything is locked
     * and okay to modify. */
    print_args_t *args = (print_args_t*)data;
    printer_t *printer = args->printer;
    const char* line = args->line;

    if (printer->remaining_lines) {
        /* Print the line, character by character. */
        printf("%d: ", printer->id);
        while (*line != '\0') {
            putchar(*line++);
        }
        putchar('\n');
        printer->remaining_lines--;
        return 1;
    }
    else if (printer->backup) {
        /* "Requeue" this rendezvous with the backup printer. */
        return print_line(printer->backup, line);
    }
    else {
        /* Out of ink, and no backup available. */
        return -1;
    }
}

printer_t backup_printer = {
    .rv = RENDEZVOUS_INITILIZER(accept_print),
    .backup = NULL,
    .id = 2,
    .remaining_lines = 5,
};

printer_t main_printer = {
    .rv = RENDEZVOUS_INITILIZER(accept_print),
    .backup = &backup_printer,
    .id = 1,
    .remaining_lines = 5,
};

void* printer_thread(void* thread_data) {
    printer_t *printer = (printer_t*) thread_data;
    while (1) {
        accept_rendezvous(&printer->rv);
    }
}

typedef struct poem {
    char* name;
    char* lines[];
} poem_t;

poem_t humpty_dumpty = {
    .name = "Humpty Dumpty",
    .lines = {
        "Humpty Dumpty sat on a wall.",
        "Humpty Dumpty had a great fall.",
        "All the king's horses and all the king's men",
        "Couldn't put Humpty together again.",
        ""
    },
};

poem_t mother_goose = {
    .name = "Mother Goose",
    .lines = {
        "Old Mother Goose",
        "When she wanted to wander,",
        "Would ride through the air",
        "On a very fine gander.",
        "Jack's mother came in,",
        "And caught the goose soon,",
        "And mounting its back,",
        "Flew up to the moon.",
        ""
    },
};

void* poem_thread(void* thread_data) {
    poem_t *poem = (poem_t*)thread_data;

    for (unsigned i = 0; poem->lines[i] != ""; i++) {
        int ret = print_line(&main_printer, poem->lines[i]);
        if (ret < 0) {
            printf("      %s out of ink!\n", poem->name);
            exit(1);
        }
    }
    return NULL;
}

int main(void)
{
    pthread_t threads[4];

    pthread_create(&threads[0], NULL, poem_thread,    &humpty_dumpty);
    pthread_create(&threads[1], NULL, poem_thread,    &mother_goose);
    pthread_create(&threads[2], NULL, printer_thread, &main_printer);
    pthread_create(&threads[3], NULL, printer_thread, &backup_printer);

    pthread_join(threads[0], NULL);
    pthread_join(threads[1], NULL);
    pthread_cancel(threads[2]);
    pthread_cancel(threads[3]);

    return 0;
}
`,`#include "rendezvous-1.h"



undefined4 _enter_rendezvous(pthread_mutex_t *param_1,undefined8 param_2)

{
  undefined4 uVar1;
  
  _pthread_mutex_lock(param_1);
  *(int *)(param_1[3].__opaque + 0x10) = *(int *)(param_1[3].__opaque + 0x10) + 1;
  _pthread_cond_signal((pthread_cond_t *)(param_1 + 1));
  while (*(int *)(param_1[3].__opaque + 0x14) == 0) {
    _pthread_cond_wait((pthread_cond_t *)(param_1[1].__opaque + 0x28),param_1);
  }
  uVar1 = (**(code **)(param_1[3].__opaque + 8))(param_2);
  param_1[3].__opaque[0x18] = '\x01';
  param_1[3].__opaque[0x19] = '\0';
  param_1[3].__opaque[0x1a] = '\0';
  param_1[3].__opaque[0x1b] = '\0';
  _pthread_cond_signal((pthread_cond_t *)(param_1[2].__opaque + 0x18));
  *(int *)(param_1[3].__opaque + 0x10) = *(int *)(param_1[3].__opaque + 0x10) + -1;
  param_1[3].__opaque[0x14] = '\0';
  param_1[3].__opaque[0x15] = '\0';
  param_1[3].__opaque[0x16] = '\0';
  param_1[3].__opaque[0x17] = '\0';
  _pthread_mutex_unlock(param_1);
  return uVar1;
}



int _accept_rendezvous(pthread_mutex_t *param_1)

{
  int iVar1;
  
  _pthread_mutex_lock(param_1);
  param_1[3].__opaque[0x14] = '\x01';
  param_1[3].__opaque[0x15] = '\0';
  param_1[3].__opaque[0x16] = '\0';
  param_1[3].__opaque[0x17] = '\0';
  while (*(int *)(param_1[3].__opaque + 0x10) == 0) {
    _pthread_cond_wait((pthread_cond_t *)(param_1 + 1),param_1);
  }
  _pthread_cond_signal((pthread_cond_t *)(param_1[1].__opaque + 0x28));
  while (*(int *)(param_1[3].__opaque + 0x18) == 0) {
    _pthread_cond_wait((pthread_cond_t *)(param_1[2].__opaque + 0x18),param_1);
  }
  param_1[3].__opaque[0x18] = '\0';
  param_1[3].__opaque[0x19] = '\0';
  param_1[3].__opaque[0x1a] = '\0';
  param_1[3].__opaque[0x1b] = '\0';
  param_1[3].__opaque[0x14] = '\0';
  param_1[3].__opaque[0x15] = '\0';
  param_1[3].__opaque[0x16] = '\0';
  param_1[3].__opaque[0x17] = '\0';
  iVar1 = _pthread_mutex_unlock(param_1);
  return iVar1;
}



void _print_line(undefined8 param_1,undefined8 param_2)

{
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  undefined8 local_18;
  
  local_30 = param_1;
  local_28 = param_2;
  local_20 = param_2;
  local_18 = param_1;
  _enter_rendezvous(param_1,&local_30);
  return;
}



undefined4 _accept_print(long *param_1)

{
  long lVar1;
  char *local_38;
  undefined4 local_14;
  
  lVar1 = *param_1;
  local_38 = (char *)param_1[1];
  if (*(int *)(lVar1 + 0xf4) == 0) {
    if (*(long *)(lVar1 + 0xe8) == 0) {
      local_14 = 0xffffffff;
    }
    else {
      local_14 = _print_line(*(undefined8 *)(lVar1 + 0xe8),local_38);
    }
  }
  else {
    _printf("%d: ");
    while (*local_38 != '\0') {
      _putchar((int)*local_38);
      local_38 = local_38 + 1;
    }
    _putchar(10);
    *(int *)(lVar1 + 0xf4) = *(int *)(lVar1 + 0xf4) + -1;
    local_14 = 1;
  }
  return local_14;
}



void _printer_thread(undefined8 param_1)

{
  do {
    _accept_rendezvous(param_1);
  } while( true );
}



undefined8 _poem_thread(long param_1)

{
  int iVar1;
  uint local_24;
  
  local_24 = 0;
  while( true ) {
    if (*(char **)(param_1 + 8 + (ulong)local_24 * 8) == "") {
      return 0;
    }
    iVar1 = _print_line(&_main_printer,*(undefined8 *)(param_1 + 8 + (ulong)local_24 * 8));
    if (iVar1 < 0) break;
    local_24 = local_24 + 1;
  }
  _printf("      %s out of ink!\n");
                    // WARNING: Subroutine does not return
  _exit(1);
}



undefined8 entry(void)

{
  int iVar1;
  pthread_t local_38;
  pthread_t local_30;
  pthread_t local_28;
  pthread_t local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _pthread_create(&local_38,(pthread_attr_t *)0x0,(void **)_poem_thread,&_humpty_dumpty);
  _pthread_create(&local_30,(pthread_attr_t *)0x0,(void **)_poem_thread,&_mother_goose);
  _pthread_create(&local_28,(pthread_attr_t *)0x0,(void **)_printer_thread,&_main_printer);
  _pthread_create(&local_20,(pthread_attr_t *)0x0,(void **)_printer_thread,&_backup_printer);
  _pthread_join(local_38,(void **)0x0);
  _pthread_join(local_30,(void **)0x0);
  _pthread_cancel(local_28);
  iVar1 = _pthread_cancel(local_20);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003da8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003db4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dc0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_cancel(pthread_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dcc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_cancel_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_cond_signal(pthread_cond_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dd8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_cond_signal_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_cond_wait(pthread_cond_t *param_1,pthread_mutex_t *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003de4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_cond_wait_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_create(pthread_t *param_1,pthread_attr_t *param_2,void **param_3,void *param_4)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003df0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_create_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_join(pthread_t param_1,void **param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dfc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_join_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_lock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_lock_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _pthread_mutex_unlock(pthread_mutex_t *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__pthread_mutex_unlock_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004058)(param_1);
  return iVar1;
}


`
`/* calculate approximations for continued fractions */
#include <stdio.h>

/* kind of function that returns a series of coefficients */
typedef double (*coeff_func)(unsigned n);

/* calculates the specified number of expansions of the continued fraction
 * described by the coefficient series f_a and f_b */
double calc(coeff_func f_a, coeff_func f_b, unsigned expansions)
{
	double a, b, r;
	a = b = r = 0.0;

	unsigned i;
	for (i = expansions; i > 0; i--) {
		a = f_a(i);
		b = f_b(i);
		r = b / (a + r);
	}
	a = f_a(0);

	return a + r;
}

/* series for sqrt(2) */
double sqrt2_a(unsigned n)
{
	return n ? 2.0 : 1.0;
}

double sqrt2_b(unsigned n)
{
	return 1.0;
}

/* series for the napier constant */
double napier_a(unsigned n)
{
	return n ? n : 2.0;
}

double napier_b(unsigned n)
{
	return n > 1.0 ? n - 1.0 : 1.0;
}

/* series for pi */
double pi_a(unsigned n)
{
	return n ? 6.0 : 3.0;
}

double pi_b(unsigned n)
{
	double c = 2.0 * n - 1.0;

	return c * c;
}

int main(void)
{
	double sqrt2, napier, pi;

	sqrt2  = calc(sqrt2_a,  sqrt2_b,  1000);
	napier = calc(napier_a, napier_b, 1000);
	pi     = calc(pi_a,     pi_b,     1000);

	printf("%12.10g\n%12.10g\n%12.10g\n", sqrt2, napier, pi);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003cc4(int64_t a1, int64_t a2);
int64_t function_100003d64(float64_t a1);
int64_t function_100003d80(void);
int64_t function_100003db0(void);
int64_t function_100003dc4(void);
int64_t function_100003e0c(void);
int64_t function_100003e68(void);
int64_t function_100003e98(void);
int32_t function_100003f78(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003cc4 - 0x100003d64
int64_t function_100003cc4(int64_t a1, int64_t a2) {
    // 0x100003cc4
    int64_t v1; // 0x100003cc4
    if ((int32_t)v1 == 0) {
        // 0x100003d58
        return 0;
    }
    // 0x100003d0c
    return v1 & 0xffffffff;
}

// Address range: 0x100003d64 - 0x100003d80
int64_t function_100003d64(float64_t a1) {
    // 0x100003d64
    int64_t result; // 0x100003d64
    return result;
}

// Address range: 0x100003d80 - 0x100003db0
int64_t function_100003d80(void) {
    // 0x100003d80
    int64_t result; // 0x100003d80
    return result;
}

// Address range: 0x100003db0 - 0x100003dc4
int64_t function_100003db0(void) {
    // 0x100003db0
    int64_t result; // 0x100003db0
    return result;
}

// Address range: 0x100003dc4 - 0x100003e0c
int64_t function_100003dc4(void) {
    // 0x100003dc4
    int64_t result; // 0x100003dc4
    return result;
}

// Address range: 0x100003e0c - 0x100003e68
int64_t function_100003e0c(void) {
    // 0x100003e0c
    int64_t result; // 0x100003e0c
    return result;
}

// Address range: 0x100003e68 - 0x100003e98
int64_t function_100003e68(void) {
    // 0x100003e68
    int64_t result; // 0x100003e68
    return result;
}

// Address range: 0x100003e98 - 0x100003ed0
int64_t function_100003e98(void) {
    // 0x100003e98
    int64_t result; // 0x100003e98
    return result;
}

// Address range: 0x100003ed0 - 0x100003f78
int64_t entry_point(void) {
    // 0x100003ed0
    function_100003cc4(1000, 0);
    float64_t v1; // 0x100003ed0
    function_100003cc4((int64_t)v1, (int64_t)&g1);
    function_100003cc4((int64_t)v1, (int64_t)&g1);
    int128_t v2; // 0x100003ed0
    _printf("%12.10g\n%12.10g\n%12.10g\n", (float64_t)(int64_t)v2, (float64_t)(int64_t)v2, (float64_t)(int64_t)v2);
    return 0;
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`//FormAI DATASET v1.0 Category: Terminal Based Game ; Style: high level of detail
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int player_health = 100, enemy_health = 100, player_attack, enemy_attack, round_count = 1;
    
    // set random seed for generating random numbers
    srand(time(NULL));
    
    // game loop
    while (player_health > 0 && enemy_health > 0) {
        printf("Round %d:\n", round_count);
        
        // player attack
        printf("Player's turn\n");
        printf("Enter attack strength (1-10): ");
        scanf("%d", &player_attack);
        if (player_attack < 1 || player_attack > 10) {
            printf("Invalid attack strength. Please enter a number between 1 and 10.\n");
            continue;
        }
        enemy_health -= player_attack;
        printf("Enemy's health decreased to %d\n", enemy_health);
        if (enemy_health <= 0) {
            printf("Player wins!\n");
            break;
        }
        
        // enemy attack
        printf("Enemy's turn\n");
        enemy_attack = rand() % 10 + 1;
        player_health -= enemy_attack;
        printf("Player's health decreased to %d\n", player_health);
        if (player_health <= 0) {
            printf("Enemy wins!\n");
            break;
        }
        
        round_count++;
    }
    
    printf("Game over.\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+2Ch] [rbp-14h] BYREF
  int v6; // [rsp+30h] [rbp-10h]
  unsigned int v7; // [rsp+34h] [rbp-Ch]
  int v8; // [rsp+38h] [rbp-8h]
  int v9; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 100;
  v8 = 100;
  v7 = 1;
  v3 = time(0i64);
  srand(v3);
  while ( v9 > 0 && v8 > 0 )
  {
    printf("Round %d:\n", v7);
    printf("Player's turn\n");
    printf("Enter attack strength (1-10): ");
    scanf("%d", &v5);
    if ( v5 > 0 && v5 <= 10 )
    {
      v8 -= v5;
      printf("Enemy's health decreased to %d\n", (unsigned int)v8);
      if ( v8 <= 0 )
      {
        printf("Player wins!\n");
        break;
      }
      printf("Enemy's turn\n");
      v6 = rand() % 10 + 1;
      v9 -= v6;
      printf("Player's health decreased to %d\n", (unsigned int)v9);
      if ( v9 <= 0 )
      {
        printf("Enemy wins!\n");
        break;
      }
      ++v7;
    }
    else
    {
      printf("Invalid attack strength. Please enter a number between 1 and 10.\n");
    }
  }
  printf("Game over.\n");
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>	// for exit()
#include <signal.h>
#include <time.h>	// for clock()
#include <unistd.h>	// for POSIX usleep()

volatile sig_atomic_t gotint = 0;

void handleSigint() {
    /*
     * Signal safety: It is not safe to call clock(), printf(),
     * or exit() inside a signal handler. Instead, we set a flag.
     */
    gotint = 1;
}

int main() {
    clock_t startTime = clock();
    signal(SIGINT, handleSigint);
    int i=0;
    for (;;) {
        if (gotint)
            break;
        usleep(500000);
        if (gotint)
            break;
	printf("%d\n", ++i);
    }
    clock_t endTime = clock();
    double td = (endTime - startTime) / (double)CLOCKS_PER_SEC;
    printf("Program has run for %5.3f seconds\n", td);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e44(void);
int32_t function_100003f40(void);
int32_t function_100003f4c(char * format, ...);
void (*function_100003f58(int32_t sig, void (*handler)(int32_t)))(int32_t);
int32_t function_100003f64(int32_t useconds);

// --------------------- Global Variables ---------------------

void (*g1)(int32_t) = (void (*)(int32_t))0x52800028b0000029; // 0x100003e44
int32_t g2 = -0x1120531; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _clock(void);
int32_t _printf(char * a1, ...);
void (*_signal(int32_t a1, void (*a2)(int32_t)))(int32_t);
int32_t _usleep(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003e44 - 0x100003e54
int64_t function_100003e44(void) {
    // 0x100003e44
    g2 = 1;
    int64_t result; // 0x100003e44
    return result;
}

// Address range: 0x100003e54 - 0x100003f40
int64_t entry_point(void) {
    // 0x100003e54
    _clock();
    _signal(2, (void (*)(int32_t))&g1);
    int128_t v1; // 0x100003e54
    if (g2 != 0) {
        // 0x100003ef0
        _clock();
        _printf("Program has run for %5.3f seconds\n", (float64_t)(int64_t)v1);
        return 0;
    }
    _usleep(0x7a120);
    while (g2 == 0) {
        // 0x100003ec8
        _printf("%d\n", (int64_t)&g1);
        if (g2 != 0) {
            // break -> 0x100003ef0
            break;
        }
        _usleep(0x7a120);
    }
    // 0x100003ef0
    _clock();
    _printf("Program has run for %5.3f seconds\n", (float64_t)(int64_t)v1);
    return 0;
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(void) {
    // 0x100003f40
    return _clock();
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// Address range: 0x100003f58 - 0x100003f64
void (*function_100003f58(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0x100003f58
    return _signal(sig, handler);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(int32_t useconds) {
    // 0x100003f64
    return _usleep(useconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BYTES 256

struct huffcode {
  int nbits;
  int code;
};
typedef struct huffcode huffcode_t;

struct huffheap {
  int *h;
  int n, s, cs;
  long *f;
};
typedef struct huffheap heap_t;

/* heap handling funcs */
static heap_t *_heap_create(int s, long *f)
{
  heap_t *h;
  h = malloc(sizeof(heap_t));
  h->h = malloc(sizeof(int)*s);
  h->s = h->cs = s;
  h->n = 0;
  h->f = f;
  return h;
}

static void _heap_destroy(heap_t *heap)
{
  free(heap->h);
  free(heap);
}

#define swap_(I,J) do { int t_; t_ = a[(I)];	\
      a[(I)] = a[(J)]; a[(J)] = t_; } while(0)
static void _heap_sort(heap_t *heap)
{
  int i=1, j=2; /* gnome sort */
  int *a = heap->h;

  while(i < heap->n) { /* smaller values are kept at the end */
    if ( heap->f[a[i-1]] >= heap->f[a[i]] ) {
      i = j; j++;
    } else {
      swap_(i-1, i);
      i--;
      i = (i==0) ? j++ : i;
    }
  }
}
#undef swap_

static void _heap_add(heap_t *heap, int c)
{
  if ( (heap->n + 1) > heap->s ) {
    heap->h = realloc(heap->h, heap->s + heap->cs);
    heap->s += heap->cs;
  }
  heap->h[heap->n] = c;
  heap->n++;
  _heap_sort(heap);
}

static int _heap_remove(heap_t *heap)
{
  if ( heap->n > 0 ) {
    heap->n--;
    return heap->h[heap->n];
  }
  return -1;
}

/* huffmann code generator */
huffcode_t **create_huffman_codes(long *freqs)
{
  huffcode_t **codes;
  heap_t *heap;
  long efreqs[BYTES*2];
  int preds[BYTES*2];
  int i, extf=BYTES;
  int r1, r2;

  memcpy(efreqs, freqs, sizeof(long)*BYTES);
  memset(&efreqs[BYTES], 0, sizeof(long)*BYTES);

  heap = _heap_create(BYTES*2, efreqs);
  if ( heap == NULL ) return NULL;

  for(i=0; i < BYTES; i++) if ( efreqs[i] > 0 ) _heap_add(heap, i);

  while( heap->n > 1 )
  {
    r1 = _heap_remove(heap);
    r2 = _heap_remove(heap);
    efreqs[extf] = efreqs[r1] + efreqs[r2];
    _heap_add(heap, extf);
    preds[r1] = extf;
    preds[r2] = -extf;
    extf++;
  }
  r1 = _heap_remove(heap);
  preds[r1] = r1;
  _heap_destroy(heap);

  codes = malloc(sizeof(huffcode_t *)*BYTES);

  int bc, bn, ix;
  for(i=0; i < BYTES; i++) {
    bc=0; bn=0;
    if ( efreqs[i] == 0 ) { codes[i] = NULL; continue; }
    ix = i;
    while( abs(preds[ix]) != ix ) {
      bc |= ((preds[ix] >= 0) ? 1 : 0 ) << bn;
      ix = abs(preds[ix]);
      bn++;
    }
    codes[i] = malloc(sizeof(huffcode_t));
    codes[i]->nbits = bn;
    codes[i]->code = bc;
  }
  return codes;
}

void free_huffman_codes(huffcode_t **c)
{
  int i;

  for(i=0; i < BYTES; i++) free(c[i]);
  free(c);
}

#define MAXBITSPERCODE 100

void inttobits(int c, int n, char *s)
{
  s[n] = 0;
  while(n > 0) {
    s[n-1] = (c%2) + '0';
    c >>= 1; n--;
  }
}

const char *test = "this is an example for huffman encoding";

int main()
{
  huffcode_t **r;
  int i;
  char strbit[MAXBITSPERCODE];
  const char *p;
  long freqs[BYTES];

  memset(freqs, 0, sizeof freqs);

  p = test;
  while(*p != '\0') freqs[*p++]++;

  r = create_huffman_codes(freqs);

  for(i=0; i < BYTES; i++) {
    if ( r[i] != NULL ) {
      inttobits(r[i]->code, r[i]->nbits, strbit);
      printf("%c (%d) %s\n", i, r[i]->code, strbit);
    }
  }

  free_huffman_codes(r);

  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003654(int64_t * a1);
int64_t function_100003670(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003984(void);
int64_t function_1000039f4(void);
int64_t function_100003ab4(void);
int64_t function_100003b18(void);
int64_t function_100003b48(void);
int64_t function_100003bac(void);
int64_t function_100003db4(void);
int64_t function_100003ef4(int64_t a1);
int32_t function_100003f00(int32_t x);
void function_100003f0c(int64_t * s, int32_t n);
void function_100003f18(int64_t * ptr);
int64_t * function_100003f24(int32_t size);
int64_t * function_100003f30(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f3c(char * format, ...);
int64_t * function_100003f48(int64_t * ptr, int32_t size);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(int64_t a1);
int32_t _abs(int32_t a1);
void _bzero(int64_t * a1, int32_t a2);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003654 - 0x100003670
int64_t function_100003654(int64_t * a1) {
    // 0x100003654
    return ___chkstk_darwin();
}

// Address range: 0x100003670 - 0x100003984
int64_t function_100003670(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003670
    int64_t v1; // 0x100003670
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003684
    *v2 = *(int64_t *)*(int64_t *)0x100004010;
    int64_t v3; // bp-4104, 0x100003670
    int64_t v4 = &v3; // 0x10000369c
    _memcpy(&v3, (int64_t *)v1, 2048);
    _bzero((int64_t *)(v4 + 2048), 2048);
    int64_t v5 = function_100003984(); // 0x1000036c4
    int64_t v6 = 0; // 0x1000036d8
    int64_t result = 0; // 0x1000036d8
    if (v5 != 0) {
        int32_t v7 = 0;
        if (*(int64_t *)(8 * (int64_t)v7 + v4) >= 1) {
            // 0x100003720
            function_1000039f4();
        }
        int32_t v8 = v7 + 1; // 0x100003738
        while (v7 < 255 != (254 - v7 & v8) < 0) {
            // 0x100003704
            v7 = v8;
            if (*(int64_t *)(8 * (int64_t)v7 + v4) >= 1) {
                // 0x100003720
                function_1000039f4();
            }
            // 0x100003734
            v8 = v7 + 1;
        }
        int32_t * v9 = (int32_t *)(v5 + 8); // 0x10000374c
        int32_t v10 = *v9; // 0x10000374c
        int32_t v11 = v10 - 1; // 0x100003750
        int64_t v12 = function_100003ab4();
        int64_t v13; // bp-6152, 0x100003670
        int64_t v14 = &v13;
        int32_t v15 = 256; // 0x100003758
        int64_t v16 = v12; // 0x100003758
        if (v11 != 0 && v11 < 0 == (v10 & -v10) < 0) {
            int64_t v17 = function_100003ab4(); // 0x100003770
            int64_t v18 = 0x100000000 * v12;
            int64_t v19 = *(int64_t *)((v18 >> 29) + v4); // 0x100003780
            int64_t v20 = 0x100000000 * v17;
            int64_t v21 = *(int64_t *)((v20 >> 29) + v4); // 0x100003788
            *(int64_t *)(8 * (int64_t)v15 + v4) = v21 + v19;
            function_1000039f4();
            *(int32_t *)((v18 >> 30) + v14) = v15;
            *(int32_t *)((v20 >> 30) + v14) = -v15;
            int32_t v22 = *v9; // 0x10000374c
            int32_t v23 = v22 - 1; // 0x100003750
            int64_t v24 = function_100003ab4();
            int64_t v25 = v24; // 0x100003758
            v15++;
            v16 = v24;
            while (v23 != 0 && v23 < 0 == (v22 & -v22) < 0) {
                // 0x100003760
                v17 = function_100003ab4();
                v18 = 0x100000000 * v25;
                v19 = *(int64_t *)((v18 >> 29) + v4);
                v20 = 0x100000000 * v17;
                v21 = *(int64_t *)((v20 >> 29) + v4);
                *(int64_t *)(8 * (int64_t)v15 + v4) = v21 + v19;
                function_1000039f4();
                *(int32_t *)((v18 >> 30) + v14) = v15;
                *(int32_t *)((v20 >> 30) + v14) = -v15;
                v22 = *v9;
                v23 = v22 - 1;
                v24 = function_100003ab4();
                v25 = v24;
                v15++;
                v16 = v24;
            }
        }
        int64_t v26 = v16;
        *(int32_t *)((0x100000000 * v26 >> 30) + v14) = (int32_t)v26;
        function_100003b18();
        result = (int64_t)_malloc(2048);
        int32_t v27 = 0;
        int64_t v28 = v27;
        int64_t v29 = 8 * v28; // 0x100003834
        int32_t * v30; // 0x100003670
        int32_t v31; // 0x100003670
        int32_t v32; // 0x100003670
        int32_t v33; // 0x100003670
        int32_t v34; // 0x100003670
        int32_t * v35; // 0x100003870
        int64_t * v36; // 0x1000038e8
        int64_t v37; // 0x1000038e8
        int64_t * v38; // 0x1000038f4
        int32_t v39; // 0x100003894
        int32_t v40; // 0x1000038bc
        int32_t v41; // 0x1000038cc
        int32_t v42; // 0x1000038d8
        int32_t * v43; // 0x100003870
        int64_t v44; // 0x100003670
        if (*(int64_t *)(v29 + v4) == 0) {
            // 0x100003848
            *(int64_t *)(v29 + result) = 0;
            v44 = result;
        } else {
            // 0x100003868
            v35 = (int32_t *)(4 * v28 + v14);
            v30 = v35;
            v33 = 0;
            v32 = 0;
            v34 = 0;
            if (_abs(*v35) != v27) {
                v39 = *v30;
                v40 = (int32_t)(v39 >= 0) << v33;
                v41 = _abs(v39);
                v42 = v33 + 1;
                v43 = (int32_t *)(4 * (int64_t)v41 + v14);
                v30 = v43;
                v33 = v42;
                v31 = v40;
                v32 = v40;
                v34 = v42;
                while (_abs(*v43) != v41) {
                    // 0x10000388c
                    v39 = *v30;
                    v40 = (int32_t)(v39 >= 0) << v33 | v31;
                    v41 = _abs(v39);
                    v42 = v33 + 1;
                    v43 = (int32_t *)(4 * (int64_t)v41 + v14);
                    v30 = v43;
                    v33 = v42;
                    v31 = v40;
                    v32 = v40;
                    v34 = v42;
                }
            }
            // 0x1000038e4
            v36 = _malloc(8);
            v37 = (int64_t)v36;
            v38 = (int64_t *)(v29 + result);
            *v38 = v37;
            *(int32_t *)v36 = v34;
            *(int32_t *)(*v38 + 4) = v32;
            v44 = v37;
        }
        int32_t v45 = v27 + 1; // 0x100003928
        int64_t v46 = v44; // 0x10000381c
        v6 = v44;
        while (v27 < 255 != (254 - v27 & v45) < 0) {
            // 0x100003824
            v27 = v45;
            v28 = v27;
            v29 = 8 * v28;
            if (*(int64_t *)(v29 + v4) == 0) {
                // 0x100003848
                *(int64_t *)(v29 + result) = 0;
                v44 = v46;
            } else {
                // 0x100003868
                v35 = (int32_t *)(4 * v28 + v14);
                v30 = v35;
                v33 = 0;
                v32 = 0;
                v34 = 0;
                if (_abs(*v35) != v27) {
                    v39 = *v30;
                    v40 = (int32_t)(v39 >= 0) << v33;
                    v41 = _abs(v39);
                    v42 = v33 + 1;
                    v43 = (int32_t *)(4 * (int64_t)v41 + v14);
                    v30 = v43;
                    v33 = v42;
                    v31 = v40;
                    v32 = v40;
                    v34 = v42;
                    while (_abs(*v43) != v41) {
                        // 0x10000388c
                        v39 = *v30;
                        v40 = (int32_t)(v39 >= 0) << v33 | v31;
                        v41 = _abs(v39);
                        v42 = v33 + 1;
                        v43 = (int32_t *)(4 * (int64_t)v41 + v14);
                        v30 = v43;
                        v33 = v42;
                        v31 = v40;
                        v32 = v40;
                        v34 = v42;
                    }
                }
                // 0x1000038e4
                v36 = _malloc(8);
                v37 = (int64_t)v36;
                v38 = (int64_t *)(v29 + result);
                *v38 = v37;
                *(int32_t *)v36 = v34;
                *(int32_t *)(*v38 + 4) = v32;
                v44 = v37;
            }
            // 0x100003924
            v45 = v27 + 1;
            v46 = v44;
            v6 = v44;
        }
    }
    // 0x100003940
    if (*(int64_t *)*(int64_t *)0x100004010 != *v2) {
        // 0x100003968
        ___stack_chk_fail(v6);
    }
    // 0x10000396c
    return result;
}

// Address range: 0x100003984 - 0x1000039f4
int64_t function_100003984(void) {
    int64_t * v1 = _malloc(32); // 0x10000399c
    int64_t result = (int64_t)v1; // 0x10000399c
    int64_t v2; // 0x100003984
    int32_t v3 = v2;
    *v1 = (int64_t)_malloc(4 * v3);
    *(int32_t *)(result + 16) = v3;
    *(int32_t *)(result + 12) = v3;
    *(int32_t *)(result + 8) = 0;
    return result;
}

// Address range: 0x1000039f4 - 0x100003ab4
int64_t function_1000039f4(void) {
    // 0x1000039f4
    int64_t v1; // 0x1000039f4
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x100003a0c
    int32_t v3 = *v2; // 0x100003a0c
    int32_t v4 = v3 + 1; // 0x100003a10
    int32_t * v5 = (int32_t *)(v1 + 12); // 0x100003a18
    int32_t v6 = *v5; // 0x100003a18
    int32_t v7 = v4 - v6; // 0x100003a1c
    int32_t v8 = v3; // 0x100003a24
    int64_t v9; // 0x1000039f4
    if (v7 != 0 && v7 < 0 == ((v7 ^ v4) & (v4 ^ v6)) < 0) {
        int32_t * v10 = (int32_t *)(v1 + 16); // 0x100003a40
        int64_t * v11 = (int64_t *)v1; // 0x100003a50
        int64_t v12 = (int64_t)_realloc(v11, *v10 + v6); // 0x100003a50
        *v11 = v12;
        *v5 = *v5 + *v10;
        v8 = *v2;
        v9 = v12;
    }
    // 0x100003a78
    *(int32_t *)(4 * (int64_t)v8 + v9) = (int32_t)v1;
    *v2 = *v2 + 1;
    return function_100003db4();
}

// Address range: 0x100003ab4 - 0x100003b18
int64_t function_100003ab4(void) {
    // 0x100003ab4
    int64_t v1; // 0x100003ab4
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x100003ac0
    uint32_t v3 = *v2; // 0x100003ac0
    int64_t result = 0xffffffff; // 0x100003acc
    if (v3 >= 1) {
        int32_t v4 = v3 - 1; // 0x100003adc
        *v2 = v4;
        result = (int64_t)*(int32_t *)(4 * (int64_t)v4 + v1);
    }
    // 0x100003b0c
    return result;
}

// Address range: 0x100003b18 - 0x100003b48
int64_t function_100003b18(void) {
    // 0x100003b18
    int64_t v1; // 0x100003b18
    int64_t * v2 = (int64_t *)v1; // 0x100003b30
    _free(v2);
    _free(v2);
    return &g1;
}

// Address range: 0x100003b48 - 0x100003bac
int64_t function_100003b48(void) {
    int32_t v1 = 0;
    int64_t v2; // 0x100003b48
    _free((int64_t *)*(int64_t *)(8 * (int64_t)v1 + v2));
    int32_t v3 = v1 + 1; // 0x100003b8c
    while (v1 < 255 != (254 - v1 & v3) < 0) {
        // 0x100003b74
        v1 = v3;
        _free((int64_t *)*(int64_t *)(8 * (int64_t)v1 + v2));
        v3 = v1 + 1;
    }
    // 0x100003b98
    _free((int64_t *)v2);
    return &g1;
}

// Address range: 0x100003bac - 0x100003c30
int64_t function_100003bac(void) {
    // 0x100003bac
    int64_t result; // 0x100003bac
    int32_t v1 = result; // 0x100003bb4
    *(char *)((0x100000000 * result >> 32) + result) = 0;
    if (v1 < 1) {
        // 0x100003c28
        return result;
    }
    int32_t v2 = v1; // 0x100003c04
    int32_t v3 = result;
    int64_t v4 = result & 0xffffffff;
    v2--;
    *(char *)(result + (int64_t)v2) = (char)(v3 - 2 * v3 / 2) + 48;
    int64_t v5 = v4 - 1; // 0x100003bdc
    int32_t v6 = v3 >> 1; // 0x100003bdc
    while (v4 >= 2) {
        // 0x100003be4
        v3 = v6;
        v4 = v5;
        v2--;
        *(char *)(result + (int64_t)v2) = (char)(v3 - 2 * v3 / 2) + 48;
        v5 = v4 - 1;
        v6 = v3 >> 1;
    }
    // 0x100003c28
    return result;
}

// Address range: 0x100003c30 - 0x100003db4
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003c48
    int64_t v2; // bp-2184, 0x100003c30
    _bzero(&v2, 2048);
    char v3 = *(char *)0x3f54; // 0x100003c74
    if (v3 != 0) {
        char * v4 = (char *)0x3f54; // 0x100003c90
        v4 = (char *)((int64_t)v4 + 1);
        int64_t * v5 = (int64_t *)(8 * (int64_t)v3 + (int64_t)&v2); // 0x100003ca0
        *v5 = *v5 + 1;
        char v6 = *v4; // 0x100003c74
        while (v6 != 0) {
            // 0x100003c88
            v4 = (char *)((int64_t)v4 + 1);
            v5 = (int64_t *)(8 * (int64_t)v6 + (int64_t)&v2);
            *v5 = *v5 + 1;
            v6 = *v4;
        }
    }
    int64_t v7 = function_100003654(&v2); // 0x100003cb4
    int64_t v8; // bp-132, 0x100003c30
    int64_t v9 = &v8;
    int32_t v10 = 0;
    int64_t v11 = *(int64_t *)(8 * (int64_t)v10 + v7); // 0x100003ce0
    int64_t v12; // 0x100003c30
    if (v11 != 0) {
        // 0x100003cf4
        function_100003bac();
        _printf("%c (%d) %s\n", (char)*(int32_t *)v11, v9, (char *)v12);
    }
    int32_t v13 = v10 + 1; // 0x100003d68
    while (v10 < 255 != (254 - v10 & v13) < 0) {
        // 0x100003cd8
        v10 = v13;
        v11 = *(int64_t *)(8 * (int64_t)v10 + v7);
        if (v11 != 0) {
            // 0x100003cf4
            function_100003bac();
            _printf("%c (%d) %s\n", (char)*(int32_t *)v11, v9, (char *)v12);
        }
        // 0x100003d64
        v13 = v10 + 1;
    }
    int64_t v14 = function_100003b48(); // 0x100003d78
    if (*(int64_t *)*(int64_t *)0x100004010 != v1) {
        // 0x100003d9c
        ___stack_chk_fail(v14);
    }
    // 0x100003da0
    return 0;
}

// Address range: 0x100003db4 - 0x100003ef4
int64_t function_100003db4(void) {
    // 0x100003db4
    int64_t result; // 0x100003db4
    int32_t * v1 = (int32_t *)(result + 8); // 0x100003de4
    int32_t v2 = *v1; // 0x100003de4
    int32_t v3 = 1 - v2; // 0x100003de8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003eec
        return result;
    }
    int32_t v4 = v2; // 0x100003db4
    int32_t v5 = 1;
    int32_t v6 = 2;
    int64_t v7 = *(int64_t *)(result + 24); // 0x100003dfc
    int32_t * v8 = (int32_t *)(result + (int64_t)(4 * v5 - 4)); // 0x100003e0c
    int32_t v9 = *v8; // 0x100003e0c
    int64_t v10 = *(int64_t *)(8 * (int64_t)v9 + v7); // 0x100003e10
    int32_t * v11 = (int32_t *)(4 * (int64_t)v5 + result); // 0x100003e24
    int32_t v12 = *v11; // 0x100003e24
    int64_t v13 = *(int64_t *)(8 * (int64_t)v12 + v7); // 0x100003e28
    int64_t v14 = v10 - v13; // 0x100003e2c
    int32_t v15; // 0x100003db4
    int32_t v16; // 0x100003db4
    int32_t v17; // 0x100003ea0
    if (v14 < 0 == ((v14 ^ v10) & (v13 ^ v10)) < 0) {
        // 0x100003e3c
        v15 = v6;
        v16 = v6 + 1;
    } else {
        // 0x100003e58
        *v8 = v12;
        *v11 = v9;
        v17 = v5 - 1;
        v4 = *v1;
        v15 = v17 == 0 ? v6 : v17;
        v16 = v6 + (int32_t)(v17 == 0);
    }
    // 0x100003ee8
    while (v15 - v4 < 0 != ((v15 - v4 ^ v15) & (v15 ^ v4)) < 0) {
        // 0x100003df8
        v5 = v15;
        v6 = v16;
        v7 = *(int64_t *)(result + 24);
        v8 = (int32_t *)(result + (int64_t)(4 * v5 - 4));
        v9 = *v8;
        v10 = *(int64_t *)(8 * (int64_t)v9 + v7);
        v11 = (int32_t *)(4 * (int64_t)v5 + result);
        v12 = *v11;
        v13 = *(int64_t *)(8 * (int64_t)v12 + v7);
        v14 = v10 - v13;
        if (v14 < 0 == ((v14 ^ v10) & (v13 ^ v10)) < 0) {
            // 0x100003e3c
            v15 = v6;
            v16 = v6 + 1;
        } else {
            // 0x100003e58
            *v8 = v12;
            *v11 = v9;
            v17 = v5 - 1;
            v4 = *v1;
            v15 = v17 == 0 ? v6 : v17;
            v16 = v6 + (int32_t)(v17 == 0);
        }
    }
    // 0x100003eec
    return result;
}

// Address range: 0x100003ef4 - 0x100003f00
int64_t function_100003ef4(int64_t a1) {
    // 0x100003ef4
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(int32_t x) {
    // 0x100003f00
    return _abs(x);
}

// Address range: 0x100003f0c - 0x100003f18
void function_100003f0c(int64_t * s, int32_t n) {
    // 0x100003f0c
    _bzero(s, n);
}

// Address range: 0x100003f18 - 0x100003f24
void function_100003f18(int64_t * ptr) {
    // 0x100003f18
    _free(ptr);
}

// Address range: 0x100003f24 - 0x100003f30
int64_t * function_100003f24(int32_t size) {
    // 0x100003f24
    return _malloc(size);
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t * function_100003f30(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f30
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f3c - 0x100003f48
int32_t function_100003f3c(char * format, ...) {
    // 0x100003f3c
    return _printf(format);
}

// Address range: 0x100003f48 - 0x100003f54
int64_t * function_100003f48(int64_t * ptr, int32_t size) {
    // 0x100003f48
    return _realloc(ptr, size);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 18

`
`//FormAI DATASET v1.0 Category: Disk space analyzer ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <dirent.h>

long long calculate_directory_size(char *path);

int main() {
    long long size = calculate_directory_size(".");
    printf("Size of current directory: %lld bytes\n", size);
    return 0;
}

long long calculate_directory_size(char *path) {
    struct dirent *dir;
    DIR *d = opendir(path);
    if (d == NULL) {
        fprintf(stderr, "Cannot open directory\n");
        exit(EXIT_FAILURE);
    }

    long long total_size = 0;
    char new_path[1024];
    while ((dir = readdir(d)) != NULL) {
        // Ignore the "." and ".." folders
        if (strcmp(dir->d_name, ".") == 0 || strcmp(dir->d_name, "..") == 0) {
            continue;
        }

        // Create the new path by concatenating the directory and the file/folder name
        snprintf(new_path, sizeof(new_path), "%s/%s", path, dir->d_name);

        // Get the file/folder information
        struct stat st;
        if (stat(new_path, &st) == -1) {
            continue;
        }

        // If it's a file, add its size to the total
        if (S_ISREG(st.st_mode)) {
            total_size += st.st_size;
        }
        // If it's a directory, recursively calculate its size and add it to the total
        else if (S_ISDIR(st.st_mode)) {
            total_size += calculate_directory_size(new_path);
        }
    }

    closedir(d);
    return total_size;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall calculate_directory_size(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000161E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v4 = calculate_directory_size(".");
  printf("Size of current directory: %lld bytes\n", v4);
  return 0;
}
// 14000165F: using guessed type __int64 __fastcall calculate_directory_size(_QWORD);
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=157 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <string.h>

void swap(char* p1, char* p2, size_t size) {
    for (; size-- > 0; ++p1, ++p2) {
        char tmp = *p1;
        *p1 = *p2;
        *p2 = tmp;
    }
}

void cocktail_shaker_sort(void* base, size_t count, size_t size,
                          int (*cmp)(const void*, const void*)) {
    char* begin = base;
    char* end = base + size * count;
    if (end == begin)
        return;
    for (end -= size; begin < end; ) {
        char* new_begin = end;
        char* new_end = begin;
        for (char* p = begin; p < end; p += size) {
            char* q = p + size;
            if (cmp(p, q) > 0) {
                swap(p, q, size);
                new_end = p;
            }
        }
        end = new_end;
        for (char* p = end; p > begin; p -= size) {
            char* q = p - size;
            if (cmp(q, p) > 0) {
                swap(p, q, size);
                new_begin = p;
            }
        }
        begin = new_begin;
    }
}

int string_compare(const void* p1, const void* p2) {
    const char* const* s1 = p1;
    const char* const* s2 = p2;
    return strcmp(*s1, *s2);
}

void print(const char** a, size_t len) {
    for (size_t i = 0; i < len; ++i)
        printf("%s ", a[i]);
    printf("\n");
}

int main() {
    const char* a[] = { "one", "two", "three", "four", "five",
        "six", "seven", "eight" };
    const size_t len = sizeof(a)/sizeof(a[0]);
    printf("before: ");
    print(a, len);
    cocktail_shaker_sort(a, len, sizeof(char*), string_compare);
    printf("after: ");
    print(a, len);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b68(void);
int64_t function_100003be8(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003dac(void);
int64_t function_100003df0(void);
int64_t function_100003f30(int64_t a1);
int64_t * function_100003f3c(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f48(char * format, ...);
int32_t function_100003f54(char * s1, char * s2);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003b68 - 0x100003be8
int64_t function_100003b68(void) {
    // 0x100003b68
    int64_t result; // 0x100003b68
    if (result == 0) {
        // 0x100003be0
        return result;
    }
    int64_t v1; // 0x100003b68
    char * v2 = (char *)v1;
    int64_t v3; // 0x100003b68
    char * v4 = (char *)v3;
    int64_t v5; // 0x100003b68
    int64_t v6 = v5 - 1; // 0x100003b80
    *v2 = *v4;
    *v4 = *v2;
    v1++;
    v3++;
    while (v6 != 0) {
        // 0x100003b98
        v2 = (char *)v1;
        v4 = (char *)v3;
        v6--;
        *v2 = *v4;
        *v4 = *v2;
        v1++;
        v3++;
    }
    // 0x100003be0
    return result;
}

// Address range: 0x100003be8 - 0x100003dac
int64_t function_100003be8(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003be8
    int64_t result; // 0x100003be8
    return result;
}

// Address range: 0x100003dac - 0x100003df0
int64_t function_100003dac(void) {
    // 0x100003dac
    int64_t v1; // 0x100003dac
    return _strcmp((char *)v1, (char *)v1);
}

// Address range: 0x100003df0 - 0x100003e70
int64_t function_100003df0(void) {
    // 0x100003df0
    int64_t v1; // 0x100003df0
    if (v1 == 0) {
        // 0x100003e58
        return _printf("\n");
    }
    int64_t v2 = 0; // 0x100003e4c
    _printf("%s ", (char *)v1);
    while (v2 + 1 != v1) {
        // 0x100003e24
        v2++;
        _printf("%s ", (char *)v1);
    }
    // 0x100003e58
    return _printf("\n");
}

// Address range: 0x100003e70 - 0x100003f30
int64_t entry_point(void) {
    // 0x100003e70
    int64_t v1; // bp-88, 0x100003e70
    _memcpy(&v1, (int64_t *)"f?", 64);
    _printf("before: ");
    function_100003df0();
    function_100003be8((int64_t)&g1, (int64_t)&g1, (int64_t)&g1, (int64_t)&g1);
    _printf("after: ");
    int64_t v2 = function_100003df0(); // 0x100003ef8
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f08
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f1c
        ___stack_chk_fail(v2);
    }
    // 0x100003f20
    return 0;
}

// Address range: 0x100003f30 - 0x100003f3c
int64_t function_100003f30(int64_t a1) {
    // 0x100003f30
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f3c - 0x100003f48
int64_t * function_100003f3c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f3c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f48 - 0x100003f54
int32_t function_100003f48(char * format, ...) {
    // 0x100003f48
    return _printf(format);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * s1, char * s2) {
    // 0x100003f54
    return _strcmp(s1, s2);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 9

`
`#include <stdio.h>

int main()
{
    const char *fruit[2] = { "apples", "oranges" };

    // Acquire the length of the array by dividing the size of all elements (found
    // with sizeof(fruit)) by the size of the first element.

    // Note that since the array elements are pointers to null-terminated character
    // arrays, the size of the first element is actually the size of the pointer
    // type - not the length of the string.

    // This size, regardless of the type being pointed to, is 8 bytes, 4 bytes, or
    // 2 bytes on 64-bit, 32-bit, or 16-bit platforms respectively.
    int length = sizeof(fruit) / sizeof(fruit[0]);

    printf("%d\n", length);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f7c(int64_t a1);
int32_t function_100003f88(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ef4 - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003ef4
    int64_t v1; // 0x100003ef4
    int32_t v2 = _printf("%d\n", v1); // 0x100003f44
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f54
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f68
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int64_t function_100003f7c(int64_t a1) {
    // 0x100003f7c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(char * format, ...) {
    // 0x100003f88
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <math.h>
#include <stdio.h>

const char* animals[] = { "Rat","Ox","Tiger","Rabbit","Dragon","Snake","Horse","Goat","Monkey","Rooster","Dog","Pig" };
const char* elements[] = { "Wood","Fire","Earth","Metal","Water" };

const char* getElement(int year) {
    int element = (int)floor((year - 4) % 10 / 2);
    return elements[element];
}

const char* getAnimal(int year) {
    return animals[(year - 4) % 12];
}

const char* getYY(int year) {
    if (year % 2 == 0) {
        return "yang";
    } else {
        return "yin";
    }
}

int main() {
    int years[] = { 1935, 1938, 1968, 1972, 1976, 2017 };
    int i;

    //the zodiac cycle didnt start until 4 CE, so years <4 shouldnt be valid
    for (i = 0; i < 6; ++i) {
        int year = years[i];
        printf("%d is the year of the %s %s (%s).\n", year, getElement(year), getAnimal(year), getYY(year));
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d08(int32_t a1);
int64_t function_100003d54(void);
int64_t function_100003d88(void);
int64_t function_100003ee4(void);
int32_t function_100003ef0(char * format, ...);

// --------------------- Global Variables ---------------------

float128_t g1 = 4.11242784384671477138867079538655933e-311L; // 0x100003f88
int64_t g2 = 0x10000000003efc; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d08 - 0x100003d54
int64_t function_100003d08(int32_t a1) {
    int32_t v1 = __asm_fcvtms((float64_t)((a1 - 4) % 10 / 2)); // 0x100003d34
    return *(int64_t *)(8 * (int64_t)v1 + (int64_t)"??");
}

// Address range: 0x100003d54 - 0x100003d88
int64_t function_100003d54(void) {
    // 0x100003d54
    int64_t v1; // 0x100003d54
    int64_t result = *(int64_t *)((int64_t)(8 * (((int32_t)v1 - 4) % 12)) + (int64_t)&g2); // 0x100003d7c
    return result;
}

// Address range: 0x100003d88 - 0x100003de0
int64_t function_100003d88(void) {
    // 0x100003d88
    int64_t v1; // 0x100003d88
    int32_t v2 = v1; // 0x100003d98
    return 2 * v2 / 2 == v2 ? (int64_t)"yang" : (int64_t)"yin";
}

// Address range: 0x100003de0 - 0x100003ee4
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003df4
    float128_t v2 = g1; // bp-48, 0x100003e0c
    for (int64_t i = 0; i < 6; i++) {
        // 0x100003e34
        function_100003d08(*(int32_t *)(4 * i + (int64_t)&v2));
        function_100003d54();
        function_100003d88();
        int64_t v3; // 0x100003de0
        _printf("%d is the year of the %s %s (%s).\n", v3, (char *)v3, (char *)v3, (char *)v3);
    }
    // 0x100003eb0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ed0
        ___stack_chk_fail();
    }
    // 0x100003ed4
    return 0;
}

// Address range: 0x100003ee4 - 0x100003ef0
int64_t function_100003ee4(void) {
    // 0x100003ee4
    return ___stack_chk_fail();
}

// Address range: 0x100003ef0 - 0x100003efc
int32_t function_100003ef0(char * format, ...) {
    // 0x100003ef0
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`//FormAI DATASET v1.0 Category: System process viewer ; Style: excited
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <ctype.h>

#define MAX_NAME_LEN 256
#define MAX_PATH_LEN 1024
#define MAX_PID_LEN 10

/* This program lists all the running processes with their 
 * name, pid, and memory usage.
*/

struct proc_info {
    char name[MAX_NAME_LEN];
    int pid;
    unsigned long int mem;
};

/* Helper function to read the contents of a directory. */
int read_dir(const char *path, char ***entries) {
    DIR *dir = opendir(path);
    if (!dir) {
        return -1;
    }

    struct dirent *entry;
    int count = 0;
    while ((entry = readdir(dir)) != NULL) {
        if (isdigit(entry->d_name[0])) {
            count++;
        }
    }

    *entries = calloc(count, sizeof(char *));
    rewinddir(dir);

    int i = 0;
    while ((entry = readdir(dir)) != NULL) {
        if (isdigit(entry->d_name[0])) {
            (*entries)[i] = calloc(strlen(entry->d_name) + 1, sizeof(char));
            strcpy((*entries)[i], entry->d_name);
            i++;
        }
    }

    closedir(dir);
    return count;
}

/* Helper function to read the information about a process
 * given its pid.
 */
int read_proc_info(int pid, struct proc_info *info) {
    char path[MAX_PATH_LEN];
    snprintf(path, MAX_PATH_LEN, "/proc/%d/stat", pid);

    FILE *file = fopen(path, "r");
    if (!file) {
        return -1;
    }

    fscanf(file, "%d %s %*c %*d %*d %*d %*d %*d %*u %*lu %*lu %*lu %*lu %lu",
           &info->pid, info->name, &info->mem);

    fclose(file);
    return 0;
}

/* Entry point of the program. */
int main(int argc, char **argv) {
    char **entries;
    int proc_count = read_dir("/proc", &entries);

    printf("Name\tPID\tMemory\n");
    printf("===================================\n");

    for (int i = 0; i < proc_count; i++) {
        int pid = atoi(entries[i]);

        struct proc_info info;
        if (read_proc_info(pid, &info) == 0) {
            printf("%s\t%d\t%lu KB\n", info.name, pid, info.mem / 1024);
        }
    }

    /* Free up the memory allocated. */
    for (int i = 0; i < proc_count; i++) {
        free(entries[i]);
    }
    free(entries);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall read_dir(_QWORD, _QWORD); // weak
__int64 __fastcall read_proc_info(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);
// int __cdecl atoi(const char *String);


//----- (0000000140001823) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[260]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v5; // [rsp+124h] [rbp+A4h]
  void *Block; // [rsp+128h] [rbp+A8h] BYREF
  unsigned int v7; // [rsp+130h] [rbp+B0h]
  int v8; // [rsp+134h] [rbp+B4h]
  int j; // [rsp+138h] [rbp+B8h]
  int i; // [rsp+13Ch] [rbp+BCh]

  _main(argc, argv, envp);
  v8 = read_dir("/proc", &Block);
  printf("Name\tPID\tMemory\n");
  printf("===================================\n");
  for ( i = 0; i < v8; ++i )
  {
    v7 = atoi(*((const char **)Block + i));
    if ( !(unsigned int)read_proc_info(v7, v4) )
      printf("%s\t%d\t%lu KB\n", v4, v7, v5 >> 10);
  }
  for ( j = 0; j < v8; ++j )
    free(*((void **)Block + j));
  free(Block);
  return 0;
}
// 14000161E: using guessed type __int64 __fastcall read_dir(_QWORD, _QWORD);
// 14000175E: using guessed type __int64 __fastcall read_proc_info(_QWORD, _QWORD);
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=196 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: visionary
#include<stdio.h>
#include<stdlib.h>

struct product{      //defining a structure to store products and their details
    char name[50];
    int pid;
    float price;
};

struct order{        //defining a structure to store details of orders
    struct product p;
    int quantity;
    float total;
};

void printMenu(struct product[], int);    //function to print the menu
void newOrder(struct order[], struct product[], int);   //function to take order from customer
void printBill(struct order[], int);    //function to print the final bill

int main(){

    struct product menu[5] = {{"Espresso", 1, 2.5},
                         {"Latte", 2, 3.5},
                         {"Cappuccino", 3, 4.5},
                         {"Mocha", 4, 5.5},
                         {"Iced Coffee", 5, 6.5}};   //creating an array of products

    int totalOrders = 0;    //variable to store total number of orders
    struct order orders[50];   //creating an array of orders

    printf("Welcome to CafeX Billing System\n\n");

    int choice = 0;
    while(choice!=3){      //loop to display the menu until customer chooses to exit
        printf("Please choose an option:\n1. Display Menu\n2. New Order\n3. Exit\n");
        scanf("%d", &choice);

        switch(choice){
            case 1:
                printMenu(menu, 5);    //calling function to print menu
                break;
            case 2:
                newOrder(orders, menu, totalOrders);   //calling function to take new order
                totalOrders++;
                break;
            case 3:
                printf("Thank you for using CafeX Billing System. Have a nice day!\n");
                break;
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }
    printBill(orders, totalOrders);   //calling function to print final bill

    return 0;
}

void printMenu(struct product menu[], int n){   //function to print the menu
    printf("Menu:\n");
    printf("------------------------------\n");
    printf("| %-12s | %-4s | %-6s |\n", "Product", "ID", "Price");
    printf("------------------------------\n");
    for(int i=0; i<n; i++){
        printf("| %-12s | %-4d | $%-5.2f |\n", menu[i].name, menu[i].pid, menu[i].price);
    }
    printf("------------------------------\n\n");
}

void newOrder(struct order orders[], struct product menu[], int totalOrders){   //function to take order from customer
    int pid=0, quantity=0;
    printf("Please enter product ID: ");
    scanf("%d", &pid);
    printf("Please enter quantity: ");
    scanf("%d", &quantity);

    struct order o = {menu[pid-1], quantity, quantity * menu[pid-1].price};  //creating new order and calculating total
    orders[totalOrders] = o;   //adding order to array of orders
    printf("Order accepted successfully!\n\n");
}

void printBill(struct order orders[], int totalOrders){   //function to print the final bill
    float subTotal=0, serviceCharge=0, tax=0, total=0;

    printf("CafeX Bill\n");
    printf("-------------------------------------------------\n");
    printf("| %-12s | %-4s | %-8s | %-8s |\n", "Product", "Qty", "Price", "Total");
    printf("-------------------------------------------------\n");
    for(int i=0; i<totalOrders; i++){
        printf("| %-12s | %-4d | $%-6.2f | $%-6.2f |\n", orders[i].p.name, orders[i].quantity, orders[i].p.price, orders[i].total);
        subTotal += orders[i].total;   //calculating subtotal
    }
    printf("-------------------------------------------------\n");
    serviceCharge = (0.1 * subTotal);   //calculating service charge
    tax = (0.15 * subTotal);    //calculating tax
    total = subTotal + serviceCharge + tax;   //calculating total

    printf("Subtotal: $%.2f\n", subTotal);
    printf("Service Charge (10%%): $%.2f\n", serviceCharge);
    printf("Tax (15%%): $%.2f\n", tax);
    printf("Total: $%.2f\n", total);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall printMenu(_QWORD, _QWORD); // weak
__int64 __fastcall newOrder(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall printBill(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char aEspresso[9] = "Espresso"; // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-54h] BYREF
  char v5[3408]; // [rsp+30h] [rbp-50h] BYREF
  char v6[300]; // [rsp+D80h] [rbp+D00h] BYREF
  unsigned int v7; // [rsp+EACh] [rbp+E2Ch]

  _main(argc, argv, envp);
  qmemcpy(v6, aEspresso, sizeof(v6));
  v7 = 0;
  printf("Welcome to CafeX Billing System\n\n");
  v4 = 0;
  while ( v4 != 3 )
  {
    printf("Please choose an option:\n1. Display Menu\n2. New Order\n3. Exit\n");
    scanf("%d", &v4);
    if ( v4 == 3 )
    {
      printf("Thank you for using CafeX Billing System. Have a nice day!\n");
    }
    else
    {
      if ( v4 > 3 )
        goto LABEL_10;
      if ( v4 == 1 )
      {
        printMenu(v6, 5i64);
      }
      else if ( v4 == 2 )
      {
        newOrder(v5, v6, v7++);
      }
      else
      {
LABEL_10:
        printf("Invalid choice. Please try again.\n");
      }
    }
  }
  printBill(v5, v7);
  return 0;
}
// 14000170B: using guessed type __int64 __fastcall printMenu(_QWORD, _QWORD);
// 14000182F: using guessed type __int64 __fastcall newOrder(_QWORD, _QWORD, _QWORD);
// 1400019B2: using guessed type __int64 __fastcall printBill(_QWORD, _QWORD);
// 140001D20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>

int kprime(int n, int k)
{
	int p, f = 0;
	for (p = 2; f < k && p*p <= n; p++)
		while (0 == n % p)
			n /= p, f++;

	return f + (n > 1) == k;
}

int main(void)
{
	int i, c, k;

	for (k = 1; k <= 5; k++) {
		printf("k = %d:", k);

		for (i = 2, c = 0; c < 10; i++)
			if (kprime(i, k)) {
				printf(" %d", i);
				c++;
			}

		putchar('\n');
	}

	return 0;
}
`,`#include "almost-prime.h"



bool _kprime(int param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_4;
  
  local_10 = 0;
  local_c = 2;
  local_4 = param_1;
  while( true ) {
    bVar1 = false;
    if (local_10 < param_2) {
      bVar1 = local_c * local_c <= local_4;
    }
    if (!bVar1) break;
    while( true ) {
      iVar2 = 0;
      if (local_c != 0) {
        iVar2 = local_4 / local_c;
      }
      if (local_4 != iVar2 * local_c) break;
      iVar2 = 0;
      if (local_c != 0) {
        iVar2 = local_4 / local_c;
      }
      local_10 = local_10 + 1;
      local_4 = iVar2;
    }
    local_c = local_c + 1;
  }
  return local_10 + (uint)(1 < local_4) == param_2;
}



undefined8 entry(void)

{
  int iVar1;
  int local_20;
  int local_1c;
  int local_18;
  
  for (local_20 = 1; local_20 < 6; local_20 = local_20 + 1) {
    _printf("k = %d:");
    local_18 = 2;
    local_1c = 0;
    while (local_1c < 10) {
      iVar1 = _kprime(local_18,local_20);
      if (iVar1 != 0) {
        _printf(" %d");
        local_1c = local_1c + 1;
      }
      local_18 = local_18 + 1;
    }
    _putchar(10);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`// C program to find LCM of two numbers
/*
    suppose we have two numbers a and b.
    Property: Since product of LCM and GCD of two numbers are equal to product
   of that number itself. i.e, LCM(a,b)*GCD(a,b)=a*b. So,here we first find the
   GCD of two numbers and using above property we find LCM of that two numbers.
*/
#include <stdio.h>

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

// Function to return LCM of two numbers
int lcm(int a, int b) { return (a * b) / gcd(a, b); }

// Driver program
int main()
{
    int a, b;
    printf("Enter two numbers to find their LCM \n");
    scanf("%d%d", &a, &b);
    printf("LCM of %d and %d is %d ", a, b, lcm(a, b));
    return 0;
}
/*
Test Case1:
a=15,b=20
LCM(a,b)=60
Test Case2:
a=12,b=18
LCM(a,b)=36
*/
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e00(void);
int64_t function_100003e68(int64_t a1, int64_t a2);
int32_t function_100003f4c(char * format, ...);
int32_t function_100003f58(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e00 - 0x100003e68
int64_t function_100003e00(void) {
    // 0x100003e00
    int64_t v1; // 0x100003e00
    int64_t v2; // 0x100003e00
    if ((int32_t)v2 != 0) {
        // 0x100003e34
        v1 = function_100003e00();
    }
    // 0x100003e58
    return v1 & 0xffffffff;
}

// Address range: 0x100003e68 - 0x100003eac
int64_t function_100003e68(int64_t a1, int64_t a2) {
    // 0x100003e68
    return (int32_t)a2 * (int32_t)a1 / (int32_t)function_100003e00();
}

// Address range: 0x100003eac - 0x100003f4c
int64_t entry_point(void) {
    // 0x100003eac
    _printf("Enter two numbers to find their LCM \n");
    int64_t v1; // 0x100003eac
    _scanf("%d%d", (int64_t *)v1, (int64_t *)v1);
    int32_t v2; // 0x100003eac
    int64_t v3 = v2; // 0x100003f0c
    function_100003e68((int64_t)v2, v3);
    _printf("LCM of %d and %d is %d ", v3, v1, v1);
    return 0;
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * format, ...) {
    // 0x100003f4c
    return _printf(format);
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(char * format, ...) {
    // 0x100003f58
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`#include "stdio.h"
#include "math.h"

int perfect(int n) {
    int max = (int)sqrt((double)n) + 1;
    int tot = 1;
    int i;

    for (i = 2; i < max; i++)
        if ( (n % i) == 0 ) {
            tot += i;
            int q = n / i;
            if (q > i)
                tot += q;
        }

    return tot == n;
}

int main() {
    int n;
    for (n = 2; n < 33550337; n++)
        if (perfect(n))
            printf("%d\n", n);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e04(void);
int32_t function_100003f90(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e04 - 0x100003efc
int64_t function_100003e04(void) {
    // 0x100003e04
    int64_t v1; // 0x100003e04
    int32_t v2 = v1; // 0x100003e08
    __asm_sshll(0.0f, 0);
    float64_t v3; // 0x100003e04
    int32_t v4 = sqrt(v3); // 0x100003e20
    int32_t v5 = v4 + 1; // 0x100003e28
    int32_t v6 = 1 - v4; // 0x100003e48
    if (v6 < 0 == (v6 & v5) < 0) {
        // 0x100003ee0
        return 1 == v2;
    }
    int32_t v7 = 1;
    int32_t v8 = 2;
    int32_t v9 = v7; // 0x100003e74
    int32_t v10; // 0x100003e94
    int32_t v11; // 0x100003ea4
    int32_t v12; // 0x100003e04
    if (v2 % v8 == 0) {
        // 0x100003e7c
        v10 = v2 / v8;
        v11 = v10 - v8;
        v12 = v11 == 0 | v11 < 0 != ((v11 ^ v10) & (v10 ^ v8)) < 0 ? 0 : v10;
        v9 = v7 + v8 + v12;
    }
    int32_t v13 = v9;
    int32_t v14 = v8 + 1; // 0x100003ed4
    int32_t v15 = v14 - v5; // 0x100003e48
    while (v15 < 0 != ((v15 ^ v14) & (v14 ^ v5)) < 0) {
        // 0x100003e58
        v7 = v13;
        v8 = v14;
        v9 = v7;
        if (v2 % v8 == 0) {
            // 0x100003e7c
            v10 = v2 / v8;
            v11 = v10 - v8;
            v12 = v11 == 0 | v11 < 0 != ((v11 ^ v10) & (v10 ^ v8)) < 0 ? 0 : v10;
            v9 = v7 + v8 + v12;
        }
        // 0x100003ed0
        v13 = v9;
        v14 = v8 + 1;
        v15 = v14 - v5;
    }
    // 0x100003ee0
    return v13 == v2;
}

// Address range: 0x100003efc - 0x100003f90
int64_t entry_point(void) {
    int32_t v1 = 2;
    int64_t v2; // 0x100003efc
    if ((int32_t)function_100003e04() != 0) {
        // 0x100003f4c
        _printf("%d\n", v2);
    }
    int32_t v3 = v1 + 1; // 0x100003f74
    while (v1 < 0x1fff000 != (0x1ffefff - v1 & v3) < 0) {
        // 0x100003f34
        v1 = v3;
        if ((int32_t)function_100003e04() != 0) {
            // 0x100003f4c
            _printf("%d\n", v2);
        }
        // 0x100003f70
        v3 = v1 + 1;
    }
    // 0x100003f80
    return 0;
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(char * format, ...) {
    // 0x100003f90
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`//FormAI DATASET v1.0 Category: File handling ; Style: relaxed
#include <stdio.h>

int main() {
  FILE *file;
  char text[100];

  // Open the file for writing
  file = fopen("example.txt", "w");

  // Check if the file was opened successfully
  if (file == NULL) {
    printf("Error opening file\n");
    return 1;
  }

  // Write some text to the file
  fprintf(file, "This is an example text that we will write to a file using C file handling.\n");

  // Close the file
  fclose(file);

  // Open the file for reading
  file = fopen("example.txt", "r");

  // Check if the file was opened successfully
  if (file == NULL) {
    printf("Error opening file\n");
    return 1;
  }

  // Read the text from the file
  printf("The contents of the file are:\n");
  while (fgets(text, 100, file) != NULL) {
    printf("%s", text);
  }

  // Close the file
  fclose(file);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[104]; // [rsp+20h] [rbp-70h] BYREF
  FILE *Stream; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  Stream = fopen("example.txt", "w");
  if ( Stream
    && (fprintf_0(Stream, "This is an example text that we will write to a file using C file handling.\n"),
        fclose(Stream),
        (Stream = fopen("example.txt", "r")) != 0i64) )
  {
    printf("The contents of the file are:\n");
    while ( fgets(Buffer, 100, Stream) )
      printf("%s", Buffer);
    fclose(Stream);
    return 0;
  }
  else
  {
    printf("Error opening file\n");
    return 1;
  }
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>

const uint8_t masks[8] = {1, 2, 4, 8, 16, 32, 64, 128};

#define half(n) ((int64_t)((n) - 1) >> 1)

#define divide(nm, d) ((uint64_t)((double)nm / (double)d))

int64_t countPrimes(uint64_t n) {
    if (n < 9) return (n < 2) ? 0 : ((int64_t)n + 1) / 2;
    uint64_t rtlmt = (uint64_t)sqrt((double)n);
    int64_t mxndx = (int64_t)((rtlmt - 1) / 2);
    int arrlen = (int)(mxndx + 1);
    uint32_t *smalls = malloc(arrlen * 4);
    uint32_t *roughs = malloc(arrlen * 4);
    int64_t *larges  = malloc(arrlen * 8);
    for (int i = 0; i < arrlen; ++i) {
        smalls[i] = (uint32_t)i;
        roughs[i] = (uint32_t)(i + i + 1);
        larges[i] = (int64_t)((n/(uint64_t)(i + i + 1) - 1) / 2);
    }
    int cullbuflen = (int)((mxndx + 8) / 8);
    uint8_t *cullbuf = calloc(cullbuflen, 1);
    int64_t nbps = 0;
    int rilmt = arrlen;
    for (int64_t i = 1; ; ++i) {
        int64_t sqri = (i + i) * (i + 1);
        if (sqri > mxndx) break;
        if (cullbuf[i >> 3] & masks[i & 7]) continue;
        cullbuf[i >> 3] |= masks[i & 7];
        uint64_t bp = (uint64_t)(i + i + 1);
        for (int64_t c = sqri; c < (int64_t)arrlen; c += (int64_t)bp) {
            cullbuf[c >> 3] |= masks[c & 7];
        }
        int nri = 0;
        for (int ori = 0; ori < rilmt; ++ori) {
            uint32_t r = roughs[ori];
            int64_t rci = (int64_t)(r >> 1);
            if (cullbuf[rci >> 3] & masks[rci & 7]) continue;
            uint64_t d = (uint64_t)r * bp;
            int64_t t = (d <= rtlmt) ? larges[(int64_t)smalls[d >> 1] - nbps] :
                                       (int64_t)smalls[half(divide(n, d))];
            larges[nri] = larges[ori] - t + nbps;
            roughs[nri] = r;
            nri++;
        }
        int64_t si = mxndx;
        for (uint64_t pm = (rtlmt/bp - 1) | 1; pm >= bp; pm -= 2) {
            uint32_t c = smalls[pm >> 1];
            uint64_t e = (pm * bp) >> 1;
            for ( ; si >= (int64_t)e; --si) smalls[si] -= c - (uint32_t)nbps;
        }
        rilmt = nri;
        nbps++;
    }
    int64_t ans = larges[0] + (int64_t)((rilmt + 2*(nbps - 1)) * (rilmt - 1) / 2);
    int ri, sri;
    for (ri = 1; ri < rilmt; ++ri) ans -= larges[ri];
    for (ri = 1; ; ++ri) {
        uint64_t p = (uint64_t)roughs[ri];
        uint64_t m = n / p;
        int ei = (int)smalls[half((uint64_t)m/p)] - nbps;
        if (ei <= ri) break;
        ans -= (int64_t)((ei - ri) * (nbps + ri - 1));
        for (sri = ri + 1; sri < ei + 1; ++sri) {
            ans += (int64_t)smalls[half(divide(m, (uint64_t)roughs[sri]))];
        }
    }
    free(smalls);
    free(roughs);
    free(larges);
    free(cullbuf);
    return ans + 1;
}

int main() {
    uint64_t n;
    int i;
    clock_t start = clock();
    for (i = 0, n = 1; i < 10; ++i, n *= 10) {
        printf("10^%d %ld\n", i, countPrimes(n));
    }
    clock_t end = clock();
    printf("\nTook %f seconds\n", (double) (end - start) / CLOCKS_PER_SEC);
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003694(void);
int64_t * function_100003f34(int32_t nmemb, int32_t size);
int32_t function_100003f40(void);
void function_100003f4c(int64_t * ptr);
int64_t * function_100003f58(int32_t size);
int32_t function_100003f64(char * format, ...);

// --------------------- Global Variables ---------------------

char * g1 = "\x01\x02\x04\b\x10 @\x80\x31\x30^%d %ld\n"; // 0x100003f78

// ------- Dynamically Linked Functions Without Header --------

int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _clock(void);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003694 - 0x100003e5c
int64_t function_100003694(void) {
    // 0x100003694
    int64_t v1; // bp-136, 0x100003694
    int64_t v2 = &v1; // 0x1000036a8
    int64_t v3 = v2 + 88;
    int64_t v4; // 0x100003694
    if ((uint64_t)v4 < 9) {
        uint64_t v5 = *(int64_t *)v3; // 0x1000036c8
        int64_t result = 0; // 0x1000036d4
        if (v5 >= 2) {
            // 0x1000036e8
            result = (v5 + 1) / 2;
        }
        // 0x100003704
        *(int64_t *)(v2 + 96) = result;
        // 0x100003e44
        return result;
    }
    float64_t * v6 = (float64_t *)v3; // 0x100003718
    int64_t v7 = sqrt(*v6); // 0x100003724
    int64_t * v8 = (int64_t *)(v2 + 80); // 0x100003728
    *v8 = v7;
    uint64_t v9 = (v7 - 1) / 2; // 0x100003738
    int64_t * v10 = (int64_t *)(v2 + 72); // 0x10000373c
    *v10 = v9;
    int32_t v11 = v9;
    int32_t v12 = v11 + 1; // 0x100003748
    int32_t v13 = 4 * v12; // 0x100003750
    int64_t * v14 = _malloc(v13); // 0x10000375c
    int64_t * v15 = (int64_t *)(v2 + 56); // 0x100003764
    *v15 = (int64_t)v14;
    int64_t * v16 = _malloc(v13); // 0x100003778
    int64_t * v17 = (int64_t *)(v2 + 48); // 0x100003780
    *v17 = (int64_t)v16;
    int64_t * v18 = _malloc(8 * v12); // 0x100003794
    int64_t * v19 = (int64_t *)(v2 + 40); // 0x10000379c
    *v19 = (int64_t)v18;
    if (v11 > -1 != (v12 & -v11) < 0) {
        int32_t v20 = 0; // 0x100003830
        int64_t v21 = v20; // 0x1000037cc
        int64_t v22 = 4 * v21; // 0x1000037d0
        *(int32_t *)(v22 + *v15) = v20;
        int32_t v23 = 2 * v20 | 1; // 0x1000037e0
        *(int32_t *)(*v17 + v22) = v23;
        uint64_t v24 = *(int64_t *)v3; // 0x1000037f0
        *(int64_t *)(*v19 + 8 * v21) = (v24 / (int64_t)v23 - 1) / 2;
        v20++;
        while (v20 - v12 < 0 != ((v20 - v12 ^ v20) & (v20 ^ v12)) < 0) {
            // 0x1000037c0
            v21 = v20;
            v22 = 4 * v21;
            *(int32_t *)(v22 + *v15) = v20;
            v23 = 2 * v20 | 1;
            *(int32_t *)(*v17 + v22) = v23;
            v24 = *(int64_t *)v3;
            *(int64_t *)(*v19 + 8 * v21) = (v24 / (int64_t)v23 - 1) / 2;
            v20++;
        }
    }
    int64_t * v25 = _calloc((int32_t)((*v10 + 8) / 8), 1); // 0x100003860
    int64_t * v26 = (int64_t *)(v2 + 24); // 0x10000386c
    *v26 = (int64_t)v25;
    int64_t * v27 = (int64_t *)(v2 + 16); // 0x100003870
    *v27 = 0;
    v1 = 1;
    int64_t v28 = *v10; // 0x1000038a8
    int64_t v29 = 4 - v28; // 0x1000038ac
    int32_t v30 = v12; // 0x1000038b4
    if (v29 == 0 || v29 < 0 != (v29 & v28) < 0) {
        int64_t v31 = v12;
        int64_t v32 = 1; // 0x100003c18
        char * v33 = (char *)(*v26 + (v32 >> 3)); // 0x1000038d0
        char v34 = *v33; // 0x1000038d0
        char v35 = *(char *)(v32 % 8 | (int64_t)&g1); // 0x1000038e4
        int64_t v36 = v32; // 0x1000038f0
        int32_t v37 = v12; // 0x1000038f0
        int64_t v38; // 0x100003694
        int64_t v39; // 0x100003694
        int64_t v40; // 0x100003694
        int64_t v41; // 0x100003694
        int32_t v42; // 0x100003694
        int32_t v43; // 0x100003694
        int32_t v44; // 0x100003694
        int64_t v45; // 0x100003694
        int64_t v46; // 0x100003694
        uint64_t v47; // 0x100003694
        int64_t v48; // 0x100003694
        int32_t v49; // 0x100003694
        int64_t v50; // 0x100003694
        uint64_t v51; // 0x100003a38
        uint64_t v52; // 0x100003a44
        int32_t v53; // 0x100003b10
        int32_t v54; // 0x1000039c0
        uint64_t v55; // 0x100003b80
        int64_t v56; // 0x100003b94
        int64_t v57; // 0x100003a88
        float64_t v58; // 0x100003a8c
        uint32_t v59; // 0x100003aac
        int64_t v60; // 0x100003a5c
        uint32_t v61; // 0x100003a6c
        int64_t v62; // 0x100003a70
        int64_t v63; // 0x100003b60
        int32_t v64; // 0x100003b6c
        int32_t * v65; // 0x100003bc0
        int64_t v66; // 0x100003bd4
        int64_t v67; // 0x100003b94
        int64_t v68; // 0x100003be8
        int64_t v69; // 0x100003acc
        int64_t v70; // 0x100003ae4
        int32_t * v71; // 0x100003bc0
        int64_t v72; // 0x100003bd4
        int64_t v73; // 0x100003b94
        uint64_t v74; // 0x100003938
        int64_t v75; // 0x100003954
        int32_t v76; // 0x1000039c0
        char v77; // 0x100003978
        char * v78; // 0x100003988
        int64_t v79; // 0x1000039a0
        int64_t v80; // 0x100003954
        int64_t v81; // 0x100003b38
        int64_t v82; // 0x1000039d8
        uint32_t v83; // 0x1000039dc
        uint64_t v84; // 0x1000039ec
        char v85; // 0x100003a00
        if ((v35 & v34) == 0) {
            // 0x1000038fc
            v41 = 4;
            *v33 = v35 | v34;
            v74 = 2 * v1 | 1;
            v75 = v41 - v31;
            v48 = v41;
            if (v75 < 0 != ((v75 ^ v41) & (v41 ^ v31)) < 0) {
                v77 = *(char *)(v48 % 8 | (int64_t)&g1);
                v78 = (char *)(*v26 + (v48 >> 3));
                *v78 = *v78 | v77;
                v79 = v48 + v74;
                v80 = v79 - v31;
                v48 = v79;
                while (v80 < 0 != ((v80 ^ v79) & (v79 ^ v31)) < 0) {
                    // 0x100003964
                    v77 = *(char *)(v48 % 8 | (int64_t)&g1);
                    v78 = (char *)(*v26 + (v48 >> 3));
                    *v78 = *v78 | v77;
                    v79 = v48 + v74;
                    v80 = v79 - v31;
                    v48 = v79;
                }
            }
            // 0x1000039b8
            v76 = -v12;
            v49 = 0;
            v43 = 0;
            if (v76 < 0 != (v12 & v76) < 0) {
                v42 = 0;
                v82 = v49;
                v83 = *(int32_t *)(*v17 + 4 * v82);
                v84 = (int64_t)(v83 / 2);
                v85 = *(char *)(v84 / 8 + *v26);
                v44 = v42;
                if ((*(char *)(v84 % 8 | (int64_t)&g1) & v85) == 0) {
                    // 0x100003a2c
                    v51 = v74 * (int64_t)v83;
                    v52 = *v8;
                    if (v51 >= v52 == (v51 != v52)) {
                        // 0x100003a84
                        v57 = *v15;
                        v58 = *v6;
                        v59 = *(int32_t *)(4 * ((int64_t)(v58 / (float64_t)v51) + 0x7fffffffffffffff) / 2 + v57);
                        v38 = *v27;
                        v39 = *v19;
                        v50 = v59;
                    } else {
                        // 0x100003a58
                        v60 = *v19;
                        v61 = *(int32_t *)(*v15 + 4 * v51 / 2);
                        v62 = *v27;
                        v38 = v62;
                        v39 = v60;
                        v50 = *(int64_t *)(8 * ((int64_t)v61 - v62) + v60);
                    }
                    // 0x100003ab8
                    v69 = *(int64_t *)(v39 + 8 * v82);
                    v70 = v42;
                    *(int64_t *)(v39 + 8 * v70) = v38 - v50 + v69;
                    *(int32_t *)(*v17 + 4 * v70) = v83;
                    v44 = v42 + 1;
                }
                // 0x100003b0c
                v53 = v49 + 1;
                v54 = v53 - v12;
                v49 = v53;
                v43 = v44;
                while (v54 < 0 != ((v54 ^ v53) & (v53 ^ v12)) < 0) {
                    // 0x1000039d0
                    v42 = v44;
                    v82 = v49;
                    v83 = *(int32_t *)(*v17 + 4 * v82);
                    v84 = (int64_t)(v83 / 2);
                    v85 = *(char *)(v84 / 8 + *v26);
                    v44 = v42;
                    if ((*(char *)(v84 % 8 | (int64_t)&g1) & v85) == 0) {
                        // 0x100003a2c
                        v51 = v74 * (int64_t)v83;
                        v52 = *v8;
                        if (v51 >= v52 == (v51 != v52)) {
                            // 0x100003a84
                            v57 = *v15;
                            v58 = *v6;
                            v59 = *(int32_t *)(4 * ((int64_t)(v58 / (float64_t)v51) + 0x7fffffffffffffff) / 2 + v57);
                            v38 = *v27;
                            v39 = *v19;
                            v50 = v59;
                        } else {
                            // 0x100003a58
                            v60 = *v19;
                            v61 = *(int32_t *)(*v15 + 4 * v51 / 2);
                            v62 = *v27;
                            v38 = v62;
                            v39 = v60;
                            v50 = *(int64_t *)(8 * ((int64_t)v61 - v62) + v60);
                        }
                        // 0x100003ab8
                        v69 = *(int64_t *)(v39 + 8 * v82);
                        v70 = v42;
                        *(int64_t *)(v39 + 8 * v70) = v38 - v50 + v69;
                        *(int32_t *)(*v17 + 4 * v70) = v83;
                        v44 = v42 + 1;
                    }
                    // 0x100003b0c
                    v53 = v49 + 1;
                    v54 = v53 - v12;
                    v49 = v53;
                    v43 = v44;
                }
            }
            // 0x100003b1c
            v37 = v43;
            v81 = *v8 / v74 - 1 | 1;
            if (v81 >= v74) {
                // 0x100003b5c
                v45 = *v10;
                v47 = v81;
                v55 = v47 * v74 / 2;
                v56 = v45 - v55;
                v46 = v45;
                if (v56 < 0 == ((v56 ^ -0x8000000000000000) & v45) < 0) {
                    // 0x100003ba4
                    v63 = *v15;
                    v64 = *(int32_t *)(v63 + 4 * v47 / 2);
                    v65 = (int32_t *)(4 * v45 + v63);
                    *v65 = (int32_t)*v27 - v64 + *v65;
                    v66 = v45 - 1;
                    v67 = v66 - v55;
                    v40 = v66;
                    v46 = v66;
                    if (v67 < 0 == ((v67 ^ -0x8000000000000000) & v66) < 0) {
                        v71 = (int32_t *)(4 * v40 + *v15);
                        *v71 = (int32_t)*v27 - v64 + *v71;
                        v72 = v40 - 1;
                        v73 = v72 - v55;
                        v40 = v72;
                        v46 = v72;
                        while (v73 < 0 == ((v73 ^ -0x8000000000000000) & v72) < 0) {
                            // 0x100003ba4
                            v71 = (int32_t *)(4 * v40 + *v15);
                            *v71 = (int32_t)*v27 - v64 + *v71;
                            v72 = v40 - 1;
                            v73 = v72 - v55;
                            v40 = v72;
                            v46 = v72;
                        }
                    }
                }
                // 0x100003be4
                v68 = v47 - 2;
                while (v68 >= v74) {
                    // 0x100003b5c
                    v45 = v46;
                    v47 = v68;
                    v55 = v47 * v74 / 2;
                    v56 = v45 - v55;
                    v46 = v45;
                    if (v56 < 0 == ((v56 ^ -0x8000000000000000) & v45) < 0) {
                        // 0x100003ba4
                        v63 = *v15;
                        v64 = *(int32_t *)(v63 + 4 * v47 / 2);
                        v65 = (int32_t *)(4 * v45 + v63);
                        *v65 = (int32_t)*v27 - v64 + *v65;
                        v66 = v45 - 1;
                        v67 = v66 - v55;
                        v40 = v66;
                        v46 = v66;
                        if (v67 < 0 == ((v67 ^ -0x8000000000000000) & v66) < 0) {
                            v71 = (int32_t *)(4 * v40 + *v15);
                            *v71 = (int32_t)*v27 - v64 + *v71;
                            v72 = v40 - 1;
                            v73 = v72 - v55;
                            v40 = v72;
                            v46 = v72;
                            while (v73 < 0 == ((v73 ^ -0x8000000000000000) & v72) < 0) {
                                // 0x100003ba4
                                v71 = (int32_t *)(4 * v40 + *v15);
                                *v71 = (int32_t)*v27 - v64 + *v71;
                                v72 = v40 - 1;
                                v73 = v72 - v55;
                                v40 = v72;
                                v46 = v72;
                            }
                        }
                    }
                    // 0x100003be4
                    v68 = v47 - 2;
                }
            }
            // 0x100003bf4
            *v27 = *v27 + 1;
            v36 = v1;
        }
        int32_t v86 = v37;
        v32 = v36 + 1;
        v1 = v32;
        int64_t v87 = 2 * v32 * (v36 + 2); // 0x10000389c
        int64_t v88 = *v10; // 0x1000038a8
        int64_t v89 = v87 - v88; // 0x1000038ac
        v30 = v86;
        while (v89 == 0 || v89 < 0 != ((v89 ^ v87) & (v88 ^ v87)) < 0) {
            int32_t v90 = v86;
            v33 = (char *)(*v26 + (v32 >> 3));
            v34 = *v33;
            v35 = *(char *)(v32 % 8 | (int64_t)&g1);
            v36 = v32;
            v37 = v90;
            if ((v35 & v34) == 0) {
                // 0x1000038fc
                v41 = v87;
                *v33 = v35 | v34;
                v74 = 2 * v1 | 1;
                v75 = v41 - v31;
                v48 = v41;
                if (v75 < 0 != ((v75 ^ v41) & (v41 ^ v31)) < 0) {
                    v77 = *(char *)(v48 % 8 | (int64_t)&g1);
                    v78 = (char *)(*v26 + (v48 >> 3));
                    *v78 = *v78 | v77;
                    v79 = v48 + v74;
                    v80 = v79 - v31;
                    v48 = v79;
                    while (v80 < 0 != ((v80 ^ v79) & (v79 ^ v31)) < 0) {
                        // 0x100003964
                        v77 = *(char *)(v48 % 8 | (int64_t)&g1);
                        v78 = (char *)(*v26 + (v48 >> 3));
                        *v78 = *v78 | v77;
                        v79 = v48 + v74;
                        v80 = v79 - v31;
                        v48 = v79;
                    }
                }
                // 0x1000039b8
                v76 = -v90;
                v49 = 0;
                v43 = 0;
                if (v76 < 0 != (v90 & v76) < 0) {
                    v42 = 0;
                    v82 = v49;
                    v83 = *(int32_t *)(*v17 + 4 * v82);
                    v84 = (int64_t)(v83 / 2);
                    v85 = *(char *)(v84 / 8 + *v26);
                    v44 = v42;
                    if ((*(char *)(v84 % 8 | (int64_t)&g1) & v85) == 0) {
                        // 0x100003a2c
                        v51 = v74 * (int64_t)v83;
                        v52 = *v8;
                        if (v51 >= v52 == (v51 != v52)) {
                            // 0x100003a84
                            v57 = *v15;
                            v58 = *v6;
                            v59 = *(int32_t *)(4 * ((int64_t)(v58 / (float64_t)v51) + 0x7fffffffffffffff) / 2 + v57);
                            v38 = *v27;
                            v39 = *v19;
                            v50 = v59;
                        } else {
                            // 0x100003a58
                            v60 = *v19;
                            v61 = *(int32_t *)(*v15 + 4 * v51 / 2);
                            v62 = *v27;
                            v38 = v62;
                            v39 = v60;
                            v50 = *(int64_t *)(8 * ((int64_t)v61 - v62) + v60);
                        }
                        // 0x100003ab8
                        v69 = *(int64_t *)(v39 + 8 * v82);
                        v70 = v42;
                        *(int64_t *)(v39 + 8 * v70) = v38 - v50 + v69;
                        *(int32_t *)(*v17 + 4 * v70) = v83;
                        v44 = v42 + 1;
                    }
                    // 0x100003b0c
                    v53 = v49 + 1;
                    v54 = v53 - v90;
                    v49 = v53;
                    v43 = v44;
                    while (v54 < 0 != ((v54 ^ v53) & (v53 ^ v90)) < 0) {
                        // 0x1000039d0
                        v42 = v44;
                        v82 = v49;
                        v83 = *(int32_t *)(*v17 + 4 * v82);
                        v84 = (int64_t)(v83 / 2);
                        v85 = *(char *)(v84 / 8 + *v26);
                        v44 = v42;
                        if ((*(char *)(v84 % 8 | (int64_t)&g1) & v85) == 0) {
                            // 0x100003a2c
                            v51 = v74 * (int64_t)v83;
                            v52 = *v8;
                            if (v51 >= v52 == (v51 != v52)) {
                                // 0x100003a84
                                v57 = *v15;
                                v58 = *v6;
                                v59 = *(int32_t *)(4 * ((int64_t)(v58 / (float64_t)v51) + 0x7fffffffffffffff) / 2 + v57);
                                v38 = *v27;
                                v39 = *v19;
                                v50 = v59;
                            } else {
                                // 0x100003a58
                                v60 = *v19;
                                v61 = *(int32_t *)(*v15 + 4 * v51 / 2);
                                v62 = *v27;
                                v38 = v62;
                                v39 = v60;
                                v50 = *(int64_t *)(8 * ((int64_t)v61 - v62) + v60);
                            }
                            // 0x100003ab8
                            v69 = *(int64_t *)(v39 + 8 * v82);
                            v70 = v42;
                            *(int64_t *)(v39 + 8 * v70) = v38 - v50 + v69;
                            *(int32_t *)(*v17 + 4 * v70) = v83;
                            v44 = v42 + 1;
                        }
                        // 0x100003b0c
                        v53 = v49 + 1;
                        v54 = v53 - v90;
                        v49 = v53;
                        v43 = v44;
                    }
                }
                // 0x100003b1c
                v37 = v43;
                v81 = *v8 / v74 - 1 | 1;
                if (v81 >= v74) {
                    // 0x100003b5c
                    v45 = *v10;
                    v47 = v81;
                    v55 = v47 * v74 / 2;
                    v56 = v45 - v55;
                    v46 = v45;
                    if (v56 < 0 == ((v56 ^ -0x8000000000000000) & v45) < 0) {
                        // 0x100003ba4
                        v63 = *v15;
                        v64 = *(int32_t *)(v63 + 4 * v47 / 2);
                        v65 = (int32_t *)(4 * v45 + v63);
                        *v65 = (int32_t)*v27 - v64 + *v65;
                        v66 = v45 - 1;
                        v67 = v66 - v55;
                        v40 = v66;
                        v46 = v66;
                        if (v67 < 0 == ((v67 ^ -0x8000000000000000) & v66) < 0) {
                            v71 = (int32_t *)(4 * v40 + *v15);
                            *v71 = (int32_t)*v27 - v64 + *v71;
                            v72 = v40 - 1;
                            v73 = v72 - v55;
                            v40 = v72;
                            v46 = v72;
                            while (v73 < 0 == ((v73 ^ -0x8000000000000000) & v72) < 0) {
                                // 0x100003ba4
                                v71 = (int32_t *)(4 * v40 + *v15);
                                *v71 = (int32_t)*v27 - v64 + *v71;
                                v72 = v40 - 1;
                                v73 = v72 - v55;
                                v40 = v72;
                                v46 = v72;
                            }
                        }
                    }
                    // 0x100003be4
                    v68 = v47 - 2;
                    while (v68 >= v74) {
                        // 0x100003b5c
                        v45 = v46;
                        v47 = v68;
                        v55 = v47 * v74 / 2;
                        v56 = v45 - v55;
                        v46 = v45;
                        if (v56 < 0 == ((v56 ^ -0x8000000000000000) & v45) < 0) {
                            // 0x100003ba4
                            v63 = *v15;
                            v64 = *(int32_t *)(v63 + 4 * v47 / 2);
                            v65 = (int32_t *)(4 * v45 + v63);
                            *v65 = (int32_t)*v27 - v64 + *v65;
                            v66 = v45 - 1;
                            v67 = v66 - v55;
                            v40 = v66;
                            v46 = v66;
                            if (v67 < 0 == ((v67 ^ -0x8000000000000000) & v66) < 0) {
                                v71 = (int32_t *)(4 * v40 + *v15);
                                *v71 = (int32_t)*v27 - v64 + *v71;
                                v72 = v40 - 1;
                                v73 = v72 - v55;
                                v40 = v72;
                                v46 = v72;
                                while (v73 < 0 == ((v73 ^ -0x8000000000000000) & v72) < 0) {
                                    // 0x100003ba4
                                    v71 = (int32_t *)(4 * v40 + *v15);
                                    *v71 = (int32_t)*v27 - v64 + *v71;
                                    v72 = v40 - 1;
                                    v73 = v72 - v55;
                                    v40 = v72;
                                    v46 = v72;
                                }
                            }
                        }
                        // 0x100003be4
                        v68 = v47 - 2;
                    }
                }
                // 0x100003bf4
                *v27 = *v27 + 1;
                v36 = v1;
            }
            // 0x100003c10
            v86 = v37;
            v32 = v36 + 1;
            v1 = v32;
            v87 = 2 * v32 * (v36 + 2);
            v88 = *v10;
            v89 = v87 - v88;
            v30 = v86;
        }
    }
    int32_t v91 = v30;
    int64_t v92 = *v19; // 0x100003c28
    int64_t v93 = *(int64_t *)v92; // 0x100003c2c
    int64_t v94 = *v27; // 0x100003c34
    int64_t v95 = ((int64_t)v91 - 2 + 2 * v94) * (int64_t)(v91 - 1) / 2 + v93; // 0x100003c64
    int32_t v96 = 1 - v91; // 0x100003c7c
    int64_t v97 = v95; // 0x100003c84
    int32_t v98 = 1; // 0x100003c84
    int64_t v99 = v95; // 0x100003c84
    if (v96 < 0 != (v96 & v91) < 0) {
        v99 -= *(int64_t *)(8 * (int64_t)v98 + v92);
        v98++;
        int32_t v100 = v98 - v91; // 0x100003c7c
        v97 = v99;
        while (v100 < 0 != ((v100 ^ v98) & (v98 ^ v91)) < 0) {
            // 0x100003c8c
            v99 -= *(int64_t *)(8 * (int64_t)v98 + v92);
            v98++;
            v100 = v98 - v91;
            v97 = v99;
        }
    }
    int64_t v101 = *v17; // 0x100003ccc
    int64_t v102 = *v15; // 0x100003cec
    int32_t v103 = 1;
    int64_t v104 = v97;
    int64_t v105 = v103; // 0x100003cd0
    uint64_t v106 = (int64_t)*(int32_t *)(4 * v105 + v101); // 0x100003cd4
    uint64_t v107 = *(int64_t *)v3 / v106; // 0x100003ce4
    int32_t v108 = *(int32_t *)(4 * (v107 / v106 + 0x7fffffffffffffff) / 2 + v102); // 0x100003d04
    int32_t v109 = v108 - (int32_t)v94; // 0x100003d10
    int32_t v110 = v109 - v103; // 0x100003d1c
    while (v110 != 0 && v110 < 0 == ((v110 ^ v109) & (v109 ^ v103)) < 0) {
        int64_t v111 = v104 - (v94 - 1 + v105) * (int64_t)v110; // 0x100003d60
        v103++;
        int32_t v112 = v109 + 1; // 0x100003d80
        int32_t v113 = v103 - v112; // 0x100003d84
        int32_t v114 = v103; // 0x100003d8c
        int64_t v115 = v111; // 0x100003d8c
        int64_t v116 = v111; // 0x100003d8c
        if (v113 < 0 != ((v113 ^ v103) & (v112 ^ v103)) < 0) {
            uint32_t v117 = *(int32_t *)(4 * (int64_t)v114 + v101); // 0x100003dac
            uint32_t v118 = *(int32_t *)(4 * ((int64_t)((float64_t)v107 / (float64_t)v117) + 0x7fffffffffffffff) / 2 + v102); // 0x100003dc4
            int64_t v119 = v115 + (int64_t)v118; // 0x100003dd0
            int32_t v120 = v114 + 1;
            int32_t v121 = v120 - v112; // 0x100003d84
            v114 = v120;
            v115 = v119;
            v116 = v119;
            while (v121 < 0 != ((v121 ^ v120) & (v120 ^ v112)) < 0) {
                // 0x100003d94
                v117 = *(int32_t *)(4 * (int64_t)v114 + v101);
                v118 = *(int32_t *)(4 * ((int64_t)((float64_t)v107 / (float64_t)v117) + 0x7fffffffffffffff) / 2 + v102);
                v119 = v115 + (int64_t)v118;
                v120 = v114 + 1;
                v121 = v120 - v112;
                v114 = v120;
                v115 = v119;
                v116 = v119;
            }
        }
        v104 = v116;
        v105 = v103;
        v106 = (int64_t)*(int32_t *)(4 * v105 + v101);
        v107 = *(int64_t *)v3 / v106;
        v108 = *(int32_t *)(4 * (v107 / v106 + 0x7fffffffffffffff) / 2 + v102);
        v109 = v108 - (int32_t)v94;
        v110 = v109 - v103;
    }
    // 0x100003e00
    _free((int64_t *)v102);
    _free((int64_t *)*v17);
    _free((int64_t *)*v19);
    _free((int64_t *)*v26);
    int64_t result2 = v104 + 1; // 0x100003e38
    *(int64_t *)(v2 + 96) = result2;
    // 0x100003e44
    return result2;
}

// Address range: 0x100003e5c - 0x100003f34
int64_t entry_point(void) {
    // 0x100003e5c
    _clock();
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003e98
        function_100003694();
        int64_t v1; // 0x100003e5c
        _printf("10^%d %ld\n", v1, (int32_t)v1);
    }
    // 0x100003eec
    _clock();
    int128_t v2; // 0x100003e5c
    _printf("\nTook %f seconds\n", (float64_t)(int64_t)v2);
    return 0;
}

// Address range: 0x100003f34 - 0x100003f40
int64_t * function_100003f34(int32_t nmemb, int32_t size) {
    // 0x100003f34
    return _calloc(nmemb, size);
}

// Address range: 0x100003f40 - 0x100003f4c
int32_t function_100003f40(void) {
    // 0x100003f40
    return _clock();
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(int64_t * ptr) {
    // 0x100003f4c
    _free(ptr);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t * function_100003f58(int32_t size) {
    // 0x100003f58
    return _malloc(size);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`//FormAI DATASET v1.0 Category: File handling ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Student {
    char name[50];
    int age;
    int marks;
};

void addStudent() {
    struct Student s;
    FILE *fp;
    fp = fopen("students.data", "ab");

    printf("Enter student name: ");
    scanf("%s", s.name);

    printf("Enter student age: ");
    scanf("%d", &s.age);

    printf("Enter student marks: ");
    scanf("%d", &s.marks);

    fwrite(&s, sizeof(struct Student), 1, fp);
    fclose(fp);

    printf("Student added successfully!\n");
}

void listStudents() {
    FILE *fp;
    struct Student s;

    fp = fopen("students.data", "rb");

    while (fread(&s, sizeof(struct Student), 1, fp)) {
        printf("Name: %s\n", s.name);
        printf("Age: %d\n", s.age);
        printf("Marks: %d\n", s.marks);
        printf("------------\n");
    }

    fclose(fp);
}

void searchStudent() {
    FILE *fp;
    struct Student s;
    char name[50];

    fp = fopen("students.data", "rb");
    printf("Enter student name: ");
    scanf("%s", name);

    while (fread(&s, sizeof(struct Student), 1, fp)) {
        if (strcmp(s.name, name) == 0) {
            printf("Name: %s\n", s.name);
            printf("Age: %d\n", s.age);
            printf("Marks: %d\n", s.marks);
            printf("------------\n");
        }
    }
    fclose(fp);
}

void deleteStudent() {
    FILE *fp, *temp;
    struct Student s;
    char name[50];
    int found = 0;

    fp = fopen("students.data", "rb");
    temp = fopen("temp.data", "wb");

    printf("Enter student name: ");
    scanf("%s", name);

    while (fread(&s, sizeof(struct Student), 1, fp)) {
        if (strcmp(s.name, name) != 0) {
            fwrite(&s, sizeof(struct Student), 1, temp);
        } else {
            found++;
            printf("Student deleted successfully!\n");
        }
    }
    fclose(fp);
    fclose(temp);

    if (found == 0) {
        printf("No student found with the name %s\n", name);
    }

    remove("students.data");
    rename("temp.data", "students.data");
}

int main() {
    int choice;

    while (1) {
        printf("1. Add student\n2. List all students\n3. Search student\n4. Delete student\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                addStudent();
                break;
            case 2:
                listStudents();
                break;
            case 3:
                searchStudent();
                break;
            case 4:
                deleteStudent();
                break;
            case 5:
                exit(0);
            default:
                printf("Invalid choice. Please select from the available options.\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 addStudent(void); // weak
__int64 listStudents(void); // weak
__int64 searchStudent(void); // weak
__int64 deleteStudent(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400019A7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    printf("1. Add student\n2. List all students\n3. Search student\n4. Delete student\n5. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        addStudent();
        break;
      case 2:
        listStudents();
        break;
      case 3:
        searchStudent();
        break;
      case 4:
        deleteStudent();
        break;
      case 5:
        exit(0);
      default:
        printf("Invalid choice. Please select from the available options.\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 addStudent(void);
// 1400016BE: using guessed type __int64 listStudents(void);
// 140001768: using guessed type __int64 searchStudent(void);
// 14000185B: using guessed type __int64 deleteStudent(void);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>


#define MAXLEN 100
typedef char TWord[MAXLEN];


typedef struct Node {
    TWord word;
    struct Node *next;
} Node;


int is_ordered_word(const TWord word) {
    assert(word != NULL);
    int i;

    for (i = 0; word[i] != '\0'; i++)
        if (word[i] > word[i + 1] && word[i + 1] != '\0')
            return 0;

    return 1;
}


Node* list_prepend(Node* words_list, const TWord new_word) {
    assert(new_word != NULL);
    Node *new_node = malloc(sizeof(Node));
    if (new_node == NULL)
        exit(EXIT_FAILURE);

    strcpy(new_node->word, new_word);
    new_node->next = words_list;
    return new_node;
}


Node* list_destroy(Node *words_list) {
    while (words_list != NULL) {
        Node *temp = words_list;
        words_list = words_list->next;
        free(temp);
    }

    return words_list;
}


void list_print(Node *words_list) {
    while (words_list != NULL) {
        printf("\n%s", words_list->word);
        words_list = words_list->next;
    }
}


int main() {
    FILE *fp = fopen("unixdict.txt", "r");
    if (fp == NULL)
        return EXIT_FAILURE;

    Node *words = NULL;
    TWord line;
    unsigned int max_len = 0;

    while (fscanf(fp, "%99s\n", line) != EOF) {
        if (strlen(line) > max_len && is_ordered_word(line)) {
            max_len = strlen(line);
            words = list_destroy(words);
            words = list_prepend(words, line);
        } else if (strlen(line) == max_len && is_ordered_word(line)) {
            words = list_prepend(words, line);
        }
    }

    fclose(fp);
    list_print(words);

    return EXIT_SUCCESS;
}
`,`#include "ordered-words-1.h"



undefined4 _is_ordered_word(long param_1)

{
  int local_24;
  
  if (param_1 == 0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("is_ordered_word","ordered-words-1.c",0x12,"word != NULL");
  }
  local_24 = 0;
  while( true ) {
    if (*(char *)(param_1 + local_24) == '\0') {
      return 1;
    }
    if ((*(char *)(param_1 + (local_24 + 1)) < *(char *)(param_1 + local_24)) &&
       (*(char *)(param_1 + (local_24 + 1)) != '\0')) break;
    local_24 = local_24 + 1;
  }
  return 0;
}



void * _list_prepend(undefined8 param_1,long param_2)

{
  void *pvVar1;
  
  if (param_2 == 0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("list_prepend","ordered-words-1.c",0x1e,"new_word != NULL");
  }
  pvVar1 = _malloc(0x70);
  if (pvVar1 == (void *)0x0) {
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  ___strcpy_chk(pvVar1,param_2,100);
  *(undefined8 *)((long)pvVar1 + 0x68) = param_1;
  return pvVar1;
}



undefined8 _list_destroy(void *param_1)

{
  void *pvVar1;
  undefined8 local_18;
  
  local_18 = param_1;
  while (local_18 != (void *)0x0) {
    pvVar1 = *(void **)((long)local_18 + 0x68);
    _free(local_18);
    local_18 = pvVar1;
  }
  return 0;
}



ulong _list_print(ulong param_1)

{
  uint uVar1;
  ulong local_18;
  
  for (local_18 = param_1; local_18 != 0; local_18 = *(ulong *)(local_18 + 0x68)) {
    uVar1 = _printf("\n%s");
    param_1 = (ulong)uVar1;
  }
  return param_1;
}



undefined4 entry(void)

{
  int iVar1;
  FILE *pFVar2;
  size_t sVar3;
  undefined8 uVar4;
  uint local_94;
  undefined8 local_90;
  undefined4 local_80;
  char acStack_7c [100];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  pFVar2 = _fopen("unixdict.txt","r");
  if (pFVar2 == (FILE *)0x0) {
    local_80 = 1;
  }
  else {
    local_90 = 0;
    local_94 = 0;
    while (iVar1 = _fscanf(pFVar2,"%99s\n"), iVar1 != -1) {
      sVar3 = _strlen(acStack_7c);
      if ((local_94 < sVar3) && (iVar1 = _is_ordered_word(acStack_7c), iVar1 != 0)) {
        sVar3 = _strlen(acStack_7c);
        local_94 = (uint)sVar3;
        uVar4 = _list_destroy(local_90);
        local_90 = _list_prepend(uVar4,acStack_7c);
      }
      else {
        sVar3 = _strlen(acStack_7c);
        if ((sVar3 == local_94) && (iVar1 = _is_ordered_word(acStack_7c), iVar1 != 0)) {
          local_90 = _list_prepend(local_90,acStack_7c);
        }
      }
    }
    _fclose(pFVar2);
    _list_print(local_90);
    local_80 = 0;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return local_80;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004030)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004038)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fscanf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fscanf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004048)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004058)();
  return sVar1;
}


`
`#include <stdio.h>

int circle_sort_inner(int *start, int *end)
{
	int *p, *q, t, swapped;

	if (start == end) return 0;

	// funny "||" on next line is for the center element of odd-lengthed array
	for (swapped = 0, p = start, q = end; p<q || (p==q && ++q); p++, q--)
		if (*p > *q)
			t = *p, *p = *q, *q = t, swapped = 1;

	// q == p-1 at this point
	return swapped | circle_sort_inner(start, q) | circle_sort_inner(p, end);
}

//helper function to show arrays before each call
void circle_sort(int *x, int n)
{
	do {
		int i;
		for (i = 0; i < n; i++) printf("%d ", x[i]);
		putchar('\n');
	} while (circle_sort_inner(x, x + (n - 1)));
}

int main(void)
{
	int x[] = {5, -1, 101, -4, 0, 1, 8, 6, 2, 3};
	circle_sort(x, sizeof(x) / sizeof(*x));

	return 0;
}
`,`#include "sorting-algorithms-circle-sort.h"



uint _circle_sort_inner(int *param_1,int *param_2)

{
  int iVar1;
  bool bVar2;
  uint uVar3;
  uint local_40;
  int *local_38;
  int *local_30;
  uint local_14;
  
  if (param_1 == param_2) {
    local_14 = 0;
  }
  else {
    local_40 = 0;
    local_38 = param_2;
    local_30 = param_1;
    while( true ) {
      bVar2 = true;
      if ((local_38 <= local_30) && (bVar2 = false, local_30 == local_38)) {
        local_38 = local_38 + 1;
        bVar2 = local_38 != (int *)0x0;
      }
      if (!bVar2) break;
      if (*local_38 < *local_30) {
        iVar1 = *local_30;
        *local_30 = *local_38;
        *local_38 = iVar1;
        local_40 = 1;
      }
      local_30 = local_30 + 1;
      local_38 = local_38 + -1;
    }
    uVar3 = _circle_sort_inner(param_1,local_38);
    local_14 = _circle_sort_inner(local_30,param_2);
    local_14 = local_40 | uVar3 | local_14;
  }
  return local_14;
}



void _circle_sort(long param_1,int param_2)

{
  int iVar1;
  int local_20;
  
  do {
    for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
      _printf("%d ");
    }
    _putchar(10);
    iVar1 = _circle_sort_inner(param_1,param_1 + (long)(param_2 + -1) * 4);
  } while (iVar1 != 0);
  return;
}



undefined8 entry(void)

{
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_40,&DAT_100003f80,0x28);
  _circle_sort(auStack_40,10);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004020)(param_1);
  return iVar1;
}


`
`#include <stdio.h>

double squaredsum(double *l, int e)
{
   int i; double sum = 0.0;
   for(i = 0 ; i < e ; i++) sum += l[i]*l[i];
   return sum;
}

int main()
{
   double list[6] = {3.0, 1.0, 4.0, 1.0, 5.0, 9.0};

   printf("%lf\n", squaredsum(list, 6));
   printf("%lf\n", squaredsum(list, 0));
   /* the same without using a real list as if it were 0-element long */
   printf("%lf\n", squaredsum(NULL, 0));
   return 0;
}
`,`#include "sum-of-squares.h"



undefined  [16] _squaredsum(long param_1,int param_2)

{
  undefined auVar1 [16];
  undefined8 local_18;
  undefined4 local_10;
  
  local_18 = 0;
  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {
    local_18 = NEON_fmadd(*(undefined8 *)(param_1 + (long)local_10 * 8),
                          *(undefined8 *)(param_1 + (long)local_10 * 8),local_18);
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_18;
  return auVar1;
}



undefined8 entry(void)

{
  int iVar1;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memset(&local_48,0,0x30);
  local_48 = 0x4008000000000000;
  local_40 = 0x3ff0000000000000;
  local_38 = 0x4010000000000000;
  local_30 = 0x3ff0000000000000;
  local_28 = 0x4014000000000000;
  local_20 = 0x4022000000000000;
  _squaredsum(&local_48,6);
  _printf("%lf\n");
  _squaredsum(&local_48,0);
  _printf("%lf\n");
  _squaredsum(0,0);
  iVar1 = _printf("%lf\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004010)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
	printf("\033[7mReversed\033[m Normal\n");

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f84(char * format, ...);

// --------------------- Global Variables ---------------------

char * g1 = "\x1b[7mReversed\x1b[m Normal\n"; // 0x100003f90

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003f50 - 0x100003f84
int64_t entry_point(void) {
    // 0x100003f50
    _printf((char *)&g1);
    return 0;
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define NUM_ROOMS 20
#define ARROWS 5

typedef enum { false, true } bool;

typedef struct {
    int connected[3];
    bool has_wumpus;
    bool has_bat;
    bool has_pit;
} Room;

Room cave[NUM_ROOMS + 1]; // Cave rooms are numbered from 1 to 20

void initialize_cave() {
    int i, j;
    // Initialize cave rooms
    for (i = 1; i <= NUM_ROOMS; i++) {
        for (j = 0; j < 3; j++) {
            cave[i].connected[j] = (i + j) % NUM_ROOMS + 1; // Circular connections
        }
        cave[i].has_wumpus = false;
        cave[i].has_bat = false;
        cave[i].has_pit = false;
    }
    // Randomly place wumpus, bats, and pits
    cave[rand() % NUM_ROOMS + 1].has_wumpus = true;
    for (i = 0; i < 2; i++) {
        cave[rand() % NUM_ROOMS + 1].has_bat = true;
        cave[rand() % NUM_ROOMS + 1].has_pit = true;
    }
}

void sense(int room) {
    printf("You are in room %d.\n", room);
    int i, adjacent_room;
    for (i = 0; i < 3; i++) {
        adjacent_room = cave[room].connected[i];
        if (cave[adjacent_room].has_wumpus)
            printf("You smell something terrible nearby.\n");
        if (cave[adjacent_room].has_bat)
            printf("You hear a rustling.\n");
        if (cave[adjacent_room].has_pit)
            printf("You feel a cold wind blowing from a nearby cavern.\n");
    }
}

void move(int *room) {
    int choice;
    printf("Choose an adjacent room to move into: ");
    scanf("%d", &choice);
    if (choice < 1 || choice > 3) {
        printf("Invalid choice. Please choose a number between 1 and 3.\n");
        move(room);
        return;
    }
    *room = cave[*room].connected[choice - 1];
}

void shoot(int room, int *arrows, bool *game_over) {
    int choice, adjacent_room;
    printf("Choose an adjacent room to shoot into: ");
    scanf("%d", &choice);
    if (choice < 1 || choice > 3) {
        printf("Invalid choice. Please choose a number between 1 and 3.\n");
        shoot(room, arrows, game_over);
        return;
    }
    adjacent_room = cave[room].connected[choice - 1];
    if (cave[adjacent_room].has_wumpus) {
        printf("Congratulations! You've killed the Wumpus!\n");
        *game_over = true;
        return;
    }
    else {
        if (rand() % 4 != 0) { // 75% chance of waking up the wumpus
            if (cave[adjacent_room].has_wumpus) {
                printf("The Wumpus has woken up and eaten you!\n");
                *game_over = true;
                return;
            }
        }
        printf("You missed! The Wumpus is still asleep.\n");
    }
    (*arrows)--;
}

int main() {
    srand(time(NULL));
    initialize_cave();
    int current_room = 1;
    int arrows = ARROWS;
    bool game_over = false;

    printf("Welcome to Hunt the Wumpus!\n");

    while (!game_over) {
        sense(current_room);
        printf("Choose your action:\n");
        printf("1. Move to an adjacent room\n");
        printf("2. Shoot into an adjacent room\n");

        int choice;
        printf("Enter your choice (1 or 2): ");
        scanf("%d", &choice);

        switch(choice) {
            case 1:
                move(&current_room);
                break;
            case 2:
                if (arrows > 0) {
                    shoot(current_room, &arrows, &game_over);
                } else {
                    printf("You're out of arrows! You lost the game.\n");
                    game_over = true;
                }
                break;
            default:
                printf("Invalid choice. Please choose 1 or 2.\n");
        }
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003678(void);
int64_t function_100003840(void);
int64_t function_100003978(void);
int64_t function_100003a2c(void);
int32_t function_100003d00(char * format, ...);
int32_t function_100003d0c(void);
int32_t function_100003d18(char * format, ...);
void function_100003d24(int32_t seed);
int32_t function_100003d30(int32_t * timer);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000cfeedfacf; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _rand(void);
int32_t _scanf(char * a1, ...);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003678 - 0x100003840
int64_t function_100003678(void) {
    int32_t v1 = 1;
    int64_t v2 = 24 * (int64_t)v1;
    int64_t v3 = v2 + (int64_t)&g1; // 0x1000036f4
    int64_t v4 = 0;
    *(int32_t *)(v3 + 4 * v4) = (v1 + (int32_t)v4) % 20 + 1;
    int64_t v5 = v4 + 1;
    while (v5 != 3) {
        // 0x1000036c0
        v4 = v5;
        *(int32_t *)(v3 + 4 * v4) = (v1 + (int32_t)v4) % 20 + 1;
        v5 = v4 + 1;
    }
    // 0x100003714
    *(int32_t *)(v2 + (int64_t)&g1 + 12) = 0;
    *(int32_t *)(v2 + (int64_t)&g1 + 16) = 0;
    *(int32_t *)(v2 + (int64_t)&g1 + 20) = 0;
    int32_t v6 = v1 + 1; // 0x100003760
    while (v1 == 19 || v1 < 19 != (18 - v1 & v6) < 0) {
        // 0x1000036ac
        v1 = v6;
        v2 = 24 * (int64_t)v1;
        v3 = v2 + (int64_t)&g1;
        v4 = 0;
        *(int32_t *)(v3 + 4 * v4) = (v1 + (int32_t)v4) % 20 + 1;
        v5 = v4 + 1;
        while (v5 != 3) {
            // 0x1000036c0
            v4 = v5;
            *(int32_t *)(v3 + 4 * v4) = (v1 + (int32_t)v4) % 20 + 1;
            v5 = v4 + 1;
        }
        // 0x100003714
        *(int32_t *)(v2 + (int64_t)&g1 + 12) = 0;
        *(int32_t *)(v2 + (int64_t)&g1 + 16) = 0;
        *(int32_t *)(v2 + (int64_t)&g1 + 20) = 0;
        v6 = v1 + 1;
    }
    int32_t v7 = _rand(); // 0x10000376c
    *(int32_t *)((int64_t)(24 * (v7 % 20) + 24) + (int64_t)&g1 + 12) = 1;
    int32_t result; // 0x1000037f4
    for (int32_t i = 0; i < 2; i++) {
        int32_t v8 = _rand(); // 0x1000037b8
        *(int32_t *)((int64_t)(24 * (v8 % 20) + 24) + (int64_t)&g1 + 16) = 1;
        result = _rand();
        *(int32_t *)((int64_t)(24 * (result % 20) + 24) + (int64_t)&g1 + 20) = 1;
    }
    // 0x100003834
    return result;
}

// Address range: 0x100003840 - 0x100003978
int64_t function_100003840(void) {
    // 0x100003840
    int64_t v1; // 0x100003840
    int32_t v2 = _printf("You are in room %d.\n", v1); // 0x100003868
    int64_t v3 = 24 * (0x100000000 * v1 >> 32) + (int64_t)&g1; // 0x1000038a0
    int64_t result = v2;
    for (int64_t i = 0; i < 3; i++) {
        int64_t v4 = 24 * (int64_t)*(int32_t *)(v3 + 4 * i); // 0x1000038b4
        int64_t v5 = result; // 0x1000038c8
        if (*(int32_t *)(v4 + (int64_t)&g1 + 12) != 0) {
            // 0x1000038d0
            v5 = _printf("You smell something terrible nearby.\n");
        }
        int64_t v6 = v5; // 0x100003904
        if (*(int32_t *)(v4 + (int64_t)&g1 + 16) != 0) {
            // 0x10000390c
            v6 = _printf("You hear a rustling.\n");
        }
        int64_t v7 = v6; // 0x100003940
        if (*(int32_t *)(v4 + (int64_t)&g1 + 20) != 0) {
            // 0x100003948
            v7 = _printf("You feel a cold wind blowing from a nearby cavern.\n");
        }
        // 0x10000395c
        result = v7;
    }
    // 0x10000396c
    return result;
}

// Address range: 0x100003978 - 0x100003a2c
int64_t function_100003978(void) {
    // 0x100003978
    int32_t v1; // 0x100003978
    int32_t v2 = v1;
    _printf("Choose an adjacent room to move into: ");
    int64_t v3; // 0x100003978
    int32_t v4 = _scanf("%d", (int64_t *)v3); // 0x1000039a8
    if (v2 < 1 != (v2 & -v2) < 0) {
        // 0x1000039d4
        _printf("Invalid choice. Please choose a number between 1 and 3.\n");
        // 0x100003a20
        return function_100003978();
    }
    int32_t v5 = v2 - 3; // 0x1000039c4
    if (v5 == 0 || v5 < 0 != (2 - v2 & v2) < 0) {
        int64_t result = v4;
        int32_t v6 = *(int32_t *)((int64_t)(4 * v2 - 4) + (int64_t)&g1 + 24 * result); // 0x100003a10
        *(int32_t *)v3 = v6;
        // 0x100003a20
        return result;
    }
    // 0x1000039d4
    _printf("Invalid choice. Please choose a number between 1 and 3.\n");
    // 0x100003a20
    return function_100003978();
}

// Address range: 0x100003a2c - 0x100003bb8
int64_t function_100003a2c(void) {
    // 0x100003a2c
    int64_t v1; // 0x100003a2c
    int64_t v2 = v1;
    int32_t v3; // 0x100003a2c
    int32_t v4 = v3;
    _printf("Choose an adjacent room to shoot into: ");
    _scanf("%d", (int64_t *)v2);
    if (v4 < 1 != (v4 & -v4) < 0) {
        // 0x100003a90
        _printf("Invalid choice. Please choose a number between 1 and 3.\n");
        // 0x100003bac
        return function_100003a2c();
    }
    int32_t v5 = v4 - 3; // 0x100003a80
    if (v5 != 0 && v5 < 0 == (2 - v4 & v4) < 0) {
        // 0x100003a90
        _printf("Invalid choice. Please choose a number between 1 and 3.\n");
        // 0x100003bac
        return function_100003a2c();
    }
    int32_t * v6 = (int32_t *)v1; // 0x100003a40
    int32_t v7 = *(int32_t *)(24 * (0x100000000 * v1 >> 32) + (int64_t)&g1 + (int64_t)(4 * v4 - 4)); // 0x100003ad4
    int32_t * v8 = (int32_t *)(24 * (int64_t)v7 + (int64_t)&g1 + 12); // 0x100003ae8
    if (*v8 != 0) {
        int32_t result = _printf("Congratulations! You've killed the Wumpus!\n"); // 0x100003b04
        *v6 = 1;
        // 0x100003bac
        return result;
    }
    int32_t v9 = _rand(); // 0x100003b18
    if (v9 == 4 * v9 / 4 || *v8 == 0) {
        int32_t result2 = _printf("You missed! The Wumpus is still asleep.\n"); // 0x100003b90
        *(int32_t *)v2 = (int32_t)v2 - 1;
        // 0x100003bac
        return result2;
    }
    int32_t result3 = _printf("The Wumpus has woken up and eaten you!\n"); // 0x100003b70
    *v6 = 1;
    // 0x100003bac
    return result3;
}

// Address range: 0x100003bb8 - 0x100003d00
int64_t entry_point(void) {
    // 0x100003bb8
    _srand(_time(NULL));
    function_100003678();
    int32_t v1 = 5; // bp-28, 0x100003be4
    _printf("Welcome to Hunt the Wumpus!\n");
    while (true) {
        // 0x100003c10
        int64_t v2; // 0x100003bb8
        int64_t v3 = v2;
        function_100003840();
        _printf("Choose your action:\n");
        _printf("1. Move to an adjacent room\n");
        _printf("2. Shoot into an adjacent room\n");
        _printf("Enter your choice (1 or 2): ");
        _scanf("%d", (int64_t *)v3);
        int32_t v4; // 0x100003bb8
        int64_t v5; // 0x100003bb8
        switch (v4) {
            case 1: {
                // 0x100003c8c
                function_100003978();
                v5 = v3;
                // break -> 0x100003cec
                break;
            }
            case 2: {
                // 0x100003c98
                if (v1 < 1) {
                    // break -> 0x100003cf0
                    break;
                }
                // 0x100003cac
                function_100003a2c();
                v5 = &v1;
                // break -> 0x100003cec
                break;
            }
            default: {
                // 0x100003cdc
                _printf("Invalid choice. Please choose 1 or 2.\n");
                v5 = v3;
                // break -> 0x100003cec
                break;
            }
        }
        // 0x100003cec
        v2 = v5;
    }
}

// Address range: 0x100003d00 - 0x100003d0c
int32_t function_100003d00(char * format, ...) {
    // 0x100003d00
    return _printf(format);
}

// Address range: 0x100003d0c - 0x100003d18
int32_t function_100003d0c(void) {
    // 0x100003d0c
    return _rand();
}

// Address range: 0x100003d18 - 0x100003d24
int32_t function_100003d18(char * format, ...) {
    // 0x100003d18
    return _scanf(format);
}

// Address range: 0x100003d24 - 0x100003d30
void function_100003d24(int32_t seed) {
    // 0x100003d24
    _srand(seed);
}

// Address range: 0x100003d30 - 0x100003d3c
int32_t function_100003d30(int32_t * timer) {
    // 0x100003d30
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include "stdio.h"
#include "stdbool.h"

#define ARRAY_LEN(a,T) (sizeof(a) / sizeof(T))

struct Interval {
    int start, end;
    bool print;
};

int main() {
    struct Interval intervals[] = {
        {2, 1000, true},
        {1000, 4000, true},
        {2, 10000, false},
        {2, 100000, false},
        {2, 1000000, false},
        {2, 10000000, false},
        {2, 100000000, false},
        {2, 1000000000, false},
    };
    int idx;

    for (idx = 0; idx < ARRAY_LEN(intervals, struct Interval); ++idx) {
        struct Interval intv = intervals[idx];
        int count = 0, i;

        if (intv.start == 2) {
            printf("eban numbers up to and including %d:\n", intv.end);
        } else {
            printf("eban numbers between %d and %d (inclusive:)", intv.start, intv.end);
        }

        for (i = intv.start; i <= intv.end; i += 2) {
            int b = i / 1000000000;
            int r = i % 1000000000;
            int m = r / 1000000;
            int t;

            r = i % 1000000;
            t = r / 1000;
            r %= 1000;
            if (m >= 30 && m <= 66) m %= 10;
            if (t >= 30 && t <= 66) t %= 10;
            if (r >= 30 && r <= 66) r %= 10;
            if (b == 0 || b == 2 || b == 4 || b == 6) {
                if (m == 0 || m == 2 || m == 4 || m == 6) {
                    if (t == 0 || t == 2 || t == 4 || t == 6) {
                        if (r == 0 || r == 2 || r == 4 || r == 6) {
                            if (intv.print) printf("%d ", i);
                            count++;
                        }
                    }
                }
            }
        }
        if (intv.print) {
            printf("\n");
        }
        printf("count = %d\n\n", count);
    }

    return 0;
}
`,`#include "eban-numbers.h"



undefined8 entry(void)

{
  int iVar1;
  uint uVar2;
  void *pvVar3;
  undefined8 uVar4;
  int local_a8;
  int local_a4;
  int local_a0;
  int local_98;
  int local_90;
  int iStack_8c;
  uint local_80;
  undefined8 uStack_78;
  uint auStack_70 [22];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar3 = _memcpy(&uStack_78,&DAT_100003ee0,0x60);
  for (local_80 = 0; local_80 < 8; local_80 = local_80 + 1) {
    uVar4 = *(undefined8 *)((long)&uStack_78 + (long)(int)local_80 * 0xc);
    uVar2 = auStack_70[(long)(int)local_80 * 3];
    local_90 = (int)uVar4;
    iStack_8c = (int)((ulong)uVar4 >> 0x20);
    if (local_90 == 2) {
      _printf("eban numbers up to and including %d:\n");
    }
    else {
      _printf("eban numbers between %d and %d (inclusive:)");
    }
    for (local_98 = local_90; local_98 <= iStack_8c; local_98 = local_98 + 2) {
      iVar1 = local_98 / 1000000000;
      local_a4 = (local_98 % 1000000000) / 1000000;
      local_a8 = (local_98 % 1000000) / 1000;
      local_a0 = (local_98 % 1000000) % 1000;
      if ((0x1d < local_a4) && (local_a4 < 0x43)) {
        local_a4 = local_a4 % 10;
      }
      if ((0x1d < local_a8) && (local_a8 < 0x43)) {
        local_a8 = local_a8 % 10;
      }
      if ((0x1d < local_a0) && (local_a0 < 0x43)) {
        local_a0 = local_a0 % 10;
      }
      if ((((((((iVar1 == 0) || (iVar1 == 2)) || (iVar1 == 4)) || (iVar1 == 6)) &&
            (((local_a4 == 0 || (local_a4 == 2)) || ((local_a4 == 4 || (local_a4 == 6)))))) &&
           (((local_a8 == 0 || (local_a8 == 2)) || ((local_a8 == 4 || (local_a8 == 6)))))) &&
          ((((local_a0 == 0 || (local_a0 == 2)) || (local_a0 == 4)) || (local_a0 == 6)))) &&
         ((uVar2 & 1) != 0)) {
        _printf("%d ");
      }
    }
    if ((uVar2 & 1) != 0) {
      _printf("\n");
    }
    uVar2 = _printf("count = %d\n\n");
    pvVar3 = (void *)(ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(pvVar3);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: systematic
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

const int G = 6.67428e-11; // Gravitational constant

struct planet {
    double m; // Mass
    double x; // Position (x, y)
    double y;
    double vx; // Velocity (x, y)
    double vy;
};

int main() {
    // Set up the planets
    struct planet sun = {1.9885e30, 0, 0, 0, 0}; // Sun
    struct planet earth = {5.972e24, 1.496e11, 0, 0, 2.9783e4}; // Earth
    struct planet moon = {7.35e22, 1.496e11 + 3.844e8, 0, 0, 2.9783e4 + 1.022e3}; // Moon

    double t = 0;
    double dt = 3600 * 24; // 1 day in seconds

    // Simulation loop
    while (1) {
        // Calculate distance and force between Earth and Sun
        double dx = earth.x - sun.x;
        double dy = earth.y - sun.y;
        double d = sqrt(dx*dx + dy*dy);
        double F = G * earth.m * sun.m / (d*d);

        // Calculate acceleration and velocity of Earth
        double ax = -F / earth.m * dx / d;
        double ay = -F / earth.m * dy / d;
        earth.vx += ax * dt;
        earth.vy += ay * dt;
        earth.x += earth.vx * dt;
        earth.y += earth.vy * dt;

        // Calculate distance and force between Moon and Earth
        dx = moon.x - earth.x;
        dy = moon.y - earth.y;
        d = sqrt(dx*dx + dy*dy);
        F = G * moon.m * earth.m / (d*d);

        // Calculate acceleration and velocity of Moon
        double axm = -F / moon.m * dx / d;
        double aym = -F / moon.m * dy / d;
        moon.vx += axm * dt;
        moon.vy += aym * dt;
        moon.x += moon.vx * dt;
        moon.y += moon.vy * dt;

        // Print out the positions of the planets
        printf("t = %f, Earth (%f, %f), Moon (%f, %f)\n", t, earth.x, earth.y, moon.x, moon.y);

        t += dt;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+38h] [rbp-48h]
  double v5; // [rsp+40h] [rbp-40h]
  double v6; // [rsp+48h] [rbp-38h]
  double v7; // [rsp+50h] [rbp-30h]
  double v8; // [rsp+68h] [rbp-18h]
  double v9; // [rsp+70h] [rbp-10h]
  double v10; // [rsp+78h] [rbp-8h]
  double v11; // [rsp+80h] [rbp+0h]
  double v12; // [rsp+E8h] [rbp+68h]
  double v13; // [rsp+E8h] [rbp+68h]
  double i; // [rsp+108h] [rbp+88h]

  _main(argc, argv, envp);
  v8 = 1.496e11;
  v9 = 0.0;
  v10 = 0.0;
  v11 = 29783.0;
  v4 = 1.499844e11;
  v5 = 0.0;
  v6 = 0.0;
  v7 = 30805.0;
  for ( i = 0.0; ; i = i + 86400.0 )
  {
    v12 = sqrt((v8 - 0.0) * (v8 - 0.0) + (v9 - 0.0) * (v9 - 0.0));
    v10 = -((double)0 * 5.972e24 * 1.9885e30 / (v12 * v12)) / 5.972e24 * (v8 - 0.0) / v12 * 86400.0 + v10;
    v11 = -((double)0 * 5.972e24 * 1.9885e30 / (v12 * v12)) / 5.972e24 * (v9 - 0.0) / v12 * 86400.0 + v11;
    v8 = v10 * 86400.0 + v8;
    v9 = v11 * 86400.0 + v9;
    v13 = sqrt((v4 - v8) * (v4 - v8) + (v5 - v9) * (v5 - v9));
    v6 = -((double)0 * 7.35e22 * 5.972e24 / (v13 * v13)) / 7.35e22 * (v4 - v8) / v13 * 86400.0 + v6;
    v7 = -((double)0 * 7.35e22 * 5.972e24 / (v13 * v13)) / 7.35e22 * (v5 - v9) / v13 * 86400.0 + v7;
    v4 = v6 * 86400.0 + v4;
    v5 = v7 * 86400.0 + v5;
    printf("t = %f, Earth (%f, %f), Moon (%f, %f)\n", i, v8, v9, v4, v5);
  }
}
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <math.h>
#include <stdio.h>
#include <string.h>

int find(char *s, char c) {
    for (char *i = s; *i != 0; i++) {
        if (*i == c) {
            return i - s;
        }
    }
    return -1;
}

void reverse(char *b, char *e) {
    for (e--; b < e; b++, e--) {
        char t = *b;
        *b = *e;
        *e = t;
    }
}

//////////////////////////////////////////////////////

struct Complex {
    double rel, img;
};

void printComplex(struct Complex c) {
    printf("(%3.0f + %3.0fi)", c.rel, c.img);
}

struct Complex makeComplex(double rel, double img) {
    struct Complex c = { rel, img };
    return c;
}

struct Complex addComplex(struct Complex a, struct Complex b) {
    struct Complex c = { a.rel + b.rel, a.img + b.img };
    return c;
}

struct Complex mulComplex(struct Complex a, struct Complex b) {
    struct Complex c = { a.rel * b.rel - a.img * b.img, a.rel * b.img - a.img * b.rel };
    return c;
}

struct Complex mulComplexD(struct Complex a, double b) {
    struct Complex c = { a.rel * b, a.img * b };
    return c;
}

struct Complex negComplex(struct Complex a) {
    return mulComplexD(a, -1.0);
}

struct Complex divComplex(struct Complex a, struct Complex b) {
    double re = a.rel * b.rel + a.img * b.img;
    double im = a.img * b.rel - a.rel * b.img;
    double d = b.rel * b.rel + b.img * b.img;
    struct Complex c = { re / d, im / d };
    return c;
}

struct Complex inv(struct Complex c) {
    double d = c.rel * c.rel + c.img * c.img;
    struct Complex i = { c.rel / d, -c.img / d };
    return i;
}

const struct Complex TWO_I = { 0.0, 2.0 };
const struct Complex INV_TWO_I = { 0.0, -0.5 };

//////////////////////////////////////////////////////

struct QuaterImaginary {
    char *b2i;
    int valid;
};

struct QuaterImaginary makeQuaterImaginary(char *s) {
    struct QuaterImaginary qi = { s, 0 }; // assume invalid until tested
    size_t i, valid = 1, cnt = 0;

    if (*s != 0) {
        for (i = 0; s[i] != 0; i++) {
            if (s[i] < '0' || '3' < s[i]) {
                if (s[i] == '.') {
                    cnt++;
                } else {
                    valid = 0;
                    break;
                }
            }
        }
        if (valid && cnt > 1) {
            valid = 0;
        }
    }

    qi.valid = valid;
    return qi;
}

void printQuaterImaginary(struct QuaterImaginary qi) {
    if (qi.valid) {
        printf("%8s", qi.b2i);
    } else {
        printf(" ERROR  ");
    }
}

//////////////////////////////////////////////////////

struct Complex qi2c(struct QuaterImaginary qi) {
    size_t len = strlen(qi.b2i);
    int pointPos = find(qi.b2i, '.');
    size_t posLen = (pointPos > 0) ? pointPos : len;
    struct Complex sum = makeComplex(0.0, 0.0);
    struct Complex prod = makeComplex(1.0, 0.0);
    size_t j;

    for (j = 0; j < posLen; j++) {
        double k = qi.b2i[posLen - 1 - j] - '0';
        if (k > 0.0) {
            sum = addComplex(sum, mulComplexD(prod, k));
        }
        prod = mulComplex(prod, TWO_I);
    }
    if (pointPos != -1) {
        prod = INV_TWO_I;
        for (j = posLen + 1; j < len; j++) {
            double k = qi.b2i[j] - '0';
            if (k > 0.0) {
                sum = addComplex(sum, mulComplexD(prod, k));
            }
            prod = mulComplex(prod, INV_TWO_I);
        }
    }
    return sum;
}

// only works properly if the real and imaginary parts are integral
struct QuaterImaginary c2qi(struct Complex c, char *out) {
    char *p = out;
    int re, im, fi;

    *p = 0;
    if (c.rel == 0.0 && c.img == 0.0) {
        return makeQuaterImaginary("0");
    }

    re = (int)c.rel;
    im = (int)c.img;
    fi = -1;
    while (re != 0) {
        int rem = re % -4;
        re /= -4;
        if (rem < 0) {
            rem += 4;
            re++;
        }
        *p++ = rem + '0';
        *p++ = '0';
        *p = 0;
    }
    if (im != 0) {
        size_t index = 1;
        struct Complex fc = divComplex((struct Complex) { 0.0, c.img }, (struct Complex) { 0.0, 2.0 });
        double f = fc.rel;
        im = (int)ceil(f);
        f = -4.0 * (f - im);
        while (im != 0) {
            int rem = im % -4;
            im /= -4;
            if (rem < 0) {
                rem += 4;
                im++;
            }
            if (index < (p - out)) {
                out[index] = rem + '0';
            } else {
                *p++ = '0';
                *p++ = rem + '0';
                *p = 0;
            }
            index += 2;
        }
        fi = (int)f;
    }

    reverse(out, p);
    if (fi != -1) {
        *p++ = '.';
        *p++ = fi + '0';
        *p = 0;
    }
    while (out[0] == '0' && out[1] != '.') {
        size_t i;
        for (i = 0; out[i] != 0; i++) {
            out[i] = out[i + 1];
        }
    }
    if (*out == '.') {
        reverse(out, p);
        *p++ = '0';
        *p = 0;
        reverse(out, p);
    }
    return makeQuaterImaginary(out);
}

//////////////////////////////////////////////////////

int main() {
    char buffer[16];
    int i;

    for (i = 1; i <= 16; i++) {
        struct Complex c1 = { i, 0.0 };
        struct QuaterImaginary qi = c2qi(c1, buffer);
        struct Complex c2 = qi2c(qi);
        printComplex(c1);
        printf(" -> ");
        printQuaterImaginary(qi);
        printf(" -> ");
        printComplex(c2);

        printf("     ");

        c1 = negComplex(c1);
        qi = c2qi(c1, buffer);
        c2 = qi2c(qi);
        printComplex(c1);
        printf(" -> ");
        printQuaterImaginary(qi);
        printf(" -> ");
        printComplex(c2);

        printf("\n");
    }

    printf("\n");

    for (i = 1; i <= 16; i++) {
        struct Complex c1 = { 0.0, i };
        struct QuaterImaginary qi = c2qi(c1, buffer);
        struct Complex c2 = qi2c(qi);
        printComplex(c1);
        printf(" -> ");
        printQuaterImaginary(qi);
        printf(" -> ");
        printComplex(c2);

        printf("     ");

        c1 = negComplex(c1);
        qi = c2qi(c1, buffer);
        c2 = qi2c(qi);
        printComplex(c1);
        printf(" -> ");
        printQuaterImaginary(qi);
        printf(" -> ");
        printComplex(c2);

        printf("\n");
    }

    return 0;
}
`,`#include "imaginary-base-numbers.h"



int _find(char *param_1,char param_2)

{
  char *local_20;
  
  local_20 = param_1;
  while( true ) {
    if (*local_20 == '\0') {
      return -1;
    }
    if (*local_20 == param_2) break;
    local_20 = local_20 + 1;
  }
  return (int)local_20 - (int)param_1;
}



void _reverse(undefined *param_1,long param_2)

{
  undefined uVar1;
  undefined *local_10;
  undefined *local_8;
  
  local_10 = (undefined *)(param_2 + -1);
  for (local_8 = param_1; local_8 < local_10; local_8 = local_8 + 1) {
    uVar1 = *local_8;
    *local_8 = *local_10;
    *local_10 = uVar1;
    local_10 = local_10 + -1;
  }
  return;
}



int _printComplex(void)

{
  int iVar1;
  
  iVar1 = _printf("(%3.0f + %3.0fi)");
  return iVar1;
}



undefined  [16] _makeComplex(ulong param_1)

{
  undefined auVar1 [16];
  
  auVar1._8_8_ = 0;
  auVar1._0_8_ = param_1;
  return auVar1;
}



undefined  [16] _addComplex(double param_1,undefined param_2 [16],double param_3)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 + param_3;
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16] _mulComplex(undefined8 param_1,double param_2,double param_3,double param_4)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = NEON_fnmsub(param_1,param_3,param_2 * param_4);
  NEON_fnmsub(param_1,param_4,param_2 * param_3);
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16] _mulComplexD(double param_1,undefined param_2 [16],double param_3)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 * param_3;
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16] _negComplex(undefined8 param_1,undefined8 param_2)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = _mulComplexD(param_1,param_2,0xbff0000000000000);
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16] _divComplex(double param_1,double param_2,undefined8 param_3,double param_4)

{
  double dVar1;
  double dVar2;
  undefined auVar3 [16];
  
  dVar1 = (double)NEON_fmadd(param_1,param_3,param_2 * param_4);
  NEON_fnmsub(param_2,param_3,param_1 * param_4);
  dVar2 = (double)NEON_fmadd(param_3,param_3,param_4 * param_4);
  auVar3._0_8_ = dVar1 / dVar2;
  auVar3._8_8_ = 0;
  return auVar3;
}



undefined  [16] _inv(double param_1,double param_2)

{
  double dVar1;
  undefined auVar2 [16];
  
  dVar1 = (double)NEON_fmadd(param_1,param_1,param_2 * param_2);
  auVar2._0_8_ = param_1 / dVar1;
  auVar2._8_8_ = 0;
  return auVar2;
}



undefined  [16] _makeQuaterImaginary(char *param_1)

{
  undefined auVar1 [16];
  ulong local_30;
  int local_28;
  long local_20;
  undefined4 uStack_4;
  
  local_28 = 1;
  local_30 = 0;
  if (*param_1 != '\0') {
    for (local_20 = 0; local_28 = 1, param_1[local_20] != '\0'; local_20 = local_20 + 1) {
      if ((param_1[local_20] < '0') || ('3' < param_1[local_20])) {
        if (param_1[local_20] != '.') {
          local_28 = 0;
          break;
        }
        local_30 = local_30 + 1;
      }
    }
    if ((local_28 != 0) && (1 < local_30)) {
      local_28 = 0;
    }
  }
  auVar1._8_4_ = local_28;
  auVar1._0_8_ = param_1;
  auVar1._12_4_ = uStack_4;
  return auVar1;
}



int _printQuaterImaginary(undefined8 param_1,int param_2)

{
  int iVar1;
  
  if (param_2 == 0) {
    iVar1 = _printf(" ERROR  ");
  }
  else {
    iVar1 = _printf("%8s");
  }
  return iVar1;
}



undefined  [16] _qi2c(char *param_1)

{
  int iVar1;
  size_t sVar2;
  undefined8 uVar3;
  undefined auVar4 [16];
  undefined8 uVar5;
  ulong local_e8;
  ulong local_68;
  undefined8 local_60;
  undefined8 uStack_58;
  ulong local_20;
  undefined8 uStack_18;
  
  sVar2 = _strlen(param_1);
  iVar1 = _find(param_1,0x2e);
  local_e8 = sVar2;
  if (0 < iVar1) {
    local_e8 = (long)iVar1;
  }
  uStack_18 = 0;
  local_20 = _makeComplex(0);
  uStack_58 = 0;
  local_60 = _makeComplex(0x3ff0000000000000);
  for (local_68 = 0; local_68 < local_e8; local_68 = local_68 + 1) {
    if (0.0 < (double)(param_1[(local_e8 - 1) - local_68] + -0x30)) {
      uVar5 = uStack_58;
      uVar3 = _mulComplexD(local_60,uStack_58,(double)(param_1[(local_e8 - 1) - local_68] + -0x30));
      local_20 = _addComplex(local_20,uStack_18,uVar3,uVar5);
    }
    local_60 = _mulComplex(local_60,uStack_58,0,0x4000000000000000);
  }
  if (iVar1 != -1) {
    uStack_58 = 0xbfe0000000000000;
    local_60 = 0;
    while (local_68 = local_e8 + 1, local_68 < sVar2) {
      if (0.0 < (double)(param_1[local_68] + -0x30)) {
        uVar5 = uStack_58;
        uVar3 = _mulComplexD(local_60,uStack_58,(double)(param_1[local_68] + -0x30));
        local_20 = _addComplex(local_20,uStack_18,uVar3,uVar5);
      }
      local_60 = _mulComplex(local_60,uStack_58,0,0xbfe0000000000000);
      local_e8 = local_68;
    }
  }
  auVar4._8_8_ = 0;
  auVar4._0_8_ = local_20;
  return auVar4;
}



undefined  [16] _c2qi(double param_1,double param_2,char *param_3)

{
  char *pcVar1;
  bool bVar2;
  double dVar3;
  long lVar4;
  undefined auVar5 [16];
  long local_a0;
  int local_94;
  ulong local_58;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  char *local_40;
  
  *param_3 = '\0';
  if ((param_1 == 0.0) && (param_2 == 0.0)) {
    auVar5 = _makeQuaterImaginary("0");
  }
  else {
    local_44 = (int)param_1;
    local_4c = -1;
    local_40 = param_3;
    while (local_44 != 0) {
      local_50 = local_44 % -4;
      local_44 = local_44 / -4;
      if (local_50 < 0) {
        local_50 = local_50 + 4;
        local_44 = local_44 + 1;
      }
      pcVar1 = local_40 + 1;
      *local_40 = (char)local_50 + '0';
      local_40 = local_40 + 2;
      *pcVar1 = '0';
      *local_40 = '\0';
    }
    if ((int)param_2 != 0) {
      local_58 = 1;
      dVar3 = (double)_divComplex(0,param_2,0,0x4000000000000000);
      local_48 = (int)dVar3;
      lVar4 = (long)local_48;
      while (local_48 != 0) {
        local_94 = local_48 % -4;
        local_48 = local_48 / -4;
        if (local_94 < 0) {
          local_94 = local_94 + 4;
          local_48 = local_48 + 1;
        }
        if (local_58 < (ulong)((long)local_40 - (long)param_3)) {
          param_3[local_58] = (char)local_94 + '0';
        }
        else {
          pcVar1 = local_40 + 1;
          *local_40 = '0';
          local_40 = local_40 + 2;
          *pcVar1 = (char)local_94 + '0';
          *local_40 = '\0';
        }
        local_58 = local_58 + 2;
      }
      local_4c = (int)((dVar3 - (double)lVar4) * -4.0);
    }
    _reverse(param_3,local_40);
    if (local_4c != -1) {
      pcVar1 = local_40 + 1;
      *local_40 = '.';
      local_40 = local_40 + 2;
      *pcVar1 = (char)local_4c + '0';
      *local_40 = '\0';
    }
    while( true ) {
      bVar2 = false;
      if (*param_3 == '0') {
        bVar2 = param_3[1] != '.';
      }
      if (!bVar2) break;
      for (local_a0 = 0; param_3[local_a0] != '\0'; local_a0 = local_a0 + 1) {
        param_3[local_a0] = param_3[local_a0 + 1];
      }
    }
    if (*param_3 == '.') {
      _reverse(param_3,local_40);
      *local_40 = '0';
      local_40[1] = '\0';
      _reverse(param_3,local_40 + 1);
    }
    auVar5 = _makeQuaterImaginary(param_3);
  }
  return auVar5;
}



undefined8 entry(void)

{
  int iVar1;
  double dVar2;
  undefined8 uVar3;
  undefined8 uVar4;
  double dVar5;
  undefined8 uVar6;
  undefined8 uVar7;
  undefined auVar8 [16];
  int local_40;
  undefined auStack_38 [16];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_40 = 1; local_40 < 0x11; local_40 = local_40 + 1) {
    dVar2 = (double)(long)local_40;
    uVar6 = 0;
    auVar8 = _c2qi(dVar2);
    uVar3 = _qi2c(auVar8._0_8_,auVar8._8_8_);
    _printComplex(dVar2,0);
    _printf(" -> ");
    _printQuaterImaginary(auVar8._0_8_,auVar8._8_8_);
    iVar1 = _printf(" -> ");
    _printComplex(uVar3,uVar6,iVar1);
    iVar1 = _printf("     ");
    uVar7 = 0;
    uVar6 = _negComplex(dVar2,iVar1);
    uVar3 = uVar7;
    auVar8 = _c2qi(uVar6,auStack_38);
    uVar4 = _qi2c(auVar8._0_8_,auVar8._8_8_);
    _printComplex(uVar6,uVar7);
    _printf(" -> ");
    _printQuaterImaginary(auVar8._0_8_,auVar8._8_8_);
    iVar1 = _printf(" -> ");
    _printComplex(uVar4,uVar3,iVar1);
    _printf("\n");
  }
  iVar1 = _printf("\n");
  local_40 = 1;
  while( true ) {
    if (0x10 < local_40) break;
    dVar5 = (double)(long)local_40;
    dVar2 = dVar5;
    auVar8 = _c2qi(0);
    uVar3 = _qi2c(auVar8._0_8_,auVar8._8_8_);
    _printComplex(0,dVar5);
    _printf(" -> ");
    _printQuaterImaginary(auVar8._0_8_,auVar8._8_8_);
    iVar1 = _printf(" -> ");
    _printComplex(uVar3,dVar2,iVar1);
    iVar1 = _printf("     ");
    uVar3 = _negComplex(0,iVar1);
    dVar2 = dVar5;
    auVar8 = _c2qi(uVar3,auStack_38);
    uVar6 = _qi2c(auVar8._0_8_,auVar8._8_8_);
    _printComplex(uVar3,dVar5);
    _printf(" -> ");
    _printQuaterImaginary(auVar8._0_8_,auVar8._8_8_);
    iVar1 = _printf(" -> ");
    _printComplex(uVar6,dVar2,iVar1);
    iVar1 = _printf("\n");
    local_40 = local_40 + 1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004018)();
  return sVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

struct s_env {
    unsigned int n, i;
    size_t size;
    void *sample;
};

void s_of_n_init(struct s_env *s_env, size_t size, unsigned int n)
{
    s_env->i = 0;
    s_env->n = n;
    s_env->size = size;
    s_env->sample = malloc(n * size);
}

void sample_set_i(struct s_env *s_env, unsigned int i, void *item)
{
    memcpy(s_env->sample + i * s_env->size, item, s_env->size);
}

void *s_of_n(struct s_env *s_env, void *item)
{
    s_env->i++;
    if (s_env->i <= s_env->n)
        sample_set_i(s_env, s_env->i - 1, item);
    else if ((rand() % s_env->i) < s_env->n)
        sample_set_i(s_env, rand() % s_env->n, item);
    return s_env->sample;
}

int *test(unsigned int n, int *items_set, unsigned int num_items)
{
    int i;
    struct s_env s_env;
    s_of_n_init(&s_env, sizeof(items_set[0]), n);
    for (i = 0; i < num_items; i++) {
        s_of_n(&s_env, (void *) &items_set[i]);
    }
    return (int *)s_env.sample;
}

int main()
{
    unsigned int i, j;
    unsigned int n = 3;
    unsigned int num_items = 10;
    unsigned int *frequencies;
    int *items_set;
    srand(time(NULL));
    items_set = malloc(num_items * sizeof(int));
    frequencies = malloc(num_items * sizeof(int));
    for (i = 0; i < num_items; i++) {
        items_set[i] = i;
        frequencies[i] = 0;
    }
    for (i = 0; i < 100000; i++) {
        int *res = test(n, items_set, num_items);
        for (j = 0; j < n; j++) {
            frequencies[res[j]]++;
        }
	free(res);
    }
    for (i = 0; i < num_items; i++) {
        printf(" %d", frequencies[i]);
    }
    puts("");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b74(int64_t * a1, int64_t a2, int32_t a3);
int64_t function_100003bd0(int64_t a1, uint32_t a2, int64_t a3);
int64_t function_100003c24(void);
int64_t function_100003d00(void);
int64_t function_100003f40(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void function_100003f4c(int64_t * ptr);
int64_t * function_100003f58(int32_t size);
int32_t function_100003f64(char * format, ...);
int32_t function_100003f70(char * s);
int32_t function_100003f7c(void);
void function_100003f88(int32_t seed);
int32_t function_100003f94(int32_t * timer);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _puts(char * a1);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003b74 - 0x100003bd0
int64_t function_100003b74(int64_t * a1, int64_t a2, int32_t a3) {
    int64_t v1 = (int64_t)a1;
    *(int32_t *)(v1 + 4) = 0;
    *(int32_t *)a1 = a3;
    *(int64_t *)(v1 + 8) = a2;
    int64_t result = (int64_t)_malloc((int32_t)a2 * a3); // 0x100003bb8
    *(int64_t *)(v1 + 16) = result;
    return result;
}

// Address range: 0x100003bd0 - 0x100003c24
int64_t function_100003bd0(int64_t a1, uint32_t a2, int64_t a3) {
    int64_t v1 = *(int64_t *)(a1 + 8); // 0x100003bf8
    return ___memcpy_chk(v1 * (int64_t)a2 + *(int64_t *)(a1 + 16), a3, v1, -1);
}

// Address range: 0x100003c24 - 0x100003d00
int64_t function_100003c24(void) {
    // 0x100003c24
    int64_t v1; // 0x100003c24
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x100003c3c
    int32_t v3 = *v2; // 0x100003c3c
    uint32_t v4 = v3 + 1; // 0x100003c40
    *v2 = v4;
    int64_t v5; // 0x100003c24
    uint32_t v6 = *(int32_t *)&v5; // 0x100003c54
    if (v4 >= v6 != v4 != v6) {
        // 0x100003c68
        function_100003bd0(v1, v3, v1);
        // 0x100003cec
        return *(int64_t *)(v1 + 16);
    }
    // 0x100003c84
    if (_rand() % *v2 < v6) {
        // 0x100003cb4
        function_100003bd0(v1, _rand() % v6, v1);
    }
    // 0x100003cec
    return *(int64_t *)(v1 + 16);
}

// Address range: 0x100003d00 - 0x100003d80
int64_t function_100003d00(void) {
    // 0x100003d00
    int64_t result; // 0x100003d00
    int32_t v1 = result; // 0x100003d14
    int64_t v2; // bp-64, 0x100003d00
    function_100003b74(&v2, 4, (int32_t)result);
    if (v1 == 0) {
        // 0x100003d70
        return result;
    }
    int32_t v3 = 0; // 0x100003d40
    function_100003c24();
    while (v3 + 1 != v1) {
        // 0x100003d48
        v3++;
        function_100003c24();
    }
    // 0x100003d70
    return result;
}

// Address range: 0x100003d80 - 0x100003f40
int64_t entry_point(void) {
    // 0x100003d80
    _srand(_time(NULL));
    int64_t v1 = (int64_t)_malloc(40); // 0x100003db4
    int64_t v2 = (int64_t)_malloc(40); // 0x100003dc4
    int64_t v3 = 0;
    int64_t v4 = 4 * v3; // 0x100003df8
    *(int32_t *)(v4 + v1) = (int32_t)v3;
    *(int32_t *)(v4 + v2) = 0;
    v3++;
    int32_t v5 = 0; // 0x100003de4
    while (v3 != 10) {
        // 0x100003dec
        v4 = 4 * v3;
        *(int32_t *)(v4 + v1) = (int32_t)v3;
        *(int32_t *)(v4 + v2) = 0;
        v3++;
        v5 = 0;
    }
    int64_t v6 = function_100003d00(); // 0x100003e54
    int32_t v7; // 0x100003e88
    int32_t * v8; // 0x100003e90
    for (int64_t i = 0; i < 3; i++) {
        // 0x100003e7c
        v7 = *(int32_t *)(4 * i + v6);
        v8 = (int32_t *)(4 * (int64_t)v7 + v2);
        *v8 = *v8 + 1;
    }
    // 0x100003eb0
    _free((int64_t *)v6);
    int32_t v9 = v5 + 1; // 0x100003ec0
    v5 = v9;
    int32_t v10 = 0; // 0x100003e40
    while (v9 != 0x186a0) {
        // 0x100003e48
        v6 = function_100003d00();
        for (int64_t i = 0; i < 3; i++) {
            // 0x100003e7c
            v7 = *(int32_t *)(4 * i + v6);
            v8 = (int32_t *)(4 * (int64_t)v7 + v2);
            *v8 = *v8 + 1;
        }
        // 0x100003eb0
        _free((int64_t *)v6);
        v9 = v5 + 1;
        v5 = v9;
        v10 = 0;
    }
    _printf(" %d", v1);
    int32_t v11 = v10 + 1; // 0x100003f18
    v10 = v11;
    while (v11 != 10) {
        // 0x100003eec
        _printf(" %d", v1);
        v11 = v10 + 1;
        v10 = v11;
    }
    // 0x100003f24
    _puts((char *)0x100003fa4);
    return 0;
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t function_100003f40(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003f40
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003f4c - 0x100003f58
void function_100003f4c(int64_t * ptr) {
    // 0x100003f4c
    _free(ptr);
}

// Address range: 0x100003f58 - 0x100003f64
int64_t * function_100003f58(int32_t size) {
    // 0x100003f58
    return _malloc(size);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * s) {
    // 0x100003f70
    return _puts(s);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(void) {
    // 0x100003f7c
    return _rand();
}

// Address range: 0x100003f88 - 0x100003f94
void function_100003f88(int32_t seed) {
    // 0x100003f88
    _srand(seed);
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(int32_t * timer) {
    // 0x100003f94
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 13

`
`#include <stdio.h>
#include <time.h>

int main() {
    int i, j, ms = 250;
    const char *a = "|/-\\";
    time_t start, now;
    struct timespec delay;
    delay.tv_sec = 0;
    delay.tv_nsec = ms * 1000000L;
    printf("\033[?25l");  // hide the cursor
    time(&start);
    while(1) {
        for (i = 0; i < 4; i++) {
            printf("\033[2J");          // clear terminal
            printf("\033[0;0H");        // place cursor at top left corner
            for (j = 0; j < 80; j++) {  // 80 character terminal width, say
                printf("%c", a[i]);
            }
            fflush(stdout);
            nanosleep(&delay, NULL);
        }
        // stop after 20 seconds, say
        time(&now);
        if (difftime(now, start) >= 20) break;
    }
    printf("\033[?25h"); // restore the cursor
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct timespec {
    int64_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
float64_t function_100003f48(int32_t time1, int32_t time0);
int32_t function_100003f54(struct _IO_FILE * stream);
int32_t function_100003f60(struct timespec * requested_time, struct timespec * remaining);
int32_t function_100003f6c(char * format, ...);
int32_t function_100003f78(int32_t * timer);

// --------------------- Global Variables ---------------------

char * g1 = "\x1b[?25l"; // 0x100003f89
char * g2 = "\x1b[2J"; // 0x100003f90
char * g3 = "\x1b[0;0H"; // 0x100003f95

// ------- Dynamically Linked Functions Without Header --------

float64_t _difftime(int32_t a1, int32_t a2);
int32_t _fflush(struct _IO_FILE * a1);
int32_t _nanosleep(struct timespec * a1, struct timespec * a2);
int32_t _printf(char * a1, ...);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003df0 - 0x100003f48
int64_t entry_point(void) {
    // 0x100003df0
    float64_t v1; // 0x100003df0
    float64_t v2 = v1;
    int64_t v3 = 0; // bp-72, 0x100003e14
    _printf((char *)&g1);
    int32_t v4; // bp-48, 0x100003df0
    _time(&v4);
    int32_t v5 = 0; // 0x100003ef0
    _printf((char *)&g2);
    _printf((char *)&g3);
    for (int32_t i = 0; i < 80; i++) {
        // 0x100003e94
        int64_t v6; // 0x100003df0
        _printf("%c", (char)v6);
    }
    // 0x100003ecc
    _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
    _nanosleep((struct timespec *)&v3, NULL);
    v5++;
    int64_t v7 = 0; // 0x100003e58
    while (v5 != 4) {
        // 0x100003e60
        _printf((char *)&g2);
        _printf((char *)&g3);
        for (int32_t i = 0; i < 80; i++) {
            // 0x100003e94
            _printf("%c", (char)v7);
        }
        // 0x100003ecc
        _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
        _nanosleep((struct timespec *)&v3, NULL);
        v5++;
        v7 = 0;
    }
    // 0x100003efc
    int32_t v8; // bp-56, 0x100003df0
    _time(&v8);
    _difftime(v8, v4);
    while (v2 != 20.0) {
        // 0x100003e44
        if (v2 > 20.0 == v2 >= 20.0 == v2 <= 20.0) {
            // break -> 0x100003f2c
            break;
        }
        v5 = 0;
        _printf((char *)&g2);
        _printf((char *)&g3);
        for (int32_t i = 0; i < 80; i++) {
            // 0x100003e94
            _printf("%c", (char)(int64_t)v4);
        }
        // 0x100003ecc
        _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
        _nanosleep((struct timespec *)&v3, NULL);
        v5++;
        v7 = 0;
        while (v5 != 4) {
            // 0x100003e60
            _printf((char *)&g2);
            _printf((char *)&g3);
            for (int32_t i = 0; i < 80; i++) {
                // 0x100003e94
                _printf("%c", (char)v7);
            }
            // 0x100003ecc
            _fflush((struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004000);
            _nanosleep((struct timespec *)&v3, NULL);
            v5++;
            v7 = 0;
        }
        // 0x100003efc
        _time(&v8);
        _difftime(v8, v4);
    }
    // 0x100003f2c
    _printf((char *)0x100003f9f);
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
float64_t function_100003f48(int32_t time1, int32_t time0) {
    // 0x100003f48
    return _difftime(time1, time0);
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(struct _IO_FILE * stream) {
    // 0x100003f54
    return _fflush(stream);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(struct timespec * requested_time, struct timespec * remaining) {
    // 0x100003f60
    return _nanosleep(requested_time, remaining);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(int32_t * timer) {
    // 0x100003f78
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`//FormAI DATASET v1.0 Category: Hotel Management System ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_ROOMS 100
#define MAX_OCCUPANTS 2

// Struct for Room Information
struct Room{
    int room_num;
    bool is_occupied;
    char occupants[MAX_OCCUPANTS][30];
    char room_type[20];
    int room_rate;
    char check_in_date[30];
    char check_out_date[30];
};

// Function Declaration
void display_menu();
void view_rooms(struct Room *rooms);
void book_room(struct Room *rooms);
void view_occupants(struct Room *rooms);
void checkout(struct Room *rooms);

int main(){
    // Initializing Rooms
    struct Room rooms[MAX_ROOMS];
    for(int i=0; i<MAX_ROOMS; i++){
        rooms[i].room_num = i+1;
        rooms[i].is_occupied = false;
        strcpy(rooms[i].room_type, "Basic");
        rooms[i].room_rate = 50;
        strcpy(rooms[i].check_in_date, "");
        strcpy(rooms[i].check_out_date, "");
    }

    // Welcome Message
    printf("Welcome to the C Hotel Management System! \n");
    display_menu(); // Display Menu

    int choice = 0;
    while(choice != 5){ // Exit Condition
        // Prompt User for Choice
        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch(choice){
            case 1: view_rooms(rooms); break;
            case 2: book_room(rooms); break;
            case 3: view_occupants(rooms); break;
            case 4: checkout(rooms); break;
            case 5: printf("Exiting Program! "); break;
            default: printf("Invalid Choice! "); break;
        }

        if(choice != 5){
            // Reload Menu
            printf("\n\n");
            display_menu();
        }
    }

    return 0;
}

void display_menu(){
    printf("===== MENU =====\n");
    printf("1. View Rooms\n");
    printf("2. Book Room\n");
    printf("3. View Occupants\n");
    printf("4. Check-Out\n");
    printf("5. Exit\n");
}

void view_rooms(struct Room *rooms){
    printf("===== ROOMS =====\n");
    printf("Room No.\tType\tRate\tStatus\n");

    for(int i=0; i<MAX_ROOMS; i++){
        printf("%d\t\t%s\t$%d\t", rooms[i].room_num, rooms[i].room_type, rooms[i].room_rate);
        if(rooms[i].is_occupied == true){
            printf("Occupied");
            printf("\tOccupants: %s", rooms[i].occupants[0]);
            if(strcmp(rooms[i].occupants[1], "") != 0){
                printf(", %s", rooms[i].occupants[1]);
            }
            printf(", Check-In: %s", rooms[i].check_in_date);
            printf(", Check-Out: %s", rooms[i].check_out_date);
        }else{
            printf("Available");
        }
        printf("\n");
    }
}

void book_room(struct Room *rooms){
    printf("===== BOOK ROOM =====\n\n");
    printf("Enter Room No.: ");
    int room_no;
    scanf("%d", &room_no);

    // Check if Room Exists
    if(room_no < 1 || room_no > MAX_ROOMS){
        printf("Invalid Room No.! ");
        return;
    }

    // Check if Room is Available
    if(rooms[room_no-1].is_occupied == true){
        printf("Room already occupied! ");
        return;
    }

    // Get User Input
    char occupants[MAX_OCCUPANTS][30];
    printf("\nEnter Name of Occupant 1: ");
    scanf(" %[^\n]s", occupants[0]);
    printf("Enter Name of Occupant 2 (Optional, press enter to skip): ");
    scanf(" %[^\n]s", occupants[1]);
    char check_in_date[30];
    char check_out_date[30];
    printf("Enter Check-In Date (DD/MM/YYYY): ");
    scanf(" %[^\n]s", check_in_date);
    printf("Enter Check-Out Date (DD/MM/YYYY): ");
    scanf(" %[^\n]s", check_out_date);

    // Update Room Information
    rooms[room_no-1].is_occupied = true;
    strcpy(rooms[room_no-1].occupants[0], occupants[0]);
    if(strcmp(occupants[1], "") != 0){
        strcpy(rooms[room_no-1].occupants[1], occupants[1]);
    }
    strcpy(rooms[room_no-1].check_in_date, check_in_date);
    strcpy(rooms[room_no-1].check_out_date, check_out_date);

    printf("\n\nRoom %d has been booked! \n", room_no);
}

void view_occupants(struct Room *rooms){
    printf("===== OCCUPANTS =====\n\n");

    // Check if any Rooms are Occupied
    bool is_occupied = false;
    for(int i=0; i<MAX_ROOMS; i++){
        if(rooms[i].is_occupied == true){
            is_occupied = true;
            break;
        }
    }

    if(is_occupied == false){
        printf("No Rooms are Occupied! ");
        return;
    }

    // Get User Input
    printf("Enter Room No.: ");
    int room_no;
    scanf("%d", &room_no);

    // Check if Room Exists and is Occupied
    if(room_no < 1 || room_no > MAX_ROOMS){
        printf("Invalid Room No.! ");
        return;
    }else{
        if(rooms[room_no-1].is_occupied == false){
            printf("Room is not Occupied! ");
            return;
        }
    }

    printf("\nOccupants of Room %d: %s", room_no, rooms[room_no-1].occupants[0]);
    if(strcmp(rooms[room_no-1].occupants[1], "") != 0){
        printf(", %s", rooms[room_no-1].occupants[1]);
    }
    printf("\n");
}

void checkout(struct Room *rooms){
    printf("===== CHECK-OUT =====\n\n");

    // Check if any Rooms are Occupied
    bool is_occupied = false;
    for(int i=0; i<MAX_ROOMS; i++){
        if(rooms[i].is_occupied == true){
            is_occupied = true;
            break;
        }
    }

    if(is_occupied == false){
        printf("No Rooms are Occupied! ");
        return;
    }

    // Get User Input
    printf("Enter Room No.: ");
    int room_no;
    scanf("%d", &room_no);

    // Check if Room Exists and is Occupied
    if(room_no < 1 || room_no > MAX_ROOMS){
        printf("Invalid Room No.! ");
        return;
    }else{
        if(rooms[room_no-1].is_occupied == false){
            printf("Room is not Occupied! ");
            return;
        }
    }

    // Calculate Bill
    int rate = rooms[room_no-1].room_rate;
    char check_in_date[30];
    strcpy(check_in_date, rooms[room_no-1].check_in_date);
    char check_out_date[30];
    strcpy(check_out_date, rooms[room_no-1].check_out_date);
    int check_in_day, check_in_month, check_in_year;
    sscanf(check_in_date, "%d/%d/%d", &check_in_day, &check_in_month, &check_in_year);
    int check_out_day, check_out_month, check_out_year;
    sscanf(check_out_date, "%d/%d/%d", &check_out_day, &check_out_month, &check_out_year);
    int days_stayed = (check_out_year - check_in_year)*365 + (check_out_month - check_in_month)*30 + (check_out_day - check_in_day);
    int total_bill = rate*days_stayed;

    printf("\nTotal Bill: $%d", total_bill);

    // Update Room Information
    rooms[room_no-1].is_occupied = false;
    strcpy(rooms[room_no-1].occupants[0], "");
    strcpy(rooms[room_no-1].occupants[1], "");
    strcpy(rooms[room_no-1].check_in_date, "");
    strcpy(rooms[room_no-1].check_out_date, "");

    printf("\n\nCheck-Out of Room %d completed! \n", room_no);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 display_menu(void); // weak
__int64 __fastcall view_rooms(_QWORD); // weak
__int64 __fastcall book_room(_QWORD); // weak
__int64 __fastcall view_occupants(_QWORD); // weak
__int64 __fastcall checkout(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-54h] BYREF
  char v5[80]; // [rsp+30h] [rbp-50h] BYREF
  _BYTE v6[15132]; // [rsp+80h] [rbp+0h] BYREF
  int i; // [rsp+3B9Ch] [rbp+3B1Ch]

  _main(argc, argv, envp);
  for ( i = 0; i <= 99; ++i )
  {
    *(_DWORD *)&v6[152 * i - 80] = i + 1;
    v6[152 * i - 76] = 0;
    strcpy(&v5[152 * i + 65], "Basic");
    *(_DWORD *)&v6[152 * i + 8] = 50;
    v6[152 * i + 12] = 0;
    v5[152 * i + 122] = 0;
  }
  printf("Welcome to the C Hotel Management System! \n");
  display_menu();
  v4 = 0;
  while ( v4 != 5 )
  {
    printf("\nEnter your choice: ");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        view_rooms(v5);
        break;
      case 2:
        book_room(v5);
        break;
      case 3:
        view_occupants(v5);
        break;
      case 4:
        checkout(v5);
        break;
      case 5:
        printf("Exiting Program! ");
        break;
      default:
        printf("Invalid Choice! ");
        break;
    }
    if ( v4 != 5 )
    {
      printf("\n\n");
      display_menu();
    }
  }
  return 0;
}
// 140001892: using guessed type __int64 display_menu(void);
// 1400018FB: using guessed type __int64 __fastcall view_rooms(_QWORD);
// 140001B49: using guessed type __int64 __fastcall book_room(_QWORD);
// 140001DC4: using guessed type __int64 __fastcall view_occupants(_QWORD);
// 140001FA3: using guessed type __int64 __fastcall checkout(_QWORD);
// 1400023B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define USE_FAKES 1

const char *states[] = {
#if USE_FAKES
	"New Kory", "Wen Kory", "York New", "Kory New", "New Kory",
#endif
	"Alabama", "Alaska", "Arizona", "Arkansas",
	"California", "Colorado", "Connecticut",
	"Delaware",
	"Florida", "Georgia", "Hawaii",
	"Idaho", "Illinois", "Indiana", "Iowa",
	"Kansas", "Kentucky", "Louisiana",
	"Maine", "Maryland", "Massachusetts", "Michigan",
	"Minnesota", "Mississippi", "Missouri", "Montana",
	"Nebraska", "Nevada", "New Hampshire", "New Jersey",
	"New Mexico", "New York", "North Carolina", "North Dakota",
	"Ohio", "Oklahoma", "Oregon",
	"Pennsylvania", "Rhode Island",
	"South Carolina", "South Dakota", "Tennessee", "Texas",
	"Utah", "Vermont", "Virginia",
	"Washington", "West Virginia", "Wisconsin", "Wyoming"
};

int n_states = sizeof(states)/sizeof(*states);
typedef struct { unsigned char c[26]; const char *name[2]; } letters;

void count_letters(letters *l, const char *s)
{
	int c;
	if (!l->name[0]) l->name[0] = s;
	else l->name[1] = s;

	while ((c = *s++)) {
		if (c >= 'a' && c <= 'z') l->c[c - 'a']++;
		if (c >= 'A' && c <= 'Z') l->c[c - 'A']++;
	}
}

int lcmp(const void *aa, const void *bb)
{
	int i;
	const letters *a = aa, *b = bb;
	for (i = 0; i < 26; i++)
		if      (a->c[i] > b->c[i]) return  1;
		else if (a->c[i] < b->c[i]) return -1;
	return 0;
}

int scmp(const void *a, const void *b)
{
	return strcmp(*(const char *const *)a, *(const char *const *)b);
}

void no_dup()
{
	int i, j;

	qsort(states, n_states, sizeof(const char*), scmp);

	for (i = j = 0; i < n_states;) {
		while (++i < n_states && !strcmp(states[i], states[j]));
		if (i < n_states) states[++j] = states[i];
	}

	n_states = j + 1;
}

void find_mix()
{
	int i, j, n;
	letters *l, *p;

	no_dup();
	n = n_states * (n_states - 1) / 2;
	p = l = calloc(n, sizeof(letters));

	for (i = 0; i < n_states; i++)
		for (j = i + 1; j < n_states; j++, p++) {
			count_letters(p, states[i]);
			count_letters(p, states[j]);
		}

	qsort(l, n, sizeof(letters), lcmp);

	for (j = 0; j < n; j++) {
		for (i = j + 1; i < n && !lcmp(l + j, l + i); i++) {
			if (l[j].name[0] == l[i].name[0]
				|| l[j].name[1] == l[i].name[0]
				|| l[j].name[1] == l[i].name[1])
				continue;
			printf("%s + %s => %s + %s\n",
				l[j].name[0], l[j].name[1], l[i].name[0], l[i].name[1]);
		}
	}
	free(l);
}

int main(void)
{
	find_mix();
	return 0;
}
`,`#include "state-name-puzzle.h"



void _count_letters(long param_1,char *param_2)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  char *local_10;
  
  if (*(long *)(param_1 + 0x20) == 0) {
    *(char **)(param_1 + 0x20) = param_2;
    local_10 = param_2;
  }
  else {
    *(char **)(param_1 + 0x28) = param_2;
    local_10 = param_2;
  }
  while( true ) {
    pcVar2 = local_10 + 1;
    iVar3 = (int)*local_10;
    if (iVar3 == 0) break;
    if ((0x60 < iVar3) && (iVar3 < 0x7b)) {
      pcVar1 = (char *)(param_1 + (iVar3 + -0x61));
      *pcVar1 = *pcVar1 + '\x01';
    }
    local_10 = pcVar2;
    if ((0x40 < iVar3) && (iVar3 < 0x5b)) {
      pcVar2 = (char *)(param_1 + (iVar3 + -0x41));
      *pcVar2 = *pcVar2 + '\x01';
    }
  }
  return;
}



undefined4 _lcmp(long param_1,long param_2)

{
  int local_1c;
  
  local_1c = 0;
  while( true ) {
    if (0x19 < local_1c) {
      return 0;
    }
    if (*(byte *)(param_2 + local_1c) < *(byte *)(param_1 + local_1c)) break;
    if (*(byte *)(param_1 + local_1c) < *(byte *)(param_2 + local_1c)) {
      return 0xffffffff;
    }
    local_1c = local_1c + 1;
  }
  return 1;
}



int _scmp(undefined8 *param_1,undefined8 *param_2)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)*param_1,(char *)*param_2);
  return iVar1;
}



void _no_dup(void)

{
  bool bVar1;
  int iVar2;
  int local_18;
  int local_14;
  
  _qsort(&_states,(long)_n_states,8,(int *)_scmp);
  local_18 = 0;
  local_14 = 0;
  while (local_14 < _n_states) {
    do {
      local_14 = local_14 + 1;
      bVar1 = false;
      if (local_14 < _n_states) {
        iVar2 = _strcmp((&_states)[local_14],(&_states)[local_18]);
        bVar1 = iVar2 == 0;
      }
    } while (bVar1);
    if (local_14 < _n_states) {
      local_18 = local_18 + 1;
      (&_states)[local_18] = (&_states)[local_14];
    }
  }
  _n_states = local_18 + 1;
  return;
}



void _find_mix(void)

{
  int iVar1;
  bool bVar2;
  int iVar3;
  void *pvVar4;
  void *local_30;
  int local_18;
  int local_14;
  
  _no_dup();
  iVar1 = (_n_states * (_n_states + -1)) / 2;
  pvVar4 = _calloc((long)iVar1,0x30);
  local_30 = pvVar4;
  for (local_14 = 0; local_18 = local_14, local_14 < _n_states; local_14 = local_14 + 1) {
    while (local_18 = local_18 + 1, local_18 < _n_states) {
      _count_letters(local_30,(&_states)[local_14]);
      _count_letters(local_30,(&_states)[local_18]);
      local_30 = (void *)((long)local_30 + 0x30);
    }
  }
  _qsort(pvVar4,(long)iVar1,0x30,(int *)_lcmp);
  for (local_18 = 0; local_14 = local_18, local_18 < iVar1; local_18 = local_18 + 1) {
    while( true ) {
      local_14 = local_14 + 1;
      bVar2 = false;
      if (local_14 < iVar1) {
        iVar3 = _lcmp((void *)((long)pvVar4 + (long)local_18 * 0x30),
                      (void *)((long)pvVar4 + (long)local_14 * 0x30));
        bVar2 = iVar3 == 0;
      }
      if (!bVar2) break;
      if (((*(long *)((long)pvVar4 + (long)local_18 * 0x30 + 0x20) !=
            *(long *)((long)pvVar4 + (long)local_14 * 0x30 + 0x20)) &&
          (*(long *)((long)pvVar4 + (long)local_18 * 0x30 + 0x28) !=
           *(long *)((long)pvVar4 + (long)local_14 * 0x30 + 0x20))) &&
         (*(long *)((long)pvVar4 + (long)local_18 * 0x30 + 0x28) !=
          *(long *)((long)pvVar4 + (long)local_14 * 0x30 + 0x28))) {
        _printf("%s + %s => %s + %s\n");
      }
    }
  }
  _free(pvVar4);
  return;
}



undefined4 entry(void)

{
  _find_mix();
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d54. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003d60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003d78. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004020)((int)param_1);
  return iVar1;
}


`
`typedef unsigned long long int ulong; // define a type that represent the limit (64-bit)

ulong mod_mul(ulong a, ulong b, const ulong mod) {
	ulong res = 0, c; // return (a * b) % mod, avoiding overflow errors while doing modular multiplication.
	for (b %= mod; a; a & 1 ? b >= mod - res ? res -= mod : 0, res += b : 0, a >>= 1, (c = b) >= mod - b ? c -= mod : 0, b += c);
	return res % mod;
}

ulong mod_pow(ulong n, ulong exp, const ulong mod) {
	ulong res = 1; // return (n ^ exp) % mod
	for (n %= mod; exp; exp & 1 ? res = mod_mul(res, n, mod) : 0, n = mod_mul(n, n, mod), exp >>= 1);
	return res;
}

ulong square_root(const ulong N) {
	ulong res = 0, rem = N, c, d;
	for (c = 1 << 62; c; c >>= 2) {
		d = res + c;
		res >>= 1;
		if (rem >= d)
			rem -= d, res += c;
	} // returns the square root of N.
	return res;
}

int is_prime(const ulong N) {
	ulong i = 1; // return a truthy value about the primality of N.
	if (N > 1) for (; i < 64 && mod_pow(i, N - 1, N) <= 1; ++i);
	return i == 64;
}

ulong pollard_rho(const ulong N) {
	// Require : N is a composite number, not a square.
	// Ensure : res is a non-trivial factor of N.
	// Option : change the timeout, change the rand function.
	static const int timeout = 18;
	static unsigned long long rand_val = 2994439072U;
	rand_val = (rand_val * 1025416097U + 286824428U) % 4294967291LLU;
	ulong res = 1, a, b, c, i = 0, j = 1, x = 1, y = 1 + rand_val % (N - 1);
	for (; res == 1; ++i) {
		if (i == j) {
			if (j >> timeout)
				break;
			j <<= 1;
			x = y;
		}
		a = y, b = y; // performs y = (y * y) % N
		for (y = 0; a; a & 1 ? b >= N - y ? y -= N : 0, y += b : 0, a >>= 1, (c = b) >= N - b ? c -= N : 0, b += c);
		y = (1 + y) % N;
		for (a = y > x ? y - x : x - y, b = N; (a %= b) && (b %= a);); // compute the gcd(abs(y - x), N);
		res = a | b;
	}
	return res;
}

void factor(const ulong N, ulong *array) {
	// very basic manager that fill the given array (the size of the result is the first array element)	
	// it does not perform initial trial divisions, which is generally highly recommended.
	if (N < 4 || is_prime(N)) {
		if (N > 1 || !*array) array[++*array] = N;
		return;
	}
	ulong x = square_root(N);
	if (x * x != N) x = pollard_rho(N);
	factor(x, array);
	factor(N / x, array);
}

#include <stdio.h>

int main(void) {
	// simple test.
	unsigned long long n = 18446744073709551615U;
	ulong fac[65] = {0};
	factor(n, fac);
	for (ulong i = 1; i <= *fac; ++i)
		printf("* %llu\n", fac[i]);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003778(void);
int64_t function_10000389c(void);
int64_t function_100003954(void);
int64_t function_1000039fc(void);
int64_t function_100003aac(void);
int64_t function_100003d7c(void);
int64_t function_100003f58(int64_t a1);
void function_100003f64(int64_t * s, int32_t n);
int32_t function_100003f70(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0xb27b83a0; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
void _bzero(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003778 - 0x10000389c
int64_t function_100003778(void) {
    // 0x100003778
    int64_t v1; // 0x100003778
    uint64_t v2 = v1;
    if (v1 == 0) {
        // 0x100003880
        return 0;
    }
    int64_t v3 = -v2;
    int64_t v4 = 0;
    int64_t v5; // 0x100003778
    uint64_t v6 = v5;
    uint64_t v7 = v1 % v2;
    int64_t v8 = v4; // 0x1000037cc
    int64_t v9; // 0x100003778
    if (v6 % 2 != 0) {
        // 0x1000037d4
        v9 = v7 < v2 - v4 ? 0 : v3;
        v8 = v4 + v7 + v9;
    }
    int64_t v10 = v8;
    int64_t v11 = (v7 < v2 - v7 ? 0 : v3) + 2 * v7; // 0x1000037b4
    v5 = v6 / 2;
    while (v6 >= 2) {
        // 0x1000037c0
        v4 = v10;
        v6 = v5;
        v7 = v11;
        v8 = v4;
        if (v6 % 2 != 0) {
            // 0x1000037d4
            v9 = v7 < v2 - v4 ? 0 : v3;
            v8 = v4 + v7 + v9;
        }
        // 0x100003824
        v10 = v8;
        v11 = (v7 < v2 - v7 ? 0 : v3) + 2 * v7;
        v5 = v6 / 2;
    }
    // 0x100003880
    return v10 % v2;
}

// Address range: 0x10000389c - 0x100003954
int64_t function_10000389c(void) {
    // 0x10000389c
    int64_t v1; // 0x10000389c
    if (v1 == 0) {
        // 0x100003944
        return 1;
    }
    // 0x10000389c
    int64_t v2; // 0x10000389c
    uint64_t v3 = v2;
    int64_t v4 = 1; // 0x1000038fc
    if (v3 % 2 != 0) {
        // 0x100003904
        v4 = function_100003778();
    }
    int64_t result = v4;
    function_100003778();
    v2 = v3 / 2;
    while (v3 >= 2) {
        // 0x1000038f0
        v3 = v2;
        v4 = result;
        if (v3 % 2 != 0) {
            // 0x100003904
            v4 = function_100003778();
        }
        // 0x100003920
        result = v4;
        function_100003778();
        v2 = v3 / 2;
    }
    // 0x100003944
    return result;
}

// Address range: 0x100003954 - 0x1000039fc
int64_t function_100003954(void) {
    // 0x100003954
    int64_t v1; // 0x100003954
    if (v1 == 0) {
        // 0x1000039f0
        return 0;
    }
    int64_t result = 0; // 0x10000397c
    int64_t v2; // 0x100003954
    uint64_t v3 = v2;
    int64_t v4; // 0x100003954
    uint64_t v5 = v4;
    uint64_t v6 = result + v5; // 0x10000398c
    result = (v3 < v6 ? 0 : v5) + result / 2;
    v4 = v5 / 4;
    v2 = v3 - (v3 < v6 ? 0 : v6);
    while (v5 >= 4) {
        // 0x100003984
        v3 = v2;
        v5 = v4;
        v6 = result + v5;
        result = (v3 < v6 ? 0 : v5) + result / 2;
        v4 = v5 / 4;
        v2 = v3 - (v3 < v6 ? 0 : v6);
    }
    // 0x1000039f0
    return result;
}

// Address range: 0x1000039fc - 0x100003aac
int64_t function_1000039fc(void) {
    // 0x1000039fc
    int64_t v1; // 0x1000039fc
    int64_t v2 = v1;
    if (v2 == 1 || v2 == 0) {
        // 0x100003a90
        return false;
    }
    int64_t v3 = 1; // 0x100003a20
    int64_t v4 = function_10000389c(); // 0x100003a58
    int64_t v5 = v3; // 0x100003a70
    while (v4 == 1 || v4 == 0) {
        // 0x100003a7c
        v3++;
        v5 = 64;
        if (v3 >= 64) {
            // break -> 0x100003a90
            break;
        }
        v4 = function_10000389c();
        v5 = v3;
    }
    // 0x100003a90
    return v5 == 64;
}

// Address range: 0x100003aac - 0x100003d7c
int64_t function_100003aac(void) {
    // 0x100003aac
    int64_t v1; // 0x100003aac
    uint64_t v2 = v1;
    g1 = (0x3d1e9ba1 * g1 + 0x111897ec) % 0xfffffffb;
    int64_t v3 = -v2;
    int64_t v4 = 0; // 0x100003aac
    int64_t v5 = 1;
    int64_t v6 = v5; // 0x100003b48
    int64_t v7 = 1; // 0x100003b48
    if (v4 == v5) {
        // 0x100003b50
        if (v5 >= 0x40000) {
            // break -> 0x100003d70
            break;
        }
        // 0x100003b6c
        v6 = 2 * v5;
    }
    int64_t v8 = v7;
    int64_t v9 = v7; // 0x100003ba8
    int64_t v10 = v7; // 0x100003ba8
    int64_t v11 = 0; // 0x100003ba8
    int64_t v12; // 0x100003aac
    int64_t v13; // 0x100003aac
    uint64_t v14; // 0x100003aac
    uint64_t v15; // 0x100003aac
    int64_t v16; // 0x100003aac
    int64_t v17; // 0x100003aac
    if (v7 != 0) {
        v16 = 0;
        v14 = v10;
        v15 = v9;
        v17 = v16;
        if (v14 % 2 != 0) {
            // 0x100003bc8
            v12 = v15 < v2 - v16 ? 0 : v3;
            v17 = v16 + v15 + v12;
        }
        // 0x100003c18
        v13 = v15 < v2 - v15 ? 0 : v3;
        v9 = v13 + 2 * v15;
        v10 = v14 / 2;
        v11 = v17;
        while (v14 >= 2) {
            // 0x100003bb4
            v16 = v17;
            v14 = v10;
            v15 = v9;
            v17 = v16;
            if (v14 % 2 != 0) {
                // 0x100003bc8
                v12 = v15 < v2 - v16 ? 0 : v3;
                v17 = v16 + v15 + v12;
            }
            // 0x100003c18
            v13 = v15 < v2 - v15 ? 0 : v3;
            v9 = v13 + 2 * v15;
            v10 = v14 / 2;
            v11 = v17;
        }
    }
    uint64_t v18 = (v11 + 1) % v2;
    int64_t v19 = v18 == v8 | v18 < v8 ? v8 - v18 : v18 - v8;
    int64_t v20; // 0x100003aac
    uint64_t v21 = v19 % v20;
    int64_t v22 = v20; // 0x100003d0c
    int64_t v23; // 0x100003aac
    int64_t v24; // 0x100003aac
    while (v21 != 0) {
        // 0x100003d3c
        v24 = v20 % v21;
        v23 = v21;
        v20 = v24;
        v22 = 0;
        if (v24 == 0) {
            // break -> 0x100003d4c
            break;
        }
        v21 = v23 % v20;
        v22 = v20;
    }
    int64_t v25 = v22 | v21; // 0x100003d54
    v4++;
    int64_t result = v25; // 0x100003b30
    while (v25 == 1) {
        // 0x100003b38
        v5 = v6;
        v7 = v18;
        v6 = v5;
        int64_t v26 = v8; // 0x100003b48
        if (v4 == v5) {
            // 0x100003b50
            result = 1;
            if (v5 >= 0x40000) {
                // break -> 0x100003d70
                break;
            }
            // 0x100003b6c
            v6 = 2 * v5;
            v26 = v7;
        }
        // 0x100003b84
        v8 = v26;
        v9 = v7;
        v10 = v7;
        v11 = 0;
        if (v7 != 0) {
            v16 = 0;
            v14 = v10;
            v15 = v9;
            v17 = v16;
            if (v14 % 2 != 0) {
                // 0x100003bc8
                v12 = v15 < v2 - v16 ? 0 : v3;
                v17 = v16 + v15 + v12;
            }
            // 0x100003c18
            v13 = v15 < v2 - v15 ? 0 : v3;
            v9 = v13 + 2 * v15;
            v10 = v14 / 2;
            v11 = v17;
            while (v14 >= 2) {
                // 0x100003bb4
                v16 = v17;
                v14 = v10;
                v15 = v9;
                v17 = v16;
                if (v14 % 2 != 0) {
                    // 0x100003bc8
                    v12 = v15 < v2 - v16 ? 0 : v3;
                    v17 = v16 + v15 + v12;
                }
                // 0x100003c18
                v13 = v15 < v2 - v15 ? 0 : v3;
                v9 = v13 + 2 * v15;
                v10 = v14 / 2;
                v11 = v17;
            }
        }
        // 0x100003c74
        v18 = (v11 + 1) % v2;
        v19 = v18 == v8 | v18 < v8 ? v8 - v18 : v18 - v8;
        v21 = v19 % v20;
        v22 = v20;
        while (v21 != 0) {
            // 0x100003d3c
            v24 = v20 % v21;
            v23 = v21;
            v20 = v24;
            v22 = 0;
            if (v24 == 0) {
                // break -> 0x100003d4c
                break;
            }
            v21 = v23 % v20;
            v22 = v20;
        }
        // 0x100003d4c
        v25 = v22 | v21;
        v4++;
        result = v25;
    }
    // 0x100003d70
    return result;
}

// Address range: 0x100003d7c - 0x100003e78
int64_t function_100003d7c(void) {
    // 0x100003d7c
    int64_t v1; // 0x100003d7c
    int64_t v2 = v1;
    uint64_t v3 = v1;
    int64_t result; // 0x100003d7c
    if (v3 >= 4) {
        int64_t v4 = function_1000039fc(); // 0x100003da8
        result = v4;
        if ((int32_t)v4 == 0) {
            int64_t v5 = function_100003954(); // 0x100003e10
            if (v5 * v5 != v3) {
                // 0x100003e38
                function_100003aac();
            }
            // 0x100003e48
            function_100003d7c();
            // 0x100003e6c
            return function_100003d7c();
        }
    }
    // 0x100003dbc
    if (v2 == 0 || v3 != 0 == (v3 != 1)) {
        // 0x100003de8
        *(int64_t *)v2 = v2 + 1;
    }
    // 0x100003e6c
    return result;
}

// Address range: 0x100003e78 - 0x100003f58
int64_t entry_point(void) {
    // 0x100003e78
    int64_t v1; // bp-552, 0x100003e78
    _bzero(&v1, 520);
    uint64_t v2 = v1; // 0x100003ed0
    int64_t v3 = 1; // 0x100003edc
    int64_t v4 = function_100003d7c(); // 0x100003edc
    if (v2 <= 1 != v2 != 1) {
        int32_t v5 = _printf("* %llu\n", (int64_t)&v1); // 0x100003f00
        v3++;
        while (v3 >= v1 != v3 != v1) {
            // 0x100003ee4
            v5 = _printf("* %llu\n", (int64_t)&v1);
            v3++;
        }
        // 0x100003ecc
        v4 = v5;
    }
    int64_t v6 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f2c
    if (v6 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f40
        ___stack_chk_fail(v4);
    }
    // 0x100003f44
    return 0;
}

// Address range: 0x100003f58 - 0x100003f64
int64_t function_100003f58(int64_t a1) {
    // 0x100003f58
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f64 - 0x100003f70
void function_100003f64(int64_t * s, int32_t n) {
    // 0x100003f64
    _bzero(s, n);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 10

`
`#include <stdio.h>

int main(void) {
    char dna[] = "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG"
                "CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG"
                "AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT"
                "GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT"
                "CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG"
                "TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA"
                "TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT"
                "CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG"
                "TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC"
                "GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT";
    int c_count = 0, t_count = 0, a_count = 0, g_count = 0, total;

    for (total = 0; dna[total]; total++) {
        if (total % 50 == 0)
            printf("\n%3d - %3d: %c", total + 1, total + 50, dna[total]);
        else if (total % 5 == 0)
            printf(" %c", dna[total]);
        else
            printf("%c", dna[total]);

        switch (dna[total]) {
            case 'C': c_count++; break;
            case 'T': t_count++; break;
            case 'A': a_count++; break;
            case 'G': g_count++; break;
        }
    }

    printf("\n\nC count: %3d\nT count: %3d\nA count: %3d\nG count: %3d\n  Total: %3d\n\n",
            c_count, t_count, a_count, g_count, total);

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int64_t function_100003d2c(int64_t a1);
int64_t * function_100003d38(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003d44(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003a70 - 0x100003cdc
int64_t entry_point(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x100003a70
    int64_t v1; // bp-533, 0x100003a70
    _memcpy(&v1, (int64_t *)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT", 501);
    int64_t v2; // 0x100003a70
    if (*(char *)&v1 == 0) {
      lab_0x100003c58:;
        int32_t v3 = _printf("\n\nC count: %3d\nT count: %3d\nA count: %3d\nG count: %3d\n  Total: %3d\n\n", (int64_t)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT", 501, v2, v2, v2); // 0x100003ca0
        int64_t v4 = *(int64_t *)0x100004008; // 0x100003cac
        if (*(int64_t *)v4 != *(int64_t *)*(int64_t *)0x100004008) {
            // 0x100003cc4
            ___stack_chk_fail((int64_t)v3);
        }
        // 0x100003cc8
        return 0;
    }
    int32_t v5 = 0;
    int32_t result; // 0x100003a70
    if (v5 % 50 == 0) {
        // 0x100003b04
        result = _printf("\n%3d - %3d: %c", (int64_t)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT", 501, (char)v2);
    } else {
        if (v5 % 5 == 0) {
            // 0x100003b70
            result = _printf(" %c", (char)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT");
        } else {
            // 0x100003b98
            result = _printf("%c", (char)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT");
        }
    }
    uint64_t v6 = (int64_t)*(char *)&v1 + 0xffffffbf & 0xffffffff; // 0x100003bd4
    while (v6 >= 19 == (v6 != 19)) {
        int32_t v7 = v5 + 1; // 0x100003c4c
        char * v8 = (char *)((int64_t)v7 + (int64_t)&v1); // 0x100003acc
        if (*v8 == 0) {
            goto lab_0x100003c58;
        }
        v5 = v7;
        if (v5 % 50 == 0) {
            // 0x100003b04
            result = _printf("\n%3d - %3d: %c", (int64_t)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT", 501, (char)v2);
        } else {
            if (v5 % 5 == 0) {
                // 0x100003b70
                result = _printf(" %c", (char)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT");
            } else {
                // 0x100003b98
                result = _printf("%c", (char)"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT");
            }
        }
        // 0x100003bc4
        v6 = (int64_t)*v8 + 0xffffffbf & 0xffffffff;
    }
    // 0x100003be8
    return result;
}

// Address range: 0x100003d2c - 0x100003d38
int64_t function_100003d2c(int64_t a1) {
    // 0x100003d2c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003d38 - 0x100003d44
int64_t * function_100003d38(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003d38
    return _memcpy(dest, src, n);
}

// Address range: 0x100003d44 - 0x100003d50
int32_t function_100003d44(char * format, ...) {
    // 0x100003d44
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`/*
 * RosettaCode: Fifteen puzle game, C89, plain vanillia TTY, MVC
 */

#define _CRT_SECURE_NO_WARNINGS /* unlocks printf etc. in MSVC */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

enum Move { MOVE_UP = 0, MOVE_DOWN = 1, MOVE_LEFT = 2, MOVE_RIGHT = 3 };

/* *****************************************************************************
 * Model
 */

#define NROWS     4
#define NCOLLUMNS 4
int holeRow;
int holeCollumn;
int cells[NROWS][NCOLLUMNS];
const int nShuffles = 100;

int Game_update(enum Move move){
    const int dx[] = {  0,  0, -1, +1 };
    const int dy[] = { -1, +1,  0,  0 };
    int i = holeRow     + dy[move];
    int j = holeCollumn + dx[move];
    if ( i >= 0 && i < NROWS && j >= 0 && j < NCOLLUMNS ){
        cells[holeRow][holeCollumn] = cells[i][j];
        cells[i][j] = 0; holeRow = i; holeCollumn = j;
        return 1;
    }
    return 0;
}

void Game_setup(void){
    int i,j,k;
    for ( i = 0; i < NROWS; i++ )
        for ( j = 0; j < NCOLLUMNS; j++ )
            cells[i][j] = i * NCOLLUMNS + j + 1;
    cells[NROWS-1][NCOLLUMNS-1] = 0;
    holeRow = NROWS - 1;
    holeCollumn = NCOLLUMNS - 1;
    k = 0;
    while ( k < nShuffles )
        k += Game_update((enum Move)(rand() % 4));
}

int Game_isFinished(void){
    int i,j; int k = 1;
    for ( i = 0; i < NROWS; i++ )
        for ( j = 0; j < NCOLLUMNS; j++ )
            if ( (k < NROWS*NCOLLUMNS) && (cells[i][j] != k++ ) )
                return 0;
    return 1;
}


/* *****************************************************************************
 * View
 */

void View_showBoard(){
    int i,j;
    putchar('\n');
    for ( i = 0; i < NROWS; i++ )
        for ( j = 0; j < NCOLLUMNS; j++ ){
            if ( cells[i][j] )
                printf(j != NCOLLUMNS-1 ? " %2d " : " %2d \n", cells[i][j]);
            else
                printf(j != NCOLLUMNS-1 ? " %2s " : " %2s \n", "");
        }
    putchar('\n');
}

void View_displayMessage(char* text){
    printf("\n%s\n", text);
}


/* *****************************************************************************
 * Controller
 */

enum Move Controller_getMove(void){
    int c;
    for(;;){
        printf("%s", "enter u/d/l/r : ");
        c = getchar();
        while( getchar() != '\n' )
            ;
        switch ( c ){
            case 27: exit(EXIT_SUCCESS);
            case 'd' : return MOVE_UP;
            case 'u' : return MOVE_DOWN;
            case 'r' : return MOVE_LEFT;
            case 'l' : return MOVE_RIGHT;
        }
    }
}

void Controller_pause(void){
    getchar();
}

int main(void){

    srand((unsigned)time(NULL));

    do Game_setup(); while ( Game_isFinished() );

    View_showBoard();
    while( !Game_isFinished() ){
        Game_update( Controller_getMove() );
        View_showBoard();
    }

    View_displayMessage("You win");
    Controller_pause();

    return EXIT_SUCCESS;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003858(void);
int64_t function_1000039dc(void);
int64_t function_100003ae8(void);
int64_t function_100003bbc(void);
int64_t function_100003d00(char * a1);
int64_t function_100003d34(void);
int64_t function_100003e34(int64_t a1);
int64_t function_100003ed0(void);
void function_100003edc(int32_t status);
int32_t function_100003ee8(void);
int32_t function_100003ef4(char * format, ...);
int32_t function_100003f00(int32_t c);
int32_t function_100003f0c(void);
void function_100003f18(int32_t seed);
int32_t function_100003f24(int32_t * timer);

// --------------------- Global Variables ---------------------

float128_t g1 = 0.0L; // 0x100003f40
float128_t g2 = 4.24399158143647898438151788554984887e-314L; // 0x100003f50
int64_t g3 = 0x100000cfeedfacf; // 0x100008000
int64_t g4 = 0; // 0x10000803c
int32_t * g5 = (int32_t *)0x100000000; // 0x100008040
int32_t * g6; // 0x100008044
int32_t g7;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(void);
int32_t _getchar(void);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003858 - 0x1000039dc
int64_t function_100003858(void) {
    int64_t * v1 = (int64_t *)*(int64_t *)0x100004008;
    int64_t v2 = (float64_t)g1; // bp-48, 0x100003888
    int64_t v3 = (float64_t)g2; // bp-64, 0x10000389c
    int32_t v4 = *(int32_t *)&g6; // 0x1000038a8
    int64_t v5; // 0x100003858
    int64_t v6 = 4 * v5 & 0x3fffffffc; // 0x1000038b0
    int32_t v7 = *(int32_t *)(v6 + (int64_t)&v3) + v4; // 0x1000038b4
    int64_t * v8 = v1; // 0x1000038e4
    int64_t result = 0; // 0x1000038e4
    if (v7 >= 0) {
        int32_t v9 = *(int32_t *)&g5; // 0x1000038c4
        int32_t v10 = *(int32_t *)(v6 + (int64_t)&v2) + v9; // 0x1000038d0
        v8 = v1;
        result = 0;
        if (v10 >= 0 && v7 < 4 != (3 - v7 & v7) < 0) {
            // 0x100003914
            v8 = v1;
            result = 0;
            if (v10 < 4 != (3 - v10 & v10) < 0) {
                int32_t * v11 = (int32_t *)(16 * (int64_t)v7 + (int64_t)&g3 + 4 * (int64_t)v10); // 0x100003940
                int32_t v12 = *v11; // 0x100003940
                *(int32_t *)(16 * (int64_t)v4 + (int64_t)&g3 + 4 * (int64_t)v9) = v12;
                *v11 = 0;
                *(int32_t *)&g6 = v7;
                *(int32_t *)&g5 = v10;
                v8 = (int64_t *)*(int64_t *)0x100004008;
                result = 1;
            }
        }
    }
    // 0x1000039a0
    if (*v8 != *v1) {
        // 0x1000039c8
        ___stack_chk_fail();
    }
    // 0x1000039cc
    return result;
}

// Address range: 0x1000039dc - 0x100003ae8
int64_t function_1000039dc(void) {
    for (int64_t i = 0; i < 4; i++) {
        int64_t v1 = 4 * i;
        int64_t v2 = 16 * i + (int64_t)&g3; // 0x100003a3c
        int64_t v3 = 0;
        int64_t v4 = v3 + 1;
        *(int32_t *)(v2 + 4 * v3) = (int32_t)(v4 + v1);
        while (v4 != 4) {
            // 0x100003a20
            v3 = v4;
            v4 = v3 + 1;
            *(int32_t *)(v2 + 4 * v3) = (int32_t)(v4 + v1);
        }
    }
    // 0x100003a70
    *(int32_t *)&g4 = 0;
    *(int32_t *)&g6 = 3;
    *(int32_t *)&g5 = 3;
    int32_t v5 = 0; // 0x100003ad0
    _rand();
    int64_t result = function_100003858(); // 0x100003ac8
    while (v5 + (int32_t)result < 100 != (99 - v5 + (int32_t)result & v5 + (int32_t)result) < 0) {
        // 0x100003ab4
        v5 += (int32_t)result;
        _rand();
        result = function_100003858();
    }
    // 0x100003adc
    return result;
}

// Address range: 0x100003ae8 - 0x100003bbc
int64_t function_100003ae8(void) {
    int32_t v1 = 0;
    uint64_t v2 = 0;
    int64_t v3 = 16 * v2 + (int64_t)&g3;
    int32_t v4 = 1;
    int32_t v5 = 0;
    uint64_t v6 = 0;
    int32_t v7 = v4; // 0x100003b38
    int64_t result; // 0x100003ae8
    if (v4 < 16 != (15 - v4 & v4) < 0) {
        // 0x100003b40
        v7 = v4 + 1;
        result = 0;
        if (*(int32_t *)(v3 + 4 * v6) != v4) {
            return result;
        }
    }
    int64_t v8 = v6 + 1;
    int32_t v9 = v5 + 1; // 0x100003b24
    while (v6 < 3 != (2 - v5 & (int32_t)v8) < 0) {
        // 0x100003b2c
        v4 = v7;
        v5 = v9;
        v6 = v8;
        v7 = v4;
        if (v4 < 16 != (15 - v4 & v4) < 0) {
            // 0x100003b40
            v7 = v4 + 1;
            result = 0;
            if (*(int32_t *)(v3 + 4 * v6) != v4) {
                return result;
            }
        }
        // 0x100003b80
        v8 = v6 + 1;
        v9 = v5 + 1;
    }
    int64_t v10 = v2 + 1;
    int32_t v11 = v1 + 1; // 0x100003b08
    result = 1;
    while (v2 < 3 != (2 - v1 & (int32_t)v10) < 0) {
        // 0x100003b18
        v1 = v11;
        v2 = v10;
        v3 = 16 * v2 + (int64_t)&g3;
        v4 = v7;
        v5 = 0;
        v6 = 0;
        v7 = v4;
        if (v4 < 16 != (15 - v4 & v4) < 0) {
            // 0x100003b40
            v7 = v4 + 1;
            result = 0;
            if (*(int32_t *)(v3 + 4 * v6) != v4) {
                return result;
            }
        }
        // 0x100003b80
        v8 = v6 + 1;
        v9 = v5 + 1;
        while (v6 < 3 != (2 - v5 & (int32_t)v8) < 0) {
            // 0x100003b2c
            v4 = v7;
            v5 = v9;
            v6 = v8;
            v7 = v4;
            if (v4 < 16 != (15 - v4 & v4) < 0) {
                // 0x100003b40
                v7 = v4 + 1;
                result = 0;
                if (*(int32_t *)(v3 + 4 * v6) != v4) {
                    return result;
                }
            }
            // 0x100003b80
            v8 = v6 + 1;
            v9 = v5 + 1;
        }
        // 0x100003b94
        v10 = v2 + 1;
        v11 = v1 + 1;
        result = 1;
    }
  lab_0x100003bb0:
    // 0x100003bb0
    return result;
}

// Address range: 0x100003bbc - 0x100003d00
int64_t function_100003bbc(void) {
    // 0x100003bbc
    _putchar(10);
    for (int64_t i = 0; i < 4; i++) {
        int64_t v1 = 16 * i + (int64_t)&g3; // 0x100003c14
        int64_t v2 = 0;
        if (*(int32_t *)(v1 + 4 * v2) == 0) {
            // 0x100003c84
            _printf(v2 == 3 ? " %2s \n" : " %2s ");
        } else {
            // 0x100003c30
            _printf(v2 == 3 ? " %2d \n" : " %2d ");
        }
        int64_t v3 = v2 + 1;
        while (v3 != 4) {
            // 0x100003c08
            v2 = v3;
            if (*(int32_t *)(v1 + 4 * v2) == 0) {
                // 0x100003c84
                _printf(v2 == 3 ? " %2s \n" : " %2s ");
            } else {
                // 0x100003c30
                _printf(v2 == 3 ? " %2d \n" : " %2d ");
            }
            // 0x100003cc8
            v3 = v2 + 1;
        }
    }
    // 0x100003cec
    return _putchar(10);
}

// Address range: 0x100003d00 - 0x100003d34
int64_t function_100003d00(char * a1) {
    // 0x100003d00
    int64_t v1; // 0x100003d00
    return _printf("\n%s\n", (char *)v1);
}

// Address range: 0x100003d34 - 0x100003e34
int64_t function_100003d34(void) {
    // 0x100003d34
    while (true) {
      lab_0x100003d44:;
        // 0x100003d44
        int64_t v1; // 0x100003d34
        _printf("%s", (char *)v1);
        int32_t v2 = _getchar(); // 0x100003d60
        while (_getchar() != 10) {
            // continue -> 0x100003d6c
        }
        int64_t result = 2; // 0x100003d34
        switch (v2) {
            case 27: {
                goto lab_0x100003dec;
            }
            case 100: {
                // 0x100003e24
                return 0;
            }
            case 108: {
                // 0x100003e24
                return 3;
            }
            case 114: {
                return result;
            }
            case 117: {
                // 0x100003e24
                result = 1;
                // 0x100003e24
                return result;
            }
            default: {
                goto lab_0x100003d44;
            }
        }
    }
  lab_0x100003dec:
    // 0x100003dec
    _exit(0);
    // UNREACHABLE
}

// Address range: 0x100003e34 - 0x100003e48
int64_t function_100003e34(int64_t a1) {
    // 0x100003e34
    return _getchar();
}

// Address range: 0x100003e48 - 0x100003ed0
int64_t entry_point(void) {
    // 0x100003e48
    _srand(_time(NULL));
    function_1000039dc();
    while ((int32_t)function_100003ae8() != 0) {
        // 0x100003e68
        function_1000039dc();
    }
    // 0x100003e84
    function_100003bbc();
    if ((int32_t)function_100003ae8() != 0) {
        // 0x100003eb0
        function_100003d00("You win");
        function_100003e34((int64_t)&g7);
        return 0;
    }
    function_100003d34();
    function_100003858();
    function_100003bbc();
    while ((int32_t)function_100003ae8() == 0) {
        // 0x100003ea0
        function_100003d34();
        function_100003858();
        function_100003bbc();
    }
    // 0x100003eb0
    function_100003d00("You win");
    function_100003e34((int64_t)&g7);
    return 0;
}

// Address range: 0x100003ed0 - 0x100003edc
int64_t function_100003ed0(void) {
    // 0x100003ed0
    return ___stack_chk_fail();
}

// Address range: 0x100003edc - 0x100003ee8
void function_100003edc(int32_t status) {
    // 0x100003edc
    _exit(status);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(void) {
    // 0x100003ee8
    return _getchar();
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * format, ...) {
    // 0x100003ef4
    return _printf(format);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(int32_t c) {
    // 0x100003f00
    return _putchar(c);
}

// Address range: 0x100003f0c - 0x100003f18
int32_t function_100003f0c(void) {
    // 0x100003f0c
    return _rand();
}

// Address range: 0x100003f18 - 0x100003f24
void function_100003f18(int32_t seed) {
    // 0x100003f18
    _srand(seed);
}

// Address range: 0x100003f24 - 0x100003f30
int32_t function_100003f24(int32_t * timer) {
    // 0x100003f24
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 16

`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

float *benford_distribution(void)
{
    static float prob[9];
    for (int i = 1; i < 10; i++)
        prob[i - 1] = log10f(1 + 1.0 / i);

    return prob;
}

float *get_actual_distribution(char *fn)
{
    FILE *input = fopen(fn, "r");
    if (!input)
    {
        perror("Can't open file");
        exit(EXIT_FAILURE);
    }

    int tally[9] = { 0 };
    char c;
    int total = 0;
    while ((c = getc(input)) != EOF)
    {
        /* get the first nonzero digit on the current line */
        while (c < '1' || c > '9')
            c = getc(input);

        tally[c - '1']++;
        total++;

        /* discard rest of line */
        while ((c = getc(input)) != '\n' && c != EOF)
            ;
    }
    fclose(input);

    static float freq[9];
    for (int i = 0; i < 9; i++)
        freq[i] = tally[i] / (float) total;

    return freq;
}

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf("Usage: benford <file>\n");
        return EXIT_FAILURE;
    }

    float *actual = get_actual_distribution(argv[1]);
    float *expected = benford_distribution();

    puts("digit\tactual\texpected");
    for (int i = 0; i < 9; i++)
        printf("%d\t%.3f\t%.3f\n", i + 1, actual[i], expected[i]);

    return EXIT_SUCCESS;
}
`,`#include "benfords-law.h"



undefined8 _benford_distribution(void)

{
  undefined4 uVar1;
  undefined4 local_14;
  
  for (local_14 = 1; local_14 < 10; local_14 = local_14 + 1) {
    uVar1 = _log10f((float)(1.0 / (double)(long)local_14 + 1.0));
    *(undefined4 *)((long)(local_14 + -1) * 4 + 0x100008000) = uVar1;
  }
  return 0x100008000;
}



undefined8 _get_actual_distribution(char *param_1)

{
  int iVar1;
  FILE *pFVar2;
  int local_5c;
  int local_58;
  char local_51;
  int aiStack_3c [9];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pFVar2 = _fopen(param_1,"r");
  if (pFVar2 == (FILE *)0x0) {
    _perror("Can\'t open file");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  _memset(aiStack_3c,0,0x24);
  local_58 = 0;
  while( true ) {
    iVar1 = _getc(pFVar2);
    local_51 = (char)iVar1;
    if (local_51 == -1) break;
    while (local_51 < '1' || '9' < local_51) {
      iVar1 = _getc(pFVar2);
      local_51 = (char)iVar1;
    }
    aiStack_3c[local_51 + -0x31] = aiStack_3c[local_51 + -0x31] + 1;
    local_58 = local_58 + 1;
    do {
      iVar1 = _getc(pFVar2);
    } while ((char)iVar1 != '\n' && (char)iVar1 != -1);
  }
  iVar1 = _fclose(pFVar2);
  for (local_5c = 0; local_5c < 9; local_5c = local_5c + 1) {
    *(float *)((long)local_5c * 4 + 0x100008024) = (float)aiStack_3c[local_5c] / (float)local_58;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0x100008024;
}



undefined4 entry(int param_1,long param_2)

{
  int local_34;
  undefined4 local_14;
  
  if (param_1 == 2) {
    _get_actual_distribution(*(undefined8 *)(param_2 + 8));
    _benford_distribution();
    _puts("digit\tactual\texpected");
    for (local_34 = 0; local_34 < 9; local_34 = local_34 + 1) {
      _printf("%d\t%.3f\t%.3f\n");
    }
    local_14 = 0;
  }
  else {
    _printf("Usage: benford <file>\n");
    local_14 = 1;
  }
  return local_14;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004020)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getc_100004028)((int)param_1);
  return iVar1;
}



void _log10f(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__log10f_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004038)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _perror(char *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__perror_100004040)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004050)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>

// The following function is for odd numbers ONLY
// Please use "for (unsigned i = 2, j; i*i <= n; i ++)" for even and odd numbers
unsigned sum_proper_divisors(const unsigned n) {
  unsigned sum = 1;
  for (unsigned i = 3, j; i < sqrt(n)+1; i += 2) if (n % i == 0) sum += i + (i == (j = n / i) ? 0 : j);
  return sum;
}

int main(int argc, char const *argv[]) {
  unsigned n, c;
  for (n = 1, c = 0; c < 25; n += 2) if (n < sum_proper_divisors(n)) printf("%u: %u\n", ++c, n);

  for ( ; c < 1000; n += 2) if (n < sum_proper_divisors(n)) c ++;
  printf("\nThe one thousandth abundant odd number is: %u\n", n);

  for (n = 1000000001 ;; n += 2) if (n < sum_proper_divisors(n)) break;
  printf("The first abundant odd number above one billion is: %u\n", n);

  return 0;
}
`,`#include "abundant-odd-numbers.h"



int _sum_proper_divisors(uint param_1)

{
  uint uVar1;
  double dVar2;
  double dVar3;
  uint local_18;
  uint local_c;
  int local_8;
  
  local_8 = 1;
  local_c = 3;
  while( true ) {
    dVar2 = (double)NEON_ucvtf((ulong)local_c);
    dVar3 = (double)NEON_ucvtf((ulong)param_1);
    if (SQRT(dVar3) + 1.0 <= dVar2) break;
    uVar1 = 0;
    if (local_c != 0) {
      uVar1 = param_1 / local_c;
    }
    if (param_1 == uVar1 * local_c) {
      local_18 = 0;
      if (local_c != 0) {
        local_18 = param_1 / local_c;
      }
      if (local_c == local_18) {
        local_18 = 0;
      }
      local_8 = local_8 + local_c + local_18;
    }
    local_c = local_c + 2;
  }
  return local_8;
}



undefined8 entry(void)

{
  uint uVar1;
  uint local_28;
  uint local_24;
  
  local_24 = 1;
  local_28 = 0;
  while (local_28 < 0x19) {
    uVar1 = _sum_proper_divisors(local_24);
    if (local_24 < uVar1) {
      local_28 = local_28 + 1;
      _printf("%u: %u\n");
    }
    local_24 = local_24 + 2;
  }
  while (local_28 < 1000) {
    uVar1 = _sum_proper_divisors(local_24);
    if (local_24 < uVar1) {
      local_28 = local_28 + 1;
    }
    local_24 = local_24 + 2;
  }
  _printf("\nThe one thousandth abundant odd number is: %u\n");
  for (local_24 = 0x3b9aca01; uVar1 = _sum_proper_divisors(local_24), uVar1 <= local_24;
      local_24 = local_24 + 2) {
  }
  _printf("The first abundant odd number above one billion is: %u\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define for_x for (int x = 0; x < w; x++)
#define for_y for (int y = 0; y < h; y++)
#define for_xy for_x for_y
void show(void *u, int w, int h)
{
	int (*univ)[w] = u;
	printf("\033[H");
	for_y {
		for_x printf(univ[y][x] ? "\033[07m  \033[m" : "  ");
		printf("\033[E");
	}
	fflush(stdout);
}

void evolve(void *u, int w, int h)
{
	unsigned (*univ)[w] = u;
	unsigned new[h][w];

	for_y for_x {
		int n = 0;
		for (int y1 = y - 1; y1 <= y + 1; y1++)
			for (int x1 = x - 1; x1 <= x + 1; x1++)
				if (univ[(y1 + h) % h][(x1 + w) % w])
					n++;

		if (univ[y][x]) n--;
		new[y][x] = (n == 3 || (n == 2 && univ[y][x]));
	}
	for_y for_x univ[y][x] = new[y][x];
}

void game(int w, int h)
{
	unsigned univ[h][w];
	for_xy univ[y][x] = rand() < RAND_MAX / 10 ? 1 : 0;
	while (1) {
		show(univ, w, h);
		evolve(univ, w, h);
		usleep(200000);
	}
}

int main(int c, char **v)
{
	int w = 0, h = 0;
	if (c > 1) w = atoi(v[1]);
	if (c > 2) h = atoi(v[2]);
	if (w <= 0) w = 30;
	if (h <= 0) h = 30;
	game(w, h);
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003880(void);
int64_t function_100003988(int64_t a1, int32_t a2, int32_t a3);
int64_t function_1000039fc(void);
int64_t function_100003d2c(int32_t a1, int32_t a2);
int64_t function_100003d7c(void);
int64_t function_100003f48(void);
int32_t function_100003f54(char * nptr);
int32_t function_100003f60(struct _IO_FILE * stream);
int32_t function_100003f6c(char * format, ...);
int32_t function_100003f78(void);
int32_t function_100003f84(int32_t useconds);

// --------------------- Global Variables ---------------------

char * g1 = "\x1b[H"; // 0x100003f90
int64_t g2 = 0x1b20206d37305b1b; // 0x100003f94

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___stack_chk_fail(void);
int32_t _atoi(char * a1);
int32_t _fflush(struct _IO_FILE * a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
int32_t _usleep(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003880 - 0x100003988
int64_t function_100003880(void) {
    // 0x100003880
    int64_t v1; // 0x100003880
    int32_t v2 = v1; // 0x100003894
    _printf((char *)&g1);
    int32_t v3 = -v2; // 0x1000038c4
    int64_t v4; // 0x100003974
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x10000396c
        v4 = *(int64_t *)*(int64_t *)0x100004018;
        return _fflush((struct _IO_FILE *)v4);
    }
    int32_t v5 = v1; // 0x100003890
    int32_t v6 = -v5; // 0x1000038e4
    int32_t v7 = 0;
    int64_t v8; // 0x100003904
    int32_t v9; // 0x10000390c
    int32_t v10; // 0x100003940
    if (v6 < 0 != (v6 & v5) < 0) {
        // 0x1000038f4
        v8 = (v1 & 0xffffffff) * (int64_t)v7;
        v10 = 0;
        v9 = *(int32_t *)(4 * (v8 + (int64_t)v10) + v1);
        _printf(v9 == 0 ? "  " : (char *)&g2);
        v10++;
        while (v10 - v5 < 0 != ((v10 - v5 ^ v10) & (v10 ^ v5)) < 0) {
            // 0x1000038f4
            v9 = *(int32_t *)(4 * (v8 + (int64_t)v10) + v1);
            _printf(v9 == 0 ? "  " : (char *)&g2);
            v10++;
        }
    }
    // 0x10000394c
    _printf((char *)0x100003fa2);
    int32_t v11 = v7 + 1; // 0x100003960
    while (v11 - v2 < 0 != ((v11 - v2 ^ v11) & (v11 ^ v2)) < 0) {
        // 0x1000038dc
        v7 = v11;
        if (v6 < 0 != (v6 & v5) < 0) {
            // 0x1000038f4
            v8 = (v1 & 0xffffffff) * (int64_t)v7;
            v10 = 0;
            v9 = *(int32_t *)(4 * (v8 + (int64_t)v10) + v1);
            _printf(v9 == 0 ? "  " : (char *)&g2);
            v10++;
            while (v10 - v5 < 0 != ((v10 - v5 ^ v10) & (v10 ^ v5)) < 0) {
                // 0x1000038f4
                v9 = *(int32_t *)(4 * (v8 + (int64_t)v10) + v1);
                _printf(v9 == 0 ? "  " : (char *)&g2);
                v10++;
            }
        }
        // 0x10000394c
        _printf((char *)0x100003fa2);
        v11 = v7 + 1;
    }
    // 0x10000396c
    v4 = *(int64_t *)*(int64_t *)0x100004018;
    return _fflush((struct _IO_FILE *)v4);
}

// Address range: 0x100003988 - 0x1000039fc
int64_t function_100003988(int64_t a1, int32_t a2, int32_t a3) {
    // 0x100003988
    return ___chkstk_darwin();
}

// Address range: 0x1000039fc - 0x100003d2c
int64_t function_1000039fc(void) {
    // 0x1000039fc
    int64_t v1; // 0x1000039fc
    int64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 - 96); // 0x100003a10
    int64_t v4; // 0x1000039fc
    *v3 = (int64_t)&v4 - *(int64_t *)(v2 - 112);
    *(int64_t *)(v2 - 48) = *(int64_t *)(v2 - 104);
    int32_t * v5 = (int32_t *)(v2 - 60); // 0x100003a1c
    *v5 = 0;
    int32_t * v6 = (int32_t *)(v2 - 24); // 0x100003a28
    int32_t v7 = *v6; // 0x100003a28
    int32_t v8 = -v7; // 0x100003a2c
    if (v8 < 0 != (v7 & v8) < 0) {
        int32_t * v9 = (int32_t *)(v2 - 64); // 0x100003a3c
        int32_t * v10 = (int32_t *)(v2 - 20); // 0x100003a48
        int32_t * v11 = (int32_t *)(v2 - 68);
        int32_t * v12 = (int32_t *)(v2 - 72);
        int32_t * v13 = (int32_t *)(v2 - 76);
        int64_t * v14 = (int64_t *)(v2 - 128);
        int64_t * v15 = (int64_t *)(v2 - 32);
        int32_t * v16 = (int32_t *)(v2 - 132);
        int32_t * v17 = (int32_t *)(v2 - 136);
        *v9 = 0;
        int32_t v18 = *v10; // 0x100003a48
        int32_t v19 = -v18; // 0x100003a4c
        int32_t v20; // 0x1000039fc
        int32_t v21; // 0x1000039fc
        int32_t v22; // 0x1000039fc
        int32_t v23; // 0x100003bf4
        int32_t v24; // 0x1000039fc
        int32_t v25; // 0x100003bdc
        int32_t v26; // 0x100003be0
        int32_t v27; // 0x100003be8
        int32_t v28; // 0x100003a64
        int32_t v29; // 0x100003a74
        int32_t v30; // 0x100003a78
        int32_t v31; // 0x100003a7c
        int32_t v32; // 0x100003a90
        int32_t v33; // 0x100003aa4
        int32_t v34; // 0x100003aa8
        int64_t v35; // 0x100003b54
        int64_t v36; // 0x100003b58
        int32_t v37; // 0x100003b68
        int32_t v38; // 0x100003b6c
        int64_t v39; // 0x100003ab8
        int64_t v40; // 0x100003abc
        int32_t v41; // 0x100003ac0
        int32_t v42; // 0x100003ac4
        int32_t v43; // 0x100003af0
        int32_t v44; // 0x100003b08
        int32_t v45; // 0x100003b48
        int32_t v46; // 0x100003a74
        int32_t v47; // 0x100003a78
        int32_t v48; // 0x100003a7c
        int32_t v49; // 0x100003b84
        int32_t v50; // 0x100003b34
        int32_t v51; // 0x100003aa4
        int32_t v52; // 0x100003aa8
        int64_t v53; // 0x100003c00
        int64_t v54; // 0x100003c04
        int32_t v55; // 0x100003c10
        int32_t v56; // 0x100003c1c
        int32_t v57; // 0x100003c2c
        int32_t v58; // 0x100003a48
        int64_t v59; // 0x100003bc8
        int64_t v60; // 0x100003bcc
        if (v19 < 0 != (v18 & v19) < 0) {
            *v11 = 0;
            v28 = *v5 - 1;
            *v12 = v28;
            v29 = *v5;
            v30 = v29 + 1;
            v31 = v28 - v30;
            v20 = v29;
            if (v31 == 0 || v31 < 0 != ((v31 ^ v28) & (v30 ^ v28)) < 0) {
                v32 = *v9 - 1;
                *v13 = v32;
                v33 = *v9 + 1;
                v34 = v32 - v33;
                v24 = v32;
                if (v34 == 0 || v34 < 0 != ((v34 ^ v32) & (v33 ^ v32)) < 0) {
                    v39 = *v14;
                    v40 = *v15;
                    v41 = *v12;
                    v42 = *v6;
                    v43 = *v10;
                    v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                    v22 = v24;
                    if (v44 != 0) {
                        // 0x100003b1c
                        *v11 = *v11 + 1;
                        v22 = *v13;
                    }
                    // 0x100003b30
                    v50 = v22 + 1;
                    *v13 = v50;
                    v51 = *v9 + 1;
                    v52 = v50 - v51;
                    v24 = v50;
                    while (v52 == 0 || v52 < 0 != ((v52 ^ v50) & (v51 ^ v50)) < 0) {
                        // 0x100003ab8
                        v39 = *v14;
                        v40 = *v15;
                        v41 = *v12;
                        v42 = *v6;
                        v43 = *v10;
                        v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                        v22 = v24;
                        if (v44 != 0) {
                            // 0x100003b1c
                            *v11 = *v11 + 1;
                            v22 = *v13;
                        }
                        // 0x100003b30
                        v50 = v22 + 1;
                        *v13 = v50;
                        v51 = *v9 + 1;
                        v52 = v50 - v51;
                        v24 = v50;
                    }
                }
                // 0x100003b44
                v45 = *v12 + 1;
                *v12 = v45;
                v46 = *v5;
                v47 = v46 + 1;
                v48 = v45 - v47;
                v20 = v46;
                while (v48 == 0 || v48 < 0 != ((v48 ^ v45) & (v47 ^ v45)) < 0) {
                    // 0x100003a8c
                    v32 = *v9 - 1;
                    *v13 = v32;
                    v33 = *v9 + 1;
                    v34 = v32 - v33;
                    v24 = v32;
                    if (v34 == 0 || v34 < 0 != ((v34 ^ v32) & (v33 ^ v32)) < 0) {
                        v39 = *v14;
                        v40 = *v15;
                        v41 = *v12;
                        v42 = *v6;
                        v43 = *v10;
                        v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                        v22 = v24;
                        if (v44 != 0) {
                            // 0x100003b1c
                            *v11 = *v11 + 1;
                            v22 = *v13;
                        }
                        // 0x100003b30
                        v50 = v22 + 1;
                        *v13 = v50;
                        v51 = *v9 + 1;
                        v52 = v50 - v51;
                        v24 = v50;
                        while (v52 == 0 || v52 < 0 != ((v52 ^ v50) & (v51 ^ v50)) < 0) {
                            // 0x100003ab8
                            v39 = *v14;
                            v40 = *v15;
                            v41 = *v12;
                            v42 = *v6;
                            v43 = *v10;
                            v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                            v22 = v24;
                            if (v44 != 0) {
                                // 0x100003b1c
                                *v11 = *v11 + 1;
                                v22 = *v13;
                            }
                            // 0x100003b30
                            v50 = v22 + 1;
                            *v13 = v50;
                            v51 = *v9 + 1;
                            v52 = v50 - v51;
                            v24 = v50;
                        }
                    }
                    // 0x100003b44
                    v45 = *v12 + 1;
                    *v12 = v45;
                    v46 = *v5;
                    v47 = v46 + 1;
                    v48 = v45 - v47;
                    v20 = v46;
                }
            }
            // 0x100003b54
            v35 = *v14;
            v36 = *v15;
            v37 = *v9;
            v38 = *(int32_t *)(4 * (v35 * (int64_t)v20 + (int64_t)v37) + v36);
            v21 = *v11;
            v49 = v21;
            if (v38 != 0) {
                // 0x100003b80
                v49 = v21 - 1;
                *v11 = v49;
            }
            // 0x100003b90
            *v16 = 1;
            v23 = 1;
            if (v49 != 3) {
                // 0x100003bac
                *v17 = 0;
                v27 = 0;
                if (*v11 == 2) {
                    // 0x100003bc8
                    v59 = *v14;
                    v60 = *v15;
                    v25 = *v9;
                    v26 = *(int32_t *)(4 * (v59 * (int64_t)*v5 + (int64_t)v25) + v60);
                    v27 = v26 != 0;
                    *v17 = v27;
                }
                // 0x100003bf4
                v23 = v27;
                *v16 = v23;
            }
            // 0x100003c00
            v53 = *v3;
            v54 = *(int64_t *)(v2 - 120);
            v55 = *v5;
            v56 = *v9;
            *(int32_t *)(4 * (v54 * (int64_t)v55 + (int64_t)v56) + v53) = v23;
            v57 = *v9 + 1;
            *v9 = v57;
            v58 = *v10;
            while (v57 - v58 < 0 != ((v57 - v58 ^ v57) & (v58 ^ v57)) < 0) {
                // 0x100003a5c
                *v11 = 0;
                v28 = *v5 - 1;
                *v12 = v28;
                v29 = *v5;
                v30 = v29 + 1;
                v31 = v28 - v30;
                v20 = v29;
                if (v31 == 0 || v31 < 0 != ((v31 ^ v28) & (v30 ^ v28)) < 0) {
                    v32 = *v9 - 1;
                    *v13 = v32;
                    v33 = *v9 + 1;
                    v34 = v32 - v33;
                    v24 = v32;
                    if (v34 == 0 || v34 < 0 != ((v34 ^ v32) & (v33 ^ v32)) < 0) {
                        v39 = *v14;
                        v40 = *v15;
                        v41 = *v12;
                        v42 = *v6;
                        v43 = *v10;
                        v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                        v22 = v24;
                        if (v44 != 0) {
                            // 0x100003b1c
                            *v11 = *v11 + 1;
                            v22 = *v13;
                        }
                        // 0x100003b30
                        v50 = v22 + 1;
                        *v13 = v50;
                        v51 = *v9 + 1;
                        v52 = v50 - v51;
                        v24 = v50;
                        while (v52 == 0 || v52 < 0 != ((v52 ^ v50) & (v51 ^ v50)) < 0) {
                            // 0x100003ab8
                            v39 = *v14;
                            v40 = *v15;
                            v41 = *v12;
                            v42 = *v6;
                            v43 = *v10;
                            v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                            v22 = v24;
                            if (v44 != 0) {
                                // 0x100003b1c
                                *v11 = *v11 + 1;
                                v22 = *v13;
                            }
                            // 0x100003b30
                            v50 = v22 + 1;
                            *v13 = v50;
                            v51 = *v9 + 1;
                            v52 = v50 - v51;
                            v24 = v50;
                        }
                    }
                    // 0x100003b44
                    v45 = *v12 + 1;
                    *v12 = v45;
                    v46 = *v5;
                    v47 = v46 + 1;
                    v48 = v45 - v47;
                    v20 = v46;
                    while (v48 == 0 || v48 < 0 != ((v48 ^ v45) & (v47 ^ v45)) < 0) {
                        // 0x100003a8c
                        v32 = *v9 - 1;
                        *v13 = v32;
                        v33 = *v9 + 1;
                        v34 = v32 - v33;
                        v24 = v32;
                        if (v34 == 0 || v34 < 0 != ((v34 ^ v32) & (v33 ^ v32)) < 0) {
                            v39 = *v14;
                            v40 = *v15;
                            v41 = *v12;
                            v42 = *v6;
                            v43 = *v10;
                            v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                            v22 = v24;
                            if (v44 != 0) {
                                // 0x100003b1c
                                *v11 = *v11 + 1;
                                v22 = *v13;
                            }
                            // 0x100003b30
                            v50 = v22 + 1;
                            *v13 = v50;
                            v51 = *v9 + 1;
                            v52 = v50 - v51;
                            v24 = v50;
                            while (v52 == 0 || v52 < 0 != ((v52 ^ v50) & (v51 ^ v50)) < 0) {
                                // 0x100003ab8
                                v39 = *v14;
                                v40 = *v15;
                                v41 = *v12;
                                v42 = *v6;
                                v43 = *v10;
                                v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                                v22 = v24;
                                if (v44 != 0) {
                                    // 0x100003b1c
                                    *v11 = *v11 + 1;
                                    v22 = *v13;
                                }
                                // 0x100003b30
                                v50 = v22 + 1;
                                *v13 = v50;
                                v51 = *v9 + 1;
                                v52 = v50 - v51;
                                v24 = v50;
                            }
                        }
                        // 0x100003b44
                        v45 = *v12 + 1;
                        *v12 = v45;
                        v46 = *v5;
                        v47 = v46 + 1;
                        v48 = v45 - v47;
                        v20 = v46;
                    }
                }
                // 0x100003b54
                v35 = *v14;
                v36 = *v15;
                v37 = *v9;
                v38 = *(int32_t *)(4 * (v35 * (int64_t)v20 + (int64_t)v37) + v36);
                v21 = *v11;
                v49 = v21;
                if (v38 != 0) {
                    // 0x100003b80
                    v49 = v21 - 1;
                    *v11 = v49;
                }
                // 0x100003b90
                *v16 = 1;
                v23 = 1;
                if (v49 != 3) {
                    // 0x100003bac
                    *v17 = 0;
                    v27 = 0;
                    if (*v11 == 2) {
                        // 0x100003bc8
                        v59 = *v14;
                        v60 = *v15;
                        v25 = *v9;
                        v26 = *(int32_t *)(4 * (v59 * (int64_t)*v5 + (int64_t)v25) + v60);
                        v27 = v26 != 0;
                        *v17 = v27;
                    }
                    // 0x100003bf4
                    v23 = v27;
                    *v16 = v23;
                }
                // 0x100003c00
                v53 = *v3;
                v54 = *(int64_t *)(v2 - 120);
                v55 = *v5;
                v56 = *v9;
                *(int32_t *)(4 * (v54 * (int64_t)v55 + (int64_t)v56) + v53) = v23;
                v57 = *v9 + 1;
                *v9 = v57;
                v58 = *v10;
            }
        }
        int32_t v61 = *v5 + 1; // 0x100003c40
        *v5 = v61;
        int32_t v62 = *v6; // 0x100003a28
        while (v61 - v62 < 0 != ((v61 - v62 ^ v61) & (v62 ^ v61)) < 0) {
            // 0x100003a3c
            *v9 = 0;
            v18 = *v10;
            v19 = -v18;
            if (v19 < 0 != (v18 & v19) < 0) {
                *v11 = 0;
                v28 = *v5 - 1;
                *v12 = v28;
                v29 = *v5;
                v30 = v29 + 1;
                v31 = v28 - v30;
                v20 = v29;
                if (v31 == 0 || v31 < 0 != ((v31 ^ v28) & (v30 ^ v28)) < 0) {
                    v32 = *v9 - 1;
                    *v13 = v32;
                    v33 = *v9 + 1;
                    v34 = v32 - v33;
                    v24 = v32;
                    if (v34 == 0 || v34 < 0 != ((v34 ^ v32) & (v33 ^ v32)) < 0) {
                        v39 = *v14;
                        v40 = *v15;
                        v41 = *v12;
                        v42 = *v6;
                        v43 = *v10;
                        v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                        v22 = v24;
                        if (v44 != 0) {
                            // 0x100003b1c
                            *v11 = *v11 + 1;
                            v22 = *v13;
                        }
                        // 0x100003b30
                        v50 = v22 + 1;
                        *v13 = v50;
                        v51 = *v9 + 1;
                        v52 = v50 - v51;
                        v24 = v50;
                        while (v52 == 0 || v52 < 0 != ((v52 ^ v50) & (v51 ^ v50)) < 0) {
                            // 0x100003ab8
                            v39 = *v14;
                            v40 = *v15;
                            v41 = *v12;
                            v42 = *v6;
                            v43 = *v10;
                            v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                            v22 = v24;
                            if (v44 != 0) {
                                // 0x100003b1c
                                *v11 = *v11 + 1;
                                v22 = *v13;
                            }
                            // 0x100003b30
                            v50 = v22 + 1;
                            *v13 = v50;
                            v51 = *v9 + 1;
                            v52 = v50 - v51;
                            v24 = v50;
                        }
                    }
                    // 0x100003b44
                    v45 = *v12 + 1;
                    *v12 = v45;
                    v46 = *v5;
                    v47 = v46 + 1;
                    v48 = v45 - v47;
                    v20 = v46;
                    while (v48 == 0 || v48 < 0 != ((v48 ^ v45) & (v47 ^ v45)) < 0) {
                        // 0x100003a8c
                        v32 = *v9 - 1;
                        *v13 = v32;
                        v33 = *v9 + 1;
                        v34 = v32 - v33;
                        v24 = v32;
                        if (v34 == 0 || v34 < 0 != ((v34 ^ v32) & (v33 ^ v32)) < 0) {
                            v39 = *v14;
                            v40 = *v15;
                            v41 = *v12;
                            v42 = *v6;
                            v43 = *v10;
                            v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                            v22 = v24;
                            if (v44 != 0) {
                                // 0x100003b1c
                                *v11 = *v11 + 1;
                                v22 = *v13;
                            }
                            // 0x100003b30
                            v50 = v22 + 1;
                            *v13 = v50;
                            v51 = *v9 + 1;
                            v52 = v50 - v51;
                            v24 = v50;
                            while (v52 == 0 || v52 < 0 != ((v52 ^ v50) & (v51 ^ v50)) < 0) {
                                // 0x100003ab8
                                v39 = *v14;
                                v40 = *v15;
                                v41 = *v12;
                                v42 = *v6;
                                v43 = *v10;
                                v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                                v22 = v24;
                                if (v44 != 0) {
                                    // 0x100003b1c
                                    *v11 = *v11 + 1;
                                    v22 = *v13;
                                }
                                // 0x100003b30
                                v50 = v22 + 1;
                                *v13 = v50;
                                v51 = *v9 + 1;
                                v52 = v50 - v51;
                                v24 = v50;
                            }
                        }
                        // 0x100003b44
                        v45 = *v12 + 1;
                        *v12 = v45;
                        v46 = *v5;
                        v47 = v46 + 1;
                        v48 = v45 - v47;
                        v20 = v46;
                    }
                }
                // 0x100003b54
                v35 = *v14;
                v36 = *v15;
                v37 = *v9;
                v38 = *(int32_t *)(4 * (v35 * (int64_t)v20 + (int64_t)v37) + v36);
                v21 = *v11;
                v49 = v21;
                if (v38 != 0) {
                    // 0x100003b80
                    v49 = v21 - 1;
                    *v11 = v49;
                }
                // 0x100003b90
                *v16 = 1;
                v23 = 1;
                if (v49 != 3) {
                    // 0x100003bac
                    *v17 = 0;
                    v27 = 0;
                    if (*v11 == 2) {
                        // 0x100003bc8
                        v59 = *v14;
                        v60 = *v15;
                        v25 = *v9;
                        v26 = *(int32_t *)(4 * (v59 * (int64_t)*v5 + (int64_t)v25) + v60);
                        v27 = v26 != 0;
                        *v17 = v27;
                    }
                    // 0x100003bf4
                    v23 = v27;
                    *v16 = v23;
                }
                // 0x100003c00
                v53 = *v3;
                v54 = *(int64_t *)(v2 - 120);
                v55 = *v5;
                v56 = *v9;
                *(int32_t *)(4 * (v54 * (int64_t)v55 + (int64_t)v56) + v53) = v23;
                v57 = *v9 + 1;
                *v9 = v57;
                v58 = *v10;
                while (v57 - v58 < 0 != ((v57 - v58 ^ v57) & (v58 ^ v57)) < 0) {
                    // 0x100003a5c
                    *v11 = 0;
                    v28 = *v5 - 1;
                    *v12 = v28;
                    v29 = *v5;
                    v30 = v29 + 1;
                    v31 = v28 - v30;
                    v20 = v29;
                    if (v31 == 0 || v31 < 0 != ((v31 ^ v28) & (v30 ^ v28)) < 0) {
                        v32 = *v9 - 1;
                        *v13 = v32;
                        v33 = *v9 + 1;
                        v34 = v32 - v33;
                        v24 = v32;
                        if (v34 == 0 || v34 < 0 != ((v34 ^ v32) & (v33 ^ v32)) < 0) {
                            v39 = *v14;
                            v40 = *v15;
                            v41 = *v12;
                            v42 = *v6;
                            v43 = *v10;
                            v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                            v22 = v24;
                            if (v44 != 0) {
                                // 0x100003b1c
                                *v11 = *v11 + 1;
                                v22 = *v13;
                            }
                            // 0x100003b30
                            v50 = v22 + 1;
                            *v13 = v50;
                            v51 = *v9 + 1;
                            v52 = v50 - v51;
                            v24 = v50;
                            while (v52 == 0 || v52 < 0 != ((v52 ^ v50) & (v51 ^ v50)) < 0) {
                                // 0x100003ab8
                                v39 = *v14;
                                v40 = *v15;
                                v41 = *v12;
                                v42 = *v6;
                                v43 = *v10;
                                v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                                v22 = v24;
                                if (v44 != 0) {
                                    // 0x100003b1c
                                    *v11 = *v11 + 1;
                                    v22 = *v13;
                                }
                                // 0x100003b30
                                v50 = v22 + 1;
                                *v13 = v50;
                                v51 = *v9 + 1;
                                v52 = v50 - v51;
                                v24 = v50;
                            }
                        }
                        // 0x100003b44
                        v45 = *v12 + 1;
                        *v12 = v45;
                        v46 = *v5;
                        v47 = v46 + 1;
                        v48 = v45 - v47;
                        v20 = v46;
                        while (v48 == 0 || v48 < 0 != ((v48 ^ v45) & (v47 ^ v45)) < 0) {
                            // 0x100003a8c
                            v32 = *v9 - 1;
                            *v13 = v32;
                            v33 = *v9 + 1;
                            v34 = v32 - v33;
                            v24 = v32;
                            if (v34 == 0 || v34 < 0 != ((v34 ^ v32) & (v33 ^ v32)) < 0) {
                                v39 = *v14;
                                v40 = *v15;
                                v41 = *v12;
                                v42 = *v6;
                                v43 = *v10;
                                v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                                v22 = v24;
                                if (v44 != 0) {
                                    // 0x100003b1c
                                    *v11 = *v11 + 1;
                                    v22 = *v13;
                                }
                                // 0x100003b30
                                v50 = v22 + 1;
                                *v13 = v50;
                                v51 = *v9 + 1;
                                v52 = v50 - v51;
                                v24 = v50;
                                while (v52 == 0 || v52 < 0 != ((v52 ^ v50) & (v51 ^ v50)) < 0) {
                                    // 0x100003ab8
                                    v39 = *v14;
                                    v40 = *v15;
                                    v41 = *v12;
                                    v42 = *v6;
                                    v43 = *v10;
                                    v44 = *(int32_t *)(4 * v39 * (int64_t)((v42 + v41) % v42) + v40 + (int64_t)(4 * ((v43 + v24) % v43)));
                                    v22 = v24;
                                    if (v44 != 0) {
                                        // 0x100003b1c
                                        *v11 = *v11 + 1;
                                        v22 = *v13;
                                    }
                                    // 0x100003b30
                                    v50 = v22 + 1;
                                    *v13 = v50;
                                    v51 = *v9 + 1;
                                    v52 = v50 - v51;
                                    v24 = v50;
                                }
                            }
                            // 0x100003b44
                            v45 = *v12 + 1;
                            *v12 = v45;
                            v46 = *v5;
                            v47 = v46 + 1;
                            v48 = v45 - v47;
                            v20 = v46;
                        }
                    }
                    // 0x100003b54
                    v35 = *v14;
                    v36 = *v15;
                    v37 = *v9;
                    v38 = *(int32_t *)(4 * (v35 * (int64_t)v20 + (int64_t)v37) + v36);
                    v21 = *v11;
                    v49 = v21;
                    if (v38 != 0) {
                        // 0x100003b80
                        v49 = v21 - 1;
                        *v11 = v49;
                    }
                    // 0x100003b90
                    *v16 = 1;
                    v23 = 1;
                    if (v49 != 3) {
                        // 0x100003bac
                        *v17 = 0;
                        v27 = 0;
                        if (*v11 == 2) {
                            // 0x100003bc8
                            v59 = *v14;
                            v60 = *v15;
                            v25 = *v9;
                            v26 = *(int32_t *)(4 * (v59 * (int64_t)*v5 + (int64_t)v25) + v60);
                            v27 = v26 != 0;
                            *v17 = v27;
                        }
                        // 0x100003bf4
                        v23 = v27;
                        *v16 = v23;
                    }
                    // 0x100003c00
                    v53 = *v3;
                    v54 = *(int64_t *)(v2 - 120);
                    v55 = *v5;
                    v56 = *v9;
                    *(int32_t *)(4 * (v54 * (int64_t)v55 + (int64_t)v56) + v53) = v23;
                    v57 = *v9 + 1;
                    *v9 = v57;
                    v58 = *v10;
                }
            }
            // 0x100003c3c
            v61 = *v5 + 1;
            *v5 = v61;
            v62 = *v6;
        }
    }
    int32_t * v63 = (int32_t *)(v2 - 80); // 0x100003c4c
    *v63 = 0;
    int32_t v64 = *v6; // 0x100003c58
    int32_t v65 = -v64; // 0x100003c5c
    if (v65 < 0 != (v64 & v65) < 0) {
        int32_t * v66 = (int32_t *)(v2 - 84); // 0x100003c6c
        int32_t * v67 = (int32_t *)(v2 - 20); // 0x100003c78
        *v66 = 0;
        int32_t v68 = *v67; // 0x100003c78
        int32_t v69 = -v68; // 0x100003c7c
        int64_t v70; // 0x100003c98
        int64_t v71; // 0x100003ca8
        int32_t v72; // 0x100003ca8
        int64_t v73; // 0x100003cac
        int32_t v74; // 0x100003ccc
        int32_t v75; // 0x100003c78
        int32_t v76; // 0x100003c7c
        if (v69 < 0 != (v68 & v69) < 0) {
            v70 = (int64_t)*v63;
            v71 = 0;
            v72 = *(int32_t *)(*v3 + v71 + 4 * *(int64_t *)(v2 - 120) * v70);
            v73 = *(int64_t *)(v2 - 32);
            *(int32_t *)(4 * *(int64_t *)(v2 - 128) * v70 + v71 + v73) = v72;
            v74 = *v66 + 1;
            *v66 = v74;
            v75 = *v67;
            v76 = v74 - v75;
            while (v76 < 0 != ((v76 ^ v74) & (v75 ^ v74)) < 0) {
                // 0x100003c8c
                v70 = (int64_t)*v63;
                v71 = 4 * (int64_t)v74;
                v72 = *(int32_t *)(*v3 + v71 + 4 * *(int64_t *)(v2 - 120) * v70);
                v73 = *(int64_t *)(v2 - 32);
                *(int32_t *)(4 * *(int64_t *)(v2 - 128) * v70 + v71 + v73) = v72;
                v74 = *v66 + 1;
                *v66 = v74;
                v75 = *v67;
                v76 = v74 - v75;
            }
        }
        int32_t v77 = *v63 + 1; // 0x100003ce0
        *v63 = v77;
        int32_t v78 = *v6; // 0x100003c58
        while (v77 - v78 < 0 != ((v77 - v78 ^ v77) & (v78 ^ v77)) < 0) {
            // 0x100003c6c
            *v66 = 0;
            v68 = *v67;
            v69 = -v68;
            if (v69 < 0 != (v68 & v69) < 0) {
                v70 = (int64_t)*v63;
                v71 = 0;
                v72 = *(int32_t *)(*v3 + v71 + 4 * *(int64_t *)(v2 - 120) * v70);
                v73 = *(int64_t *)(v2 - 32);
                *(int32_t *)(4 * *(int64_t *)(v2 - 128) * v70 + v71 + v73) = v72;
                v74 = *v66 + 1;
                *v66 = v74;
                v75 = *v67;
                v76 = v74 - v75;
                while (v76 < 0 != ((v76 ^ v74) & (v75 ^ v74)) < 0) {
                    // 0x100003c8c
                    v70 = (int64_t)*v63;
                    v71 = 4 * (int64_t)v74;
                    v72 = *(int32_t *)(*v3 + v71 + 4 * *(int64_t *)(v2 - 120) * v70);
                    v73 = *(int64_t *)(v2 - 32);
                    *(int32_t *)(4 * *(int64_t *)(v2 - 128) * v70 + v71 + v73) = v72;
                    v74 = *v66 + 1;
                    *v66 = v74;
                    v75 = *v67;
                    v76 = v74 - v75;
                }
            }
            // 0x100003cdc
            v77 = *v63 + 1;
            *v63 = v77;
            v78 = *v6;
        }
    }
    // 0x100003cec
    *(int64_t *)(v2 - 144) = *(int64_t *)(v2 - 40);
    int64_t result; // 0x1000039fc
    if (*(int64_t *)*(int64_t *)0x100004010 != *(int64_t *)(v2 - 8)) {
        // 0x100003d14
        result = ___stack_chk_fail();
    }
    // 0x100003d18
    return result;
}

// Address range: 0x100003d2c - 0x100003d7c
int64_t function_100003d2c(int32_t a1, int32_t a2) {
    // 0x100003d2c
    return ___chkstk_darwin();
}

// Address range: 0x100003d7c - 0x100003e7c
int64_t function_100003d7c(void) {
    // 0x100003d7c
    int64_t v1; // 0x100003d7c
    int64_t v2 = v1;
    int64_t * v3 = (int64_t *)(v2 - 48); // 0x100003d90
    int64_t v4; // 0x100003d7c
    *v3 = (int64_t)&v4 - *(int64_t *)(v2 - 64);
    *(int64_t *)(v2 - 24) = *(int64_t *)(v2 - 56);
    int32_t * v5 = (int32_t *)(v2 - 36); // 0x100003d9c
    *v5 = 0;
    int32_t * v6 = (int32_t *)(v2 - 4); // 0x100003da8
    int32_t v7 = *v6; // 0x100003da8
    int32_t v8 = -v7; // 0x100003dac
    int32_t * v9; // 0x100003d7c
    if (v8 < 0 == (v7 & v8) < 0) {
        // 0x100003d7c
        v9 = (int32_t *)(v2 - 8);
    } else {
        int32_t * v10 = (int32_t *)(v2 - 40); // 0x100003dbc
        int32_t * v11 = (int32_t *)(v2 - 8);
        *v10 = 0;
        int32_t v12 = *v11; // 0x100003dc8
        int32_t v13 = -v12; // 0x100003dcc
        int32_t v14; // 0x100003ddc
        int64_t v15; // 0x100003de0
        int64_t v16; // 0x100003de4
        int32_t v17; // 0x100003e08
        int32_t v18; // 0x100003e14
        int32_t v19; // 0x100003e24
        int32_t v20; // 0x100003dc8
        if (v13 < 0 != (v12 & v13) < 0) {
            v14 = _rand();
            v15 = *(int64_t *)(v2 - 72);
            v16 = *v3;
            v17 = *v10;
            v18 = *v5;
            *(int32_t *)(4 * (v15 * (int64_t)v17 + (int64_t)v18) + v16) = (int32_t)(v14 < 0xccccccc != (0xccccccb - v14 & v14) < 0);
            v19 = *v10 + 1;
            *v10 = v19;
            v20 = *v11;
            while (v19 - v20 < 0 != ((v19 - v20 ^ v19) & (v20 ^ v19)) < 0) {
                // 0x100003ddc
                v14 = _rand();
                v15 = *(int64_t *)(v2 - 72);
                v16 = *v3;
                v17 = *v10;
                v18 = *v5;
                *(int32_t *)(4 * (v15 * (int64_t)v17 + (int64_t)v18) + v16) = (int32_t)(v14 < 0xccccccc != (0xccccccb - v14 & v14) < 0);
                v19 = *v10 + 1;
                *v10 = v19;
                v20 = *v11;
            }
        }
        int32_t v21 = *v5 + 1; // 0x100003e38
        *v5 = v21;
        int32_t v22 = *v6; // 0x100003da8
        int32_t v23 = v21 - v22; // 0x100003dac
        v9 = v11;
        while (v23 < 0 != ((v23 ^ v21) & (v22 ^ v21)) < 0) {
            // 0x100003dbc
            *v10 = 0;
            v12 = *v11;
            v13 = -v12;
            if (v13 < 0 != (v12 & v13) < 0) {
                v14 = _rand();
                v15 = *(int64_t *)(v2 - 72);
                v16 = *v3;
                v17 = *v10;
                v18 = *v5;
                *(int32_t *)(4 * (v15 * (int64_t)v17 + (int64_t)v18) + v16) = (int32_t)(v14 < 0xccccccc != (0xccccccb - v14 & v14) < 0);
                v19 = *v10 + 1;
                *v10 = v19;
                v20 = *v11;
                while (v19 - v20 < 0 != ((v19 - v20 ^ v19) & (v20 ^ v19)) < 0) {
                    // 0x100003ddc
                    v14 = _rand();
                    v15 = *(int64_t *)(v2 - 72);
                    v16 = *v3;
                    v17 = *v10;
                    v18 = *v5;
                    *(int32_t *)(4 * (v15 * (int64_t)v17 + (int64_t)v18) + v16) = (int32_t)(v14 < 0xccccccc != (0xccccccb - v14 & v14) < 0);
                    v19 = *v10 + 1;
                    *v10 = v19;
                    v20 = *v11;
                }
            }
            // 0x100003e34
            v21 = *v5 + 1;
            *v5 = v21;
            v22 = *v6;
            v23 = v21 - v22;
            v9 = v11;
        }
    }
    // 0x100003e48
    while (true) {
        // 0x100003e48
        function_100003880();
        function_100003988(*v3, *v6, *v9);
        _usleep(0x30d40);
    }
}

// Address range: 0x100003e7c - 0x100003f48
int64_t entry_point(void) {
    // 0x100003e7c
    int64_t v1; // 0x100003e7c
    int32_t v2 = v1; // 0x100003e8c
    int32_t v3 = v2 - 1; // 0x100003ea0
    int32_t v4 = 0; // 0x100003ea8
    if (v3 != 0 && v3 < 0 == (v2 & -v2) < 0) {
        // 0x100003eb0
        v4 = _atoi((char *)*(int64_t *)(v1 + 8));
    }
    int32_t v5 = v4;
    int32_t v6 = v2 - 2; // 0x100003ec8
    int32_t v7; // 0x100003e7c
    if (v6 == 0 || v6 < 0 != (1 - v2 & v2) < 0) {
        // 0x100003eec
        v7 = v5 < 1 ? 30 : v5;
    } else {
        int32_t v8 = _atoi((char *)*(int64_t *)(v1 + 16)); // 0x100003ee0
        int32_t v9 = v5 < 1 ? 30 : v5;
        v7 = v9;
        if (v8 >= 1) {
            function_100003d2c(v9, v8);
            return 0;
        }
    }
    function_100003d2c(v7, 30);
    return 0;
}

// Address range: 0x100003f48 - 0x100003f54
int64_t function_100003f48(void) {
    // 0x100003f48
    return ___stack_chk_fail();
}

// Address range: 0x100003f54 - 0x100003f60
int32_t function_100003f54(char * nptr) {
    // 0x100003f54
    return _atoi(nptr);
}

// Address range: 0x100003f60 - 0x100003f6c
int32_t function_100003f60(struct _IO_FILE * stream) {
    // 0x100003f60
    return _fflush(stream);
}

// Address range: 0x100003f6c - 0x100003f78
int32_t function_100003f6c(char * format, ...) {
    // 0x100003f6c
    return _printf(format);
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(void) {
    // 0x100003f78
    return _rand();
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(int32_t useconds) {
    // 0x100003f84
    return _usleep(useconds);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`#include <stdio.h>

// Euclid's algorithm
int GCD(int x, int y)
{
    if (y == 0)
        return x;
    return GCD(y, x % y);
}

int main()
{
    int a, b;
    printf("Input two numbers:\n");
    scanf("%d %d", &a, &b);
    printf("Greatest common divisor: %d\n", GCD(a, b));
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003e84(void);
int32_t function_100003f58(char * format, ...);
int32_t function_100003f64(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003e84 - 0x100003eec
int64_t function_100003e84(void) {
    // 0x100003e84
    int64_t v1; // 0x100003e84
    int64_t v2; // 0x100003e84
    if ((int32_t)v2 != 0) {
        // 0x100003eb8
        v1 = function_100003e84();
    }
    // 0x100003edc
    return v1 & 0xffffffff;
}

// Address range: 0x100003eec - 0x100003f58
int64_t entry_point(void) {
    // 0x100003eec
    _printf("Input two numbers:\n");
    int64_t v1; // 0x100003eec
    _scanf("%d %d", (int64_t *)v1, (int64_t *)v1);
    function_100003e84();
    int32_t v2; // 0x100003eec
    _printf("Greatest common divisor: %d\n", (int64_t)v2);
    return 0;
}

// Address range: 0x100003f58 - 0x100003f64
int32_t function_100003f58(char * format, ...) {
    // 0x100003f58
    return _printf(format);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: protected
#include<stdio.h>

/* This program implements the Fractional Knapsack Problem using a greedy algorithm. */

#define MAX_SIZE 100

typedef struct{
    int value;
    int weight;
    float ratio;
} Item;

int compare(Item a, Item b) {
    return a.ratio < b.ratio;
}

int main() {
    int n, W;
    Item items[MAX_SIZE];
    
    printf("Enter the number of items: ");
    scanf("%d", &n);
    
    printf("Enter the capacity of the knapsack: ");
    scanf("%d", &W);
    
    printf("Enter the value and weight of each item:\n");
    for(int i = 0; i < n; i++) {
        scanf("%d%d", &items[i].value, &items[i].weight);
        items[i].ratio = (float)items[i].value / items[i].weight;
    }
    
    // sort the items in descending order of their ratio
    qsort(items, n, sizeof(Item), compare);
    
    int i = 0;
    float max_value = 0.0;
    
    while(W > 0 && i < n) {
        if(items[i].weight <= W) {
            // take the entire item as it can be accommodated in the knapsack
            max_value += items[i].value;
            W -= items[i].weight;
        } else {
            // take a fraction of the item that can fit in the knapsack
            max_value += W * items[i].ratio;
            W = 0;
        }
        i++;
    }
    
    printf("Maximum possible value that can be obtained = %0.2f\n", max_value);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __cdecl compare(const void *, const void *); // idb
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);


//----- (0000000140001606) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _DWORD Base[24]; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v5[1116]; // [rsp+80h] [rbp+0h] BYREF
  int v6; // [rsp+4DCh] [rbp+45Ch] BYREF
  int NumOfElements; // [rsp+4E0h] [rbp+460h] BYREF
  float NumOfElements_4; // [rsp+4E4h] [rbp+464h]
  int v9; // [rsp+4E8h] [rbp+468h]
  int i; // [rsp+4ECh] [rbp+46Ch]

  _main(argc, argv, envp);
  printf("Enter the number of items: ");
  scanf("%d", &NumOfElements);
  printf("Enter the capacity of the knapsack: ");
  scanf("%d", &v6);
  printf("Enter the value and weight of each item:\n");
  for ( i = 0; i < NumOfElements; ++i )
  {
    scanf("%d%d", &Base[3 * i], &Base[3 * i + 1]);
    *(float *)&v5[12 * i - 88] = (float)*(int *)&v5[12 * i - 96] / (float)*(int *)&v5[12 * i - 92];
  }
  qsort(Base, (unsigned int)NumOfElements, 0xCui64, compare);
  v9 = 0;
  NumOfElements_4 = 0.0;
  while ( v6 > 0 && v9 < NumOfElements )
  {
    if ( *(_DWORD *)&v5[12 * v9 - 92] > v6 )
    {
      NumOfElements_4 = (float)(*(float *)&v5[12 * v9 - 88] * (float)v6) + NumOfElements_4;
      v6 = 0;
    }
    else
    {
      NumOfElements_4 = (float)*(int *)&v5[12 * v9 - 96] + NumOfElements_4;
      v6 -= *(_DWORD *)&v5[12 * v9 - 92];
    }
    ++v9;
  }
  printf("Maximum possible value that can be obtained = %0.2f\n", NumOfElements_4);
  return 0;
}
// 1400019E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>

int main()
{
	unsigned int i = 0;
	while (++i) printf("%u\n", i);

	return 0;
}
`,`#include "integer-sequence-1.h"



undefined8 entry(void)

{
  int local_18;
  
  local_18 = 0;
  while (local_18 = local_18 + 1, local_18 != 0) {
    _printf("%u\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`/*

  David Lambert, 2010-Dec-09

  filter producing morse beep commands.

  build:
    make morse

  use:
    $ echo tie a. | ./morse
    beep -n -f 440 -l 300 -D 100 -n -D 200 -n -f 440 -l 100 -D 100 -n -f 440 -l 100 -D 100 -n -D 200 -n -f 440 -l 100 -D 100 -n -D 200 -n -D 400 -n -f 440 -l 100 -D 100 -n -f 440 -l 300 -D 100 -n -D 200 -n -f 440 -l 100 -D 100 -n -f 440 -l 300 -D 100 -n -f 440 -l 100 -D 100 -n -f 440 -l 300 -D 100 -n -f 440 -l 100 -D 100 -n -f 440 -l 300 -D 100 -n -D 200 -n -D 400 -n -D 400

  bugs:
    What is the space between letter and punctuation?
    Demo truncates input lines at 71 characters or so.

 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BIND(A,L,H) ((L)<(A)?(A)<(H)?(A):(H):(L))
/*
  BIND(-1,0,9) is 0
  BIND( 7,0,9) is 7
  BIND(77,0,9) is 9
*/

char
  /* beep args for */
  /* dit  dah     extra space */
  dih[50],dah[50],medium[30],word[30],
  *dd[2] = {dih,dah};
const char
  *ascii = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,?'!/()&:;=+-_\"$@",
  *itu[] = {
     "13","3111","3131","311","1","1131","331","1111","11","1333","313","1311","33","31","333","1331","3313","131","111","3","113","1113","133","3113","3133","3311","33333","13333","11333","11133","11113","11111","31111","33111","33311","33331","131313","331133","113311","133331","313133","31131","31331","313313","13111","333111","313131","31113","13131","311113","113313","131131","1113113","133131"
  };

void append(char*s,const char*morse) {
  for (; *morse; ++morse)
    strcat(s,dd['3'==*morse]);
  strcat(s,medium);
}

char*translate(const char*i,char*o) {
  const char*pc;
  sprintf(o,"beep");
  for (; *i; ++i)
    if (NULL == (pc = strchr(ascii,toupper(*i))))
      strcat(o,word);
    else
      append(o,itu[pc-ascii]);
  strcat(o,word);
  return o;
}

int main(int ac,char*av[]) {
  char
    sin[73],sout[100000];
  int
    dit = 100;
  if (1 < ac) {
    if (strlen(av[1]) != strspn(av[1],"0123456789"))
      return 0*fprintf(stderr,"use: %s [duration]   dit in ms, default %d\n",*av,dit);
    dit = BIND(atoi(av[1]),1,1000);
  }
  sprintf(dah," -n -f 440 -l %d -D %d",3*dit,dit);
  sprintf(dih," -n -f 440 -l %d -D %d",dit,dit);
  sprintf(medium," -n -D %d",(3-1)*dit);
  sprintf(word," -n -D %d",(7-(3-1)-1)*dit);
  while (NULL != fgets(sin,72,stdin))
    puts(translate(sin,sout));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038f0(void);
int64_t function_100003988(void);
int64_t function_100003aa4(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003d64(int64_t a1, int64_t a2, int64_t a3, char * a4);
int64_t function_100003d70(int64_t a1);
int64_t function_100003d7c(int64_t a1, int64_t a2, int64_t a3);
int32_t function_100003d88(char * nptr);
char * function_100003d94(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_100003da0(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003dac(char * s);
char * function_100003db8(char * s, int32_t c);
int32_t function_100003dc4(char * s);
int32_t function_100003dd0(char * s, char * accept);
int32_t function_100003ddc(int32_t c);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000000081fa; // 0x100008000
char * g2 = "\xe8="; // 0x100008010
int64_t g3 = 0x100000cfeedfacf; // 0x1000081c8
int64_t g4 = 0; // 0x1000081fa
int64_t g5 = 0x1900000000; // 0x10000822c
int64_t g6 = 0x4000000000010000; // 0x10000824a

// ------- Dynamically Linked Functions Without Header --------

int64_t ___chkstk_darwin(void);
int64_t ___sprintf_chk(int64_t a1, int64_t a2, int64_t a3, char * a4);
int64_t ___stack_chk_fail(int64_t a1);
int64_t ___strcat_chk(int64_t a1, int64_t a2, int64_t a3);
int32_t _atoi(char * a1);
char * _fgets(char * a1, int32_t a2, struct _IO_FILE * a3);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _puts(char * a1);
char * _strchr(char * a1, int32_t a2);
int32_t _strlen(char * a1);
int32_t _strspn(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x1000038f0 - 0x100003988
int64_t function_1000038f0(void) {
    // 0x1000038f0
    int64_t v1; // 0x1000038f0
    char v2 = *(char *)v1; // 0x10000390c
    if (v2 == 0) {
        // 0x100003968
        return ___strcat_chk(v1, (int64_t)&g5, -1);
    }
    int64_t v3 = *(int64_t *)(8 * (int64_t)(v2 == 51) + (int64_t)&g1); // 0x100003948
    ___strcat_chk(v1, v3, -1);
    int64_t v4; // 0x1000038f0
    int64_t v5 = v4 + 1; // 0x10000395c
    char v6 = *(char *)v5; // 0x10000390c
    while (v6 != 0) {
        // 0x100003920
        v3 = *(int64_t *)(8 * (int64_t)(v6 == 51) + (int64_t)&g1);
        ___strcat_chk(v1, v3, -1);
        v5++;
        v6 = *(char *)v5;
    }
    // 0x100003968
    return ___strcat_chk(v1, (int64_t)&g5, -1);
}

// Address range: 0x100003988 - 0x100003a84
int64_t function_100003988(void) {
    // 0x100003988
    int64_t result; // 0x100003988
    ___sprintf_chk(result, 0, -1, "beep");
    char c = *(char *)result; // 0x1000039bc
    if (c == 0) {
        // 0x100003a60
        ___strcat_chk(result, (int64_t)&g6, -1);
        return result;
    }
    if (_strchr(g2, _toupper((int32_t)c)) == NULL) {
        // 0x100003a0c
        ___strcat_chk(result, (int64_t)&g6, -1);
    } else {
        // 0x100003a24
        function_1000038f0();
    }
    // 0x100003a50
    int64_t v1; // 0x100003988
    int64_t v2 = v1 + 1; // 0x100003a54
    char c2 = *(char *)v2; // 0x1000039bc
    while (c2 != 0) {
        // 0x1000039d0
        if (_strchr(g2, _toupper((int32_t)c2)) == NULL) {
            // 0x100003a0c
            ___strcat_chk(result, (int64_t)&g6, -1);
        } else {
            // 0x100003a24
            function_1000038f0();
        }
        // 0x100003a50
        v2++;
        c2 = *(char *)v2;
    }
    // 0x100003a60
    ___strcat_chk(result, (int64_t)&g6, -1);
    return result;
}

// Address range: 0x100003a84 - 0x100003aa4
int64_t entry_point(void) {
    // 0x100003a84
    return ___chkstk_darwin();
}

// Address range: 0x100003aa4 - 0x100003d64
int64_t function_100003aa4(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003aa4
    int64_t v1; // 0x100003aa4
    int64_t * v2 = (int64_t *)(v1 - 24); // 0x100003ab8
    *v2 = *(int64_t *)*(int64_t *)0x100004018;
    int32_t v3 = v1; // 0x100003ac0
    int32_t v4 = 1 - v3; // 0x100003ad8
    int64_t v5; // 0x100003aa4
    if (v4 < 0 == (v4 & v3) < 0) {
        goto lab_0x100003be8;
    } else {
        int64_t * v6 = (int64_t *)(v1 + 8); // 0x100003aec
        if (_strlen((char *)*v6) == _strspn((char *)*v6, "0123456789")) {
            int32_t v7 = _atoi((char *)*v6); // 0x100003b70
            int32_t v8 = 1 - v7; // 0x100003b78
            if (v8 < 0 != (v8 & v7) < 0) {
                int32_t v9 = _atoi((char *)*v6); // 0x100003b90
                if (v9 < 1000 != (999 - v9 & v9) < 0) {
                    // 0x100003ba4
                    _atoi((char *)*v6);
                }
            }
            goto lab_0x100003be8;
        } else {
            int64_t v10 = *(int64_t *)*(int64_t *)0x100004020; // 0x100003b2c
            v5 = _fprintf((struct _IO_FILE *)v10, "use: %s [duration]   dit in ms, default %d\n", (char *)v1, v1);
            goto lab_0x100003d20;
        }
    }
  lab_0x100003be8:
    // 0x100003be8
    ___sprintf_chk((int64_t)&g3, 0, 50, " -n -f 440 -l %d -D %d");
    ___sprintf_chk((int64_t)&g4, 0, 50, " -n -f 440 -l %d -D %d");
    ___sprintf_chk((int64_t)&g5, 0, 30, " -n -D %d");
    ___sprintf_chk((int64_t)&g6, 0, 30, " -n -D %d");
    char * v11 = (char *)(v1 - 97); // 0x100003cec
    v5 = 0;
    if (_fgets(v11, 72, (struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004028) != NULL) {
        _puts((char *)function_100003988());
        v5 = 0;
        while (_fgets(v11, 72, (struct _IO_FILE *)*(int64_t *)*(int64_t *)0x100004028) != NULL) {
            // 0x100003d04
            _puts((char *)function_100003988());
            v5 = 0;
        }
    }
    goto lab_0x100003d20;
  lab_0x100003d20:
    // 0x100003d20
    if (*(int64_t *)*(int64_t *)0x100004018 != *v2) {
        // 0x100003d48
        ___stack_chk_fail(v5);
    }
    // 0x100003d4c
    return 0;
}

// Address range: 0x100003d64 - 0x100003d70
int64_t function_100003d64(int64_t a1, int64_t a2, int64_t a3, char * a4) {
    // 0x100003d64
    return ___sprintf_chk(a1, a2, a3, a4);
}

// Address range: 0x100003d70 - 0x100003d7c
int64_t function_100003d70(int64_t a1) {
    // 0x100003d70
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003d7c - 0x100003d88
int64_t function_100003d7c(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003d7c
    return ___strcat_chk(a1, a2, a3);
}

// Address range: 0x100003d88 - 0x100003d94
int32_t function_100003d88(char * nptr) {
    // 0x100003d88
    return _atoi(nptr);
}

// Address range: 0x100003d94 - 0x100003da0
char * function_100003d94(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x100003d94
    return _fgets(s, n, stream);
}

// Address range: 0x100003da0 - 0x100003dac
int32_t function_100003da0(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003da0
    return _fprintf(stream, format);
}

// Address range: 0x100003dac - 0x100003db8
int32_t function_100003dac(char * s) {
    // 0x100003dac
    return _puts(s);
}

// Address range: 0x100003db8 - 0x100003dc4
char * function_100003db8(char * s, int32_t c) {
    // 0x100003db8
    return _strchr(s, c);
}

// Address range: 0x100003dc4 - 0x100003dd0
int32_t function_100003dc4(char * s) {
    // 0x100003dc4
    return _strlen(s);
}

// Address range: 0x100003dd0 - 0x100003ddc
int32_t function_100003dd0(char * s, char * accept) {
    // 0x100003dd0
    return _strspn(s, accept);
}

// Address range: 0x100003ddc - 0x100003de8
int32_t function_100003ddc(int32_t c) {
    // 0x100003ddc
    return _toupper(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 15

`
`#include <stdio.h>

int main() {
  int c;
  while ((c = getchar()) != EOF) {
    putchar(c);
  }
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f90(void);
int32_t function_100003f9c(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _getchar(void);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003f48 - 0x100003f90
int64_t entry_point(void) {
    int32_t v1 = _getchar(); // 0x100003f5c
    if (v1 == -1) {
        // 0x100003f80
        return 0;
    }
    _putchar(v1);
    int32_t v2 = _getchar(); // 0x100003f5c
    while (v2 != -1) {
        // 0x100003f74
        _putchar(v2);
        v2 = _getchar();
    }
    // 0x100003f80
    return 0;
}

// Address range: 0x100003f90 - 0x100003f9c
int32_t function_100003f90(void) {
    // 0x100003f90
    return _getchar();
}

// Address range: 0x100003f9c - 0x100003fa8
int32_t function_100003f9c(int32_t c) {
    // 0x100003f9c
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`//FormAI DATASET v1.0 Category: Text processing ; Style: surprised
#include <stdio.h>
#include <string.h>

int main()
{
   char string[100];
   int i, j, len;
   
   printf("Wow, I'm so surprised to see you here!\n\n");
   printf("What string would you like to process? ");
   scanf("%s", string);

   len = strlen(string);

   printf("\n\nProcessing your string...\n\n");

   for(i=0; i<len; i++)
   {
      for(j=0; j<=i; j++)
      {
          printf("%c", string[j]);
      }
      printf("\n");
   }

   printf("\n");
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[100]; // [rsp+20h] [rbp-70h] BYREF
  int v5; // [rsp+84h] [rbp-Ch]
  int j; // [rsp+88h] [rbp-8h]
  int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Wow, I'm so surprised to see you here!\n\n");
  printf("What string would you like to process? ");
  scanf("%s", Str);
  v5 = strlen(Str);
  printf("\n\nProcessing your string...\n\n");
  for ( i = 0; i < v5; ++i )
  {
    for ( j = 0; j <= i; ++j )
      printf("%c", (unsigned int)Str[j]);
    printf("\n");
  }
  printf("\n");
  return 0;
}
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[100];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include<stdio.h>

int main()
{
	FILE* fp = fopen("TAPE.FILE","w");
	
	fprintf(fp,"This code should be able to write a file to magnetic tape.\n");
	fprintf(fp,"The Wikipedia page on Magnetic tape data storage shows that magnetic tapes are still in use.\n");
	fprintf(fp,"In fact, the latest format, at the time of writing this code is TS1155 released in 2017.\n");
	fprintf(fp,"And since C is already 44, maybe 45, years old in 2017, I am sure someone somewhere did use a C compiler on magnetic tapes.\n");
	fprintf(fp,"If you happen to have one, please try to compile and execute me on that system.\n");
	fprintf(fp,"My creator tested me on an i5 machine with SSD and RAM that couldn't have even been dreamt of by Denis Ritchie.\n");
	fprintf(fp,"Who knows ? Maybe he did foresee today, after all he created something which is still young after 44-45 years and counting...\n");
	fprintf(fp,"EOF");
	
	fclose(fp);
	
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003cc0(struct _IO_FILE * stream);
struct _IO_FILE * function_100003ccc(char * filename, char * modes);
int32_t function_100003cd8(struct _IO_FILE * stream, char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _fclose(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bf8 - 0x100003cc0
int64_t entry_point(void) {
    struct _IO_FILE * v1 = _fopen("TAPE.FILE", "w"); // 0x100003c20
    _fprintf(v1, "This code should be able to write a file to magnetic tape.\n");
    _fprintf(v1, "The Wikipedia page on Magnetic tape data storage shows that magnetic tapes are still in use.\n");
    _fprintf(v1, "In fact, the latest format, at the time of writing this code is TS1155 released in 2017.\n");
    _fprintf(v1, "And since C is already 44, maybe 45, years old in 2017, I am sure someone somewhere did use a C compiler on magnetic tapes.\n");
    _fprintf(v1, "If you happen to have one, please try to compile and execute me on that system.\n");
    _fprintf(v1, "My creator tested me on an i5 machine with SSD and RAM that couldn't have even been dreamt of by Denis Ritchie.\n");
    _fprintf(v1, "Who knows ? Maybe he did foresee today, after all he created something which is still young after 44-45 years and counting...\n");
    _fprintf(v1, "EOF");
    _fclose(v1);
    return 0;
}

// Address range: 0x100003cc0 - 0x100003ccc
int32_t function_100003cc0(struct _IO_FILE * stream) {
    // 0x100003cc0
    return _fclose(stream);
}

// Address range: 0x100003ccc - 0x100003cd8
struct _IO_FILE * function_100003ccc(char * filename, char * modes) {
    // 0x100003ccc
    return _fopen(filename, modes);
}

// Address range: 0x100003cd8 - 0x100003ce4
int32_t function_100003cd8(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003cd8
    return _fprintf(stream, format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: statistical
#include <stdio.h>

int main() {
    printf("This program prints a unique C pattern in statistical style!\n");

    int rows = 15; // Change this value to adjust the size of the pattern
    int i, j, k;

    for (i = 1; i <= rows; i++) {
        printf("C\t"); // Prints the first column of the C pattern
        for (j = 1; j <= i; j++) {
            printf("*"); // Prints the asterisk at the bottom of the C pattern
        }
        for (k = i; k <= rows; k++) {
            printf(" "); // Prints spaces to form the left side of the C pattern
        }
        printf("*\n"); // Prints the last asterisk to complete the C pattern
    }

    for (i = rows; i >= 1; i--) {
        printf("C\t"); // Prints the first column of the C pattern
        for (j = 1; j <= i; j++) {
            printf("*"); // Prints the asterisk at the top of the C pattern
        }
        for (k = i; k <= rows; k++) {
            printf(" "); // Prints spaces to form the right side of the C pattern
        }
        printf("*\n"); // Prints the last asterisk to complete the C pattern
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int k; // [rsp+24h] [rbp-Ch]
  int ii; // [rsp+24h] [rbp-Ch]
  int j; // [rsp+28h] [rbp-8h]
  int n; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]
  int m; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("This program prints a unique C pattern in statistical style!\n");
  for ( i = 1; i <= 15; ++i )
  {
    printf("C\t");
    for ( j = 1; j <= i; ++j )
      printf("*");
    for ( k = i; k <= 15; ++k )
      printf(" ");
    printf("*\n");
  }
  for ( m = 15; m > 0; --m )
  {
    printf("C\t");
    for ( n = 1; n <= m; ++n )
      printf("*");
    for ( ii = m; ii <= 15; ++ii )
      printf(" ");
    printf("*\n");
  }
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>

int semiprime(int n)
{
	int p, f = 0;
	for (p = 2; f < 2 && p*p <= n; p++)
		while (0 == n % p)
			n /= p, f++;

	return f + (n > 1) == 2;
}

int main(void)
{
	int i;
	for (i = 2; i < 100; i++)
		if (semiprime(i)) printf(" %d", i);
	putchar('\n');

	return 0;
}
`,`#include "semiprime.h"



bool _semiprime(int param_1)

{
  bool bVar1;
  int iVar2;
  undefined4 local_c;
  undefined4 local_8;
  undefined4 local_4;
  
  local_c = 0;
  local_8 = 2;
  local_4 = param_1;
  while( true ) {
    bVar1 = false;
    if (local_c < 2) {
      bVar1 = local_8 * local_8 <= local_4;
    }
    if (!bVar1) break;
    while( true ) {
      iVar2 = 0;
      if (local_8 != 0) {
        iVar2 = local_4 / local_8;
      }
      if (local_4 != iVar2 * local_8) break;
      iVar2 = 0;
      if (local_8 != 0) {
        iVar2 = local_4 / local_8;
      }
      local_c = local_c + 1;
      local_4 = iVar2;
    }
    local_8 = local_8 + 1;
  }
  return local_c + (uint)(1 < local_4) == 2;
}



undefined8 entry(void)

{
  int iVar1;
  int local_18;
  
  for (local_18 = 2; local_18 < 100; local_18 = local_18 + 1) {
    iVar1 = _semiprime(local_18);
    if (iVar1 != 0) {
      _printf(" %d");
    }
  }
  _putchar(10);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include<math.h>
#include<stdio.h>
#include<stdlib.h>

double agm( double a, double g ) {
   /* arithmetic-geometric mean */
   double iota = 1.0E-16;
   double a1, g1;

   if( a*g < 0.0 ) {
      printf( "arithmetic-geometric mean undefined when x*y<0\n" );
      exit(1);
   }

   while( fabs(a-g)>iota ) {
      a1 = (a + g) / 2.0;
      g1 = sqrt(a * g);

      a = a1;
      g = g1;
   }

   return a;
}

int main( void ) {
   double x, y;
   printf( "Enter two numbers: " );
   scanf( "%lf%lf", &x, &y );
   printf( "The arithmetic-geometric mean is %lf\n", agm(x, y) );
   return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <math.h>
#include <stdint.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003dcc(void);
void function_100003f04(int32_t status);
int32_t function_100003f10(char * format, ...);
int32_t function_100003f1c(char * format, ...);

// --------------------- Global Variables ---------------------

float64_t g1 = 9.9999999e-17; // 0x100003f28

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dcc - 0x100003e90
int64_t function_100003dcc(void) {
    // 0x100003dcc
    float64_t v1; // 0x100003dcc
    if (v1 * v1 > 0.0) {
        // 0x100003e08
        _printf("arithmetic-geometric mean undefined when x*y<0\n");
        _exit(1);
        // UNREACHABLE
    }
    float64_t v2 = g1;
    float64_t v3 = __asm_fabd(v1, v1); // 0x100003e28
    int64_t result; // 0x100003dcc
    if (v3 == v2) {
        // 0x100003e80
        return result;
    }
    float64_t v4 = v3; // 0x100003e30
    while (v4 > v2 == v4 >= v2 == v4 <= v2) {
        // 0x100003e40
        float64_t v5; // 0x100003dcc
        float64_t v6; // 0x100003dcc
        float64_t v7 = 0.5 * (v5 + v6); // 0x100003e50
        float64_t v8 = sqrt(v5 * v6); // 0x100003e64
        v4 = __asm_fabd(v7, v8);
        v5 = v7;
        v6 = v8;
        if (v4 == v2) {
            // break -> 0x100003e80
            break;
        }
    }
    // 0x100003e80
    return result;
}

// Address range: 0x100003e90 - 0x100003f04
int64_t entry_point(void) {
    // 0x100003e90
    _printf("Enter two numbers: ");
    int64_t v1; // 0x100003e90
    _scanf("%lf%lf", (float64_t *)v1, (float64_t *)v1);
    function_100003dcc();
    int128_t v2; // 0x100003e90
    _printf("The arithmetic-geometric mean is %lf\n", (float64_t)(int64_t)v2);
    return 0;
}

// Address range: 0x100003f04 - 0x100003f10
void function_100003f04(int32_t status) {
    // 0x100003f04
    _exit(status);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * format, ...) {
    // 0x100003f10
    return _printf(format);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(char * format, ...) {
    // 0x100003f1c
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`//FormAI DATASET v1.0 Category: Weather simulation ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int temperature, humidity, wind_speed, rainfall;
    srand(time(0)); // to generate random values

    temperature = rand() % 50; // temperature range from 0 to 50 degree Celsius
    humidity = rand() % 100; // humidity range from 0 to 100 percent
    wind_speed = rand() % 50; // wind speed range from 0 to 50 kmph
    rainfall = rand() % 100; // rainfall range from 0 to 100 mm/month

    printf("Today's weather simulation:\n");
    printf("Temperature: %d degree Celsius\n", temperature);
    printf("Humidity: %d%%\n", humidity);
    printf("Wind Speed: %d kmph\n", wind_speed);
    printf("Rainfall: %d mm/month\n", rainfall);

    // weather conditions based on temperature, humidity, wind speed and rainfall
    if (temperature >= 30 && humidity >= 60 && rainfall < 50) {
        printf("It's a hot and humid day. Drink plenty of water and stay indoors.\n");
    }
    else if (temperature <= 10 && wind_speed >= 25 && rainfall >= 50) {
        printf("It's a cold and windy day with heavy rainfall. Stay warm and dry.\n");
    }
    else if (wind_speed >= 50) {
        printf("It's a stormy day. Stay indoors and be cautious.\n");
    }
    else {
        printf("Weather conditions are normal today. Enjoy your day!\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+20h] [rbp-10h]
  int v6; // [rsp+24h] [rbp-Ch]
  int v7; // [rsp+28h] [rbp-8h]
  int v8; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v8 = rand() % 50;
  v7 = rand() % 100;
  v6 = rand() % 50;
  v5 = rand() % 100;
  printf("Today's weather simulation:\n");
  printf("Temperature: %d degree Celsius\n", (unsigned int)v8);
  printf("Humidity: %d%%\n", (unsigned int)v7);
  printf("Wind Speed: %d kmph\n", (unsigned int)v6);
  printf("Rainfall: %d mm/month\n", (unsigned int)v5);
  if ( v8 <= 29 || v7 <= 59 || v5 > 49 )
  {
    if ( v8 > 10 || v6 <= 24 || v5 <= 49 )
    {
      if ( v6 <= 49 )
        printf("Weather conditions are normal today. Enjoy your day!\n");
      else
        printf("It's a stormy day. Stay indoors and be cautious.\n");
    }
    else
    {
      printf("It's a cold and windy day with heavy rainfall. Stay warm and dry.\n");
    }
  }
  else
  {
    printf("It's a hot and humid day. Drink plenty of water and stay indoors.\n");
  }
  return 0;
}
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text Summarizer ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SENTENCES 1000
#define MAX_LENGTH 1000

char *get_sentence(char *text);
void summarize(char *text);

int main() {
    char text[MAX_LENGTH];
    printf("Enter text to summarize: ");
    fgets(text, MAX_LENGTH, stdin);
    printf("\nSummary:\n");
    summarize(text);
    return 0;
}

/**
 * Function to get the next sentence from a given text
 * Returns the sentence as a string
 */
char *get_sentence(char *text) {
    static char sentence[MAX_LENGTH]; // static variable to store sentence
    int i = 0;
    while (*text) {
        if (*text == '.' || *text == '?' || *text == '!') {
            sentence[i++] = *(text++);
            sentence[i] = '\0';
            return sentence;
        }
        sentence[i++] = *(text++);
    }
    return NULL;
}

/**
 * Function to summarize a given text
 */
void summarize(char *text) {
    int sentence_count = 0;
    char *sentences[MAX_SENTENCES];
    char *word;
    char *summarized_text[MAX_LENGTH];
    int summarized_length = 0;
    int i;

    // Split the text into sentences
    sentences[sentence_count++] = strtok(text, ".?!");
    while ((sentences[sentence_count] = strtok(NULL, ".?!")) != NULL) {
        sentence_count++;
    }

    // Loop through each sentence and pick out important words
    for (i = 0; i < sentence_count; i++) {
        word = strtok(sentences[i], " ");
        while (word != NULL) {
            if (strcmp(word, "the") && strcmp(word, "a") && strcmp(word, "an") && strcmp(word, "and") && strcmp(word, "but") && strcmp(word, "or") && strcmp(word, "on") && strcmp(word, "at") && strcmp(word, "in") && strcmp(word, "of") && strcmp(word, "to") && strcmp(word, "with")) {
                strcat(summarized_text, word);
                strcat(summarized_text, " ");
                summarized_length += (strlen(word) + 1);
                if (summarized_length > (MAX_LENGTH / 2)) {
                    break;
                }
            }
            word = strtok(NULL, " ");
        }
        if (summarized_length > (MAX_LENGTH / 2)) {
            break;
        }
    }
    summarized_text[summarized_length] = '\0';

    // Print the summarized text
    printf("%s...\n", summarized_text);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall summarize(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1008]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  printf("Enter text to summarize: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  printf("\nSummary:\n");
  summarize(Buffer);
  return 0;
}
// 1400016B9: using guessed type __int64 __fastcall summarize(_QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

#define FACES "23456789tjqka"
#define SUITS "shdc"

typedef int bool;

typedef struct {
    int face;  /* FACES map to 0..12 respectively */
    char suit;
} card;

card cards[5];

int compare_card(const void *a, const void *b) {
    card c1 = *(card *)a;
    card c2 = *(card *)b;
    return c1.face - c2.face;
}

bool equals_card(card c1, card c2) {
    if (c1.face == c2.face && c1.suit == c2.suit) return TRUE;
    return FALSE;
}

bool are_distinct() {
    int i, j;
    for (i = 0; i < 4; ++i)
        for (j = i + 1; j < 5; ++j)
            if (equals_card(cards[i], cards[j])) return FALSE;
    return TRUE;
}

bool is_straight() {
    int i;
    qsort(cards, 5, sizeof(card), compare_card);
    if (cards[0].face + 4 == cards[4].face) return TRUE;
    if (cards[4].face == 12 && cards[0].face == 0 &&
        cards[3].face == 3) return TRUE;
    return FALSE;
}

bool is_flush() {
    int i;
    char suit = cards[0].suit;
    for (i = 1; i < 5; ++i) if (cards[i].suit != suit) return FALSE;
    return TRUE;
}

const char *analyze_hand(const char *hand) {
    int i, j, gs = 0;
    char suit, *cp;
    bool found, flush, straight;
    int groups[13];
    if (strlen(hand) != 14) return "invalid";
    for (i = 0; i < 14; i += 3) {
        cp = strchr(FACES, tolower(hand[i]));
        if (cp == NULL) return "invalid";
        j = i / 3;
        cards[j].face = cp - FACES;
        suit = tolower(hand[i + 1]);
        cp = strchr(SUITS, suit);
        if (cp == NULL) return "invalid";
        cards[j].suit = suit;
    }
    if (!are_distinct()) return "invalid";
    for (i = 0; i < 13; ++i) groups[i] = 0;
    for (i = 0; i < 5; ++i) groups[cards[i].face]++;
    for (i = 0; i < 13; ++i) if (groups[i] > 0) gs++;
    switch(gs) {
        case 2:
            found = FALSE;
            for (i = 0; i < 13; ++i) if (groups[i] == 4) {
                found = TRUE;
                break;
            }
            if (found) return "four-of-a-kind";
            return "full-house";
        case 3:
            found = FALSE;
            for (i = 0; i < 13; ++i) if (groups[i] == 3) {
                found = TRUE;
                break;
            }
            if (found) return "three-of-a-kind";
            return "two-pairs";
        case 4:
            return "one-pair";
        default:
            flush = is_flush();
            straight = is_straight();
            if (flush && straight)
                return "straight-flush";
            else if (flush)
                return "flush";
            else if (straight)
                return "straight";
            else
                return "high-card";
    }
}

int main(){
    int i;
    const char *type;
    const char *hands[10] = {
        "2h 2d 2c kc qd",
        "2h 5h 7d 8c 9s",
        "ah 2d 3c 4c 5d",
        "2h 3h 2d 3c 3d",
        "2h 7h 2d 3c 3d",
        "2h 7h 7d 7c 7s",
        "th jh qh kh ah",
        "4h 4s ks 5d ts",
        "qc tc 7c 6c 4c",
        "ah ah 7c 6c 4c"
    };
    for (i = 0; i < 10; ++i) {
        type = analyze_hand(hands[i]);
        printf("%s: %s\n", hands[i], type);
    }
    return 0;
}
`,`#include "poker-hand-analyser.h"



int _compare_card(undefined8 *param_1,undefined8 *param_2)

{
  undefined4 local_20;
  undefined4 local_18;
  
  local_18 = (int)*param_1;
  local_20 = (int)*param_2;
  return local_18 - local_20;
}



undefined4 _equals_card(undefined8 param_1,undefined8 param_2)

{
  undefined4 local_14;
  undefined uStack_10;
  undefined4 local_c;
  undefined uStack_8;
  undefined4 local_4;
  
  local_c = (int)param_1;
  local_14 = (int)param_2;
  if ((local_c == local_14) &&
     (uStack_8 = (char)((ulong)param_1 >> 0x20), uStack_10 = (char)((ulong)param_2 >> 0x20),
     uStack_8 == uStack_10)) {
    local_4 = 1;
  }
  else {
    local_4 = 0;
  }
  return local_4;
}



undefined4 _are_distinct(void)

{
  int iVar1;
  int local_1c;
  int local_18;
  
  local_18 = 0;
  do {
    local_1c = local_18;
    if (3 < local_18) {
      return 1;
    }
    while (local_1c = local_1c + 1, local_1c < 5) {
      iVar1 = _equals_card(*(undefined8 *)(&_cards + (long)local_18 * 8),
                           *(undefined8 *)(&_cards + (long)local_1c * 8));
      if (iVar1 != 0) {
        return 0;
      }
    }
    local_18 = local_18 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 _is_straight(void)

{
  undefined4 local_14;
  
  _qsort(&_cards,5,8,(int *)_compare_card);
  if (__cards + 4 == _DAT_100008020) {
    local_14 = 1;
  }
  else if (((_DAT_100008020 == 0xc) && (__cards == 0)) && (_DAT_100008018 == 3)) {
    local_14 = 1;
  }
  else {
    local_14 = 0;
  }
  return local_14;
}



undefined4 _is_flush(void)

{
  int local_8;
  
  local_8 = 1;
  while( true ) {
    if (4 < local_8) {
      return 1;
    }
    if ((&DAT_100008004)[(long)local_8 * 8] != DAT_100008004) break;
    local_8 = local_8 + 1;
  }
  return 0;
}



char * _analyze_hand(char *param_1)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  size_t sVar4;
  char *pcVar5;
  int local_6c;
  int local_64;
  char *local_58;
  int aiStack_4c [13];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_6c = 0;
  sVar4 = _strlen(param_1);
  if (sVar4 == 0xe) {
    for (local_64 = 0; local_64 < 0xe; local_64 = local_64 + 3) {
      iVar2 = _tolower((int)param_1[local_64]);
      pcVar5 = _strchr("23456789tjqka",iVar2);
      if (pcVar5 == (char *)0x0) {
        local_58 = "invalid";
        goto LAB_100003d10;
      }
      *(int *)(&_cards + (long)(local_64 / 3) * 8) = (int)pcVar5 + -16000;
      iVar2 = _tolower((int)param_1[local_64 + 1]);
      pcVar5 = _strchr("shdc",(int)(char)iVar2);
      if (pcVar5 == (char *)0x0) {
        local_58 = "invalid";
        goto LAB_100003d10;
      }
      (&DAT_100008004)[(long)(local_64 / 3) * 8] = (char)iVar2;
    }
    iVar2 = _are_distinct();
    if (iVar2 == 0) {
      local_58 = "invalid";
    }
    else {
      for (local_64 = 0; local_64 < 0xd; local_64 = local_64 + 1) {
        aiStack_4c[local_64] = 0;
      }
      for (local_64 = 0; local_64 < 5; local_64 = local_64 + 1) {
        aiStack_4c[*(int *)(&_cards + (long)local_64 * 8)] =
             aiStack_4c[*(int *)(&_cards + (long)local_64 * 8)] + 1;
      }
      for (local_64 = 0; local_64 < 0xd; local_64 = local_64 + 1) {
        if (0 < aiStack_4c[local_64]) {
          local_6c = local_6c + 1;
        }
      }
      if (local_6c == 2) {
        bVar1 = false;
        for (local_64 = 0; local_64 < 0xd; local_64 = local_64 + 1) {
          if (aiStack_4c[local_64] == 4) {
            bVar1 = true;
            break;
          }
        }
        if (bVar1) {
          local_58 = "four-of-a-kind";
        }
        else {
          local_58 = "full-house";
        }
      }
      else if (local_6c == 3) {
        bVar1 = false;
        for (local_64 = 0; local_64 < 0xd; local_64 = local_64 + 1) {
          if (aiStack_4c[local_64] == 3) {
            bVar1 = true;
            break;
          }
        }
        if (bVar1) {
          local_58 = "three-of-a-kind";
        }
        else {
          local_58 = "two-pairs";
        }
      }
      else if (local_6c == 4) {
        local_58 = "one-pair";
      }
      else {
        iVar2 = _is_flush();
        iVar3 = _is_straight();
        if ((iVar2 == 0) || (iVar3 == 0)) {
          if (iVar2 == 0) {
            if (iVar3 == 0) {
              local_58 = "high-card";
            }
            else {
              local_58 = "straight";
            }
          }
          else {
            local_58 = "flush";
          }
        }
        else {
          local_58 = "straight-flush";
        }
      }
    }
  }
  else {
    local_58 = "invalid";
  }
LAB_100003d10:
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return local_58;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  uint uVar1;
  void *pvVar2;
  int local_70;
  undefined8 auStack_68 [10];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar2 = _memcpy(auStack_68,&PTR_s_2h_2d_2c_kc_qd_100004040,0x50);
  for (local_70 = 0; local_70 < 10; local_70 = local_70 + 1) {
    _analyze_hand(auStack_68[local_70]);
    uVar1 = _printf("%s: %s\n");
    pvVar2 = (void *)(ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pvVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e38. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strchr(char *param_1,int param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strchr_100004028)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e68. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004030)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tolower(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tolower_100004038)(_c);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Resume Parsing System ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//Struct for storing resume information
struct resume {
    char name[50];
    char email[50];
    char phone[20];
    char skills[1000];
};

//Function for parsing resumes
int parse_resume(char* filename, struct resume* r) {
    FILE* fp = fopen(filename, "r");

    if(fp == NULL) {
        printf("Error: file not found.\n");
        return 0;
    }

    char line[1000];

    //Loop through each line of the file
    while(fgets(line, 1000, fp) != NULL) {
        //Check for name
        if(strstr(line, "Name:")) {
            char* name = strstr(line, ":") + 1;
            strcpy(r->name, name);
        }
        //Check for email
        if(strstr(line, "Email:")) {
            char* email = strstr(line, ":") + 1;
            strcpy(r->email, email);
        }
        //Check for phone number
        if(strstr(line, "Phone:")) {
            char* phone = strstr(line, ":") + 1;
            strcpy(r->phone, phone);
        }
        //Check for skills
        if(strstr(line, "Skills:")) {
            char* skills = strstr(line, ":") + 1;
            strcpy(r->skills, skills);
        }
    }

    fclose(fp);

    return 1;
}

int main() {
    char filename[50];
    printf("Enter filename: ");
    scanf("%s", filename);

    struct resume r;
    int success = parse_resume(filename, &r);

    if(success) {
        printf("Name: %s\nEmail: %s\nPhone: %s\nSkills: %s\n", r.name, r.email, r.phone, r.skills);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall parse_resume(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017B9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[50]; // [rsp+30h] [rbp-50h] BYREF
  char v5[50]; // [rsp+62h] [rbp-1Eh] BYREF
  char v6[20]; // [rsp+94h] [rbp+14h] BYREF
  char v7[1000]; // [rsp+A8h] [rbp+28h] BYREF
  char v8[60]; // [rsp+490h] [rbp+410h] BYREF

  _main(argc, argv, envp);
  printf("Enter filename: ");
  scanf("%s", v8);
  if ( (unsigned int)parse_resume(v8, v4) )
    printf("Name: %s\nEmail: %s\nPhone: %s\nSkills: %s\n", v4, v5, v6, v7);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall parse_resume(_QWORD, _QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400017B9: using guessed type char anonymous_0[50];
// 1400017B9: using guessed type char anonymous_1[20];
// 1400017B9: using guessed type char anonymous_2[1000];

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: inquisitive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct pixel {
    int red;
    int green;
    int blue;
} Pixel;

int main() {
    int width, height;
    printf("Enter the width of the image: ");
    scanf("%d", &width);
    printf("Enter the height of the image: ");
    scanf("%d", &height);

    Pixel image[width][height];
    srand(time(NULL)); // seed the random number generator

    // loop through each pixel in the image
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            // generate a random color for the pixel
            image[x][y].red = rand() % 256;
            image[x][y].green = rand() % 256;
            image[x][y].blue = rand() % 256;
        }
    }

    // print the image as ASCII art
    printf("\n");
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            // choose a character to represent each pixel based on its brightness
            int brightness = (image[x][y].red + image[x][y].green + image[x][y].blue) / 3;
            char c;
            if (brightness < 64) {
                c = ' ';
            } else if (brightness < 128) {
                c = '.';
            } else if (brightness < 192) {
                c = '*';
            } else {
                c = '#';
            }
            // print the character in the appropriate color
            printf("\033[38;2;%d;%d;%dm%c\033[0m", image[x][y].red, image[x][y].green, image[x][y].blue, c);
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned __int64 v3; // rbx
  void *v4; // rsp
  unsigned int v5; // eax
  __int64 v6; // r9
  unsigned int v7; // r10d
  unsigned int v8; // eax
  __int64 v10; // [rsp+0h] [rbp-A0h] BYREF
  __int64 v11; // [rsp+20h] [rbp-80h]
  char v12; // [rsp+30h] [rbp-70h] BYREF
  __int64 *v13; // [rsp+38h] [rbp-68h]
  __int64 v14; // [rsp+40h] [rbp-60h]
  __int64 v15; // [rsp+48h] [rbp-58h]
  __int64 v16; // [rsp+50h] [rbp-50h]
  __int64 v17; // [rsp+58h] [rbp-48h]
  int v18; // [rsp+64h] [rbp-3Ch] BYREF
  int v19; // [rsp+68h] [rbp-38h] BYREF
  int v20; // [rsp+6Ch] [rbp-34h]
  char *v21; // [rsp+70h] [rbp-30h]
  __int64 v22; // [rsp+78h] [rbp-28h]
  __int64 v23; // [rsp+80h] [rbp-20h]
  char v24; // [rsp+8Fh] [rbp-11h]
  int m; // [rsp+90h] [rbp-10h]
  int k; // [rsp+94h] [rbp-Ch]
  int j; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v13 = &v10;
  printf("Enter the width of the image: ");
  scanf("%d", &v19);
  printf("Enter the height of the image: ");
  scanf("%d", &v18);
  v23 = v18 - 1i64;
  v16 = v18;
  v17 = 0i64;
  v3 = 12i64 * v18;
  v22 = v19 - 1i64;
  v14 = v18;
  v15 = 0i64;
  v4 = alloca(16 * ((unsigned __int64)(12 * v19 * (__int64)v18 + 15) >> 4));
  v21 = &v12;
  v5 = time(0i64);
  srand(v5);
  for ( i = 0; i < v19; ++i )
  {
    for ( j = 0; j < v18; ++j )
    {
      *(_DWORD *)&v21[12 * j + 4 * i * (v3 >> 2)] = rand() % 256;
      *(_DWORD *)&v21[12 * j + 4 + 4 * i * (v3 >> 2)] = rand() % 256;
      *(_DWORD *)&v21[12 * j + 8 + 4 * i * (v3 >> 2)] = rand() % 256;
    }
  }
  printf("\n");
  for ( k = 0; k < v18; ++k )
  {
    for ( m = 0; m < v19; ++m )
    {
      v20 = (*(_DWORD *)&v21[12 * k + 4 + 4 * m * (v3 >> 2)]
           + *(_DWORD *)&v21[12 * k + 4 * m * (v3 >> 2)]
           + *(_DWORD *)&v21[12 * k + 8 + 4 * m * (v3 >> 2)])
          / 3;
      if ( v20 > 63 )
      {
        if ( v20 > 127 )
        {
          if ( v20 > 191 )
            v24 = 35;
          else
            v24 = 42;
        }
        else
        {
          v24 = 46;
        }
      }
      else
      {
        v24 = 32;
      }
      v6 = *(unsigned int *)&v21[12 * k + 8 + 4 * m * (v3 >> 2)];
      v7 = *(_DWORD *)&v21[12 * k + 4 + 4 * m * (v3 >> 2)];
      v8 = *(_DWORD *)&v21[12 * k + 4 * m * (v3 >> 2)];
      LODWORD(v11) = v24;
      printf("\x1B[38;2;%d;%d;%dm%c\x1B[0m", v8, v7, v6, v11);
    }
    printf("\n");
  }
  return 0;
}
// 140001B60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include<stdio.h>
#include<math.h>

typedef struct{
	double x,y;
	}point;
	
double distance(point p1,point p2)
{
	return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
	
void findCircles(point p1,point p2,double radius)
{
	double separation = distance(p1,p2),mirrorDistance;
	
	if(separation == 0.0)
	{
		radius == 0.0 ? printf("\nNo circles can be drawn through (%.4f,%.4f)",p1.x,p1.y):
							 printf("\nInfinitely many circles can be drawn through (%.4f,%.4f)",p1.x,p1.y);
	}
	
	else if(separation == 2*radius)
	{
		printf("\nGiven points are opposite ends of a diameter of the circle with center (%.4f,%.4f) and radius %.4f",(p1.x+p2.x)/2,(p1.y+p2.y)/2,radius);
	}
	
	else if(separation > 2*radius)
	{
		printf("\nGiven points are farther away from each other than a diameter of a circle with radius %.4f",radius);
	}
	
	else
	{
		mirrorDistance =sqrt(pow(radius,2) - pow(separation/2,2));
		
		printf("\nTwo circles are possible.");
		printf("\nCircle C1 with center (%.4f,%.4f), radius %.4f and Circle C2 with center (%.4f,%.4f), radius %.4f",(p1.x+p2.x)/2 + mirrorDistance*(p1.y-p2.y)/separation,(p1.y+p2.y)/2 + mirrorDistance*(p2.x-p1.x)/separation,radius,(p1.x+p2.x)/2 - mirrorDistance*(p1.y-p2.y)/separation,(p1.y+p2.y)/2 - mirrorDistance*(p2.x-p1.x)/separation,radius);
	}
}

int main()
{
    int i;

    point cases[] = 	
    {	{0.1234, 0.9876},    {0.8765, 0.2345},
	{0.0000, 2.0000},    {0.0000, 0.0000},
	{0.1234, 0.9876},    {0.1234, 0.9876},
	{0.1234, 0.9876},    {0.8765, 0.2345},
	{0.1234, 0.9876},    {0.1234, 0.9876}
    };

    double radii[] = {2.0,1.0,2.0,0.5,0.0};

    for(i=0;i<5;i++)
    {	
	printf("\nCase %d)",i+1);
	findCircles(cases[2*i],cases[2*i+1],radii[i]);
    }

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000038dc(void);
int64_t function_100003934(void);
int64_t function_100003d0c(int64_t a1);
int64_t * function_100003d18(int64_t * dest, int64_t * src, int32_t n);
int64_t * function_100003d24(int64_t * s, int32_t c, int32_t n);
float64_t function_100003d30(float64_t a1, float64_t a2);
int32_t function_100003d3c(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x3fbf972474538ef3; // 0x100003ef8

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int64_t * _memset(int64_t * a1, int32_t a2, int32_t a3);
float64_t _pow(float64_t a1, float64_t a2);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x1000038dc - 0x100003934
int64_t function_1000038dc(void) {
    // 0x1000038dc
    int64_t result; // 0x1000038dc
    return result;
}

// Address range: 0x100003934 - 0x100003bd4
int64_t function_100003934(void) {
    // 0x100003934
    float64_t v1; // 0x100003934
    float64_t v2 = v1;
    int128_t v3; // 0x100003934
    int128_t v4 = v3;
    function_1000038dc();
    int32_t result; // 0x100003934
    if (v2 == 0.0) {
        if (v1 == 0.0) {
            // 0x100003994
            result = _printf("\nNo circles can be drawn through (%.4f,%.4f)", (float64_t)(int64_t)v3, (float64_t)(int64_t)v4);
        } else {
            // 0x1000039b8
            result = _printf("\nInfinitely many circles can be drawn through (%.4f,%.4f)", (float64_t)(int64_t)v3, (float64_t)(int64_t)v4);
        }
        // 0x100003bc8
        return result;
    }
    float64_t v5 = 2.0 * v1; // 0x1000039ec
    if (v2 == v5) {
        // 0x100003a00
        result = _printf("\nGiven points are opposite ends of a diameter of the circle with center (%.4f,%.4f) and radius %.4f", (float64_t)(int64_t)v3, (float64_t)(int64_t)v4, (float64_t)(int64_t)v3);
        // 0x100003bc8
        return result;
    }
    if (v2 > v5 == v2 >= v5 == v2 <= v5) {
        // 0x100003a68
        result = _printf("\nGiven points are farther away from each other than a diameter of a circle with radius %.4f", (float64_t)(int64_t)v3);
    } else {
        float64_t v6 = _pow(_pow((float64_t)(int64_t)v3, (float64_t)(int64_t)v4), (float64_t)(int64_t)v4); // 0x100003aa4
        _printf("\nTwo circles are possible.");
        result = _printf("\nCircle C1 with center (%.4f,%.4f), radius %.4f and Circle C2 with center (%.4f,%.4f), radius %.4f", v6, (float64_t)(int64_t)v4, (float64_t)(int64_t)v3, (float64_t)(int64_t)v3, (float64_t)(int64_t)v3, (float64_t)(int64_t)v3);
    }
    // 0x100003bc8
    return result;
}

// Address range: 0x100003bd4 - 0x100003d0c
int64_t entry_point(void) {
    // 0x100003bd4
    int64_t v1; // bp-200, 0x100003bd4
    _memcpy(&v1, &g1, 160);
    int64_t v2; // bp-240, 0x100003bd4
    _memset(&v2, 0, 40);
    v2 = 0x4000000000000000;
    int64_t v3; // 0x100003cbc
    for (int32_t i = 0; i < 5; i++) {
        // 0x100003c5c
        _printf("\nCase %d)", 0);
        v3 = function_100003934();
    }
    int64_t v4 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ce0
    if (v4 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003cf4
        ___stack_chk_fail(v3);
    }
    // 0x100003cf8
    return 0;
}

// Address range: 0x100003d0c - 0x100003d18
int64_t function_100003d0c(int64_t a1) {
    // 0x100003d0c
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003d18 - 0x100003d24
int64_t * function_100003d18(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003d18
    return _memcpy(dest, src, n);
}

// Address range: 0x100003d24 - 0x100003d30
int64_t * function_100003d24(int64_t * s, int32_t c, int32_t n) {
    // 0x100003d24
    return _memset(s, c, n);
}

// Address range: 0x100003d30 - 0x100003d3c
float64_t function_100003d30(float64_t a1, float64_t a2) {
    // 0x100003d30
    return _pow(a1, a2);
}

// Address range: 0x100003d3c - 0x100003d48
int32_t function_100003d3c(char * format, ...) {
    // 0x100003d3c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`#include <stdio.h>

void comb(int m, int n, unsigned char *c)
{
	int i;
	for (i = 0; i < n; i++) c[i] = n - i;

	while (1) {
		for (i = n; i--;)
			printf("%d%c", c[i], i ? ' ': '\n');

		/* this check is not strictly necessary, but if m is not close to n,
		   it makes the whole thing quite a bit faster */
		i = 0;
		if (c[i]++ < m) continue;

		for (; c[i] >= m - i;) if (++i >= n) return;
		for (c[i]++; i; i--) c[i-1] = c[i] + 1;
	}
}

int main()
{
	unsigned char buf[100];
	comb(5, 3, buf);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d4c(void);
int64_t function_100003f88(int64_t a1);
int32_t function_100003f94(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003d4c - 0x100003f24
int64_t function_100003d4c(void) {
    // 0x100003d4c
    int64_t v1; // 0x100003d4c
    int32_t v2 = v1; // 0x100003d5c
    int32_t v3 = -v2; // 0x100003d74
    if (v3 < 0 != (v3 & v2) < 0) {
        int32_t v4 = 0;
        *(char *)(v1 + (int64_t)v4) = (char)(v2 - v4);
        int32_t v5 = v4 + 1; // 0x100003da4
        while (v5 - v2 < 0 != ((v5 - v2 ^ v5) & (v5 ^ v2)) < 0) {
            // 0x100003d84
            v4 = v5;
            *(char *)(v1 + (int64_t)v4) = (char)(v2 - v4);
            v5 = v4 + 1;
        }
    }
    int32_t v6 = v1; // 0x100003d58
    int64_t result; // 0x100003d4c
    while (true) {
        char v7; // 0x100003d4c
        int64_t v8; // 0x100003d4c
        int64_t v9; // 0x100003d4c
        int64_t v10; // 0x100003d4c
        if (v2 == 0) {
            // 0x100003db4
            v7 = *(char *)&v10;
            v9 = v8;
        } else {
            char v11 = v10;
            int32_t v12 = v2; // 0x100003dc4
            v12--;
            int32_t v13 = _printf("%d%c", v1, v11); // 0x100003e24
            while (v12 != 0) {
                // 0x100003ddc
                v12--;
                v13 = _printf("%d%c", v1, v11);
            }
            // 0x100003dc0
            v7 = v11;
            v9 = v13;
        }
        // 0x100003e2c
        result = v9;
        *(char *)v1 = v7 + 1;
        int32_t v14 = (int32_t)v7 - v6; // 0x100003e4c
        if (v14 < 0 == (v14 & v6) < 0) {
            int32_t v15 = 0;
            char * v16 = (char *)(v1 + (int64_t)v15);
            unsigned char v17 = *v16; // 0x100003e6c
            int32_t v18 = v6 - v15; // 0x100003e78
            while ((int32_t)v17 - v18 < 0 == ((int32_t)v17 - v18 & v18) < 0) {
                int32_t v19 = v15 + 1; // 0x100003e90
                int32_t v20 = v19 - v2; // 0x100003e9c
                if (v20 < 0 == ((v20 ^ v19) & (v19 ^ v2)) < 0) {
                    return result;
                }
                v15 = v19;
                v16 = (char *)(v1 + (int64_t)v15);
                v17 = *v16;
                v18 = v6 - v15;
            }
            // 0x100003ebc
            *v16 = v17 + 1;
            int32_t v21 = v15; // 0x100003ee4
            if (v15 != 0) {
                char v22 = *(char *)(v1 + (int64_t)v21); // 0x100003ef4
                int32_t v23 = v21 - 1; // 0x100003f04
                *(char *)(v1 + (int64_t)v23) = v22 + 1;
                v21 = v23;
                while (v23 != 0) {
                    // 0x100003eec
                    v22 = *(char *)(v1 + (int64_t)v21);
                    v23 = v21 - 1;
                    *(char *)(v1 + (int64_t)v23) = v22 + 1;
                    v21 = v23;
                }
            }
        }
        // 0x100003db4
        v8 = result;
    }
    // 0x100003eac
    return result;
}

// Address range: 0x100003f24 - 0x100003f88
int64_t entry_point(void) {
    int64_t v1 = function_100003d4c(); // 0x100003f50
    int64_t v2 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003f60
    if (v2 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f74
        ___stack_chk_fail(v1);
    }
    // 0x100003f78
    return 0;
}

// Address range: 0x100003f88 - 0x100003f94
int64_t function_100003f88(int64_t a1) {
    // 0x100003f88
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(char * format, ...) {
    // 0x100003f94
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>

int main()
{
  int door, square, increment;
  for (door = 1, square = 1, increment = 1; door <= 100; door++ == square && (square += increment += 2))
    printf("door #%d is %s.\n", door, (door == square? "open" : "closed"));
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f7c(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ea4 - 0x100003f7c
int64_t entry_point(void) {
    int32_t v1 = 1;
    int64_t v2; // 0x100003ea4
    _printf("door #%d is %s.\n", v2, (char *)v2);
    int32_t v3 = v1 + 1; // 0x100003f30
    while (v1 == 99 || v1 < 99 != (98 - v1 & v3) < 0) {
        // 0x100003edc
        v1 = v3;
        _printf("door #%d is %s.\n", v2, (char *)v2);
        v3 = v1 + 1;
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`#include <stdio.h>
#include <stdlib.h>

size_t rprint(char *s, int *x, int len)
{
#define sep (a > s ? "," : "") /* use comma except before first output */
#define ol (s ? 100 : 0)       /* print only if not testing for length */
	int i, j;
	char *a = s;
	for (i = j = 0; i < len; i = ++j) {
		for (; j < len - 1 && x[j + 1] == x[j] + 1; j++);

		if (i + 1 < j)
			a += snprintf(s?a:s, ol, "%s%d-%d", sep, x[i], x[j]);
		else
			while (i <= j)
				a += snprintf(s?a:s, ol, "%s%d", sep, x[i++]);
	}
	return a - s;
#undef sep
#undef ol
}

int main()
{
	int x[] = {	0,  1,  2,  4,  6,  7,  8, 11, 12, 14,
			15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
			25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
			37, 38, 39 };

	char *s = malloc(rprint(0, x, sizeof(x) / sizeof(int)) + 1);
	rprint(s, x, sizeof(x) / sizeof(int));
	printf("%s\n", s);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003af8(void);
int64_t function_100003ed4(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5);
int64_t function_100003ee0(int64_t a1);
int64_t * function_100003eec(int32_t size);
int64_t * function_100003ef8(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f04(char * format, ...);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x100000000; // 0x100003f24

// ------- Dynamically Linked Functions Without Header --------

int64_t ___snprintf_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5);
int64_t ___stack_chk_fail(int64_t a1);
int64_t * _malloc(int32_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003af8 - 0x100003e20
int64_t function_100003af8(void) {
    // 0x100003af8
    int64_t v1; // 0x100003af8
    int32_t v2 = v1; // 0x100003b0c
    int32_t v3 = -v2; // 0x100003b2c
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e08
        int64_t v4; // 0x100003af8
        return v4 - v1;
    }
    int32_t v5 = v2 - 1; // 0x100003b48
    int64_t v6 = v1 == 0 ? 0 : 100;
    int32_t v7 = 0;
    int32_t v8 = v7 - v5; // 0x100003b4c
    int32_t v9 = v7; // 0x100003b5c
    int32_t v10 = v7; // 0x100003b5c
    int32_t v11; // 0x100003af8
    int32_t v12; // 0x100003b70
    int32_t v13; // 0x100003ba8
    int32_t v14; // 0x100003b4c
    if (v8 < 0 != ((v8 ^ v7) & (v7 ^ v5)) < 0) {
        v11 = v9;
        v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 + 4));
        v10 = v11;
        while (v12 == *(int32_t *)(4 * (int64_t)v11 + v1) + 1) {
            // 0x100003ba4
            v13 = v11 + 1;
            v14 = v13 - v5;
            v9 = v13;
            v10 = v13;
            if (v14 < 0 == ((v14 ^ v13) & (v13 ^ v5)) < 0) {
                // break -> 0x100003bb4
                break;
            }
            v11 = v9;
            v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 + 4));
            v10 = v11;
        }
    }
    int32_t v15 = v10;
    int32_t v16 = v7 + 1; // 0x100003bb8
    int32_t v17 = v16 - v15; // 0x100003bc0
    int32_t v18; // 0x100003af8
    int64_t v19; // 0x100003af8
    int64_t v20; // 0x100003af8
    int64_t v21; // 0x100003af8
    int64_t v22; // 0x100003af8
    int64_t v23; // 0x100003af8
    int32_t v24; // 0x100003ce0
    int32_t v25; // 0x100003dac
    int64_t v26; // 0x100003de0
    int32_t v27; // 0x100003ce0
    if (v17 < 0 == ((v17 ^ v16) & (v15 ^ v16)) < 0) {
        // 0x100003cd8
        v24 = v7 - v15;
        v18 = v7;
        v21 = v19;
        if (v24 == 0 || v24 < 0 != ((v24 ^ v7) & (v15 ^ v7)) < 0) {
            v23 = v1 == 0 ? 0 : v19;
            v25 = v18 + 1;
            v26 = (0x100000000 * ___snprintf_chk(v23, v6, 0, -1, "%s%d") >> 32) + v19;
            v27 = v25 - v15;
            v18 = v25;
            v20 = v26;
            v21 = v26;
            while (v27 == 0 || v27 < 0 != ((v27 ^ v25) & (v25 ^ v15)) < 0) {
                // 0x100003cf0
                v23 = v1 == 0 ? 0 : v20;
                v25 = v18 + 1;
                v26 = (0x100000000 * ___snprintf_chk(v23, v6, 0, -1, "%s%d") >> 32) + v20;
                v27 = v25 - v15;
                v18 = v25;
                v20 = v26;
                v21 = v26;
            }
        }
    } else {
        // 0x100003bd0
        v22 = v1 == 0 ? 0 : v19;
        v21 = (0x100000000 * ___snprintf_chk(v22, v6, 0, -1, "%s%d-%d") >> 32) + v19;
    }
    int32_t v28 = v15 + 1; // 0x100003df8
    int32_t v29 = v28 - v2; // 0x100003b2c
    while (v29 < 0 != ((v29 ^ v28) & (v28 ^ v2)) < 0) {
        int64_t v30 = v21;
        v7 = v28;
        v8 = v7 - v5;
        v9 = v7;
        v10 = v7;
        if (v8 < 0 != ((v8 ^ v7) & (v7 ^ v5)) < 0) {
            v11 = v9;
            v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 + 4));
            v10 = v11;
            while (v12 == *(int32_t *)(4 * (int64_t)v11 + v1) + 1) {
                // 0x100003ba4
                v13 = v11 + 1;
                v14 = v13 - v5;
                v9 = v13;
                v10 = v13;
                if (v14 < 0 == ((v14 ^ v13) & (v13 ^ v5)) < 0) {
                    // break -> 0x100003bb4
                    break;
                }
                v11 = v9;
                v12 = *(int32_t *)(v1 + (int64_t)(4 * v11 + 4));
                v10 = v11;
            }
        }
        // 0x100003bb4
        v15 = v10;
        v16 = v7 + 1;
        v17 = v16 - v15;
        if (v17 < 0 == ((v17 ^ v16) & (v15 ^ v16)) < 0) {
            // 0x100003cd8
            v24 = v7 - v15;
            v18 = v7;
            v20 = v30;
            v21 = v30;
            if (v24 == 0 || v24 < 0 != ((v24 ^ v7) & (v15 ^ v7)) < 0) {
                v23 = v1 == 0 ? 0 : v20;
                v25 = v18 + 1;
                v26 = (0x100000000 * ___snprintf_chk(v23, v6, 0, -1, "%s%d") >> 32) + v20;
                v27 = v25 - v15;
                v18 = v25;
                v20 = v26;
                v21 = v26;
                while (v27 == 0 || v27 < 0 != ((v27 ^ v25) & (v25 ^ v15)) < 0) {
                    // 0x100003cf0
                    v23 = v1 == 0 ? 0 : v20;
                    v25 = v18 + 1;
                    v26 = (0x100000000 * ___snprintf_chk(v23, v6, 0, -1, "%s%d") >> 32) + v20;
                    v27 = v25 - v15;
                    v18 = v25;
                    v20 = v26;
                    v21 = v26;
                }
            }
        } else {
            // 0x100003bd0
            v22 = v1 == 0 ? 0 : v30;
            v21 = (0x100000000 * ___snprintf_chk(v22, v6, 0, -1, "%s%d-%d") >> 32) + v30;
        }
        // 0x100003df4
        v28 = v15 + 1;
        v29 = v28 - v2;
    }
    // 0x100003e08
    return v21 - v1;
}

// Address range: 0x100003e20 - 0x100003ed4
int64_t entry_point(void) {
    // 0x100003e20
    int64_t v1; // bp-156, 0x100003e20
    _memcpy(&v1, &g1, 132);
    _malloc((int32_t)function_100003af8() + 1);
    function_100003af8();
    int32_t v2 = _printf("%s\n", &v1); // 0x100003e9c
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004010; // 0x100003eac
    if (v3 != *(int64_t *)*(int64_t *)0x100004010) {
        // 0x100003ec0
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003ec4
    return 0;
}

// Address range: 0x100003ed4 - 0x100003ee0
int64_t function_100003ed4(int64_t a1, int64_t a2, int64_t a3, int64_t a4, char * a5) {
    // 0x100003ed4
    return ___snprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003ee0 - 0x100003eec
int64_t function_100003ee0(int64_t a1) {
    // 0x100003ee0
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003eec - 0x100003ef8
int64_t * function_100003eec(int32_t size) {
    // 0x100003eec
    return _malloc(size);
}

// Address range: 0x100003ef8 - 0x100003f04
int64_t * function_100003ef8(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003ef8
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(char * format, ...) {
    // 0x100003f04
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include<stdlib.h>
#include<string.h>
#include<stdio.h>

int flag = 1;

void heapPermute(int n, int arr[],int arrLen){
	int temp;
	int i;
	
	if(n==1){
		printf("\n[");
		
		for(i=0;i<arrLen;i++)
			printf("%d,",arr[i]);
		printf("\b] Sign : %d",flag);
		
		flag*=-1;
	}
	else{
		for(i=0;i<n-1;i++){
			heapPermute(n-1,arr,arrLen);
			
			if(n%2==0){
				temp = arr[i];
				arr[i] = arr[n-1];
				arr[n-1] = temp;
			}
			else{
				temp = arr[0];
				arr[0] = arr[n-1];
				arr[n-1] = temp;
			}
		}
		heapPermute(n-1,arr,arrLen);
	}
}

int main(int argC,char* argV[0])
{
	int *arr, i=0, count = 1;
	char* token;
	
	if(argC==1)
		printf("Usage : %s <comma separated list of integers>",argV[0]);
	else{
		while(argV[1][i]!=00){
			if(argV[1][i++]==',')
				count++;
		}
		
		arr = (int*)malloc(count*sizeof(int));
		
		i = 0;
		
		token = strtok(argV[1],",");
		
		while(token!=NULL){
			arr[i++] = atoi(token);
			token = strtok(NULL,",");
		}
		
		heapPermute(i,arr,count);
	}
		
	return 0;
}
`,`#include "permutations-by-swapping.h"



ulong _heapPermute(int param_1,undefined4 *param_2,int param_3)

{
  undefined4 uVar1;
  uint uVar2;
  ulong uVar3;
  int local_2c;
  
  if (param_1 == 1) {
    _printf("\n[");
    for (local_2c = 0; local_2c < param_3; local_2c = local_2c + 1) {
      _printf("%d,");
    }
    uVar2 = _printf("\b] Sign : %d");
    uVar3 = (ulong)uVar2;
    _flag = -_flag;
  }
  else {
    for (local_2c = 0; local_2c < param_1 + -1; local_2c = local_2c + 1) {
      _heapPermute(param_1 + -1,param_2,param_3);
      if (param_1 % 2 == 0) {
        uVar1 = param_2[local_2c];
        param_2[local_2c] = param_2[param_1 + -1];
        param_2[param_1 + -1] = uVar1;
      }
      else {
        uVar1 = *param_2;
        *param_2 = param_2[param_1 + -1];
        param_2[param_1 + -1] = uVar1;
      }
    }
    uVar3 = _heapPermute(param_1 + -1,param_2,param_3);
  }
  return uVar3;
}



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  void *pvVar2;
  long lVar3;
  char *local_38;
  int local_30;
  int local_2c;
  
  local_2c = 0;
  local_30 = 1;
  if (param_1 == 1) {
    _printf("Usage : %s <comma separated list of integers>");
  }
  else {
    while (*(char *)(*(long *)(param_2 + 8) + (long)local_2c) != '\0') {
      lVar3 = (long)local_2c;
      local_2c = local_2c + 1;
      if (*(char *)(*(long *)(param_2 + 8) + lVar3) == ',') {
        local_30 = local_30 + 1;
      }
    }
    pvVar2 = _malloc((long)local_30 << 2);
    local_2c = 0;
    local_38 = _strtok(*(char **)(param_2 + 8),",");
    while (local_38 != (char *)0x0) {
      iVar1 = _atoi(local_38);
      lVar3 = (long)local_2c;
      local_2c = local_2c + 1;
      *(int *)((long)pvVar2 + lVar3 * 4) = iVar1;
      local_38 = _strtok((char *)0x0,",");
    }
    _heapPermute(local_2c,pvVar2,local_30);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strtok(char *param_1,char *param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strtok_100004018)();
  return pcVar1;
}


`
`#include<math.h>
#include<stdio.h>

double
meanAngle (double *angles, int size)
{
  double y_part = 0, x_part = 0;
  int i;

  for (i = 0; i < size; i++)
    {
      x_part += cos (angles[i] * M_PI / 180);
      y_part += sin (angles[i] * M_PI / 180);
    }

  return atan2 (y_part / size, x_part / size) * 180 / M_PI;
}

int
main ()
{
  double angleSet1[] = { 350, 10 };
  double angleSet2[] = { 90, 180, 270, 360};
  double angleSet3[] = { 10, 20, 30};

  printf ("\nMean Angle for 1st set : %lf degrees", meanAngle (angleSet1, 2));
  printf ("\nMean Angle for 2nd set : %lf degrees", meanAngle (angleSet2, 4));
  printf ("\nMean Angle for 3rd set : %lf degrees\n", meanAngle (angleSet3, 3));
  return 0;
}
`,`#include "averages-mean-angle.h"



undefined  [16] _meanAngle(long param_1,int param_2)

{
  double dVar1;
  undefined auVar2 [16];
  undefined4 local_34;
  undefined8 local_30;
  undefined8 local_28;
  
  local_28 = 0.0;
  local_30 = 0.0;
  for (local_34 = 0; local_34 < param_2; local_34 = local_34 + 1) {
    dVar1 = (double)_cos((*(double *)(param_1 + (long)local_34 * 8) * 3.141592653589793) / 180.0);
    local_30 = local_30 + dVar1;
    dVar1 = (double)_sin((*(double *)(param_1 + (long)local_34 * 8) * 3.141592653589793) / 180.0);
    local_28 = local_28 + dVar1;
  }
  dVar1 = (double)_atan2(local_28 / (double)(long)param_2,local_30 / (double)(long)param_2);
  auVar2._0_8_ = (dVar1 * 180.0) / 3.141592653589793;
  auVar2._8_8_ = 0;
  return auVar2;
}



undefined8 entry(void)

{
  int iVar1;
  undefined8 local_70;
  undefined8 uStack_68;
  undefined8 local_60;
  undefined8 local_50;
  undefined8 uStack_48;
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  undefined8 uStack_28;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_28 = 0x4024000000000000;
  local_30 = 0x4075e00000000000;
  uStack_48 = 0x4066800000000000;
  local_50 = 0x4056800000000000;
  uStack_38 = 0x4076800000000000;
  local_40 = 0x4070e00000000000;
  uStack_68 = 0x4034000000000000;
  local_70 = 0x4024000000000000;
  local_60 = 0x403e000000000000;
  _meanAngle(&local_30,2);
  _printf("\nMean Angle for 1st set : %lf degrees");
  _meanAngle(&local_50,4);
  _printf("\nMean Angle for 2nd set : %lf degrees");
  _meanAngle(&local_70,3);
  iVar1 = _printf("\nMean Angle for 3rd set : %lf degrees\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e9c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void _atan2(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__atan2_100004010)();
  return;
}



void _cos(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cos_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



void _sin(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__sin_100004028)();
  return;
}


`
`#include<stdlib.h>
#include<math.h>
#include<stdio.h>

typedef struct
{
  int hour, minute, second;
} digitime;

double
timeToDegrees (digitime time)
{
  return (360 * time.hour / 24.0 + 360 * time.minute / (24 * 60.0) +
          360 * time.second / (24 * 3600.0));
}

digitime
timeFromDegrees (double angle)
{
  digitime d;
  double totalSeconds = 24 * 60 * 60 * angle / 360;

  d.second = (int) totalSeconds % 60;
  d.minute = ((int) totalSeconds % 3600 - d.second) / 60;
  d.hour = (int) totalSeconds / 3600;

  return d;
}

double
meanAngle (double *angles, int size)
{
  double y_part = 0, x_part = 0;
  int i;

  for (i = 0; i < size; i++)
    {
      x_part += cos (angles[i] * M_PI / 180);
      y_part += sin (angles[i] * M_PI / 180);
    }

  return atan2 (y_part / size, x_part / size) * 180 / M_PI;
}

int
main ()
{
  digitime *set, meanTime;
  int inputs, i;
  double *angleSet, angleMean;

  printf ("Enter number of inputs : ");
  scanf ("%d", &inputs);
  set = malloc (inputs * sizeof (digitime));
  angleSet = malloc (inputs * sizeof (double));
  printf ("\n\nEnter the data separated by a space between each unit : ");

  for (i = 0; i < inputs; i++)
    {
      scanf ("%d:%d:%d", &set[i].hour, &set[i].minute, &set[i].second);
      angleSet[i] = timeToDegrees (set[i]);
    }

  meanTime = timeFromDegrees (360 + meanAngle (angleSet, inputs));

  printf ("\n\nThe mean time is : %d:%d:%d", meanTime.hour, meanTime.minute,
          meanTime.second);
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039f8(void);
int64_t function_100003ab4(void);
int64_t function_100003ba0(void);
int64_t function_100003eac(int64_t a1);
float64_t function_100003eb8(float64_t a1, float64_t a2);
float64_t function_100003ec4(float64_t a1);
int64_t * function_100003ed0(int32_t size);
int32_t function_100003edc(char * format, ...);
int32_t function_100003ee8(char * format, ...);
float64_t function_100003ef4(float64_t a1);

// --------------------- Global Variables ---------------------

float64_t g1 = 86400.0; // 0x100003f00
float64_t g2 = 360.0; // 0x100003f10

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
float64_t _atan2(float64_t a1, float64_t a2);
float64_t _cos(float64_t a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _scanf(char * a1, ...);
float64_t _sin(float64_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000039f8 - 0x100003ab4
int64_t function_1000039f8(void) {
    // 0x1000039f8
    int64_t result; // 0x1000039f8
    return result;
}

// Address range: 0x100003ab4 - 0x100003ba0
int64_t function_100003ab4(void) {
    // 0x100003b8c
    float64_t v1; // 0x100003ab4
    return (int32_t)(v1 * g1 / g2) / 3600;
}

// Address range: 0x100003ba0 - 0x100003cbc
int64_t function_100003ba0(void) {
    // 0x100003ba0
    int64_t v1; // 0x100003ba0
    int32_t v2 = v1; // 0x100003bb0
    int128_t v3; // 0x100003ba0
    int64_t v4 = v3;
    int32_t v5 = -v2; // 0x100003bd0
    int32_t v6 = 0; // 0x100003bd8
    int128_t v7; // 0x100003c70
    if (v5 < 0 == (v5 & v2) < 0) {
        // 0x100003c64
        v7 = __asm_sshll(0.0f, 0);
        __asm_sshll(0.0f, 0);
        return _atan2((float64_t)v4, (float64_t)(int64_t)v7);
    }
    float64_t v8 = _cos((float64_t)v4); // 0x100003c0c
    v6++;
    int64_t v9 = (float32_t)_sin(v8);
    int32_t v10 = v6 - v2; // 0x100003bd0
    int64_t v11 = v9; // 0x100003bd8
    while (v10 < 0 != ((v10 ^ v6) & (v6 ^ v2)) < 0) {
        // 0x100003be0
        v8 = _cos((float64_t)v9);
        v6++;
        v9 = (float32_t)_sin(v8);
        v10 = v6 - v2;
        v11 = v9;
    }
    // 0x100003c64
    v7 = __asm_sshll(0.0f, 0);
    __asm_sshll(0.0f, 0);
    return _atan2((float64_t)v11, (float64_t)(int64_t)v7);
}

// Address range: 0x100003cbc - 0x100003eac
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003cd0
    _printf("Enter number of inputs : ");
    int64_t v2; // 0x100003cbc
    _scanf("%d", (int64_t *)v2);
    int32_t v3; // 0x100003cbc
    int64_t * v4 = _malloc(12 * v3); // 0x100003d0c
    int64_t * v5 = _malloc(8 * v3); // 0x100003d1c
    _printf("\n\nEnter the data separated by a space between each unit : ");
    int32_t v6 = -v3; // 0x100003d40
    if (v6 < 0 != (v3 & v6) < 0) {
        int32_t v7 = 0; // 0x100003df0
        int64_t v8; // 0x100003cbc
        _scanf("%d:%d:%d", (int64_t *)v8, (int64_t *)v2, (int64_t *)v2);
        int64_t v9 = v7; // 0x100003db4
        function_1000039f8();
        float64_t v10; // 0x100003cbc
        *(int64_t *)(8 * v9 + (int64_t)v5) = (int64_t)v10;
        v7++;
        while (v7 - v3 < 0 != ((v7 - v3 ^ v7) & (v7 ^ v3)) < 0) {
            // 0x100003d50
            v8 = (int64_t)*(int32_t *)((int64_t)v4 + 8 + 12 * v9);
            _scanf("%d:%d:%d", (int64_t *)v8, (int64_t *)v2, (int64_t *)v2);
            v9 = v7;
            function_1000039f8();
            float64_t v11; // 0x100003cbc
            *(int64_t *)(8 * v9 + (int64_t)v5) = (int64_t)v11;
            v7++;
        }
    }
    // 0x100003dfc
    function_100003ba0();
    function_100003ab4();
    int32_t v12 = _printf("\n\nThe mean time is : %d:%d:%d", (int64_t)v3, v2, v2); // 0x100003e74
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e98
        ___stack_chk_fail((int64_t)v12);
    }
    // 0x100003e9c
    return 0;
}

// Address range: 0x100003eac - 0x100003eb8
int64_t function_100003eac(int64_t a1) {
    // 0x100003eac
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003eb8 - 0x100003ec4
float64_t function_100003eb8(float64_t a1, float64_t a2) {
    // 0x100003eb8
    return _atan2(a1, a2);
}

// Address range: 0x100003ec4 - 0x100003ed0
float64_t function_100003ec4(float64_t a1) {
    // 0x100003ec4
    return _cos(a1);
}

// Address range: 0x100003ed0 - 0x100003edc
int64_t * function_100003ed0(int32_t size) {
    // 0x100003ed0
    return _malloc(size);
}

// Address range: 0x100003edc - 0x100003ee8
int32_t function_100003edc(char * format, ...) {
    // 0x100003edc
    return _printf(format);
}

// Address range: 0x100003ee8 - 0x100003ef4
int32_t function_100003ee8(char * format, ...) {
    // 0x100003ee8
    return _scanf(format);
}

// Address range: 0x100003ef4 - 0x100003f00
float64_t function_100003ef4(float64_t a1) {
    // 0x100003ef4
    return _sin(a1);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 11

`
`#include <stdio.h>
#include <stdlib.h>

int isprime(int n)
{
	int p;
	for (p = 2; p*p <= n; p++)
		if (n%p == 0) return 0;
	return n > 2;
}

int spiral(int w, int h, int x, int y)
{
	return y ? w + spiral(h - 1, w, y - 1, w - x - 1) : x;
}

int main(int c, char **v)
{
	int i, j, w = 50, h = 50, s = 1;
	if (c > 1 && (w = atoi(v[1])) <= 0) w = 50;
	if (c > 2 && (h = atoi(v[2])) <= 0) h = w;
	if (c > 3 && (s = atoi(v[3])) <= 0) s = 1;

	for (i = 0; i < h; i++) {
		for (j = 0; j < w; j++)
			putchar(isprime(w*h + s - 1 - spiral(w, h, j, i))[" #"]);
		putchar('\n');
	}
	return 0;
}
`,`#include "ulam-spiral-for-primes--2.h"



bool _isprime(int param_1)

{
  int iVar1;
  int local_c;
  
  local_c = 2;
  while( true ) {
    if (param_1 < local_c * local_c) {
      return 2 < param_1;
    }
    iVar1 = 0;
    if (local_c != 0) {
      iVar1 = param_1 / local_c;
    }
    if (param_1 == iVar1 * local_c) break;
    local_c = local_c + 1;
  }
  return false;
}



int _spiral(int param_1,int param_2,int param_3,int param_4)

{
  int local_24;
  
  local_24 = param_3;
  if (param_4 != 0) {
    local_24 = _spiral(param_2 + -1,param_1,param_4 + -1,(param_1 - param_3) + -1);
    local_24 = param_1 + local_24;
  }
  return local_24;
}



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  
  local_2c = 0x32;
  local_30 = 0x32;
  local_34 = 1;
  if (1 < param_1) {
    local_2c = _atoi(*(char **)(param_2 + 8));
    if (local_2c < 1) {
      local_2c = 0x32;
    }
  }
  if (2 < param_1) {
    local_30 = _atoi(*(char **)(param_2 + 0x10));
    if (local_30 < 1) {
      local_30 = local_2c;
    }
  }
  if (3 < param_1) {
    local_34 = _atoi(*(char **)(param_2 + 0x18));
    if (local_34 < 1) {
      local_34 = 1;
    }
  }
  for (local_24 = 0; local_24 < local_30; local_24 = local_24 + 1) {
    for (local_28 = 0; local_28 < local_2c; local_28 = local_28 + 1) {
      iVar1 = _spiral(local_2c,local_30,local_28,local_24);
      iVar1 = _isprime((local_2c * local_30 + local_34 + -1) - iVar1);
      _putchar((int)" #"[iVar1]);
    }
    _putchar(10);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned char byte;
int w = 0, h = 0, verbose = 0;
unsigned long count = 0;

byte **hor, **ver, **vis;
byte **c = 0;

enum { U = 1, D = 2, L = 4, R = 8 };

byte ** alloc2(int w, int h)
{
	int i;
	byte **x = calloc(1, sizeof(byte*) * h + h * w);
	x[0] = (byte *)&x[h];
	for (i = 1; i < h; i++)
		x[i] = x[i - 1] + w;
	return x;
}

void show()
{
	int i, j, v, last_v;
	printf("%ld\n", count);
#if 0
	for (i = 0; i <= h; i++) {
		for (j = 0; j <= w; j++)
			printf("%d ", hor[i][j]);
		puts("");
	}
	puts("");

	for (i = 0; i <= h; i++) {
		for (j = 0; j <= w; j++)
			printf("%d ", ver[i][j]);
		puts("");
	}
	puts("");
#endif
	for (i = 0; i < h; i++) {
		if (!i) v = last_v = 0;
		else last_v = v = hor[i][0] ? !last_v : last_v;

		for (j = 0; j < w; v = ver[i][++j] ? !v : v)
			printf(v ? "\033[31m[]" : "\033[33m{}");
		puts("\033[m");
	}
	putchar('\n');
}

void walk(int y, int x)
{
	if (x < 0 || y < 0 || x > w || y > h) return;

	if (!x || !y || x == w || y == h) {
		++count;
		if (verbose) show();
		return;
	}

	if (vis[y][x]) return;
	vis[y][x]++; vis[h - y][w - x]++;

	if (x && !hor[y][x - 1]) {
		hor[y][x - 1] = hor[h - y][w - x] = 1;
		walk(y, x - 1);
		hor[y][x - 1] = hor[h - y][w - x] = 0;
	}
	if (x < w && !hor[y][x]) {
		hor[y][x] = hor[h - y][w - x - 1] = 1;
		walk(y, x + 1);
		hor[y][x] = hor[h - y][w - x - 1] = 0;
	}

	if (y && !ver[y - 1][x]) {
		ver[y - 1][x] = ver[h - y][w - x] = 1;
		walk(y - 1, x);
		ver[y - 1][x] = ver[h - y][w - x] = 0;
	}

	if (y < h && !ver[y][x]) {
		ver[y][x] = ver[h - y - 1][w - x] = 1;
		walk(y + 1, x);
		ver[y][x] = ver[h - y - 1][w - x] = 0;
	}

	vis[y][x]--; vis[h - y][w - x]--;
}

void cut(void)
{
	if (1 & (h * w)) return;

	hor = alloc2(w + 1, h + 1);
	ver = alloc2(w + 1, h + 1);
	vis = alloc2(w + 1, h + 1);

	if (h & 1) {
		ver[h/2][w/2] = 1;
		walk(h / 2, w / 2);
	} else if (w & 1) {
		hor[h/2][w/2] = 1;
		walk(h / 2, w / 2);
	} else {
		vis[h/2][w/2] = 1;

		hor[h/2][w/2-1] = hor[h/2][w/2] = 1;
		walk(h / 2, w / 2 - 1);
		hor[h/2][w/2-1] = hor[h/2][w/2] = 0;

		ver[h/2 - 1][w/2] = ver[h/2][w/2] = 1;
		walk(h / 2 - 1, w/2);
	}
}

void cwalk(int y, int x, int d)
{
	if (!y || y == h || !x || x == w) {
		++count;
		return;
	}
	vis[y][x] = vis[h-y][w-x] = 1;

	if (x && !vis[y][x-1])
		cwalk(y, x - 1, d|1);
	if ((d&1) && x < w && !vis[y][x+1])
		cwalk(y, x + 1, d|1);
	if (y && !vis[y-1][x])
		cwalk(y - 1, x, d|2);
	if ((d&2) && y < h && !vis[y + 1][x])
		cwalk(y + 1, x, d|2);

	vis[y][x] = vis[h-y][w-x] = 0;
}

void count_only(void)
{
	int t;
	long res;
	if (h * w & 1) return;
	if (h & 1) t = h, h = w, w = t;

	vis = alloc2(w + 1, h + 1);
	vis[h/2][w/2] = 1;

	if (w & 1) vis[h/2][w/2 + 1] = 1;
	if (w > 1) {
		cwalk(h/2, w/2 - 1, 1);
		res = 2 * count - 1;
		count = 0;
		if (w != h)
			cwalk(h/2+1, w/2, (w & 1) ? 3 : 2);

		res += 2 * count - !(w & 1);
	} else {
		res = 1;
	}
	if (w == h) res = 2 * res + 2;
	count = res;
}

int main(int c, char **v)
{
	int i;

	for (i = 1; i < c; i++) {
		if (v[i][0] == '-' && v[i][1] == 'v' && !v[i][2]) {
			verbose = 1;
		} else if (!w) {
			w = atoi(v[i]);
			if (w <= 0) goto bail;
		} else if (!h) {
			h = atoi(v[i]);
			if (h <= 0) goto bail;
		} else
			goto bail;
	}
	if (!w) goto bail;
	if (!h) h = w;

	if (verbose) cut();
	else count_only();

	printf("Total: %ld\n", count);
	return 0;

bail:	fprintf(stderr, "bad args\n");
	return 1;
}
`,`#include "cut-a-rectangle-3.h"



long * _alloc2(int param_1,int param_2)

{
  long *plVar1;
  int local_1c;
  
  plVar1 = (long *)_calloc(1,(long)param_2 * 8 + (long)(param_2 * param_1));
  *plVar1 = (long)(plVar1 + param_2);
  for (local_1c = 1; local_1c < param_2; local_1c = local_1c + 1) {
    plVar1[local_1c] = plVar1[local_1c + -1] + (long)param_1;
  }
  return plVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _show(void)

{
  char *pcVar1;
  int iVar2;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  int local_18;
  int local_14;
  
  _printf("%ld\n");
  for (local_14 = 0; local_14 < __h; local_14 = local_14 + 1) {
    if (local_14 == 0) {
      local_1c = 0;
    }
    else {
      if (**(char **)(__hor + (long)local_14 * 8) == '\0') {
        local_24 = local_20;
      }
      else {
        local_24 = (uint)(local_20 == 0);
      }
      local_1c = local_24;
    }
    local_20 = local_1c;
    local_18 = 0;
    while (local_18 < __w) {
      pcVar1 = "\x1b[31m[]";
      if (local_1c == 0) {
        pcVar1 = "\x1b[33m{}";
      }
      _printf(pcVar1);
      local_18 = local_18 + 1;
      if (*(char *)(*(long *)(__ver + (long)local_14 * 8) + (long)local_18) == '\0') {
        local_28 = local_1c;
      }
      else {
        local_28 = (uint)(local_1c == 0);
      }
      local_1c = local_28;
    }
    _puts("\x1b[m");
  }
  iVar2 = _putchar(10);
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram

void _walk(int param_1,int param_2)

{
  char *pcVar1;
  
  if ((((-1 < param_2) && (-1 < param_1)) && (param_2 <= __w)) && (param_1 <= __h)) {
    if (((param_2 == 0) || (param_1 == 0)) || ((param_2 == __w || (param_1 == __h)))) {
      __count = __count + 1;
      if (__verbose != 0) {
        _show();
      }
    }
    else if (*(char *)(*(long *)(__vis + (long)param_1 * 8) + (long)param_2) == '\0') {
      pcVar1 = (char *)(*(long *)(__vis + (long)param_1 * 8) + (long)param_2);
      *pcVar1 = *pcVar1 + '\x01';
      pcVar1 = (char *)(*(long *)(__vis + (long)(__h - param_1) * 8) + (long)(__w - param_2));
      *pcVar1 = *pcVar1 + '\x01';
      if ((param_2 != 0) &&
         (*(char *)(*(long *)(__hor + (long)param_1 * 8) + (long)(param_2 + -1)) == '\0')) {
        *(undefined *)(*(long *)(__hor + (long)(__h - param_1) * 8) + (long)(__w - param_2)) = 1;
        *(undefined *)(*(long *)(__hor + (long)param_1 * 8) + (long)(param_2 + -1)) = 1;
        _walk(param_1,param_2 + -1);
        *(undefined *)(*(long *)(__hor + (long)(__h - param_1) * 8) + (long)(__w - param_2)) = 0;
        *(undefined *)(*(long *)(__hor + (long)param_1 * 8) + (long)(param_2 + -1)) = 0;
      }
      if ((param_2 < __w) &&
         (*(char *)(*(long *)(__hor + (long)param_1 * 8) + (long)param_2) == '\0')) {
        *(undefined *)(*(long *)(__hor + (long)(__h - param_1) * 8) + (long)((__w - param_2) + -1))
             = 1;
        *(undefined *)(*(long *)(__hor + (long)param_1 * 8) + (long)param_2) = 1;
        _walk(param_1,param_2 + 1);
        *(undefined *)(*(long *)(__hor + (long)(__h - param_1) * 8) + (long)((__w - param_2) + -1))
             = 0;
        *(undefined *)(*(long *)(__hor + (long)param_1 * 8) + (long)param_2) = 0;
      }
      if ((param_1 != 0) &&
         (*(char *)(*(long *)(__ver + (long)(param_1 + -1) * 8) + (long)param_2) == '\0')) {
        *(undefined *)(*(long *)(__ver + (long)(__h - param_1) * 8) + (long)(__w - param_2)) = 1;
        *(undefined *)(*(long *)(__ver + (long)(param_1 + -1) * 8) + (long)param_2) = 1;
        _walk(param_1 + -1,param_2);
        *(undefined *)(*(long *)(__ver + (long)(__h - param_1) * 8) + (long)(__w - param_2)) = 0;
        *(undefined *)(*(long *)(__ver + (long)(param_1 + -1) * 8) + (long)param_2) = 0;
      }
      if ((param_1 < __h) &&
         (*(char *)(*(long *)(__ver + (long)param_1 * 8) + (long)param_2) == '\0')) {
        *(undefined *)(*(long *)(__ver + (long)((__h - param_1) + -1) * 8) + (long)(__w - param_2))
             = 1;
        *(undefined *)(*(long *)(__ver + (long)param_1 * 8) + (long)param_2) = 1;
        _walk(param_1 + 1,param_2);
        *(undefined *)(*(long *)(__ver + (long)((__h - param_1) + -1) * 8) + (long)(__w - param_2))
             = 0;
        *(undefined *)(*(long *)(__ver + (long)param_1 * 8) + (long)param_2) = 0;
      }
      pcVar1 = (char *)(*(long *)(__vis + (long)param_1 * 8) + (long)param_2);
      *pcVar1 = *pcVar1 + -1;
      pcVar1 = (char *)(*(long *)(__vis + (long)(__h - param_1) * 8) + (long)(__w - param_2));
      *pcVar1 = *pcVar1 + -1;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram

void _cut(void)

{
  if ((__h * __w & 1) == 0) {
    __hor = _alloc2(__w + 1,__h + 1);
    __ver = _alloc2(__w + 1,__h + 1);
    __vis = _alloc2(__w + 1,__h + 1);
    if ((__h & 1) == 0) {
      if ((__w & 1) == 0) {
        *(undefined *)(*(long *)(__vis + (long)((int)__h / 2) * 8) + (long)((int)__w / 2)) = 1;
        *(undefined *)(*(long *)(__hor + (long)((int)__h / 2) * 8) + (long)((int)__w / 2)) = 1;
        *(undefined *)(*(long *)(__hor + (long)((int)__h / 2) * 8) + (long)((int)__w / 2 + -1)) = 1;
        _walk((int)__h / 2,(int)__w / 2 + -1);
        *(undefined *)(*(long *)(__hor + (long)((int)__h / 2) * 8) + (long)((int)__w / 2)) = 0;
        *(undefined *)(*(long *)(__hor + (long)((int)__h / 2) * 8) + (long)((int)__w / 2 + -1)) = 0;
        *(undefined *)(*(long *)(__ver + (long)((int)__h / 2) * 8) + (long)((int)__w / 2)) = 1;
        *(undefined *)(*(long *)(__ver + (long)((int)__h / 2 + -1) * 8) + (long)((int)__w / 2)) = 1;
        _walk((int)__h / 2 + -1,(int)__w / 2);
      }
      else {
        *(undefined *)(*(long *)(__hor + (long)((int)__h / 2) * 8) + (long)((int)__w / 2)) = 1;
        _walk((int)__h / 2,(int)__w / 2);
      }
    }
    else {
      *(undefined *)(*(long *)(__ver + (long)((int)__h / 2) * 8) + (long)((int)__w / 2)) = 1;
      _walk((int)__h / 2,(int)__w / 2);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _cwalk(int param_1,int param_2,uint param_3)

{
  if ((((param_1 == 0) || (param_1 == __h)) || (param_2 == 0)) || (param_2 == __w)) {
    __count = __count + 1;
  }
  else {
    *(undefined *)(*(long *)(__vis + (long)(__h - param_1) * 8) + (long)(__w - param_2)) = 1;
    *(undefined *)(*(long *)(__vis + (long)param_1 * 8) + (long)param_2) = 1;
    if ((param_2 != 0) &&
       (*(char *)(*(long *)(__vis + (long)param_1 * 8) + (long)(param_2 + -1)) == '\0')) {
      _cwalk(param_1,param_2 + -1,param_3 | 1);
    }
    if ((((param_3 & 1) != 0) && (param_2 < __w)) &&
       (*(char *)(*(long *)(__vis + (long)param_1 * 8) + (long)(param_2 + 1)) == '\0')) {
      _cwalk(param_1,param_2 + 1,param_3 | 1);
    }
    if ((param_1 != 0) &&
       (*(char *)(*(long *)(__vis + (long)(param_1 + -1) * 8) + (long)param_2) == '\0')) {
      _cwalk(param_1 + -1,param_2,param_3 | 2);
    }
    if ((((param_3 & 2) != 0) && (param_1 < __h)) &&
       (*(char *)(*(long *)(__vis + (long)(param_1 + 1) * 8) + (long)param_2) == '\0')) {
      _cwalk(param_1 + 1,param_2,param_3 | 2);
    }
    *(undefined *)(*(long *)(__vis + (long)(__h - param_1) * 8) + (long)(__w - param_2)) = 0;
    *(undefined *)(*(long *)(__vis + (long)param_1 * 8) + (long)param_2) = 0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram

void _count_only(void)

{
  uint uVar1;
  undefined4 uVar2;
  long lVar3;
  undefined8 local_20;
  
  uVar1 = __h;
  if ((__h * __w & 1) == 0) {
    if ((__h & 1) != 0) {
      __h = __w;
      __w = uVar1;
    }
    __vis = _alloc2(__w + 1,__h + 1);
    *(undefined *)(*(long *)(__vis + (long)((int)__h / 2) * 8) + (long)((int)__w / 2)) = 1;
    if ((__w & 1) != 0) {
      *(undefined *)(*(long *)(__vis + (long)((int)__h / 2) * 8) + (long)((int)__w / 2 + 1)) = 1;
    }
    if ((int)__w < 2) {
      local_20 = 1;
    }
    else {
      _cwalk((int)__h / 2,(int)__w / 2 + -1,1);
      lVar3 = __count * 2;
      __count = 0;
      if (__w != __h) {
        uVar2 = 3;
        if ((__w & 1) == 0) {
          uVar2 = 2;
        }
        _cwalk((int)__h / 2 + 1,(int)__w / 2,uVar2);
      }
      local_20 = lVar3 + -1 + (__count * 2 - (ulong)((__w & 1) == 0));
    }
    if (__w == __h) {
      local_20 = local_20 * 2 + 2;
    }
    __count = local_20;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 entry(int param_1,long param_2)

{
  int iVar1;
  int local_24;
  undefined4 local_14;
  
  for (local_24 = 1; local_24 < param_1; local_24 = local_24 + 1) {
    if (((**(char **)(param_2 + (long)local_24 * 8) == '-') &&
        (*(char *)(*(long *)(param_2 + (long)local_24 * 8) + 1) == 'v')) &&
       (*(char *)(*(long *)(param_2 + (long)local_24 * 8) + 2) == '\0')) {
      __verbose = 1;
    }
    else {
      if (__w == 0) {
        __w = _atoi(*(char **)(param_2 + (long)local_24 * 8));
        iVar1 = __w;
      }
      else {
        if (__h != 0) goto LAB_100003efc;
        __h = _atoi(*(char **)(param_2 + (long)local_24 * 8));
        iVar1 = __h;
      }
      if (iVar1 < 1) goto LAB_100003efc;
    }
  }
  if (__w == 0) {
LAB_100003efc:
    _fprintf(*(FILE **)PTR____stderrp_100004000,"bad args\n");
    local_14 = 1;
  }
  else {
    if (__h == 0) {
      __h = __w;
    }
    if (__verbose == 0) {
      _count_only();
    }
    else {
      _cut();
    }
    _printf("Total: %ld\n");
    local_14 = 0;
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004028)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004030)((int)param_1);
  return iVar1;
}


`
`#include <assert.h>
#include <stdio.h>

int main(int c, char **v)
{
	unsigned int n = 1 << (c - 1), i = n, j, k;
	assert(n);

	while (i--) {
		if (!(i & (i + (i & -(int)i)))) // consecutive 1s
			continue;

		for (j = n, k = 1; j >>= 1; k++)
			if (i & j) printf("%s ", v[k]);

		putchar('\n');
	}

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f58(char * a1, char * a2, int64_t a3, int64_t a4);
int32_t function_100003f64(char * format, ...);
int32_t function_100003f70(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___assert_rtn(char * a1, char * a2, int64_t a3, int64_t a4);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003df0 - 0x100003f58
int64_t entry_point(void) {
    // 0x100003df0
    int64_t v1; // 0x100003df0
    uint32_t v2 = (int32_t)v1 - 1; // 0x100003e10
    int32_t v3 = 1 << v2; // 0x100003e14
    int32_t v4 = v3 - 1;
    uint32_t v5; // 0x100003df0
    int32_t v6; // 0x100003df0
    if (((v4 & 1 - v3) + v4 & v4) != 0) {
        // 0x100003ed0
        if (v2 != 0) {
            v5 = v3;
            v6 = v5 / 2;
            if ((v6 & v4) != 0) {
                // 0x100003f04
                _printf("%s ", (char *)v1);
            }
            // 0x100003f2c
            while (v5 >= 4) {
                // 0x100003eec
                v5 = v6;
                v6 = v5 / 2;
                if ((v6 & v4) != 0) {
                    // 0x100003f04
                    _printf("%s ", (char *)v1);
                }
            }
        }
        // 0x100003f3c
        _putchar(10);
    }
    while (v4 != 0) {
        int32_t v7 = v4;
        v4 = v7 - 1;
        if (((v4 & 1 - v7) + v4 & v4) != 0) {
            // 0x100003ed0
            if (v2 != 0) {
                v5 = v3;
                v6 = v5 / 2;
                if ((v6 & v4) != 0) {
                    // 0x100003f04
                    _printf("%s ", (char *)v1);
                }
                // 0x100003f2c
                while (v5 >= 4) {
                    // 0x100003eec
                    v5 = v6;
                    v6 = v5 / 2;
                    if ((v6 & v4) != 0) {
                        // 0x100003f04
                        _printf("%s ", (char *)v1);
                    }
                }
            }
            // 0x100003f3c
            _putchar(10);
        }
    }
    // 0x100003f48
    return 0;
}

// Address range: 0x100003f58 - 0x100003f64
int64_t function_100003f58(char * a1, char * a2, int64_t a3, int64_t a4) {
    // 0x100003f58
    return ___assert_rtn(a1, a2, a3, a4);
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(int32_t c) {
    // 0x100003f70
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <stdint.h>
#include <ctype.h>

#define NELEMS(arr) (sizeof(arr) / sizeof(arr[0]))

#define da_dim(name, type)  type *name = NULL;          \
                            int _qy_ ## name ## _p = 0;  \
                            int _qy_ ## name ## _max = 0

#define da_redim(name)      do {if (_qy_ ## name ## _p >= _qy_ ## name ## _max) \
                                name = realloc(name, (_qy_ ## name ## _max += 32) * sizeof(name[0]));} while (0)

#define da_rewind(name)     _qy_ ## name ## _p = 0

#define da_append(name, x)  do {da_redim(name); name[_qy_ ## name ## _p++] = x;} while (0)

typedef unsigned char uchar;
typedef uchar code;

typedef enum { FETCH, STORE, PUSH, ADD, SUB, MUL, DIV, MOD, LT, GT, LE, GE, EQ, NE, AND,
    OR, NEG, NOT, JMP, JZ, PRTC, PRTS, PRTI, HALT
} Code_t;

typedef struct Code_map {
    char    *text;
    Code_t   op;
} Code_map;

Code_map code_map[] = {
    {"fetch",  FETCH},
    {"store",  STORE},
    {"push",   PUSH },
    {"add",    ADD  },
    {"sub",    SUB  },
    {"mul",    MUL  },
    {"div",    DIV  },
    {"mod",    MOD  },
    {"lt",     LT   },
    {"gt",     GT   },
    {"le",     LE   },
    {"ge",     GE   },
    {"eq",     EQ   },
    {"ne",     NE   },
    {"and",    AND  },
    {"or",     OR   },
    {"neg",    NEG  },
    {"not",    NOT  },
    {"jmp",    JMP  },
    {"jz",     JZ   },
    {"prtc",   PRTC },
    {"prts",   PRTS },
    {"prti",   PRTI },
    {"halt",   HALT },
};

FILE *source_fp;
da_dim(object, code);

void error(const char *fmt, ... ) {
    va_list ap;
    char buf[1000];

    va_start(ap, fmt);
    vsprintf(buf, fmt, ap);
    va_end(ap);
    printf("error: %s\n", buf);
    exit(1);
}

/*** Virtual Machine interpreter ***/
void run_vm(const code obj[], int32_t data[], int g_size, char **string_pool) {
    int32_t *sp = &data[g_size + 1];
    const code *pc = obj;

    again:
    switch (*pc++) {
        case FETCH: *sp++ = data[*(int32_t *)pc];  pc += sizeof(int32_t); goto again;
        case STORE: data[*(int32_t *)pc] = *--sp;  pc += sizeof(int32_t); goto again;
        case PUSH:  *sp++ = *(int32_t *)pc;        pc += sizeof(int32_t); goto again;
        case ADD:   sp[-2] += sp[-1]; --sp;                             goto again;
        case SUB:   sp[-2] -= sp[-1]; --sp;                             goto again;
        case MUL:   sp[-2] *= sp[-1]; --sp;                             goto again;
        case DIV:   sp[-2] /= sp[-1]; --sp;                             goto again;
        case MOD:   sp[-2] %= sp[-1]; --sp;                             goto again;
        case LT:    sp[-2] = sp[-2] <  sp[-1]; --sp;                    goto again;
        case GT:    sp[-2] = sp[-2] >  sp[-1]; --sp;                    goto again;
        case LE:    sp[-2] = sp[-2] <= sp[-1]; --sp;                    goto again;
        case GE:    sp[-2] = sp[-2] >= sp[-1]; --sp;                    goto again;
        case EQ:    sp[-2] = sp[-2] == sp[-1]; --sp;                    goto again;
        case NE:    sp[-2] = sp[-2] != sp[-1]; --sp;                    goto again;
        case AND:   sp[-2] = sp[-2] && sp[-1]; --sp;                    goto again;
        case OR:    sp[-2] = sp[-2] || sp[-1]; --sp;                    goto again;
        case NEG:   sp[-1] = -sp[-1];                                   goto again;
        case NOT:   sp[-1] = !sp[-1];                                   goto again;
        case JMP:   pc += *(int32_t *)pc;                               goto again;
        case JZ:    pc += (*--sp == 0) ? *(int32_t *)pc : (int32_t)sizeof(int32_t); goto again;
        case PRTC:  printf("%c", sp[-1]); --sp;                         goto again;
        case PRTS:  printf("%s", string_pool[sp[-1]]); --sp;            goto again;
        case PRTI:  printf("%d", sp[-1]); --sp;                         goto again;
        case HALT:                                                      break;
        default:    error("Unknown opcode %d\n", *(pc - 1));
    }
}

char *read_line(int *len) {
    static char *text = NULL;
    static int textmax = 0;

    for (*len = 0; ; (*len)++) {
        int ch = fgetc(source_fp);
        if (ch == EOF || ch == '\n') {
            if (*len == 0)
                return NULL;
            break;
        }
        if (*len + 1 >= textmax) {
            textmax = (textmax == 0 ? 128 : textmax * 2);
            text = realloc(text, textmax);
        }
        text[*len] = ch;
    }
    text[*len] = '\0';
    return text;
}

char *rtrim(char *text, int *len) {         // remove trailing spaces
    for (; *len > 0 && isspace(text[*len - 1]); --(*len))
        ;

    text[*len] = '\0';
    return text;
}

char *translate(char *st) {
    char *p, *q;
    if (st[0] == '"')                       // skip leading " if there
        ++st;
    p = q = st;

    while ((*p++ = *q++) != '\0') {
        if (q[-1] == '\\') {
            if (q[0] == 'n') {
                p[-1] = '\n';
                ++q;
            } else if (q[0] == '\\') {
                ++q;
            }
        }
        if (q[0] == '"' && q[1] == '\0')    // skip trialing " if there
            ++q;
    }

    return st;
}

/* convert an opcode string into its byte value */
int findit(const char text[], int offset) {
    for (size_t i = 0; i < sizeof(code_map) / sizeof(code_map[0]); i++) {
        if (strcmp(code_map[i].text, text) == 0)
            return code_map[i].op;
    }
    error("Unknown instruction %s at %d\n", text, offset);
    return -1;
}

void emit_byte(int c) {
    da_append(object, (uchar)c);
}

void emit_int(int32_t n) {
    union {
        int32_t n;
        unsigned char c[sizeof(int32_t)];
    } x;

    x.n = n;

    for (size_t i = 0; i < sizeof(x.n); ++i) {
        emit_byte(x.c[i]);
    }
}

/*
Datasize: 5 Strings: 3
" is prime\n"
"Total primes found: "
"\n"
 154 jmp    (-73) 82
 164 jz     (32) 197
 175 push  0
 159 fetch [4]
 149 store [3]
 */

/* Load code into global array object, return the string pool and data size */
char **load_code(int *ds) {
    int line_len, n_strings;
    char **string_pool;
    char *text = read_line(&line_len);
    text = rtrim(text, &line_len);

    strtok(text, " ");                      // skip "Datasize:"
    *ds = atoi(strtok(NULL, " "));          // get actual data_size
    strtok(NULL, " ");                      // skip "Strings:"
    n_strings = atoi(strtok(NULL, " "));    // get number of strings

    string_pool = malloc(n_strings * sizeof(char *));
    for (int i = 0; i < n_strings; ++i) {
        text = read_line(&line_len);
        text = rtrim(text, &line_len);
        text = translate(text);
        string_pool[i] = strdup(text);
    }

    for (;;) {
        int len;

        text = read_line(&line_len);
        if (text == NULL)
            break;
        text = rtrim(text, &line_len);

        int offset = atoi(strtok(text, " "));   // get the offset
        char *instr = strtok(NULL, " ");    // get the instruction
        int opcode = findit(instr, offset);
        emit_byte(opcode);
        char *operand = strtok(NULL, " ");

        switch (opcode) {
            case JMP: case JZ:
                operand++;                  // skip the '('
                len = strlen(operand);
                operand[len - 1] = '\0';    // remove the ')'
                emit_int(atoi(operand));
                break;
            case PUSH:
                emit_int(atoi(operand));
                break;
            case FETCH: case STORE:
                operand++;                  // skip the '['
                len = strlen(operand);
                operand[len - 1] = '\0';    // remove the ']'
                emit_int(atoi(operand));
                break;
        }
    }
    return string_pool;
}

void init_io(FILE **fp, FILE *std, const char mode[], const char fn[]) {
    if (fn[0] == '\0')
        *fp = std;
    else if ((*fp = fopen(fn, mode)) == NULL)
        error(0, 0, "Can't open %s\n", fn);
}

int main(int argc, char *argv[]) {
    init_io(&source_fp, stdin,  "r",  argc > 1 ? argv[1] : "");
    int data_size;
    char **string_pool = load_code(&data_size);
    int data[1000 + data_size];
    run_vm(object, data, data_size, string_pool);
}
`,`#include "compiler-virtual-machine-interpreter.h"



void _error(undefined8 param_1)

{
  undefined auStack_410 [1000];
  undefined8 local_28;
  
  local_28 = *(undefined8 *)PTR____stack_chk_guard_100004010;
  ___vsprintf_chk(auStack_410,0,1000,param_1,&stack0x00000000);
  _printf("error: %s\n");
                    // WARNING: Subroutine does not return
  _exit(1);
}



int * _run_vm(int *param_1,long param_2,int param_3)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int *piVar4;
  int local_54;
  uint local_50;
  uint local_4c;
  int *local_40;
  int *local_38;
  
  local_40 = param_1;
  local_38 = (int *)(param_2 + (long)(param_3 + 1) * 4);
  do {
    piVar4 = (int *)((long)local_40 + 1);
    switch(*(undefined *)local_40) {
    case 0:
      *local_38 = *(int *)(param_2 + (long)*piVar4 * 4);
      local_40 = (int *)((long)local_40 + 5);
      local_38 = local_38 + 1;
      break;
    case 1:
      *(int *)(param_2 + (long)*piVar4 * 4) = local_38[-1];
      local_40 = (int *)((long)local_40 + 5);
      local_38 = local_38 + -1;
      break;
    case 2:
      *local_38 = *piVar4;
      local_40 = (int *)((long)local_40 + 5);
      local_38 = local_38 + 1;
      break;
    case 3:
      local_38[-2] = local_38[-2] + local_38[-1];
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 4:
      local_38[-2] = local_38[-2] - local_38[-1];
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 5:
      local_38[-2] = local_38[-2] * local_38[-1];
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 6:
      iVar1 = 0;
      if (local_38[-1] != 0) {
        iVar1 = local_38[-2] / local_38[-1];
      }
      local_38[-2] = iVar1;
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 7:
      iVar1 = local_38[-1];
      iVar2 = 0;
      if (iVar1 != 0) {
        iVar2 = local_38[-2] / iVar1;
      }
      local_38[-2] = local_38[-2] - iVar2 * iVar1;
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 8:
      local_38[-2] = (uint)(local_38[-2] < local_38[-1]);
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 9:
      local_38[-2] = (uint)(local_38[-1] < local_38[-2]);
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 10:
      local_38[-2] = (uint)(local_38[-2] <= local_38[-1]);
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 0xb:
      local_38[-2] = (uint)(local_38[-1] <= local_38[-2]);
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 0xc:
      local_38[-2] = (uint)(local_38[-2] == local_38[-1]);
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 0xd:
      local_38[-2] = (uint)(local_38[-2] != local_38[-1]);
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 0xe:
      local_4c = 0;
      if (local_38[-2] != 0) {
        local_4c = (uint)(local_38[-1] != 0);
      }
      local_38[-2] = local_4c;
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 0xf:
      local_50 = 1;
      if (local_38[-2] == 0) {
        local_50 = (uint)(local_38[-1] != 0);
      }
      local_38[-2] = local_50;
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 0x10:
      local_38[-1] = -local_38[-1];
      local_40 = piVar4;
      break;
    case 0x11:
      local_38[-1] = (uint)(local_38[-1] == 0);
      local_40 = piVar4;
      break;
    case 0x12:
      local_40 = (int *)((long)piVar4 + (long)*piVar4);
      break;
    case 0x13:
      if (local_38[-1] == 0) {
        local_54 = *piVar4;
      }
      else {
        local_54 = 4;
      }
      local_40 = (int *)((long)piVar4 + (long)local_54);
      local_38 = local_38 + -1;
      break;
    case 0x14:
      uVar3 = _printf("%c");
      param_1 = (int *)(ulong)uVar3;
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 0x15:
      uVar3 = _printf("%s");
      param_1 = (int *)(ulong)uVar3;
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 0x16:
      uVar3 = _printf("%d");
      param_1 = (int *)(ulong)uVar3;
      local_40 = piVar4;
      local_38 = local_38 + -1;
      break;
    case 0x17:
      return param_1;
    default:
      piVar4 = (int *)_error("Unknown opcode %d\n");
      return piVar4;
    }
  } while( true );
}



void * _read_line(int *param_1)

{
  int iVar1;
  int local_28;
  void *local_18;
  
  *param_1 = 0;
  while ((iVar1 = _fgetc(_source_fp), iVar1 != -1 && (iVar1 != 10))) {
    if (DAT_1000081a0 <= *param_1 + 1) {
      if (DAT_1000081a0 == 0) {
        local_28 = 0x80;
      }
      else {
        local_28 = DAT_1000081a0 << 1;
      }
      DAT_1000081a0 = local_28;
      DAT_100008198 = _realloc(DAT_100008198,(long)local_28);
    }
    *(char *)((long)DAT_100008198 + (long)*param_1) = (char)iVar1;
    *param_1 = *param_1 + 1;
  }
  if (*param_1 == 0) {
    local_18 = (void *)0x0;
  }
  else {
    *(undefined *)((long)DAT_100008198 + (long)*param_1) = 0;
    local_18 = DAT_100008198;
  }
  return local_18;
}



long _rtrim(long param_1,int *param_2)

{
  bool bVar1;
  int iVar2;
  
  while( true ) {
    bVar1 = false;
    if (0 < *param_2) {
      iVar2 = _isspace((int)*(char *)(param_1 + (*param_2 + -1)));
      bVar1 = iVar2 != 0;
    }
    if (!bVar1) break;
    *param_2 = *param_2 + -1;
  }
  *(undefined *)(param_1 + *param_2) = 0;
  return param_1;
}



char * _translate(char *param_1)

{
  char *pcVar1;
  char *pcVar2;
  char cVar3;
  char *local_18;
  char *local_10;
  char *local_8;
  
  local_8 = param_1;
  if (*param_1 == '\"') {
    local_8 = param_1 + 1;
  }
  local_18 = local_8;
  local_10 = local_8;
  while( true ) {
    pcVar1 = local_18 + 1;
    cVar3 = *local_18;
    pcVar2 = local_10 + 1;
    *local_10 = cVar3;
    if (cVar3 == '\0') break;
    if (*local_18 == '\\') {
      if (*pcVar1 == 'n') {
        *local_10 = '\n';
        pcVar1 = local_18 + 2;
      }
      else if (*pcVar1 == '\\') {
        pcVar1 = local_18 + 2;
      }
    }
    local_18 = pcVar1;
    local_10 = pcVar2;
    if ((*local_18 == '\"') && (local_18[1] == '\0')) {
      local_18 = local_18 + 1;
    }
  }
  return local_8;
}



undefined4 _findit(char *param_1)

{
  int iVar1;
  ulong local_30;
  
  local_30 = 0;
  while( true ) {
    if (0x17 < local_30) {
      _error("Unknown instruction %s at %d\n");
      return 0xffffffff;
    }
    iVar1 = _strcmp((&_code_map)[local_30 * 2],param_1);
    if (iVar1 == 0) break;
    local_30 = local_30 + 1;
  }
  return *(undefined4 *)(&DAT_100008008 + local_30 * 0x10);
}



void _emit_byte(undefined param_1)

{
  long lVar1;
  
  if (__qy_object_max <= __qy_object_p) {
    __qy_object_max = __qy_object_max + 0x20;
    _object = _realloc(_object,(long)__qy_object_max);
  }
  lVar1 = (long)__qy_object_p;
  __qy_object_p = __qy_object_p + 1;
  *(undefined *)((long)_object + lVar1) = param_1;
  return;
}



void _emit_int(undefined4 param_1)

{
  ulong local_20;
  undefined4 local_18;
  undefined4 local_14;
  
  local_18 = param_1;
  local_14 = param_1;
  for (local_20 = 0; local_20 < 4; local_20 = local_20 + 1) {
    _emit_byte(*(undefined *)((long)&local_18 + local_20));
  }
  return;
}



void * _load_code(int *param_1)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  char *pcVar4;
  void *pvVar5;
  long lVar6;
  size_t sVar7;
  int local_34;
  undefined auStack_1c [4];
  int *local_18;
  
  local_18 = param_1;
  uVar3 = _read_line();
  pcVar4 = (char *)_rtrim(uVar3,auStack_1c);
  _strtok(pcVar4," ");
  pcVar4 = _strtok((char *)0x0," ");
  iVar1 = _atoi(pcVar4);
  *local_18 = iVar1;
  _strtok((char *)0x0," ");
  pcVar4 = _strtok((char *)0x0," ");
  iVar1 = _atoi(pcVar4);
  pvVar5 = _malloc((long)iVar1 << 3);
  for (local_34 = 0; local_34 < iVar1; local_34 = local_34 + 1) {
    uVar3 = _read_line();
    uVar3 = _rtrim(uVar3,auStack_1c);
    pcVar4 = (char *)_translate(uVar3);
    pcVar4 = _strdup(pcVar4);
    *(char **)((long)pvVar5 + (long)local_34 * 8) = pcVar4;
  }
  while (lVar6 = _read_line(auStack_1c), lVar6 != 0) {
    pcVar4 = (char *)_rtrim(lVar6,auStack_1c);
    pcVar4 = _strtok(pcVar4," ");
    iVar1 = _atoi(pcVar4);
    pcVar4 = _strtok((char *)0x0," ");
    uVar2 = _findit(pcVar4,iVar1);
    _emit_byte(uVar2);
    pcVar4 = _strtok((char *)0x0," ");
    if (uVar2 < 2) {
      pcVar4 = pcVar4 + 1;
      sVar7 = _strlen(pcVar4);
      pcVar4[(int)sVar7 + -1] = '\0';
      iVar1 = _atoi(pcVar4);
      _emit_int(iVar1);
    }
    else if (uVar2 == 2) {
      iVar1 = _atoi(pcVar4);
      _emit_int(iVar1);
    }
    else if (uVar2 - 0x12 < 2) {
      pcVar4 = pcVar4 + 1;
      sVar7 = _strlen(pcVar4);
      pcVar4[(int)sVar7 + -1] = '\0';
      iVar1 = _atoi(pcVar4);
      _emit_int(iVar1);
    }
  }
  return pvVar5;
}



void _init_io(undefined8 *param_1,undefined8 param_2,char *param_3,char *param_4)

{
  FILE *pFVar1;
  
  if (*param_4 == '\0') {
    *param_1 = param_2;
  }
  else {
    pFVar1 = _fopen(param_4,param_3);
    *param_1 = pFVar1;
    if (pFVar1 == (FILE *)0x0) {
      _error(0);
    }
  }
  return;
}



undefined4 entry(int param_1,long param_2)

{
  undefined auStack_70 [8];
  ulong local_68;
  undefined4 local_5c;
  char *local_58;
  undefined8 local_50;
  undefined *local_40;
  undefined8 local_38;
  int local_2c;
  long local_28;
  int local_20;
  undefined4 local_1c;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_1c = 0;
  local_50 = *(undefined8 *)PTR____stdinp_100004018;
  if (param_1 < 2) {
    local_58 = "";
  }
  else {
    local_58 = *(char **)(param_2 + 8);
  }
  local_28 = param_2;
  local_20 = param_1;
  _init_io(&_source_fp,local_50,"r",local_58);
  local_38 = _load_code(&local_2c);
  local_68 = (ulong)(local_2c + 1000) * 4 + 0xf & 0xfffffffffffffff0;
  local_40 = auStack_70;
  (*(code *)PTR____chkstk_darwin_100004000)();
  _run_vm(_object,auStack_70 + -local_68,local_2c,local_38);
  local_5c = local_1c;
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return local_1c;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void ___vsprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____vsprintf_chk_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004030)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetc_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e68. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004040)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isspace(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isspace_100004048)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e80. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004050)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004058)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004060)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004068)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004070)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004078)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strtok(char *param_1,char *param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strtok_100004080)();
  return pcVar1;
}


`
`#include "stdio.h"

typedef struct Range {
    int start, end, sum;
} Range;

Range maxSubseq(const int sequence[], const int len) {
    int maxSum = 0, thisSum = 0, i = 0;
    int start = 0, end = -1, j;

    for (j = 0; j < len; j++) {
        thisSum += sequence[j];
        if (thisSum < 0) {
            i = j + 1;
            thisSum = 0;
        } else if (thisSum > maxSum) {
            maxSum = thisSum;
            start = i;
            end   = j;
        }
    }

    Range r;
    if (start <= end && start >= 0 && end >= 0) {
        r.start = start;
        r.end = end + 1;
        r.sum = maxSum;
    } else {
        r.start = 0;
        r.end = 0;
        r.sum = 0;
    }
    return r;
}

int main(int argc, char **argv) {
    int a[] = {-1 , -2 , 3 , 5 , 6 , -2 , -1 , 4 , -4 , 2 , -1};
    int alength = sizeof(a)/sizeof(a[0]);

    Range r = maxSubseq(a, alength);
    printf("Max sum = %d\n", r.sum);
    int i;
    for (i = r.start; i < r.end; i++)
        printf("%d ", a[i]);
    printf("\n");

    return 0;
}
`,`#include "greatest-subsequential-sum.h"



undefined  [16] _maxSubseq(long param_1,int param_2)

{
  undefined auVar1 [16];
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_34;
  int iStack_30;
  int local_2c;
  undefined4 uStack_1c;
  
  local_48 = 0;
  local_4c = 0;
  local_50 = 0;
  local_54 = 0;
  local_58 = -1;
  for (local_5c = 0; local_5c < param_2; local_5c = local_5c + 1) {
    local_4c = local_4c + *(int *)(param_1 + (long)local_5c * 4);
    if (local_4c < 0) {
      local_50 = local_5c + 1;
      local_4c = 0;
    }
    else if (local_48 < local_4c) {
      local_54 = local_50;
      local_58 = local_5c;
      local_48 = local_4c;
    }
  }
  if (((local_58 < local_54) || (local_54 < 0)) || (local_58 < 0)) {
    local_34 = 0;
    iStack_30 = 0;
    local_2c = 0;
  }
  else {
    local_34 = local_54;
    iStack_30 = local_58 + 1;
    local_2c = local_48;
  }
  auVar1._4_4_ = iStack_30;
  auVar1._0_4_ = local_34;
  auVar1._12_4_ = uStack_1c;
  auVar1._8_4_ = local_2c;
  if (*(long *)PTR____stack_chk_guard_100004008 == *(long *)PTR____stack_chk_guard_100004008) {
    return auVar1;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  int iVar1;
  undefined8 uVar2;
  int local_7c;
  int local_78;
  int iStack_74;
  undefined auStack_44 [44];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_44,&DAT_100003f68,0x2c);
  uVar2 = _maxSubseq(auStack_44,0xb);
  _printf("Max sum = %d\n");
  local_78 = (int)uVar2;
  for (local_7c = local_78; iStack_74 = (int)((ulong)uVar2 >> 0x20), local_7c < iStack_74;
      local_7c = local_7c + 1) {
    _printf("%d ");
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Digital signal processing ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define PI 3.14159265358979323846

void DFT(double *input, double *real_output, double *imag_output, int n);
void FFT(double *input, double *real_output, double *imag_output, int n);
void complex_mult(double x_real, double x_imag, double y_real, double y_imag, double *z_real, double *z_imag);

int main()
{
    int n, i;
    double *input, *real_output, *imag_output;

    printf("Enter the number of samples: ");
    scanf("%d", &n);

    input = (double *)malloc(n * sizeof(double));
    real_output = (double *)malloc(n * sizeof(double));
    imag_output = (double *)malloc(n * sizeof(double));

    printf("Enter the samples: ");
    for (i = 0; i < n; i++)
    {
        scanf("%lf", &input[i]);
    }

    DFT(input, real_output, imag_output, n);

    printf("\nDFT Output:\n");

    for (i = 0; i < n; i++)
    {
        printf("X[%d] = %lf + %lfj\n", i, real_output[i], imag_output[i]);
    }

    FFT(input, real_output, imag_output, n);

    printf("\nFFT Output:\n");

    for (i = 0; i < n; i++)
    {
        printf("X[%d] = %lf + %lfj\n", i, real_output[i], imag_output[i]);
    }

    free(input);
    free(real_output);
    free(imag_output);

    return 0;
}

void DFT(double *input, double *real_output, double *imag_output, int n)
{
    int k, n1;
    double c, s, arg;

    for (k = 0; k < n; k++)
    {
        real_output[k] = 0;
        imag_output[k] = 0;

        for (n1 = 0; n1 < n; n1++)
        {
            arg = 2 * PI * k * n1 / (double)n;
            c = cos(arg);
            s = sin(arg);
            real_output[k] += input[n1] * c;
            imag_output[k] -= input[n1] * s;
        }
    }
}

void FFT(double *input, double *real_output, double *imag_output, int n)
{
    int i, j, k, n1, l, m;
    double c, s, arg, temp_real, temp_imag;
    double *x_real, *x_imag, *tmp_real, *tmp_imag;

    x_real = (double *)malloc(n * sizeof(double));
    x_imag = (double *)malloc(n * sizeof(double));
    tmp_real = (double *)malloc(n * sizeof(double));
    tmp_imag = (double *)malloc(n * sizeof(double));

    for (i = 0; i < n; i++)
    {
        x_real[i] = input[i];
        x_imag[i] = 0;
    }

    j = 0;
    for (i = 1; i < n - 1; i++)
    {
        k = n >> 1;
        while (k <= j)
        {
            j -= k;
            k >>= 1;
        }
        j += k;
        if (i < j)
        {
            temp_real = x_real[i];
            temp_imag = x_imag[i];
            x_real[i] = x_real[j];
            x_imag[i] = x_imag[j];
            x_real[j] = temp_real;
            x_imag[j] = temp_imag;
        }
    }

    for (i = 0; i < log2(n); i++)
    {
        l = 1 << i;
        for (j = 0; j < n; j += 2 * l)
        {
            for (k = 0; k < l; k++)
            {
                arg = 2 * PI * k / (double)(2 * l);
                c = cos(arg);
                s = sin(arg);
                complex_mult(x_real[j + k + l], x_imag[j + k + l], c, s, &temp_real, &temp_imag);
                tmp_real[j + k] = x_real[j + k] + temp_real;
                tmp_imag[j + k] = x_imag[j + k] + temp_imag;
                tmp_real[j + k + l] = x_real[j + k] - temp_real;
                tmp_imag[j + k + l] = x_imag[j + k] - temp_imag;
            }
        }

        for (m = 0; m < n; m++)
        {
            x_real[m] = tmp_real[m];
            x_imag[m] = tmp_imag[m];
        }
    }

    for (i = 0; i < n; i++)
    {
        real_output[i] = x_real[i];
        imag_output[i] = x_imag[i];
    }

    free(x_real);
    free(x_imag);
    free(tmp_real);
    free(tmp_imag);
}

void complex_mult(double x_real, double x_imag, double y_real, double y_imag, double *z_real, double *z_imag)
{
    *z_real = x_real * y_real - x_imag * y_imag;
    *z_imag = x_real * y_imag + x_imag * y_real;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall DFT(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall FFT(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-24h] BYREF
  void *v5; // [rsp+30h] [rbp-20h]
  void *v6; // [rsp+38h] [rbp-18h]
  void *Block; // [rsp+40h] [rbp-10h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of samples: ");
  scanf("%d", &v4);
  Block = malloc(8i64 * v4);
  v6 = malloc(8i64 * v4);
  v5 = malloc(8i64 * v4);
  printf("Enter the samples: ");
  for ( i = 0; i < v4; ++i )
    scanf("%lf", (char *)Block + 8 * i);
  DFT(Block, v6, v5, (unsigned int)v4);
  printf("\nDFT Output:\n");
  for ( i = 0; i < v4; ++i )
    printf("X[%d] = %lf + %lfj\n", (unsigned int)i, *((_QWORD *)v6 + i), *((_QWORD *)v5 + i));
  FFT(Block, v6, v5, (unsigned int)v4);
  printf("\nFFT Output:\n");
  for ( i = 0; i < v4; ++i )
    printf("X[%d] = %lf + %lfj\n", (unsigned int)i, *((_QWORD *)v6 + i), *((_QWORD *)v5 + i));
  free(Block);
  free(v6);
  free(v5);
  return 0;
}
// 140001834: using guessed type __int64 __fastcall DFT(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400019C8: using guessed type __int64 __fastcall FFT(_QWORD, _QWORD, _QWORD, _QWORD);
// 140002080: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdlib.h>
#include <stdio.h>

int main() {
  puts(getenv("HOME"));
  puts(getenv("PATH"));
  puts(getenv("USER"));
  return 0;
}
`,`#include "environment-variables.h"



undefined4 entry(void)

{
  char *pcVar1;
  
  pcVar1 = _getenv("HOME");
  _puts(pcVar1);
  pcVar1 = _getenv("PATH");
  _puts(pcVar1);
  pcVar1 = _getenv("USER");
  _puts(pcVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _getenv(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__getenv_100004000)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void show(int *x)
{
	int i, j;
	for (i = 0; i < 9; i++) {
		if (!(i % 3)) putchar('\n');
		for (j = 0; j < 9; j++)
			printf(j % 3 ? "%2d" : "%3d", *x++);
		putchar('\n');
	}
}

int trycell(int *x, int pos)
{
	int row = pos / 9;
	int col = pos % 9;
	int i, j, used = 0;

	if (pos == 81) return 1;
	if (x[pos]) return trycell(x, pos + 1);

	for (i = 0; i < 9; i++)
		used |= 1 << (x[i * 9 + col] - 1);

	for (j = 0; j < 9; j++)
		used |= 1 << (x[row * 9 + j] - 1);

	row = row / 3 * 3;
	col = col / 3 * 3;
	for (i = row; i < row + 3; i++)
		for (j = col; j < col + 3; j++)
			used |= 1 << (x[i * 9 + j] - 1);

	for (x[pos] = 1; x[pos] <= 9; x[pos]++, used >>= 1)
		if (!(used & 1) && trycell(x, pos + 1)) return 1;

	x[pos] = 0;
	return 0;
}

void solve(const char *s)
{
	int i, x[81];
	for (i = 0; i < 81; i++)
		x[i] = s[i] >= '1' && s[i] <= '9' ? s[i] - '0' : 0;

	if (trycell(x, 0))
		show(x);
	else
		puts("no solution");
}

int main(void)
{
	solve(	"5x..7...."
		"6..195..."
		".98....6."
		"8...6...3"
		"4..8.3..1"
		"7...2...6"
		".6....28."
		"...419..5"
		"....8..79"	);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_1000039b0(void);
int64_t function_100003abc(void);
int64_t function_100003da8(void);
int64_t function_100003f08(int64_t a1);
int32_t function_100003f14(char * format, ...);
int32_t function_100003f20(int32_t c);
int32_t function_100003f2c(char * s);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _puts(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x1000039b0 - 0x100003abc
int64_t function_1000039b0(void) {
    int32_t result; // 0x100003a98
    for (int32_t i = 0; i < 9; i++) {
        // 0x1000039dc
        if (i % 3 == 0) {
            // 0x100003a00
            _putchar(10);
        }
        for (int32_t j = 0; j < 9; j++) {
            // 0x100003a28
            _printf(j % 3 == 0 ? "%3d" : "%2d");
        }
        // 0x100003a94
        result = _putchar(10);
    }
    // 0x100003ab0
    return result;
}

// Address range: 0x100003abc - 0x100003da8
int64_t function_100003abc(void) {
    // 0x100003abc
    int64_t v1; // 0x100003abc
    int32_t v2 = v1; // 0x100003acc
    if (v2 == 81) {
        // 0x100003d98
        return 1;
    }
    int32_t v3 = v2 / 9; // 0x100003ad8
    int32_t v4 = v2 % 9;
    int32_t * v5 = (int32_t *)((0x100000000 * v1 >> 30) + v1); // 0x100003b20
    int64_t v6 = 0; // 0x100003b2c
    int32_t v7 = 0; // 0x100003b2c
    int64_t result; // 0x100003abc
    if (*v5 != 0) {
        // 0x100003b34
        result = function_100003abc() & 0xffffffff;
      lab_0x100003d98:
        // 0x100003d98
        return result;
    }
    int32_t v8 = *(int32_t *)(v1 + (int64_t)(4 * (9 * (int32_t)v6 + v4))); // 0x100003b80
    v7 |= 1 << v8 - 1;
    v6++;
    while (v6 != 9) {
        // 0x100003b68
        v8 = *(int32_t *)(v1 + (int64_t)(4 * (9 * (int32_t)v6 + v4)));
        v7 |= 1 << v8 - 1;
        v6++;
    }
    int32_t v9 = 9 * v3; // 0x100003bd8
    int64_t v10 = 0;
    int32_t v11 = *(int32_t *)(v1 + (int64_t)(4 * (v9 + (int32_t)v10))); // 0x100003be4
    int32_t v12 = 1 << v11 - 1 | v7; // 0x100003bf8
    v10++;
    int32_t v13 = v12; // 0x100003bc4
    while (v10 != 9) {
        // 0x100003bcc
        v11 = *(int32_t *)(v1 + (int64_t)(4 * (v9 + (int32_t)v10)));
        v12 = 1 << v11 - 1 | v13;
        v10++;
        v13 = v12;
    }
    int32_t v14 = v3 - v3 % 3; // 0x100003c20
    int32_t v15 = v14 + 3; // 0x100003c4c
    int32_t v16 = v12; // 0x100003c58
    if (((v15 ^ v14) & -v14) >= 0) {
        int32_t v17 = v4 - v4 % 3; // 0x100003c30
        int32_t v18 = v17 + 3; // 0x100003c74
        int32_t v19 = v12; // 0x100003c80
        int32_t v20; // 0x100003cb4
        int32_t v21; // 0x100003cc4
        int32_t v22; // 0x100003c78
        if (((v18 ^ v17) & -v17) >= 0) {
            // 0x100003c88
            v21 = v17;
            v20 = v12;
            v20 |= 1 << *(int32_t *)(v1 + (int64_t)(4 * (v21 + 9 * v14))) - 1;
            v21++;
            v22 = v21 - v18;
            v19 = v20;
            while (v22 < 0 != ((v22 ^ v21) & (v21 ^ v18)) < 0) {
                // 0x100003c88
                v20 |= 1 << *(int32_t *)(v1 + (int64_t)(4 * (v21 + 9 * v14))) - 1;
                v21++;
                v22 = v21 - v18;
                v19 = v20;
            }
        }
        int32_t v23 = v19;
        int32_t v24 = v14 + 1; // 0x100003cd8
        int32_t v25 = v24 - v15; // 0x100003c50
        v16 = v23;
        while (v25 < 0 != ((v25 ^ v24) & (v24 ^ v15)) < 0) {
            int32_t v26 = v23;
            int32_t v27 = v24;
            v19 = v26;
            if (((v18 ^ v17) & -v17) >= 0) {
                // 0x100003c88
                v21 = v17;
                v20 = v26;
                int32_t v28 = *(int32_t *)(v1 + (int64_t)(4 * (v21 + 9 * v27))); // 0x100003ca0
                v20 |= 1 << v28 - 1;
                v21++;
                v22 = v21 - v18;
                v19 = v20;
                while (v22 < 0 != ((v22 ^ v21) & (v21 ^ v18)) < 0) {
                    // 0x100003c88
                    v28 = *(int32_t *)(v1 + (int64_t)(4 * (v21 + 9 * v27)));
                    v20 |= 1 << v28 - 1;
                    v21++;
                    v22 = v21 - v18;
                    v19 = v20;
                }
            }
            // 0x100003cd4
            v23 = v19;
            v24 = v27 + 1;
            v25 = v24 - v15;
            v16 = v23;
        }
    }
    // 0x100003d14
    *v5 = 1;
    int32_t v29 = 1; // 0x100003d68
    int32_t v30 = v16; // 0x100003abc
    while (true) {
        int32_t v31 = v29; // 0x100003d20
        if (v30 % 2 == 0) {
            // 0x100003d28
            if ((int32_t)function_100003abc() != 0) {
                // break -> 0x100003d98
                break;
            }
            // 0x100003d28
            v31 = *v5;
        }
        // 0x100003d58
        v29 = v31 + 1;
        *v5 = v29;
        int32_t v32 = v31 - 8; // 0x100003d04
        v30 >>= 1;
        if (v32 != 0 && v32 < 0 == (7 - v31 & v29) < 0) {
            // 0x100003d80
            *v5 = 0;
            result = 0;
            return result;
        }
    }
    // 0x100003d98
    return 1;
}

// Address range: 0x100003da8 - 0x100003ed4
int64_t function_100003da8(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003dc0
    for (int64_t i = 0; i < 81; i++) {
        // 0x100003de8
        int64_t v2; // 0x100003da8
        char v3 = *(char *)(i + v2); // 0x100003df0
        int32_t v4 = v3; // 0x100003df0
        int32_t v5 = 0; // 0x100003dfc
        if (v3 < 49 == (48 - v4 & v4) < 0) {
            int32_t v6 = v4 - 57; // 0x100003e10
            v5 = v6 == 0 | v6 < 0 != (56 - v4 & v4) < 0 ? v4 - 48 : 0;
        }
        // 0x100003e44
        int64_t v7; // bp-364, 0x100003da8
        *(int32_t *)(4 * i + (int64_t)&v7) = v5;
    }
    // 0x100003e68
    int64_t v8; // 0x100003da8
    if ((int32_t)function_100003abc() == 0) {
        // 0x100003e90
        v8 = _puts("no solution");
    } else {
        // 0x100003e84
        v8 = function_1000039b0();
    }
    int64_t result = v8; // 0x100003eb8
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003ec0
        result = ___stack_chk_fail(v8);
    }
    // 0x100003ec4
    return result;
}

// Address range: 0x100003ed4 - 0x100003f08
int64_t entry_point(void) {
    // 0x100003ed4
    function_100003da8();
    return 0;
}

// Address range: 0x100003f08 - 0x100003f14
int64_t function_100003f08(int64_t a1) {
    // 0x100003f08
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f14 - 0x100003f20
int32_t function_100003f14(char * format, ...) {
    // 0x100003f14
    return _printf(format);
}

// Address range: 0x100003f20 - 0x100003f2c
int32_t function_100003f20(int32_t c) {
    // 0x100003f20
    return _putchar(c);
}

// Address range: 0x100003f2c - 0x100003f38
int32_t function_100003f2c(char * s) {
    // 0x100003f2c
    return _puts(s);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 8

`
`//FormAI DATASET v1.0 Category: String manipulation ; Style: all-encompassing
#include <stdio.h>
#include <string.h>

int main() {
    char str1[100], str2[100];
    printf("Enter first string: ");
    fgets(str1, 100, stdin);
    printf("Enter second string: ");
    fgets(str2, 100, stdin);

    // Finding the length of the strings
    int length1 = strlen(str1) - 1; // fgets inputs '\n' while Enter is pressed, thus subtracting 1.
    int length2 = strlen(str2) - 1;

    // Concatenating the two strings and displaying the result
    printf("\nAfter concatenating the two strings: ");
    strcat(str1, str2);
    printf("%s", str1);

    // Reversing the first string and displaying the result
    printf("\n\nAfter reversing the first string: ");
    for(int i=0, j=length1-1; i<length1/2; i++, j--) {
        char temp = str1[i];
        str1[i] = str1[j];
        str1[j] = temp;
    }
    printf("%s", str1);

    // Checking if the second string is a palindrome
    int flag=1; // flag=1 means the string is a palindrome, flag=0 means the string is not a palindrome
    for(int i=0, j=length2-1; i<length2/2; i++, j--) {
        if(str2[i] != str2[j]) {
            flag=0;
            break;
        }
    }
    if(flag) printf("\n\nThe second string is a palindrome.");
    else printf("\n\nThe second string is not a palindrome.");

    // Counting the number of vowels in the first string and displaying the result
    int vowel_count=0;
    for(int i=0; i<length1; i++) {
        if(str1[i]=='a' || str1[i]=='e' || str1[i]=='i' || str1[i]=='o' || str1[i]=='u'
            || str1[i]=='A' || str1[i]=='E' || str1[i]=='I' || str1[i]=='O' || str1[i]=='U') {
            vowel_count++;
        }
    }
    printf("\n\nThe first string contains %d vowels.", vowel_count);

    // Replacing all occurrences of a with x in the second string and displaying the result
    for(int i=0; i<length2; i++) {
        if(str2[i]=='a') {
            str2[i] = 'x';
        }
    }
    printf("\n\nAfter replacing all occurrences of a with x in the second string: %s", str2);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcat(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Str[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[103]; // [rsp+90h] [rbp+10h] BYREF
  char v8; // [rsp+F7h] [rbp+77h]
  int v9; // [rsp+F8h] [rbp+78h]
  int v10; // [rsp+FCh] [rbp+7Ch]
  int j; // [rsp+100h] [rbp+80h]
  int i; // [rsp+104h] [rbp+84h]
  unsigned int v13; // [rsp+108h] [rbp+88h]
  int v14; // [rsp+10Ch] [rbp+8Ch]
  int v15; // [rsp+110h] [rbp+90h]
  int v16; // [rsp+114h] [rbp+94h]
  int v17; // [rsp+118h] [rbp+98h]
  int v18; // [rsp+11Ch] [rbp+9Ch]

  _main(argc, argv, envp);
  printf("Enter first string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  printf("Enter second string: ");
  v4 = __acrt_iob_func(0);
  fgets(Str, 100, v4);
  v10 = strlen(Buffer) - 1;
  v9 = strlen(Str) - 1;
  printf("\nAfter concatenating the two strings: ");
  strcat(Buffer, Str);
  printf("%s", Buffer);
  printf("\n\nAfter reversing the first string: ");
  v18 = 0;
  v17 = v10 - 1;
  while ( v18 < v10 / 2 )
  {
    v8 = Buffer[v18];
    Buffer[v18] = Buffer[v17];
    Buffer[v17] = v8;
    ++v18;
    --v17;
  }
  printf("%s", Buffer);
  v16 = 1;
  v15 = 0;
  v14 = v9 - 1;
  while ( v15 < v9 / 2 )
  {
    if ( Str[v15] != Str[v14] )
    {
      v16 = 0;
      break;
    }
    ++v15;
    --v14;
  }
  if ( v16 )
    printf("\n\nThe second string is a palindrome.");
  else
    printf("\n\nThe second string is not a palindrome.");
  v13 = 0;
  for ( i = 0; i < v10; ++i )
  {
    if ( Buffer[i] == 97
      || Buffer[i] == 101
      || Buffer[i] == 105
      || Buffer[i] == 111
      || Buffer[i] == 117
      || Buffer[i] == 65
      || Buffer[i] == 69
      || Buffer[i] == 73
      || Buffer[i] == 79
      || Buffer[i] == 85 )
    {
      ++v13;
    }
  }
  printf("\n\nThe first string contains %d vowels.", v13);
  for ( j = 0; j < v9; ++j )
  {
    if ( Str[j] == 97 )
      Str[j] = 120;
  }
  printf("\n\nAfter replacing all occurrences of a with x in the second string: %s", Str);
  return 0;
}
// 1400019B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[103];
// 140001591: using guessed type char Str[112];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedurally Generated Maze ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 10
#define COLS 10

void generateMaze(int maze[ROWS][COLS]) {
    int i, j;
    // Initialize maze with walls
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            maze[i][j] = 1;
        }
    }
    // Set starting and ending points
    maze[0][0] = 0;
    maze[ROWS-1][COLS-1] = 0;
    
    srand(time(NULL)); // Seed random number generator
    int row = 1, col = 1;
    maze[row][col] = 0; // Set starting position to open space
    
    int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // Up, Down, Left, Right
    int numDirections = 4;
    while (numDirections > 0) {
        int r = rand() % numDirections;
        int dirRow = directions[r][0];
        int dirCol = directions[r][1];
        int neighborRow = row + 2 * dirRow;
        int neighborCol = col + 2 * dirCol;
        if (neighborRow > 0 && neighborRow < ROWS-1 && neighborCol > 0 && neighborCol < COLS-1 && maze[neighborRow][neighborCol] == 1) {
            // Clear path to neighbor
            maze[row+dirRow][col+dirCol] = 0;
            maze[neighborRow][neighborCol] = 0;
            // Move to neighbor
            row = neighborRow;
            col = neighborCol;
            // Reset directions array and increment open space count
            numDirections = 4;
            continue;
        }
        // Remove direction from directions array
        directions[r][0] = directions[numDirections-1][0];
        directions[r][1] = directions[numDirections-1][1];
        numDirections--;
    }
}

void printMaze(int maze[ROWS][COLS]) {
    int i, j;
    printf(" ");
    for (j = 0; j < COLS; j++) {
        printf("_ ");
    }
    printf("\n");
    for (i = 0; i < ROWS; i++) {
        printf("|");
        for (j = 0; j < COLS; j++) {
            if (maze[i][j] == 0) {
                printf("  ");
            } else {
                printf("__");
            }
            if (j == COLS-1) {
                printf("|");
            } else if (maze[i][j] == 0 && maze[i][j+1] == 0) {
                printf(" ");
            } else {
                printf("_");
            }
        }
        printf("\n");
    }
}

int main() {
    int maze[ROWS][COLS];
    generateMaze(maze);
    printMaze(maze);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall generateMaze(_QWORD); // weak
__int64 __fastcall printMaze(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001978) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[400]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  generateMaze(v4);
  printMaze(v4);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall generateMaze(_QWORD);
// 1400017FA: using guessed type __int64 __fastcall printMaze(_QWORD);
// 140001A70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include<string.h>
#include<stdio.h>

int main(int argc,char** argv)
{
    int i,len;
    char reference;

    if(argc>2){
        printf("Usage : %s <Test String>\n",argv[0]);
        return 0;
    }

    if(argc==1||strlen(argv[1])==1){
        printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n",argc==1?"":argv[1],argc==1?0:(int)strlen(argv[1]));
        return 0;
    }

    reference = argv[1][0];
    len = strlen(argv[1]);

    for(i=1;i<len;i++){
        if(argv[1][i]!=reference){
            printf("Input string : \"%s\"\nLength : %d\nFirst different character : \"%c\"(0x%x) at position : %d\n",argv[1],len,argv[1][i],argv[1][i],i+1);
            return 0;
        }
    }

    printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n",argv[1],len);

    return 0;

}
`,`#include "determine-if-a-string-has-all-the-same-characters-1.h"



undefined4 entry(int param_1,long param_2)

{
  byte bVar1;
  size_t sVar2;
  int local_24;
  
  if (param_1 < 3) {
    if ((param_1 == 1) || (sVar2 = _strlen(*(char **)(param_2 + 8)), sVar2 == 1)) {
      if (param_1 != 1) {
        _strlen(*(char **)(param_2 + 8));
      }
      _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n");
    }
    else {
      bVar1 = **(byte **)(param_2 + 8);
      sVar2 = _strlen(*(char **)(param_2 + 8));
      for (local_24 = 1; local_24 < (int)sVar2; local_24 = local_24 + 1) {
        if ((int)*(char *)(*(long *)(param_2 + 8) + (long)local_24) != (uint)bVar1) {
          _printf(
                 "Input string : \"%s\"\nLength : %d\nFirst different character : \"%c\"(0x%x) at position : %d\n"
                 );
          return 0;
        }
      }
      _printf("Input string : \"%s\"\nLength : %d\nAll characters are identical.\n");
    }
  }
  else {
    _printf("Usage : %s <Test String>\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004008)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

#define N 100000
int main()
{
	int i, flip, *q = (int*)malloc(sizeof(int) * N) - 1;

	q[1] = q[2] = 1;

	for (i = 3; i <= N; i++)
		q[i] = q[i - q[i - 1]] + q[i - q[i - 2]];
		
	for (i = 1; i <= 10; i++)
		printf("%d%c", q[i], i == 10 ? '\n' : ' ');

	printf("%d\n", q[1000]);

	for (flip = 0, i = 1; i < N; i++)
		flip += q[i] > q[i + 1];

	printf("flips: %d\n", flip);
	return 0;
}
`,`#include "hofstadter-q-sequence.h"



undefined8 entry(void)

{
  undefined4 *puVar1;
  int local_18;
  
  puVar1 = (undefined4 *)_malloc(400000);
  puVar1[1] = 1;
  *puVar1 = 1;
  for (local_18 = 3; local_18 < 0x186a1; local_18 = local_18 + 1) {
    puVar1[(long)local_18 + -1] =
         puVar1[(long)(local_18 - puVar1[(long)(local_18 + -1) + -1]) + -1] +
         puVar1[(long)(local_18 - puVar1[(long)(local_18 + -2) + -1]) + -1];
  }
  for (local_18 = 1; local_18 < 0xb; local_18 = local_18 + 1) {
    _printf("%d%c");
  }
  _printf("%d\n");
  for (local_18 = 1; local_18 < 100000; local_18 = local_18 + 1) {
  }
  _printf("flips: %d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>		/* getaddrinfo, getnameinfo */
#include <stdio.h>		/* fprintf, printf */
#include <stdlib.h>		/* exit */
#include <string.h>		/* memset */

int
main()
{
	struct addrinfo hints, *res, *res0;
	int error;
	char host[NI_MAXHOST];

	/*
	 * Request only one socket type from getaddrinfo(). Else we
	 * would get both SOCK_DGRAM and SOCK_STREAM, and print two
	 * copies of each numeric address.
	 */
	memset(&hints, 0, sizeof hints);
	hints.ai_family = PF_UNSPEC;     /* IPv4, IPv6, or anything */
	hints.ai_socktype = SOCK_DGRAM;  /* Dummy socket type */

	/*
	 * Use getaddrinfo() to resolve "www.kame.net" and allocate
	 * a linked list of addresses.
	 */
	error = getaddrinfo("www.kame.net", NULL, &hints, &res0);
	if (error) {
		fprintf(stderr, "%s\n", gai_strerror(error));
		exit(1);
	}

	/* Iterate the linked list. */
	for (res = res0; res; res = res->ai_next) {
		/*
		 * Use getnameinfo() to convert res->ai_addr to a
		 * printable string.
		 *
		 * NI_NUMERICHOST means to present the numeric address
		 * without doing reverse DNS to get a domain name.
		 */
		error = getnameinfo(res->ai_addr, res->ai_addrlen,
		    host, sizeof host, NULL, 0, NI_NUMERICHOST);

		if (error) {
			fprintf(stderr, "%s\n", gai_strerror(error));
		} else {
			/* Print the numeric address. */
			printf("%s\n", host);
		}
	}

	/* Free the linked list. */
	freeaddrinfo(res0);

	return 0;
}
`,`#include "dns-query.h"



undefined8 entry(void)

{
  int iVar1;
  FILE *pFVar2;
  addrinfo *local_470;
  addrinfo *local_468;
  addrinfo aStack_460;
  undefined4 local_430;
  char acStack_429 [1025];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_430 = 0;
  _memset(&aStack_460,0,0x30);
  aStack_460.ai_family = 0;
  aStack_460.ai_socktype = 2;
  iVar1 = _getaddrinfo("www.kame.net",(char *)0x0,&aStack_460,&local_470);
  if (iVar1 != 0) {
    pFVar2 = *(FILE **)PTR____stderrp_100004010;
    _gai_strerror(iVar1);
    _fprintf(pFVar2,"%s\n");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  for (local_468 = local_470; local_468 != (addrinfo *)0x0; local_468 = local_468->ai_next) {
    iVar1 = _getnameinfo(local_468->ai_addr,local_468->ai_addrlen,acStack_429,0x401,(char *)0x0,0,2)
    ;
    if (iVar1 == 0) {
      _printf("%s\n");
    }
    else {
      pFVar2 = *(FILE **)PTR____stderrp_100004010;
      _gai_strerror(iVar1);
      _fprintf(pFVar2,"%s\n");
    }
  }
  _freeaddrinfo(local_470);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004018)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _freeaddrinfo(addrinfo *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__freeaddrinfo_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _gai_strerror(int param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__gai_strerror_100004030)(param_1);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getaddrinfo(char *param_1,char *param_2,addrinfo *param_3,addrinfo **param_4)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getaddrinfo_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getnameinfo(sockaddr *param_1,socklen_t param_2,char *param_3,socklen_t param_4,char *param_5,
                socklen_t param_6,int param_7)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getnameinfo_100004040)
                    ((int)param_1,param_2,param_3,param_4,param_5,param_6,param_7);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004048)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004050)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <time.h>
#include <stdio.h>

int main() {
    int a[10][10], i, j;

    srand(time(NULL));
    for (i = 0; i < 10; i++)
        for (j = 0; j < 10; j++)
            a[i][j] = rand() % 20 + 1;

    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            printf(" %d", a[i][j]);
            if (a[i][j] == 20)
                break;
        }
        if (a[i][j] == 20)
            break;
        printf("\n");
    }
    printf("\n");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003f64(int64_t a1);
int32_t function_100003f70(char * format, ...);
int32_t function_100003f7c(void);
void function_100003f88(int32_t seed);
int32_t function_100003f94(int32_t * timer);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d54 - 0x100003f64
int64_t entry_point(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003d6c
    _srand(_time(NULL));
    int64_t v2; // bp-440, 0x100003d54
    int64_t v3 = &v2;
    int64_t v4 = 0;
    for (int64_t i = 0; i < 10; i++) {
        // 0x100003dbc
        *(int32_t *)(40 * v4 + v3 + 4 * i) = _rand() % 20 + 1;
    }
    // 0x100003e08
    v4++;
    while (v4 != 10) {
        for (int64_t i = 0; i < 10; i++) {
            // 0x100003dbc
            *(int32_t *)(40 * v4 + v3 + 4 * i) = _rand() % 20 + 1;
        }
        // 0x100003e08
        v4++;
    }
    int32_t v5 = 0;
    int64_t v6 = 40 * (int64_t)v5 + v3;
    int32_t v7 = 0;
    int64_t v8; // 0x100003d54
    _printf(" %d", v8);
    if (*(int32_t *)(4 * (int64_t)v7 + v6) == 20) {
        // break (via goto) -> 0x100003f20
        goto lab_0x100003f20;
    }
    int32_t v9 = v7 + 1; // 0x100003ec4
    while (v7 < 9 != (8 - v7 & v9) < 0) {
        // 0x100003e50
        v7 = v9;
        _printf(" %d", v8);
        if (*(int32_t *)(4 * (int64_t)v7 + v6) == 20) {
            // break (via goto) -> 0x100003f20
            goto lab_0x100003f20;
        }
        // 0x100003ec0
        v9 = v7 + 1;
    }
    while (*(int32_t *)(4 * (int64_t)v9 + v6) != 20) {
        // 0x100003f00
        _printf((char *)0x100003fa4);
        int32_t v10 = v5 + 1; // 0x100003f14
        if (v5 < 9 == (8 - v5 & v10) < 0) {
            // break -> 0x100003f20
            break;
        }
        v5 = v10;
        v6 = 40 * (int64_t)v5 + v3;
        v7 = 0;
        _printf(" %d", v8);
        if (*(int32_t *)(4 * (int64_t)v7 + v6) == 20) {
            // break (via goto) -> 0x100003f20
            goto lab_0x100003f20;
        }
        // 0x100003ec0
        v9 = v7 + 1;
        while (v7 < 9 != (8 - v7 & v9) < 0) {
            // 0x100003e50
            v7 = v9;
            _printf(" %d", v8);
            if (*(int32_t *)(4 * (int64_t)v7 + v6) == 20) {
                // break (via goto) -> 0x100003f20
                goto lab_0x100003f20;
            }
            // 0x100003ec0
            v9 = v7 + 1;
        }
    }
  lab_0x100003f20:;
    int32_t v11 = _printf("\n"); // 0x100003f28
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003f4c
        ___stack_chk_fail((int64_t)v11);
    }
    // 0x100003f50
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int64_t function_100003f64(int64_t a1) {
    // 0x100003f64
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f70 - 0x100003f7c
int32_t function_100003f70(char * format, ...) {
    // 0x100003f70
    return _printf(format);
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(void) {
    // 0x100003f7c
    return _rand();
}

// Address range: 0x100003f88 - 0x100003f94
void function_100003f88(int32_t seed) {
    // 0x100003f88
    _srand(seed);
}

// Address range: 0x100003f94 - 0x100003fa0
int32_t function_100003f94(int32_t * timer) {
    // 0x100003f94
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: satisfied
#include<stdio.h>

int search(int arr[], int n, int key){
    int i;
    for(i=0; i<n; i++){
        if(arr[i]==key)
            return i;
    }
    return -1;
}

int main(){
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    int key = 3;
    int result = search(arr, n, key);
    if(result==-1)
        printf("Key not found\n");
    else
        printf("Key found at index %d\n", result);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall search(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[5]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v5; // [rsp+34h] [rbp-Ch]
  int v6; // [rsp+38h] [rbp-8h]
  int v7; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 1;
  v4[1] = 2;
  v4[2] = 3;
  v4[3] = 4;
  v4[4] = 5;
  v7 = 5;
  v6 = 3;
  v5 = search(v4, 5i64, 3i64);
  if ( v5 == -1 )
    printf("Key not found\n");
  else
    printf("Key found at index %d\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall search(_QWORD, _QWORD, _QWORD);
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//Evidence of the Monty Hall solution of marquinho1986 in C [github.com/marquinho1986]

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <time.h>
#include <math.h>
#define NumSim 1000000000 // one billion of simulations! using the Law of large numbers concept [https://en.wikipedia.org/wiki/Law_of_large_numbers]

void main() {
      unsigned long int i,stay=0;
      int ChosenDoor,WinningDoor;
      bool door[3]={0,0,0};

      srand(time(NULL));  //initialize random seed.
	
	  for(i=0;i<=NumSim;i++){
	
	      WinningDoor=rand() % 3; // choosing winning door.
	
	      ChosenDoor=rand() % 3;  // selected door.
	
	      if(door[WinningDoor]=true,door[ChosenDoor])stay++;
	
	      door[WinningDoor]=false;
	
      }
	
     printf("\nAfter %lu games, I won %u by staying.  That is %f%%. and I won by switching %lu That is %f%%",NumSim, stay, (float)stay*100.0/(float)i,abs(NumSim-stay),100-(float)stay*100.0/(float)i);
	
  }
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f04(int32_t x);
int32_t function_100003f10(char * format, ...);
int32_t function_100003f1c(void);
void function_100003f28(int32_t seed);
int32_t function_100003f34(int32_t * timer);

// ------- Dynamically Linked Functions Without Header --------

int32_t _abs(int32_t a1);
int32_t _printf(char * a1, ...);
int32_t _rand(void);
void _srand(int32_t a1);
int32_t _time(int32_t * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d5c - 0x100003f04
int64_t entry_point(void) {
    int16_t v1 = 0; // bp-44, 0x100003d6c
    _srand(_time(NULL));
    int64_t v2 = &v1;
    int64_t v3 = 0; // 0x100003e2c
    int64_t v4 = 0;
    int32_t v5 = _rand(); // 0x100003da4
    int32_t v6 = _rand(); // 0x100003dc0
    char * v7 = (char *)((int64_t)(v5 % 3) + v2); // 0x100003dec
    *v7 = 1;
    unsigned char v8 = *(char *)((int64_t)(v6 % 3) + v2); // 0x100003df8
    v4 += (int64_t)(v8 % 2 != 0);
    *v7 = 0;
    v3++;
    while (v3 >= 0x3b9aca00 != v3 != 0x3b9aca00) {
        // 0x100003da4
        v5 = _rand();
        v6 = _rand();
        v7 = (char *)((int64_t)(v5 % 3) + v2);
        *v7 = 1;
        v8 = *(char *)((int64_t)(v6 % 3) + v2);
        v4 += (int64_t)(v8 % 2 != 0);
        *v7 = 0;
        v3++;
    }
    // 0x100003e38
    _abs(0x3b9aca00 - (int32_t)v4);
    int64_t v9; // 0x100003d5c
    int128_t v10; // 0x100003d5c
    return _printf("\nAfter %lu games, I won %u by staying.  That is %f%%. and I won by switching %lu That is %f%%", (int32_t)v9, (int32_t)v9, (float64_t)(int64_t)v10, (int32_t)v9, (float64_t)(int64_t)v10);
}

// Address range: 0x100003f04 - 0x100003f10
int32_t function_100003f04(int32_t x) {
    // 0x100003f04
    return _abs(x);
}

// Address range: 0x100003f10 - 0x100003f1c
int32_t function_100003f10(char * format, ...) {
    // 0x100003f10
    return _printf(format);
}

// Address range: 0x100003f1c - 0x100003f28
int32_t function_100003f1c(void) {
    // 0x100003f1c
    return _rand();
}

// Address range: 0x100003f28 - 0x100003f34
void function_100003f28(int32_t seed) {
    // 0x100003f28
    _srand(seed);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(int32_t * timer) {
    // 0x100003f34
    return _time(timer);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#define day_of_week( x ) ((x) == 1 ? "Sweetmorn" :\
                          (x) == 2 ? "Boomtime" :\
                          (x) == 3 ? "Pungenday" :\
                          (x) == 4 ? "Prickle-Prickle" :\
                          "Setting Orange")

#define season( x ) ((x) == 0 ? "Chaos" :\
                    (x) == 1 ? "Discord" :\
                    (x) == 2 ? "Confusion" :\
                    (x) == 3 ? "Bureaucracy" :\
                    "The Aftermath")

#define date( x ) ((x)%73 == 0 ? 73 : (x)%73)

#define leap_year( x ) ((x) % 400 == 0 || (((x) % 4) == 0 && (x) % 100))

char * ddate( int y, int d ){
  int dyear = 1166 + y;
  char * result = malloc( 100 * sizeof( char ) );

  if( leap_year( y ) ){
    if( d == 60 ){
      sprintf( result, "St. Tib's Day, YOLD %d", dyear );
      return result;
    } else if( d >= 60 ){
      -- d;
    }
  }

  sprintf( result, "%s, %s %d, YOLD %d",
           day_of_week(d%5), season(((d%73)==0?d-1:d)/73 ), date( d ), dyear );

  return result;
}


int day_of_year( int y, int m, int d ){
  int month_lengths[ 12 ] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

  for( ; m > 1; m -- ){
    d += month_lengths[ m - 2 ];
    if( m == 3 && leap_year( y ) ){
      ++ d;
    }
  }
  return d;
}


int main( int argc, char * argv[] ){
  time_t now;
  struct tm * now_time;
  int year, doy;

  if( argc == 1 ){
    now = time( NULL );
    now_time = localtime( &now );
    year = now_time->tm_year + 1900; doy = now_time->tm_yday + 1;
  } else if( argc == 4 ){
    year = atoi( argv[ 1 ] ); doy = day_of_year( atoi( argv[ 1 ] ), atoi( argv[ 2 ] ), atoi( argv[ 3 ] ) );
  }

  char * result = ddate( year, doy );
  puts( result );
  free( result );

  return 0;
}
`,`#include "discordian-date.h"



void * _ddate(int param_1,int param_2)

{
  void *pvVar1;
  
  pvVar1 = _malloc(100);
  if (((param_1 % 400 == 0) || ((param_1 % 4 == 0 && (param_1 % 100 != 0)))) && (param_2 == 0x3c)) {
    ___sprintf_chk(pvVar1,0,0xffffffffffffffff,"St. Tib\'s Day, YOLD %d");
  }
  else {
    ___sprintf_chk(pvVar1,0,0xffffffffffffffff,"%s, %s %d, YOLD %d");
  }
  return pvVar1;
}



int _day_of_year(int param_1,int param_2,int param_3)

{
  int local_54;
  int local_50;
  int aiStack_48 [12];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  _memcpy(aiStack_48,&DAT_100003f78,0x30);
  local_54 = param_3;
  for (local_50 = param_2; 1 < local_50; local_50 = local_50 + -1) {
    local_54 = local_54 + aiStack_48[local_50 + -2];
    if ((local_50 == 3) && ((param_1 % 400 == 0 || ((param_1 % 4 == 0 && (param_1 % 100 != 0)))))) {
      local_54 = local_54 + 1;
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return local_54;
}



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  tm *ptVar4;
  char *pcVar5;
  int local_38;
  int local_34;
  time_t local_28;
  long local_20;
  int local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_20 = param_2;
  local_18 = param_1;
  if (param_1 == 1) {
    local_28 = _time((time_t *)0x0);
    ptVar4 = _localtime(&local_28);
    local_34 = ptVar4->tm_year + 0x76c;
    local_38 = ptVar4->tm_yday + 1;
  }
  else if (param_1 == 4) {
    local_34 = _atoi(*(char **)(param_2 + 8));
    iVar1 = _atoi(*(char **)(local_20 + 8));
    iVar2 = _atoi(*(char **)(local_20 + 0x10));
    iVar3 = _atoi(*(char **)(local_20 + 0x18));
    local_38 = _day_of_year(iVar1,iVar2,iVar3);
  }
  pcVar5 = (char *)_ddate(local_34,local_38);
  _puts(pcVar5);
  _free(pcVar5);
  return 0;
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * _localtime(time_t *param_1)

{
  tm *ptVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  ptVar1 = (tm *)(*(code *)PTR__localtime_100004028)();
  return ptVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004030)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004048)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <libgen.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

int main (int argc, char **argv) {
    char *str, *s;
    struct stat statBuf;

    if (argc != 2) {
        fprintf (stderr, "usage: %s <path>\n", basename (argv[0]));
        exit (1);
    }
    s = argv[1];
    while ((str = strtok (s, "/")) != NULL) {
        if (str != s) {
            str[-1] = '/';
        }
        if (stat (argv[1], &statBuf) == -1) {
            mkdir (argv[1], 0);
        } else {
            if (! S_ISDIR (statBuf.st_mode)) {
                fprintf (stderr, "couldn't create directory %s\n", argv[1]);
                exit (1);
            }
        }
        s = NULL;
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
char * function_100003f2c(char * filename);
void function_100003f38(int32_t status);
int32_t function_100003f44(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003f50(char * path, int32_t mode);
int32_t function_100003f5c(char * file, struct stat * buf);
char * function_100003f68(char * s, char * delim);

// ------- Dynamically Linked Functions Without Header --------

char * _basename(char * a1);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _mkdir(char * a1, int32_t a2);
int32_t _stat(char * a1, struct stat * a2);
char * _strtok(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100003dc4 - 0x100003f2c
int64_t entry_point(void) {
    // 0x100003dc4
    int64_t v1; // 0x100003dc4
    if ((int32_t)v1 != 2) {
        int64_t v2 = *(int64_t *)*(int64_t *)0x100004000; // 0x100003df8
        _basename((char *)v1);
        _fprintf((struct _IO_FILE *)v2, "usage: %s <path>\n", (char *)v1);
        _exit(1);
        // UNREACHABLE
    }
    int64_t * v3 = (int64_t *)(v1 + 8); // 0x100003e34
    char * v4 = (char *)*v3; // 0x100003e38
    char * v5 = _strtok(v4, "/"); // 0x100003e4c
    if (v5 == NULL) {
        // 0x100003f1c
        return 0;
    }
    // 0x100003e68
    if (v5 != v4) {
        // 0x100003e80
        *(char *)((int64_t)v5 - 1) = 47;
    }
    // 0x100003e94
    int64_t v6; // bp-192, 0x100003dc4
    int32_t v7; // 0x100003dc4
    if (_stat((char *)*v3, (struct stat *)&v6) == -1) {
        // 0x100003eb4
        _mkdir((char *)*v3, 0);
    } else {
        if ((v7 & 0xf000) != 0x4000) {
            // break -> 0x100003ee0
            break;
        }
    }
    char * v8 = _strtok(NULL, "/"); // 0x100003e4c
    while (v8 != NULL) {
        char * v9 = v8;
        if (v9 != NULL) {
            // 0x100003e80
            *(char *)((int64_t)v9 - 1) = 47;
        }
        // 0x100003e94
        if (_stat((char *)*v3, (struct stat *)&v6) == -1) {
            // 0x100003eb4
            _mkdir((char *)*v3, 0);
        } else {
            if ((v7 & 0xf000) != 0x4000) {
                // break -> 0x100003ee0
                break;
            }
        }
        // 0x100003f14
        v8 = _strtok(NULL, "/");
    }
    // 0x100003f1c
    return 0;
}

// Address range: 0x100003f2c - 0x100003f38
char * function_100003f2c(char * filename) {
    // 0x100003f2c
    return _basename(filename);
}

// Address range: 0x100003f38 - 0x100003f44
void function_100003f38(int32_t status) {
    // 0x100003f38
    _exit(status);
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003f44
    return _fprintf(stream, format);
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * path, int32_t mode) {
    // 0x100003f50
    return _mkdir(path, mode);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(char * file, struct stat * buf) {
    // 0x100003f5c
    return _stat(file, buf);
}

// Address range: 0x100003f68 - 0x100003f74
char * function_100003f68(char * s, char * delim) {
    // 0x100003f68
    return _strtok(s, delim);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 7

`
`#include <stdlib.h>
#include <time.h>
#include <stdio.h>

int main() {
    int a[10][10], i, j;

    srand(time(NULL));
    for (i = 0; i < 10; i++)
        for (j = 0; j < 10; j++)
            a[i][j] = rand() % 20 + 1;

    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            printf(" %d", a[i][j]);
            if (a[i][j] == 20)
                goto Done;
        }
        printf("\n");
    }
Done:
    printf("\n");
    return 0;
}
`,`#include "loops-nested-1.h"



undefined8 entry(void)

{
  int iVar1;
  time_t tVar2;
  int local_1c4;
  int local_1c0;
  int aiStack_1b8 [100];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  tVar2 = _time((time_t *)0x0);
  _srand((uint)tVar2);
  for (local_1c0 = 0; local_1c0 < 10; local_1c0 = local_1c0 + 1) {
    for (local_1c4 = 0; local_1c4 < 10; local_1c4 = local_1c4 + 1) {
      iVar1 = _rand();
      aiStack_1b8[(long)local_1c0 * 10 + (long)local_1c4] = iVar1 % 0x14 + 1;
    }
  }
  for (local_1c0 = 0; local_1c0 < 10; local_1c0 = local_1c0 + 1) {
    for (local_1c4 = 0; local_1c4 < 10; local_1c4 = local_1c4 + 1) {
      _printf(" %d");
      if (aiStack_1b8[(long)local_1c0 * 10 + (long)local_1c4] == 0x14) goto LAB_100003f20;
    }
    _printf("\n");
  }
LAB_100003f20:
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004018)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f9c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004028)();
  return tVar1;
}


`
`//FormAI DATASET v1.0 Category: Fractal Generation ; Style: enthusiastic
#include <stdio.h>

int main() {
    printf("Welcome to the world of fractals!\n");
    printf("Are you ready to witness the beauty of the Mandelbrot set?\n");
    printf("Buckle up, because this is going to be an adventure!\n");

    int x, y;
    double zx, zy, cX, cY, tmp;

    int max_iterations = 50;
    double zoom = 1.0;
    double moveX = -0.5;
    double moveY = 0.0;

    int width = 80;
    int height = 40;

    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            zx = zy = 0;
            cX = (x - width / 2.0) / (0.5 * zoom * width) + moveX;
            cY = (y - height / 2.0) / (0.5 * zoom * height) + moveY;
            int i = max_iterations;

            while (zx * zx + zy * zy < 4 && i-- > 0) {
                tmp = zx * zx - zy * zy + cX;
                zy = 2.0 * zx * zy + cY;
                zx = tmp;
            }

            if (i > 0) {
                putchar('#');
            } else {
                putchar('.');
            }
        }
        putchar('\n');
    }

    printf("Wow, wasn't that amazing?\n");
    printf("Fractals are truly a magical thing.\n");
    printf("Now that you've seen the Mandelbrot set, what other fractals would you like to explore?\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl putchar(int Character);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  double v5; // [rsp+28h] [rbp-58h]
  int v6; // [rsp+64h] [rbp-1Ch]
  double v7; // [rsp+68h] [rbp-18h]
  double v8; // [rsp+70h] [rbp-10h]
  int i; // [rsp+78h] [rbp-8h]
  int j; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the world of fractals!\n");
  printf("Are you ready to witness the beauty of the Mandelbrot set?\n");
  printf("Buckle up, because this is going to be an adventure!\n");
  for ( i = 0; i < 40; ++i )
  {
    for ( j = 0; j < 80; ++j )
    {
      v7 = 0.0;
      v8 = 0.0;
      v6 = 50;
      while ( v8 * v8 + v7 * v7 < 4.0 )
      {
        v3 = v6--;
        if ( v3 <= 0 )
          break;
        v5 = v8 * v8 - v7 * v7 + ((double)j - (double)80 / 2.0) / ((double)80 * (1.0 * 0.5)) + -0.5;
        v7 = (v8 + v8) * v7 + ((double)i - (double)40 / 2.0) / ((double)40 * (1.0 * 0.5)) + 0.0;
        v8 = v5;
      }
      if ( v6 <= 0 )
        putchar(46);
      else
        putchar(35);
    }
    putchar(10);
  }
  printf("Wow, wasn't that amazing?\n");
  printf("Fractals are truly a magical thing.\n");
  printf("Now that you've seen the Mandelbrot set, what other fractals would you like to explore?\n");
  return 0;
}
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>

int main() {
  remove("input.txt");
  remove("/input.txt");
  remove("docs");
  remove("/docs");
  return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003f7c(char * filename);

// ------- Dynamically Linked Functions Without Header --------

int32_t _remove(char * a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003f24 - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003f24
    _remove("input.txt");
    _remove("/input.txt");
    _remove("docs");
    _remove("/docs");
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * filename) {
    // 0x100003f7c
    return _remove(filename);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 2

`
`   #include<stdlib.h>
   #include<ctype.h>
   #include<stdio.h>

   int** oddMagicSquare(int n) {
        if (n < 3 || n % 2 == 0)
            return NULL;

        int value = 0;
        int squareSize = n * n;
        int c = n / 2, r = 0,i;

        int** result = (int**)malloc(n*sizeof(int*));
		
		for(i=0;i<n;i++)
			result[i] = (int*)malloc(n*sizeof(int));

        while (++value <= squareSize) {
            result[r][c] = value;
            if (r == 0) {
                if (c == n - 1) {
                    r++;
                } else {
                    r = n - 1;
                    c++;
                }
            } else if (c == n - 1) {
                r--;
                c = 0;
            } else if (result[r - 1][c + 1] == 0) {
                r--;
                c++;
            } else {
                r++;
            }
        }
        return result;
    }

    int** singlyEvenMagicSquare(int n) {
        if (n < 6 || (n - 2) % 4 != 0)
            return NULL;

        int size = n * n;
        int halfN = n / 2;
        int subGridSize = size / 4, i;

        int** subGrid = oddMagicSquare(halfN);
        int gridFactors[] = {0, 2, 3, 1};
        int** result = (int**)malloc(n*sizeof(int*));
		
		for(i=0;i<n;i++)
			result[i] = (int*)malloc(n*sizeof(int));

        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                int grid = (r / halfN) * 2 + (c / halfN);
                result[r][c] = subGrid[r % halfN][c % halfN];
                result[r][c] += gridFactors[grid] * subGridSize;
            }
        }

        int nColsLeft = halfN / 2;
        int nColsRight = nColsLeft - 1;

        for (int r = 0; r < halfN; r++)
            for (int c = 0; c < n; c++) {
                if (c < nColsLeft || c >= n - nColsRight
                        || (c == nColsLeft && r == nColsLeft)) {

                    if (c == 0 && r == nColsLeft)
                        continue;

                    int tmp = result[r][c];
                    result[r][c] = result[r + halfN][c];
                    result[r + halfN][c] = tmp;
                }
            }

        return result;
    }
	
	int numDigits(int n){
		int count = 1;
		
		while(n>=10){
			n /= 10;
			count++;
		}
		
		return count;
	}
	
	void printMagicSquare(int** square,int rows){
		int i,j;
		
		for(i=0;i<rows;i++){
			for(j=0;j<rows;j++){
				printf("%*s%d",rows - numDigits(square[i][j]),"",square[i][j]);
			}
			printf("\n");
		}
		printf("\nMagic constant: %d ", (rows * rows + 1) * rows / 2);
	}
	
	int main(int argC,char* argV[])
	{
		int n;
		
		if(argC!=2||isdigit(argV[1][0])==0)
			printf("Usage : %s <integer specifying rows in magic square>",argV[0]);
		else{
			n = atoi(argV[1]);
			printMagicSquare(singlyEvenMagicSquare(n),n);
		}
		return 0;
	}
`,`#include "magic-squares-of-singly-even-order.h"



void * _oddMagicSquare(int param_1)

{
  void *pvVar1;
  int local_30;
  int local_2c;
  int local_28;
  int local_20;
  void *local_18;
  
  if ((param_1 < 3) || (param_1 % 2 == 0)) {
    local_18 = (void *)0x0;
  }
  else {
    local_20 = 0;
    local_28 = param_1 / 2;
    local_2c = 0;
    local_18 = _malloc((long)param_1 << 3);
    for (local_30 = 0; local_30 < param_1; local_30 = local_30 + 1) {
      pvVar1 = _malloc((long)param_1 << 2);
      *(void **)((long)local_18 + (long)local_30 * 8) = pvVar1;
    }
    while (local_20 = local_20 + 1, local_20 <= param_1 * param_1) {
      *(int *)(*(long *)((long)local_18 + (long)local_2c * 8) + (long)local_28 * 4) = local_20;
      if (local_2c == 0) {
        if (local_28 == param_1 + -1) {
          local_2c = 1;
        }
        else {
          local_2c = param_1 + -1;
          local_28 = local_28 + 1;
        }
      }
      else if (local_28 == param_1 + -1) {
        local_2c = local_2c + -1;
        local_28 = 0;
      }
      else if (*(int *)(*(long *)((long)local_18 + (long)(local_2c + -1) * 8) +
                       (long)(local_28 + 1) * 4) == 0) {
        local_2c = local_2c + -1;
        local_28 = local_28 + 1;
      }
      else {
        local_2c = local_2c + 1;
      }
    }
  }
  return local_18;
}



void * _singlyEvenMagicSquare(int param_1)

{
  int *piVar1;
  undefined4 uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  long lVar8;
  void *pvVar9;
  int local_7c;
  int local_78;
  int local_68;
  int local_64;
  int local_4c;
  void *local_38;
  int local_30 [6];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  if ((param_1 < 6) || ((param_1 + -2) % 4 != 0)) {
    local_38 = (void *)0x0;
  }
  else {
    iVar3 = param_1 / 2;
    lVar8 = _oddMagicSquare(iVar3);
    local_30[2] = 3;
    local_30[3] = 1;
    local_30[0] = 0;
    local_30[1] = 2;
    local_38 = _malloc((long)param_1 << 3);
    for (local_4c = 0; local_4c < param_1; local_4c = local_4c + 1) {
      pvVar9 = _malloc((long)param_1 << 2);
      *(void **)((long)local_38 + (long)local_4c * 8) = pvVar9;
    }
    for (local_64 = 0; local_64 < param_1; local_64 = local_64 + 1) {
      for (local_68 = 0; local_68 < param_1; local_68 = local_68 + 1) {
        iVar4 = 0;
        if (iVar3 != 0) {
          iVar4 = local_64 / iVar3;
        }
        iVar5 = 0;
        if (iVar3 != 0) {
          iVar5 = local_68 / iVar3;
        }
        iVar6 = 0;
        if (iVar3 != 0) {
          iVar6 = local_64 / iVar3;
        }
        iVar7 = 0;
        if (iVar3 != 0) {
          iVar7 = local_68 / iVar3;
        }
        *(undefined4 *)(*(long *)((long)local_38 + (long)local_64 * 8) + (long)local_68 * 4) =
             *(undefined4 *)
              (*(long *)(lVar8 + (long)(local_64 - iVar6 * iVar3) * 8) +
              (long)(local_68 - iVar7 * iVar3) * 4);
        piVar1 = (int *)(*(long *)((long)local_38 + (long)local_64 * 8) + (long)local_68 * 4);
        *piVar1 = *piVar1 + local_30[iVar5 + iVar4 * 2] * ((param_1 * param_1) / 4);
      }
    }
    iVar4 = iVar3 / 2;
    for (local_78 = 0; local_78 < iVar3; local_78 = local_78 + 1) {
      for (local_7c = 0; local_7c < param_1; local_7c = local_7c + 1) {
        if ((((local_7c < iVar4) || (param_1 - (iVar4 + -1) <= local_7c)) ||
            ((local_7c == iVar4 && (local_78 == iVar4)))) &&
           ((local_7c != 0 || (local_78 != iVar4)))) {
          uVar2 = *(undefined4 *)
                   (*(long *)((long)local_38 + (long)local_78 * 8) + (long)local_7c * 4);
          *(undefined4 *)(*(long *)((long)local_38 + (long)local_78 * 8) + (long)local_7c * 4) =
               *(undefined4 *)
                (*(long *)((long)local_38 + (long)(local_78 + iVar3) * 8) + (long)local_7c * 4);
          *(undefined4 *)
           (*(long *)((long)local_38 + (long)(local_78 + iVar3) * 8) + (long)local_7c * 4) = uVar2;
        }
      }
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return local_38;
}



int _numDigits(int param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 1;
  for (local_4 = param_1; 9 < local_4; local_4 = local_4 / 10) {
    local_8 = local_8 + 1;
  }
  return local_8;
}



int _printMagicSquare(long param_1,int param_2)

{
  int iVar1;
  int local_24;
  int local_20;
  
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
      _numDigits(*(undefined4 *)(*(long *)(param_1 + (long)local_20 * 8) + (long)local_24 * 4));
      _printf("%*s%d");
    }
    _printf("\n");
  }
  iVar1 = _printf("\nMagic constant: %d ");
  return iVar1;
}



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  undefined8 uVar2;
  
  if ((param_1 == 2) && (iVar1 = _isdigit((int)**(char **)(param_2 + 8)), iVar1 != 0)) {
    iVar1 = _atoi(*(char **)(param_2 + 8));
    uVar2 = _singlyEvenMagicSquare(iVar1);
    _printMagicSquare(uVar2,iVar1);
  }
  else {
    _printf("Usage : %s <integer specifying rows in magic square>");
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isdigit(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isdigit_100004018)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

#define MAX 15

int count_divisors(int n) {
    int i, count = 0;
    for (i = 1; i * i <= n; ++i) {
        if (!(n % i)) {
            if (i == n / i)
                count++;
            else
                count += 2;
        }
    }
    return count;
}

int main() {
    int i, next = 1;
    printf("The first %d terms of the sequence are:\n", MAX);
    for (i = 1; next <= MAX; ++i) {
        if (next == count_divisors(i)) {
            printf("%d ", i);
            next++;
        }
    }
    printf("\n");
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003dd0(void);
int32_t function_100003f64(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003dd0 - 0x100003e90
int64_t function_100003dd0(void) {
    // 0x100003dd0
    int64_t v1; // 0x100003dd0
    int32_t v2 = v1; // 0x100003dd4
    int32_t v3 = 1 - v2; // 0x100003df8
    if (v3 != 0 && v3 < 0 == (v3 & v2) < 0) {
        // 0x100003e84
        return 0;
    }
    int32_t v4 = 0;
    int32_t v5 = 1;
    int32_t v6 = v4; // 0x100003e24
    int32_t v7; // 0x100003dd0
    if (v2 % v5 == 0) {
        // 0x100003e2c
        v7 = v5 == v2 / v5 ? 1 : 2;
        v6 = v7 + v4;
    }
    int32_t result = v6;
    int32_t v8 = v5 + 1; // 0x100003e78
    int32_t v9 = v8 * v8; // 0x100003df0
    int32_t v10 = v9 - v2; // 0x100003df8
    while (v10 == 0 || v10 < 0 != ((v10 ^ v9) & (v9 ^ v2)) < 0) {
        // 0x100003e08
        v4 = result;
        v5 = v8;
        v6 = v4;
        if (v2 % v5 == 0) {
            // 0x100003e2c
            v7 = v5 == v2 / v5 ? 1 : 2;
            v6 = v7 + v4;
        }
        // 0x100003e74
        result = v6;
        v8 = v5 + 1;
        v9 = v8 * v8;
        v10 = v9 - v2;
    }
    // 0x100003e84
    return result;
}

// Address range: 0x100003e90 - 0x100003f64
int64_t entry_point(void) {
    // 0x100003e90
    int64_t v1; // 0x100003e90
    _printf("The first %d terms of the sequence are:\n", v1);
    int32_t v2 = 1;
    int32_t v3 = v2; // 0x100003f00
    if (v2 == (int32_t)function_100003dd0()) {
        // 0x100003f08
        _printf("%d ", v1);
        v3 = v2 + 1;
    }
    // 0x100003f38
    while (v3 == 15 || v3 < 15 != (14 - v3 & v3) < 0) {
        // 0x100003ee4
        v2 = v3;
        v3 = v2;
        if (v2 == (int32_t)function_100003dd0()) {
            // 0x100003f08
            _printf("%d ", v1);
            v3 = v2 + 1;
        }
    }
    // 0x100003f48
    _printf((char *)0x100003f9d);
    return 0;
}

// Address range: 0x100003f64 - 0x100003f70
int32_t function_100003f64(char * format, ...) {
    // 0x100003f64
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`//FormAI DATASET v1.0 Category: Rogue-like Game with Procedural Generation ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAP_SIZE 100
#define MAX_ROOMS 20
#define MAX_ROOM_SIZE 10

typedef struct {
    int x, y, w, h;
} room_t;

char map[MAP_SIZE][MAP_SIZE];
room_t rooms[MAX_ROOMS];

void init_map() {
    int i, j;
    for (i = 0; i < MAP_SIZE; i++) {
        for (j = 0; j < MAP_SIZE; j++) {
            map[i][j] = '#';
        }
    }
}

int is_overlap(room_t r1, room_t r2) {
    int r1_x1 = r1.x;
    int r1_x2 = r1.x + r1.w - 1;
    int r1_y1 = r1.y;
    int r1_y2 = r1.y + r1.h - 1;

    int r2_x1 = r2.x;
    int r2_x2 = r2.x + r2.w - 1;
    int r2_y1 = r2.y;
    int r2_y2 = r2.y + r2.h - 1;

    if (r1_x1 <= r2_x2 && r1_x2 >= r2_x1 && r1_y1 <= r2_y2 && r1_y2 >= r2_y1) {
        return 1;
    } else {
        return 0;
    }
}

void place_room(int i) {
    int x, y, w, h, j;
    room_t room;

    do {
        x = rand() % (MAP_SIZE - MAX_ROOM_SIZE);
        y = rand() % (MAP_SIZE - MAX_ROOM_SIZE);
        w = rand() % MAX_ROOM_SIZE + 1;
        h = rand() % MAX_ROOM_SIZE + 1;

        room.x = x;
        room.y = y;
        room.w = w;
        room.h = h;

        for (j = 0; j < i; j++) {
            if (is_overlap(room, rooms[j])) {
                break;
            }
        }

    } while (j < i);

    rooms[i] = room;

    for (x = room.x + 1; x < room.x + room.w - 1; x++) {
        for (y = room.y + 1; y < room.y + room.h - 1; y++) {
            map[x][y] = '.';
        }
    }
}

void connect_rooms() {
    int i, x, y;
    room_t r1, r2;

    for (i = 1; i < MAX_ROOMS; i++) {
        r1 = rooms[i - 1];
        r2 = rooms[i];

        x = rand() % (r1.w - 2) + r1.x + 1;
        y = rand() % (r1.h - 2) + r1.y + 1;

        while (x != r2.x + r2.w / 2) {
            if (x < r2.x + r2.w / 2) {
                x++;
            } else {
                x--;
            }

            if (map[x][y] != '.') {
                map[x][y] = '.';
            }
        }

        while (y != r2.y + r2.h / 2) {
            if (y < r2.y + r2.h / 2) {
                y++;
            } else {
                y--;
            }

            if (map[x][y] != '.') {
                map[x][y] = '.';
            }
        }
    }
}

void print_map() {
    int i, j;

    for (i = 0; i < MAP_SIZE; i++) {
        for (j = 0; j < MAP_SIZE; j++) {
            putchar(map[i][j]);
        }
        putchar('\n');
    }
}

int main() {

    srand(time(NULL));

    init_map();

    int i;
    for (i = 0; i < MAX_ROOMS; i++) {
        place_room(i);
    }

    connect_rooms();

    print_map();

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 init_map(void); // weak
__int64 __fastcall place_room(_QWORD); // weak
__int64 connect_rooms(void); // weak
__int64 print_map(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001AFF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  init_map();
  for ( i = 0; i <= 19; ++i )
    place_room((unsigned int)i);
  connect_rooms();
  print_map();
  return 0;
}
// 14000155F: using guessed type __int64 init_map(void);
// 14000167D: using guessed type __int64 __fastcall place_room(_QWORD);
// 140001876: using guessed type __int64 connect_rooms(void);
// 140001A7F: using guessed type __int64 print_map(void);
// 140001C10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=88 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File system simulation ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_BLOCKS 100

typedef struct DirectoryEntry {
    char name[20];
    int firstBlock;
} DirectoryEntry;

typedef struct FileSystem {
    int freeBlockCount;
    int allocatedBlockCount;
    int blocks[MAX_BLOCKS];
    DirectoryEntry dir[MAX_BLOCKS];
} FileSystem;

void initializeFileSystem(FileSystem *fs) {
    fs->freeBlockCount = MAX_BLOCKS;
    fs->allocatedBlockCount = 0;
    
    for (int i = 0; i < MAX_BLOCKS; i++) {
        fs->blocks[i] = 0;
        strcpy(fs->dir[i].name, "");
        fs->dir[i].firstBlock = -1;
    }
}

int allocateBlock(FileSystem *fs) {
    if (fs->freeBlockCount > 0) {
        int randBlock = rand() % MAX_BLOCKS;
        while (fs->blocks[randBlock] == 1) {
            randBlock = rand() % MAX_BLOCKS;
        }
        fs->blocks[randBlock] = 1;
        fs->freeBlockCount--;
        fs->allocatedBlockCount++;
        return randBlock;
    }
    else {
        return -1;
    }
}

void addDirectoryEntry(FileSystem *fs, char *name, int firstBlock) {
    for (int i = 0; i < MAX_BLOCKS; i++) {
        if (strcmp(fs->dir[i].name, "") == 0) {
            strcpy(fs->dir[i].name, name);
            fs->dir[i].firstBlock = firstBlock;
            break;
        }
    }
}

void printDirectory(FileSystem *fs) {
    printf("DIRECTORY CONTENTS:\n");
    for (int i = 0; i < MAX_BLOCKS; i++) {
        if (strcmp(fs->dir[i].name, "") != 0) {
            printf("%s - firstBlock: %d\n", fs->dir[i].name, fs->dir[i].firstBlock);
        }
    }
}

int main() {
    srand(time(0));
    
    FileSystem fs;
    initializeFileSystem(&fs);
    
    printf("Creating file 'alice'...\n");
    int aliceBlock = allocateBlock(&fs);
    addDirectoryEntry(&fs, "alice", aliceBlock);
    printf("Created file 'alice' in block %d\n", aliceBlock);
    printf("Free blocks remaining: %d\n", fs.freeBlockCount);
    
    printf("\nCreating file 'bob'...\n");
    int bobBlock = allocateBlock(&fs);
    addDirectoryEntry(&fs, "bob", bobBlock);
    printf("Created file 'bob' in block %d\n", bobBlock);
    printf("Free blocks remaining: %d\n", fs.freeBlockCount);
    
    printf("\nCreating file 'charlie'...\n");
    int charlieBlock = allocateBlock(&fs);
    addDirectoryEntry(&fs, "charlie", charlieBlock);
    printf("Created file 'charlie' in block %d\n", charlieBlock);
    printf("Free blocks remaining: %d\n", fs.freeBlockCount);
    
    printf("\nCreating file 'david'...\n");
    int davidBlock = allocateBlock(&fs);
    addDirectoryEntry(&fs, "david", davidBlock);
    printf("Created file 'david' in block %d\n", davidBlock);
    printf("Free blocks remaining: %d\n", fs.freeBlockCount);
    
    printDirectory(&fs);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall initializeFileSystem(_QWORD); // weak
__int64 __fastcall allocateBlock(_QWORD); // weak
__int64 __fastcall addDirectoryEntry(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall printDirectory(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001899) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[704]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v6; // [rsp+B20h] [rbp+AA0h]
  unsigned int v7; // [rsp+B24h] [rbp+AA4h]
  unsigned int v8; // [rsp+B28h] [rbp+AA8h]
  unsigned int Block; // [rsp+B2Ch] [rbp+AACh]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  initializeFileSystem(v5);
  printf("Creating file 'alice'...\n");
  Block = allocateBlock(v5);
  addDirectoryEntry(v5, "alice", Block);
  printf("Created file 'alice' in block %d\n", Block);
  printf("Free blocks remaining: %d\n", (unsigned int)v5[0]);
  printf("\nCreating file 'bob'...\n");
  v8 = allocateBlock(v5);
  addDirectoryEntry(v5, "bob", v8);
  printf("Created file 'bob' in block %d\n", v8);
  printf("Free blocks remaining: %d\n", (unsigned int)v5[0]);
  printf("\nCreating file 'charlie'...\n");
  v7 = allocateBlock(v5);
  addDirectoryEntry(v5, "charlie", v7);
  printf("Created file 'charlie' in block %d\n", v7);
  printf("Free blocks remaining: %d\n", (unsigned int)v5[0]);
  printf("\nCreating file 'david'...\n");
  v6 = allocateBlock(v5);
  addDirectoryEntry(v5, "david", v6);
  printf("Created file 'david' in block %d\n", v6);
  printf("Free blocks remaining: %d\n", (unsigned int)v5[0]);
  printDirectory(v5);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall initializeFileSystem(_QWORD);
// 14000164C: using guessed type __int64 __fastcall allocateBlock(_QWORD);
// 140001713: using guessed type __int64 __fastcall addDirectoryEntry(_QWORD, _QWORD, _QWORD);
// 1400017D1: using guessed type __int64 __fastcall printDirectory(_QWORD);
// 140001B40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

typedef union uwb {
    unsigned w;
    unsigned char b[4];
} WBunion;

typedef unsigned Digest[4];

unsigned f0( unsigned abcd[] ){
    return ( abcd[1] & abcd[2]) | (~abcd[1] & abcd[3]);}

unsigned f1( unsigned abcd[] ){
    return ( abcd[3] & abcd[1]) | (~abcd[3] & abcd[2]);}

unsigned f2( unsigned abcd[] ){
    return  abcd[1] ^ abcd[2] ^ abcd[3];}

unsigned f3( unsigned abcd[] ){
    return abcd[2] ^ (abcd[1] |~ abcd[3]);}

typedef unsigned (*DgstFctn)(unsigned a[]);

unsigned *calcKs( unsigned *k)
{
    double s, pwr;
    int i;

    pwr = pow( 2, 32);
    for (i=0; i<64; i++) {
        s = fabs(sin(1+i));
        k[i] = (unsigned)( s * pwr );
    }
    return k;
}

// ROtate v Left by amt bits
unsigned rol( unsigned v, short amt )
{
    unsigned  msk1 = (1<<amt) -1;
    return ((v>>(32-amt)) & msk1) | ((v<<amt) & ~msk1);
}

unsigned *md5( const char *msg, int mlen)
{
    static Digest h0 = { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476 };
//    static Digest h0 = { 0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210 };
    static DgstFctn ff[] = { &f0, &f1, &f2, &f3 };
    static short M[] = { 1, 5, 3, 7 };
    static short O[] = { 0, 1, 5, 0 };
    static short rot0[] = { 7,12,17,22};
    static short rot1[] = { 5, 9,14,20};
    static short rot2[] = { 4,11,16,23};
    static short rot3[] = { 6,10,15,21};
    static short *rots[] = {rot0, rot1, rot2, rot3 };
    static unsigned kspace[64];
    static unsigned *k;

    static Digest h;
    Digest abcd;
    DgstFctn fctn;
    short m, o, g;
    unsigned f;
    short *rotn;
    union {
        unsigned w[16];
        char     b[64];
    }mm;
    int os = 0;
    int grp, grps, q, p;
    unsigned char *msg2;

    if (k==NULL) k= calcKs(kspace);

    for (q=0; q<4; q++) h[q] = h0[q];   // initialize

    {
        grps  = 1 + (mlen+8)/64;
        msg2 = malloc( 64*grps);
        memcpy( msg2, msg, mlen);
        msg2[mlen] = (unsigned char)0x80;
        q = mlen + 1;
        while (q < 64*grps){ msg2[q] = 0; q++ ; }
        {
//            unsigned char t;
            WBunion u;
            u.w = 8*mlen;
//            t = u.b[0]; u.b[0] = u.b[3]; u.b[3] = t;
//            t = u.b[1]; u.b[1] = u.b[2]; u.b[2] = t;
            q -= 8;
            memcpy(msg2+q, &u.w, 4 );
        }
    }

    for (grp=0; grp<grps; grp++)
    {
        memcpy( mm.b, msg2+os, 64);
        for(q=0;q<4;q++) abcd[q] = h[q];
        for (p = 0; p<4; p++) {
            fctn = ff[p];
            rotn = rots[p];
            m = M[p]; o= O[p];
            for (q=0; q<16; q++) {
                g = (m*q + o) % 16;
                f = abcd[1] + rol( abcd[0]+ fctn(abcd) + k[q+16*p] + mm.w[g], rotn[q%4]);

                abcd[0] = abcd[3];
                abcd[3] = abcd[2];
                abcd[2] = abcd[1];
                abcd[1] = f;
            }
        }
        for (p=0; p<4; p++)
            h[p] += abcd[p];
        os += 64;
    }

    if( msg2 )
        free( msg2 );

    return h;
}

int main( int argc, char *argv[] )
{
    int j,k;
    const char *msg = "The quick brown fox jumps over the lazy dog.";
    unsigned *d = md5(msg, strlen(msg));
    WBunion u;

    printf("= 0x");
    for (j=0;j<4; j++){
        u.w = d[j];
        for (k=0;k<4;k++) printf("%02x",u.b[k]);
    }
    printf("\n");

    return 0;
}
`,`#include "md5-2.h"



uint _f0(long param_1)

{
  return *(uint *)(param_1 + 4) & *(uint *)(param_1 + 8) |
         *(uint *)(param_1 + 0xc) & (*(uint *)(param_1 + 4) ^ 0xffffffff);
}



uint _f1(long param_1)

{
  return *(uint *)(param_1 + 0xc) & *(uint *)(param_1 + 4) |
         *(uint *)(param_1 + 8) & (*(uint *)(param_1 + 0xc) ^ 0xffffffff);
}



uint _f2(long param_1)

{
  return *(uint *)(param_1 + 4) ^ *(uint *)(param_1 + 8) ^ *(uint *)(param_1 + 0xc);
}



uint _f3(long param_1)

{
  return *(uint *)(param_1 + 8) ^ (*(uint *)(param_1 + 4) | *(uint *)(param_1 + 0xc) ^ 0xffffffff);
}



long _calcKs(long param_1)

{
  double dVar1;
  double dVar2;
  undefined4 local_2c;
  
  dVar1 = (double)_pow(0x4000000000000000,0x4040000000000000);
  for (local_2c = 0; local_2c < 0x40; local_2c = local_2c + 1) {
    dVar2 = (double)_sin((double)(local_2c + 1));
    *(int *)(param_1 + (long)local_2c * 4) = (int)(ABS(dVar2) * dVar1);
  }
  return param_1;
}



uint _rol(uint param_1,short param_2)

{
  uint uVar1;
  
  uVar1 = (1 << (ulong)((int)param_2 & 0x1f)) - 1;
  return param_1 >> (ulong)(0x20U - (int)param_2 & 0x1f) & uVar1 |
         param_1 << (ulong)((int)param_2 & 0x1f) & (uVar1 ^ 0xffffffff);
}



// WARNING: Restarted to delay deadcode elimination for space: stack

undefined * _md5(undefined8 param_1,int param_2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int local_bc;
  void *local_b8;
  int local_ac;
  int local_a8;
  int local_a4;
  int local_a0;
  int local_9c;
  int aiStack_98 [16];
  undefined *local_58;
  int local_4c;
  short local_46;
  short local_44;
  short local_42;
  code *local_40;
  int local_34;
  undefined8 local_30;
  int local_28 [4];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_9c = 0;
  local_34 = param_2;
  local_30 = param_1;
  if (DAT_100008180 == 0) {
    DAT_100008180 = _calcKs(&DAT_100008080);
  }
  for (local_a8 = 0; local_a8 < 4; local_a8 = local_a8 + 1) {
    *(undefined4 *)(&DAT_100008188 + (long)local_a8 * 4) =
         *(undefined4 *)(&DAT_100008000 + (long)local_a8 * 4);
  }
  local_a4 = (local_34 + 8) / 0x40 + 1;
  local_b8 = _malloc((long)(local_a4 * 0x40));
  ___memcpy_chk(local_b8,local_30,(long)local_34,0xffffffffffffffff);
  *(undefined *)((long)local_b8 + (long)local_34) = 0x80;
  iVar3 = local_34;
  while (local_a8 = iVar3 + 1, local_a8 < local_a4 * 0x40) {
    *(undefined *)((long)local_b8 + (long)local_a8) = 0;
    iVar3 = local_a8;
  }
  local_bc = local_34 * 8;
  local_a8 = iVar3 + -7;
  ___memcpy_chk((long)local_b8 + (long)local_a8,&local_bc,4,0xffffffffffffffff);
  for (local_a0 = 0; local_a0 < local_a4; local_a0 = local_a0 + 1) {
    _memcpy(aiStack_98,(void *)((long)local_b8 + (long)local_9c),0x40);
    for (local_a8 = 0; local_a8 < 4; local_a8 = local_a8 + 1) {
      local_28[local_a8] = *(int *)(&DAT_100008188 + (long)local_a8 * 4);
    }
    for (local_ac = 0; local_ac < 4; local_ac = local_ac + 1) {
      local_40 = (code *)(&PTR__f0_100008010)[local_ac];
      local_58 = (&PTR_DAT_100008060)[local_ac];
      local_42 = *(short *)(&DAT_100008030 + (long)local_ac * 2);
      local_44 = *(short *)(&DAT_100008038 + (long)local_ac * 2);
      for (local_a8 = 0; iVar1 = local_28[1], iVar3 = local_28[0], local_a8 < 0x10;
          local_a8 = local_a8 + 1) {
        iVar2 = local_42 * local_a8 + (int)local_44;
        local_46 = (short)iVar2 + (short)(iVar2 / 0x10) * -0x10;
        iVar2 = (*local_40)(local_28);
        iVar3 = _rol(iVar3 + iVar2 +
                     *(int *)(DAT_100008180 + (long)(local_a8 + local_ac * 0x10) * 4) +
                     aiStack_98[local_46],(long)*(short *)(local_58 + (long)(local_a8 % 4) * 2));
        local_4c = iVar1 + iVar3;
        local_28[0] = local_28[3];
        local_28[3] = local_28[2];
        local_28[2] = local_28[1];
        local_28[1] = iVar1 + iVar3;
      }
    }
    for (local_ac = 0; local_ac < 4; local_ac = local_ac + 1) {
      *(int *)(&DAT_100008188 + (long)local_ac * 4) =
           *(int *)(&DAT_100008188 + (long)local_ac * 4) + local_28[local_ac];
    }
    local_9c = local_9c + 0x40;
  }
  if (local_b8 != (void *)0x0) {
    _free(local_b8);
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return &DAT_100008188;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  size_t sVar1;
  int local_28;
  int local_24;
  
  sVar1 = _strlen("The quick brown fox jumps over the lazy dog.");
  _md5("The quick brown fox jumps over the lazy dog.",sVar1);
  _printf("= 0x");
  for (local_24 = 0; local_24 < 4; local_24 = local_24 + 1) {
    for (local_28 = 0; local_28 < 4; local_28 = local_28 + 1) {
      _printf("%02x");
    }
  }
  _printf("\n");
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}



void _sin(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__sin_100004040)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004048)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

struct item { double w, v; const char *name; } items[] = {
	{ 3.8, 36, "beef" },
	{ 5.4, 43, "pork" },
	{ 3.6, 90, "ham" },
	{ 2.4, 45, "greaves" },
	{ 4.0, 30, "flitch" },
	{ 2.5, 56, "brawn" },
	{ 3.7, 67, "welt" },
	{ 3.0, 95, "salami" },
	{ 5.9, 98, "sausage" },
};

int item_cmp(const void *aa, const void *bb)
{
	const struct item *a = aa, *b = bb;
	double ua = a->v / a->w, ub = b->v / b->w;
	return ua < ub ? -1 : ua > ub;
}

int main()
{
	struct item *it;
	double space = 15;

	qsort(items, 9, sizeof(struct item), item_cmp);
	for (it = items + 9; it---items && space > 0; space -= it->w)
		if (space >= it->w)
			printf("take all %s\n", it->name);
		else
			printf("take %gkg of %g kg of %s\n",
				space, it->w, it->name);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d4c(void);
int32_t function_100003f28(char * format, ...);
void function_100003f34(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));

// --------------------- Global Variables ---------------------

int64_t g1 = 0x400e666666666666; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
void _qsort(int64_t * a1, int32_t a2, int32_t a3, int32_t (*a4)(int64_t *, int64_t *));

// ------------------------ Functions -------------------------

// Address range: 0x100003d4c - 0x100003de4
int64_t function_100003d4c(void) {
    // 0x100003d4c
    int64_t v1; // 0x100003d4c
    int64_t v2 = v1;
    int64_t v3 = v1;
    float64_t v4 = *(float64_t *)(v3 + 8) / (float64_t)v3; // 0x100003d78
    float64_t v5 = *(float64_t *)(v2 + 8) / (float64_t)v2; // 0x100003d90
    return v4 > v5 ? 0xffffffff : (int64_t)(v4 < v5);
}

// Address range: 0x100003de4 - 0x100003f28
int64_t entry_point(void) {
    // 0x100003de4
    _qsort(&g1, 9, 24, (int32_t (*)(int64_t *, int64_t *))0x100003d4c);
    return 0;
}

// Address range: 0x100003f28 - 0x100003f34
int32_t function_100003f28(char * format, ...) {
    // 0x100003f28
    return _printf(format);
}

// Address range: 0x100003f34 - 0x100003f40
void function_100003f34(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x100003f34
    _qsort(base, nmemb, size, compar);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <stdint.h>
#include <ctype.h>

typedef unsigned char uchar;

typedef enum {
    nd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While,
    nd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,
    nd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or
} NodeType;

typedef enum { FETCH, STORE, PUSH, ADD, SUB, MUL, DIV, MOD, LT, GT, LE, GE, EQ, NE, AND,
    OR, NEG, NOT, JMP, JZ, PRTC, PRTS, PRTI, HALT
} Code_t;

typedef uchar code;

typedef struct Tree {
    NodeType node_type;
    struct Tree *left;
    struct Tree *right;
    char *value;
} Tree;

#define da_dim(name, type)  type *name = NULL;          \
                            int _qy_ ## name ## _p = 0;  \
                            int _qy_ ## name ## _max = 0

#define da_redim(name)      do {if (_qy_ ## name ## _p >= _qy_ ## name ## _max) \
                                name = realloc(name, (_qy_ ## name ## _max += 32) * sizeof(name[0]));} while (0)

#define da_rewind(name)     _qy_ ## name ## _p = 0

#define da_append(name, x)  do {da_redim(name); name[_qy_ ## name ## _p++] = x;} while (0)
#define da_len(name)        _qy_ ## name ## _p
#define da_add(name)        do {da_redim(name); _qy_ ## name ## _p++;} while (0)

FILE *source_fp, *dest_fp;
static int here;
da_dim(object, code);
da_dim(globals, const char *);
da_dim(string_pool, const char *);

// dependency: Ordered by NodeType, must remain in same order as NodeType enum
struct {
    char       *enum_text;
    NodeType   node_type;
    Code_t     opcode;
} atr[] = {
    {"Identifier"  , nd_Ident,    -1 },
    {"String"      , nd_String,   -1 },
    {"Integer"     , nd_Integer,  -1 },
    {"Sequence"    , nd_Sequence, -1 },
    {"If"          , nd_If,       -1 },
    {"Prtc"        , nd_Prtc,     -1 },
    {"Prts"        , nd_Prts,     -1 },
    {"Prti"        , nd_Prti,     -1 },
    {"While"       , nd_While,    -1 },
    {"Assign"      , nd_Assign,   -1 },
    {"Negate"      , nd_Negate,   NEG},
    {"Not"         , nd_Not,      NOT},
    {"Multiply"    , nd_Mul,      MUL},
    {"Divide"      , nd_Div,      DIV},
    {"Mod"         , nd_Mod,      MOD},
    {"Add"         , nd_Add,      ADD},
    {"Subtract"    , nd_Sub,      SUB},
    {"Less"        , nd_Lss,      LT },
    {"LessEqual"   , nd_Leq,      LE },
    {"Greater"     , nd_Gtr,      GT },
    {"GreaterEqual", nd_Geq,      GE },
    {"Equal"       , nd_Eql,      EQ },
    {"NotEqual"    , nd_Neq,      NE },
    {"And"         , nd_And,      AND},
    {"Or"          , nd_Or,       OR },
};

void error(const char *fmt, ... ) {
    va_list ap;
    char buf[1000];

    va_start(ap, fmt);
    vsprintf(buf, fmt, ap);
    va_end(ap);
    printf("error: %s\n", buf);
    exit(1);
}

Code_t type_to_op(NodeType type) {
    return atr[type].opcode;
}

Tree *make_node(NodeType node_type, Tree *left, Tree *right) {
    Tree *t = calloc(sizeof(Tree), 1);
    t->node_type = node_type;
    t->left = left;
    t->right = right;
    return t;
}

Tree *make_leaf(NodeType node_type, char *value) {
    Tree *t = calloc(sizeof(Tree), 1);
    t->node_type = node_type;
    t->value = strdup(value);
    return t;
}

/*** Code generator ***/

void emit_byte(int c) {
    da_append(object, (uchar)c);
    ++here;
}

void emit_int(int32_t n) {
    union {
        int32_t n;
        unsigned char c[sizeof(int32_t)];
    } x;

    x.n = n;

    for (size_t i = 0; i < sizeof(x.n); ++i) {
        emit_byte(x.c[i]);
    }
}

int hole() {
    int t = here;
    emit_int(0);
    return t;
}

void fix(int src, int dst) {
    *(int32_t *)(object + src) = dst-src;
}

int fetch_var_offset(const char *id) {
    for (int i = 0; i < da_len(globals); ++i) {
        if (strcmp(id, globals[i]) == 0)
            return i;
    }
    da_add(globals);
    int n = da_len(globals) - 1;
    globals[n] = strdup(id);
    return n;
}

int fetch_string_offset(const char *st) {
    for (int i = 0; i < da_len(string_pool); ++i) {
        if (strcmp(st, string_pool[i]) == 0)
            return i;
    }
    da_add(string_pool);
    int n = da_len(string_pool) - 1;
    string_pool[n] = strdup(st);
    return n;
}

void code_gen(Tree *x) {
    int p1, p2, n;

    if (x == NULL) return;
    switch (x->node_type) {
        case nd_Ident:
            emit_byte(FETCH);
            n = fetch_var_offset(x->value);
            emit_int(n);
            break;
        case nd_Integer:
            emit_byte(PUSH);
            emit_int(atoi(x->value));
            break;
        case nd_String:
            emit_byte(PUSH);
            n = fetch_string_offset(x->value);
            emit_int(n);
            break;
        case nd_Assign:
            n = fetch_var_offset(x->left->value);
            code_gen(x->right);
            emit_byte(STORE);
            emit_int(n);
            break;
        case nd_If:
            code_gen(x->left);        // if expr
            emit_byte(JZ);                  // if false, jump
            p1 = hole();                    // make room for jump dest
            code_gen(x->right->left);   // if true statements
            if (x->right->right != NULL) {
                emit_byte(JMP);
                p2 = hole();
            }
            fix(p1, here);
            if (x->right->right != NULL) {
                code_gen(x->right->right);
                fix(p2, here);
            }
            break;
        case nd_While:
            p1 = here;
            code_gen(x->left);        // while expr
            emit_byte(JZ);                  // if false, jump
            p2 = hole();                    // make room for jump dest
            code_gen(x->right);       // statements
            emit_byte(JMP);                 // back to the top
            fix(hole(), p1);                // plug the top
            fix(p2, here);                  // plug the 'if false, jump'
            break;
        case nd_Sequence:
            code_gen(x->left);
            code_gen(x->right);
            break;
        case nd_Prtc:
            code_gen(x->left);
            emit_byte(PRTC);
            break;
        case nd_Prti:
            code_gen(x->left);
            emit_byte(PRTI);
            break;
        case nd_Prts:
            code_gen(x->left);
            emit_byte(PRTS);
            break;
        case nd_Lss: case nd_Gtr: case nd_Leq: case nd_Geq: case nd_Eql: case nd_Neq:
        case nd_And: case nd_Or: case nd_Sub: case nd_Add: case nd_Div: case nd_Mul:
        case nd_Mod:
            code_gen(x->left);
            code_gen(x->right);
            emit_byte(type_to_op(x->node_type));
            break;
        case nd_Negate: case nd_Not:
            code_gen(x->left);
            emit_byte(type_to_op(x->node_type));
            break;
        default:
            error("error in code generator - found %d, expecting operator\n", x->node_type);
    }
}

void code_finish() {
    emit_byte(HALT);
}

void list_code() {
    fprintf(dest_fp, "Datasize: %d Strings: %d\n", da_len(globals), da_len(string_pool));
    for (int i = 0; i < da_len(string_pool); ++i)
        fprintf(dest_fp, "%s\n", string_pool[i]);

    code *pc = object;

    again: fprintf(dest_fp, "%5d ", (int)(pc - object));
    switch (*pc++) {
        case FETCH: fprintf(dest_fp, "fetch [%d]\n", *(int32_t *)pc);
                    pc += sizeof(int32_t);  goto again;
        case STORE: fprintf(dest_fp, "store [%d]\n", *(int32_t *)pc);
                    pc += sizeof(int32_t);  goto again;
        case PUSH : fprintf(dest_fp, "push  %d\n", *(int32_t *)pc);
                    pc += sizeof(int32_t);    goto again;
        case ADD  : fprintf(dest_fp, "add\n");      goto again;
        case SUB  : fprintf(dest_fp, "sub\n");      goto again;
        case MUL  : fprintf(dest_fp, "mul\n");      goto again;
        case DIV  : fprintf(dest_fp, "div\n");      goto again;
        case MOD  : fprintf(dest_fp, "mod\n");      goto again;
        case LT   : fprintf(dest_fp, "lt\n");       goto again;
        case GT   : fprintf(dest_fp, "gt\n");       goto again;
        case LE   : fprintf(dest_fp, "le\n");       goto again;
        case GE   : fprintf(dest_fp, "ge\n");       goto again;
        case EQ   : fprintf(dest_fp, "eq\n");       goto again;
        case NE   : fprintf(dest_fp, "ne\n");       goto again;
        case AND  : fprintf(dest_fp, "and\n");      goto again;
        case OR   : fprintf(dest_fp, "or\n");       goto again;
        case NOT  : fprintf(dest_fp, "not\n");      goto again;
        case NEG  : fprintf(dest_fp, "neg\n");      goto again;
        case JMP  : fprintf(dest_fp, "jmp    (%d) %d\n",
                        *(int32_t *)pc, (int32_t)(pc + *(int32_t *)pc - object));
                    pc += sizeof(int32_t); goto again;
        case JZ   : fprintf(dest_fp, "jz     (%d) %d\n",
                        *(int32_t *)pc, (int32_t)(pc + *(int32_t *)pc - object));
                    pc += sizeof(int32_t); goto again;
        case PRTC : fprintf(dest_fp, "prtc\n");     goto again;
        case PRTI : fprintf(dest_fp, "prti\n");     goto again;
        case PRTS : fprintf(dest_fp, "prts\n");     goto again;
        case HALT : fprintf(dest_fp, "halt\n");     break;
        default:error("listcode:Unknown opcode %d\n", *(pc - 1));
    }
}

void init_io(FILE **fp, FILE *std, const char mode[], const char fn[]) {
    if (fn[0] == '\0')
        *fp = std;
    else if ((*fp = fopen(fn, mode)) == NULL)
        error(0, 0, "Can't open %s\n", fn);
}

NodeType get_enum_value(const char name[]) {
    for (size_t i = 0; i < sizeof(atr) / sizeof(atr[0]); i++) {
        if (strcmp(atr[i].enum_text, name) == 0) {
            return atr[i].node_type;
        }
    }
    error("Unknown token %s\n", name);
    return -1;
}

char *read_line(int *len) {
    static char *text = NULL;
    static int textmax = 0;

    for (*len = 0; ; (*len)++) {
        int ch = fgetc(source_fp);
        if (ch == EOF || ch == '\n') {
            if (*len == 0)
                return NULL;
            break;
        }
        if (*len + 1 >= textmax) {
            textmax = (textmax == 0 ? 128 : textmax * 2);
            text = realloc(text, textmax);
        }
        text[*len] = ch;
    }
    text[*len] = '\0';
    return text;
}

char *rtrim(char *text, int *len) {         // remove trailing spaces
    for (; *len > 0 && isspace(text[*len - 1]); --(*len))
        ;

    text[*len] = '\0';
    return text;
}

Tree *load_ast() {
    int len;
    char *yytext = read_line(&len);
    yytext = rtrim(yytext, &len);

    // get first token
    char *tok = strtok(yytext, " ");

    if (tok[0] == ';') {
        return NULL;
    }
    NodeType node_type = get_enum_value(tok);

    // if there is extra data, get it
    char *p = tok + strlen(tok);
    if (p != &yytext[len]) {
        for (++p; isspace(*p); ++p)
            ;
        return make_leaf(node_type, p);
    }

    Tree *left  = load_ast();
    Tree *right = load_ast();
    return make_node(node_type, left, right);
}

int main(int argc, char *argv[]) {
    init_io(&source_fp, stdin,  "r",  argc > 1 ? argv[1] : "");
    init_io(&dest_fp,   stdout, "wb", argc > 2 ? argv[2] : "");

    code_gen(load_ast());
    code_finish();
    list_code();

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002970(void);
int64_t function_1000029dc(void);
int64_t function_100002a04(int32_t a1, int64_t a2, int64_t a3);
int64_t function_100002a60(void);
int64_t function_100002ab0(void);
int64_t function_100002b68(void);
int64_t function_100002bcc(int64_t a1);
int64_t function_100002bfc(void);
int64_t function_100002c2c(void);
int64_t function_100002d64(void);
int64_t function_100002e9c(void);
int64_t function_1000031ec(int64_t a1);
int64_t function_100003204(int64_t a1, int64_t a2);
int64_t function_100003748(void);
int64_t function_1000037ec(void);
int64_t function_1000038a8(void);
int64_t function_100003a10(void);
int64_t function_100003ab8(void);
int64_t function_100003ce4(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t function_100003cf0(char * nptr);
int64_t * function_100003cfc(int32_t nmemb, int32_t size);
void function_100003d08(int32_t status);
int32_t function_100003d14(struct _IO_FILE * stream);
struct _IO_FILE * function_100003d20(char * filename, char * modes);
int32_t function_100003d2c(struct _IO_FILE * stream, char * format, ...);
int32_t function_100003d38(int32_t c);
int32_t function_100003d44(char * format, ...);
int64_t * function_100003d50(int64_t * ptr, int32_t size);
int32_t function_100003d5c(char * s1, char * s2);
char * function_100003d68(char * s);
int32_t function_100003d74(char * s);
char * function_100003d80(char * s, char * delim);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x20000000003d8c; // 0x100008000
int64_t g2 = 0x100000cfeedfacf; // 0x100008190
int32_t g3 = 0; // 0x100008198
int32_t g4 = 2; // 0x10000819c
int64_t g5 = 0x55800000012; // 0x1000081a0
int32_t g6 = 0x200085; // 0x1000081a8
int32_t g7 = 0; // 0x1000081ac
int64_t g8 = 0x4800000019; // 0x1000081b0
char g9[11] = "__PAGEZERO"; // 0x1000081b8
char g10[7] = "GEZERO"; // 0x1000081bc
struct _IO_FILE * g11 = NULL; // 0x1000081c8
int32_t g12 = 0; // 0x1000081d0
int64_t g13 = 0; // 0x1000081d8
int32_t g14 = 0; // 0x1000081e0
int32_t g15;

// ------- Dynamically Linked Functions Without Header --------

int64_t ___vsprintf_chk(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int32_t _atoi(char * a1);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fgetc(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
int32_t _fprintf(struct _IO_FILE * a1, char * a2, ...);
int32_t _isspace(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);
char * _strtok(char * a1, char * a2);

// ------------------------ Functions -------------------------

// Address range: 0x100002970 - 0x1000029dc
int64_t function_100002970(void) {
    // 0x100002970
    int64_t v1; // 0x100002970
    int64_t v2; // bp-1032, 0x100002970
    int64_t v3; // 0x100002970
    ___vsprintf_chk(&v2, 0, 1000, v3, (int64_t)&v1);
    _printf("error: %s\n", NULL);
    _exit(1);
    // UNREACHABLE
}

// Address range: 0x1000029dc - 0x100002a04
int64_t function_1000029dc(void) {
    // 0x1000029dc
    int64_t v1; // 0x1000029dc
    uint32_t result = *(int32_t *)((16 * v1 & 0xffffffff0) + (int64_t)&g1 + 12); // 0x1000029f8
    return result;
}

// Address range: 0x100002a04 - 0x100002a60
int64_t function_100002a04(int32_t a1, int64_t a2, int64_t a3) {
    int64_t * v1 = _calloc(32, 1); // 0x100002a24
    *(int32_t *)v1 = a1;
    int64_t result = (int64_t)v1; // 0x100002a3c
    *(int64_t *)(result + 8) = a2;
    *(int64_t *)(result + 16) = a3;
    return result;
}

// Address range: 0x100002a60 - 0x100002ab0
int64_t function_100002a60(void) {
    int64_t * v1 = _calloc(32, 1); // 0x100002a7c
    int64_t result = (int64_t)v1; // 0x100002a7c
    int64_t v2; // 0x100002a60
    *(int32_t *)v1 = (int32_t)v2;
    *(int64_t *)(result + 24) = (int64_t)_strdup((char *)v2);
    return result;
}

// Address range: 0x100002ab0 - 0x100002b68
int64_t function_100002ab0(void) {
    int32_t v1 = g3; // 0x100002acc
    int32_t v2 = v1 - g4; // 0x100002ad8
    int32_t v3 = v1; // 0x100002ae0
    int64_t v4 = g2; // 0x100002ae0
    int64_t result; // 0x100002ab0
    if (v2 < 0 == ((v2 ^ v1) & (g4 ^ v1)) < 0) {
        int32_t v5 = g4 + 32; // 0x100002afc
        g4 = v5;
        v4 = (int64_t)_realloc((int64_t *)g2, v5);
        g2 = v4;
        v3 = g3;
        result = v4;
    }
    // 0x100002b24
    g3 = v3 + 1;
    int64_t v6; // 0x100002ab0
    *(char *)(v4 + (int64_t)v3) = (char)v6;
    g12++;
    return result;
}

// Address range: 0x100002b68 - 0x100002bcc
int64_t function_100002b68(void) {
    int64_t result; // 0x100002ba8
    for (int64_t i = 0; i < 4; i++) {
        // 0x100002b9c
        result = function_100002ab0();
    }
    // 0x100002bc0
    return result;
}

// Address range: 0x100002bcc - 0x100002bfc
int64_t function_100002bcc(int64_t a1) {
    // 0x100002bcc
    function_100002b68();
    return (uint32_t)g12;
}

// Address range: 0x100002bfc - 0x100002c2c
int64_t function_100002bfc(void) {
    // 0x100002bfc
    int64_t v1; // 0x100002bfc
    int64_t result = v1;
    *(int32_t *)((0x100000000 * result >> 32) + g2) = (int32_t)v1 - (int32_t)result;
    return result;
}

// Address range: 0x100002c2c - 0x100002d64
int64_t function_100002c2c(void) {
    // 0x100002c2c
    int64_t v1; // 0x100002c2c
    char * v2 = (char *)v1; // 0x100002c38
    int32_t v3 = -g6; // 0x100002c50
    int32_t v4 = 0; // 0x100002c58
    if (v3 < 0 != (g6 & v3) < 0) {
        int64_t v5 = *(int64_t *)(8 * (int64_t)v4 + g5); // 0x100002c70
        int32_t result = v4; // 0x100002c80
        while (_strcmp(v2, (char *)v5) != 0) {
            // 0x100002c98
            v4++;
            int32_t v6 = v4 - g6; // 0x100002c50
            if (v6 < 0 == ((v6 ^ v4) & (g6 ^ v4)) < 0) {
                goto lab_0x100002cb0;
            }
            v5 = *(int64_t *)(8 * (int64_t)v4 + g5);
            result = v4;
        }
        // 0x100002d54
        return result;
    }
  lab_0x100002cb0:;
    int32_t v7 = g6;
    int32_t v8 = v7 - g7; // 0x100002cc0
    int32_t result2 = v7; // 0x100002cc8
    if (v8 < 0 == ((v8 ^ v7) & (g7 ^ v7)) < 0) {
        int32_t v9 = g7 + 32; // 0x100002ce4
        g7 = v9;
        g5 = (int64_t)_realloc((int64_t *)g5, 8 * v9);
        result2 = g6;
    }
    // 0x100002d0c
    g6 = result2 + 1;
    char * v10 = _strdup(v2); // 0x100002d34
    *(int64_t *)(g5 + 8 * (int64_t)result2) = (int64_t)v10;
    // 0x100002d54
    return result2;
}

// Address range: 0x100002d64 - 0x100002e9c
int64_t function_100002d64(void) {
    // 0x100002d64
    int64_t v1; // 0x100002d64
    char * v2 = (char *)v1; // 0x100002d70
    int32_t v3 = *(int32_t *)&g9; // 0x100002d84
    int32_t v4 = -v3; // 0x100002d88
    int32_t v5 = 0; // 0x100002d90
    int32_t v6 = v3; // 0x100002d90
    if (v4 < 0 != (v3 & v4) < 0) {
        int64_t v7 = *(int64_t *)(8 * (int64_t)v5 + g8); // 0x100002da8
        int32_t result = v5; // 0x100002db8
        while (_strcmp(v2, (char *)v7) != 0) {
            // 0x100002dd0
            v5++;
            int32_t v8 = *(int32_t *)&g9; // 0x100002d84
            int32_t v9 = v5 - v8; // 0x100002d88
            v6 = v8;
            if (v9 < 0 == ((v9 ^ v5) & (v8 ^ v5)) < 0) {
                goto lab_0x100002de8;
            }
            v7 = *(int64_t *)(8 * (int64_t)v5 + g8);
            result = v5;
        }
        // 0x100002e8c
        return result;
    }
  lab_0x100002de8:;
    int32_t v10 = v6;
    int32_t v11 = *(int32_t *)&g10; // 0x100002df4
    int32_t v12 = v10 - v11; // 0x100002df8
    int32_t result2 = v10; // 0x100002e00
    if (v12 < 0 == ((v12 ^ v10) & (v11 ^ v10)) < 0) {
        int32_t v13 = v11 + 32; // 0x100002e1c
        *(int32_t *)&g10 = v13;
        g8 = (int64_t)_realloc((int64_t *)g8, 8 * v13);
        result2 = *(int32_t *)&g9;
    }
    // 0x100002e44
    *(int32_t *)&g9 = result2 + 1;
    char * v14 = _strdup(v2); // 0x100002e6c
    *(int64_t *)(g8 + 8 * (int64_t)result2) = (int64_t)v14;
    // 0x100002e8c
    return result2;
}

// Address range: 0x100002e9c - 0x100003188
int64_t function_100002e9c(void) {
    // 0x100002e9c
    int64_t result; // 0x100002e9c
    if (result == 0) {
        // 0x100002ee4
        return result;
    }
    uint32_t v1 = (int32_t)result;
    if (v1 >= 24 != v1 != 24) {
        // 0x100002ee4
        return result;
    }
    // 0x100003158
    function_100002970();
    // UNREACHABLE
}

// Address range: 0x1000031ec - 0x100003204
int64_t function_1000031ec(int64_t a1) {
    // 0x1000031ec
    return function_100002ab0();
}

// Address range: 0x100003204 - 0x1000036e8
int64_t function_100003204(int64_t a1, int64_t a2) {
    // 0x100003204
    _fprintf((struct _IO_FILE *)0x4f52, "Datasize: %d Strings: %d\n");
    int32_t v1 = *(int32_t *)&g9; // 0x10000325c
    int32_t v2 = -v1; // 0x100003260
    int32_t v3 = 0; // 0x100003268
    if (v2 < 0 != (v1 & v2) < 0) {
        _fprintf((struct _IO_FILE *)0x4f52, "%s\n");
        v3++;
        int32_t v4 = *(int32_t *)&g9; // 0x10000325c
        while (v3 - v4 < 0 != ((v3 - v4 ^ v3) & (v4 ^ v3)) < 0) {
            // 0x100003270
            _fprintf((struct _IO_FILE *)0x4f52, "%s\n");
            v3++;
            v4 = *(int32_t *)&g9;
        }
    }
    int32_t result = _fprintf((struct _IO_FILE *)0x4f52, "%5d "); // 0x1000032f0
    unsigned char v5 = *(char *)g2; // 0x100003300
    if (v5 >= 23 != v5 != 23) {
        // 0x10000331c
        return result;
    }
    // 0x1000036b8
    function_100002970();
    // UNREACHABLE
}

// Address range: 0x100003748 - 0x1000037ec
int64_t function_100003748(void) {
    // 0x100003748
    int64_t v1; // 0x100003748
    if ((char)v1 == 0) {
        // 0x1000037e0
        int64_t result; // 0x100003748
        return result;
    }
    struct _IO_FILE * v2 = _fopen((char *)v1, (char *)v1); // 0x100003794
    int64_t result2 = (int64_t)v2; // 0x100003794
    *(int64_t *)v1 = result2;
    if (v2 != NULL) {
        // 0x1000037e0
        return result2;
    }
    // 0x1000037b4
    function_100002970();
    // UNREACHABLE
}

// Address range: 0x1000037ec - 0x1000038a8
int64_t function_1000037ec(void) {
    int64_t v1 = 0; // 0x100003868
    int64_t v2 = 16 * v1; // 0x10000381c
    int64_t v3 = *(int64_t *)(v2 + (int64_t)&g1); // 0x100003828
    int64_t v4; // 0x1000037ec
    while (_strcmp((char *)v3, (char *)v4) != 0) {
        // 0x100003804
        v1++;
        if (v1 >= 25) {
            // 0x100003874
            function_100002970();
            // UNREACHABLE
        }
        v2 = 16 * v1;
        v3 = *(int64_t *)(v2 + (int64_t)&g1);
    }
    // 0x100003844
    return (int64_t)*(int32_t *)(v2 + (int64_t)&g1 + 8);
}

// Address range: 0x1000038a8 - 0x100003a10
int64_t function_1000038a8(void) {
    int32_t v1 = 0; // 0x1000038c0
    int64_t result; // 0x1000039f4
    int32_t v2; // 0x1000038a8
    while (true) {
        // 0x1000038c4
        int64_t v3; // 0x1000038a8
        *(int32_t *)v3 = v1;
        int32_t v4 = _fgetc(g11); // 0x1000038d0
        int64_t v5; // 0x1000038a8
        v2 = *(int32_t *)&v5;
        switch (v4) {
            case -1: {
            }
            case 10: {
                // 0x100003900
                result = 0;
                if (v2 != 0) {
                    // 0x1000039dc
                    *(char *)(g13 + (int64_t)v2) = 0;
                    result = g13;
                }
                // 0x100003a00
                return result;
            }
        }
        int32_t v6 = v2 + 1; // 0x10000392c
        int32_t v7 = *(int32_t *)((int64_t)&g1 + 480); // 0x100003934
        int32_t v8 = v6 - v7; // 0x100003938
        int64_t v9; // 0x1000038a8
        if (v8 < 0 == ((v8 ^ v6) & (v7 ^ v6)) < 0) {
            int32_t v10 = g14; // 0x10000394c
            int32_t v11 = v10 == 0 ? 128 : 2 * v10;
            g14 = v11;
            int64_t v12 = (int64_t)_realloc((int64_t *)g13, v11); // 0x10000399c
            g13 = v12;
            v9 = v12;
        } else {
            // 0x100003924
            v9 = g13;
        }
        // 0x1000039ac
        *(char *)(v9 + (int64_t)v2) = (char)v4;
        v1 = *(int32_t *)&v5 + 1;
    }
    // 0x100003900
    result = 0;
    if (v2 != 0) {
        // 0x1000039dc
        *(char *)(g13 + (int64_t)v2) = 0;
        result = g13;
    }
    // 0x100003a00
    return result;
}

// Address range: 0x100003a10 - 0x100003ab8
int64_t function_100003a10(void) {
    // 0x100003a10
    int64_t result; // 0x100003a10
    int32_t v1 = result;
    if (v1 < 1) {
        // 0x100003a94
        *(char *)(result + (int64_t)v1) = 0;
        return result;
    }
    uint32_t v2 = v1 - 1; // 0x100003a54
    char v3 = *(char *)(result + (int64_t)v2); // 0x100003a58
    int32_t v4 = v1; // 0x100003a74
    while (_isspace((int32_t)v3) != 0) {
        // 0x100003a80
        *(int32_t *)result = v2;
        int64_t v5; // 0x100003a10
        int32_t v6 = *(int32_t *)&v5; // 0x100003a2c
        v4 = v6;
        if (v6 < 1) {
            // break -> 0x100003a94
            break;
        }
        v2 = v6 - 1;
        v3 = *(char *)(result + (int64_t)v2);
        v4 = v6;
    }
    // 0x100003a94
    *(char *)(result + (int64_t)v4) = 0;
    return result;
}

// Address range: 0x100003ab8 - 0x100003bec
int64_t function_100003ab8(void) {
    // 0x100003ab8
    function_1000038a8();
    int64_t v1 = function_100003a10(); // 0x100003adc
    char * v2 = _strtok((char *)v1, " "); // 0x100003af0
    if (*v2 == 59) {
        // 0x100003bdc
        return 0;
    }
    int64_t v3 = function_1000037ec(); // 0x100003b1c
    int64_t v4 = (int64_t)_strlen(v2) + (int64_t)v2; // 0x100003b38
    int32_t v5; // 0x100003ab8
    if (v4 == v1 + (int64_t)v5) {
        int64_t v6 = function_100003ab8(); // 0x100003bb4
        // 0x100003bdc
        return function_100002a04((int32_t)v3, v6, function_100003ab8());
    }
    char * v7 = (char *)v4; // 0x100003b6c
    while (_isspace((int32_t)*(char *)((int64_t)v7 + 1)) != 0) {
        // 0x100003b70
        v7 = (char *)((int64_t)v7 + 1);
    }
    // 0x100003bdc
    return function_100002a60();
}

// Address range: 0x100003bec - 0x100003ce4
int64_t entry_point(void) {
    // 0x100003bec
    function_100003748();
    function_100003748();
    function_100003ab8();
    function_100002e9c();
    function_1000031ec((int64_t)&g15);
    function_100003204((int64_t)&g15, (int64_t)&g15);
    return 0;
}

// Address range: 0x100003ce4 - 0x100003cf0
int64_t function_100003ce4(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x100003ce4
    return ___vsprintf_chk(a1, a2, a3, a4, a5);
}

// Address range: 0x100003cf0 - 0x100003cfc
int32_t function_100003cf0(char * nptr) {
    // 0x100003cf0
    return _atoi(nptr);
}

// Address range: 0x100003cfc - 0x100003d08
int64_t * function_100003cfc(int32_t nmemb, int32_t size) {
    // 0x100003cfc
    return _calloc(nmemb, size);
}

// Address range: 0x100003d08 - 0x100003d14
void function_100003d08(int32_t status) {
    // 0x100003d08
    _exit(status);
}

// Address range: 0x100003d14 - 0x100003d20
int32_t function_100003d14(struct _IO_FILE * stream) {
    // 0x100003d14
    return _fgetc(stream);
}

// Address range: 0x100003d20 - 0x100003d2c
struct _IO_FILE * function_100003d20(char * filename, char * modes) {
    // 0x100003d20
    return _fopen(filename, modes);
}

// Address range: 0x100003d2c - 0x100003d38
int32_t function_100003d2c(struct _IO_FILE * stream, char * format, ...) {
    // 0x100003d2c
    return _fprintf(stream, format);
}

// Address range: 0x100003d38 - 0x100003d44
int32_t function_100003d38(int32_t c) {
    // 0x100003d38
    return _isspace(c);
}

// Address range: 0x100003d44 - 0x100003d50
int32_t function_100003d44(char * format, ...) {
    // 0x100003d44
    return _printf(format);
}

// Address range: 0x100003d50 - 0x100003d5c
int64_t * function_100003d50(int64_t * ptr, int32_t size) {
    // 0x100003d50
    return _realloc(ptr, size);
}

// Address range: 0x100003d5c - 0x100003d68
int32_t function_100003d5c(char * s1, char * s2) {
    // 0x100003d5c
    return _strcmp(s1, s2);
}

// Address range: 0x100003d68 - 0x100003d74
char * function_100003d68(char * s) {
    // 0x100003d68
    return _strdup(s);
}

// Address range: 0x100003d74 - 0x100003d80
int32_t function_100003d74(char * s) {
    // 0x100003d74
    return _strlen(s);
}

// Address range: 0x100003d80 - 0x100003d8c
char * function_100003d80(char * s, char * delim) {
    // 0x100003d80
    return _strtok(s, delim);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 33

`
`//FormAI DATASET v1.0 Category: QR code reader ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>

#define QR_CODE_SIZE 21

int main() {
    char qrCode[QR_CODE_SIZE + 1] = {0};
    bool isCodeScanned = false;

    printf("\n\n==============================================\n\n");
    printf("Welcome to the unique QR Code reader program!\n\n");
    printf("Please scan your QR code to get started.\n\n");

    while (!isCodeScanned) {
        printf("Scanning...");
        sleep(2); // Simulate the QR code scanning process
        printf("\n\n");

        fgets(qrCode, sizeof(qrCode), stdin);

        if (strlen(qrCode) == QR_CODE_SIZE) {
            // Check if its a valid QR code
            printf("You have successfully scanned the following QR code:\n\n");
            printf("%s\n\n", qrCode);
            isCodeScanned = true;
        } else {
            printf("Invalid QR code. Please try again.\n\n");
            memset(qrCode, 0, sizeof(qrCode)); // Clear array for next scan
        }
    }

    printf("Thank you for using the unique QR Code reader program!\n\n");
    printf("Exiting...\n\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void *__cdecl memset(void *, int Val, size_t Size);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[31]; // [rsp+20h] [rbp-20h] BYREF
  char v6; // [rsp+3Fh] [rbp-1h]

  _main(argc, argv, envp);
  memset(Buffer, 0, 22);
  v6 = 0;
  printf("\n\n==============================================\n\n");
  printf("Welcome to the unique QR Code reader program!\n\n");
  printf("Please scan your QR code to get started.\n\n");
  while ( v6 != 1 )
  {
    printf("Scanning...");
    sleep(2i64);
    printf("\n\n");
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 22, v3);
    if ( strlen(Buffer) == 21 )
    {
      printf("You have successfully scanned the following QR code:\n\n");
      printf("%s\n\n", Buffer);
      v6 = 1;
    }
    else
    {
      printf("Invalid QR code. Please try again.\n\n");
      memset(Buffer, 0, 0x16ui64);
    }
  }
  printf("Thank you for using the unique QR Code reader program!\n\n");
  printf("Exiting...\n\n");
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400027F0: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Metadata Extractor ; Style: romantic
#include <stdio.h>
#include <stdlib.h>

int main() {

    // Open the file to extract metadata
    FILE *file = fopen("love.mp3", "r");

    // Check if file is opened successfully
    if (file == NULL) {
        printf("Failed to open file!");
        exit(1);
    }

    // Extract metadata using fseek and fread functions
    fseek(file, -128, SEEK_END);

    char tag[3];
    char title[30];
    char artist[30];
    char album[30];
    char year[4];
    char comment[29];
    char genre;

    fread(tag, sizeof(char), 3, file);
    fread(title, sizeof(char), 30, file);
    fread(artist, sizeof(char), 30, file);
    fread(album, sizeof(char), 30, file);
    fread(year, sizeof(char), 4, file);
    fread(comment, sizeof(char), 29, file);
    fread(&genre, sizeof(char), 1, file);

    // Print the extracted metadata
    printf("Title : %s\n", title);
    printf("Artist : %s\n", artist);
    printf("Album : %s\n", album);
    printf("Year : %s\n", year);
    printf("Comment : %s\n", comment);

    // Close the file
    fclose(file);

    // End the program with a romantic message
    printf("\n\nMy love, just like this program extracted metadata from a file, I extracted you from the world. You are the title that defines me, the artist that colors my life, and the album that's worth my soul. The year we met is engraved in my heart and our love is the comment that feels every space. You are the genre that gives my life meaning. I love you more than words can express. Always yours, my love.\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Fh] [rbp-A1h] BYREF
  char v5[44]; // [rsp+30h] [rbp-A0h] BYREF
  char v6[4]; // [rsp+5Ch] [rbp-74h] BYREF
  char v7[32]; // [rsp+60h] [rbp-70h] BYREF
  char v8[32]; // [rsp+80h] [rbp-50h] BYREF
  char v9[37]; // [rsp+A0h] [rbp-30h] BYREF
  char Buffer[3]; // [rsp+C5h] [rbp-Bh] BYREF
  FILE *Stream; // [rsp+C8h] [rbp-8h]

  _main(argc, argv, envp);
  Stream = fopen("love.mp3", "r");
  if ( !Stream )
  {
    printf("Failed to open file!");
    exit(1);
  }
  fseek(Stream, -128, 2);
  fread(Buffer, 1ui64, 3ui64, Stream);
  fread(v9, 1ui64, 0x1Eui64, Stream);
  fread(v8, 1ui64, 0x1Eui64, Stream);
  fread(v7, 1ui64, 0x1Eui64, Stream);
  fread(v6, 1ui64, 4ui64, Stream);
  fread(v5, 1ui64, 0x1Dui64, Stream);
  fread(&v4, 1ui64, 1ui64, Stream);
  printf("Title : %s\n", v9);
  printf("Artist : %s\n", v8);
  printf("Album : %s\n", v7);
  printf("Year : %s\n", v6);
  printf("Comment : %s\n", v5);
  fclose(Stream);
  printf(
    "\n"
    "\n"
    "My love, just like this program extracted metadata from a file, I extracted you from the world. You are the title th"
    "at defines me, the artist that colors my life, and the album that's worth my soul. The year we met is engraved in my"
    " heart and our love is the comment that feels every space. You are the genre that gives my life meaning. I love you "
    "more than words can express. Always yours, my love.\n");
  return 0;
}
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[3];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue Implementation ; Style: medieval
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Defining the structure of a Queue node.
struct QueueNode {
    int data;
    struct QueueNode* next;
};

// Defining the structure of a Queue.
struct Queue {
    struct QueueNode *front, *rear;
};

// Function to create a new Queue node.
struct QueueNode* createQueueNode(int data) {
    struct QueueNode* temp = (struct QueueNode*)malloc(sizeof(struct QueueNode));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

// Function to create a new Queue.
struct Queue* createQueue() {
    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
    q->front = q->rear = NULL;
    return q;
}

// Function to check if a Queue is empty.
int isEmpty(struct Queue* q) {
    return (q->front == NULL);
}

// Function to add an element to the Queue.
void enqueue(struct Queue* q, int data) {
    struct QueueNode* temp = createQueueNode(data);
    if (q->rear == NULL) {
        q->front = q->rear = temp; 
        return;
    }
    q->rear->next = temp;
    q->rear = temp;
}

// Function to remove an element from the Queue.
int dequeue(struct Queue* q) {
    if (isEmpty(q)) {
        return -1;
    }
    struct QueueNode* temp = q->front;
    int data = temp->data;
    q->front = q->front->next;
    if (q->front == NULL) {
        q->rear = NULL;
    }
    free(temp);
    return data;
}

int main() {
    // Creating a new Queue.
    struct Queue* queue = createQueue();
    printf("Greetings! Welcome to the medieval Queue. Shall we build one?\n\n");

    // Waiting for the user to respond.
    while(1) {
        printf("Please enter 'Aye' to add an element to the Queue, 'Nay' to remove an element from the Queue and 'Farewell' to exit.\n");
        char input[50];
        scanf("%s", input);
        
        // Checking the user's response and taking the appropriate action.
        if (strcmp(input, "Aye") == 0) {
            printf("Please enter an integer to add to the Queue: ");
            int data;
            scanf("%d", &data);
            enqueue(queue, data);
            printf("%d has been added to the Queue.\n", data);
        }
        else if (strcmp(input, "Nay") == 0) {
            int data = dequeue(queue);
            if (data == -1) {
                printf("The Queue is empty!\n");
            }
            else {
                printf("%d has been removed from the Queue.\n", data);
            }
        }
        else if (strcmp(input, "Farewell") == 0) {
            printf("Farewell, my dear friend. May the blessings of the Queen guide you on your journey.\n");
            break;
        }
        else {
            printf("That's not a valid command, my friend. Please try again.\n");
        }
    }
    
    // Freeing the memory used by the Queue.
    struct QueueNode* current = queue->front;
    while (current != NULL) {
        struct QueueNode* temp = current;
        current = current->next;
        free(temp);
    }
    free(queue);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 createQueue(void); // weak
__int64 __fastcall enqueue(_QWORD, _QWORD); // weak
__int64 __fastcall dequeue(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl free(void *Block);


//----- (000000014000174B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[64]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v5; // [rsp+60h] [rbp-20h] BYREF
  unsigned int v6; // [rsp+64h] [rbp-1Ch]
  void *Block; // [rsp+68h] [rbp-18h]
  void *Queue; // [rsp+70h] [rbp-10h]
  _QWORD *v9; // [rsp+78h] [rbp-8h]

  _main(argc, argv, envp);
  Queue = (void *)createQueue();
  printf("Greetings! Welcome to the medieval Queue. Shall we build one?\n\n");
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        printf(
          "Please enter 'Aye' to add an element to the Queue, 'Nay' to remove an element from the Queue and 'Farewell' to exit.\n");
        scanf("%s", Str1);
        if ( strcmp(Str1, "Aye") )
          break;
        printf("Please enter an integer to add to the Queue: ");
        scanf("%d", &v5);
        enqueue(Queue, v5);
        printf("%d has been added to the Queue.\n", v5);
      }
      if ( strcmp(Str1, "Nay") )
        break;
      v6 = dequeue(Queue);
      if ( v6 == -1 )
        printf("The Queue is empty!\n");
      else
        printf("%d has been removed from the Queue.\n", v6);
    }
    if ( !strcmp(Str1, "Farewell") )
      break;
    printf("That's not a valid command, my friend. Please try again.\n");
  }
  printf("Farewell, my dear friend. May the blessings of the Queen guide you on your journey.\n");
  v9 = *(_QWORD **)Queue;
  while ( v9 )
  {
    Block = v9;
    v9 = (_QWORD *)v9[1];
    free(Block);
  }
  free(Queue);
  return 0;
}
// 14000161A: using guessed type __int64 createQueue(void);
// 14000166F: using guessed type __int64 __fastcall enqueue(_QWORD, _QWORD);
// 1400016D8: using guessed type __int64 __fastcall dequeue(_QWORD);
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Graph representation ; Style: artistic
#include <stdio.h>

int main() {
    printf("   * * * * * * * * * * * * * *\n");
    printf(" *                             *\n");
    printf("*                               *\n");
    printf("*             ******            *\n");
    printf("*            *      *           *\n");
    printf("*           *        *          *\n");
    printf("*          *   **     *         *\n");
    printf("*         *     *      *        *\n");
    printf("*        *      *       *       *\n");
    printf("*        *      *        *      *\n");
    printf("*         *     *         *     *\n");
    printf("*          *   *           *    *\n");
    printf("*           * *             *   *\n");
    printf("*            *               *  *\n");
    printf(" *                             *\n");
    printf("   * * * * * * * * * * * * * *\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("   * * * * * * * * * * * * * *\n");
  printf(" *                             *\n");
  printf("*                               *\n");
  printf("*             ******            *\n");
  printf("*            *      *           *\n");
  printf("*           *        *          *\n");
  printf("*          *   **     *         *\n");
  printf("*         *     *      *        *\n");
  printf("*        *      *       *       *\n");
  printf("*        *      *        *      *\n");
  printf("*         *     *         *     *\n");
  printf("*          *   *           *    *\n");
  printf("*           * *             *   *\n");
  printf("*            *               *  *\n");
  printf(" *                             *\n");
  printf("   * * * * * * * * * * * * * *\n");
  return 0;
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#define _POSIX_SOURCE
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <stddef.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
struct functionInfo {
    char* name;
    int timesCalled;
    char marked;
};
void addToList(struct functionInfo** list, struct functionInfo toAdd, \
               size_t* numElements, size_t* allocatedSize)
{
    static const char* keywords[32] = {"auto", "break", "case", "char", "const", \
                                       "continue", "default", "do", "double", \
                                       "else", "enum", "extern", "float", "for", \
                                       "goto", "if", "int", "long", "register", \
                                       "return", "short", "signed", "sizeof", \
                                       "static", "struct", "switch", "typedef", \
                                       "union", "unsigned", "void", "volatile", \
                                       "while"
                                      };
    int i;
    /* If the "function" being called is actually a keyword, then ignore it */
    for (i = 0; i < 32; i++) {
        if (!strcmp(toAdd.name, keywords[i])) {
            return;
        }
    }
    if (!*list) {
        *allocatedSize = 10;
        *list = calloc(*allocatedSize, sizeof(struct functionInfo));
        if (!*list) {
            printf("Failed to allocate %lu elements of %lu bytes each.\n", \
                   *allocatedSize, sizeof(struct functionInfo));
            abort();
        }
        (*list)[0].name = malloc(strlen(toAdd.name)+1);
        if (!(*list)[0].name) {
            printf("Failed to allocate %lu bytes.\n", strlen(toAdd.name)+1);
            abort();
        }
        strcpy((*list)[0].name, toAdd.name);
        (*list)[0].timesCalled = 1;
        (*list)[0].marked = 0;
        *numElements = 1;
    } else {
        char found = 0;
        unsigned int i;
        for (i = 0; i < *numElements; i++) {
            if (!strcmp((*list)[i].name, toAdd.name)) {
                found = 1;
                (*list)[i].timesCalled++;
                break;
            }
        }
        if (!found) {
            struct functionInfo* newList = calloc((*allocatedSize)+10, \
                                                  sizeof(struct functionInfo));
            if (!newList) {
                printf("Failed to allocate %lu elements of %lu bytes each.\n", \
                       (*allocatedSize)+10, sizeof(struct functionInfo));
                abort();
            }
            memcpy(newList, *list, (*allocatedSize)*sizeof(struct functionInfo));
            free(*list);
            *allocatedSize += 10;
            *list = newList;
            (*list)[*numElements].name = malloc(strlen(toAdd.name)+1);
            if (!(*list)[*numElements].name) {
                printf("Failed to allocate %lu bytes.\n", strlen(toAdd.name)+1);
                abort();
            }
            strcpy((*list)[*numElements].name, toAdd.name);
            (*list)[*numElements].timesCalled = 1;
            (*list)[*numElements].marked = 0;
            (*numElements)++;
        }
    }
}
void printList(struct functionInfo** list, size_t numElements)
{
    char maxSet = 0;
    unsigned int i;
    size_t maxIndex = 0;
    for (i = 0; i<10; i++) {
        maxSet = 0;
        size_t j;
        for (j = 0; j<numElements; j++) {
            if (!maxSet || (*list)[j].timesCalled > (*list)[maxIndex].timesCalled) {
                if (!(*list)[j].marked) {
                    maxSet = 1;
                    maxIndex = j;
                }
            }
        }
        (*list)[maxIndex].marked = 1;
        printf("%s() called %d times.\n", (*list)[maxIndex].name, \
               (*list)[maxIndex].timesCalled);
    }
}
void freeList(struct functionInfo** list, size_t numElements)
{
    size_t i;
    for (i = 0; i<numElements; i++) {
        free((*list)[i].name);
    }
    free(*list);
}
char* extractFunctionName(char* readHead)
{
    char* identifier = readHead;
    if (isalpha(*identifier) || *identifier == '_') {
        while (isalnum(*identifier) || *identifier == '_') {
            identifier++;
        }
    }
    /* Search forward for spaces and then an open parenthesis
     * but do not include this in the function name.
     */
    char* toParen = identifier;
    if (toParen == readHead) return NULL;
    while (isspace(*toParen)) {
        toParen++;
    }
    if (*toParen != '(') return NULL;
    /* Copy the found function name to the output string */
    ptrdiff_t size = (ptrdiff_t)((ptrdiff_t)identifier) \
                     - ((ptrdiff_t)readHead)+1;
    char* const name = malloc(size);
    if (!name) {
        printf("Failed to allocate %lu bytes.\n", size);
        abort();
    }
    name[size-1] = '\0';
    memcpy(name, readHead, size-1);
    /* Function names can't be blank */
    if (strcmp(name, "")) {
        return name;
    }
    free(name);
    return NULL;
}
int main(int argc, char** argv)
{
    int i;
    for (i = 1; i<argc; i++) {
        errno = 0;
        FILE* file = fopen(argv[i], "r");
        if (errno || !file) {
            printf("fopen() failed with error code \"%s\"\n", \
                   strerror(errno));
            abort();
        }
        char comment = 0;
#define DOUBLEQUOTE 1
#define SINGLEQUOTE 2
        int string = 0;
        struct functionInfo* functions = NULL;
        struct functionInfo toAdd;
        size_t numElements = 0;
        size_t allocatedSize = 0;
        struct stat metaData;
        errno = 0;
        if (fstat(fileno(file), &metaData) < 0) {
            printf("fstat() returned error \"%s\"\n", strerror(errno));
            abort();
        }
        char* mmappedSource = (char*)mmap(NULL, metaData.st_size, PROT_READ, \
                                          MAP_PRIVATE, fileno(file), 0);
        if (errno) {
            printf("mmap() failed with error \"%s\"\n", strerror(errno));
            abort();
        }
        if (!mmappedSource) {
            printf("mmap() returned NULL.\n");
            abort();
        }
        char* readHead = mmappedSource;
        while (readHead < mmappedSource + metaData.st_size) {
            while (*readHead) {
                /* Ignore comments inside strings */
                if (!string) {
                    if (*readHead == '/' && !strncmp(readHead, "/*", 2)) {
                        comment = 1;
                    }
                    if (*readHead == '*' && !strncmp(readHead, "*/", 2)) {
                        comment = 0;
                    }
                }
                /* Ignore strings inside comments */
                if (!comment) {
                    if (*readHead == '"') {
                        if (!string) {
                            string = DOUBLEQUOTE;
                        } else if (string == DOUBLEQUOTE) {
                            /* Only toggle string mode if the quote character
                             * is not escaped
                             */
                            if (strncmp((readHead-1), "\\\"", 2)) {
                                string = 0;
                            }
                        }
                    }
                    if (*readHead == '\'') {
                        if (!string) {
                            string = SINGLEQUOTE;
                        } else if (string == SINGLEQUOTE) {
                            if (strncmp((readHead-1), "\\\'", 2)) {
                                string = 0;
                            }
                        }
                    }
                }
                /* Look for identifiers outside of any comment or string */
                if (!comment && !string) {
                    char* name = extractFunctionName(readHead);
                    /* Don't read part of an identifier on the next iteration */
                    if (name) {
                        toAdd.name = name;
                        addToList(&functions, toAdd, &numElements, &allocatedSize);
                        readHead += strlen(name);
                    }
                    free(name);
                }
                readHead++;
            }
        }
        errno = 0;
        munmap(mmappedSource, metaData.st_size);
        if (errno) {
            printf("munmap() returned error \"%s\"\n", strerror(errno));
            abort();
        }
        errno = 0;
        fclose(file);
        if (errno) {
            printf("fclose() returned error \"%s\"\n", strerror(errno));
            abort();
        }
        printList(&functions, numElements);
        freeList(&functions, numElements);
    }
    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100002fd4(void);
int64_t function_1000033a0(void);
int64_t function_100003514(void);
int64_t function_10000358c(void);
void function_100003cb0(int32_t status, int32_t errnum, char * format, ...);
int64_t function_100003cbc(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_100003cc8(int64_t a1, int64_t a2, int64_t a3);
void function_100003cd4(void);
int64_t * function_100003ce0(int32_t nmemb, int32_t size);
int32_t function_100003cec(struct _IO_FILE * stream);
int32_t function_100003cf8(struct _IO_FILE * stream);
struct _IO_FILE * function_100003d04(char * filename, char * modes);
void function_100003d10(int64_t * ptr);
int32_t function_100003d1c(int32_t fd, struct stat * buf);
int32_t function_100003d28(int32_t c);
int32_t function_100003d34(int32_t c);
int32_t function_100003d40(int32_t c);
int64_t * function_100003d4c(int32_t size);
int64_t * function_100003d58(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset);
int32_t function_100003d64(int64_t * addr, int32_t len);
int32_t function_100003d70(char * format, ...);
int32_t function_100003d7c(char * s1, char * s2);
char * function_100003d88(int32_t errnum);
int32_t function_100003d94(char * s);
int32_t function_100003da0(char * s1, char * s2, int32_t n);

// --------------------- Global Variables ---------------------

char * g1; // 0x100003edc
int64_t g2 = 0x10000000003dac; // 0x100008000
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void ___error(int32_t a1, int32_t a2, char * a3, ...);
int64_t ___memcpy_chk(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t ___strcpy_chk(int64_t a1, int64_t a2, int64_t a3);
void _abort(void);
int64_t * _calloc(int32_t a1, int32_t a2);
int32_t _fclose(struct _IO_FILE * a1);
int32_t _fileno(struct _IO_FILE * a1);
struct _IO_FILE * _fopen(char * a1, char * a2);
void _free(int64_t * a1);
int32_t _fstat(int32_t a1, struct stat * a2);
int32_t _isalnum(int32_t a1);
int32_t _isalpha(int32_t a1);
int32_t _isspace(int32_t a1);
int64_t * _malloc(int32_t a1);
int64_t * _mmap(int64_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _munmap(int64_t * a1, int32_t a2);
int32_t _printf(char * a1, ...);
int32_t _strcmp(char * a1, char * a2);
int32_t _strlen(char * a1);
int32_t _strncmp(char * a1, char * a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100002fd4 - 0x1000033a0
int64_t function_100002fd4(void) {
    // 0x100002fd4
    int64_t v1; // 0x100002fd4
    int64_t v2 = v1;
    char * v3 = (char *)v1; // 0x100002fe0
    int32_t v4 = 0; // 0x100002fd4
    uint64_t v5 = 0;
    int64_t v6 = *(int64_t *)(8 * v5 + (int64_t)&g2); // 0x100003020
    int32_t v7 = _strcmp(v3, (char *)v6); // 0x100003024
    int64_t result = 0; // 0x100003030
    int64_t v8; // 0x100002fd4
    int32_t v9; // 0x100002fd4
    int64_t v10; // 0x100002fd4
    while (v7 != 0) {
        int32_t v11 = v4;
        int64_t v12 = v5 + 1;
        v4 = v11 + 1;
        if (v5 < 31 == (30 - v11 & (int32_t)v12) < 0) {
            if (v1 == 0) {
                goto lab_0x100003210;
            } else {
                // 0x100003194
                v8 = 0;
                v9 = 0;
                v10 = v7;
                goto lab_0x100003194_2;
            }
        }
        v5 = v12;
        v6 = *(int64_t *)(8 * v5 + (int64_t)&g2);
        v7 = _strcmp(v3, (char *)v6);
        result = 0;
    }
    // 0x100003394
    return result;
  lab_0x100003210:;
    int64_t * v13 = _calloc((int32_t)v2 + 10, 16); // 0x100003220
    if (v13 == NULL) {
        // 0x10000323c
        _printf("Failed to allocate %lu elements of %lu bytes each.\n", 16, (int32_t)v1);
        _abort();
        goto lab_0x100003268;
    } else {
        goto lab_0x100003268;
    }
  lab_0x100003268:;
    int64_t v14 = 0x100000000 * (int64_t)v13 >> 32; // 0x100003268
    _free((int64_t *)___memcpy_chk(v14, v14, 16 * v2, -1));
    *(int64_t *)v2 = v2 + 10;
    *(int64_t *)v1 = v14;
    int64_t * v15 = _malloc(_strlen(v3) + 1); // 0x1000032bc
    int64_t v16 = (int64_t)v15; // 0x1000032bc
    *(int64_t *)(v16 - 16) = v16;
    int64_t v17 = v16; // 0x1000032f8
    if (v15 == NULL) {
        // 0x100003300
        _strlen(v3);
        _printf("Failed to allocate %lu bytes.\n", (int32_t)v14);
        _abort();
        v17 = *(int64_t *)((int64_t)&g3 - 16);
        goto lab_0x100003324;
    } else {
        goto lab_0x100003324;
    }
  lab_0x100003194_2:;
    int64_t v18 = 16 * v8; // 0x1000031a0
    int32_t v19 = _strcmp((char *)*(int64_t *)(v10 + v18), v3); // 0x1000031ac
    int64_t v20 = v19; // 0x1000031ac
    if (v19 == 0) {
        int32_t * v21 = (int32_t *)((v18 | 8) + v20); // 0x1000031d8
        *v21 = *v21 + 1;
        result = 0;
        return result;
    } else {
        int32_t v22 = v9 + 1; // 0x1000031f0
        int64_t v23 = v22; // 0x100003178
        v8 = v23;
        v9 = v22;
        v10 = v20;
        if (v1 > v23) {
            goto lab_0x100003194_2;
        } else {
            goto lab_0x100003210;
        }
    }
  lab_0x100003324:;
    int64_t v24 = ___strcpy_chk(v17, v1, -1); // 0x100003344
    *(int32_t *)(v24 - 8) = 1;
    *(char *)(v24 - 4) = 0;
    *(int64_t *)v1 = 0;
    result = v24;
    return result;
}

// Address range: 0x1000033a0 - 0x100003514
int64_t function_1000033a0(void) {
    int32_t v1 = 0; // 0x1000034fc
    int64_t v2 = 0;
    int64_t v3; // 0x1000033a0
    int64_t v4; // 0x1000033a0
    int32_t v5; // 0x1000033a0
    int32_t v6; // 0x1000033a0
    int32_t v7; // 0x1000033a0
    int64_t v8; // 0x1000033a0
    int64_t v9; // 0x1000033a0
    int64_t v10; // 0x1000033a0
    int64_t v11; // 0x1000033a0
    int64_t v12; // 0x1000033a0
    int64_t v13; // 0x1000033a0
    int64_t v14; // 0x1000033a0
    int64_t v15; // 0x1000033a0
    int64_t result; // 0x1000034f0
    while (true) {
        int64_t v16 = v2;
        int64_t v17; // 0x1000033a0
        int64_t v18 = v17;
        if (v14 == 0) {
            // 0x1000033e4
            v4 = v18 + 12;
            v10 = v16;
        } else {
            int64_t v19 = v18 + 8;
            v15 = v18 + 12;
            v12 = 0;
            v5 = 0;
            v8 = v16;
            while (true) {
              lab_0x1000033fc:
                // 0x1000033fc
                v9 = v8;
                v6 = v5;
                v13 = v12;
                v3 = 16 * v13;
                if (v6 % 256 == 0) {
                    goto lab_0x100003448;
                } else {
                    int32_t v20 = *(int32_t *)(v3 + v19); // 0x100003420
                    int32_t v21 = *(int32_t *)(16 * v9 + v19); // 0x100003434
                    int32_t v22 = v20 - v21; // 0x100003438
                    v11 = v9;
                    v7 = v6;
                    if (v22 == 0 || v22 < 0 != ((v22 ^ v20) & (v21 ^ v20)) < 0) {
                        goto lab_0x100003488;
                    } else {
                        goto lab_0x100003448;
                    }
                }
            }
        }
      lab_0x100003498:
        // 0x100003498
        v2 = v10;
        *(char *)(16 * v2 + v4) = 1;
        result = _printf("%s() called %d times.\n", (char *)v14, v14);
        v1++;
        v17 = result;
        if (v1 == 10) {
            // break -> 0x100003508
            break;
        }
    }
    // 0x100003508
    return result;
  lab_0x100003448:;
    char v23 = *(char *)(v3 + v15); // 0x100003458
    v11 = v23 == 0 ? v13 : v9;
    v7 = v23 == 0 ? 1 : v6;
    goto lab_0x100003488;
  lab_0x100003488:;
    int64_t v24 = v13 + 1; // 0x10000348c
    v12 = v24;
    v5 = v7;
    v8 = v11;
    v4 = v15;
    v10 = v11;
    if (v24 == v14) {
        // break -> 0x100003498
        goto lab_0x100003498;
    }
    goto lab_0x1000033fc;
}

// Address range: 0x100003514 - 0x10000358c
int64_t function_100003514(void) {
    int64_t v1 = 0; // 0x100003540
    int64_t v2; // 0x100003514
    if (v2 == 0) {
        // 0x100003574
        int64_t v3; // 0x100003514
        _free((int64_t *)v3);
        return &g3;
    }
    int64_t v4; // 0x100003514
    _free((int64_t *)*(int64_t *)(16 * v1 + v4));
    v1++;
    v4 = &g3;
    while (v1 != v2) {
        // 0x100003548
        _free((int64_t *)*(int64_t *)(16 * v1 + v4));
        v1++;
        v4 = &g3;
    }
    // 0x100003574
    _free((int64_t *)(int64_t)&g3);
    return &g3;
}

// Address range: 0x10000358c - 0x100003778
int64_t function_10000358c(void) {
    // 0x10000358c
    int64_t v1; // 0x10000358c
    char * v2 = (char *)v1; // 0x1000035a0
    char v3 = v1;
    char * v4 = v2; // 0x1000035b8
    char * v5 = v2; // 0x1000035b8
    if (v3 == 95 | _isalpha((int32_t)v3) != 0) {
        while (true) {
            char * v6 = v4;
            if (_isalnum((int32_t)*v6) == 0) {
                // 0x100003618
                v5 = v6;
                if (*v6 != 95) {
                    // break -> 0x100003638
                    break;
                }
            }
            // 0x100003624
            v4 = (char *)((int64_t)v6 + 1);
        }
    }
    int64_t v7 = (int64_t)v5; // 0x100003638
    if (v1 == v7) {
        // 0x100003768
        return 0;
    }
    char * v8 = v5; // 0x100003678
    char * v9 = v5; // 0x100003678
    if (_isspace((int32_t)*v5) != 0) {
        v8 = (char *)((int64_t)v8 + 1);
        v9 = v8;
        while (_isspace((int32_t)*v8) != 0) {
            // 0x100003680
            v8 = (char *)((int64_t)v8 + 1);
            v9 = v8;
        }
    }
    // 0x100003690
    if (*v9 != 40) {
        // 0x100003768
        return 0;
    }
    int64_t v10 = v7 - v1; // 0x1000036b8
    int64_t * v11 = _malloc((int32_t)v10 + 1); // 0x1000036c8
    if (v11 == NULL) {
        // 0x1000036e4
        _printf("Failed to allocate %lu bytes.\n", (int32_t)v1);
        _abort();
    }
    int64_t v12 = (int64_t)v11; // 0x100003700
    *(char *)(v10 + v12) = 0;
    ___memcpy_chk(v12, v1, v10, -1);
    int32_t v13 = _strcmp((char *)v11, (char *)&g1); // 0x100003738
    int64_t result = v12; // 0x100003744
    if (v13 == 0) {
        // 0x100003758
        _free(v11);
        result = 0;
    }
    // 0x100003768
    return result;
}

// Address range: 0x100003778 - 0x100003cb0
int64_t entry_point(void) {
    // 0x100003778
    int64_t v1; // 0x100003778
    int32_t v2 = v1; // 0x10000378c
    int32_t v3 = 1 - v2; // 0x1000037a8
    if (v3 < 0 == (v3 & v2) < 0) {
        // 0x100003c9c
        return 0;
    }
    // 0x1000037b8
    char * v4; // 0x100003778
    int64_t v5 = (int64_t)v4;
    int32_t v6 = v5;
    int32_t v7 = 1; // 0x100003c90
    int64_t v8; // 0x100003778
    char * v9 = (char *)v8; // 0x1000037b8
    int64_t v10; // 0x100003778
    ___error((int32_t)v10, (int32_t)v1, v9);
    g3 = 0;
    struct _IO_FILE * v11 = _fopen((char *)*(int64_t *)(8 * (int64_t)v7 + v1), "r"); // 0x1000037d4
    ___error((int32_t)(int64_t)v11, (int32_t)"r", v9);
    if (v11 == NULL || g3 != 0) {
        // 0x100003808
        ___error((int32_t)&g3, (int32_t)"r", v9);
        _strerror(g3);
        _printf("fopen() failed with error code \"%s\"\n", "r");
        _abort();
    }
    // 0x10000382c
    ___error((int32_t)&g3, (int32_t)"r", v9);
    g3 = 0;
    int64_t v12; // bp-256, 0x100003778
    int32_t v13 = _fstat(_fileno(v11), (struct stat *)&v12); // 0x100003854
    if (v13 < 0) {
        // 0x100003868
        ___error(v13, (int32_t)(int64_t)&v12, v9);
        _strerror(g3);
        _printf("fstat() returned error \"%s\"\n", &v12);
        _abort();
    }
    int64_t * v14 = _mmap(NULL, v6, 1, 2, _fileno(v11), 0); // 0x1000038b4
    uint64_t v15 = (int64_t)v14;
    ___error((int32_t)v15, v6, (char *)1);
    if (g3 != 0) {
        // 0x1000038d4
        ___error((int32_t)&g3, v6, (char *)1);
        _strerror(g3);
        _printf("mmap() failed with error \"%s\"\n", v4);
        _abort();
    }
    if (v14 == NULL) {
        // 0x10000390c
        _printf("mmap() returned NULL.\n");
        _abort();
    }
    uint64_t v16 = v15 + v5; // 0x100003934
    int32_t v17 = v6; // 0x100003940
    int64_t v18 = &g3; // 0x100003940
    int64_t v19 = 1; // 0x100003940
    char v20; // 0x100003778
    char v21; // 0x100003778
    char v22; // 0x100003778
    char v23; // 0x100003778
    char v24; // 0x100003778
    char v25; // 0x100003778
    char v26; // 0x100003778
    char v27; // 0x100003778
    char * v28; // 0x100003778
    char * v29; // 0x100003778
    char * v30; // 0x100003778
    char * v31; // 0x100003778
    int32_t v32; // 0x100003778
    int32_t v33; // 0x100003778
    int32_t v34; // 0x100003778
    int32_t v35; // 0x100003778
    int32_t v36; // 0x100003778
    int32_t v37; // 0x100003778
    int32_t v38; // 0x100003778
    int32_t v39; // 0x100003778
    int32_t v40; // 0x100003778
    int32_t v41; // 0x100003778
    int32_t v42; // 0x100003778
    int32_t v43; // 0x100003778
    int32_t v44; // 0x100003778
    uint32_t v45; // 0x100003a08
    int32_t v46; // 0x1000039a0
    char v47; // 0x100003778
    int32_t v48; // 0x1000039e8
    int32_t v49; // 0x100003a7c
    int64_t v50; // 0x100003778
    int64_t v51; // 0x100003778
    int64_t v52; // 0x100003778
    int64_t v53; // 0x100003778
    int64_t v54; // 0x100003778
    int64_t v55; // 0x100003778
    int64_t v56; // 0x100003778
    int64_t v57; // 0x100003778
    int64_t v58; // 0x100003778
    int64_t v59; // 0x100003778
    int64_t v60; // 0x100003778
    int64_t v61; // 0x100003778
    int64_t v62; // 0x100003778
    int64_t v63; // 0x100003778
    int64_t v64; // 0x100003778
    int64_t v65; // 0x100003778
    int64_t v66; // 0x100003778
    int64_t v67; // 0x100003778
    int64_t v68; // 0x100003778
    int64_t v69; // 0x100003778
    int64_t v70; // 0x100003778
    int64_t v71; // 0x100003778
    int64_t v72; // 0x100003778
    int64_t v73; // 0x100003778
    int64_t v74; // 0x100003778
    int64_t v75; // 0x100003778
    int64_t v76; // 0x100003778
    int64_t v77; // 0x100003778
    if (v16 > v15) {
        // 0x10000394c
        v20 = *(char *)v14;
        v27 = v20;
        v22 = v20;
        v69 = 1;
        v59 = v5;
        v50 = &g3;
        v31 = (char *)v14;
        v42 = 0;
        v35 = 0;
        while (true) {
            // 0x10000394c
            v21 = v27;
            v34 = v35;
            v41 = v42;
            v30 = v31;
            v53 = v50;
            v62 = v59;
            v72 = v69;
            v23 = v27;
            v24 = v22;
            v70 = v69;
            v60 = v59;
            v51 = v50;
            v28 = v31;
            v39 = v42;
            v32 = v35;
            if (v22 != 0) {
                while (true) {
                    // 0x100003964
                    v33 = v32;
                    v40 = v39;
                    v29 = v28;
                    v52 = v51;
                    v61 = v60;
                    v71 = v70;
                    v38 = v33;
                    v55 = v52;
                    v65 = v61;
                    v74 = v71;
                    if (v40 == 0) {
                        // 0x100003978
                        v25 = v23;
                        v36 = v33;
                        v54 = v52;
                        v64 = v61;
                        v73 = v71;
                        if (v24 == 47) {
                            // 0x100003990
                            v46 = _strncmp(v29, "/*", 2);
                            v25 = *v29;
                            v36 = v46 == 0 ? 1 : v33;
                            v54 = v46;
                            v64 = (int64_t)"/*";
                            v73 = 2;
                        }
                        // 0x1000039c0
                        v37 = v36;
                        v38 = v37;
                        v55 = v54;
                        v65 = v64;
                        v74 = v73;
                        if (v25 == 42) {
                            // 0x1000039d8
                            v48 = _strncmp(v29, "*/", 2);
                            v38 = v48 == 0 ? 0 : v37;
                            v55 = v48;
                            v65 = (int64_t)"*/";
                            v74 = 2;
                        }
                    }
                    // 0x100003a08
                    v75 = v74;
                    v66 = v65;
                    v56 = v55;
                    v45 = v38 % 256;
                    v44 = v40;
                    v58 = v56;
                    v68 = v66;
                    v77 = v75;
                    if (v45 == 0) {
                        // 0x100003a1c
                        v47 = *v29;
                        v26 = v47;
                        v43 = v40;
                        v57 = v56;
                        v67 = v66;
                        v76 = v75;
                        if (v47 == 34) {
                            // 0x100003a34
                            v44 = 1;
                            v58 = v56;
                            v68 = v66;
                            v77 = v75;
                            switch (v40) {
                                case 0: {
                                    goto lab_0x100003b30;
                                }
                                case 1: {
                                    // 0x100003a68
                                    v49 = _strncmp((char *)((int64_t)v29 - 1), "\\\"", 2);
                                    v26 = *v29;
                                    v43 = v49 == 0;
                                    v57 = v49;
                                    v67 = (int64_t)"\\\"";
                                    v76 = 2;
                                    goto lab_0x100003aa4;
                                }
                                default: {
                                    // 0x100003aa4
                                    v44 = v40;
                                    v58 = v56;
                                    v68 = v66;
                                    v77 = v75;
                                    goto lab_0x100003b30;
                                }
                            }
                        } else {
                            goto lab_0x100003aa4;
                        }
                    } else {
                        goto lab_0x100003b30;
                    }
                }
            }
            // 0x100003928
            v19 = v72;
            v63 = v62;
            v18 = v53;
            v31 = v30;
            v42 = v41;
            v35 = v34;
            v27 = v21;
            v22 = 0;
            v69 = v19;
            v59 = v63;
            v50 = v18;
            if (v16 <= (int64_t)v31) {
                // break -> 0x100003928
                break;
            }
        }
        // 0x100003928
        v17 = v63;
    }
    char * v78 = (char *)v19; // 0x100003bd0
    ___error((int32_t)v18, v17, v78);
    g3 = 0;
    ___error(_munmap(v14, v6), v6, v78);
    if (g3 != 0) {
        // 0x100003bfc
        ___error((int32_t)&g3, v6, v78);
        _strerror(g3);
        _printf("munmap() returned error \"%s\"\n", v4);
        _abort();
    }
    // 0x100003c20
    ___error((int32_t)&g3, v6, v78);
    g3 = 0;
    ___error(_fclose(v11), v6, v78);
    if (g3 != 0) {
        // 0x100003c48
        ___error((int32_t)&g3, v6, v78);
        _strerror(g3);
        _printf("fclose() returned error \"%s\"\n", v4);
        _abort();
    }
    // 0x100003c6c
    function_1000033a0();
    v7++;
    int32_t v79 = v7 - v2; // 0x1000037a8
    int64_t v80 = v19; // 0x1000037b0
    int32_t v81 = 0; // 0x1000037b0
    v10 = function_100003514();
    while (v79 < 0 != ((v79 ^ v7) & (v7 ^ v2)) < 0) {
        // 0x1000037b8
        v9 = (char *)v80;
        ___error((int32_t)v10, v81, v9);
        g3 = 0;
        v11 = _fopen((char *)*(int64_t *)(8 * (int64_t)v7 + v1), "r");
        ___error((int32_t)(int64_t)v11, (int32_t)"r", v9);
        if (v11 == NULL || g3 != 0) {
            // 0x100003808
            ___error((int32_t)&g3, (int32_t)"r", v9);
            _strerror(g3);
            _printf("fopen() failed with error code \"%s\"\n", "r");
            _abort();
        }
        // 0x10000382c
        ___error((int32_t)&g3, (int32_t)"r", v9);
        g3 = 0;
        v13 = _fstat(_fileno(v11), (struct stat *)&v12);
        if (v13 < 0) {
            // 0x100003868
            ___error(v13, (int32_t)(int64_t)&v12, v9);
            _strerror(g3);
            _printf("fstat() returned error \"%s\"\n", &v12);
            _abort();
        }
        // 0x10000388c
        v14 = _mmap(NULL, v6, 1, 2, _fileno(v11), 0);
        v15 = (int64_t)v14;
        ___error((int32_t)v15, v6, (char *)1);
        if (g3 != 0) {
            // 0x1000038d4
            ___error((int32_t)&g3, v6, (char *)1);
            _strerror(g3);
            _printf("mmap() failed with error \"%s\"\n", v4);
            _abort();
        }
        if (v14 == NULL) {
            // 0x10000390c
            _printf("mmap() returned NULL.\n");
            _abort();
        }
        // 0x10000391c
        v16 = v15 + v5;
        v17 = v6;
        int64_t v82 = &g3; // 0x100003940
        v80 = 1;
        if (v16 > v15) {
            // 0x10000394c
            v20 = *(char *)v14;
            v27 = v20;
            v22 = v20;
            v69 = 1;
            v59 = v5;
            v50 = &g3;
            v31 = (char *)v14;
            v42 = 0;
            v35 = 0;
            while (true) {
                // 0x10000394c
                v21 = v27;
                v34 = v35;
                v41 = v42;
                v30 = v31;
                v53 = v50;
                v62 = v59;
                v72 = v69;
                v23 = v27;
                v24 = v22;
                v70 = v69;
                v60 = v59;
                v51 = v50;
                v28 = v31;
                v39 = v42;
                v32 = v35;
                if (v22 != 0) {
                    while (true) {
                        // 0x100003964
                        v33 = v32;
                        v40 = v39;
                        v29 = v28;
                        v52 = v51;
                        v61 = v60;
                        v71 = v70;
                        v38 = v33;
                        v55 = v52;
                        v65 = v61;
                        v74 = v71;
                        if (v40 == 0) {
                            // 0x100003978
                            v25 = v23;
                            v36 = v33;
                            v54 = v52;
                            v64 = v61;
                            v73 = v71;
                            if (v24 == 47) {
                                // 0x100003990
                                v46 = _strncmp(v29, "/*", 2);
                                v25 = *v29;
                                v36 = v46 == 0 ? 1 : v33;
                                v54 = v46;
                                v64 = (int64_t)"/*";
                                v73 = 2;
                            }
                            // 0x1000039c0
                            v37 = v36;
                            v38 = v37;
                            v55 = v54;
                            v65 = v64;
                            v74 = v73;
                            if (v25 == 42) {
                                // 0x1000039d8
                                v48 = _strncmp(v29, "*/", 2);
                                v38 = v48 == 0 ? 0 : v37;
                                v55 = v48;
                                v65 = (int64_t)"*/";
                                v74 = 2;
                            }
                        }
                        // 0x100003a08
                        v75 = v74;
                        v66 = v65;
                        v56 = v55;
                        v45 = v38 % 256;
                        v44 = v40;
                        v58 = v56;
                        v68 = v66;
                        v77 = v75;
                        if (v45 == 0) {
                            // 0x100003a1c
                            v47 = *v29;
                            v26 = v47;
                            v43 = v40;
                            v57 = v56;
                            v67 = v66;
                            v76 = v75;
                            if (v47 == 34) {
                                // 0x100003a34
                                v44 = 1;
                                v58 = v56;
                                v68 = v66;
                                v77 = v75;
                                switch (v40) {
                                    case 0: {
                                        goto lab_0x100003b30;
                                    }
                                    case 1: {
                                        // 0x100003a68
                                        v49 = _strncmp((char *)((int64_t)v29 - 1), "\\\"", 2);
                                        v26 = *v29;
                                        v43 = v49 == 0;
                                        v57 = v49;
                                        v67 = (int64_t)"\\\"";
                                        v76 = 2;
                                        goto lab_0x100003aa4;
                                    }
                                    default: {
                                        // 0x100003aa4
                                        v44 = v40;
                                        v58 = v56;
                                        v68 = v66;
                                        v77 = v75;
                                        goto lab_0x100003b30;
                                    }
                                }
                            } else {
                                goto lab_0x100003aa4;
                            }
                        } else {
                            goto lab_0x100003b30;
                        }
                    }
                }
                // 0x100003928
                v19 = v72;
                v63 = v62;
                v18 = v53;
                v31 = v30;
                v42 = v41;
                v35 = v34;
                v27 = v21;
                v22 = 0;
                v69 = v19;
                v59 = v63;
                v50 = v18;
                if (v16 <= (int64_t)v31) {
                    // break -> 0x100003928
                    break;
                }
            }
            // 0x100003928
            v17 = v63;
            v82 = v18;
            v80 = v19;
        }
        // 0x100003bd0
        v78 = (char *)v80;
        ___error((int32_t)v82, v17, v78);
        g3 = 0;
        ___error(_munmap(v14, v6), v6, v78);
        if (g3 != 0) {
            // 0x100003bfc
            ___error((int32_t)&g3, v6, v78);
            _strerror(g3);
            _printf("munmap() returned error \"%s\"\n", v4);
            _abort();
        }
        // 0x100003c20
        ___error((int32_t)&g3, v6, v78);
        g3 = 0;
        ___error(_fclose(v11), v6, v78);
        if (g3 != 0) {
            // 0x100003c48
            ___error((int32_t)&g3, v6, v78);
            _strerror(g3);
            _printf("fclose() returned error \"%s\"\n", v4);
            _abort();
        }
        // 0x100003c6c
        function_1000033a0();
        v7++;
        v79 = v7 - v2;
        v81 = 0;
        v10 = function_100003514();
    }
    // 0x100003c9c
    return 0;
  lab_0x100003b30:;
    int64_t v83 = v77;
    int64_t v84 = v68;
    char * v85 = v29; // 0x100003b3c
    int64_t v86 = v58; // 0x100003b3c
    int64_t v87 = v84; // 0x100003b3c
    int64_t v88 = v83; // 0x100003b3c
    if ((v44 || v45) == 0) {
        int64_t v89 = function_10000358c(); // 0x100003b5c
        char * v90 = v29; // 0x100003b70
        int64_t v91 = v84; // 0x100003b70
        int64_t v92 = v83; // 0x100003b70
        if (v89 != 0) {
            // 0x100003b78
            function_100002fd4();
            v90 = (char *)((int64_t)_strlen((char *)v89) + (int64_t)v29);
            v91 = v89;
            v92 = (int64_t)v4;
        }
        // 0x100003bb0
        _free((int64_t *)v89);
        v85 = v90;
        v86 = &g3;
        v87 = v91;
        v88 = v92;
    }
    char * v93 = (char *)((int64_t)v85 + 1);
    char v94 = *v93; // 0x100003950
    v21 = 0;
    v34 = v38;
    v41 = v44;
    v30 = v93;
    v53 = v86;
    v62 = v87;
    v72 = v88;
    v23 = v94;
    v24 = v94;
    v70 = v88;
    v60 = v87;
    v51 = v86;
    v28 = v93;
    v39 = v44;
    v32 = v38;
    if (v94 == 0) {
        // break -> 0x100003928
        goto lab_0x100003928;
    }
    goto lab_0x100003964;
  lab_0x100003aa4:;
    int64_t v95 = v76;
    int64_t v96 = v67;
    int64_t v97 = v57;
    int32_t v98 = v43;
    v44 = v98;
    v58 = v97;
    v68 = v96;
    v77 = v95;
    if (v26 == 39) {
        // 0x100003abc
        v44 = 2;
        v58 = v97;
        v68 = v96;
        v77 = v95;
        switch (v98) {
            case 0: {
                goto lab_0x100003b30;
            }
            case 2: {
                int32_t v99 = _strncmp((char *)((int64_t)v29 - 1), "\\'", 2); // 0x100003b04
                v44 = v99 == 0 ? 2 : 0;
                v58 = v99;
                v68 = (int64_t)"\\'";
                v77 = 2;
                goto lab_0x100003b30;
            }
            default: {
                // 0x100003b30
                v44 = v98;
                v58 = v97;
                v68 = v96;
                v77 = v95;
                goto lab_0x100003b30;
            }
        }
    } else {
        goto lab_0x100003b30;
    }
}

// Address range: 0x100003cb0 - 0x100003cbc
void function_100003cb0(int32_t status, int32_t errnum, char * format, ...) {
    // 0x100003cb0
    ___error(status, errnum, format);
}

// Address range: 0x100003cbc - 0x100003cc8
int64_t function_100003cbc(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x100003cbc
    return ___memcpy_chk(a1, a2, a3, a4);
}

// Address range: 0x100003cc8 - 0x100003cd4
int64_t function_100003cc8(int64_t a1, int64_t a2, int64_t a3) {
    // 0x100003cc8
    return ___strcpy_chk(a1, a2, a3);
}

// Address range: 0x100003cd4 - 0x100003ce0
void function_100003cd4(void) {
    // 0x100003cd4
    _abort();
}

// Address range: 0x100003ce0 - 0x100003cec
int64_t * function_100003ce0(int32_t nmemb, int32_t size) {
    // 0x100003ce0
    return _calloc(nmemb, size);
}

// Address range: 0x100003cec - 0x100003cf8
int32_t function_100003cec(struct _IO_FILE * stream) {
    // 0x100003cec
    return _fclose(stream);
}

// Address range: 0x100003cf8 - 0x100003d04
int32_t function_100003cf8(struct _IO_FILE * stream) {
    // 0x100003cf8
    return _fileno(stream);
}

// Address range: 0x100003d04 - 0x100003d10
struct _IO_FILE * function_100003d04(char * filename, char * modes) {
    // 0x100003d04
    return _fopen(filename, modes);
}

// Address range: 0x100003d10 - 0x100003d1c
void function_100003d10(int64_t * ptr) {
    // 0x100003d10
    _free(ptr);
}

// Address range: 0x100003d1c - 0x100003d28
int32_t function_100003d1c(int32_t fd, struct stat * buf) {
    // 0x100003d1c
    return _fstat(fd, buf);
}

// Address range: 0x100003d28 - 0x100003d34
int32_t function_100003d28(int32_t c) {
    // 0x100003d28
    return _isalnum(c);
}

// Address range: 0x100003d34 - 0x100003d40
int32_t function_100003d34(int32_t c) {
    // 0x100003d34
    return _isalpha(c);
}

// Address range: 0x100003d40 - 0x100003d4c
int32_t function_100003d40(int32_t c) {
    // 0x100003d40
    return _isspace(c);
}

// Address range: 0x100003d4c - 0x100003d58
int64_t * function_100003d4c(int32_t size) {
    // 0x100003d4c
    return _malloc(size);
}

// Address range: 0x100003d58 - 0x100003d64
int64_t * function_100003d58(int64_t * addr, int32_t len, int32_t prot, int32_t flags, int32_t fd, int32_t offset) {
    // 0x100003d58
    return _mmap(addr, len, prot, flags, fd, offset);
}

// Address range: 0x100003d64 - 0x100003d70
int32_t function_100003d64(int64_t * addr, int32_t len) {
    // 0x100003d64
    return _munmap(addr, len);
}

// Address range: 0x100003d70 - 0x100003d7c
int32_t function_100003d70(char * format, ...) {
    // 0x100003d70
    return _printf(format);
}

// Address range: 0x100003d7c - 0x100003d88
int32_t function_100003d7c(char * s1, char * s2) {
    // 0x100003d7c
    return _strcmp(s1, s2);
}

// Address range: 0x100003d88 - 0x100003d94
char * function_100003d88(int32_t errnum) {
    // 0x100003d88
    return _strerror(errnum);
}

// Address range: 0x100003d94 - 0x100003da0
int32_t function_100003d94(char * s) {
    // 0x100003d94
    return _strlen(s);
}

// Address range: 0x100003da0 - 0x100003dac
int32_t function_100003da0(char * s1, char * s2, int32_t n) {
    // 0x100003da0
    return _strncmp(s1, s2, n);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 26

`
`#include<stdio.h>
#define de 0
#define pe 1
#define ab 2

int main(){
	int sum = 0, i, j;
	int try_max = 0;
	//1 is deficient by default and can add it deficient list
	int   count_list[3] = {1,0,0};
	for(i=2; i <= 20000; i++){
		//Set maximum to check for proper division
		try_max = i/2;
		//1 is in all proper division number
		sum = 1;
		for(j=2; j<try_max; j++){
			//Check for proper division
			if (i % j)
				continue; //Pass if not proper division
			//Set new maximum for divisibility check
			try_max = i/j;
			//Add j to sum
			sum += j;
			if (j != try_max)
				sum += try_max;
		}
		//Categorize summation
		if (sum < i){
			count_list[de]++;
			continue;
		}
		if (sum > i){
			count_list[ab]++;
			continue;
		}
		count_list[pe]++;
	}
	printf("\nThere are %d deficient," ,count_list[de]);
	printf(" %d perfect," ,count_list[pe]);
	printf(" %d abundant numbers between 1 and 20000.\n" ,count_list[ab]);
return 0;
}
`,`#include "abundant-deficient-and-perfect-number-classifications.h"



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  int local_3c;
  int local_38;
  int local_34;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_34 = 2; local_34 < 0x4e21; local_34 = local_34 + 1) {
    local_3c = local_34 / 2;
    for (local_38 = 2; local_38 < local_3c; local_38 = local_38 + 1) {
      iVar1 = 0;
      if (local_38 != 0) {
        iVar1 = local_34 / local_38;
      }
      if ((local_34 == iVar1 * local_38) && (local_3c = 0, local_38 != 0)) {
        local_3c = local_34 / local_38;
      }
    }
  }
  _printf("\nThere are %d deficient,");
  _printf(" %d perfect,");
  iVar1 = _printf(" %d abundant numbers between 1 and 20000.\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>      /* C POSIX library file control options */
#include <unistd.h>     /* C POSIX library system calls: open, close */
#include <sys/mman.h>   /* memory management declarations: mmap, munmap */
#include <errno.h>      /* Std C library system error numbers: errno */
#include <err.h>        /* GNU C lib error messages: err */

int read_lines(const char * fname, int (*call_back)(const char*, const char*))
{
        int fd = open(fname, O_RDONLY);
        struct stat fs;
        char *buf, *buf_end;
        char *begin, *end, c;

        if (fd == -1) {
                err(1, "open: %s", fname);
                return 0;
        }

        if (fstat(fd, &fs) == -1) {
                err(1, "stat: %s", fname);
                return 0;
        }

        /* fs.st_size could have been 0 actually */
        buf = mmap(0, fs.st_size, PROT_READ, MAP_SHARED, fd, 0);
        if (buf == (void*) -1) {
                err(1, "mmap: %s", fname);
                close(fd);
                return 0;
        }

        buf_end = buf + fs.st_size;

        begin = end = buf;
        while (1) {
                if (! (*end == '\r' || *end == '\n')) {
                        if (++end < buf_end) continue;
                } else if (1 + end < buf_end) {
                        /* see if we got "\r\n" or "\n\r" here */
                        c = *(1 + end);
                        if ( (c == '\r' || c == '\n') && c != *end)
                                ++end;
                }

                /* call the call back and check error indication. Announce
                   error here, because we didn't tell call_back the file name */
                if (! call_back(begin, end)) {
                        err(1, "[callback] %s", fname);
                        break;
                }

                if ((begin = ++end) >= buf_end)
                        break;
        }

        munmap(buf, fs.st_size);
        close(fd);
        return 1;
}

int print_line(const char* begin, const char* end)
{
        if (write(fileno(stdout), begin, end - begin + 1) == -1) {
                return 0;
        }
        return 1;
}

int main()
{
        return read_lines("test.ps", print_line) ? 0 : 1;
}
`,`#include "read-a-file-line-by-line-3.h"



// WARNING: Restarted to delay deadcode elimination for space: stack

undefined8 _read_lines(char *param_1,code *param_2)

{
  char *pcVar1;
  char cVar2;
  int iVar3;
  char *pcVar4;
  char *local_d8;
  char *local_d0;
  stat sStack_b8;
  int local_24;
  code *local_20;
  char *local_18;
  
  local_20 = param_2;
  local_18 = param_1;
  local_24 = _open(param_1,0);
  if (local_24 == -1) {
    _err(1,"open: %s");
  }
  iVar3 = _fstat(local_24,&sStack_b8);
  if (iVar3 == -1) {
    _err(1,"stat: %s");
  }
  pcVar4 = (char *)_mmap(0,sStack_b8.st_size,1,1,local_24,0);
  if (pcVar4 == (char *)0xffffffffffffffff) {
    _err(1,"mmap: %s");
  }
  pcVar1 = pcVar4 + sStack_b8.st_size;
  local_d8 = pcVar4;
  local_d0 = pcVar4;
LAB_100003cdc:
  do {
    if ((*local_d8 == '\r') || (*local_d8 == '\n')) {
      if ((local_d8 + 1 < pcVar1) &&
         (((cVar2 = local_d8[1], cVar2 == '\r' || (cVar2 == '\n')) && (cVar2 != *local_d8)))) {
        local_d8 = local_d8 + 1;
      }
    }
    else {
      local_d8 = local_d8 + 1;
      if (local_d8 < pcVar1) goto LAB_100003cdc;
    }
    iVar3 = (*local_20)(local_d0,local_d8);
    if (iVar3 == 0) {
      _err(1,"[callback] %s");
    }
    local_d8 = local_d8 + 1;
    local_d0 = local_d8;
    if (pcVar1 <= local_d8) {
      _munmap(pcVar4,sStack_b8.st_size);
      _close(local_24);
      return 1;
    }
  } while( true );
}



bool _print_line(void *param_1,long param_2)

{
  int iVar1;
  ssize_t sVar2;
  
  iVar1 = _fileno(*(FILE **)PTR____stdoutp_100004000);
  sVar2 = _write(iVar1,param_1,(param_2 - (long)param_1) + 1);
  return sVar2 != -1;
}



bool entry(void)

{
  int iVar1;
  
  iVar1 = _read_lines("test.ps",_print_line);
  return iVar1 == 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004008)(param_1);
  return iVar1;
}



void _err(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__err_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fileno(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fileno_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fstat(int param_1,stat *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fstat_100004020)(param_1);
  return iVar1;
}



void _mmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__mmap_100004028)();
  return;
}



void _munmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__munmap_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _open(char *param_1,int param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__open_100004038)((int)param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t _write(int param_1,void *param_2,size_t param_3)

{
  ssize_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__write_100004040)(param_1);
  return sVar1;
}


`
`#include <stdio.h>

typedef unsigned char sint;
enum states { s_blnk = 0, s_tran, s_cont, s_disj };

/* Recursively look at each item in list, taking both choices of
   picking the item or not.  The state at each step depends on prvious
   pickings, with the state transition table:
	blank + no pick -> blank
	blank + pick -> contiguous
	transitional + no pick -> transitional
	transitional + pick -> disjoint
	contiguous + no pick -> transitional
	contiguous + pick -> contiguous
	disjoint + pick -> disjoint
	disjoint + no pick -> disjoint
   At first step, before looking at any item, state is blank.
   Because state is known at each step and needs not be calculated,
   it can be quite fast.
*/
unsigned char tbl[][2] = {
	{ s_blnk, s_cont },
	{ s_tran, s_disj },
	{ s_tran, s_cont },
	{ s_disj, s_disj },
};

void pick(sint n, sint step, sint state, char **v, unsigned long bits)
{
	int i, b;
	if (step == n) {
		if (state != s_disj) return;
		for (i = 0, b = 1; i < n; i++, b <<= 1)
			if ((b & bits)) printf("%s ", v[i]);
		putchar('\n');
		return;
	}

	bits <<= 1;
	pick(n, step + 1, tbl[state][0], v, bits); /* no pick */
	pick(n, step + 1, tbl[state][1], v, bits | 1); /* pick */
}

int main(int c, char **v)
{
	if (c - 1 >= sizeof(unsigned long) * 4)
		printf("Too many items");
	else
		pick(c - 1, 0, s_blnk, v + 1, 0);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003d9c(void);
int32_t function_100003f7c(char * format, ...);
int32_t function_100003f88(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003d9c - 0x100003efc
int64_t function_100003d9c(void) {
    // 0x100003d9c
    int64_t v1; // 0x100003d9c
    if ((v1 ^ v1) % 256 != 0) {
        // 0x100003e7c
        function_100003d9c();
        // 0x100003ef0
        return function_100003d9c();
    }
    if (v1 % 256 != 3) {
        // 0x100003ef0
        int64_t result; // 0x100003d9c
        return result;
    }
    uint32_t v2 = (int32_t)v1 % 256;
    if (v2 == 0) {
        // 0x100003ef0
        return _putchar(10);
    }
    int32_t v3 = 1; // 0x100003d9c
    int32_t v4 = 0; // 0x100003e58
    if ((v1 & (int64_t)v3) != 0) {
        // 0x100003e2c
        _printf("%s ", (char *)v1);
    }
    // 0x100003e54
    v4++;
    int32_t v5 = v4 - v2; // 0x100003e04
    v3 *= 2;
    while (v5 < 0 != (v4 & -v5) < 0) {
        // 0x100003e14
        if ((v1 & (int64_t)v3) != 0) {
            // 0x100003e2c
            _printf("%s ", (char *)v1);
        }
        // 0x100003e54
        v4++;
        v5 = v4 - v2;
        v3 *= 2;
    }
    // 0x100003ef0
    return _putchar(10);
}

// Address range: 0x100003efc - 0x100003f7c
int64_t entry_point(void) {
    // 0x100003efc
    int64_t v1; // 0x100003efc
    if (0x100000000 * v1 - 0x100000000 >> 32 < 32) {
        // 0x100003f44
        function_100003d9c();
    } else {
        // 0x100003f34
        _printf("Too many items");
    }
    // 0x100003f6c
    return 0;
}

// Address range: 0x100003f7c - 0x100003f88
int32_t function_100003f7c(char * format, ...) {
    // 0x100003f7c
    return _printf(format);
}

// Address range: 0x100003f88 - 0x100003f94
int32_t function_100003f88(int32_t c) {
    // 0x100003f88
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdio.h>

unsigned digit_sum(unsigned n) {
    unsigned sum = 0;
    do { sum += n % 10; }
    while(n /= 10);
    return sum;
}

unsigned a131382(unsigned n) {
    unsigned m;
    for (m = 1; n != digit_sum(m*n); m++);
    return m;
}

int main() {
    unsigned n;
    for (n = 1; n <= 70; n++) {
        printf("%9u", a131382(n));
        if (n % 10 == 0) printf("\n");
    }
    return 0;
}
`,`#include "minimum-multiple-of-m-where-digital-sum-equals-m.h"



int _digit_sum(uint param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 0;
  local_4 = param_1;
  do {
    local_8 = local_8 + local_4 % 10;
    local_4 = local_4 / 10;
  } while (local_4 != 0);
  return local_8;
}



int _a131382(int param_1)

{
  int iVar1;
  undefined4 local_18;
  
  local_18 = 1;
  while( true ) {
    iVar1 = _digit_sum(local_18 * param_1);
    if (param_1 == iVar1) break;
    local_18 = local_18 + 1;
  }
  return local_18;
}



undefined8 entry(void)

{
  uint local_18;
  
  for (local_18 = 1; local_18 < 0x47; local_18 = local_18 + 1) {
    _a131382(local_18);
    _printf("%9u");
    if (local_18 % 10 == 0) {
      _printf("\n");
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Word Frequency Counter ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50 // Maximum word length
#define MAX_WORDS 1000 // Maximum number of words

char *words[MAX_WORDS]; // Array of strings to store words
int frequencies[MAX_WORDS]; // Array to store frequency of each word
int curr_index = 0; // Index into the words array

// Function to add word to arrays or increment frequency if already present
void add_word(char *word) {
    int i, is_new_word = 1;
    for (i = 0; i < curr_index; i++) {
        if (strcmp(word, words[i]) == 0) {
            frequencies[i]++;
            is_new_word = 0;
            break;
        }
    }
    if (is_new_word) {
        words[curr_index] = malloc(MAX_WORD_LENGTH * sizeof(char));
        strcpy(words[curr_index], word);
        frequencies[curr_index++] = 1;
    }
}

// Function to read input file and retrieve words
void read_file(char *filename) {
    FILE *fp = fopen(filename, "r");
    if (fp == NULL) {
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }
    char curr_word[MAX_WORD_LENGTH];
    int i, j, len;
    while (fscanf(fp, "%s", curr_word) != EOF) {
        // Convert word to lowercase
        len = strlen(curr_word);
        for (i = 0; i < len; i++) {
            curr_word[i] = tolower(curr_word[i]);
        }
        // Remove punctuation
        for (i = 0, j = 0; curr_word[i] != '\0'; i++) {
            if (isalpha(curr_word[i])) {
                curr_word[j++] = curr_word[i];
            }
        }
        curr_word[j] = '\0';
        // Add word to arrays
        if (strlen(curr_word) > 0) {
            add_word(curr_word);
        }
    }
    fclose(fp);
}

// Function to print word frequency table
void print_table() {
    printf("Word\tFrequency\n");
    int i;
    for (i = 0; i < curr_index; i++) {
        printf("%s\t%d\n", words[i], frequencies[i]);
    }
}

int main() {
    char filename[MAX_WORD_LENGTH];
    printf("Enter filename: ");
    scanf("%s", filename);
    read_file(filename);
    print_table();
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall read_file(_QWORD); // weak
__int64 print_table(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000194A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[64]; // [rsp+20h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  printf("Enter filename: ");
  scanf("%s", v4);
  read_file(v4);
  print_table();
  return 0;
}
// 14000177D: using guessed type __int64 __fastcall read_file(_QWORD);
// 1400018CF: using guessed type __int64 print_table(void);
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Basic Image Processing: Simple tasks like flipping an image, changing brightness/contrast ; Style: funny
#include<stdio.h>
#include<stdlib.h>

int main(){
    printf("Welcome to the image processing tool!\n");
    printf("Please enter the name of the image file you want to edit: ");

    char filename[100];
    scanf("%s", filename);

    // Opening the given file
    FILE* file = fopen(filename, "r");

    if(file == NULL) {
        printf("Oops! Unable to open file. Please make sure the file exists.\n");
        printf("Tip: Make sure the file name is correct and the file is not currently in use!\n");
        exit(0);
    }
    else {
        printf("File opened successfully!\n");
        printf("Please enter the task you want to perform:\n");
        printf("1. Flip the image\n");
        printf("2. Change brightness\n");
        printf("3. Change contrast\n");
        printf("Enter your choice (1/2/3): ");

        int choice;
        scanf("%d", &choice);
        printf("\nWait...processing your request...\n");

        // Processing the given task
        switch(choice) {
            case 1:
                printf("Flipping image...\n");
                // Code to flip the image
                break;
            case 2:
                printf("Changing brightness...\n");
                // Code to change brightness
                break;
            case 3:
                printf("Changing contrast...\n");
                // Code to change contrast
                break;
            default:
                printf("Invalid choice. Try again!\n");
                break;
        }
    }

    printf("\nDone processing your request! Thank you for using our tool!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-74h] BYREF
  char FileName[104]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the image processing tool!\n");
  printf("Please enter the name of the image file you want to edit: ");
  scanf("%s", FileName);
  if ( !fopen(FileName, "r") )
  {
    printf("Oops! Unable to open file. Please make sure the file exists.\n");
    printf("Tip: Make sure the file name is correct and the file is not currently in use!\n");
    exit(0);
  }
  printf("File opened successfully!\n");
  printf("Please enter the task you want to perform:\n");
  printf("1. Flip the image\n");
  printf("2. Change brightness\n");
  printf("3. Change contrast\n");
  printf("Enter your choice (1/2/3): ");
  scanf("%d", &v4);
  printf("\nWait...processing your request...\n");
  if ( v4 == 3 )
  {
    printf("Changing contrast...\n");
  }
  else
  {
    if ( v4 > 3 )
    {
LABEL_11:
      printf("Invalid choice. Try again!\n");
      goto LABEL_12;
    }
    if ( v4 == 1 )
    {
      printf("Flipping image...\n");
    }
    else
    {
      if ( v4 != 2 )
        goto LABEL_11;
      printf("Changing brightness...\n");
    }
  }
LABEL_12:
  printf("\nDone processing your request! Thank you for using our tool!\n");
  return 0;
}
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
int main (int argc, char *argv[]) {
//here we check arguments
	if (argc < 2) {
        printf("Enter an argument. Example 1234 or dcba:\n");
        return 0;
	}
//it calculates an array's length
        int x;
        for (x = 0; argv[1][x] != '\0'; x++);
//buble sort the array
	int f, v, m;
	 for(f=0; f < x; f++) {
    	 for(v = x-1; v > f; v-- ) {
     	 if (argv[1][v-1] > argv[1][v]) {
	m=argv[1][v-1];
	argv[1][v-1]=argv[1][v];
	argv[1][v]=m;
    }
  }
}

//it calculates a factorial to stop the algorithm
    char a[x];
	int k=0;
	int fact=k+1;
             while (k!=x) {
                   a[k]=argv[1][k];
               	   k++;
		  fact = k*fact;
                   }
                   a[k]='\0';
//Main part: here we permutate
           int i, j;
           int y=0;
           char c;
          while (y != fact) {
          printf("%s\n", a);
          i=x-2;
          while(a[i] > a[i+1] ) i--;
          j=x-1;
          while(a[j] < a[i] ) j--;
      c=a[j];
      a[j]=a[i];
      a[i]=c;
i++;
for (j = x-1; j > i; i++, j--) {
  c = a[i];
  a[i] = a[j];
  a[j] = c;
      }
y++;
   }
}
`,`#include "permutations-1.h"



undefined4 entry(int param_1,long param_2)

{
  char cVar1;
  long lVar2;
  uint uVar3;
  uint uVar4;
  ulong uVar5;
  long alStack_90 [2];
  undefined auStack_80 [12];
  undefined4 local_74;
  ulong local_70;
  undefined *local_68;
  undefined local_5d;
  int local_5c;
  uint local_58;
  int local_54;
  int local_50;
  uint local_4c;
  undefined *local_40;
  int local_38;
  uint local_34;
  int local_30;
  uint local_2c;
  long local_28;
  int local_20;
  undefined4 local_1c;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_1c = 0;
  local_28 = param_2;
  local_20 = param_1;
  if (param_1 < 2) {
    uVar4 = _printf("Enter an argument. Example 1234 or dcba:\n");
    uVar5 = (ulong)uVar4;
    local_1c = 0;
  }
  else {
    for (local_2c = 0; *(char *)(*(long *)(param_2 + 8) + (long)(int)local_2c) != '\0';
        local_2c = local_2c + 1) {
    }
    for (local_30 = 0; uVar4 = local_2c, local_30 < (int)local_2c; local_30 = local_30 + 1) {
      while (uVar3 = uVar4, local_34 = uVar3 - 1, local_30 < (int)local_34) {
        uVar4 = local_34;
        if (*(char *)(*(long *)(param_2 + 8) + (long)(int)local_34) <
            *(char *)(*(long *)(param_2 + 8) + (long)(int)(uVar3 - 2))) {
          cVar1 = *(char *)(*(long *)(param_2 + 8) + (long)(int)(uVar3 - 2));
          local_38 = (int)cVar1;
          *(undefined *)(*(long *)(param_2 + 8) + (long)(int)(uVar3 - 2)) =
               *(undefined *)(*(long *)(param_2 + 8) + (long)(int)local_34);
          *(char *)(*(long *)(param_2 + 8) + (long)(int)local_34) = cVar1;
          uVar4 = local_34;
        }
      }
    }
    local_70 = (ulong)local_2c + 0xf & 0xfffffffffffffff0;
    local_40 = auStack_80;
    uVar5 = (*(code *)PTR____chkstk_darwin_100004000)();
    lVar2 = -local_70;
    local_68 = auStack_80 + lVar2;
    local_4c = 0;
    local_50 = 1;
    while (local_4c != local_2c) {
      local_68[(int)local_4c] = *(undefined *)(*(long *)(local_28 + 8) + (long)(int)local_4c);
      local_4c = local_4c + 1;
      local_50 = local_4c * local_50;
    }
    local_68[(int)local_4c] = 0;
    for (local_5c = 0; local_5c != local_50; local_5c = local_5c + 1) {
      *(undefined **)((long)alStack_90 + lVar2) = local_68;
      uVar4 = _printf("%s\n");
      uVar5 = (ulong)uVar4;
      for (local_54 = local_2c - 2; local_58 = local_2c,
          (char)local_68[local_54 + 1] < (char)local_68[local_54]; local_54 = local_54 + -1) {
      }
      do {
        local_58 = local_58 - 1;
      } while ((char)local_68[(int)local_58] < (char)local_68[local_54]);
      local_5d = local_68[(int)local_58];
      local_68[(int)local_58] = local_68[local_54];
      local_68[local_54] = local_5d;
      local_58 = local_2c;
      while( true ) {
        local_54 = local_54 + 1;
        local_58 = local_58 - 1;
        if ((int)local_58 <= local_54) break;
        local_5d = local_68[local_54];
        local_68[local_54] = local_68[(int)local_58];
        local_68[(int)local_58] = local_5d;
      }
    }
  }
  local_74 = local_1c;
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return local_1c;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(uVar5);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void padovanN(int n, size_t t, int *p) {
    int i, j;
    if (n < 2 || t < 3) {
        for (i = 0; i < t; ++i) p[i] = 1;
        return;
    }
    padovanN(n-1, t, p);
    for (i = n + 1; i < t; ++i) {
        p[i] = 0;
        for (j = i - 2; j >= i - n - 1; --j) p[i] += p[j];
    }
}

int main() {
    int n, i;
    const size_t t = 15;
    int p[t];
    printf("First %ld terms of the Padovan n-step number sequences:\n", t);
    for (n = 2; n <= 8; ++n) {
        for (i = 0; i < t; ++i) p[i] = 0;
        padovanN(n, t, p);
        printf("%d: ", n);
        for (i = 0; i < t; ++i) printf("%3d ", p[i]);
        printf("\n");
    }
    return 0;
}
`,`#include "padovan-n-step-number-sequences.h"



void _padovanN(int param_1,ulong param_2,long param_3)

{
  int *piVar1;
  int local_30;
  int local_2c;
  
  if ((param_1 < 2) || (param_2 < 3)) {
    for (local_2c = 0; (ulong)(long)local_2c < param_2; local_2c = local_2c + 1) {
      *(undefined4 *)(param_3 + (long)local_2c * 4) = 1;
    }
  }
  else {
    _padovanN(param_1 + -1,param_2,param_3);
    for (local_2c = param_1 + 1; (ulong)(long)local_2c < param_2; local_2c = local_2c + 1) {
      *(undefined4 *)(param_3 + (long)local_2c * 4) = 0;
      for (local_30 = local_2c + -2; (local_2c - param_1) + -1 <= local_30; local_30 = local_30 + -1
          ) {
        piVar1 = (int *)(param_3 + (long)local_2c * 4);
        *piVar1 = *piVar1 + *(int *)(param_3 + (long)local_30 * 4);
      }
    }
  }
  return;
}



undefined8 entry(void)

{
  int iVar1;
  uint local_60;
  int local_5c;
  undefined4 auStack_54 [15];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  iVar1 = _printf("First %ld terms of the Padovan n-step number sequences:\n");
  for (local_5c = 2; local_5c < 9; local_5c = local_5c + 1) {
    for (local_60 = 0; local_60 < 0xf; local_60 = local_60 + 1) {
      auStack_54[(int)local_60] = 0;
    }
    _padovanN(local_5c,0xf,auStack_54);
    _printf("%d: ");
    for (local_60 = 0; local_60 < 0xf; local_60 = local_60 + 1) {
      _printf("%3d ");
    }
    iVar1 = _printf("\n");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <sys/wait.h>
#include <err.h>

typedef int (*intfunc)(int);
typedef void (*pfunc)(int*, int);

pfunc partial(intfunc fin)
{
	pfunc f;
	static int idx = 0;
	char cc[256], lib[256];
	FILE *fp;
	sprintf(lib, "/tmp/stuff%d.so", ++idx);
	sprintf(cc, "cc -pipe -x c -shared -o %s -", lib);

	fp = popen(cc, "w");
	fprintf(fp, "#define t typedef\xat int _i,*i;t _i(*__)(_i);__ p =(__)%p;"
		"void _(i _1, _i l){while(--l>-1)l[_1]=p(l[_1]);}", fin);
	fclose(fp);

	*(void **)(&f) = dlsym(dlopen(lib, RTLD_LAZY), "_");
	unlink(lib);
	return f;
}

int square(int a)
{
	return a * a;
}

int dbl(int a)
{
	return a + a;
}

int main()
{
	int x[] = { 1, 2, 3, 4 };
	int y[] = { 1, 2, 3, 4 };
	int i;

	pfunc f = partial(square);
	pfunc g = partial(dbl);

	printf("partial square:\n");
	f(x, 4);
	for (i = 0; i < 4; i++) printf("%d\n", x[i]);

	printf("partial double:\n");
	g(y, 4);
	for (i = 0; i < 4; i++) printf("%d\n", y[i]);

	return 0;
}
`,`#include "partial-function-application-1.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 _partial(void)

{
  int iVar1;
  FILE *pFVar2;
  undefined8 uVar3;
  char acStack_228 [256];
  char acStack_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _DAT_100008000 = _DAT_100008000 + 1;
  ___sprintf_chk();
  ___sprintf_chk(acStack_128,0,0x100,"cc -pipe -x c -shared -o %s -");
  pFVar2 = _popen(acStack_128,"w");
  _fprintf(pFVar2,
           "#define t typedef\nt int _i,*i;t _i(*__)(_i);__ p =(__)%p;void _(i _1, _i l){while(--l>-1)l[_1]=p(l[_1]);}"
          );
  _fclose(pFVar2);
  uVar3 = _dlopen(acStack_228,1);
  uVar3 = _dlsym(uVar3,"_");
  iVar1 = _unlink(acStack_228);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return uVar3;
}



int _square(int param_1)

{
  return param_1 * param_1;
}



int _dbl(int param_1)

{
  return param_1 * 2;
}



undefined8 entry(void)

{
  uint uVar1;
  code *pcVar2;
  code *pcVar3;
  ulong uVar4;
  int local_48;
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  undefined8 uStack_28;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  uStack_28 = 0x400000003;
  local_30 = 0x200000001;
  uStack_38 = 0x400000003;
  local_40 = 0x200000001;
  pcVar2 = (code *)_partial(_square);
  pcVar3 = (code *)_partial(_dbl);
  _printf("partial square:\n");
  (*pcVar2)(&local_30,4);
  for (local_48 = 0; local_48 < 4; local_48 = local_48 + 1) {
    _printf("%d\n");
  }
  _printf("partial double:\n");
  uVar4 = (*pcVar3)(&local_40,4);
  for (local_48 = 0; local_48 < 4; local_48 = local_48 + 1) {
    uVar1 = _printf("%d\n");
    uVar4 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar4);
  }
  return 0;
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void _dlopen(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__dlopen_100004018)();
  return;
}



void _dlsym(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__dlsym_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _popen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea0. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__popen_100004038)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _unlink(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__unlink_100004048)((int)param_1);
  return iVar1;
}


`
`#include <string.h>
#include <stdio.h>
#include <stdlib.h>

  /* removes all chars from string */
char *strip_chars(const char *string, const char *chars)
{
  char * newstr = malloc(strlen(string) + 1);
  int counter = 0;

  for ( ; *string; string++) {
    if (!strchr(chars, *string)) {
      newstr[ counter ] = *string;
      ++ counter;
    }
  }

  newstr[counter] = 0;
  return newstr;
}

int main(void)
{
  char *new = strip_chars("She was a soul stripper. She took my heart!", "aei");
  printf("%s\n", new);

  free(new);
  return 0;
}
`,`#include "strip-a-set-of-characters-from-a-string-1.h"



void * _strip_chars(char *param_1,char *param_2)

{
  size_t sVar1;
  void *pvVar2;
  char *pcVar3;
  int local_2c;
  char *local_18;
  
  sVar1 = _strlen(param_1);
  pvVar2 = _malloc(sVar1 + 1);
  local_2c = 0;
  for (local_18 = param_1; *local_18 != '\0'; local_18 = local_18 + 1) {
    pcVar3 = _strchr(param_2,(int)*local_18);
    if (pcVar3 == (char *)0x0) {
      *(char *)((long)pvVar2 + (long)local_2c) = *local_18;
      local_2c = local_2c + 1;
    }
  }
  *(undefined *)((long)pvVar2 + (long)local_2c) = 0;
  return pvVar2;
}



undefined4 entry(void)

{
  void *pvVar1;
  
  pvVar1 = (void *)_strip_chars("She was a soul stripper. She took my heart!","aei");
  _printf("%s\n");
  _free(pvVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strchr(char *param_1,int param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strchr_100004018)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004020)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <alloca.h> /* stdlib.h might not have obliged. */
#include <string.h>

static void reverse(char *s, int len)
{
    int i, j;
    char tmp;

    for (i = 0, j = len - 1; i < len / 2; ++i, --j)
        tmp = s[i], s[i] = s[j], s[j] = tmp;
}

/* Wrap strcmp() for qsort(). */
static int strsort(const void *s1, const void *s2)
{
    return strcmp(*(char *const *) s1, *(char *const *) s2);
}

int main(void)
{
    int i, c, ct = 0, len, sem = 0;
    char **words, **drows, tmp[24];
    FILE *dict = fopen("unixdict.txt", "r");

    /* Determine word count. */
    while ((c = fgetc(dict)) != EOF)
        ct += c == '\n';
    rewind(dict);

    /* Using alloca() is generally discouraged, but we're not doing
     * anything too fancy and the memory gains are significant. */
    words = alloca(ct * sizeof words);
    drows = alloca(ct * sizeof drows);

    for (i = 0; fscanf(dict, "%s%n", tmp, &len) != EOF; ++i) {
        /* Use just enough memory to store the next word. */
        strcpy(words[i] = alloca(len), tmp);

        /* Store it again, then reverse it. */
        strcpy(drows[i] = alloca(len), tmp);
        reverse(drows[i], len - 1);
    }

    fclose(dict);
    qsort(drows, ct, sizeof drows, strsort);

    /* Walk both sorted lists, checking only the words which could
     * possibly be a semordnilap pair for the current reversed word. */
    for (c = i = 0; i < ct; ++i) {
        while (strcmp(drows[i], words[c]) > 0 && c < ct - 1)
            c++;
        /* We found a semordnilap. */
        if (!strcmp(drows[i], words[c])) {
            strcpy(tmp, drows[i]);
            reverse(tmp, strlen(tmp));
            /* Unless it was a palindrome. */
            if (strcmp(drows[i], tmp) > 0 && sem++ < 5)
                printf("%s\t%s\n", drows[i], tmp);
        }
    }

    printf("Semordnilap pairs: %d\n", sem);
    return 0;
}
`,`#include "semordnilap.h"



undefined8 entry(void)

{
  bool bVar1;
  uint uVar2;
  long lVar3;
  FILE *pFVar4;
  undefined *puVar5;
  int iVar6;
  undefined8 uVar7;
  size_t sVar8;
  char *local_a0;
  uint local_94;
  ulong local_90;
  char *local_88;
  undefined8 local_80;
  ulong local_78;
  ulong local_70;
  ulong local_68;
  FILE *local_60;
  undefined *local_58;
  long local_50;
  uint local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_38;
  undefined4 local_34;
  char acStack_30 [24];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_34 = 0;
  local_40 = 0;
  local_48 = 0;
  local_60 = _fopen("unixdict.txt","r");
  while (local_3c = _fgetc(local_60), local_3c != -1) {
    local_40 = local_40 + (uint)(local_3c == 10);
  }
  _rewind(local_60);
  local_70 = (long)local_40 * 8 + 0xfU & 0xfffffffffffffff0;
  (*(code *)PTR____chkstk_darwin_100004000)();
  lVar3 = (long)&local_a0 - local_70;
  local_68 = (long)local_40 * 8 + 0xfU & 0xfffffffffffffff0;
  local_50 = lVar3;
  (*(code *)PTR____chkstk_darwin_100004000)();
  puVar5 = (undefined *)(lVar3 - local_68);
  local_38 = 0;
  local_58 = puVar5;
  while( true ) {
    pFVar4 = local_60;
    *(char **)(puVar5 + -0x10) = acStack_30;
    *(int **)(puVar5 + -8) = &local_44;
    iVar6 = _fscanf(pFVar4,"%s%n");
    if (iVar6 == -1) break;
    local_90 = (long)local_44 + 0xfU & 0xfffffffffffffff0;
    (*(code *)PTR____chkstk_darwin_100004000)();
    lVar3 = (long)puVar5 - local_90;
    *(long *)(local_50 + (long)local_38 * 8) = lVar3;
    local_88 = acStack_30;
    local_80 = 0xffffffffffffffff;
    uVar7 = ___strcpy_chk();
    local_78 = (long)local_44 + 0xfU & 0xfffffffffffffff0;
    (*(code *)PTR____chkstk_darwin_100004000)(uVar7,local_88,local_80);
    puVar5 = (undefined *)(lVar3 - local_78);
    *(undefined **)(local_58 + (long)local_38 * 8) = puVar5;
    ___strcpy_chk();
    FUN_100003e04(*(undefined8 *)(local_58 + (long)local_38 * 8),local_44 + -1);
    local_38 = local_38 + 1;
  }
  _fclose(local_60);
  _qsort(local_58,(long)local_40,8,(int *)FUN_100003eb4);
  local_3c = 0;
  for (local_38 = 0; local_38 < local_40; local_38 = local_38 + 1) {
    while( true ) {
      iVar6 = _strcmp(*(char **)(local_58 + (long)local_38 * 8),
                      *(char **)(local_50 + (long)local_3c * 8));
      local_94 = 0;
      if (0 < iVar6) {
        local_94 = (uint)(local_3c < local_40 + -1);
      }
      if (local_94 == 0) break;
      local_3c = local_3c + 1;
    }
    iVar6 = _strcmp(*(char **)(local_58 + (long)local_38 * 8),
                    *(char **)(local_50 + (long)local_3c * 8));
    if (iVar6 == 0) {
      local_a0 = acStack_30;
      ___strcpy_chk(local_a0,*(undefined8 *)(local_58 + (long)local_38 * 8),0x18);
      sVar8 = _strlen(local_a0);
      FUN_100003e04(local_a0,sVar8);
      iVar6 = _strcmp(*(char **)(local_58 + (long)local_38 * 8),local_a0);
      if ((0 < iVar6) && (uVar2 = local_48 + 1, bVar1 = (int)local_48 < 5, local_48 = uVar2, bVar1))
      {
        *(undefined8 *)(puVar5 + -0x10) = *(undefined8 *)(local_58 + (long)local_38 * 8);
        *(char **)(puVar5 + -8) = acStack_30;
        _printf("%s\t%s\n");
      }
    }
  }
  *(ulong *)(puVar5 + -0x10) = (ulong)local_48;
  iVar6 = _printf("Semordnilap pairs: %d\n");
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar6);
}



void FUN_100003e04(long param_1,int param_2)

{
  undefined uVar1;
  undefined4 local_14;
  undefined4 local_10;
  
  local_14 = param_2 + -1;
  for (local_10 = 0; local_10 < param_2 / 2; local_10 = local_10 + 1) {
    uVar1 = *(undefined *)(param_1 + local_10);
    *(undefined *)(param_1 + local_10) = *(undefined *)(param_1 + local_14);
    *(undefined *)(param_1 + local_14) = uVar1;
    local_14 = local_14 + -1;
  }
  return;
}



int FUN_100003eb4(undefined8 *param_1,undefined8 *param_2)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)*param_1,(char *)*param_2);
  return iVar1;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetc_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004030)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fscanf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fscanf_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004048)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _rewind(FILE *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__rewind_100004050)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004058)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004060)();
  return sVar1;
}


`
`/*
  compilation and test in bash
  $ a=./c && make $a && $a ball bell ball ball YUP YEP     ball BELL ball BALL YUP yep
  cc -Wall -c -o c.o c.c
  	eq , ne , gt , lt , ge , le
  ball 0 1 0 1 0 1 bell
  ball 0 1 0 1 0 1 bell ignoring case
  ball 1 0 0 0 1 1 ball
  ball 1 0 0 0 1 1 ball ignoring case
  YUP 0 1 1 0 1 0 YEP
  YUP 0 1 1 0 1 0 YEP ignoring case
  ball 0 1 1 0 1 0 BELL
  ball 0 1 0 1 0 1 BELL ignoring case
  ball 0 1 1 0 1 0 BALL
  ball 1 0 0 0 1 1 BALL ignoring case
  YUP 0 1 0 1 0 1 yep
  YUP 0 1 1 0 1 0 yep ignoring case
*/

#include<string.h>

#define STREQ(A,B) (0==strcmp((A),(B)))
#define STRNE(A,B) (!STREQ(A,B))
#define STRLT(A,B) (strcmp((A),(B))<0)
#define STRLE(A,B) (strcmp((A),(B))<=0)
#define STRGT(A,B) STRLT(B,A)
#define STRGE(A,B) STRLE(B,A)

#define STRCEQ(A,B) (0==strcasecmp((A),(B)))
#define STRCNE(A,B) (!STRCEQ(A,B))
#define STRCLT(A,B) (strcasecmp((A),(B))<0)
#define STRCLE(A,B) (strcasecmp((A),(B))<=0)
#define STRCGT(A,B) STRCLT(B,A)
#define STRCGE(A,B) STRCLE(B,A)

#include<stdio.h>

void compare(const char*a, const char*b) {
  printf("%s%2d%2d%2d%2d%2d%2d %s\n",
	 a,
	 STREQ(a,b), STRNE(a,b), STRGT(a,b), STRLT(a,b), STRGE(a,b), STRLE(a,b),
	 b
	 );
}
void comparecase(const char*a, const char*b) {
  printf("%s%2d%2d%2d%2d%2d%2d %s ignoring case\n",
	 a,
	 STRCEQ(a,b), STRCNE(a,b), STRCGT(a,b), STRCLT(a,b), STRCGE(a,b), STRCLE(a,b),
	 b
	 );
}
int main(int ac, char*av[]) {
  char*a,*b;
  puts("\teq , ne , gt , lt , ge , le");
  while (0 < (ac -= 2)) {
    a = *++av, b = *++av;
    compare(a, b);
    comparecase(a, b);
  }
  return 0;
}
`,`#include "string-comparison-2.h"



int _compare(char *param_1,char *param_2)

{
  int iVar1;
  
  _strcmp(param_1,param_2);
  _strcmp(param_1,param_2);
  _strcmp(param_2,param_1);
  _strcmp(param_1,param_2);
  _strcmp(param_2,param_1);
  _strcmp(param_1,param_2);
  iVar1 = _printf("%s%2d%2d%2d%2d%2d%2d %s\n");
  return iVar1;
}



int _comparecase(char *param_1,char *param_2)

{
  int iVar1;
  
  _strcasecmp(param_1,param_2);
  _strcasecmp(param_1,param_2);
  _strcasecmp(param_2,param_1);
  _strcasecmp(param_1,param_2);
  _strcasecmp(param_2,param_1);
  _strcasecmp(param_1,param_2);
  iVar1 = _printf("%s%2d%2d%2d%2d%2d%2d %s ignoring case\n");
  return iVar1;
}



undefined8 entry(int param_1,long param_2)

{
  undefined8 uVar1;
  undefined8 uVar2;
  long local_20;
  int local_18;
  
  _puts("\teq , ne , gt , lt , ge , le");
  local_20 = param_2;
  local_18 = param_1;
  while (local_18 = local_18 + -2, 0 < local_18) {
    uVar1 = *(undefined8 *)(local_20 + 8);
    uVar2 = *(undefined8 *)(local_20 + 0x10);
    _compare(uVar1,uVar2);
    _comparecase(uVar1,uVar2);
    local_20 = local_20 + 0x10;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcasecmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcasecmp_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int check_isin(char *a) {
    int i, j, k, v, s[24];

    j = 0;
    for(i = 0; i < 12; i++) {
        k = a[i];
        if(k >= '0' && k <= '9') {
            if(i < 2) return 0;
            s[j++] = k - '0';
        } else if(k >= 'A' && k <= 'Z') {
            if(i == 11) return 0;
            k -= 'A' - 10;
            s[j++] = k / 10;
            s[j++] = k % 10;
        } else {
            return 0;
        }
    }

    if(a[i]) return 0;

    v = 0;
    for(i = j - 2; i >= 0; i -= 2) {
        k = 2 * s[i];
        v += k > 9 ? k - 9 : k;
    }

    for(i = j - 1; i >= 0; i -= 2) {
        v += s[i];
    }

    return v % 10 == 0;
}

int main() {
    char *test[7] = {"US0378331005", "US0373831005", "U50378331005",
                     "US03378331005", "AU0000XVGZA3", "AU0000VXGZA3",
                     "FR0000988040"};
    int i;
    for(i = 0; i < 7; i++) printf("%c%c", check_isin(test[i]) ? 'T' : 'F', i == 6 ? '\n' : ' ');
    return 0;
}

/* will print: T F F F T T T */
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003b38(void);
int64_t function_100003f20(int64_t a1);
int64_t * function_100003f2c(int64_t * dest, int64_t * src, int32_t n);
int32_t function_100003f38(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int64_t ___stack_chk_fail(int64_t a1);
int64_t * _memcpy(int64_t * a1, int64_t * a2, int32_t a3);
int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003b38 - 0x100003e1c
int64_t function_100003b38(void) {
    int64_t v1 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003b4c
    int64_t v2; // bp-120, 0x100003b38
    int64_t v3 = &v2;
    int64_t v4 = 0;
    int64_t v5; // 0x100003b38
    char v6 = *(char *)v5;
    int32_t v7 = 0; // 0x100003b38
    int32_t v8 = 0;
    char v9; // 0x100003b38
    uint64_t v10; // 0x100003b38
    int64_t result; // 0x100003b38
    int32_t v11; // 0x100003b38
    int32_t v12; // 0x100003b38
    int32_t v13; // 0x100003b38
    int32_t v14; // 0x100003b80
    while (true) {
      lab_0x100003b78:
        // 0x100003b78
        v11 = v8;
        v13 = v7;
        v9 = v6;
        v10 = v4;
        v14 = v9;
        if (v9 < 48 == (47 - v14 & v14) < 0) {
            int32_t v15 = v14 - 57; // 0x100003ba0
            if (v15 == 0 || v15 < 0 != (56 - v14 & v14) < 0) {
                // 0x100003bb0
                result = 0;
                if (v10 < 2 != (1 - v13 & (int32_t)v10) < 0) {
                    // break -> 0x100003de0
                    break;
                }
                // 0x100003bcc
                *(int32_t *)(4 * (int64_t)v11 + v3) = v14 - 48;
                v12 = v11 + 1;
                goto lab_0x100003c9c;
            } else {
                goto lab_0x100003bf0;
            }
        } else {
            goto lab_0x100003bf0;
        }
    }
    goto lab_0x100003de0_3;
  lab_0x100003bf0:
    // 0x100003bf0
    if (v9 < 65 != (64 - v14 & v14) < 0) {
        // break -> 0x100003de0
        goto lab_0x100003de0_3;
    }
    int32_t v31 = v14 - 90; // 0x100003c08
    result = 0;
    if (v10 == 11 || v31 != 0 == v31 < 0 == (89 - v14 & v14) < 0) {
        // break -> 0x100003de0
        goto lab_0x100003de0_3;
    }
    int32_t v32 = v14 - 55; // 0x100003c38
    *(int32_t *)(4 * (int64_t)v11 + v3) = v32 / 10;
    *(int32_t *)(4 * (int64_t)(v11 + 1) + v3) = v32 % 10;
    v12 = v11 + 2;
    goto lab_0x100003c9c;
  lab_0x100003c9c:
    // 0x100003c9c
    v8 = v12;
    v4 = v10 + 1;
    v6 = *(char *)(v4 + v5);
    v7 = v13 + 1;
    int64_t v22; // 0x100003b38
    int32_t v25; // 0x100003b38
    int32_t v20; // 0x100003b38
    int32_t v27; // 0x100003b38
    if (v10 < 11 == (10 - v13 & (int32_t)v4) < 0) {
        // 0x100003cac
        result = 0;
        if (v6 == 0) {
            int32_t v33 = v8 - 2;
            v20 = 0;
            if (v33 < 0) {
                goto lab_0x100003d68;
            } else {
                // 0x100003cfc
                v22 = v33;
                v27 = v33;
                v25 = 0;
                goto lab_0x100003cfc_2;
            }
        } else {
            goto lab_0x100003de0_3;
        }
    }
    goto lab_0x100003b78;
  lab_0x100003de0_3:
    // 0x100003de0
    if (*(int64_t *)*(int64_t *)0x100004008 != v1) {
        // 0x100003e08
        ___stack_chk_fail(v5);
    }
    // 0x100003e0c
    return result;
  lab_0x100003d68:;
    int32_t v16 = v8 - 1; // 0x100003d6c
    int64_t v17; // 0x100003b38
    int32_t v18; // 0x100003b38
    int32_t v19; // 0x100003b38
    if (v16 < 0) {
        // 0x100003db8
        result = v20 % 10 == 0;
        goto lab_0x100003de0_3;
    } else {
        // 0x100003d8c
        v17 = v16;
        v19 = v16;
        v18 = v20;
        goto lab_0x100003d8c_2;
    }
  lab_0x100003cfc_2:;
    int32_t v21 = 2 * *(int32_t *)(4 * v22 + v3); // 0x100003d0c
    int32_t v23 = v21 - 9; // 0x100003d18
    int32_t v24 = (v23 < 0 == (8 - v21 & v21) < 0 ? v23 : v21) + v25; // 0x100003d4c
    int32_t v26 = v27 - 2;
    v22 -= 2;
    v27 = v26;
    v25 = v24;
    v20 = v24;
    if (v26 < 0) {
        goto lab_0x100003d68;
    } else {
        goto lab_0x100003cfc_2;
    }
  lab_0x100003d8c_2:;
    int32_t v28 = *(int32_t *)(4 * v17 + v3) + v18; // 0x100003d9c
    int32_t v29 = v19 - 2; // 0x100003dac
    v17 -= 2;
    v19 = v29;
    v18 = v28;
    int32_t v30 = v28; // 0x100003d84
    if (v29 < 0) {
        // 0x100003db8
        result = v30 % 10 == 0;
        goto lab_0x100003de0_3;
    } else {
        goto lab_0x100003d8c_2;
    }
}

// Address range: 0x100003e1c - 0x100003f20
int64_t entry_point(void) {
    // 0x100003e1c
    int64_t v1; // bp-80, 0x100003e1c
    _memcpy(&v1, (int64_t *)"D?", 56);
    int32_t v2; // 0x100003ed4
    for (int32_t i = 0; i < 7; i++) {
        // 0x100003e6c
        function_100003b38();
        v2 = _printf("%c%c", (char)"D?", 56);
    }
    int64_t v3 = *(int64_t *)*(int64_t *)0x100004008; // 0x100003ef8
    if (v3 != *(int64_t *)*(int64_t *)0x100004008) {
        // 0x100003f0c
        ___stack_chk_fail((int64_t)v2);
    }
    // 0x100003f10
    return 0;
}

// Address range: 0x100003f20 - 0x100003f2c
int64_t function_100003f20(int64_t a1) {
    // 0x100003f20
    return ___stack_chk_fail(a1);
}

// Address range: 0x100003f2c - 0x100003f38
int64_t * function_100003f2c(int64_t * dest, int64_t * src, int32_t n) {
    // 0x100003f2c
    return _memcpy(dest, src, n);
}

// Address range: 0x100003f38 - 0x100003f44
int32_t function_100003f38(char * format, ...) {
    // 0x100003f38
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 5

`
`//FormAI DATASET v1.0 Category: Cat Language Translator ; Style: Claude Shannon
/* Cat Language Translator */

#include <stdio.h>
#include <string.h>

int main() {

    printf("\n");
    printf("Welcome to the Cat Language Translator!\n");
    printf("\n");

    /* Input cat word */
    char cat_word[50];
    printf("Enter a word in Cat language: ");
    scanf("%s", cat_word);
    printf("\n");

    /* Translate cat word to English */
    if(strcmp(cat_word, "meow") == 0) {
        printf("Translation: Hello!\n");
    }
    else if(strcmp(cat_word, "purr") == 0) {
        printf("Translation: Thank you!\n");
    }
    else if(strcmp(cat_word, "hiss") == 0) {
        printf("Translation: I'm scared!\n");
    }
    else if(strcmp(cat_word, "sniff") == 0) {
        printf("Translation: What's that smell?\n");
    }
    else if(strcmp(cat_word, "lick") == 0) {
        printf("Translation: Yummy!\n");
    }
    else if(strcmp(cat_word, "scratch") == 0) {
        printf("Translation: I'm itchy!\n");
    }
    else if(strcmp(cat_word, "sleep") == 0) {
        printf("Translation: Zzz...\n");
    }
    else {
        printf("Translation: I don't understand!\n");
    }

    printf("\n");
    printf("Thank you for using the Cat Language Translator!\n");
    printf("\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[64]; // [rsp+20h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  printf("\n");
  printf("Welcome to the Cat Language Translator!\n");
  printf("\n");
  printf("Enter a word in Cat language: ");
  scanf("%s", Str1);
  printf("\n");
  if ( !strcmp(Str1, "meow") )
  {
    printf("Translation: Hello!\n");
  }
  else if ( !strcmp(Str1, "purr") )
  {
    printf("Translation: Thank you!\n");
  }
  else if ( !strcmp(Str1, "hiss") )
  {
    printf("Translation: I'm scared!\n");
  }
  else if ( !strcmp(Str1, "sniff") )
  {
    printf("Translation: What's that smell?\n");
  }
  else if ( !strcmp(Str1, "lick") )
  {
    printf("Translation: Yummy!\n");
  }
  else if ( !strcmp(Str1, "scratch") )
  {
    printf("Translation: I'm itchy!\n");
  }
  else if ( !strcmp(Str1, "sleep") )
  {
    printf("Translation: Zzz...\n");
  }
  else
  {
    printf("Translation: I don't understand!\n");
  }
  printf("\n");
  printf("Thank you for using the Cat Language Translator!\n");
  printf("\n");
  return 0;
}
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: String manipulation ; Style: paranoid
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_STR_LEN 50

int main() {

  char input_str[MAX_STR_LEN + 1];
  char output_str[MAX_STR_LEN + 1];
  int length = 0;
  int num_upper = 0;
  int num_lower = 0;
  int num_digits = 0;
  int num_special = 0;
  int paranoid_score = 0;
  int i;

  printf("Enter a string (max length %d): ", MAX_STR_LEN);
  fgets(input_str, MAX_STR_LEN+1, stdin);
  length = strlen(input_str);

  // Copy input string to output string
  strcpy(output_str, input_str);

  // Calculate number of uppercase, lowercase characters, digits, and special characters
  for(i = 0; i < length; i++) {
    if(isupper(input_str[i])) {
      num_upper++;
    }
    else if(islower(input_str[i])) {
      num_lower++;
    }
    else if(isdigit(input_str[i])) {
      num_digits++;
    }
    else if(!isspace(input_str[i])) {
      num_special++;
    }
  }

  // Calculate paranoid score based on number of characters and type of characters
  paranoid_score = length * 2;
  paranoid_score += num_upper * 5;
  paranoid_score += num_lower * 3;
  paranoid_score += num_digits * 4;
  paranoid_score += num_special * 6;

  // Print out paranoid score and output string
  printf("Paranoid Score: %d\n", paranoid_score);
  printf("Output String: %s\n", output_str);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *islower)(int C);
// extern int (__cdecl *isspace)(int C);
// extern int (__cdecl *isupper)(int C);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Destination[64]; // [rsp+20h] [rbp-90h] BYREF
  char Buffer[52]; // [rsp+60h] [rbp-50h] BYREF
  unsigned int v7; // [rsp+94h] [rbp-1Ch]
  int v8; // [rsp+98h] [rbp-18h]
  int i; // [rsp+9Ch] [rbp-14h]
  int v10; // [rsp+A0h] [rbp-10h]
  int v11; // [rsp+A4h] [rbp-Ch]
  int v12; // [rsp+A8h] [rbp-8h]
  int v13; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v7 = 0;
  printf("Enter a string (max length %d): ", 50i64);
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 51, v3);
  v8 = strlen(Buffer);
  strcpy(Destination, Buffer);
  for ( i = 0; i < v8; ++i )
  {
    if ( isupper(Buffer[i]) )
    {
      ++v13;
    }
    else if ( islower(Buffer[i]) )
    {
      ++v12;
    }
    else if ( (unsigned int)(Buffer[i] - 48) > 9 )
    {
      if ( !isspace(Buffer[i]) )
        ++v10;
    }
    else
    {
      ++v11;
    }
  }
  v7 = 6 * v10 + 4 * v11 + 3 * v12 + 5 * v13 + 2 * v8;
  printf("Paranoid Score: %d\n", v7);
  printf("Output String: %s\n", Destination);
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[52];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include<stdio.h>

typedef struct{
	double x,y,z;
}vector;

vector addVectors(vector a,vector b){
	return (vector){a.x+b.x,a.y+b.y,a.z+b.z};
}

vector subVectors(vector a,vector b){
	return (vector){a.x-b.x,a.y-b.y,a.z-b.z};
}

double dotProduct(vector a,vector b){
	return a.x*b.x + a.y*b.y + a.z*b.z;
}

vector scaleVector(double l,vector a){
	return (vector){l*a.x,l*a.y,l*a.z};
}

vector intersectionPoint(vector lineVector, vector linePoint, vector planeNormal, vector planePoint){
	vector diff = subVectors(linePoint,planePoint);
	
	return addVectors(addVectors(diff,planePoint),scaleVector(-dotProduct(diff,planeNormal)/dotProduct(lineVector,planeNormal),lineVector));
}

int main(int argC,char* argV[])
{
	vector lV,lP,pN,pP,iP;
	
	if(argC!=5)
		printf("Usage : %s <line direction, point on line, normal to plane and point on plane given as (x,y,z) tuples separated by space>");
	else{
		sscanf(argV[1],"(%lf,%lf,%lf)",&lV.x,&lV.y,&lV.z);
		sscanf(argV[3],"(%lf,%lf,%lf)",&pN.x,&pN.y,&pN.z);
		
		if(dotProduct(lV,pN)==0)
			printf("Line and Plane do not intersect, either parallel or line is on the plane");
		else{
			sscanf(argV[2],"(%lf,%lf,%lf)",&lP.x,&lP.y,&lP.z);
			sscanf(argV[4],"(%lf,%lf,%lf)",&pP.x,&pP.y,&pP.z);
			
			iP = intersectionPoint(lV,lP,pN,pP);
			
			printf("Intersection point is (%lf,%lf,%lf)",iP.x,iP.y,iP.z);
		}
	}
		
	return 0;
}
`,`#include "find-the-intersection-of-a-line-with-a-plane.h"



undefined  [16]
_addVectors(double param_1,undefined param_2 [16],undefined param_3 [16],double param_4)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 + param_4;
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16]
_subVectors(double param_1,undefined param_2 [16],undefined param_3 [16],double param_4)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 - param_4;
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16]
_dotProduct(undefined8 param_1,double param_2,undefined8 param_3,undefined8 param_4,double param_5,
           undefined8 param_6)

{
  undefined auVar1 [16];
  undefined8 uVar2;
  
  uVar2 = NEON_fmadd(param_1,param_4,param_2 * param_5);
  auVar1._0_8_ = NEON_fmadd(param_3,param_6,uVar2);
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16] _scaleVector(double param_1,double param_2)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 * param_2;
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16]
_intersectionPoint(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                  undefined8 param_5,undefined8 param_6)

{
  undefined8 uVar1;
  undefined8 uVar2;
  double dVar3;
  double dVar4;
  undefined auVar5 [16];
  undefined8 uVar6;
  undefined8 uVar7;
  undefined8 param_9;
  undefined8 param_10;
  undefined8 param_11;
  undefined8 param_12;
  undefined8 param_13;
  undefined8 param_14;
  
  uVar1 = _subVectors(param_4,param_5,param_6,param_12,param_13,param_14);
  uVar6 = param_5;
  uVar7 = param_6;
  uVar2 = _addVectors(uVar1,param_5,param_6,param_12,param_13,param_14);
  dVar3 = (double)_dotProduct(uVar1,param_5,param_6,param_9,param_10,param_11);
  dVar4 = (double)_dotProduct(param_1,param_2,param_3,param_9,param_10,param_11);
  uVar1 = _scaleVector(-dVar3 / dVar4,param_1,param_2,param_3);
  auVar5._0_8_ = _addVectors(uVar2,uVar6,uVar7,uVar1,param_1,param_2);
  auVar5._8_8_ = 0;
  return auVar5;
}



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  double dVar2;
  undefined8 local_78;
  undefined8 local_70;
  undefined8 local_68;
  undefined8 local_60;
  undefined8 local_58;
  undefined8 local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  
  if (param_1 == 5) {
    _sscanf(*(char **)(param_2 + 8),"(%lf,%lf,%lf)");
    iVar1 = _sscanf(*(char **)(param_2 + 0x18),"(%lf,%lf,%lf)");
    dVar2 = (double)_dotProduct(local_48,local_40,local_38,local_78,local_70,local_68,iVar1);
    if (dVar2 == 0.0) {
      _printf("Line and Plane do not intersect, either parallel or line is on the plane");
    }
    else {
      _sscanf(*(char **)(param_2 + 0x10),"(%lf,%lf,%lf)");
      iVar1 = _sscanf(*(char **)(param_2 + 0x20),"(%lf,%lf,%lf)");
      _intersectionPoint(local_48,local_40,local_38,local_60,local_58,local_50,iVar1);
      _printf("Intersection point is (%lf,%lf,%lf)");
    }
  }
  else {
    _printf(
           "Usage : %s <line direction, point on line, normal to plane and point on plane given as (x,y,z) tuples separated by space>"
           );
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _sscanf(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__sscanf_100004008)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Fractal Generation ; Style: curious
#include <stdio.h>
#include <math.h>

int main() {
    int resolution = 512;
    double zoom = 1.0;
    double x_center = -0.5;
    double y_center = 0.0;

    int max_iter = 1024;
    int x, y, n;
    double cx, cy, zx, zy, temp;

    // Creating the image array
    int image[resolution][resolution];
    for (y = 0; y < resolution; y++) {
        for (x = 0; x < resolution; x++) {
            image[y][x] = 0;
        }
    }

    // Main loop through all the pixels
    for (y = 0; y < resolution; y++) {
        for (x = 0; x < resolution; x++) {
            cx = (x - resolution / 2.0) * (4.0/(double)resolution) / zoom + x_center;
            cy = (y - resolution / 2.0) * (4.0/(double)resolution) / zoom + y_center;
            zx = 0.0;
            zy = 0.0;
            n = 0;
            while (zx * zx + zy * zy < 4 && n < max_iter) {
                temp = zx * zx - zy * zy + cx;
                zy = 2 * zx * zy + cy;
                zx = temp;
                n++;
            }
            image[y][x] = n % 256;
        }
    }

    // Printing the image array to a PGM file
    FILE *fp = fopen("fractal.pgm", "wb");
    fprintf(fp, "P5\n%d %d\n255\n", resolution, resolution);
    for (y = 0; y < resolution; y++) {
        for (x = 0; x < resolution; x++) {
            fputc(image[y][x], fp);
        }
    }
    fclose(fp);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fprintf_0(FILE *const Stream, const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl fputc(int Character, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001583) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  __int64 v5; // [rsp+0h] [rbp-D0h] BYREF
  char v6; // [rsp+20h] [rbp-B0h] BYREF
  __int64 *v7; // [rsp+28h] [rbp-A8h]
  __int64 v8; // [rsp+30h] [rbp-A0h]
  __int64 v9; // [rsp+38h] [rbp-98h]
  __int64 v10; // [rsp+40h] [rbp-90h]
  __int64 v11; // [rsp+48h] [rbp-88h]
  double v12; // [rsp+50h] [rbp-80h]
  double v13; // [rsp+58h] [rbp-78h]
  double v14; // [rsp+60h] [rbp-70h]
  FILE *Stream; // [rsp+68h] [rbp-68h]
  char *v16; // [rsp+70h] [rbp-60h]
  __int64 v17; // [rsp+78h] [rbp-58h]
  __int64 v18; // [rsp+80h] [rbp-50h]
  int v19; // [rsp+8Ch] [rbp-44h]
  double v20; // [rsp+90h] [rbp-40h]
  double v21; // [rsp+98h] [rbp-38h]
  double v22; // [rsp+A0h] [rbp-30h]
  int v23; // [rsp+ACh] [rbp-24h]
  double v24; // [rsp+B0h] [rbp-20h]
  double v25; // [rsp+B8h] [rbp-18h]
  int k; // [rsp+C4h] [rbp-Ch]
  int i; // [rsp+C8h] [rbp-8h]
  int j; // [rsp+CCh] [rbp-4h]

  _main(argc, argv, envp);
  v7 = &v5;
  v23 = 512;
  v22 = 1.0;
  v21 = -0.5;
  v20 = 0.0;
  v19 = 1024;
  v18 = 511i64;
  v8 = 512i64;
  v9 = 0i64;
  v17 = 511i64;
  v10 = 512i64;
  v11 = 0i64;
  v3 = alloca(0x100000i64);
  v16 = &v6;
  for ( i = 0; i < v23; ++i )
  {
    for ( j = 0; j < v23; ++j )
      *(_DWORD *)&v16[2048 * (__int64)i + 4 * j] = 0;
  }
  for ( i = 0; i < v23; ++i )
  {
    for ( j = 0; j < v23; ++j )
    {
      v14 = 4.0 / (double)v23 * ((double)j - (double)v23 / 2.0) / v22 + v21;
      v13 = 4.0 / (double)v23 * ((double)i - (double)v23 / 2.0) / v22 + v20;
      v25 = 0.0;
      v24 = 0.0;
      for ( k = 0; v25 * v25 + v24 * v24 < 4.0 && k < v19; ++k )
      {
        v12 = v25 * v25 - v24 * v24 + v14;
        v24 = (v25 + v25) * v24 + v13;
        v25 = v12;
      }
      *(_DWORD *)&v16[2048 * (__int64)i + 4 * j] = k % 256;
    }
  }
  Stream = fopen("fractal.pgm", "wb");
  fprintf_0(Stream, "P5\n%d %d\n255\n", (unsigned int)v23, (unsigned int)v23);
  for ( i = 0; i < v23; ++i )
  {
    for ( j = 0; j < v23; ++j )
      fputc(*(_DWORD *)&v16[2048 * (__int64)i + 4 * j], Stream);
  }
  fclose(Stream);
  return 0;
}
// 140001A50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
` #include <stdio.h>

/**
 * description : Counts the number of bits set to 1
 *        input: the number to have its bit counted
 *       output: the number of bits set to 1
 */
unsigned count_bits(unsigned v) {
    unsigned c = 0;
    while (v) {
        c += v & 1;
        v >>= 1;
    }

    return c;
}

int main(void) {
    /*          i: loop iterator
     *     length: the length of the sequence to be printed
     * ascii_base: the lower char for use when printing
     */
    unsigned i, length = 0;
    int ascii_base;


    /* scan in sequence length */
    printf("Sequence length: ");
    do {
        scanf("%u", &length);
    } while (length == 0);


    /* scan in sequence mode */
    printf("(a)lpha or (b)inary: ");
    do {
        ascii_base = getchar();
    } while ((ascii_base != 'a') && (ascii_base != 'b'));
    ascii_base = ascii_base == 'b' ? '0' : 'A';


    /* print the Thue-Morse sequence */
    for (i = 0; i < length; ++i) {
        putchar(ascii_base + count_bits(i) % 2);
    }
    putchar('\n');

    return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003da8(void);
int32_t function_100003f44(void);
int32_t function_100003f50(char * format, ...);
int32_t function_100003f5c(int32_t c);
int32_t function_100003f68(char * format, ...);

// ------- Dynamically Linked Functions Without Header --------

int32_t _getchar(void);
int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);
int32_t _scanf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003da8 - 0x100003dfc
int64_t function_100003da8(void) {
    // 0x100003da8
    int64_t v1; // 0x100003da8
    int32_t v2 = v1; // 0x100003dac
    uint32_t v3 = v2; // 0x100003dc4
    if (v2 == 0) {
        // 0x100003df0
        return 0;
    }
    int32_t result = 0; // 0x100003dc4
    result += v3 % 2;
    while (v3 >= 2) {
        // 0x100003dcc
        v3 /= 2;
        result += v3 % 2;
    }
    // 0x100003df0
    return result;
}

// Address range: 0x100003dfc - 0x100003f44
int64_t entry_point(void) {
    // 0x100003dfc
    _printf("Sequence length: ");
    while (true) {
        // 0x100003e20
        int64_t v1; // 0x100003dfc
        _scanf("%u", (int32_t *)v1);
    }
}

// Address range: 0x100003f44 - 0x100003f50
int32_t function_100003f44(void) {
    // 0x100003f44
    return _getchar();
}

// Address range: 0x100003f50 - 0x100003f5c
int32_t function_100003f50(char * format, ...) {
    // 0x100003f50
    return _printf(format);
}

// Address range: 0x100003f5c - 0x100003f68
int32_t function_100003f5c(int32_t c) {
    // 0x100003f5c
    return _putchar(c);
}

// Address range: 0x100003f68 - 0x100003f74
int32_t function_100003f68(char * format, ...) {
    // 0x100003f68
    return _scanf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 6

`
`//FormAI DATASET v1.0 Category: Scientific ; Style: sophisticated
#include <stdio.h>
#include <math.h>

int main() {
  int num, power;
  double result;

  printf("Enter a number: ");
  scanf("%d", &num);

  printf("Enter a power: ");
  scanf("%d", &power);

  result = pow(num, power);

  printf("%d raised to the power of %d is %lf\n", num, power, result);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v5; // [rsp+24h] [rbp-Ch] BYREF
  double v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a number: ");
  scanf("%d", &v5);
  printf("Enter a power: ");
  scanf("%d", &v4);
  v6 = pow((double)(int)v5, (double)(int)v4);
  printf("%d raised to the power of %d is %lf\n", v5, v4, v6);
  return 0;
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>

int main()
{
	printf("\033[7mReversed\033[m Normal\n");

	return 0;
}
`,`#include "terminal-control-inverse-video.h"



undefined4 entry(void)

{
  _printf("\x1b[7mReversed\x1b[m Normal\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: multivariable
#include <stdio.h>
#include <math.h>

#define G 6.67408E-11 // Gravitational constant
#define TIME_STEP 10 // Time step in seconds

// Structure to store vector components
typedef struct {
    double x;
    double y;
    double z;
} Vector;

// Structure to store planet properties
typedef struct {
    char name[20];
    double mass;
    Vector position;
    Vector velocity;
} Planet;

// Function to calculate distance between two planets
double distance(Planet p1, Planet p2) {
    double dx = p1.position.x - p2.position.x;
    double dy = p1.position.y - p2.position.y;
    double dz = p1.position.z - p2.position.z;
    return sqrt(dx*dx + dy*dy + dz*dz);
}

// Function to calculate gravitational force between two planets
Vector gravity(Planet p1, Planet p2) {
    double r = distance(p1, p2);
    double f = (G * p1.mass * p2.mass) / (r*r);
    Vector dir = {p2.position.x - p1.position.x, p2.position.y - p1.position.y, p2.position.z - p1.position.z};
    double mag = sqrt(dir.x*dir.x + dir.y*dir.y + dir.z*dir.z);
    dir.x /= mag;
    dir.y /= mag;
    dir.z /= mag;
    Vector force = {dir.x * f, dir.y * f, dir.z * f};
    return force;
}

// Function to update planet position and velocity based on gravitational forces
void update(Planet *p, Planet *planets, int n) {
    Vector net_force = {0.0, 0.0, 0.0};
    for (int i = 0; i < n; i++) {
        if (p != &planets[i]) {
            net_force.x += gravity(*p, planets[i]).x;
            net_force.y += gravity(*p, planets[i]).y;
            net_force.z += gravity(*p, planets[i]).z;
        }
    }
    double ax = net_force.x / p->mass;
    double ay = net_force.y / p->mass;
    double az = net_force.z / p->mass;
    p->velocity.x += ax * TIME_STEP;
    p->velocity.y += ay * TIME_STEP;
    p->velocity.z += az * TIME_STEP;
    p->position.x += p->velocity.x * TIME_STEP;
    p->position.y += p->velocity.y * TIME_STEP;
    p->position.z += p->velocity.z * TIME_STEP;
}

int main() {
    // Define planets
    Planet sun = {"Sun", 1.989E+30, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
    Planet earth = {"Earth", 5.97E+24, {1.4710E+11, 0.0, 0.0}, {0.0, 30290.0, 0.0}};
    Planet mars = {"Mars", 6.39E+23, {0.0, 2.279E+11, 0.0}, {-24007.0, 0.0, 0.0}};
    Planet venus = {"Venus", 4.87E+24, {-1.0758E+11, 0.0, 0.0}, {0.0, -35020.0, 0.0}};
    Planet planets[4] = {sun, earth, mars, venus};
    int n = 4;

    // Run simulation for 1 year
    int seconds_in_year = 365*24*60*60;
    int steps = seconds_in_year / TIME_STEP; 
    for (int i = 0; i < steps; i++) {
        for (int j = 0; j < n; j++) {
            update(&planets[j], planets, n);
        }
    }

    // Print final positions of planets
    for (int i = 0; i < n; i++) {
        printf("%s position: %.2f, %.2f, %.2f\n", planets[i].name, planets[i].position.x, planets[i].position.y, planets[i].position.z);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall update(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001D63) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[10]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v5[32]; // [rsp+80h] [rbp+0h] BYREF
  __int64 v6; // [rsp+180h] [rbp+100h]
  __int64 v7; // [rsp+188h] [rbp+108h]
  __int64 v8; // [rsp+190h] [rbp+110h]
  __int64 v9; // [rsp+198h] [rbp+118h]
  __int64 v10; // [rsp+1A0h] [rbp+120h]
  __int64 v11; // [rsp+1A8h] [rbp+128h]
  __int64 v12; // [rsp+1B0h] [rbp+130h]
  __int64 v13; // [rsp+1B8h] [rbp+138h]
  __int64 v14; // [rsp+1C0h] [rbp+140h]
  __int64 v15; // [rsp+1C8h] [rbp+148h]
  __int64 v16; // [rsp+1D0h] [rbp+150h]
  __int64 v17; // [rsp+1D8h] [rbp+158h]
  __int64 v18; // [rsp+1E0h] [rbp+160h]
  __int64 v19; // [rsp+1E8h] [rbp+168h]
  __int64 v20; // [rsp+1F0h] [rbp+170h]
  __int64 v21; // [rsp+1F8h] [rbp+178h]
  __int64 v22; // [rsp+200h] [rbp+180h]
  __int64 v23; // [rsp+208h] [rbp+188h]
  __int64 v24; // [rsp+210h] [rbp+190h]
  __int64 v25; // [rsp+218h] [rbp+198h]
  __int64 v26; // [rsp+220h] [rbp+1A0h]
  __int64 v27; // [rsp+228h] [rbp+1A8h]
  __int64 v28; // [rsp+230h] [rbp+1B0h]
  __int64 v29; // [rsp+238h] [rbp+1B8h]
  __int64 v30; // [rsp+240h] [rbp+1C0h]
  __int64 v31; // [rsp+248h] [rbp+1C8h]
  __int64 v32; // [rsp+250h] [rbp+1D0h]
  __int64 v33; // [rsp+258h] [rbp+1D8h]
  __int64 v34; // [rsp+260h] [rbp+1E0h]
  __int64 v35; // [rsp+268h] [rbp+1E8h]
  __int64 v36; // [rsp+270h] [rbp+1F0h]
  __int64 v37; // [rsp+278h] [rbp+1F8h]
  __int64 v38; // [rsp+280h] [rbp+200h]
  __int64 v39; // [rsp+288h] [rbp+208h]
  __int64 v40; // [rsp+290h] [rbp+210h]
  __int64 v41; // [rsp+298h] [rbp+218h]
  __int64 v42; // [rsp+2A0h] [rbp+220h]
  __int64 v43; // [rsp+2A8h] [rbp+228h]
  int v44; // [rsp+2B8h] [rbp+238h]
  int v45; // [rsp+2BCh] [rbp+23Ch]
  int v46; // [rsp+2C0h] [rbp+240h]
  int k; // [rsp+2C4h] [rbp+244h]
  int j; // [rsp+2C8h] [rbp+248h]
  int i; // [rsp+2CCh] [rbp+24Ch]

  _main(argc, argv, envp);
  v34 = 7238995i64;
  v35 = 0i64;
  LODWORD(v36) = 0;
  v37 = 0x46391ACE3D05AEF4i64;
  v38 = 0i64;
  v39 = 0i64;
  v40 = 0i64;
  v41 = 0i64;
  v42 = 0i64;
  v43 = 0i64;
  v24 = 0x6874726145i64;
  v25 = 0i64;
  LODWORD(v26) = 0;
  v27 = 0x4513C0C964D9C187i64;
  v28 = 0x42411FEBEF800000i64;
  v29 = 0i64;
  v30 = 0i64;
  v31 = 0i64;
  v32 = 0x40DD948000000000i64;
  v33 = 0i64;
  v14 = 1936875853i64;
  v15 = 0i64;
  LODWORD(v16) = 0;
  v17 = 0x44E0EA084D181CD6i64;
  v18 = 0i64;
  v19 = 0x424A87F303800000i64;
  v20 = 0i64;
  v21 = 0xC0D771C000000000ui64;
  v22 = 0i64;
  v23 = 0i64;
  v5[30] = 0x73756E6556i64;
  v5[31] = 0i64;
  LODWORD(v6) = 0;
  v7 = 0x45101D0CEA7F08A4i64;
  v8 = 0xC2390C4487000000ui64;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0xC0E1198000000000ui64;
  v13 = 0i64;
  v4[0] = 7238995i64;
  v4[1] = 0i64;
  v4[2] = v36;
  v4[3] = 0x46391ACE3D05AEF4i64;
  memset(&v4[4], 0, 48);
  v5[0] = 0x6874726145i64;
  v5[1] = 0i64;
  v5[2] = v26;
  v5[3] = 0x4513C0C964D9C187i64;
  v5[4] = 0x42411FEBEF800000i64;
  memset(&v5[5], 0, 24);
  v5[8] = 0x40DD948000000000i64;
  v5[9] = 0i64;
  v5[10] = 1936875853i64;
  v5[11] = 0i64;
  v5[12] = v16;
  v5[13] = 0x44E0EA084D181CD6i64;
  v5[14] = 0i64;
  v5[15] = 0x424A87F303800000i64;
  v5[16] = 0i64;
  v5[17] = 0xC0D771C000000000ui64;
  v5[18] = 0i64;
  v5[19] = 0i64;
  v5[20] = 0x73756E6556i64;
  v5[21] = 0i64;
  v5[22] = v6;
  v5[23] = 0x45101D0CEA7F08A4i64;
  v5[24] = 0xC2390C4487000000ui64;
  memset(&v5[25], 0, 24);
  v5[28] = 0xC0E1198000000000ui64;
  v5[29] = 0i64;
  v46 = 4;
  v45 = 31536000;
  v44 = 3153600;
  for ( i = 0; i < v44; ++i )
  {
    for ( j = 0; j < v46; ++j )
      update(&v4[10 * j], v4, (unsigned int)v46);
  }
  for ( k = 0; k < v46; ++k )
    printf(
      "%s position: %.2f, %.2f, %.2f\n",
      (const char *)&v4[10 * k],
      *(double *)&v5[10 * k - 6],
      *(double *)&v5[10 * k - 5],
      *(double *)&v5[10 * k - 4]);
  return 0;
}
// 14000184D: using guessed type __int64 __fastcall update(_QWORD, _QWORD, _QWORD);
// 1400023E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: authentic
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 10 // the maximum size of the array

/* function to swap two elements in an array */
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

/* function to perform bubble sort */
void bubble_sort(int arr[], int n) {
    for(int i=0;i<n-1;i++) {
        for(int j=0;j<n-i-1;j++) {
            if(arr[j] > arr[j+1]) {
                swap(&arr[j], &arr[j+1]);
            }
        }
    }
}

/* function to perform selection sort */
void selection_sort(int arr[], int n) {
    int min_idx;
    for(int i=0;i<n-1;i++) {
        min_idx = i;
        for(int j=i+1;j<n;j++) {
            if(arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        swap(&arr[i], &arr[min_idx]);
    }
}

/* function to perform insertion sort */
void insertion_sort(int arr[], int n) {
    int key, j;
    for(int i=1;i<n;i++) {
        key = arr[i];
        j = i - 1;
        while(j >= 0 && arr[j] > key) {
            arr[j+1] = arr[j];
            j = j - 1;
        }
        arr[j+1] = key;
    }
}

int main() {
    int arr[MAX_SIZE], n, choice;
    printf("Enter the size of the array (maximum 10): ");
    scanf("%d", &n);
    printf("Enter the elements of the array: ");
    for(int i=0;i<n;i++) {
        scanf("%d", &arr[i]);
    }
    printf("Enter your choice of sorting algorithm:\n");
    printf("1. Bubble Sort\n");
    printf("2. Selection Sort\n");
    printf("3. Insertion Sort\n");
    printf("Your choice: ");
    scanf("%d", &choice);
    switch(choice) {
        case 1:
            bubble_sort(arr, n);
            printf("Sorted array using Bubble Sort: ");
            break;
        case 2:
            selection_sort(arr, n);
            printf("Sorted array using Selection Sort: ");
            break;
        case 3:
            insertion_sort(arr, n);
            printf("Sorted array using Insertion Sort: ");
            break;
        default:
            printf("Invalid choice.\n");
            exit(0);
    }
    for(int i=0;i<n;i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall bubble_sort(_QWORD, _QWORD); // weak
__int64 __fastcall selection_sort(_QWORD, _QWORD); // weak
__int64 __fastcall insertion_sort(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001853) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-38h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-34h] BYREF
  int v6[10]; // [rsp+30h] [rbp-30h] BYREF
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the size of the array (maximum 10): ");
  scanf("%d", &v5);
  printf("Enter the elements of the array: ");
  for ( i = 0; i < (int)v5; ++i )
    scanf("%d", &v6[i]);
  printf("Enter your choice of sorting algorithm:\n");
  printf("1. Bubble Sort\n");
  printf("2. Selection Sort\n");
  printf("3. Insertion Sort\n");
  printf("Your choice: ");
  scanf("%d", &v4);
  if ( v4 == 3 )
  {
    insertion_sort(v6, v5);
    printf("Sorted array using Insertion Sort: ");
  }
  else
  {
    if ( v4 > 3 )
      goto LABEL_12;
    if ( v4 == 1 )
    {
      bubble_sort(v6, v5);
      printf("Sorted array using Bubble Sort: ");
    }
    else
    {
      if ( v4 != 2 )
      {
LABEL_12:
        printf("Invalid choice.\n");
        exit(0);
      }
      selection_sort(v6, v5);
      printf("Sorted array using Selection Sort: ");
    }
  }
  for ( j = 0; j < (int)v5; ++j )
    printf("%d ", (unsigned int)v6[j]);
  printf("\n");
  return 0;
}
// 140001617: using guessed type __int64 __fastcall bubble_sort(_QWORD, _QWORD);
// 1400016D0: using guessed type __int64 __fastcall selection_sort(_QWORD, _QWORD);
// 140001789: using guessed type __int64 __fastcall insertion_sort(_QWORD, _QWORD);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001853: using guessed type int var_30[10];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>

#define JOBS 12
#define jobs(a) for (switch_to(a = 0); a < JOBS || !printf("\n"); switch_to(++a))
typedef struct { int seq, cnt; } env_t;

env_t env[JOBS] = {{0, 0}};
int *seq, *cnt;

void hail()
{
	printf("% 4d", *seq);
	if (*seq == 1) return;
	++*cnt;
	*seq = (*seq & 1) ? 3 * *seq + 1 : *seq / 2;
}

void switch_to(int id)
{
	seq = &env[id].seq;
	cnt = &env[id].cnt;
}

int main()
{
	int i;
	jobs(i) { env[i].seq = i + 1; }

again:	jobs(i) { hail(); }
	jobs(i) { if (1 != *seq) goto again; }

	printf("COUNTS:\n");
	jobs(i) { printf("% 4d", *cnt); }

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003bf4(void);
int64_t function_100003cec(void);
int32_t function_100003f84(char * format, ...);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)0x100000cfeedfacf; // 0x100008000
int32_t * g2 = NULL; // 0x100008060
int32_t * g3 = (int32_t *)0x18800000019; // 0x100008068

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003bf4 - 0x100003cec
int64_t function_100003bf4(void) {
    // 0x100003bf4
    int64_t v1; // 0x100003bf4
    int32_t result = _printf("% 4d", v1); // 0x100003c28
    if (*g3 != 1) {
        int32_t * v2 = g2; // 0x100003c54
        *v2 = *v2 + 1;
        uint32_t v3 = *g3; // 0x100003c70
        *g3 = v3 % 2 == 0 ? v3 / 2 : 3 * v3 + 1;
    }
    // 0x100003ce0
    return result;
}

// Address range: 0x100003cec - 0x100003d34
int64_t function_100003cec(void) {
    // 0x100003cec
    int64_t result; // 0x100003cec
    int64_t v1 = 0x100000000 * result >> 29; // 0x100003d04
    *(int64_t *)&g3 = v1 + (int64_t)&g1;
    *(int64_t *)&g2 = v1 + (int64_t)&g1 + 4;
    return result;
}

// Address range: 0x100003d34 - 0x100003f84
int64_t entry_point(void) {
    // 0x100003d34
    function_100003cec();
    int32_t v1 = 0; // 0x100003d50
    while (true) {
        int32_t v2 = v1;
        if (v2 < 12 == (11 - v2 & v2) < 0) {
            // 0x100003d8c
            if (_printf("\n") != 0) {
                // break -> 0x100003dd0
                break;
            }
        }
        // 0x100003d98
        v1 = v2 + 1;
        *(int32_t *)(8 * (int64_t)v2 + (int64_t)&g1) = v1;
        function_100003cec();
    }
    while (true) {
        // 0x100003dd0
        function_100003cec();
    }
  lab_0x100003ed4:
    // 0x100003ed4
    _printf("COUNTS:\n");
    function_100003cec();
    int32_t v3 = 0; // 0x100003eec
    while (true) {
        int32_t v4 = v3;
        if (v4 < 12 == (11 - v4 & v4) < 0) {
            // 0x100003f28
            if (_printf("\n") != 0) {
                // break -> 0x100003f74
                break;
            }
        }
        // 0x100003f34
        int64_t v5; // 0x100003d34
        _printf("% 4d", v5);
        function_100003cec();
        v3 = v4 + 1;
    }
    // 0x100003f74
    return 0;
}

// Address range: 0x100003f84 - 0x100003f90
int32_t function_100003f84(char * format, ...) {
    // 0x100003f84
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef __GNUC__
#include <setjmp.h>
struct LOOP_T; typedef struct LOOP_T LOOP;
struct LOOP_T {
    jmp_buf b; LOOP * p;
} LOOP_base, * LOOP_V = &LOOP_base;
#define FOR(I, C, A, ACT) (LOOP_V = &(LOOP){ .p = LOOP_V }, \
                           (I), setjmp(LOOP_V->b), \
                           ((C) ? ((ACT),(A), longjmp(LOOP_V->b, 1), 0) : 0), \
                           LOOP_V = LOOP_V->p, 0)
#else
#define FOR(I, C, A, ACT) (({for(I;C;A){ACT;}}), 0)    // GNU version
#endif

typedef struct List { struct List * nx; char val[]; } List;
typedef struct { int _1, _2, _3; } Triple;

#define SEQ(OUT, SETS, PRED) (SEQ_var=&(ITERATOR){.l=NULL,.p=SEQ_var}, \
                              M_FFOLD(((PRED)?APPEND(OUT):0),M_ID SETS), \
                              SEQ_var->p->old=SEQ_var->l,SEQ_var=SEQ_var->p,SEQ_var->old)
typedef struct ITERATOR { List * l, * old; struct ITERATOR * p; } ITERATOR;
ITERATOR * FE_var, SEQ_base, * SEQ_var = &SEQ_base;
#define FOR_EACH(V, T, L, ACT) (FE_var=&(ITERATOR){.l=(L),.p=FE_var}, \
                                FOR((V) = *(T*)&FE_var->l->val, FE_var->l?((V)=*(T*)&FE_var->l->val,1):0, \
                                FE_var->l=FE_var->l->nx, ACT), FE_var=FE_var->p)

#define M_FFOLD(ID, ...) M_ID(M_CONC(M_FFOLD_, M_NARGS(__VA_ARGS__)) (ID, __VA_ARGS__))
#define FORSET(V, T, L) V, T, L
#define APPEND(T, val) (SEQ_var->l?listAppend(SEQ_var->l,sizeof(T),&val):(SEQ_var->l=listNew(sizeof(T),&val)))

#define M_FFOLD_1(ID, E) FOR_EACH M_IDP(FORSET E, ID)
#define M_FFOLD_2(ID, E, ...) FOR_EACH M_IDP(FORSET E, M_FFOLD_1(ID, __VA_ARGS__))
#define M_FFOLD_3(ID, E, ...) FOR_EACH M_IDP(FORSET E, M_FFOLD_2(ID, __VA_ARGS__))  //...

#define M_NARGS(...) M_NARGS_(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
#define M_NARGS_(_10, _9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) N
#define M_CONC(A, B) M_CONC_(A, B)
#define M_CONC_(A, B) A##B
#define M_ID(...) __VA_ARGS__
#define M_IDP(...) (__VA_ARGS__)

#define R(f, t) int,intRangeList(f, t)
#define T(a, b, c) Triple,((Triple){(a),(b),(c)})

List * listNew(int sz, void * val) {
 List * l = malloc(sizeof(List) + sz); l->nx = NULL; memcpy(l->val, val, sz); return l;
}
List * listAppend(List * l, int sz, void * val) {
 while (l->nx) { l = l->nx; } l->nx = listNew(sz, val); return l;
}
List * intRangeList(int f, int t) {
 List * l = listNew(sizeof f, &f), * e = l;
 for (int i = f + 1; i <= t; i ++) { e = e->nx = listNew(sizeof i, &i); } // C11 compliant
//int i;
//for (i = f + 1; i <= t; i ++) { e = e->nx = listNew(sizeof i, &i); }    // use this for C99
 return l;
}

int main(void) {
    volatile int x, y, z; const int n = 20;

    List * pTriples = SEQ(
                          T(x, y, z),
                          (
                           (x, R(1, n)),
                           (y, R(x, n)),
                           (z, R(y, n))
                          ),
                          (x*x + y*y == z*z)
                         );

    volatile Triple t;
    FOR_EACH(t, Triple, pTriples,  printf("%d, %d, %d\n", t._1, t._2, t._3)  );

    return 0;
}
`,`#include "list-comprehensions.h"



undefined8 * _listNew(int param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc((long)param_1 + 8);
  *puVar1 = 0;
  ___memcpy_chk(puVar1 + 1,param_2,(long)param_1,0xffffffffffffffff);
  return puVar1;
}



long * _listAppend(long *param_1,undefined4 param_2,undefined8 param_3)

{
  long lVar1;
  undefined8 local_18;
  
  for (local_18 = param_1; *local_18 != 0; local_18 = (long *)*local_18) {
  }
  lVar1 = _listNew(param_2,param_3);
  *local_18 = lVar1;
  return local_18;
}



undefined8 * _intRangeList(int param_1,int param_2)

{
  undefined8 *puVar1;
  int local_2c;
  undefined8 *local_28;
  undefined8 *local_20;
  int local_18;
  int local_14;
  
  local_18 = param_2;
  local_14 = param_1;
  local_20 = (undefined8 *)_listNew(4,&local_14);
  local_28 = local_20;
  local_2c = local_14;
  while (local_2c = local_2c + 1, local_2c <= local_18) {
    puVar1 = (undefined8 *)_listNew(4,&local_2c);
    *local_28 = puVar1;
    local_28 = puVar1;
  }
  return local_20;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

undefined8 entry(void)

{
  undefined8 uVar1;
  long local_e0 [2];
  long *local_d0;
  undefined local_c4 [12];
  int local_b8;
  int local_b4;
  int local_b0;
  int local_ac;
  int local_a8;
  int local_a4;
  long local_a0 [2];
  long *local_90;
  long local_88 [2];
  long *local_78;
  long local_70 [2];
  long *local_60;
  undefined8 local_58;
  undefined8 local_50;
  undefined *local_48;
  long local_40;
  undefined4 local_34;
  int local_30;
  int local_2c;
  int local_28;
  undefined4 local_24;
  
  local_24 = 0;
  local_34 = 0x14;
  local_58 = 0;
  local_50 = 0;
  local_48 = _SEQ_var;
  _SEQ_var = (undefined *)&local_58;
  local_70[0] = _intRangeList(1);
  local_70[1] = 0;
  local_60 = _FE_var;
  local_28 = *(int *)(local_70[0] + 8);
  _FE_var = local_70;
  while (*_FE_var != 0) {
    local_28 = *(int *)(*_FE_var + 8);
    local_88[0] = _intRangeList(local_28,0x14);
    local_88[1] = 0;
    local_78 = _FE_var;
    local_2c = *(int *)(local_88[0] + 8);
    _FE_var = local_88;
    while (*_FE_var != 0) {
      local_2c = *(int *)(*_FE_var + 8);
      local_a0[0] = _intRangeList(local_2c,0x14);
      local_a0[1] = 0;
      local_90 = _FE_var;
      local_30 = *(int *)(local_a0[0] + 8);
      _FE_var = local_a0;
      while (*_FE_var != 0) {
        local_30 = *(int *)(*_FE_var + 8);
        if (local_28 * local_28 + local_2c * local_2c == local_30 * local_30) {
          if (*(long *)_SEQ_var == 0) {
            local_b8 = local_28;
            local_b4 = local_2c;
            local_b0 = local_30;
            uVar1 = _listNew(0xc,&local_b8);
            *(undefined8 *)_SEQ_var = uVar1;
          }
          else {
            local_ac = local_28;
            local_a8 = local_2c;
            local_a4 = local_30;
            _listAppend(*(undefined8 *)_SEQ_var,0xc,&local_ac);
          }
        }
        *_FE_var = *(long *)*_FE_var;
      }
      _FE_var = (long *)_FE_var[2];
      *_FE_var = *(long *)*_FE_var;
    }
    _FE_var = (long *)_FE_var[2];
    *_FE_var = *(long *)*_FE_var;
  }
  _FE_var = (long *)_FE_var[2];
  *(undefined8 *)(*(long *)(_SEQ_var + 0x10) + 8) = *(undefined8 *)_SEQ_var;
  _SEQ_var = *(undefined **)(_SEQ_var + 0x10);
  local_e0[0] = *(long *)(_SEQ_var + 8);
  local_e0[1] = 0;
  local_d0 = _FE_var;
  _FE_var = local_e0;
  local_40 = local_e0[0];
  _memcpy(local_c4,(void *)(local_e0[0] + 8),0xc);
  while (*_FE_var != 0) {
    _memcpy(local_c4,(void *)(*_FE_var + 8),0xc);
    _printf("%d, %d, %d\n");
    *_FE_var = *(long *)*_FE_var;
  }
  _FE_var = (long *)_FE_var[2];
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

void reverse(char *p) {
    size_t len = strlen(p);
    char *r = p + len - 1;
    while (p < r) {
        *p ^= *r;
        *r ^= *p;
        *p++ ^= *r--;
    }
}

void to_bt(int n, char *b) {
    static char d[] = { '0', '+', '-' };
    static int v[] = { 0, 1, -1 };

    char *ptr = b;
    *ptr = 0;

    while (n) {
        int r = n % 3;
        if (r < 0) {
            r += 3;
        }

        *ptr = d[r];
        *(++ptr) = 0;

        n -= v[r];
        n /= 3;
    }

    reverse(b);
}

int from_bt(const char *a) {
    int n = 0;

    while (*a != '\0') {
        n *= 3;
        if (*a == '+') {
            n++;
        } else if (*a == '-') {
            n--;
        }
        a++;
    }

    return n;
}

char last_char(char *ptr) {
    char c;

    if (ptr == NULL || *ptr == '\0') {
        return '\0';
    }

    while (*ptr != '\0') {
        ptr++;
    }
    ptr--;

    c = *ptr;
    *ptr = 0;
    return c;
}

void add(const char *b1, const char *b2, char *out) {
    if (*b1 != '\0' && *b2 != '\0') {
        char c1[16];
        char c2[16];
        char ob1[16];
        char ob2[16];
        char d[3] = { 0, 0, 0 };
        char L1, L2;

        strcpy(c1, b1);
        strcpy(c2, b2);
        L1 = last_char(c1);
        L2 = last_char(c2);
        if (L2 < L1) {
            L2 ^= L1;
            L1 ^= L2;
            L2 ^= L1;
        }

        if (L1 == '-') {
            if (L2 == '0') {
                d[0] = '-';
            }
            if (L2 == '-') {
                d[0] = '+';
                d[1] = '-';
            }
        }
        if (L1 == '+') {
            if (L2 == '0') {
                d[0] = '+';
            }
            if (L2 == '-') {
                d[0] = '0';
            }
            if (L2 == '+') {
                d[0] = '-';
                d[1] = '+';
            }
        }
        if (L1 == '0') {
            if (L2 == '0') {
                d[0] = '0';
            }
        }

        add(c1, &d[1], ob1);
        add(ob1, c2, ob2);
        strcpy(out, ob2);

        d[1] = 0;
        strcat(out, d);
    } else if (*b1 != '\0') {
        strcpy(out, b1);
    } else if (*b2 != '\0') {
        strcpy(out, b2);
    } else {
        *out = '\0';
    }
}

void unary_minus(const char *b, char *out) {
    while (*b != '\0') {
        if (*b == '-') {
            *out++ = '+';
            b++;
        } else if (*b == '+') {
            *out++ = '-';
            b++;
        } else {
            *out++ = *b++;
        }
    }
    *out = '\0';
}

void subtract(const char *b1, const char *b2, char *out) {
    char buf[16];
    unary_minus(b2, buf);
    add(b1, buf, out);
}

void mult(const char *b1, const char *b2, char *out) {
    char r[16] = "0";
    char t[16];
    char c1[16];
    char c2[16];
    char *ptr = c2;

    strcpy(c1, b1);
    strcpy(c2, b2);

    reverse(c2);

    while (*ptr != '\0') {
        if (*ptr == '+') {
            add(r, c1, t);
            strcpy(r, t);
        }
        if (*ptr == '-') {
            subtract(r, c1, t);
            strcpy(r, t);
        }
        strcat(c1, "0");

        ptr++;
    }

    ptr = r;
    while (*ptr == '0') {
        ptr++;
    }
    strcpy(out, ptr);
}

int main() {
    const char *a = "+-0++0+";
    char b[16];
    const char *c = "+-++-";
    char t[16];
    char d[16];

    to_bt(-436, b);
    subtract(b, c, t);
    mult(a, t, d);

    printf("      a: %14s %10d\n", a, from_bt(a));
    printf("      b: %14s %10d\n", b, from_bt(b));
    printf("      c: %14s %10d\n", c, from_bt(c));
    printf("a*(b-c): %14s %10d\n", d, from_bt(d));

    return 0;
}
`,`#include "balanced-ternary.h"



void _reverse(byte *param_1)

{
  size_t sVar1;
  byte *local_28;
  byte *local_18;
  
  sVar1 = _strlen((char *)param_1);
  local_28 = param_1 + sVar1;
  local_18 = param_1;
  while (local_28 = local_28 + -1, local_18 < local_28) {
    *local_18 = *local_18 ^ *local_28;
    *local_28 = *local_28 ^ *local_18;
    *local_18 = *local_18 ^ *local_28;
    local_18 = local_18 + 1;
  }
  return;
}



void _to_bt(int param_1,undefined *param_2)

{
  int local_2c;
  undefined *local_28;
  int local_14;
  
  *param_2 = 0;
  local_28 = param_2;
  for (local_14 = param_1; local_14 != 0;
      local_14 = (local_14 - *(int *)((long)&PTR___mh_execute_header_100008004 + (long)local_2c * 4)
                 ) / 3) {
    local_2c = local_14 % 3;
    if (local_2c < 0) {
      local_2c = local_2c + 3;
    }
    *local_28 = (&DAT_100008000)[local_2c];
    local_28[1] = 0;
    local_28 = local_28 + 1;
  }
  _reverse(param_2);
  return;
}



int _from_bt(char *param_1)

{
  int local_c;
  char *local_8;
  
  local_c = 0;
  for (local_8 = param_1; *local_8 != '\0'; local_8 = local_8 + 1) {
    local_c = local_c * 3;
    if (*local_8 == '+') {
      local_c = local_c + 1;
    }
    else if (*local_8 == '-') {
      local_c = local_c + -1;
    }
  }
  return local_c;
}



long _last_char(char *param_1)

{
  char *local_10;
  char local_1;
  
  if ((param_1 == (char *)0x0) || (local_10 = param_1, *param_1 == '\0')) {
    local_1 = '\0';
  }
  else {
    for (; *local_10 != '\0'; local_10 = local_10 + 1) {
    }
    local_1 = local_10[-1];
    local_10[-1] = '\0';
  }
  return (long)local_1;
}



void _add(char *param_1,char *param_2,undefined *param_3)

{
  char cVar1;
  char local_76;
  char local_75;
  undefined2 local_74;
  undefined local_72;
  undefined *local_70;
  char *local_68;
  char *local_60;
  undefined auStack_58 [16];
  undefined auStack_48 [16];
  undefined auStack_38 [16];
  undefined auStack_28 [16];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_70 = param_3;
  local_68 = param_2;
  local_60 = param_1;
  if ((*param_1 == '\0') || (*param_2 == '\0')) {
    if (*param_1 == '\0') {
      if (*param_2 == '\0') {
        *param_3 = 0;
      }
      else {
        ___strcpy_chk(param_3,param_2,0xffffffffffffffff);
      }
    }
    else {
      ___strcpy_chk(param_3,param_1,0xffffffffffffffff);
    }
  }
  else {
    local_74._0_1_ = 0;
    local_74._1_1_ = 0;
    local_72 = 0;
    ___strcpy_chk(auStack_28,param_1);
    ___strcpy_chk(auStack_38,local_68,0x10);
    local_75 = _last_char(auStack_28);
    cVar1 = _last_char(auStack_38);
    local_76 = cVar1;
    if (cVar1 < local_75) {
      local_76 = local_75;
      local_75 = cVar1;
    }
    if (local_75 == '-') {
      if (local_76 == '0') {
        local_74._0_1_ = 0x2d;
      }
      if (local_76 == '-') {
        local_74._0_1_ = 0x2b;
        local_74._1_1_ = 0x2d;
      }
    }
    if (local_75 == '+') {
      if (local_76 == '0') {
        local_74._0_1_ = 0x2b;
      }
      if (local_76 == '-') {
        local_74._0_1_ = 0x30;
      }
      if (local_76 == '+') {
        local_74._0_1_ = 0x2d;
        local_74._1_1_ = 0x2b;
      }
    }
    if ((local_75 == '0') && (local_76 == '0')) {
      local_74._0_1_ = 0x30;
    }
    _add(auStack_28,(long)&local_74 + 1);
    _add(auStack_48,auStack_38);
    ___strcpy_chk(local_70,auStack_58);
    local_74 = (ushort)(byte)local_74;
    ___strcat_chk(local_70,&local_74,0xffffffffffffffff);
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



void _unary_minus(char *param_1,char *param_2)

{
  char *local_10;
  char *local_8;
  
  local_10 = param_2;
  for (local_8 = param_1; *local_8 != '\0'; local_8 = local_8 + 1) {
    if (*local_8 == '-') {
      *local_10 = '+';
    }
    else if (*local_8 == '+') {
      *local_10 = '-';
    }
    else {
      *local_10 = *local_8;
    }
    local_10 = local_10 + 1;
  }
  *local_10 = '\0';
  return;
}



void _subtract(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  undefined auStack_28 [16];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _unary_minus(param_2);
  _add(param_1,auStack_28,param_3);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void _mult(undefined8 param_1,undefined8 param_2,undefined8 param_3)

{
  char *local_80;
  char local_60 [16];
  undefined auStack_50 [16];
  undefined auStack_40 [16];
  char local_30 [24];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_30[8] = '\0';
  local_30[9] = '\0';
  local_30[10] = '\0';
  local_30[0xb] = '\0';
  local_30[0xc] = '\0';
  local_30[0xd] = '\0';
  local_30[0xe] = '\0';
  local_30[0xf] = '\0';
  local_30[0] = '0';
  local_30[1] = '\0';
  local_30[2] = '\0';
  local_30[3] = '\0';
  local_30[4] = '\0';
  local_30[5] = '\0';
  local_30[6] = '\0';
  local_30[7] = '\0';
  local_80 = local_60;
  ___strcpy_chk(auStack_50,param_1);
  ___strcpy_chk(local_80,param_2,0x10);
  _reverse(local_80);
  for (; *local_80 != '\0'; local_80 = local_80 + 1) {
    if (*local_80 == '+') {
      _add(local_30,auStack_50);
      ___strcpy_chk(local_30,auStack_40,0x10);
    }
    if (*local_80 == '-') {
      _subtract(local_30,auStack_50);
      ___strcpy_chk(local_30,auStack_40,0x10);
    }
    ___strcat_chk(auStack_50,"0",0x10);
  }
  for (local_80 = local_30; *local_80 == '0'; local_80 = local_80 + 1) {
  }
  ___strcpy_chk(param_3,local_80,0xffffffffffffffff);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



undefined8 entry(void)

{
  int iVar1;
  undefined auStack_48 [16];
  undefined auStack_38 [16];
  undefined auStack_28 [16];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _to_bt(0xfffffe4c);
  _subtract(auStack_28,"+-++-");
  _mult("+-0++0+",auStack_38);
  _from_bt("+-0++0+");
  _printf("      a: %14s %10d\n");
  _from_bt(auStack_28);
  _printf("      b: %14s %10d\n");
  _from_bt("+-++-");
  _printf("      c: %14s %10d\n");
  _from_bt(auStack_48);
  iVar1 = _printf("a*(b-c): %14s %10d\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strcat_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcat_chk_100004010)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004028)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct list_t list_t, *list;
struct list_t{
	int is_list, ival; /* ival is either the integer value or list length */
	list *lst;
};

list new_list()
{
	list x = malloc(sizeof(list_t));
	x->ival = 0;
	x->is_list = 1;
	x->lst = 0;
	return x;
}

void append(list parent, list child)
{
	parent->lst = realloc(parent->lst, sizeof(list) * (parent->ival + 1));
	parent->lst[parent->ival++] = child;
}

list from_string(char *s, char **e, list parent)
{
	list ret = 0;
	if (!parent) parent = new_list();

	while (*s != '\0') {
		if (*s == ']') {
			if (e) *e = s + 1;
			return parent;
		}
		if (*s == '[') {
			ret = new_list();
			ret->is_list = 1;
			ret->ival = 0;
			append(parent, ret);
			from_string(s + 1, &s, ret);
			continue;
		}
		if (*s >= '0' && *s <= '9') {
			ret = new_list();
			ret->is_list = 0;
			ret->ival = strtol(s, &s, 10);
			append(parent, ret);
			continue;
		}
		s++;
	}

	if (e) *e = s;
	return parent;
}

void show_list(list l)
{
	int i;
	if (!l) return;
	if (!l->is_list) {
		printf("%d", l->ival);
		return;
	}

	printf("[");
	for (i = 0; i < l->ival; i++) {
		show_list(l->lst[i]);
		if (i < l->ival - 1) printf(", ");
	}
	printf("]");
}

list flatten(list from, list to)
{
	int i;
	list t;

	if (!to) to = new_list();
	if (!from->is_list) {
		t = new_list();
		*t = *from;
		append(to, t);
	} else
		for (i = 0; i < from->ival; i++)
			flatten(from->lst[i], to);
	return to;
}

void delete_list(list l)
{
	int i;
	if (!l) return;
	if (l->is_list && l->ival) {
		for (i = 0; i < l->ival; i++)
			delete_list(l->lst[i]);
		free(l->lst);
	}

	free(l);
}

int main()
{
	list l = from_string("[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []", 0, 0);

	printf("Nested: ");
	show_list(l);
	printf("\n");

	list flat = flatten(l, 0);
	printf("Flattened: ");
	show_list(flat);

	/* delete_list(l); delete_list(flat); */
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef long double float128_t;

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003978(void);
int64_t function_1000039bc(int64_t a1, int64_t a2);
int64_t function_100003a30(void);
int64_t function_100003be8(void);
int64_t function_100003cf0(void);
int64_t function_100003dc8(void);
void function_100003f1c(int64_t * ptr);
int64_t * function_100003f28(int32_t size);
int32_t function_100003f34(char * format, ...);
int64_t * function_100003f40(int64_t * ptr, int32_t size);
int32_t function_100003f4c(char * nptr, char ** endptr, int32_t base);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------- Dynamically Linked Functions Without Header --------

void _free(int64_t * a1);
int64_t * _malloc(int32_t a1);
int32_t _printf(char * a1, ...);
int64_t * _realloc(int64_t * a1, int32_t a2);
int32_t _strtol(char * a1, char ** a2, int32_t a3);

// ------------------------ Functions -------------------------

// Address range: 0x100003978 - 0x1000039bc
int64_t function_100003978(void) {
    int64_t * v1 = _malloc(16); // 0x100003988
    int64_t result = (int64_t)v1; // 0x100003988
    *(int32_t *)(result + 4) = 0;
    *(int32_t *)v1 = 1;
    *(int64_t *)(result + 8) = 0;
    return result;
}

// Address range: 0x1000039bc - 0x100003a30
int64_t function_1000039bc(int64_t a1, int64_t a2) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x1000039d4
    int32_t * v2 = (int32_t *)(a1 + 4); // 0x1000039dc
    int64_t result = (int64_t)_realloc((int64_t *)*v1, 8 * *v2 + 8); // 0x1000039f4
    *v1 = result;
    int32_t v3 = *v2; // 0x100003a10
    *v2 = v3 + 1;
    *(int64_t *)(8 * (int64_t)v3 + result) = a2;
    return result;
}

// Address range: 0x100003a30 - 0x100003be8
int64_t function_100003a30(void) {
    // 0x100003a30
    int64_t v1; // 0x100003a30
    char * v2 = (char *)v1; // bp-32, 0x100003a3c
    int64_t result; // 0x100003a30
    if (v1 == 0) {
        // 0x100003a60
        result = function_100003978();
    }
    // 0x100003a6c
    char * v3; // 0x100003a70
    while (true) {
      lab_0x100003a70_2:
        // 0x100003a70
        v3 = v2;
        char v4 = *v3; // 0x100003a74
        switch (v4) {
            case 0: {
                goto lab_0x100003ba8;
            }
            case 93: {
                if (v1 != 0) {
                    // 0x100003ab4
                    *(int64_t *)v1 = (int64_t)v3 + 1;
                }
                // 0x100003bd8
                return result;
            }
            case 91: {
                int64_t v5 = function_100003978(); // 0x100003aec
                *(int32_t *)v5 = 1;
                *(int32_t *)(v5 + 4) = 0;
                function_1000039bc(result, v5);
                function_100003a30();
                goto lab_0x100003a70_2;
            }
            default: {
                int32_t v6 = v4; // 0x100003b30
                if (v4 < 48 == (47 - v6 & v6) < 0) {
                    int32_t v7 = v6 - 57; // 0x100003b4c
                    if (v7 == 0 || v7 < 0 != (56 - v6 & v6) < 0) {
                        int64_t v8 = function_100003978(); // 0x100003b5c
                        *(int32_t *)v8 = 0;
                        *(int32_t *)(v8 + 4) = _strtol(v2, &v2, 10);
                        function_1000039bc(result, v8);
                        goto lab_0x100003a70_2;
                    } else {
                        // 0x100003b98
                        v2 = (char *)((int64_t)v3 + 1);
                        goto lab_0x100003a70_2;
                    }
                } else {
                    // 0x100003b98
                    v2 = (char *)((int64_t)v3 + 1);
                    goto lab_0x100003a70_2;
                }
            }
        }
    }
  lab_0x100003ba8:
    if (v1 != 0) {
        // 0x100003bbc
        *(int64_t *)v1 = (int64_t)v3;
    }
    // 0x100003bd8
    return result;
}

// Address range: 0x100003be8 - 0x100003cf0
int64_t function_100003be8(void) {
    // 0x100003be8
    int64_t v1; // 0x100003be8
    if (v1 == 0) {
        // 0x100003ce4
        return 0;
    }
    if ((int32_t)v1 == 0) {
        // 0x100003ce4
        return _printf("%d", v1);
    }
    // 0x100003c4c
    _printf("[");
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x100003c68
    int32_t v3 = *v2; // 0x100003c68
    int32_t v4 = -v3; // 0x100003c6c
    if (v4 < 0 != (v3 & v4) < 0) {
        int32_t v5 = 0;
        function_100003be8();
        int32_t v6 = *v2; // 0x100003c98
        int32_t v7 = v6 - 1; // 0x100003c9c
        int32_t v8 = v5 - v7; // 0x100003ca0
        int32_t v9 = v6; // 0x100003ca8
        if (v8 < 0 != ((v8 ^ v5) & (v7 ^ v5)) < 0) {
            // 0x100003cb0
            _printf(", ");
            v9 = *v2;
        }
        int32_t v10 = v5 + 1; // 0x100003cc8
        while (v10 - v9 < 0 != ((v10 - v9 ^ v10) & (v9 ^ v10)) < 0) {
            // 0x100003c7c
            v5 = v10;
            function_100003be8();
            v6 = *v2;
            v7 = v6 - 1;
            v8 = v5 - v7;
            v9 = v6;
            if (v8 < 0 != ((v8 ^ v5) & (v7 ^ v5)) < 0) {
                // 0x100003cb0
                _printf(", ");
                v9 = *v2;
            }
            // 0x100003cc4
            v10 = v5 + 1;
        }
    }
    // 0x100003ce4
    return _printf("]");
}

// Address range: 0x100003cf0 - 0x100003dc8
int64_t function_100003cf0(void) {
    // 0x100003cf0
    int64_t result; // 0x100003cf0
    int64_t v1; // 0x100003cf0
    if (v1 == 0) {
        // 0x100003d18
        result = function_100003978();
    }
    // 0x100003d24
    if ((int32_t)v1 == 0) {
        int64_t v2 = function_100003978(); // 0x100003d3c
        int64_t v3; // 0x100003cf0
        *(float128_t *)v2 = *(float128_t *)&v3;
        function_1000039bc(result, v2);
        // 0x100003db8
        return result;
    }
    int32_t * v4 = (int32_t *)(v1 + 4); // 0x100003d74
    int32_t v5 = *v4; // 0x100003d74
    int32_t v6 = -v5; // 0x100003d78
    if (v6 < 0 == (v5 & v6) < 0) {
        // 0x100003db8
        return result;
    }
    int32_t v7 = 0; // 0x100003d80
    function_100003cf0();
    v7++;
    int32_t v8 = *v4; // 0x100003d74
    while (v7 - v8 < 0 != ((v7 - v8 ^ v7) & (v8 ^ v7)) < 0) {
        // 0x100003d88
        function_100003cf0();
        v7++;
        v8 = *v4;
    }
    // 0x100003db8
    return result;
}

// Address range: 0x100003dc8 - 0x100003e94
int64_t function_100003dc8(void) {
    // 0x100003dc8
    int64_t v1; // 0x100003dc8
    if (v1 == 0) {
        // 0x100003e88
        return 0;
    }
    if ((int32_t)v1 == 0) {
        // 0x100003e7c
        _free((int64_t *)v1);
        // 0x100003e88
        return &g1;
    }
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x100003e0c
    int32_t v3 = *v2; // 0x100003e0c
    if (v3 == 0) {
        // 0x100003e7c
        _free((int64_t *)v1);
        // 0x100003e88
        return &g1;
    }
    int32_t v4 = -v3; // 0x100003e34
    int32_t v5 = 0; // 0x100003e3c
    if (v4 < 0 != (v3 & v4) < 0) {
        function_100003dc8();
        v5++;
        int32_t v6 = *v2; // 0x100003e30
        while (v5 - v6 < 0 != ((v5 - v6 ^ v5) & (v6 ^ v5)) < 0) {
            // 0x100003e44
            function_100003dc8();
            v5++;
            v6 = *v2;
        }
    }
    // 0x100003e6c
    _free((int64_t *)*(int64_t *)(v1 + 8));
    // 0x100003e7c
    _free((int64_t *)v1);
    // 0x100003e88
    return &g1;
}

// Address range: 0x100003e94 - 0x100003f1c
int64_t entry_point(void) {
    // 0x100003e94
    function_100003a30();
    _printf("Nested: ");
    function_100003be8();
    _printf("\n");
    function_100003cf0();
    _printf("Flattened: ");
    function_100003be8();
    return 0;
}

// Address range: 0x100003f1c - 0x100003f28
void function_100003f1c(int64_t * ptr) {
    // 0x100003f1c
    _free(ptr);
}

// Address range: 0x100003f28 - 0x100003f34
int64_t * function_100003f28(int32_t size) {
    // 0x100003f28
    return _malloc(size);
}

// Address range: 0x100003f34 - 0x100003f40
int32_t function_100003f34(char * format, ...) {
    // 0x100003f34
    return _printf(format);
}

// Address range: 0x100003f40 - 0x100003f4c
int64_t * function_100003f40(int64_t * ptr, int32_t size) {
    // 0x100003f40
    return _realloc(ptr, size);
}

// Address range: 0x100003f4c - 0x100003f58
int32_t function_100003f4c(char * nptr, char ** endptr, int32_t base) {
    // 0x100003f4c
    return _strtol(nptr, endptr, base);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 12

`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: light-weight
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to generate a random internet speed between 1 and 100 Mbps
int generate_speed() {
    return rand() % 100 + 1;
}

// Function to simulate a speed test
int test_speed() {
    int speed = generate_speed();
    printf("Testing internet speed... \n");
    printf("Download speed: %d Mbps \n", speed);
    printf("Upload speed: %d Mbps \n", speed);
    printf("Latency: %d ms \n", rand() % 50 + 1);
    return speed;
}

// Function to compare two internet speeds and return the higher speed
int compare_speeds(int speed1, int speed2) {
    if (speed1 > speed2) {
        return speed1;
    } else {
        return speed2;
    }
}

int main() {
    srand(time(0)); // Seed the random number generator with current time
    int speed1 = test_speed();
    int speed2 = test_speed();
    int max_speed = compare_speeds(speed1, speed2);
    printf("Your maximum internet speed is: %d Mbps \n", max_speed);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 test_speed(void); // weak
__int64 __fastcall compare_speeds(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001689) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  unsigned int v6; // [rsp+28h] [rbp-8h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v7 = test_speed();
  v6 = test_speed();
  v5 = compare_speeds(v7, v6);
  printf("Your maximum internet speed is: %d Mbps \n", v5);
  return 0;
}
// 1400015E5: using guessed type __int64 test_speed(void);
// 14000166D: using guessed type __int64 __fastcall compare_speeds(_QWORD, _QWORD);
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Random Conspiracy Theory Generator ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

char *conspiracy_theories[] = {
    "The moon landing was faked by the government to win the space race against Russia.",
    "The Illuminati are controlling world events from the shadows.",
    "Chemtrails are being used by the government to control the population.",
    "The world is flat and the government is lying to us about it.",
    "Aliens have been visiting Earth for centuries and the government is covering it up.",
    "911 was an inside job orchestrated by the government to justify war in the Middle East.",
    "The CIAs mind control experiments are still being used today to manipulate the masses.",
    "The Denver airport is hiding secret underground bunkers for the elite in case of a global disaster.",
    "The government is hiding the cure for cancer to keep the medical industry profitable.",
    "The major world religions are all part of a vast conspiracy to control and manipulate humanity."
};

void print_conspiracy_theory(char **conspiracy_theories)
{
    srand(time(NULL));
    int random_index = rand() % 10;
    printf("%s\n", conspiracy_theories[random_index]);
}

int main()
{
    print_conspiracy_theory(conspiracy_theories);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall print_conspiracy_theory(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char *conspiracy_theories[10] =
{
  "The moon landing was faked by the government to win the space race against Russia.",
  "The Illuminati are controlling world events from the shadows.",
  "Chemtrails are being used by the government to control the population.",
  "The world is flat and the government is lying to us about it.",
  "Aliens have been visiting Earth for centuries and the government is covering it up.",
  "911 was an inside job orchestrated by the government to justify war in the Middle East.",
  "The CIAs mind control experiments are still being used today to manipulate the masses.",
  "The Denver airport is hiding secret underground bunkers for the elite in case of a global disaster.",
  "The government is hiding the cure for cancer to keep the medical industry profitable.",
  "The major world religions are all part of a vast conspiracy to control and manipulate humanity."
}; // weak


//----- (0000000140001630) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  print_conspiracy_theory(conspiracy_theories);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall print_conspiracy_theory(_QWORD);
// 140001710: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000A020: using guessed type char *conspiracy_theories[10];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data recovery tool ; Style: protected
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define BUFFER_SIZE 512

int main()
{
    FILE *fp;
    size_t fileLen;
    char *buffer, fileName[20], newFileName[30];
    int i, j, extensionIndex;

    // Get the name of the file to be recovered from user
    printf("Enter filename: ");
    scanf("%s", fileName);

    // Open the file in read mode
    fp = fopen(fileName, "r");
    if(fp == NULL)
    {
        printf("Error: Failed to open file %s\n", fileName);
        exit(1);
    }

    // Calculate the size of the file
    fseek(fp, 0, SEEK_END);
    fileLen = ftell(fp);
    rewind(fp);

    // Allocate memory for the buffer to store the file content
    buffer = (char *) malloc(fileLen * sizeof(char));
    if(buffer == NULL)
    {
        printf("Error: Failed to allocate memory for buffer\n");
        fclose(fp);
        exit(1);
    }

    // Read the contents of the file into the buffer
    fread(buffer, fileLen, 1, fp);

    // Close the file
    fclose(fp);

    // Search for the file extension
    extensionIndex = -1;
    for(i = strlen(fileName) - 1; i >= 0; i--)
    {
        if(fileName[i] == '.')
        {
            extensionIndex = i;
            break;
        }
    }

    if(extensionIndex == -1)
    {
        printf("Error: File extension not found\n");
        free(buffer);
        exit(1);
    }

    // Generate the new filename by appending "_recovered" to the original filename
    strncpy(newFileName, fileName, extensionIndex);
    strcat(newFileName, "_recovered");
    strcat(newFileName, fileName + extensionIndex);

    // Open the newly generated file in write mode
    fp = fopen(newFileName, "wb");
    if(fp == NULL)
    {
        printf("Error: Failed to create recovered file %s\n", newFileName);
        free(buffer);
        exit(1);
    }

    // Write the contents of the buffer back to the file
    fwrite(buffer, fileLen, 1, fp);

    // Close the file
    fclose(fp);

    // Free up the memory allocated for the buffer
    free(buffer);

    printf("Recovery process completed successfully. Recovered file saved as %s\n", newFileName);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcat(char *Destination, const char *Source);
// void __cdecl rewind(FILE *Stream);
// void *__cdecl malloc(size_t Size);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// void __cdecl free(void *Block);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Destination[32]; // [rsp+20h] [rbp-60h] BYREF
  char FileName[32]; // [rsp+40h] [rbp-40h] BYREF
  void *Buffer; // [rsp+60h] [rbp-20h]
  size_t Size; // [rsp+68h] [rbp-18h]
  FILE *Stream; // [rsp+70h] [rbp-10h]
  int v9; // [rsp+78h] [rbp-8h]
  int i; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter filename: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "r");
  if ( !Stream )
  {
    printf("Error: Failed to open file %s\n", FileName);
    exit(1);
  }
  fseek(Stream, 0, 2);
  Size = ftell(Stream);
  rewind(Stream);
  Buffer = malloc(Size);
  if ( !Buffer )
  {
    printf("Error: Failed to allocate memory for buffer\n");
    fclose(Stream);
    exit(1);
  }
  fread(Buffer, Size, 1ui64, Stream);
  fclose(Stream);
  v9 = -1;
  for ( i = strlen(FileName) - 1; i >= 0; --i )
  {
    if ( FileName[i] == 46 )
    {
      v9 = i;
      break;
    }
  }
  if ( v9 == -1 )
  {
    printf("Error: File extension not found\n");
    free(Buffer);
    exit(1);
  }
  strncpy(Destination, FileName, v9);
  strcat(Destination, "_recovered");
  strcat(Destination, &FileName[v9]);
  Stream = fopen(Destination, "wb");
  if ( !Stream )
  {
    printf("Error: Failed to create recovered file %s\n", Destination);
    free(Buffer);
    exit(1);
  }
  fwrite(Buffer, Size, 1ui64, Stream);
  fclose(Stream);
  free(Buffer);
  printf("Recovery process completed successfully. Recovered file saved as %s\n", Destination);
  return 0;
}
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char FileName[32];

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <limits.h>

typedef unsigned long long ull;
#define N (sizeof(ull) * CHAR_BIT)
#define B(x) (1ULL << (x))

void evolve(ull state, int rule)
{
	int i, p, q, b;

	for (p = 0; p < 10; p++) {
		for (b = 0, q = 8; q--; ) {
			ull st = state;
			b |= (st&1) << q;

			for (state = i = 0; i < N; i++)
				if (rule & B(7 & (st>>(i-1) | st<<(N+1-i))))
					state |= B(i);
		}
		printf(" %d", b);
	}
	putchar('\n');
	return;
}

int main(void)
{
	evolve(1, 30);
	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003df0(void);
int32_t function_100003f8c(char * format, ...);
int32_t function_100003f98(int32_t c);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _putchar(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x100003df0 - 0x100003f58
int64_t function_100003df0(void) {
    for (int32_t i = 0; i < 10; i++) {
        // 0x100003e30
        int64_t v1; // 0x100003df0
        _printf(" %d", v1);
    }
    // 0x100003f44
    return _putchar(10);
}

// Address range: 0x100003f58 - 0x100003f8c
int64_t entry_point(void) {
    // 0x100003f58
    function_100003df0();
    return 0;
}

// Address range: 0x100003f8c - 0x100003f98
int32_t function_100003f8c(char * format, ...) {
    // 0x100003f8c
    return _printf(format);
}

// Address range: 0x100003f98 - 0x100003fa4
int32_t function_100003f98(int32_t c) {
    // 0x100003f98
    return _putchar(c);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 4

`
`//FormAI DATASET v1.0 Category: Periodic Table Quiz ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Defines the element structure
struct Element {
    char name[20];
    char symbol[3];
    int number;
};

// Defines a function to populate the periodic table with elements
void populateTable(struct Element table[118]) {
    // Adds Hydrogen to the table
    struct Element hydrogen = {"Hydrogen", "H", 1};
    table[0] = hydrogen;
    // Adds Helium to the table
    struct Element helium = {"Helium", "He", 2};
    table[1] = helium;
    // Continues adding elements to the table
    // ...
}

// Defines a function to shuffle the elements in the periodic table
void shuffleTable(struct Element table[118]) {
    srand((unsigned int)time(NULL));
    for (int i = 117; i >= 0; i--) {
        int j = rand() % (i + 1);
        struct Element temp = table[i];
        table[i] = table[j];
        table[j] = temp;
    }
}

int main() {
    struct Element periodicTable[118];
    // Populates the periodic table with elements
    populateTable(periodicTable);
    // Shuffles the periodic table
    shuffleTable(periodicTable);
    // Prints the shuffled periodic table in a quiz format
    int correctAnswers = 0;
    int totalQuestions = 0;
    for (int i = 0; i < 118; i++) {
        struct Element element = periodicTable[i];
        char answer[20];
        printf("What is the symbol for %s? ", element.name);
        scanf("%s", answer);
        if (strcmp(answer, element.symbol) == 0) {
            printf("Correct!\n\n");
            correctAnswers++;
        } else {
            printf("Incorrect! The symbol for %s is %s.\n\n", element.name, element.symbol);
        }
        totalQuestions++;
    }
    // Prints the quiz results
    printf("Your score: %d/%d\n", correctAnswers, totalQuestions);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall populateTable(_QWORD); // weak
__int64 __fastcall shuffleTable(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (00000001400017DE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v3; // rax
  __int64 v4; // rbx
  char Str1[32]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v7[2]; // [rsp+40h] [rbp-40h] BYREF
  __int64 v8; // [rsp+50h] [rbp-30h] BYREF
  int v9; // [rsp+58h] [rbp-28h]
  char v10[32]; // [rsp+60h] [rbp-20h] BYREF
  __int64 v11; // [rsp+80h] [rbp+0h] BYREF
  int i; // [rsp+D54h] [rbp+CD4h]
  unsigned int v13; // [rsp+D58h] [rbp+CD8h]
  unsigned int v14; // [rsp+D5Ch] [rbp+CDCh]

  _main(argc, argv, envp);
  populateTable(v10);
  shuffleTable(v10);
  v14 = 0;
  v13 = 0;
  for ( i = 0; i <= 117; ++i )
  {
    v3 = (char *)&v11 + 28 * i - 32;
    v4 = *((_QWORD *)v3 + 1);
    v7[0] = *(_QWORD *)v3;
    v7[1] = v4;
    v8 = *((_QWORD *)v3 + 2);
    v9 = *((_DWORD *)v3 + 6);
    printf("What is the symbol for %s? ", (const char *)v7);
    scanf("%s", Str1);
    if ( !strcmp(Str1, (const char *)&v8 + 4) )
    {
      printf("Correct!\n\n");
      ++v14;
    }
    else
    {
      printf("Incorrect! The symbol for %s is %s.\n\n", (const char *)v7, (const char *)&v8 + 4);
    }
    ++v13;
  }
  printf("Your score: %d/%d\n", v14, v13);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall populateTable(_QWORD);
// 1400016BC: using guessed type __int64 __fastcall shuffleTable(_QWORD);
// 1400019F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: URL Sanitizer ; Style: light-weight
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

/* Function declarations */
bool checkForIllegalChars(char c);
char* sanitizeURL(char* url);

/* Main function */
int main() {
    char url[100] = "https://www.example.com/search?q=c++";
    printf("Original URL: %s\n", url);
    printf("Sanitized URL: %s\n", sanitizeURL(url));
    return 0;
}

/* Function to check for illegal characters */
bool checkForIllegalChars(char c) {
    if (c == '<' || c == '>' || c == '\"' ||
        c == '#' || c == '%' || c == '{' ||
        c == '}' || c == '|' || c == '\\' ||
        c == '^' || c == '~' || c == '[' ||
        c == ']' || c == '``' || c == ';' ||
        c == '/' || c == '?') {
        return true;
    }
    return false;
}

/* Function to sanitize a URL */
char* sanitizeURL(char* url) {
    int i, j = 0;
    int len = strlen(url);
    char* sanitizedURL = (char*)malloc(len * sizeof(char));
    for (i = 0; i < len; i++) {
        if (!checkForIllegalChars(url[i])) {
            sanitizedURL[j] = url[i];
            j++;
        }
    }
    sanitizedURL[j] = '\0';
    return sanitizedURL;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall sanitizeURL(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rax
  _WORD v5[20]; // [rsp+20h] [rbp-70h] BYREF
  __int64 v6; // [rsp+48h] [rbp-48h]
  __int64 v7; // [rsp+50h] [rbp-40h]
  __int64 v8; // [rsp+58h] [rbp-38h]
  __int64 v9; // [rsp+60h] [rbp-30h]
  __int64 v10; // [rsp+68h] [rbp-28h]
  __int64 v11; // [rsp+70h] [rbp-20h]
  __int64 v12; // [rsp+78h] [rbp-18h]
  int v13; // [rsp+80h] [rbp-10h]

  _main(argc, argv, envp);
  strcpy((char *)v5, "https://www.example.com/search?q=c++");
  HIBYTE(v5[18]) = 0;
  v5[19] = 0;
  v6 = 0i64;
  v7 = 0i64;
  v8 = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0;
  printf("Original URL: %s\n", (const char *)v5);
  v3 = (const char *)sanitizeURL(v5);
  printf("Sanitized URL: %s\n", v3);
  return 0;
}
// 1400016DF: using guessed type __int64 __fastcall sanitizeURL(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdio.h>
#include <stdlib.h>

int main()
{
	int i;
	printf("<table style=\"text-align:center; border: 1px solid\"><th></th>"
		"<th>X</th><th>Y</th><th>Z</th>");
	for (i = 0; i < 4; i++) {
		printf("<tr><th>%d</th><td>%d</td><td>%d</td><td>%d</td></tr>", i,
			rand() % 10000, rand() % 10000, rand() % 10000);
	}
	printf("</table>");

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int32_t function_100003ef4(char * format, ...);
int32_t function_100003f00(void);

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);
int32_t _rand(void);

// ------------------------ Functions -------------------------

// Address range: 0x100003e00 - 0x100003ef4
int64_t entry_point(void) {
    // 0x100003e00
    _printf("<table style=\"text-align:center; border: 1px solid\"><th></th><th>X</th><th>Y</th><th>Z</th>");
    for (int32_t i = 0; i < 4; i++) {
        // 0x100003e38
        _rand();
        _rand();
        _rand();
        int64_t v1; // 0x100003e00
        _printf("<tr><th>%d</th><td>%d</td><td>%d</td><td>%d</td></tr>", v1, v1, v1, v1);
    }
    // 0x100003ed8
    _printf("</table>");
    return 0;
}

// Address range: 0x100003ef4 - 0x100003f00
int32_t function_100003ef4(char * format, ...) {
    // 0x100003ef4
    return _printf(format);
}

// Address range: 0x100003f00 - 0x100003f0c
int32_t function_100003f00(void) {
    // 0x100003f00
    return _rand();
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`#include <stdio.h>

struct ModularArithmetic {
    int value;
    int modulus;
};

struct ModularArithmetic make(const int value, const int modulus) {
    struct ModularArithmetic r = { value % modulus, modulus };
    return r;
}

struct ModularArithmetic add(const struct ModularArithmetic a, const struct ModularArithmetic b) {
    return make(a.value + b.value, a.modulus);
}

struct ModularArithmetic addi(const struct ModularArithmetic a, const int v) {
    return make(a.value + v, a.modulus);
}

struct ModularArithmetic mul(const struct ModularArithmetic a, const struct ModularArithmetic b) {
    return make(a.value * b.value, a.modulus);
}

struct ModularArithmetic pow(const struct ModularArithmetic b, int pow) {
    struct ModularArithmetic r = make(1, b.modulus);
    while (pow-- > 0) {
        r = mul(r, b);
    }
    return r;
}

void print(const struct ModularArithmetic v) {
    printf("ModularArithmetic(%d, %d)", v.value, v.modulus);
}

struct ModularArithmetic f(const struct ModularArithmetic x) {
    return addi(add(pow(x, 100), x), 1);
}

int main() {
    struct ModularArithmetic input = make(10, 13);
    struct ModularArithmetic output = f(input);

    printf("f(");
    print(input);
    printf(") = ");
    print(output);
    printf("\n");

    return 0;
}
`,`#include "modular-arithmetic.h"



undefined8 _make(int param_1,int param_2)

{
  int iVar1;
  
  iVar1 = 0;
  if (param_2 != 0) {
    iVar1 = param_1 / param_2;
  }
  return CONCAT44(param_2,param_1 - iVar1 * param_2);
}



undefined8 _add(undefined8 param_1,int param_2)

{
  undefined8 uVar1;
  undefined4 local_20;
  undefined4 uStack_1c;
  
  local_20 = (int)param_1;
  uStack_1c = (undefined4)((ulong)param_1 >> 0x20);
  uVar1 = _make(local_20 + param_2,uStack_1c);
  return uVar1;
}



undefined8 _addi(undefined8 param_1,int param_2)

{
  undefined8 uVar1;
  undefined4 local_20;
  undefined4 uStack_1c;
  
  local_20 = (int)param_1;
  uStack_1c = (undefined4)((ulong)param_1 >> 0x20);
  uVar1 = _make(local_20 + param_2,uStack_1c);
  return uVar1;
}



undefined8 _mul(undefined8 param_1,int param_2)

{
  undefined8 uVar1;
  undefined4 local_20;
  undefined4 uStack_1c;
  
  local_20 = (int)param_1;
  uStack_1c = (undefined4)((ulong)param_1 >> 0x20);
  uVar1 = _make(local_20 * param_2,uStack_1c);
  return uVar1;
}



undefined8 _pow(undefined8 param_1,int param_2)

{
  undefined4 local_24;
  undefined4 uStack_1c;
  undefined8 local_18;
  
  uStack_1c = (undefined4)((ulong)param_1 >> 0x20);
  local_18 = _make(1,uStack_1c);
  local_24 = param_2;
  while( true ) {
    if (local_24 < 1) break;
    local_18 = _mul(local_18,param_1);
    local_24 = local_24 + -1;
  }
  return local_18;
}



int _print(void)

{
  int iVar1;
  
  iVar1 = _printf("ModularArithmetic(%d, %d)");
  return iVar1;
}



undefined8 _f(undefined8 param_1)

{
  undefined8 uVar1;
  
  uVar1 = _pow(param_1,100);
  uVar1 = _add(uVar1,param_1);
  uVar1 = _addi(uVar1,1);
  return uVar1;
}



undefined4 entry(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  
  uVar1 = _make(10,0xd);
  uVar2 = _f(uVar1);
  _printf("f(");
  _print(uVar1);
  _printf(") = ");
  _print(uVar2);
  _printf("\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

#define CACHE 256
enum { h_unknown = 0, h_yes, h_no };
unsigned char buf[CACHE] = {0, h_yes, 0};

int happy(int n)
{
	int sum = 0, x, nn;
	if (n < CACHE) {
		if (buf[n]) return 2 - buf[n];
		buf[n] = h_no;
	}

	for (nn = n; nn; nn /= 10) x = nn % 10, sum += x * x;

	x = happy(sum);
	if (n < CACHE) buf[n] = 2 - x;
	return x;
}

int main()
{
	int i, cnt = 8;
	for (i = 1; cnt || !printf("\n"); i++)
		if (happy(i)) --cnt, printf("%d ", i);

	printf("The %dth happy number: ", cnt = 1000000);
	for (i = 1; cnt; i++)
		if (happy(i)) --cnt || printf("%d\n", i);

	return 0;
}
`,`//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int64_t entry_point(void);
int64_t function_100003ca8(void);
int32_t function_100003f78(char * format, ...);

// --------------------- Global Variables ---------------------

char * g1; // 0x100008000

// ------- Dynamically Linked Functions Without Header --------

int32_t _printf(char * a1, ...);

// ------------------------ Functions -------------------------

// Address range: 0x100003ca8 - 0x100003df4
int64_t function_100003ca8(void) {
    // 0x100003ca8
    int64_t v1; // 0x100003ca8
    int32_t v2 = v1; // 0x100003cb4
    if (v2 < 256 != (255 - v2 & v2) < 0) {
        char * v3 = (char *)((0x100000000 * v1 >> 32) + (int64_t)&g1); // 0x100003ce0
        unsigned char v4 = *v3; // 0x100003ce0
        if (v4 != 0) {
            // 0x100003de4
            return 2 - (int64_t)v4 & 0xffffffff;
        }
        // 0x100003d14
        *v3 = 2;
    }
    int32_t v5 = v2; // 0x100003d48
    if (v2 != 0) {
        while (v5 >= 10) {
            // 0x100003d50
            v5 /= 10;
        }
    }
    int64_t v6 = function_100003ca8(); // 0x100003d9c
    if (v2 < 256 != (255 - v2 & v2) < 0) {
        // 0x100003db8
        *(char *)((0x100000000 * v1 >> 32) + (int64_t)&g1) = 2 - (char)v6;
    }
    // 0x100003de4
    return v6 & 0xffffffff;
}

// Address range: 0x100003df4 - 0x100003f78
int64_t entry_point(void) {
    int32_t v1 = 8; // 0x100003e14
    int64_t v2; // 0x100003df4
    while (true) {
        int32_t v3 = v1;
        if (v3 == 0) {
            // 0x100003e50
            if (_printf("\n") != 0) {
                // break -> 0x100003eb4
                break;
            }
        }
        // 0x100003e5c
        v1 = v3;
        if ((int32_t)function_100003ca8() != 0) {
            // 0x100003e74
            _printf("%d ", v2);
            v1 = v3 - 1;
        }
    }
    // 0x100003eb4
    _printf("The %dth happy number: ", v2);
    int32_t v4 = 0xf4240; // 0x100003f18
    while (true) {
        int32_t v5 = v4;
        v4 = v5;
        if ((int32_t)function_100003ca8() != 0) {
            // 0x100003f14
            v4 = v5 - 1;
            if (v4 == 0) {
                // break -> 0x100003f68
                break;
            }
        }
    }
    // 0x100003f68
    _printf("%d\n", v2);
    return 0;
}

// Address range: 0x100003f78 - 0x100003f84
int32_t function_100003f78(char * format, ...) {
    // 0x100003f78
    return _printf(format);
}

// --------------------- Meta-Information ---------------------

// Detected functions: 3

`
`//FormAI DATASET v1.0 Category: Physics simulation ; Style: optimized
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main() {
    double mass1, mass2, position1, position2, velocity1, velocity2, acceleration1, acceleration2, time = 0.0, dt = 0.1;
    double spring_constant = 10.0, damping_constant = 0.5;
    double force1, force2, displacement, previous_displacement;
    int steps = 1000;

    printf("Enter mass of first object: ");
    scanf("%lf", &mass1);
    printf("Enter initial position of first object: ");
    scanf("%lf", &position1);
    printf("Enter initial velocity of first object: ");
    scanf("%lf", &velocity1);

    printf("Enter mass of second object: ");
    scanf("%lf", &mass2);
    printf("Enter initial position of second object: ");
    scanf("%lf", &position2);
    printf("Enter initial velocity of second object: ");
    scanf("%lf", &velocity2);

    displacement = position1 - position2;
    previous_displacement = displacement;

    printf("Time  Position1  Position2  \n");

    for(int i = 0; i < steps; i++) {
        force1 = -spring_constant * displacement - damping_constant * (previous_displacement - displacement) / dt;
        force2 = -force1;
        acceleration1 = force1 / mass1;
        acceleration2 = force2 / mass2;
        position1 += velocity1 * dt + 0.5 * acceleration1 * dt * dt;
        position2 += velocity2 * dt + 0.5 * acceleration2 * dt * dt;
        velocity1 += acceleration1 * dt;
        velocity2 += acceleration2 * dt;
        displacement = position1 - position2;
        previous_displacement = displacement;

        printf("%f  %f  %f\n", time, position1, position2);
        time += dt;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+20h] [rbp-90h] BYREF
  double v5; // [rsp+28h] [rbp-88h] BYREF
  double v6; // [rsp+30h] [rbp-80h] BYREF
  double v7; // [rsp+38h] [rbp-78h] BYREF
  double v8; // [rsp+40h] [rbp-70h] BYREF
  double v9; // [rsp+48h] [rbp-68h] BYREF
  double v10; // [rsp+50h] [rbp-60h]
  double v11; // [rsp+58h] [rbp-58h]
  double v12; // [rsp+60h] [rbp-50h]
  double v13; // [rsp+68h] [rbp-48h]
  int v14; // [rsp+74h] [rbp-3Ch]
  double v15; // [rsp+78h] [rbp-38h]
  double v16; // [rsp+80h] [rbp-30h]
  double v17; // [rsp+88h] [rbp-28h]
  int i; // [rsp+94h] [rbp-1Ch]
  double v19; // [rsp+98h] [rbp-18h]
  double v20; // [rsp+A0h] [rbp-10h]
  double v21; // [rsp+A8h] [rbp-8h]

  _main(argc, argv, envp);
  v21 = 0.0;
  v17 = 0.1;
  v16 = 10.0;
  v15 = 0.5;
  v14 = 1000;
  printf("Enter mass of first object: ");
  scanf("%lf", &v9);
  printf("Enter initial position of first object: ");
  scanf("%lf", &v7);
  printf("Enter initial velocity of first object: ");
  scanf("%lf", &v5);
  printf("Enter mass of second object: ");
  scanf("%lf", &v8);
  printf("Enter initial position of second object: ");
  scanf("%lf", &v6);
  printf("Enter initial velocity of second object: ");
  scanf("%lf", &v4);
  v20 = v7 - v6;
  v19 = v7 - v6;
  printf("Time  Position1  Position2  \n");
  for ( i = 0; i < v14; ++i )
  {
    v13 = -v16 * v20 - (v19 - v20) * v15 / v17;
    v12 = -v13;
    v11 = v13 / v9;
    v10 = -v13 / v8;
    v7 = v7 + v5 * v17 + 0.5 * (v13 / v9) * v17 * v17;
    v6 = v6 + v4 * v17 + 0.5 * v10 * v17 * v17;
    v5 = v5 + v13 / v9 * v17;
    v4 = v4 + v10 * v17;
    v20 = v7 - v6;
    v19 = v7 - v6;
    printf("%f  %f  %f\n", v21, v7, v6);
    v21 = v21 + v17;
  }
  return 0;
}
// 1400019D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`#include <stdlib.h>
#include <stdio.h>

int main(void)
{
  printf("Hello world!\n");
  return EXIT_SUCCESS;
}
`,`#include "hello-world-text-3.h"



undefined4 entry(void)

{
  _printf("Hello world!\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
