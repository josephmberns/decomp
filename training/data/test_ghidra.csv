`#include<stdlib.h>
#include<math.h>
#include<stdio.h>

typedef struct
{
  int hour, minute, second;
} digitime;

double
timeToDegrees (digitime time)
{
  return (360 * time.hour / 24.0 + 360 * time.minute / (24 * 60.0) +
          360 * time.second / (24 * 3600.0));
}

digitime
timeFromDegrees (double angle)
{
  digitime d;
  double totalSeconds = 24 * 60 * 60 * angle / 360;

  d.second = (int) totalSeconds % 60;
  d.minute = ((int) totalSeconds % 3600 - d.second) / 60;
  d.hour = (int) totalSeconds / 3600;

  return d;
}

double
meanAngle (double *angles, int size)
{
  double y_part = 0, x_part = 0;
  int i;

  for (i = 0; i < size; i++)
    {
      x_part += cos (angles[i] * M_PI / 180);
      y_part += sin (angles[i] * M_PI / 180);
    }

  return atan2 (y_part / size, x_part / size) * 180 / M_PI;
}

int
main ()
{
  digitime *set, meanTime;
  int inputs, i;
  double *angleSet, angleMean;

  printf ("Enter number of inputs : ");
  scanf ("%d", &inputs);
  set = malloc (inputs * sizeof (digitime));
  angleSet = malloc (inputs * sizeof (double));
  printf ("\n\nEnter the data separated by a space between each unit : ");

  for (i = 0; i < inputs; i++)
    {
      scanf ("%d:%d:%d", &set[i].hour, &set[i].minute, &set[i].second);
      angleSet[i] = timeToDegrees (set[i]);
    }

  meanTime = timeFromDegrees (360 + meanAngle (angleSet, inputs));

  printf ("\n\nThe mean time is : %d:%d:%d", meanTime.hour, meanTime.minute,
          meanTime.second);
  return 0;
}
`,`#include "averages-mean-time-of-day.h"



undefined  [16] _timeToDegrees(undefined8 param_1,int param_2)

{
  undefined auVar1 [16];
  undefined4 local_38;
  undefined4 uStack_34;
  
  local_38 = (int)param_1;
  uStack_34 = (int)((ulong)param_1 >> 0x20);
  auVar1._0_8_ = (double)(local_38 * 0x168) / 24.0 + (double)(uStack_34 * 0x168) / 1440.0 +
                 (double)(param_2 * 0x168) / 86400.0;
  if (*(long *)PTR____stack_chk_guard_100004008 != *(long *)PTR____stack_chk_guard_100004008) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined  [16] _timeFromDegrees(double param_1)

{
  undefined auVar1 [16];
  double dVar2;
  undefined4 uStack_1c;
  
  dVar2 = (param_1 * 86400.0) / 360.0;
  auVar1._4_4_ = ((int)dVar2 % 0xe10 - (int)dVar2 % 0x3c) / 0x3c;
  auVar1._0_4_ = (int)dVar2 / 0xe10;
  auVar1._12_4_ = uStack_1c;
  auVar1._8_4_ = (int)dVar2 % 0x3c;
  if (*(long *)PTR____stack_chk_guard_100004008 == *(long *)PTR____stack_chk_guard_100004008) {
    return auVar1;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined  [16] _meanAngle(long param_1,int param_2)

{
  double dVar1;
  undefined auVar2 [16];
  undefined4 local_34;
  undefined8 local_30;
  undefined8 local_28;
  
  local_28 = 0.0;
  local_30 = 0.0;
  for (local_34 = 0; local_34 < param_2; local_34 = local_34 + 1) {
    dVar1 = (double)_cos((*(double *)(param_1 + (long)local_34 * 8) * 3.141592653589793) / 180.0);
    local_30 = local_30 + dVar1;
    dVar1 = (double)_sin((*(double *)(param_1 + (long)local_34 * 8) * 3.141592653589793) / 180.0);
    local_28 = local_28 + dVar1;
  }
  dVar1 = (double)_atan2(local_28 / (double)(long)param_2,local_30 / (double)(long)param_2);
  auVar2._0_8_ = (dVar1 * 180.0) / 3.141592653589793;
  auVar2._8_8_ = 0;
  return auVar2;
}



undefined8 entry(void)

{
  undefined8 *puVar1;
  int iVar2;
  void *pvVar3;
  void *pvVar4;
  long lVar5;
  undefined8 uVar6;
  double dVar7;
  int local_60;
  int local_5c;
  undefined4 uStack_1c;
  
  lVar5 = *(long *)PTR____stack_chk_guard_100004008;
  _printf("Enter number of inputs : ");
  _scanf("%d");
  pvVar3 = _malloc((long)local_5c * 0xc);
  pvVar4 = _malloc((long)local_5c << 3);
  _printf("\n\nEnter the data separated by a space between each unit : ");
  for (local_60 = 0; local_60 < local_5c; local_60 = local_60 + 1) {
    _scanf("%d:%d:%d");
    puVar1 = (undefined8 *)((long)pvVar3 + (long)local_60 * 0xc);
    uVar6 = _timeToDegrees(*puVar1,CONCAT44(uStack_1c,*(undefined4 *)(puVar1 + 1)));
    *(undefined8 *)((long)pvVar4 + (long)local_60 * 8) = uVar6;
  }
  dVar7 = (double)_meanAngle(pvVar4,local_5c);
  _timeFromDegrees(dVar7 + 360.0);
  iVar2 = _printf("\n\nThe mean time is : %d:%d:%d");
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar5) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void _atan2(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__atan2_100004010)();
  return;
}



void _cos(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cos_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004030)((int)param_1);
  return iVar1;
}



void _sin(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__sin_100004038)();
  return;
}


`
`#include <stdio.h>
#include <math.h>
#include <unistd.h>

const char *shades = ".:!*oe&#%@";

double light[3] = { -50, 0, 50 };
void normalize(double * v)
{
	double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
	v[0] /= len; v[1] /= len; v[2] /= len;
}

double dot(double *x, double *y)
{
	double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];
	return d < 0 ? -d : 0;
}

typedef struct { double cx, cy, cz, r; } sphere_t;

/* positive shpere and negative sphere */
sphere_t pos = { 20, 20, 0, 20 }, neg = { 1, 1, -6, 20 };

/* check if a ray (x,y, -inf)->(x, y, inf) hits a sphere; if so, return
   the intersecting z values.  z1 is closer to the eye */
int hit_sphere(sphere_t *sph, double x, double y, double *z1, double *z2)
{
	double zsq;
	x -= sph->cx;
	y -= sph->cy;
	zsq = sph->r * sph->r - (x * x + y * y);
	if (zsq < 0) return 0;
	zsq = sqrt(zsq);
	*z1 = sph->cz - zsq;
	*z2 = sph->cz + zsq;
	return 1;
}

void draw_sphere(double k, double ambient)
{
	int i, j, intensity, hit_result;
	double b;
	double vec[3], x, y, zb1, zb2, zs1, zs2;
	for (i = floor(pos.cy - pos.r); i <= ceil(pos.cy + pos.r); i++) {
		y = i + .5;
		for (j = floor(pos.cx - 2 * pos.r); j <= ceil(pos.cx + 2 * pos.r); j++) {
			x = (j - pos.cx) / 2. + .5 + pos.cx;

			/* ray lands in blank space, draw bg */
			if (!hit_sphere(&pos, x, y, &zb1, &zb2))
				hit_result = 0;

			/* ray hits pos sphere but not neg, draw pos sphere surface */
			else if (!hit_sphere(&neg, x, y, &zs1, &zs2))
				hit_result = 1;

			/* ray hits both, but pos front surface is closer */
			else if (zs1 > zb1) hit_result = 1;

			/* pos sphere surface is inside neg sphere, show bg */
			else if (zs2 > zb2) hit_result = 0;

			/* back surface on neg sphere is inside pos sphere,
			   the only place where neg sphere surface will be shown */
			else if (zs2 > zb1) hit_result = 2;
			else		    hit_result = 1;

			switch(hit_result) {
			case 0:
				putchar('+');
				continue;
			case 1:
				vec[0] = x - pos.cx;
				vec[1] = y - pos.cy;
				vec[2] = zb1 - pos.cz;
				break;
			default:
				vec[0] = neg.cx - x;
				vec[1] = neg.cy - y;
				vec[2] = neg.cz - zs2;
			}

			normalize(vec);
			b = pow(dot(light, vec), k) + ambient;
			intensity = (1 - b) * (sizeof(shades) - 1);
			if (intensity < 0) intensity = 0;
			if (intensity >= sizeof(shades) - 1)
				intensity = sizeof(shades) - 2;
			putchar(shades[intensity]);
		}
		putchar('\n');
	}
}

int main()
{
	double ang = 0;

	while (1) {
		printf("\033[H");
		light[1] = cos(ang * 2);
		light[2] = cos(ang);
		light[0] = sin(ang);
		normalize(light);
		ang += .05;

		draw_sphere(2, .3);
		usleep(100000);
	}
	return 0;
}
`,`#include "death-star.h"



void _normalize(double *param_1)

{
  double dVar1;
  undefined8 uVar2;
  
  uVar2 = NEON_fmadd(*param_1,*param_1,param_1[1] * param_1[1]);
  dVar1 = (double)NEON_fmadd(param_1[2],param_1[2],uVar2);
  dVar1 = SQRT(dVar1);
  *param_1 = *param_1 / dVar1;
  param_1[1] = param_1[1] / dVar1;
  param_1[2] = param_1[2] / dVar1;
  return;
}



undefined  [16] _dot(undefined8 *param_1,undefined8 *param_2)

{
  undefined auVar1 [16];
  undefined8 uVar2;
  double local_20;
  
  uVar2 = NEON_fmadd(*param_1,*param_2,(double)param_1[1] * (double)param_2[1]);
  local_20 = (double)NEON_fmadd(param_1[2],param_2[2],uVar2);
  if (0.0 <= local_20) {
    local_20 = 0.0;
  }
  else {
    local_20 = -local_20;
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_20;
  return auVar1;
}



bool _hit_sphere(double param_1,double param_2,double *param_3,double *param_4,double *param_5)

{
  double dVar1;
  undefined8 uVar2;
  
  uVar2 = NEON_fmadd(param_1 - *param_3,param_1 - *param_3,
                     (param_2 - param_3[1]) * (param_2 - param_3[1]));
  dVar1 = (double)NEON_fnmsub(param_3[3],param_3[3],uVar2);
  if (0.0 <= dVar1) {
    *param_4 = param_3[2] - SQRT(dVar1);
    *param_5 = param_3[2] + SQRT(dVar1);
  }
  return 0.0 <= dVar1;
}



void _draw_sphere(undefined8 param_1,double param_2,ulong param_3)

{
  int iVar1;
  uint uVar2;
  double dVar3;
  undefined8 uVar4;
  double local_88;
  double local_80;
  double local_78;
  double local_70;
  double local_68;
  double local_60;
  double local_58;
  int local_50;
  uint local_4c;
  int local_48;
  int local_44;
  double local_40;
  undefined8 local_38;
  double local_30;
  double local_28;
  double local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_40 = param_2;
  local_38 = param_1;
  for (local_44 = (int)(DAT_100008028 - DAT_100008038);
      (double)(long)local_44 <= (double)(long)(DAT_100008028 + DAT_100008038);
      local_44 = local_44 + 1) {
    local_68 = (double)(long)local_44 + 0.5;
    dVar3 = (double)NEON_fmadd(0xc000000000000000,DAT_100008038,_pos);
    for (local_48 = (int)dVar3; dVar3 = (double)NEON_fmadd(0x4000000000000000,DAT_100008038,_pos),
        (double)(long)local_48 <= (double)(long)dVar3; local_48 = local_48 + 1) {
      local_60 = ((double)(long)local_48 - _pos) / 2.0 + 0.5 + _pos;
      iVar1 = _hit_sphere(local_60,local_68,&_pos,&local_70,&local_78);
      if (iVar1 == 0) {
        local_50 = 0;
      }
      else {
        iVar1 = _hit_sphere(local_60,local_68,&_neg,&local_80,&local_88);
        if (iVar1 == 0) {
          local_50 = 1;
        }
        else if (local_80 <= local_70) {
          if (local_88 <= local_78) {
            if (local_88 <= local_70) {
              local_50 = 1;
            }
            else {
              local_50 = 2;
            }
          }
          else {
            local_50 = 0;
          }
        }
        else {
          local_50 = 1;
        }
      }
      if (local_50 == 0) {
        _putchar(0x2b);
      }
      else {
        if (local_50 == 1) {
          local_30 = local_60 - _pos;
          local_28 = local_68 - DAT_100008028;
          local_20 = local_70 - DAT_100008030;
        }
        else {
          local_30 = _neg - local_60;
          local_28 = DAT_100008048 - local_68;
          local_20 = DAT_100008050 - local_88;
        }
        _normalize();
        uVar4 = _dot(&_light,&local_30);
        local_58 = (double)_pow(uVar4,local_38);
        local_58 = local_58 + local_40;
        local_4c = (uint)((1.0 - local_58) * 7.0);
        if ((int)local_4c < 0) {
          local_4c = 0;
        }
        if (6 < local_4c) {
          local_4c = 6;
        }
        _putchar((int)(char)_shades[(int)local_4c]);
      }
    }
    uVar2 = _putchar(10);
    param_3 = (ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(param_3);
}



void entry(void)

{
  int iVar1;
  double local_20;
  
  local_20 = 0.0;
  do {
    iVar1 = _printf("\x1b[H");
    DAT_100008010 = _cos(local_20 * 2.0,iVar1);
    DAT_100008018 = _cos(local_20);
    _light = _sin(local_20);
    _normalize(&_light);
    local_20 = local_20 + 0.05;
    _draw_sphere(0x4000000000000000,0x3fd3333333333333);
    _usleep(100000);
  } while( true );
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void _cos(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cos_100004010)();
  return;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004028)(param_1);
  return iVar1;
}



void _sin(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__sin_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _usleep(useconds_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__usleep_100004038)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int f(int n, int x, int y)
{
	return (x + y*2 + 1)%n;
}

int main(int argc, char **argv)
{
	int i, j, n;

	//Edit: Add argument checking
	if(argc!=2) return 1;

	//Edit: Input must be odd and not less than 3.
	n = atoi(argv[1]);
	if (n < 3 || (n%2) == 0) return 2;

	for (i = 0; i < n; i++) {
		for (j = 0; j < n; j++)
			printf("% 4d", f(n, n - j - 1, i)*n + f(n, j, i) + 1);
		putchar('\n');
	}
	printf("\n Magic Constant: %d.\n", (n*n+1)/2*n);

	return 0;
}
`,`#include "magic-squares-of-odd-order.h"



int _f(int param_1,int param_2,int param_3)

{
  int iVar1;
  int iVar2;
  
  iVar1 = param_2 + param_3 * 2 + 1;
  iVar2 = 0;
  if (param_1 != 0) {
    iVar2 = iVar1 / param_1;
  }
  return iVar1 - iVar2 * param_1;
}



undefined4 entry(int param_1,long param_2)

{
  int iVar1;
  int local_28;
  int local_24;
  undefined4 local_14;
  
  if (param_1 == 2) {
    iVar1 = _atoi(*(char **)(param_2 + 8));
    if ((iVar1 < 3) || (iVar1 % 2 == 0)) {
      local_14 = 2;
    }
    else {
      for (local_24 = 0; local_24 < iVar1; local_24 = local_24 + 1) {
        for (local_28 = 0; local_28 < iVar1; local_28 = local_28 + 1) {
          _f(iVar1,(iVar1 - local_28) + -1,local_24);
          _f(iVar1,local_28,local_24);
          _printf("% 4d");
        }
        _putchar(10);
      }
      _printf("\n Magic Constant: %d.\n");
      local_14 = 0;
    }
  }
  else {
    local_14 = 1;
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004010)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

struct node {
	int val, len;
	struct node *next;
};

void lis(int *v, int len)
{
	int i;
	struct node *p, *n = calloc(len, sizeof *n);
	for (i = 0; i < len; i++)
		n[i].val = v[i];

	for (i = len; i--; ) {
		// find longest chain that can follow n[i]
		for (p = n + i; p++ < n + len; ) {
			if (p->val > n[i].val && p->len >= n[i].len) {
				n[i].next = p;
				n[i].len = p->len + 1;
			}
		}
	}

	// find longest chain
	for (i = 0, p = n; i < len; i++)
		if (n[i].len > p->len) p = n + i;

	do printf(" %d", p->val); while ((p = p->next));
	putchar('\n');

	free(n);
}

int main(void)
{
	int x[] = { 3, 2, 6, 4, 5, 1 };
	int y[] = { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 };

	lis(x, sizeof(x) / sizeof(int));
	lis(y, sizeof(y) / sizeof(int));
	return 0;
}
`,`#include "longest-increasing-subsequence.h"



void _lis(long param_1,int param_2)

{
  int iVar1;
  int *piVar2;
  void *pvVar3;
  int *local_28;
  int local_20;
  
  pvVar3 = _calloc((long)param_2,0x10);
  for (local_20 = 0; iVar1 = param_2, local_20 < param_2; local_20 = local_20 + 1) {
    *(undefined4 *)((long)pvVar3 + (long)local_20 * 0x10) =
         *(undefined4 *)(param_1 + (long)local_20 * 4);
  }
  while (local_20 = iVar1, iVar1 = local_20 + -1, local_20 != 0) {
    piVar2 = (int *)((long)pvVar3 + (long)iVar1 * 0x10);
    while (local_28 = piVar2, piVar2 = local_28 + 4,
          local_28 < (int *)((long)pvVar3 + (long)param_2 * 0x10)) {
      if ((*(int *)((long)pvVar3 + (long)iVar1 * 0x10) < *piVar2) &&
         (*(int *)((long)pvVar3 + (long)iVar1 * 0x10 + 4) <= local_28[5])) {
        *(int **)((long)pvVar3 + (long)iVar1 * 0x10 + 8) = piVar2;
        *(int *)((long)pvVar3 + (long)iVar1 * 0x10 + 4) = local_28[5] + 1;
      }
    }
  }
  local_28 = (int *)pvVar3;
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    if (*(int *)((long)local_28 + 4) < *(int *)((long)pvVar3 + (long)local_20 * 0x10 + 4)) {
      local_28 = (int *)((long)pvVar3 + (long)local_20 * 0x10);
    }
  }
  do {
    _printf(" %d");
    local_28 = *(int **)((long)local_28 + 8);
  } while (local_28 != (int *)0x0);
  _putchar(10);
  _free(pvVar3);
  return;
}



undefined8 entry(void)

{
  undefined auStack_70 [64];
  undefined8 local_30;
  undefined8 uStack_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_28 = 0x400000006;
  local_30 = 0x200000003;
  local_20 = 0x100000005;
  _memcpy(auStack_70,&DAT_100003f68,0x40);
  _lis(&local_30,6);
  _lis(auStack_70,0x10);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004030)(param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
    double inf = 1/0.0;
    double minus_inf = -1/0.0;
    double minus_zero = -1/ inf ;
    double nan = 0.0/0.0;

    printf("positive infinity: %f\n",inf);
    printf("negative infinity: %f\n",minus_inf);
    printf("negative zero: %f\n",minus_zero);
    printf("not a number: %f\n",nan);

    /* some arithmetic */

    printf("+inf + 2.0 = %f\n",inf + 2.0);
    printf("+inf - 10.1 = %f\n",inf - 10.1);
    printf("+inf + -inf = %f\n",inf + minus_inf);
    printf("0.0 * +inf = %f\n",0.0 * inf);
    printf("1.0/-0.0 = %f\n",1.0/minus_zero);
    printf("NaN + 1.0 = %f\n",nan + 1.0);
    printf("NaN + NaN = %f\n",nan + nan);

    /* some comparisons */

    printf("NaN == NaN = %s\n",nan == nan ? "true" : "false");
    printf("0.0 == -0.0 = %s\n",0.0 == minus_zero ? "true" : "false");

    return 0;
}
`,`#include "extreme-floating-point-values-1.h"



// WARNING: Removing unreachable block (ram,0x000100003e5c)

undefined4 entry(void)

{
  _printf("positive infinity: %f\n");
  _printf("negative infinity: %f\n");
  _printf("negative zero: %f\n");
  _printf("not a number: %f\n");
  _printf("+inf + 2.0 = %f\n");
  _printf("+inf - 10.1 = %f\n");
  _printf("+inf + -inf = %f\n");
  _printf("0.0 * +inf = %f\n");
  _printf("1.0/-0.0 = %f\n");
  _printf("NaN + 1.0 = %f\n");
  _printf("NaN + NaN = %f\n");
  _printf("NaN == NaN = %s\n");
  _printf("0.0 == -0.0 = %s\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <assert.h>

int main(){
   int a;
   /* ...input or change a here */
   assert(a == 42); /* aborts program when a is not 42, unless the NDEBUG macro was defined */

   return 0;
}
`,`#include "assertions-1.h"



undefined8 entry(void)

{
  int local_18;
  
  if (local_18 != 0x2a) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("main","assertions-1.c",6,"a == 42");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#define MAX_BUF 50

int main(void)
{
  char buf[MAX_BUF];
  time_t seconds = time(NULL);
  struct tm *now = localtime(&seconds);
  const char *months[] = {"January", "February", "March", "April", "May", "June",
                          "July", "August", "September", "October", "November", "December"};

  const char *days[] = {"Sunday", "Monday", "Tuesday", "Wednesday","Thursday","Friday","Saturday"};

  (void) printf("%d-%d-%d\n", now->tm_year + 1900, now->tm_mon + 1, now->tm_mday);
  (void) printf("%s, %s %d, %d\n",days[now->tm_wday], months[now->tm_mon],
               now->tm_mday, now->tm_year + 1900);
  /* using the strftime (the result depends on the locale) */
  (void) strftime(buf, MAX_BUF, "%A, %B %e, %Y", now);
  (void) printf("%s\n", buf);
  return EXIT_SUCCESS;
}
`,`#include "date-format.h"



undefined8 entry(void)

{
  int iVar1;
  tm *ptVar2;
  time_t local_108;
  undefined4 local_fc;
  undefined auStack_f8 [56];
  undefined auStack_c0 [102];
  char acStack_5a [50];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_fc = 0;
  local_108 = _time((time_t *)0x0);
  ptVar2 = _localtime(&local_108);
  _memcpy(auStack_c0,&PTR_s_January_100004038,0x60);
  _memcpy(auStack_f8,&PTR_s_Sunday_100004098,0x38);
  _printf("%d-%d-%d\n");
  _printf("%s, %s %d, %d\n");
  _strftime(acStack_5a,0x32,"%A, %B %e, %Y",ptVar2);
  iVar1 = _printf("%s\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * _localtime(time_t *param_1)

{
  tm *ptVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  ptVar1 = (tm *)(*(code *)PTR__localtime_100004010)();
  return ptVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strftime(char *param_1,size_t param_2,char *param_3,tm *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strftime_100004028)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004030)();
  return tVar1;
}


`
`#include <limits.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

typedef long long llong_t;
struct PrimeArray {
    llong_t *ptr;
    size_t size;
    size_t capacity;
};

struct PrimeArray allocate() {
    struct PrimeArray primes;

    primes.size = 0;
    primes.capacity = 10;
    primes.ptr = malloc(primes.capacity * sizeof(llong_t));

    return primes;
}

void deallocate(struct PrimeArray *primes) {
    free(primes->ptr);
    primes->ptr = NULL;
}

void push_back(struct PrimeArray *primes, llong_t p) {
    if (primes->size >= primes->capacity) {
        size_t new_capacity = (3 * primes->capacity) / 2 + 1;
        llong_t *temp = realloc(primes->ptr, new_capacity * sizeof(llong_t));
        if (NULL == temp) {
            fprintf(stderr, "Failed to reallocate the prime array.");
            exit(1);
        } else {
            primes->ptr = temp;
            primes->capacity = new_capacity;
        }
    }

    primes->ptr[primes->size++] = p;
}

int main() {
    const int cutOff = 200, bigUn = 100000, chunks = 50, little = bigUn / chunks;
    struct PrimeArray primes = allocate();
    int c = 0;
    bool showEach = true;
    llong_t u = 0, v = 1, i;

    push_back(&primes, 3);
    push_back(&primes, 5);

    printf("The first %d cuban primes:\n", cutOff);
    for (i = 1; i < LLONG_MAX; ++i) {
        bool found = false;
        llong_t mx = ceil(sqrt(v += (u += 6)));
        llong_t j;

        for (j = 0; j < primes.size; ++j) {
            if (primes.ptr[j] > mx) {
                break;
            }
            if (v % primes.ptr[j] == 0) {
                found = true;
                break;
            }
        }
        if (!found) {
            c += 1;
            if (showEach) {
                llong_t z;
                for (z = primes.ptr[primes.size - 1] + 2; z <= v - 2; z += 2) {
                    bool fnd = false;

                    for (j = 0; j < primes.size; ++j) {
                        if (primes.ptr[j] > mx) {
                            break;
                        }
                        if (z % primes.ptr[j] == 0) {
                            fnd = true;
                            break;
                        }
                    }
                    if (!fnd) {
                        push_back(&primes, z);
                    }
                }
                push_back(&primes, v);
                printf("%11lld", v);
                if (c % 10 == 0) {
                    printf("\n");
                }
                if (c == cutOff) {
                    showEach = false;
                    printf("\nProgress to the %dth cuban prime: ", bigUn);
                }
            }
            if (c % little == 0) {
                printf(".");
                if (c == bigUn) {
                    break;
                }
            }
        }
    }
    printf("\nThe %dth cuban prime is %lld\n", c, v);

    deallocate(&primes);
    return 0;
}
`,`#include "cuban-primes-1.h"



void _allocate(undefined8 *param_1)

{
  void *pvVar1;
  
  param_1[1] = 0;
  param_1[2] = 10;
  pvVar1 = _malloc(param_1[2] << 3);
  *param_1 = pvVar1;
  return;
}



void _deallocate(undefined8 *param_1)

{
  _free((void *)*param_1);
  *param_1 = 0;
  return;
}



void _push_back(long *param_1,undefined8 param_2)

{
  void *pvVar1;
  long lVar2;
  
  if ((ulong)param_1[2] <= (ulong)param_1[1]) {
    lVar2 = (ulong)(param_1[2] * 3) / 2 + 1;
    pvVar1 = _realloc((void *)*param_1,lVar2 * 8);
    if (pvVar1 == (void *)0x0) {
      _fprintf(*(FILE **)PTR____stderrp_100004000,"Failed to reallocate the prime array.");
                    // WARNING: Subroutine does not return
      _exit(1);
    }
    *param_1 = (long)pvVar1;
    param_1[2] = lVar2;
  }
  lVar2 = param_1[1];
  param_1[1] = lVar2 + 1;
  *(undefined8 *)(*param_1 + lVar2 * 8) = param_2;
  return;
}



undefined8 entry(void)

{
  long lVar1;
  bool bVar2;
  bool bVar3;
  long lVar4;
  long local_80;
  ulong local_78;
  long local_60;
  long local_58;
  long local_50;
  int local_44;
  long local_40;
  ulong local_38;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_18 = 200;
  local_1c = 100000;
  local_20 = 0x32;
  local_24 = 2000;
  _allocate();
  local_44 = 0;
  bVar3 = true;
  local_50 = 0;
  local_58 = 1;
  _push_back(&local_40,3);
  _push_back(&local_40,5);
  _printf("The first %d cuban primes:\n");
  for (local_60 = 1; local_60 < 0x7fffffffffffffff; local_60 = local_60 + 1) {
    bVar2 = false;
    local_50 = local_50 + 6;
    local_58 = local_58 + local_50;
    local_78 = 0;
    while( true ) {
      if ((local_38 <= local_78) ||
         ((long)SQRT((double)local_58) < *(long *)(local_40 + local_78 * 8))) goto LAB_100003c78;
      lVar4 = *(long *)(local_40 + local_78 * 8);
      lVar1 = 0;
      if (lVar4 != 0) {
        lVar1 = local_58 / lVar4;
      }
      if (local_58 == lVar1 * lVar4) break;
      local_78 = local_78 + 1;
    }
    bVar2 = true;
LAB_100003c78:
    if (!bVar2) {
      local_44 = local_44 + 1;
      if (bVar3) {
        local_80 = *(long *)(local_40 + (local_38 - 1) * 8);
        while (local_80 = local_80 + 2, local_80 <= local_58 + -2) {
          bVar2 = false;
          local_78 = 0;
          while( true ) {
            if ((local_38 <= local_78) ||
               ((long)SQRT((double)local_58) < *(long *)(local_40 + local_78 * 8)))
            goto LAB_100003d68;
            lVar4 = *(long *)(local_40 + local_78 * 8);
            lVar1 = 0;
            if (lVar4 != 0) {
              lVar1 = local_80 / lVar4;
            }
            if (local_80 == lVar1 * lVar4) break;
            local_78 = local_78 + 1;
          }
          bVar2 = true;
LAB_100003d68:
          if (!bVar2) {
            _push_back(&local_40,local_80);
          }
        }
        _push_back(&local_40,local_58);
        _printf("%11lld");
        if (local_44 % 10 == 0) {
          _printf("\n");
        }
        if (local_44 == 200) {
          bVar3 = false;
          _printf("\nProgress to the %dth cuban prime: ");
        }
      }
      if ((local_44 % 2000 == 0) && (_printf("."), local_44 == 100000)) break;
    }
  }
  _printf("\nThe %dth cuban prime is %lld\n");
  _deallocate(&local_40);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004008)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004030)();
  return pvVar1;
}


`
`#include<stdlib.h>
#include<stdio.h>

int* patienceSort(int* arr,int size){
	int decks[size][size],i,j,min,pickedRow;
	
	int *count = (int*)calloc(sizeof(int),size),*sortedArr = (int*)malloc(size*sizeof(int));
	
	for(i=0;i<size;i++){
		for(j=0;j<size;j++){
			if(count[j]==0 || (count[j]>0 && decks[j][count[j]-1]>=arr[i])){
				decks[j][count[j]] = arr[i];
				count[j]++;
				break;
			}
		}
	}
	
	min = decks[0][count[0]-1];
	pickedRow = 0;
	
	for(i=0;i<size;i++){
		for(j=0;j<size;j++){
			if(count[j]>0 && decks[j][count[j]-1]<min){
				min = decks[j][count[j]-1];
				pickedRow = j;
			}
		}
		sortedArr[i] = min;
		count[pickedRow]--;
		
		for(j=0;j<size;j++)
			if(count[j]>0){
				min = decks[j][count[j]-1];
				pickedRow = j;
				break;
			}
	}
	
	free(count);
	free(decks);
	
	return sortedArr;
}

int main(int argC,char* argV[])
{
	int *arr, *sortedArr, i;
	
	if(argC==0)
		printf("Usage : %s <integers to be sorted separated by space>");
	else{
		arr = (int*)malloc((argC-1)*sizeof(int));
		
		for(i=1;i<=argC;i++)
			arr[i-1] = atoi(argV[i]);
		
		sortedArr = patienceSort(arr,argC-1);
		
		for(i=0;i<argC-1;i++)
			printf("%d ",sortedArr[i]);
	}
	
	return 0;
}
`,`#include "sorting-algorithms-patience-sort.h"



void * _patienceSort(long param_1,uint param_2)

{
  void *local_90;
  undefined *local_88;
  ulong local_80;
  ulong local_78;
  ulong local_70;
  void *local_68;
  void *local_60;
  int *local_58;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  ulong local_38;
  undefined *local_30;
  uint local_24;
  long local_20;
  long local_18;
  
  local_30 = (undefined *)&local_90;
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_70 = (ulong)param_2;
  local_80 = (ulong)param_2;
  local_78 = local_70 * local_80 * 4 + 0xf & 0xfffffffffffffff0;
  local_24 = param_2;
  local_20 = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_68 = (void *)((long)&local_90 - local_78);
  local_38 = local_70;
  local_58 = (int *)_calloc(4,(long)(int)local_24);
  local_60 = _malloc((long)(int)local_24 << 2);
  local_44 = 0;
  do {
    if ((int)local_24 <= local_44) {
      local_4c = *(int *)((long)local_68 + (long)(*local_58 + -1) * 4);
      local_50 = 0;
      local_44 = 0;
      do {
        if ((int)local_24 <= local_44) {
          _free(local_58);
          _free(local_68);
          local_90 = local_60;
          local_88 = local_30;
          if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
            return local_60;
          }
                    // WARNING: Subroutine does not return
          ___stack_chk_fail();
        }
        for (local_48 = 0; local_48 < (int)local_24; local_48 = local_48 + 1) {
          if ((0 < local_58[local_48]) &&
             (*(int *)((long)local_68 +
                      (long)(local_58[local_48] + -1) * 4 + (long)local_48 * local_80 * 4) <
              local_4c)) {
            local_4c = *(int *)((long)local_68 +
                               (long)(local_58[local_48] + -1) * 4 + (long)local_48 * local_80 * 4);
            local_50 = local_48;
          }
        }
        *(int *)((long)local_60 + (long)local_44 * 4) = local_4c;
        local_58[local_50] = local_58[local_50] + -1;
        for (local_48 = 0; local_48 < (int)local_24; local_48 = local_48 + 1) {
          if (0 < local_58[local_48]) {
            local_4c = *(int *)((long)local_68 +
                               (long)(local_58[local_48] + -1) * 4 + (long)local_48 * local_80 * 4);
            local_50 = local_48;
            break;
          }
        }
        local_44 = local_44 + 1;
      } while( true );
    }
    for (local_48 = 0; local_48 < (int)local_24; local_48 = local_48 + 1) {
      if ((local_58[local_48] == 0) ||
         ((0 < local_58[local_48] &&
          (*(int *)(local_20 + (long)local_44 * 4) <=
           *(int *)((long)local_68 +
                   (long)(local_58[local_48] + -1) * 4 + (long)local_48 * local_80 * 4))))) {
        *(undefined4 *)
         ((long)local_68 + (long)local_58[local_48] * 4 + (long)local_48 * local_80 * 4) =
             *(undefined4 *)(local_20 + (long)local_44 * 4);
        local_58[local_48] = local_58[local_48] + 1;
        break;
      }
    }
    local_44 = local_44 + 1;
  } while( true );
}



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  void *pvVar2;
  int local_34;
  
  if (param_1 == 0) {
    _printf("Usage : %s <integers to be sorted separated by space>");
  }
  else {
    pvVar2 = _malloc((long)(param_1 + -1) << 2);
    for (local_34 = 1; local_34 <= param_1; local_34 = local_34 + 1) {
      iVar1 = _atoi(*(char **)(param_2 + (long)local_34 * 8));
      *(int *)((long)pvVar2 + (long)(local_34 + -1) * 4) = iVar1;
    }
    _patienceSort(pvVar2,param_1 + -1);
    for (local_34 = 0; local_34 < param_1 + -1; local_34 = local_34 + 1) {
      _printf("%d ");
    }
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004030)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}


`
`/**
 * @file
 * @brief Program to identify if a number is [palindrome
 * number](https://en.wikipedia.org/wiki/Palindrome) or not.
 * @see project_euler/problem_4/sol1.c
 */
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>

bool isPalindrome(int number);

/** Driver Code */
int main()
{
    assert(isPalindrome(0));
    assert(isPalindrome(1));
    assert(isPalindrome(12321));
    assert(!isPalindrome(1234));
    return 0;
}

/**
 * Check given number whether is palindrome number or not
 * @param number number to check
 * @return true if given number is palindrome number
 * @return false if number is not a palindrome number
 */
bool isPalindrome(int number)
{
    int reversedNumber = 0;
    int originalNumber = number;
    while (number != 0)
    {
        int remainder = number % 10;
        reversedNumber = reversedNumber * 10 + remainder;
        number /= 10;
    }
    return originalNumber == reversedNumber;
}
`,`#include "palindrome.h"



undefined8 entry(void)

{
  uint uVar1;
  
  uVar1 = _isPalindrome(0);
  if (((uVar1 ^ 1) & 1) != 0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("main","palindrome.c",0x10,"isPalindrome(0)");
  }
  uVar1 = _isPalindrome();
  if (((uVar1 ^ 1) & 1) != 0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("main","palindrome.c",0x11,"isPalindrome(1)");
  }
  uVar1 = _isPalindrome(0x3021);
  if (((uVar1 ^ 1) & 1) != 0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("main","palindrome.c",0x12,"isPalindrome(12321)");
  }
  uVar1 = _isPalindrome(0x4d2);
  if ((uVar1 & 1) != 0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("main","palindrome.c",0x13,"!isPalindrome(1234)");
  }
  return 0;
}



bool _isPalindrome(int param_1)

{
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 0;
  for (local_4 = param_1; local_4 != 0; local_4 = local_4 / 10) {
    local_8 = local_8 * 10 + local_4 % 10;
  }
  return param_1 == local_8;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}


`
`#include <stdio.h>
#include <stdbool.h>
#include <time.h>

#define n 100
#define nn ((n * (n + 1)) >> 1)

bool Contains(int lst[], int item, int size) {
	for (int i = size - 1; i >= 0; i--)
 		if (item == lst[i]) return true;
	return false;
}

int * MianChowla()
{
	static int mc[n]; mc[0] = 1;
	int sums[nn];	sums[0] = 2;
	int sum, le, ss = 1;
	for (int i = 1; i < n; i++) {
		le = ss;
		for (int j = mc[i - 1] + 1; ; j++) {
			mc[i] = j;
			for (int k = 0; k <= i; k++) {
				sum = mc[k] + j;
				if (Contains(sums, sum, ss)) {
					ss = le; goto nxtJ;
				}
				sums[ss++] = sum;
			}
			break;
		nxtJ:;
		}
	}
	return mc;
}

int main() {
	clock_t st = clock(); int * mc; mc = MianChowla();
        double et = ((double)(clock() - st)) / CLOCKS_PER_SEC;
	printf("The first 30 terms of the Mian-Chowla sequence are:\n");
	for (int i = 0; i < 30; i++) printf("%d ", mc[i]);
	printf("\n\nTerms 91 to 100 of the Mian-Chowla sequence are:\n");
	for (int i = 90; i < 100; i++) printf("%d ", mc[i]);
	printf("\n\nComputation time was %f seconds.", et);
}
`,`#include "mian-chowla-sequence-1.h"



undefined _Contains(long param_1,int param_2,int param_3)

{
  int local_1c;
  
  local_1c = param_3 + -1;
  while( true ) {
    if (local_1c < 0) {
      return 0;
    }
    if (param_2 == *(int *)(param_1 + (long)local_1c * 4)) break;
    local_1c = local_1c + -1;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined * _MianChowla(void)

{
  int iVar1;
  int iVar2;
  ulong uVar3;
  long lVar4;
  int local_4f28;
  int local_4f24;
  int local_4f20;
  int local_4f1c;
  int local_4f10 [5050];
  long local_28;
  
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _DAT_100008000 = 1;
  local_4f10[0] = 2;
  local_4f1c = 1;
  local_4f20 = 1;
LAB_100003c64:
  iVar2 = local_4f1c;
  if (99 < local_4f20) {
    if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
      return &DAT_100008000;
    }
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  local_4f24 = *(int *)(&DAT_100008000 + (long)(local_4f20 + -1) * 4);
  do {
    local_4f24 = local_4f24 + 1;
    *(int *)(&DAT_100008000 + (long)local_4f20 * 4) = local_4f24;
    local_4f28 = 0;
    local_4f1c = iVar2;
    while( true ) {
      if (local_4f20 < local_4f28) {
        local_4f20 = local_4f20 + 1;
        goto LAB_100003c64;
      }
      iVar1 = *(int *)(&DAT_100008000 + (long)local_4f28 * 4);
      uVar3 = _Contains(local_4f10,iVar1 + local_4f24,local_4f1c);
      if ((uVar3 & 1) != 0) break;
      lVar4 = (long)local_4f1c;
      local_4f1c = local_4f1c + 1;
      local_4f10[lVar4] = iVar1 + local_4f24;
      local_4f28 = local_4f28 + 1;
    }
  } while( true );
}



undefined4 entry(void)

{
  int local_38;
  int local_34;
  
  _clock();
  _MianChowla();
  _clock();
  _printf("The first 30 terms of the Mian-Chowla sequence are:\n");
  for (local_34 = 0; local_34 < 0x1e; local_34 = local_34 + 1) {
    _printf("%d ");
  }
  _printf("\n\nTerms 91 to 100 of the Mian-Chowla sequence are:\n");
  for (local_38 = 0x5a; local_38 < 100; local_38 = local_38 + 1) {
    _printf("%d ");
  }
  _printf("\n\nComputation time was %f seconds.");
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

clock_t _clock(void)

{
  clock_t cVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  cVar1 = (*(code *)PTR__clock_100004018)();
  return cVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    // Get a chance to make stdin input buffer dirty.
    //
    char text[256];
    getchar();

    // This DOES NOT WORK properly on all modern systems including Linux & W10.
    // Obsolete, don't use this. BTW, there is no fpurge in MSVC libs in 2020.
    //
    // fflush(stdin);

    // Always works. Readed characters may remain somethere in RAM.
    //
    fseek(stdin, 0, SEEK_END);

    // A very dirty solution - an unbuffered stream does not need any flushing.
    //
    // setvbuf(stdin, NULL, _IONBF, 0);

    // Now we are able to check if the buffer is really empty.
    //
    fgets(text, sizeof(text), stdin);
    puts(text);

    return EXIT_SUCCESS;
}
`,`#include "keyboard-input-flush-the-keyboard-buffer-1.h"



undefined8 entry(void)

{
  undefined *puVar1;
  int iVar2;
  char acStack_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _getchar();
  puVar1 = PTR____stdinp_100004010;
  _fseek(*(FILE **)PTR____stdinp_100004010,0,2);
  _fgets(acStack_128,0x100,*(FILE **)puVar1);
  iVar2 = _puts(acStack_128);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004018)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fseek(FILE *param_1,long param_2,int param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fseek_100004020)((int)param_1,param_2,param_3);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004028)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004030)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>

typedef const char * String;
typedef struct sTable {
    String * *rows;
    int      n_rows,n_cols;
} *Table;

typedef int (*CompareFctn)(String a, String b);

struct {
   CompareFctn  compare;
   int   column;
   int   reversed;
} sortSpec;

int CmprRows( const void *aa, const void *bb)
{
   String *rA = *(String *const *)aa;
   String *rB = *(String *const *)bb;
   int sortCol = sortSpec.column;

   String left = sortSpec.reversed ? rB[sortCol] : rA[sortCol];
   String right = sortSpec.reversed ? rA[sortCol] : rB[sortCol];
   return sortSpec.compare( left, right );
}

/** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * tbl parameter is a table of rows of strings
 * argSpec is a string containing zero or more of the letters o,c,r
 * if o is present - the corresponding optional argument is a function which
 *      determines the ordering of the strings.
 * if c is present - the corresponding optional argument is an integer that
 *      specifies the column to sort on.
 * if r is present - the corresponding optional argument is either
 *      true(nonzero) or false(zero) and if true, the sort will b in reverse order
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int sortTable(Table tbl, const char* argSpec,... )
{
   va_list vl;
   const char *p;
   int c;
   sortSpec.compare = &strcmp;
   sortSpec.column = 0;
   sortSpec.reversed = 0;

   va_start(vl, argSpec);
   if (argSpec)
      for (p=argSpec; *p; p++) {
         switch (*p) {
         case 'o':
            sortSpec.compare = va_arg(vl,CompareFctn);
            break;
         case 'c':
            c = va_arg(vl,int);
            if ( 0<=c && c<tbl->n_cols)
               sortSpec.column  = c;
            break;
         case 'r':
            sortSpec.reversed = (0!=va_arg(vl,int));
            break;
         }
      }
   va_end(vl);
   qsort( tbl->rows, tbl->n_rows, sizeof(String *), CmprRows);
   return 0;
}

void printTable( Table tbl, FILE *fout, const char *colFmts[])
{
   int row, col;

   for (row=0; row<tbl->n_rows; row++) {
      fprintf(fout, "   ");
      for(col=0; col<tbl->n_cols; col++) {
         fprintf(fout, colFmts[col], tbl->rows[row][col]);
      }
      fprintf(fout, "\n");
   }
   fprintf(fout, "\n");
}

int ord(char v)
{
    return v-'0';
}

/* an alternative comparison function */
int cmprStrgs(String s1, String s2)
{
    const char *p1 = s1;
    const char *p2 = s2;
    const char *mrk1, *mrk2;
    while ((tolower(*p1) == tolower(*p2)) && *p1) {
       p1++; p2++;
    }
    if (isdigit(*p1) && isdigit(*p2)) {
        long v1, v2;
        if ((*p1 == '0') ||(*p2 == '0')) {
            while (p1 > s1) {
                p1--; p2--;
                if (*p1 != '0') break;
            }
            if (!isdigit(*p1)) {
                p1++; p2++;
            }
        }
        mrk1 = p1; mrk2 = p2;
        v1 = 0;
        while(isdigit(*p1)) {
            v1 = 10*v1+ord(*p1);
            p1++;
        }
        v2 = 0;
        while(isdigit(*p2)) {
            v2 = 10*v2+ord(*p2);
            p2++;
        }
        if (v1 == v2)
           return(p2-mrk2)-(p1-mrk1);
        return v1 - v2;
    }
    if (tolower(*p1) != tolower(*p2))
       return (tolower(*p1) - tolower(*p2));
    for(p1=s1, p2=s2; (*p1 == *p2) && *p1; p1++, p2++);
    return (*p1 -*p2);
}

int main()
{
   const char *colFmts[] = {" %-5.5s"," %-5.5s"," %-9.9s"};
   String r1[] = { "a101", "red",  "Java" };
   String r2[] = { "ab40", "gren", "Smalltalk" };
   String r3[] = { "ab9",  "blue", "Fortran" };
   String r4[] = { "ab09", "ylow", "Python" };
   String r5[] = { "ab1a", "blak", "Factor" };
   String r6[] = { "ab1b", "brwn", "C Sharp" };
   String r7[] = { "Ab1b", "pink", "Ruby" };
   String r8[] = { "ab1",  "orng", "Scheme" };

   String *rows[] = { r1, r2, r3, r4, r5, r6, r7, r8 };
   struct sTable table;
   table.rows = rows;
   table.n_rows = 8;
   table.n_cols = 3;

   sortTable(&table, "");
   printf("sort on col 0, ascending\n");
   printTable(&table, stdout, colFmts);

   sortTable(&table, "ro", 1, &cmprStrgs);
   printf("sort on col 0, reverse.special\n");
   printTable(&table, stdout, colFmts);

   sortTable(&table, "c", 1);
   printf("sort on col 1, ascending\n");
   printTable(&table, stdout, colFmts);

   sortTable(&table, "cr", 2, 1);
   printf("sort on col 2, reverse\n");
   printTable(&table, stdout, colFmts);
   return 0;
}
`,`#include "optional-parameters.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _CmprRows(long *param_1,long *param_2)

{
  undefined8 uVar1;
  undefined8 local_58;
  
  if (_DAT_10000800c == 0) {
    uVar1 = *(undefined8 *)(*param_1 + (long)_DAT_100008008 * 8);
    local_58 = *(undefined8 *)(*param_2 + (long)_DAT_100008008 * 8);
  }
  else {
    uVar1 = *(undefined8 *)(*param_2 + (long)_DAT_100008008 * 8);
    local_58 = *(undefined8 *)(*param_1 + (long)_DAT_100008008 * 8);
  }
  (*__sortSpec)(uVar1,local_58);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 _sortTable(undefined8 *param_1,char *param_2)

{
  int iVar1;
  char cVar2;
  char *local_30;
  
  __sortSpec = PTR__strcmp_100004038;
  _DAT_100008008 = 0;
  _DAT_10000800c = 0;
  local_30 = param_2;
  if (param_2 != (char *)0x0) {
    for (; *local_30 != '\0'; local_30 = local_30 + 1) {
      cVar2 = *local_30;
      if (cVar2 == 'c') {
        iVar1 = *(int *)register0x00000008;
        register0x00000008 = (BADSPACEBASE *)((long)register0x00000008 + 8);
        if ((-1 < iVar1) && (iVar1 < *(int *)((long)param_1 + 0xc))) {
          _DAT_100008008 = iVar1;
        }
      }
      else if (cVar2 == 'o') {
        __sortSpec = *(undefined **)register0x00000008;
        register0x00000008 = (BADSPACEBASE *)((long)register0x00000008 + 8);
      }
      else if (cVar2 == 'r') {
        iVar1 = *(int *)register0x00000008;
        register0x00000008 = (BADSPACEBASE *)((long)register0x00000008 + 8);
        _DAT_10000800c = (uint)(iVar1 != 0);
      }
    }
  }
  _qsort((void *)*param_1,(long)*(int *)(param_1 + 1),8,(int *)_CmprRows);
  return 0;
}



int _printTable(long param_1,FILE *param_2,long param_3)

{
  int iVar1;
  int local_30;
  int local_2c;
  
  for (local_2c = 0; local_2c < *(int *)(param_1 + 8); local_2c = local_2c + 1) {
    _fprintf(param_2,"   ");
    for (local_30 = 0; local_30 < *(int *)(param_1 + 0xc); local_30 = local_30 + 1) {
      _fprintf(param_2,*(char **)(param_3 + (long)local_30 * 8));
    }
    _fprintf(param_2,"\n");
  }
  iVar1 = _fprintf(param_2,"\n");
  return iVar1;
}



int _ord(char param_1)

{
  return param_1 + -0x30;
}



int _cmprStrgs(char *param_1,char *param_2)

{
  char *pcVar1;
  char *pcVar2;
  bool bVar3;
  int iVar4;
  int iVar5;
  long local_58;
  long local_50;
  char *local_38;
  char *local_30;
  int local_14;
  
  local_38 = param_2;
  local_30 = param_1;
  while( true ) {
    iVar4 = _tolower((int)*local_30);
    iVar5 = _tolower((int)*local_38);
    bVar3 = false;
    if (iVar4 == iVar5) {
      bVar3 = *local_30 != '\0';
    }
    if (!bVar3) break;
    local_30 = local_30 + 1;
    local_38 = local_38 + 1;
  }
  iVar4 = _isdigit((int)*local_30);
  if ((iVar4 == 0) || (iVar4 = _isdigit((int)*local_38), iVar4 == 0)) {
    iVar4 = _tolower((int)*local_30);
    iVar5 = _tolower((int)*local_38);
    pcVar1 = param_2;
    pcVar2 = param_1;
    if (iVar4 == iVar5) {
      while( true ) {
        local_30 = pcVar2;
        local_38 = pcVar1;
        bVar3 = false;
        if (*local_30 == *local_38) {
          bVar3 = *local_30 != '\0';
        }
        if (!bVar3) break;
        pcVar1 = local_38 + 1;
        pcVar2 = local_30 + 1;
      }
      local_14 = (int)*local_30 - (int)*local_38;
    }
    else {
      local_14 = _tolower((int)*local_30);
      iVar4 = _tolower((int)*local_38);
      local_14 = local_14 - iVar4;
    }
  }
  else {
    if ((*local_30 == '0') || (*local_38 == '0')) {
      do {
        if (local_30 <= param_1) break;
        local_30 = local_30 + -1;
        local_38 = local_38 + -1;
      } while (*local_30 == '0');
      iVar4 = _isdigit((int)*local_30);
      if (iVar4 == 0) {
        local_30 = local_30 + 1;
        local_38 = local_38 + 1;
      }
    }
    pcVar2 = local_30;
    pcVar1 = local_38;
    local_50 = 0;
    while (iVar4 = _isdigit((int)*local_30), iVar4 != 0) {
      iVar4 = _ord((long)*local_30);
      local_50 = local_50 * 10 + (long)iVar4;
      local_30 = local_30 + 1;
    }
    local_58 = 0;
    while (iVar4 = _isdigit((int)*local_38), iVar4 != 0) {
      iVar4 = _ord((long)*local_38);
      local_58 = local_58 * 10 + (long)iVar4;
      local_38 = local_38 + 1;
    }
    if (local_50 == local_58) {
      local_14 = ((int)local_38 - (int)pcVar1) - ((int)local_30 - (int)pcVar2);
    }
    else {
      local_14 = (int)local_50 - (int)local_58;
    }
  }
  return local_14;
}



undefined8 entry(void)

{
  undefined *puVar1;
  undefined8 **local_198;
  undefined4 local_190;
  undefined4 local_18c;
  undefined4 local_184;
  char **local_180;
  char **local_178;
  char **local_170;
  char **local_168;
  char **local_160;
  char **local_158;
  char **local_150;
  char **local_148;
  char *local_140;
  char *pcStack_138;
  char *local_130;
  char *local_120;
  char *pcStack_118;
  char *local_110;
  char *local_100;
  char *pcStack_f8;
  char *local_f0;
  char *local_e0;
  char *pcStack_d8;
  char *local_d0;
  char *local_c0;
  char *pcStack_b8;
  char *local_b0;
  char *local_a0;
  char *pcStack_98;
  char *local_90;
  char *local_80;
  char *pcStack_78;
  char *local_70;
  char *local_60;
  char *pcStack_58;
  char *local_50;
  char *local_40;
  char *pcStack_38;
  char *local_30;
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_184 = 0;
  pcStack_38 = " %-5.5s";
  local_40 = " %-5.5s";
  local_30 = " %-9.9s";
  local_180 = &local_60;
  pcStack_58 = "red";
  local_60 = "a101";
  local_50 = "Java";
  local_178 = &local_80;
  pcStack_78 = "gren";
  local_80 = "ab40";
  local_70 = "Smalltalk";
  local_170 = &local_a0;
  pcStack_98 = "blue";
  local_a0 = "ab9";
  local_90 = "Fortran";
  local_168 = &local_c0;
  pcStack_b8 = "ylow";
  local_c0 = "ab09";
  local_b0 = "Python";
  local_160 = &local_e0;
  pcStack_d8 = "blak";
  local_e0 = "ab1a";
  local_d0 = "Factor";
  local_158 = &local_100;
  pcStack_f8 = "brwn";
  local_100 = "ab1b";
  local_f0 = "C Sharp";
  local_150 = &local_120;
  pcStack_118 = "pink";
  local_120 = "Ab1b";
  local_110 = "Ruby";
  local_148 = &local_140;
  pcStack_138 = "orng";
  local_140 = "ab1";
  local_130 = "Scheme";
  local_198 = &local_180;
  local_190 = 8;
  local_18c = 3;
  _sortTable(&local_198,"");
  _printf("sort on col 0, ascending\n");
  puVar1 = PTR____stdoutp_100004010;
  _printTable(&local_198,*(undefined8 *)PTR____stdoutp_100004010,&local_40);
  _sortTable(&local_198,"ro");
  _printf("sort on col 0, reverse.special\n");
  _printTable(&local_198,*(undefined8 *)puVar1,&local_40);
  _sortTable(&local_198,"c");
  _printf("sort on col 1, ascending\n");
  _printTable(&local_198,*(undefined8 *)puVar1,&local_40);
  _sortTable(&local_198,"cr");
  _printf("sort on col 2, reverse\n");
  _printTable(&local_198,*(undefined8 *)puVar1,&local_40);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isdigit(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isdigit_100004020)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tolower(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tolower_100004040)(_c);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int(*cmp_func)(const void*, const void*);

void perm_sort(void *a, int n, size_t msize, cmp_func _cmp)
{
	char *p, *q, *tmp = malloc(msize);
#	define A(i) ((char *)a + msize * (i))
#	define swap(a, b) {\
		memcpy(tmp, a, msize);\
		memcpy(a, b, msize);\
		memcpy(b, tmp, msize);	}
	while (1) {
		/* find largest k such that a[k - 1] < a[k] */
		for (p = A(n - 1); (void*)p > a; p = q)
			if (_cmp(q = p - msize, p) > 0)
				break;

		if ((void*)p <= a) break;

		/* find largest l such that a[l] > a[k - 1] */
		for (p = A(n - 1); p > q; p-= msize)
			if (_cmp(q, p) > 0) break;

		swap(p, q); /* swap a[k - 1], a[l] */
		/* flip a[k] through a[end] */
		for (q += msize, p = A(n - 1); q < p; q += msize, p -= msize)
			swap(p, q);
	}
	free(tmp);
}

int scmp(const void *a, const void *b) { return strcmp(*(const char *const *)a, *(const char *const *)b); }

int main()
{
	int i;
	const char *strs[] = { "spqr", "abc", "giant squid", "stuff", "def" };
	perm_sort(strs, 5, sizeof(*strs), scmp);

	for (i = 0; i < 5; i++)
		printf("%s\n", strs[i]);
	return 0;
}
`,`#include "sorting-algorithms-permutation-sort.h"



void _perm_sort(ulong param_1,int param_2,size_t param_3,code *param_4)

{
  ulong uVar1;
  int iVar2;
  void *pvVar3;
  ulong local_40;
  ulong local_38;
  
  pvVar3 = _malloc(param_3);
  do {
    uVar1 = param_1 + param_3 * (long)(param_2 + -1);
    do {
      local_38 = uVar1;
      if (local_38 <= param_1) break;
      local_40 = local_38 - param_3;
      iVar2 = (*param_4)(local_40,local_38);
      uVar1 = local_40;
    } while (iVar2 < 1);
    if (local_38 <= param_1) {
      _free(pvVar3);
      return;
    }
    local_38 = param_1 + param_3 * (long)(param_2 + -1);
    while ((local_40 < local_38 && (iVar2 = (*param_4)(local_40,local_38), iVar2 < 1))) {
      local_38 = local_38 - param_3;
    }
    ___memcpy_chk(pvVar3,local_38,param_3);
    ___memcpy_chk(local_38,local_40,param_3,0xffffffffffffffff);
    ___memcpy_chk(local_40,pvVar3,param_3,0xffffffffffffffff);
    for (local_38 = param_1 + param_3 * (long)(param_2 + -1); local_40 = local_40 + param_3,
        local_40 < local_38; local_38 = local_38 - param_3) {
      ___memcpy_chk(pvVar3,local_38,param_3);
      ___memcpy_chk(local_38,local_40,param_3,0xffffffffffffffff);
      ___memcpy_chk(local_40,pvVar3,param_3,0xffffffffffffffff);
    }
  } while( true );
}



int _scmp(undefined8 *param_1,undefined8 *param_2)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)*param_1,(char *)*param_2);
  return iVar1;
}



undefined8 entry(void)

{
  uint uVar1;
  ulong uVar2;
  int local_48;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  _memcpy(auStack_40,&PTR_s_spqr_100004040,0x28);
  uVar2 = _perm_sort(auStack_40,5,8,_scmp);
  for (local_48 = 0; local_48 < 5; local_48 = local_48 + 1) {
    uVar1 = _printf("%s\n");
    uVar2 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar2);
  }
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004038)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

size_t rprint(char *s, int *x, int len)
{
#define sep (a > s ? "," : "") /* use comma except before first output */
#define ol (s ? 100 : 0)       /* print only if not testing for length */
	int i, j;
	char *a = s;
	for (i = j = 0; i < len; i = ++j) {
		for (; j < len - 1 && x[j + 1] == x[j] + 1; j++);

		if (i + 1 < j)
			a += snprintf(s?a:s, ol, "%s%d-%d", sep, x[i], x[j]);
		else
			while (i <= j)
				a += snprintf(s?a:s, ol, "%s%d", sep, x[i++]);
	}
	return a - s;
#undef sep
#undef ol
}

int main()
{
	int x[] = {	0,  1,  2,  4,  6,  7,  8, 11, 12, 14,
			15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
			25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
			37, 38, 39 };

	char *s = malloc(rprint(0, x, sizeof(x) / sizeof(int)) + 1);
	rprint(s, x, sizeof(x) / sizeof(int));
	printf("%s\n", s);

	return 0;
}
`,`#include "range-extraction.h"



long _rprint(long param_1,long param_2,int param_3)

{
  bool bVar1;
  int iVar2;
  undefined4 uVar3;
  long local_60;
  long local_48;
  long local_38;
  int local_2c;
  int local_28;
  
  local_28 = 0;
  local_38 = param_1;
  while (local_2c = local_28, local_28 < param_3) {
    while( true ) {
      bVar1 = false;
      if (local_2c < param_3 + -1) {
        bVar1 = *(int *)(param_2 + (long)(local_2c + 1) * 4) ==
                *(int *)(param_2 + (long)local_2c * 4) + 1;
      }
      if (!bVar1) break;
      local_2c = local_2c + 1;
    }
    if (local_28 + 1 < local_2c) {
      local_48 = param_1;
      if (param_1 != 0) {
        local_48 = local_38;
      }
      uVar3 = 100;
      if (param_1 == 0) {
        uVar3 = 0;
      }
      iVar2 = ___snprintf_chk(local_48,uVar3,0,0xffffffffffffffff,"%s%d-%d");
      local_38 = local_38 + iVar2;
    }
    else {
      while (local_28 <= local_2c) {
        local_60 = param_1;
        if (param_1 != 0) {
          local_60 = local_38;
        }
        uVar3 = 100;
        if (param_1 == 0) {
          uVar3 = 0;
        }
        local_28 = local_28 + 1;
        iVar2 = ___snprintf_chk(local_60,uVar3,0,0xffffffffffffffff,"%s%d");
        local_38 = local_38 + iVar2;
      }
    }
    local_28 = local_2c + 1;
  }
  return local_38 - param_1;
}



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  void *pvVar3;
  undefined auStack_9c [132];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  _memcpy(auStack_9c,&PTR___mh_execute_header_100003f24,0x84);
  lVar2 = _rprint(0,auStack_9c);
  pvVar3 = _malloc(lVar2 + 1);
  _rprint(pvVar3,auStack_9c,0x21);
  iVar1 = _printf("%s\n");
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___snprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____snprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>

#define MAX_DIGITS 9

int digits[MAX_DIGITS];

void getDigits(int i) {
    int ix = 0;
    while (i > 0) {
        digits[ix++] = i % 10;
        i /= 10;
    }
}

int main() {
    int n, d, i, max, lastDigit, sum, dp;
    int powers[10] = {0, 1, 4, 9, 16, 25, 36, 49, 64, 81};
    printf("Own digits power sums for N = 3 to 9 inclusive:\n");
    for (n = 3; n < 10; ++n) {
        for (d = 2; d < 10; ++d) powers[d] *= d;
        i = (int)pow(10, n-1);
        max = i * 10;
        lastDigit = 0;
        while (i < max) {
            if (!lastDigit) {
                getDigits(i);
                sum = 0;
                for (d = 0; d < n; ++d) {
                    dp = digits[d];
                    sum += powers[dp];
                }
            } else if (lastDigit == 1) {
                sum++;
            } else {
                sum += powers[lastDigit] - powers[lastDigit-1];
            }
            if (sum == i) {
                printf("%d\n", i);
                if (lastDigit == 0) printf("%d\n", i + 1);
                i += 10 - lastDigit;
                lastDigit = 0;
            } else if (sum > i) {
                i += 10 - lastDigit;
                lastDigit = 0;
            } else if (lastDigit < 9) {
                i++;
                lastDigit++;
            } else {
                i++;
                lastDigit = 0;
            }
        }
    }
    return 0;
}
`,`#include "own-digits-power-sum-1.h"



void _getDigits(int param_1)

{
  long lVar1;
  int local_8;
  int local_4;
  
  local_8 = 0;
  for (local_4 = param_1; 0 < local_4; local_4 = local_4 / 10) {
    lVar1 = (long)local_8;
    local_8 = local_8 + 1;
    *(int *)(&_digits + lVar1 * 4) = local_4 % 10;
  }
  return;
}



undefined8 entry(void)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  double extraout_d0;
  int local_5c;
  int local_58;
  int local_50;
  int local_4c;
  int local_48;
  int aiStack_40 [10];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(aiStack_40,&PTR___mh_execute_header_100003f40,0x28);
  uVar2 = _printf("Own digits power sums for N = 3 to 9 inclusive:\n");
  uVar3 = (ulong)uVar2;
  for (local_48 = 3; local_48 < 10; local_48 = local_48 + 1) {
    for (local_4c = 2; local_4c < 10; local_4c = local_4c + 1) {
      aiStack_40[local_4c] = aiStack_40[local_4c] * local_4c;
    }
    uVar3 = _pow(0x4024000000000000,(double)(local_48 + -1));
    local_50 = (int)extraout_d0;
    iVar1 = local_50 * 10;
    local_58 = 0;
    while (local_50 < iVar1) {
      if (local_58 == 0) {
        uVar3 = _getDigits(local_50);
        local_5c = 0;
        for (local_4c = 0; local_4c < local_48; local_4c = local_4c + 1) {
          local_5c = local_5c + aiStack_40[*(int *)(&_digits + (long)local_4c * 4)];
        }
      }
      else if (local_58 == 1) {
        local_5c = local_5c + 1;
      }
      else {
        local_5c = local_5c + (aiStack_40[local_58] - aiStack_40[local_58 + -1]);
      }
      if (local_5c == local_50) {
        uVar2 = _printf("%d\n");
        if (local_58 == 0) {
          uVar2 = _printf("%d\n");
        }
        uVar3 = (ulong)uVar2;
        local_50 = local_50 + (10 - local_58);
        local_58 = 0;
      }
      else if (local_50 < local_5c) {
        local_50 = local_50 + (10 - local_58);
        local_58 = 0;
      }
      else {
        if (local_58 < 9) {
          local_58 = local_58 + 1;
        }
        else {
          local_58 = 0;
        }
        local_50 = local_50 + 1;
      }
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(uVar3);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

#define twidth 5
#define mdr(rmdr, rmp, n)\
    do { *rmp = 0; _mdr(rmdr, rmp, n); } while (0)

void _mdr(int *rmdr, int *rmp, long long n)
{
    /* Adjust r if 0 case, so we don't return 1 */
    int r = n ? 1 : 0;
    while (n) {
        r *= (n % 10);
        n /= 10;
    }

    (*rmp)++;
    if (r >= 10)
        _mdr(rmdr, rmp, r);
    else
        *rmdr = r;
}

int main(void)
{
    int i, j, vmdr, vmp;
    const int values[] = { 123321, 7739, 893, 899998 };
    const int vsize    = sizeof(values) / sizeof(values[0]);

    /* Initial test values */
    printf("Number    MDR    MP\n");
    for (i = 0; i < vsize; ++i) {
        mdr(&vmdr, &vmp, values[i]);
        printf("%6d   %3d   %3d\n", values[i], vmdr, vmp);
    }

    /* Determine table values */
    int table[10][twidth] = { 0 };
    int tfill[10]         = { 0 };
    int total             = 0;
    for (i = 0; total < 10 * twidth; ++i) {
        mdr(&vmdr, &vmp, i);
        if (tfill[vmdr] < twidth) {
            table[vmdr][tfill[vmdr]++] = i;
            total++;
        }
    }

    /* Print calculated table values */
    printf("\nMDR: [n0..n4]\n");
    for (i = 0; i < 10; ++i) {
        printf("%3d: [", i);
        for (j = 0; j < twidth; ++j)
            printf("%d%s", table[i][j], j != twidth - 1 ? ", " : "");
        printf("]\n");
    }

    return 0;
}
`,`#include "digital-root-multiplicative-digital-root.h"



void __mdr(uint *param_1,int *param_2,long param_3)

{
  uint local_2c;
  long local_28;
  
  local_2c = (uint)(param_3 != 0);
  for (local_28 = param_3; local_28 != 0; local_28 = local_28 / 10) {
    local_2c = local_2c * ((int)local_28 + (int)(local_28 / 10) * -10);
  }
  *param_2 = *param_2 + 1;
  if ((int)local_2c < 10) {
    *param_1 = local_2c;
  }
  else {
    __mdr(param_1,param_2,(long)(int)local_2c);
  }
  return;
}



undefined8 entry(void)

{
  int iVar1;
  int local_14c;
  undefined4 local_144;
  int local_140;
  int local_13c;
  int local_138;
  undefined4 local_134;
  int aiStack_130 [10];
  int aiStack_108 [50];
  int local_40 [6];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_134 = 0;
  local_40[2] = 0x37d;
  local_40[3] = 0xdbb9e;
  local_40[0] = 0x1e1b9;
  local_40[1] = 0x1e3b;
  _printf("Number    MDR    MP\n");
  for (local_138 = 0; local_138 < 4; local_138 = local_138 + 1) {
    local_144 = 0;
    __mdr(&local_140,&local_144,(long)local_40[local_138]);
    _printf("%6d   %3d   %3d\n");
  }
  _memset(aiStack_108,0,200);
  _memset(aiStack_130,0,0x28);
  local_14c = 0;
  local_138 = 0;
  while (local_14c < 0x32) {
    local_144 = 0;
    __mdr(&local_140,&local_144,(long)local_138);
    if (aiStack_130[local_140] < 5) {
      iVar1 = aiStack_130[local_140];
      aiStack_130[local_140] = iVar1 + 1;
      aiStack_108[(long)local_140 * 5 + (long)iVar1] = local_138;
      local_14c = local_14c + 1;
    }
    local_138 = local_138 + 1;
  }
  iVar1 = _printf("\nMDR: [n0..n4]\n");
  for (local_138 = 0; local_138 < 10; local_138 = local_138 + 1) {
    _printf("%3d: [");
    for (local_13c = 0; local_13c < 5; local_13c = local_13c + 1) {
      _printf("%d%s");
    }
    iVar1 = _printf("]\n");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004010)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main(int argc, char **argv) {

   int user1 = 0, user2 = 0;
   printf("Enter two integers.  Space delimited, please:  ");
   scanf("%d %d",&user1, &user2);
   int array[user1][user2];
   array[user1/2][user2/2] = user1 + user2;
   printf("array[%d][%d] is %d\n",user1/2,user2/2,array[user1/2][user2/2]);

   return 0;
}
`,`#include "create-a-two-dimensional-array-at-runtime-1.h"



undefined4 entry(undefined4 param_1,undefined8 param_2)

{
  uint uVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  int iVar5;
  ulong auStack_a0 [2];
  uint *local_90 [2];
  uint auStack_80 [2];
  uint *local_78;
  uint *local_70;
  ulong local_68;
  ulong local_60;
  ulong local_58;
  undefined4 local_4c;
  ulong local_48;
  ulong local_40;
  undefined *local_38;
  uint local_30;
  uint local_2c;
  undefined8 local_28;
  undefined4 local_20;
  undefined4 local_1c;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_1c = 0;
  local_78 = &local_2c;
  local_2c = 0;
  local_70 = &local_30;
  local_30 = 0;
  local_28 = param_2;
  local_20 = param_1;
  _printf("Enter two integers.  Space delimited, please:  ");
  local_90[0] = local_78;
  local_90[1] = local_70;
  iVar5 = _scanf("%d %d");
  local_60 = (ulong)local_2c;
  local_58 = (ulong)local_30;
  local_68 = local_60 * local_58 * 4 + 0xf & 0xfffffffffffffff0;
  local_38 = (undefined *)auStack_80;
  (*(code *)PTR____chkstk_darwin_100004000)(iVar5);
  uVar4 = local_58;
  lVar3 = -local_68;
  local_40 = local_60;
  local_48 = local_58;
  *(uint *)((long)auStack_80 +
           (long)((int)local_30 / 2) * 4 + (long)((int)local_2c / 2) * local_58 * 4 + lVar3 + -0x80
           + 0x80) = local_2c + local_30;
  uVar2 = (int)local_30 / 2;
  uVar1 = *(uint *)((long)auStack_80 +
                   (long)((int)local_30 / 2) * 4 +
                   (long)((int)local_2c / 2) * uVar4 * 4 + lVar3 + -0x80 + 0x80);
  *(ulong *)((long)auStack_a0 + lVar3) = (ulong)(uint)((int)local_2c / 2);
  *(ulong *)((long)auStack_a0 + lVar3 + 8) = (ulong)uVar2;
  *(ulong *)((long)local_90 + lVar3) = (ulong)uVar1;
  iVar5 = _printf("array[%d][%d] is %d\n");
  local_1c = 0;
  local_4c = 0;
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar5);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

void get_div_cnt(int n){
	int lmt,f,divcnt,divsum;
	divsum = 1;
	divcnt = 1;
	lmt = n/2;
    f = 2;
	for (;;) {
	  if (f > lmt ) break;
	  if (!(n % f)){
		  divsum +=f;
		  divcnt++;
	  }
	  if (divsum == n) break;
      f++;
	}
    printf("%8d equals the sum of its first %d divisors\n", n, divcnt);	
}

int main() {
    const int maxNumber = 100*1000*1000;
    int *dsum = (int *)malloc((maxNumber + 1) * sizeof(int));
    int i, j;
    for (i = 0; i <= maxNumber; ++i) {
        dsum[i] = 1;
    }
    for (i = 2; i <= maxNumber; ++i) {
        for (j = i + i; j <= maxNumber; j += i) {
        if (dsum[j] == j) get_div_cnt(j);
        dsum[j] += i;
        }
    }
    free(dsum);
    return 0;
}
`,`#include "erd-s-nicolas-numbers-2.h"



int _get_div_cnt(int param_1)

{
  int iVar1;
  int local_24;
  int local_1c;
  
  local_24 = 1;
  for (local_1c = 2; local_1c <= param_1 / 2; local_1c = local_1c + 1) {
    iVar1 = 0;
    if (local_1c != 0) {
      iVar1 = param_1 / local_1c;
    }
    if (param_1 == iVar1 * local_1c) {
      local_24 = local_24 + local_1c;
    }
    if (local_24 == param_1) break;
  }
  iVar1 = _printf("%8d equals the sum of its first %d divisors\n");
  return iVar1;
}



undefined8 entry(void)

{
  int *piVar1;
  void *pvVar2;
  undefined4 local_28;
  undefined4 local_24;
  
  pvVar2 = _malloc(0x17d78404);
  for (local_24 = 0; local_24 < 0x5f5e101; local_24 = local_24 + 1) {
    *(undefined4 *)((long)pvVar2 + (long)local_24 * 4) = 1;
  }
  for (local_24 = 2; local_24 < 0x5f5e101; local_24 = local_24 + 1) {
    for (local_28 = local_24 * 2; local_28 < 0x5f5e101; local_28 = local_28 + local_24) {
      if (*(int *)((long)pvVar2 + (long)local_28 * 4) == local_28) {
        _get_div_cnt(local_28);
      }
      piVar1 = (int *)((long)pvVar2 + (long)local_28 * 4);
      *piVar1 = *piVar1 + local_24;
    }
  }
  _free(pvVar2);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`const char   foo     = 'a';
const double pi      = 3.14159;
const double minsize = 10;
const double maxsize = 10;

// On pointers
const int *       ptrToConst;      // The value is constant, but the pointer may change.
int const *       ptrToConst;      // The value is constant, but the pointer may change. (Identical to the above.)
int       * const constPtr;        // The pointer is constant, but the value may change.
int const * const constPtrToConst; // Both the pointer and value are constant.

// On parameters
int main(const int    argc, // note that here, the "const", applied to the integer argument itself,
                            // is kind of pointless, as arguments are passed by value, so
                            // it does not affect any code outside of the function
         const char** argv)
{
    /* ... */
}
`,`#include "enforced-immutability-2.h"



undefined8 entry(void)

{
  return 0;
}


`
`#include<stdlib.h>
#include<string.h>
#include<stdio.h>

int main(int argc, char** argv)
{
	int i,j,sandPileEdge, centerPileHeight, processAgain = 1,top,down,left,right;	
	int** sandPile;
	char* fileName;
	static unsigned char colour[3];

	if(argc!=3){
		printf("Usage: %s <Sand pile side> <Center pile height>",argv[0]);
		return 0;
	}

	sandPileEdge = atoi(argv[1]);
	centerPileHeight = atoi(argv[2]);

	if(sandPileEdge<=0 || centerPileHeight<=0){
		printf("Sand pile and center pile dimensions must be positive integers.");
		return 0;
	}

	sandPile = (int**)malloc(sandPileEdge * sizeof(int*));

	for(i=0;i<sandPileEdge;i++){
		sandPile[i] = (int*)calloc(sandPileEdge,sizeof(int));
	}

	sandPile[sandPileEdge/2][sandPileEdge/2] = centerPileHeight;

	printf("Initial sand pile :\n\n");

	for(i=0;i<sandPileEdge;i++){
		for(j=0;j<sandPileEdge;j++){
			printf("%3d",sandPile[i][j]);
		}
		printf("\n");
	}

	while(processAgain == 1){

		processAgain = 0;
		top = 0;
		down = 0;
		left = 0;
		right = 0;

		for(i=0;i<sandPileEdge;i++){
			for(j=0;j<sandPileEdge;j++){
				if(sandPile[i][j]>=4){				
					if(i-1>=0){
						top = 1;
						sandPile[i-1][j]+=1;
						if(sandPile[i-1][j]>=4)
							processAgain = 1;
					}
					if(i+1<sandPileEdge){
						down = 1;
						sandPile[i+1][j]+=1;
						if(sandPile[i+1][j]>=4)
							processAgain = 1;
					}
					if(j-1>=0){
						left = 1;
						sandPile[i][j-1]+=1;
						if(sandPile[i][j-1]>=4)
							processAgain = 1;
					}
					if(j+1<sandPileEdge){
						right = 1;
						sandPile[i][j+1]+=1;
						if(sandPile[i][j+1]>=4)
							processAgain = 1;
					}
				sandPile[i][j] -= (top + down + left + right);
				if(sandPile[i][j]>=4)
					processAgain = 1;
				}
			}
		}
	}

	printf("Final sand pile : \n\n");

	for(i=0;i<sandPileEdge;i++){
		for(j=0;j<sandPileEdge;j++){
			printf("%3d",sandPile[i][j]);
		}
		printf("\n");
	}

	fileName = (char*)malloc((strlen(argv[1]) + strlen(argv[2]) + 23)*sizeof(char));

	strcpy(fileName,"Final_Sand_Pile_");
	strcat(fileName,argv[1]);
	strcat(fileName,"_");
	strcat(fileName,argv[2]);
	strcat(fileName,".ppm");
	
	FILE *fp = fopen(fileName,"wb");

	fprintf(fp,"P6\n%d %d\n255\n",sandPileEdge,sandPileEdge);

	for(i=0;i<sandPileEdge;i++){
		for(j=0;j<sandPileEdge;j++){
			colour[0] = (sandPile[i][j] + i)%256;
			colour[1] = (sandPile[i][j] + j)%256;
			colour[2] = (sandPile[i][j] + i*j)%256;
			fwrite(colour,1,3,fp);
		}
	}
	
	fclose(fp);

	printf("\nImage file written to %s\n",fileName);

	return 0;
}
`,`#include "abelian-sandpile-model.h"



undefined4 entry(int param_1,long param_2)

{
  int *piVar1;
  bool bVar2;
  int iVar3;
  int iVar4;
  void *pvVar5;
  void *pvVar6;
  size_t sVar7;
  size_t sVar8;
  char *pcVar9;
  FILE *pFVar10;
  int local_44;
  int local_40;
  int local_3c;
  int local_38;
  int local_28;
  int local_24;
  
  bVar2 = true;
  if (param_1 == 3) {
    iVar3 = _atoi(*(char **)(param_2 + 8));
    iVar4 = _atoi(*(char **)(param_2 + 0x10));
    if ((iVar3 < 1) || (iVar4 < 1)) {
      _printf("Sand pile and center pile dimensions must be positive integers.");
    }
    else {
      pvVar5 = _malloc((long)iVar3 << 3);
      for (local_24 = 0; local_24 < iVar3; local_24 = local_24 + 1) {
        pvVar6 = _calloc((long)iVar3,4);
        *(void **)((long)pvVar5 + (long)local_24 * 8) = pvVar6;
      }
      *(int *)(*(long *)((long)pvVar5 + (long)(iVar3 / 2) * 8) + (long)(iVar3 / 2) * 4) = iVar4;
      _printf("Initial sand pile :\n\n");
      for (local_24 = 0; local_24 < iVar3; local_24 = local_24 + 1) {
        for (local_28 = 0; local_28 < iVar3; local_28 = local_28 + 1) {
          _printf("%3d");
        }
        _printf("\n");
      }
      while (bVar2) {
        bVar2 = false;
        local_38 = 0;
        local_3c = 0;
        local_40 = 0;
        local_44 = 0;
        for (local_24 = 0; local_24 < iVar3; local_24 = local_24 + 1) {
          for (local_28 = 0; local_28 < iVar3; local_28 = local_28 + 1) {
            if (3 < *(int *)(*(long *)((long)pvVar5 + (long)local_24 * 8) + (long)local_28 * 4)) {
              if (-1 < local_24 + -1) {
                local_38 = 1;
                piVar1 = (int *)(*(long *)((long)pvVar5 + (long)(local_24 + -1) * 8) +
                                (long)local_28 * 4);
                *piVar1 = *piVar1 + 1;
                if (3 < *(int *)(*(long *)((long)pvVar5 + (long)(local_24 + -1) * 8) +
                                (long)local_28 * 4)) {
                  bVar2 = true;
                }
              }
              if (local_24 + 1 < iVar3) {
                local_3c = 1;
                piVar1 = (int *)(*(long *)((long)pvVar5 + (long)(local_24 + 1) * 8) +
                                (long)local_28 * 4);
                *piVar1 = *piVar1 + 1;
                if (3 < *(int *)(*(long *)((long)pvVar5 + (long)(local_24 + 1) * 8) +
                                (long)local_28 * 4)) {
                  bVar2 = true;
                }
              }
              if (-1 < local_28 + -1) {
                local_40 = 1;
                piVar1 = (int *)(*(long *)((long)pvVar5 + (long)local_24 * 8) +
                                (long)(local_28 + -1) * 4);
                *piVar1 = *piVar1 + 1;
                if (3 < *(int *)(*(long *)((long)pvVar5 + (long)local_24 * 8) +
                                (long)(local_28 + -1) * 4)) {
                  bVar2 = true;
                }
              }
              if (local_28 + 1 < iVar3) {
                local_44 = 1;
                piVar1 = (int *)(*(long *)((long)pvVar5 + (long)local_24 * 8) +
                                (long)(local_28 + 1) * 4);
                *piVar1 = *piVar1 + 1;
                if (3 < *(int *)(*(long *)((long)pvVar5 + (long)local_24 * 8) +
                                (long)(local_28 + 1) * 4)) {
                  bVar2 = true;
                }
              }
              piVar1 = (int *)(*(long *)((long)pvVar5 + (long)local_24 * 8) + (long)local_28 * 4);
              *piVar1 = *piVar1 - (local_38 + local_3c + local_40 + local_44);
              if (3 < *(int *)(*(long *)((long)pvVar5 + (long)local_24 * 8) + (long)local_28 * 4)) {
                bVar2 = true;
              }
            }
          }
        }
      }
      _printf("Final sand pile : \n\n");
      for (local_24 = 0; local_24 < iVar3; local_24 = local_24 + 1) {
        for (local_28 = 0; local_28 < iVar3; local_28 = local_28 + 1) {
          _printf("%3d");
        }
        _printf("\n");
      }
      sVar7 = _strlen(*(char **)(param_2 + 8));
      sVar8 = _strlen(*(char **)(param_2 + 0x10));
      pcVar9 = (char *)_malloc(sVar7 + sVar8 + 0x17);
      ___strcpy_chk(pcVar9,"Final_Sand_Pile_");
      ___strcat_chk(pcVar9,*(undefined8 *)(param_2 + 8),0xffffffffffffffff);
      ___strcat_chk(pcVar9,"_",0xffffffffffffffff);
      ___strcat_chk(pcVar9,*(undefined8 *)(param_2 + 0x10),0xffffffffffffffff);
      ___strcat_chk(pcVar9,".ppm",0xffffffffffffffff);
      pFVar10 = _fopen(pcVar9,"wb");
      _fprintf(pFVar10,"P6\n%d %d\n255\n");
      for (local_24 = 0; local_24 < iVar3; local_24 = local_24 + 1) {
        for (local_28 = 0; local_28 < iVar3; local_28 = local_28 + 1) {
          DAT_100008000 =
               (char)*(undefined4 *)
                      (*(long *)((long)pvVar5 + (long)local_24 * 8) + (long)local_28 * 4) +
               (char)local_24;
          DAT_100008001 =
               (char)*(undefined4 *)
                      (*(long *)((long)pvVar5 + (long)local_24 * 8) + (long)local_28 * 4) +
               (char)local_28;
          DAT_100008002 =
               (char)*(undefined4 *)
                      (*(long *)((long)pvVar5 + (long)local_24 * 8) + (long)local_28 * 4) +
               (char)local_24 * (char)local_28;
          _fwrite(&DAT_100008000,1,3,pFVar10);
        }
      }
      _fclose(pFVar10);
      _printf("\nImage file written to %s\n");
    }
  }
  else {
    _printf("Usage: %s <Sand pile side> <Center pile height>");
  }
  return 0;
}



void ___strcat_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcat_chk_100004000)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e80. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004028)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fwrite(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fwrite_100004038)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004040)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004050)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>	// for exit()
#include <signal.h>
#include <time.h>	// for clock()
#include <unistd.h>	// for POSIX usleep()

volatile sig_atomic_t gotint = 0;

void handleSigint() {
    /*
     * Signal safety: It is not safe to call clock(), printf(),
     * or exit() inside a signal handler. Instead, we set a flag.
     */
    gotint = 1;
}

int main() {
    clock_t startTime = clock();
    signal(SIGINT, handleSigint);
    int i=0;
    for (;;) {
        if (gotint)
            break;
        usleep(500000);
        if (gotint)
            break;
	printf("%d\n", ++i);
    }
    clock_t endTime = clock();
    double td = (endTime - startTime) / (double)CLOCKS_PER_SEC;
    printf("Program has run for %5.3f seconds\n", td);
    return 0;
}
`,`#include "handle-a-signal.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _handleSigint(void)

{
  __gotint = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(void)

{
  _clock();
  _signal(2);
  while ((__gotint == 0 && (_usleep(500000), __gotint == 0))) {
    _printf("%d\n");
  }
  _clock();
  _printf("Program has run for %5.3f seconds\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

clock_t _clock(void)

{
  clock_t cVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  cVar1 = (*(code *)PTR__clock_100004000)();
  return cVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _signal(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__signal_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _usleep(useconds_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__usleep_100004018)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <getopt.h>

#define NUMLETTERS 26
#define BUFSIZE 4096

char *get_input(void);

int main(int argc, char *argv[])
{
    char const usage[] = "Usage: vinigere [-d] key";
    char sign = 1;
    char const plainmsg[] = "Plain text:  ";
    char const cryptmsg[] = "Cipher text: ";
    bool encrypt = true;
    int opt;

    while ((opt = getopt(argc, argv, "d")) != -1) {
        switch (opt) {
        case 'd':
            sign = -1;
            encrypt = false;
            break;
        default:
            fprintf(stderr, "Unrecogized command line argument:'-%i'\n", opt);
            fprintf(stderr, "\n%s\n", usage);
            return 1;
        }
    }

    if (argc - optind != 1) {
        fprintf(stderr, "%s requires one argument and one only\n", argv[0]);
        fprintf(stderr, "\n%s\n", usage);
        return 1;
    }


    // Convert argument into array of shifts
    char const *const restrict key = argv[optind];
    size_t const keylen = strlen(key);
    char shifts[keylen];

    char const *restrict plaintext = NULL;
    for (size_t i = 0; i < keylen; i++) {
        if (!(isalpha(key[i]))) {
            fprintf(stderr, "Invalid key\n");
            return 2;
        }
        char const charcase = (isupper(key[i])) ? 'A' : 'a';
        // If decrypting, shifts will be negative.
        // This line would turn "bacon" into {1, 0, 2, 14, 13}
        shifts[i] = (key[i] - charcase) * sign;
    }

    do {
        fflush(stdout);
        // Print "Plain text: " if encrypting and "Cipher text:  " if
        // decrypting
        printf("%s", (encrypt) ? plainmsg : cryptmsg);
        plaintext = get_input();
        if (plaintext == NULL) {
            fprintf(stderr, "Error getting input\n");
            return 4;
        }
    } while (strcmp(plaintext, "") == 0); // Reprompt if entry is empty

    size_t const plainlen = strlen(plaintext);

    char* const restrict ciphertext = calloc(plainlen + 1, sizeof *ciphertext);
    if (ciphertext == NULL) {
        fprintf(stderr, "Memory error\n");
        return 5;
    }

    for (size_t i = 0, j = 0; i < plainlen; i++) {
        // Skip non-alphabetical characters
        if (!(isalpha(plaintext[i]))) {
            ciphertext[i] = plaintext[i];
            continue;
        }
        // Check case
        char const charcase = (isupper(plaintext[i])) ? 'A' : 'a';
        // Wrapping conversion algorithm
        ciphertext[i] = ((plaintext[i] + shifts[j] - charcase + NUMLETTERS) % NUMLETTERS) + charcase;
        j = (j+1) % keylen;
    }
    ciphertext[plainlen] = '\0';
    printf("%s%s\n", (encrypt) ? cryptmsg : plainmsg, ciphertext);

    free(ciphertext);
    // Silence warnings about const not being maintained in cast to void*
    free((char*) plaintext);
    return 0;
}
char *get_input(void) {

    char *const restrict buf = malloc(BUFSIZE * sizeof (char));
    if (buf == NULL) {
        return NULL;
    }

    fgets(buf, BUFSIZE, stdin);

    // Get rid of newline
    size_t const len = strlen(buf);
    if (buf[len - 1] == '\n') buf[len - 1] = '\0';

    return buf;
}
`,`#include "vigen-re-cipher.h"



undefined4 entry(int param_1,char *param_2)

{
  ulong uVar1;
  long lVar2;
  void *pvVar3;
  int iVar4;
  char *local_130 [2];
  undefined auStack_120 [4];
  undefined4 local_11c;
  undefined6 *local_118;
  undefined6 *local_110;
  ulong local_108;
  undefined *local_100;
  undefined8 *local_f8;
  undefined8 *local_f0;
  byte local_e1;
  long local_e0;
  ulong local_d8;
  void *local_d0;
  size_t local_c8;
  char local_bd;
  undefined4 local_bc;
  ulong local_b8;
  char *local_b0;
  undefined *local_a0;
  size_t local_98;
  char *local_90;
  uint local_88;
  byte local_82;
  char local_81;
  char *local_80;
  int local_78;
  undefined4 local_74;
  undefined6 local_70;
  undefined2 uStack_6a;
  undefined6 uStack_68;
  undefined6 local_60;
  undefined2 uStack_5a;
  undefined6 uStack_58;
  char local_50 [40];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_74 = 0;
  builtin_strncpy(local_50,"Usage: vinigere [-d] key",0x19);
  local_81 = '\x01';
  local_60 = 0x206e69616c50;
  uStack_5a = 0x6574;
  uStack_58 = 0x20203a7478;
  local_70 = 0x726568706943;
  uStack_6a = 0x7420;
  uStack_68 = 0x203a747865;
  local_82 = 1;
  local_80 = param_2;
  local_78 = param_1;
  while (local_88 = _getopt(local_78,local_80,"d"), local_88 != 0xffffffff) {
    if (local_88 != 100) {
      local_f0 = (undefined8 *)PTR____stderrp_100004018;
      local_130[0] = (char *)(ulong)local_88;
      _fprintf(*(FILE **)PTR____stderrp_100004018,"Unrecogized command line argument:\'-%i\'\n");
      local_130[0] = local_50;
      _fprintf((FILE *)*local_f0,"\n%s\n");
      local_74 = 1;
      goto LAB_100003d48;
    }
    local_81 = -1;
    local_82 = 0;
    local_88 = 100;
  }
  if (local_78 - *(int *)PTR__optind_100004078 == 1) {
    local_90 = *(char **)(local_80 + (long)*(int *)PTR__optind_100004078 * 8);
    local_98 = _strlen(local_90);
    local_108 = local_98 + 0xf & 0xfffffffffffffff0;
    local_a0 = auStack_120;
    (*(code *)PTR____chkstk_darwin_100004000)();
    lVar2 = -local_108;
    local_100 = auStack_120 + lVar2;
    local_b0 = (char *)0x0;
    for (local_b8 = 0; local_b8 < local_98; local_b8 = local_b8 + 1) {
      iVar4 = _isalpha((int)local_90[local_b8]);
      if (iVar4 == 0) {
        _fprintf(*(FILE **)PTR____stderrp_100004018,"Invalid key\n");
        local_74 = 2;
        goto LAB_100003d3c;
      }
      iVar4 = _isupper((int)local_90[local_b8]);
      local_bd = 'A';
      if (iVar4 == 0) {
        local_bd = 'a';
      }
      local_100[local_b8] = (local_90[local_b8] - local_bd) * local_81;
    }
    do {
      _fflush(*(FILE **)PTR____stdoutp_100004028);
      if ((local_82 & 1) == 0) {
        local_110 = &local_70;
      }
      else {
        local_110 = &local_60;
      }
      *(undefined6 **)((long)local_130 + lVar2) = local_110;
      iVar4 = _printf("%s");
      local_b0 = (char *)_get_input(iVar4);
      if (local_b0 == (char *)0x0) {
        _fprintf(*(FILE **)PTR____stderrp_100004018,"Error getting input\n");
        local_74 = 4;
        goto LAB_100003d3c;
      }
      iVar4 = _strcmp(local_b0,"");
    } while (iVar4 == 0);
    local_c8 = _strlen(local_b0);
    local_d0 = _calloc(local_c8 + 1,1);
    if (local_d0 == (void *)0x0) {
      _fprintf(*(FILE **)PTR____stderrp_100004018,"Memory error\n");
      local_74 = 5;
    }
    else {
      local_e0 = 0;
      for (local_d8 = 0; pvVar3 = local_d0, local_d8 < local_c8; local_d8 = local_d8 + 1) {
        iVar4 = _isalpha((int)local_b0[local_d8]);
        if (iVar4 == 0) {
          *(char *)((long)local_d0 + local_d8) = local_b0[local_d8];
        }
        else {
          iVar4 = _isupper((int)local_b0[local_d8]);
          local_e1 = 0x41;
          if (iVar4 == 0) {
            local_e1 = 0x61;
          }
          iVar4 = (((int)local_b0[local_d8] + (int)(char)local_100[local_e0]) - (uint)local_e1) +
                  0x1a;
          *(byte *)((long)local_d0 + local_d8) =
               (char)iVar4 + (char)(iVar4 / 0x1a) * -0x1a + local_e1;
          uVar1 = 0;
          if (local_98 != 0) {
            uVar1 = (local_e0 + 1U) / local_98;
          }
          local_e0 = (local_e0 + 1U) - uVar1 * local_98;
        }
      }
      *(undefined *)((long)local_d0 + local_c8) = 0;
      if ((local_82 & 1) == 0) {
        local_118 = &local_60;
      }
      else {
        local_118 = &local_70;
      }
      *(undefined6 **)((long)local_130 + lVar2) = local_118;
      *(void **)((long)local_130 + lVar2 + 8) = pvVar3;
      _printf("%s%s\n");
      _free(local_d0);
      _free(local_b0);
      local_74 = 0;
    }
LAB_100003d3c:
    local_bc = 1;
  }
  else {
    local_f8 = (undefined8 *)PTR____stderrp_100004018;
    local_130[0] = *(char **)local_80;
    _fprintf(*(FILE **)PTR____stderrp_100004018,"%s requires one argument and one only\n");
    local_130[0] = local_50;
    _fprintf((FILE *)*local_f8,"\n%s\n");
    local_74 = 1;
  }
LAB_100003d48:
  local_11c = local_74;
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return local_74;
}



char * _get_input(void)

{
  size_t sVar1;
  char *local_18;
  
  local_18 = (char *)_malloc(0x1000);
  if (local_18 == (char *)0x0) {
    local_18 = (char *)0x0;
  }
  else {
    _fgets(local_18,0x1000,*(FILE **)PTR____stdinp_100004020);
    sVar1 = _strlen(local_18);
    if (local_18[sVar1 - 1] == '\n') {
      local_18[sVar1 - 1] = '\0';
    }
  }
  return local_18;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e50. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004030)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e68. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004040)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e80. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004050)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getopt(int param_1,char *param_2,char *param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getopt_100004058)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isalpha(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isalpha_100004060)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isupper(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isupper_100004068)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004070)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004080)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004088)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004090)();
  return sVar1;
}


`
`#include <stdio.h>
int main()
{
	printf("\033[6;3HHello\n");
	return 0;
}
`,`#include "terminal-control-cursor-positioning-1.h"



undefined4 entry(void)

{
  _printf("\x1b[6;3HHello\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void last_sunday(struct tm *res, unsigned year, unsigned mon)
{
	time_t sec;

	*res = (struct tm){
		.tm_year = year + mon / 12,
		.tm_mon = mon % 12,
		.tm_hour = 12,
		.tm_isdst = -1
	};
	sec = mktime(res);
	sec -= res->tm_wday * 86400;
	*res = *localtime(&sec);
}

int main(int argc, char *argv[])
{
	struct tm date;
	char str[12];
	unsigned m, y;

	if (argc < 2)
		return 1;
	y = strtoul(argv[1], NULL, 0) - 1900;
	for (m = 1; m <= 12; ++m) {
		last_sunday(&date, y, m);
		strftime(str, sizeof str, "%F", &date);
		puts(str);
	}

	return 0;
}
`,`#include "find-the-last-sunday-of-each-month.h"



void _last_sunday(tm *param_1,int param_2,uint param_3)

{
  tm *ptVar1;
  time_t tVar2;
  tm *ptVar3;
  undefined4 local_60;
  undefined4 local_5c;
  undefined4 local_58;
  undefined4 local_54;
  uint local_50;
  int local_4c;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined8 local_38;
  undefined8 local_30;
  long local_28;
  uint local_20;
  int local_1c;
  tm *local_18;
  
  local_60 = 0;
  local_5c = 0;
  local_58 = 0xc;
  local_54 = 0;
  local_50 = param_3 % 0xc;
  local_4c = param_2 + param_3 / 0xc;
  local_48 = 0;
  local_44 = 0;
  local_40 = 0xffffffff;
  local_38 = 0;
  local_30 = 0;
  local_20 = param_3;
  local_1c = param_2;
  local_18 = param_1;
  _memcpy(param_1,&local_60,0x38);
  tVar2 = _mktime(local_18);
  ptVar1 = local_18;
  local_28 = tVar2 - local_18->tm_wday * 0x15180;
  ptVar3 = _localtime(&local_28);
  _memcpy(ptVar1,ptVar3,0x38);
  return;
}



undefined4 entry(ulong param_1,long param_2)

{
  int iVar1;
  uint uVar2;
  uint local_74;
  tm tStack_70;
  long local_38;
  int local_2c;
  undefined4 local_28;
  char acStack_24 [12];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_28 = 0;
  local_2c = (int)param_1;
  local_38 = param_2;
  if (local_2c < 2) {
    local_28 = 1;
  }
  else {
    param_1 = _strtoul(*(char **)(param_2 + 8),(char **)0x0,0);
    iVar1 = (int)param_1;
    for (local_74 = 1; local_74 < 0xd; local_74 = local_74 + 1) {
      _last_sunday(&tStack_70,iVar1 + -0x76c,local_74);
      _strftime(acStack_24,0xc,"%F",&tStack_70);
      uVar2 = _puts(acStack_24);
      param_1 = (ulong)uVar2;
    }
    local_28 = 0;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return local_28;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * _localtime(time_t *param_1)

{
  tm *ptVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  ptVar1 = (tm *)(*(code *)PTR__localtime_100004010)();
  return ptVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _mktime(tm *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__mktime_100004020)();
  return tVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strftime(char *param_1,size_t param_2,char *param_3,tm *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strftime_100004030)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulong _strtoul(char *param_1,char **param_2,int param_3)

{
  ulong uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__strtoul_100004038)(param_1,param_2,param_3);
  return uVar1;
}


`
`#include <stdlib.h>  /* for qsort */
#include <string.h>  /* for strlen */
#include <strings.h> /* for strcasecmp */

int mycmp(const void *s1, const void *s2)
{
    const char *l = *(const char **)s1, *r = *(const char **)s2;
    size_t ll = strlen(l), lr = strlen(r);

    if (ll > lr) return -1;
    if (ll < lr) return 1;
    return strcasecmp(l, r);
}

int main()
{
    const char *strings[] = {
      "Here", "are", "some", "sample", "strings", "to", "be", "sorted" };

    qsort(strings, sizeof(strings)/sizeof(*strings), sizeof(*strings), mycmp);
    return 0;
}
`,`#include "sort-using-a-custom-comparator.h"



int _mycmp(undefined8 *param_1,undefined8 *param_2)

{
  size_t sVar1;
  size_t sVar2;
  char *pcVar3;
  char *pcVar4;
  undefined4 local_14;
  
  pcVar3 = (char *)*param_1;
  pcVar4 = (char *)*param_2;
  sVar1 = _strlen(pcVar3);
  sVar2 = _strlen(pcVar4);
  if (sVar2 < sVar1) {
    local_14 = -1;
  }
  else if (sVar1 < sVar2) {
    local_14 = 1;
  }
  else {
    local_14 = _strcasecmp(pcVar3,pcVar4);
  }
  return local_14;
}



undefined8 entry(void)

{
  undefined auStack_58 [64];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_58,&PTR_s_Here_100004030,0x40);
  _qsort(auStack_58,8,8,(int *)_mycmp);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcasecmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcasecmp_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004028)();
  return sVar1;
}


`
`/*
 * RossetaCode: Sum to 100, C99, an algorithm using ternary numbers.
 *
 * Find solutions to the "sum to one hundred" puzzle.
 */

#include <stdio.h>
#include <stdlib.h>

/*
 * There are only 13122 (i.e. 2*3**8) different possible expressions,
 * thus we can encode them as positive integer numbers from 0 to 13121.
 */
#define NUMBER_OF_EXPRESSIONS (2 * 3*3*3*3 * 3*3*3*3 )
enum OP { ADD, SUB, JOIN };
typedef int (*cmp)(const void*, const void*);

// Replacing struct Expression and struct CountSum by a tuple like
// struct Pair { int first; int last; } is possible but would make the source
// code less readable.

struct Expression{
    int sum;
    int code;
}expressions[NUMBER_OF_EXPRESSIONS];
int expressionsLength = 0;
int compareExpressionBySum(const struct Expression* a, const struct Expression* b){
    return a->sum - b->sum;
}

struct CountSum{
    int counts;
    int sum;
}countSums[NUMBER_OF_EXPRESSIONS];
int countSumsLength = 0;
int compareCountSumsByCount(const struct CountSum* a, const struct CountSum* b){
    return a->counts - b->counts;
}

int evaluate(int code){
    int value  = 0, number = 0, power  = 1;
    for ( int k = 9; k >= 1; k-- ){
        number = power*k + number;
        switch( code % 3 ){
            case ADD:  value = value + number; number = 0; power = 1; break;
            case SUB:  value = value - number; number = 0; power = 1; break;
            case JOIN: power = power * 10                ; break;
        }
        code /= 3;
    }
    return value;
}

void print(int code){
    static char s[19]; char* p = s;
    int a = 19683, b = 6561;
    for ( int k = 1; k <= 9; k++ ){
        switch((code % a) / b){
            case ADD: if ( k > 1 ) *p++ = '+'; break;
            case SUB:              *p++ = '-'; break;
        }
        a = b;
        b = b / 3;
        *p++ = '0' + k;
    }
    *p = 0;
    printf("%9d = %s\n", evaluate(code), s);
}

void comment(char* string){
    printf("\n\n%s\n\n", string);
}

void init(void){
    for ( int i = 0; i < NUMBER_OF_EXPRESSIONS; i++ ){
        expressions[i].sum = evaluate(i);
        expressions[i].code = i;
    }
    expressionsLength = NUMBER_OF_EXPRESSIONS;
    qsort(expressions,expressionsLength,sizeof(struct Expression),(cmp)compareExpressionBySum);

    int j = 0;
    countSums[0].counts = 1;
    countSums[0].sum = expressions[0].sum;
    for ( int i = 0; i < expressionsLength; i++ ){
        if ( countSums[j].sum != expressions[i].sum ){
            j++;
            countSums[j].counts = 1;
            countSums[j].sum = expressions[i].sum;
        }
        else
            countSums[j].counts++;
    }
    countSumsLength = j + 1;
    qsort(countSums,countSumsLength,sizeof(struct CountSum),(cmp)compareCountSumsByCount);
}

int main(void){

    init();

    comment("Show all solutions that sum to 100");
    const int givenSum = 100;
    struct Expression ex = { givenSum, 0 };
    struct Expression* found;
    if ( found = bsearch(&ex,expressions,expressionsLength,
        sizeof(struct Expression),(cmp)compareExpressionBySum) ){
        while ( found != expressions && (found-1)->sum == givenSum )
            found--;
        while ( found != &expressions[expressionsLength] && found->sum == givenSum )
            print(found++->code);
    }

    comment("Show the positve sum that has the maximum number of solutions");
    int maxSumIndex = countSumsLength - 1;
    while( countSums[maxSumIndex].sum < 0 )
        maxSumIndex--;
    printf("%d has %d solutions\n",
        countSums[maxSumIndex].sum, countSums[maxSumIndex].counts);

    comment("Show the lowest positive number that can't be expressed");
    for ( int value = 0; ; value++ ){
        struct Expression ex = { value, 0 };
        if (!bsearch(&ex,expressions,expressionsLength,
                sizeof(struct Expression),(cmp)compareExpressionBySum)){
            printf("%d\n", value);
            break;
        }
    }

    comment("Show the ten highest numbers that can be expressed");
    for ( int i = expressionsLength-1; i >= expressionsLength-10; i-- )
        print(expressions[i].code);

    return 0;
}
`,`#include "sum-to-100-1.h"



int _compareExpressionBySum(int *param_1,int *param_2)

{
  return *param_1 - *param_2;
}



int _compareCountSumsByCount(int *param_1,int *param_2)

{
  return *param_1 - *param_2;
}



int _evaluate(int param_1)

{
  int iVar1;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = 0;
  local_c = 0;
  local_10 = 1;
  local_4 = param_1;
  for (local_14 = 9; 0 < local_14; local_14 = local_14 + -1) {
    local_c = local_10 * local_14 + local_c;
    iVar1 = local_4 % 3;
    if (iVar1 == 0) {
      local_8 = local_8 + local_c;
      local_c = 0;
      local_10 = 1;
    }
    else if (iVar1 == 1) {
      local_8 = local_8 - local_c;
      local_c = 0;
      local_10 = 1;
    }
    else if (iVar1 == 2) {
      local_10 = local_10 * 10;
    }
    local_4 = local_4 / 3;
  }
  return local_8;
}



int _print(int param_1)

{
  int iVar1;
  int iVar2;
  int local_2c;
  int local_28;
  int local_24;
  char *local_20;
  
  local_20 = &DAT_10003b428;
  local_24 = 0x4ce3;
  local_28 = 0x19a1;
  for (local_2c = 1; local_2c < 10; local_2c = local_2c + 1) {
    iVar2 = 0;
    if (local_24 != 0) {
      iVar2 = param_1 / local_24;
    }
    iVar1 = 0;
    if (local_28 != 0) {
      iVar1 = (param_1 - iVar2 * local_24) / local_28;
    }
    if (iVar1 == 0) {
      if (1 < local_2c) {
        *local_20 = '+';
        local_20 = local_20 + 1;
      }
    }
    else if (iVar1 == 1) {
      *local_20 = '-';
      local_20 = local_20 + 1;
    }
    local_24 = local_28;
    local_28 = local_28 / 3;
    *local_20 = (char)local_2c + '0';
    local_20 = local_20 + 1;
  }
  *local_20 = '\0';
  _evaluate(param_1);
  iVar2 = _printf("%9d = %s\n");
  return iVar2;
}



void _comment(void *ctx,xmlChar *value)

{
  _printf("\n\n%s\n\n");
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _init(void)

{
  undefined4 uVar1;
  int local_1c;
  int local_18;
  int local_14;
  
  for (local_14 = 0; local_14 < 0x3342; local_14 = local_14 + 1) {
    uVar1 = _evaluate(local_14);
    *(undefined4 *)(&_expressions + (long)local_14 * 8) = uVar1;
    *(int *)((long)local_14 * 8 + 0x100021a1c) = local_14;
  }
  __expressionsLength = 0x3342;
  _qsort(&_expressions,0x3342,8,(int *)_compareExpressionBySum);
  local_18 = 0;
  __countSums = 1;
  _DAT_10000800c = __expressions;
  for (local_1c = 0; local_1c < __expressionsLength; local_1c = local_1c + 1) {
    if (*(int *)(&DAT_10000800c + (long)local_18 * 8) ==
        *(int *)(&_expressions + (long)local_1c * 8)) {
      *(int *)(&_countSums + (long)local_18 * 8) = *(int *)(&_countSums + (long)local_18 * 8) + 1;
    }
    else {
      local_18 = local_18 + 1;
      *(undefined4 *)(&_countSums + (long)local_18 * 8) = 1;
      *(undefined4 *)(&DAT_10000800c + (long)local_18 * 8) =
           *(undefined4 *)(&_expressions + (long)local_1c * 8);
    }
  }
  __countSumsLength = local_18 + 1;
  _qsort(&_countSums,(long)__countSumsLength,8,(int *)_compareCountSumsByCount);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(void)

{
  int *piVar1;
  bool bVar2;
  void *pvVar3;
  xmlChar *value;
  xmlChar *pxVar4;
  xmlChar *extraout_x1;
  int local_3c;
  int local_38 [4];
  int *local_28;
  undefined8 local_20;
  undefined4 local_18;
  undefined4 local_14;
  
  local_14 = 0;
  _init();
  _comment("Show all solutions that sum to 100",value);
  local_18 = 100;
  local_20 = 100;
  pxVar4 = &_expressions;
  local_28 = (int *)_bsearch(&local_20,&_expressions,(long)__expressionsLength,8,
                             (int *)_compareExpressionBySum);
  if (local_28 != (int *)0x0) {
    while( true ) {
      bVar2 = false;
      if (local_28 != (int *)&_expressions) {
        bVar2 = local_28[-2] == 100;
      }
      if (!bVar2) break;
      local_28 = local_28 + -2;
    }
    while( true ) {
      bVar2 = false;
      if (local_28 != (int *)(&_expressions + (long)__expressionsLength * 8)) {
        bVar2 = *local_28 == 100;
      }
      if (!bVar2) break;
      piVar1 = local_28 + 1;
      local_28 = local_28 + 2;
      _print(*piVar1);
      pxVar4 = extraout_x1;
    }
  }
  _comment("Show the positve sum that has the maximum number of solutions",pxVar4);
  local_38[3] = __countSumsLength;
  do {
    local_38[3] = local_38[3] + -1;
  } while (*(int *)(&DAT_10000800c + (long)local_38[3] * 8) < 0);
  _printf("%d has %d solutions\n");
  _comment("Show the lowest positive number that can\'t be expressed",pxVar4);
  local_38[2] = 0;
  while( true ) {
    local_38[0] = local_38[2];
    local_38[1] = 0;
    pxVar4 = &_expressions;
    pvVar3 = _bsearch(local_38,&_expressions,(long)__expressionsLength,8,
                      (int *)_compareExpressionBySum);
    if (pvVar3 == (void *)0x0) break;
    local_38[2] = local_38[2] + 1;
  }
  _printf("%d\n");
  _comment("Show the ten highest numbers that can be expressed",pxVar4);
  local_3c = __expressionsLength;
  while (local_3c = local_3c + -1, __expressionsLength + -10 <= local_3c) {
    _print(*(undefined4 *)((long)local_3c * 8 + 0x100021a1c));
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _bsearch(void *param_1,void *param_2,size_t param_3,size_t param_4,int *param_5)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__bsearch_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004010)();
  return;
}


`
`#include <stdlib.h>	/* exit(), free() */
#include <stdio.h>	/* fputs(), perror(), printf() */
#include <string.h>

int
main()
{
	size_t len;
	char src[] = "Hello";
	char dst1[80], dst2[80];
	char *dst3, *ref;

	/*
	 * Option 1. Use strcpy() from <string.h>.
	 *
	 * DANGER! strcpy() can overflow the destination buffer.
	 * strcpy() is only safe if the source string is shorter than
	 * the destination buffer. We know that "Hello" (6 characters
	 * with the final '\0') easily fits in dst1 (80 characters).
	 */
	strcpy(dst1, src);

	/*
	 * Option 2. Use strlen() and memcpy() from <string.h>, to copy
	 * strlen(src) + 1 bytes including the final '\0'.
	 */
	len = strlen(src);
	if (len >= sizeof dst2) {
		fputs("The buffer is too small!\n", stderr);
		exit(1);
	}
	memcpy(dst2, src, len + 1);

	/*
	 * Option 3. Use strdup() from <string.h>, to allocate a copy.
	 */
	dst3 = strdup(src);
	if (dst3 == NULL) {
		/* Failed to allocate memory! */
		perror("strdup");
		exit(1);
	}

	/* Create another reference to the source string. */
	ref = src;

	/* Modify the source string, not its copies. */
	memset(src, '-', 5);

	printf(" src: %s\n", src);   /*  src: ----- */
	printf("dst1: %s\n", dst1);  /* dst1: Hello */
	printf("dst2: %s\n", dst2);  /* dst2: Hello */
	printf("dst3: %s\n", dst3);  /* dst3: Hello */
	printf(" ref: %s\n", ref);   /*  ref: ----- */

	/* Free memory from strdup(). */
	free(dst3);

	return 0;
}
`,`#include "copy-a-string-1.h"



undefined8 entry(void)

{
  char *pcVar1;
  char local_e0 [8];
  size_t local_d8;
  undefined4 local_cc;
  undefined auStack_c8 [80];
  undefined auStack_78 [80];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_cc = 0;
  builtin_strncpy(local_e0,"Hello",6);
  ___strcpy_chk(auStack_78,local_e0,0x50);
  local_d8 = _strlen(local_e0);
  if (0x4f < local_d8) {
    _fputs("The buffer is too small!\n",*(FILE **)PTR____stderrp_100004018);
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  ___memcpy_chk(auStack_c8,local_e0,local_d8 + 1,0x50);
  pcVar1 = _strdup(local_e0);
  if (pcVar1 == (char *)0x0) {
    _perror("strdup");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  builtin_strncpy(local_e0,"----",4);
  local_e0[4] = 0x2d;
  _printf(" src: %s\n");
  _printf("dst1: %s\n");
  _printf("dst2: %s\n");
  _printf("dst3: %s\n");
  _printf(" ref: %s\n");
  _free(pcVar1);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004028)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fputs(char *param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fputs_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004038)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _perror(char *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__perror_100004040)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004050)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004058)();
  return sVar1;
}


`
`#include <stdio.h>

char * base;
void get_diff()
{
	char x;
	if (base - &x < 200)
		printf("%p %d\n", &x, base - &x);
}

void recur()
{
	get_diff();
	recur();
}

int main()
{
	char v = 32;
	printf("pos of v: %p\n", base = &v);
	recur();
	return 0;
}
`,`#include "find-limit-of-recursion-2.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong _get_diff(ulong param_1)

{
  uint uVar1;
  undefined uStack_11;
  
  if (__base - (long)&uStack_11 < 200) {
    uVar1 = _printf("%p %d\n");
    param_1 = (ulong)uVar1;
  }
  return param_1;
}



void _recur(void)

{
  _get_diff();
  _recur();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 entry(void)

{
  int iVar1;
  undefined local_15;
  undefined4 local_14;
  
  local_14 = 0;
  __base = &local_15;
  local_15 = 0x20;
  iVar1 = _printf("pos of v: %p\n");
  _recur(iVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int i;

#define sum(i, lo_byname, hi_byname, term)      \
  ({                                            \
  int lo = lo_byname;                           \
  int hi = hi_byname;                           \
                                                \
  double temp = 0;                              \
  for (i = lo; i <= hi; ++i)                    \
    temp += term;                               \
  temp;                                         \
  })

int main () {
    printf("%f\n", sum(i, 1, 100, 1.0 / i));
    return 0;
}
`,`#include "jensens-device-2.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(void)

{
  for (__i = 1; __i < 0x65; __i = __i + 1) {
  }
  _printf("%f\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <complex.h>

double PI;
typedef double complex cplx;

void _fft(cplx buf[], cplx out[], int n, int step)
{
	if (step < n) {
		_fft(out, buf, n, step * 2);
		_fft(out + step, buf + step, n, step * 2);

		for (int i = 0; i < n; i += 2 * step) {
			cplx t = cexp(-I * PI * i / n) * out[i + step];
			buf[i / 2]     = out[i] + t;
			buf[(i + n)/2] = out[i] - t;
		}
	}
}

void fft(cplx buf[], int n)
{
	cplx out[n];
	for (int i = 0; i < n; i++) out[i] = buf[i];
	_fft(buf, out, n, 1);
}

/* pad array length to power of two */
cplx *pad_two(double g[], int len, int *ns)
{
	int n = 1;
	if (*ns) n = *ns;
	else while (n < len) n *= 2;

	cplx *buf = calloc(sizeof(cplx), n);
	for (int i = 0; i < len; i++) buf[i] = g[i];
	*ns = n;
	return buf;
}

void deconv(double g[], int lg, double f[], int lf, double out[], int row_len) {
	int ns = 0;
	cplx *g2 = pad_two(g, lg, &ns);
	cplx *f2 = pad_two(f, lf, &ns);

	fft(g2, ns);
	fft(f2, ns);

	cplx h[ns];
	for (int i = 0; i < ns; i++) h[i] = g2[i] / f2[i];
	fft(h, ns);

	for (int i = 0; i < ns; i++) {
		if (cabs(creal(h[i])) < 1e-10)
			h[i] = 0;
	}

	for (int i = 0; i > lf - lg - row_len; i--)
		out[-i] = h[(i + ns) % ns]/32;
	free(g2);
	free(f2);
}

double* unpack2(void *m, int rows, int len, int to_len)
{
	double *buf = calloc(sizeof(double), rows * to_len);
	for (int i = 0; i < rows; i++)
		for (int j = 0; j < len; j++)
			buf[i * to_len + j] = ((double(*)[len])m)[i][j];
	return buf;
}

void pack2(double * buf, int rows, int from_len, int to_len, void *out)
{
	for (int i = 0; i < rows; i++)
		for (int j = 0; j < to_len; j++)
			((double(*)[to_len])out)[i][j] = buf[i * from_len + j] / 4;
}

void deconv2(void *g, int row_g, int col_g, void *f, int row_f, int col_f, void *out) {
	double *g2 = unpack2(g, row_g, col_g, col_g);
	double *f2 = unpack2(f, row_f, col_f, col_g);

	double ff[(row_g - row_f + 1) * col_g];
	deconv(g2, row_g * col_g, f2, row_f * col_g, ff, col_g);
	pack2(ff, row_g - row_f + 1, col_g, col_g - col_f + 1, out);

	free(g2);
	free(f2);
}

double* unpack3(void *m, int x, int y, int z, int to_y, int to_z)
{
	double *buf = calloc(sizeof(double), x * to_y * to_z);
	for (int i = 0; i < x; i++)
		for (int j = 0; j < y; j++) {
			for (int k = 0; k < z; k++)
				buf[(i * to_y + j) * to_z + k] =
					((double(*)[y][z])m)[i][j][k];
		}
	return buf;
}

void pack3(double * buf, int x, int y, int z, int to_y, int to_z, void *out)
{
	for (int i = 0; i < x; i++)
		for (int j = 0; j < to_y; j++)
			for (int k = 0; k < to_z; k++)
				((double(*)[to_y][to_z])out)[i][j][k] =
					buf[(i * y + j) * z + k] / 4;
}

void deconv3(void *g, int gx, int gy, int gz, void *f, int fx, int fy, int fz, void *out) {
	double *g2 = unpack3(g, gx, gy, gz, gy, gz);
	double *f2 = unpack3(f, fx, fy, fz, gy, gz);

	double ff[(gx - fx + 1) * gy * gz];
	deconv(g2, gx * gy * gz, f2, fx * gy * gz, ff, gy * gz);
	pack3(ff, gx - fx + 1, gy, gz, gy - fy + 1, gz - fz + 1, out);

	free(g2);
	free(f2);
}

int main()
{
	PI = atan2(1,1) * 4;
	double h[2][3][4] = {
		{{-6, -8, -5,  9}, {-7, 9, -6, -8}, { 2, -7,  9,  8}},
		{{ 7,  4,  4, -6}, { 9, 9,  4, -4}, {-3,  7, -2, -3}}
	};
	int hx = 2, hy = 3, hz = 4;
	double f[3][2][3] = {	{{-9,  5, -8}, { 3,  5,  1}},
				{{-1, -7,  2}, {-5, -6,  6}},
				{{ 8,  5,  8}, {-2, -6, -4}} };
	int fx = 3, fy = 2, fz = 3;
	double g[4][4][6] = {
		{	{ 54,  42,  53, -42,  85, -72}, { 45,-170,  94, -36,  48,  73},
			{-39,  65,-112, -16, -78, -72}, {  6, -11,  -6,  62,  49,   8} },
		{ 	{-57,  49, -23,   52, -135,  66},{-23, 127, -58,   -5, -118,  64},
			{ 87, -16,  121,  23,  -41, -12},{-19,  29,   35,-148,  -11,  45} },
		{	{-55, -147, -146, -31,  55,  60},{-88,  -45,  -28,  46, -26,-144},
			{-12, -107,  -34, 150, 249,  66},{ 11,  -15,  -34,  27, -78, -50} },
		{	{ 56,  67, 108,   4,  2,-48},{ 58,  67,  89,  32, 32, -8},
			{-42, -31,-103, -30,-23, -8},{  6,   4, -26, -10, 26, 12}
		}
	};
	int gx = 4, gy = 4, gz = 6;

	double h2[gx - fx + 1][gy - fy + 1][gz - fz + 1];
	deconv3(g, gx, gy, gz, f, fx, fy, fz, h2);
	printf("deconv3(g, f):\n");
	for (int i = 0; i < gx - fx + 1; i++) {
		for (int j = 0; j < gy - fy + 1; j++) {
			for (int k = 0; k < gz - fz + 1; k++)
				printf("%g ", h2[i][j][k]);
			printf("\n");
		}
		if (i < gx - fx) printf("\n");
	}

	double f2[gx - hx + 1][gy - hy + 1][gz - hz + 1];
	deconv3(g, gx, gy, gz, h, hx, hy, hz, f2);
	printf("\ndeconv3(g, h):\n");
	for (int i = 0; i < gx - hx + 1; i++) {
		for (int j = 0; j < gy - hy + 1; j++) {
			for (int k = 0; k < gz - hz + 1; k++)
				printf("%g ", f2[i][j][k]);
			printf("\n");
		}
		if (i < gx - hx) printf("\n");
	}
}

/* two-D case; since task doesn't require showing it, it's commented out */
/*
int main()
{
	PI = atan2(1,1) * 4;
	double h[][6] = { 	{-8, 1, -7, -2, -9, 4},
				{4, 5, -5, 2, 7, -1},
				{-6, -3, -3, -6, 9, 5} };
	int hr = 3, hc = 6;

	double f[][5] = {	{-5, 2, -2, -6, -7},
				{9, 7, -6, 5, -7},
				{1, -1, 9, 2, -7},
				{5, 9, -9, 2, -5},
				{-8, 5, -2, 8, 5} };
	int fr = 5, fc = 5;
	double g[][10] = {
			{40, -21, 53, 42, 105, 1, 87, 60, 39, -28},
			{-92, -64, 19, -167, -71, -47, 128, -109, 40, -21},
			{58, 85, -93, 37, 101, -14, 5, 37, -76, -56},
			{-90, -135, 60, -125, 68, 53, 223, 4, -36, -48},
			{78, 16, 7, -199, 156, -162, 29, 28, -103, -10},
			{-62, -89, 69, -61, 66, 193, -61, 71, -8, -30},
			{48, -6, 21, -9, -150, -22, -56, 32, 85, 25}	};
	int gr = 7, gc = 10;

	double h2[gr - fr + 1][gc - fc + 1];
	deconv2(g, gr, gc, f, fr, fc, h2);
	for (int i = 0; i < gr - fr + 1; i++) {
		for (int j = 0; j < gc - fc + 1; j++)
			printf(" %g", h2[i][j]);
		printf("\n");
	}

	double f2[gr - hr + 1][gc - hc + 1];
	deconv2(g, gr, gc, h, hr, hc, f2);
	for (int i = 0; i < gr - hr + 1; i++) {
		for (int j = 0; j < gc - hc + 1; j++)
			printf(" %g", f2[i][j]);
		printf("\n");
	}
}*/
`,`#include "deconvolution-2d+-1.h"



// WARNING: Removing unreachable block (ram,0x0001000021c8)
// WARNING: Removing unreachable block (ram,0x0001000021e8)
// WARNING: Removing unreachable block (ram,0x0001000022a8)
// WARNING: Removing unreachable block (ram,0x0001000022c8)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fft(long param_1,long param_2,int param_3,int param_4)

{
  double *pdVar1;
  double *pdVar2;
  undefined8 uVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  int local_2c;
  
  if (param_4 < param_3) {
    __fft(param_2,param_1,param_3,param_4 << 1);
    __fft(param_2 + (long)param_4 * 0x10,param_1 + (long)param_4 * 0x10,param_3,param_4 << 1);
    for (local_2c = 0; local_2c < param_3; local_2c = local_2c + param_4 * 2) {
      dVar6 = __PI * -0.0 * 0.0 + __PI * -1.0 * (double)(long)local_2c;
      uVar3 = FUN_100003550(__PI * -0.0 * (double)(long)local_2c - __PI * -1.0 * 0.0,dVar6,
                            (double)(long)param_3,0);
      dVar4 = (double)_cexp(uVar3);
      pdVar1 = (double *)(param_2 + (long)(local_2c + param_4) * 0x10);
      dVar7 = *pdVar1;
      dVar8 = pdVar1[1];
      dVar5 = dVar4 * dVar7 - dVar6 * dVar8;
      dVar6 = dVar4 * dVar8 + dVar6 * dVar7;
      pdVar2 = (double *)(param_2 + (long)local_2c * 0x10);
      dVar4 = pdVar2[1];
      pdVar1 = (double *)(param_1 + (long)(local_2c / 2) * 0x10);
      *pdVar1 = *pdVar2 + dVar5;
      pdVar1[1] = dVar4 + dVar6;
      pdVar2 = (double *)(param_2 + (long)local_2c * 0x10);
      dVar4 = pdVar2[1];
      pdVar1 = (double *)(param_1 + (long)((local_2c + param_3) / 2) * 0x10);
      *pdVar1 = *pdVar2 - dVar5;
      pdVar1[1] = dVar4 - dVar6;
    }
  }
  return;
}



void _fft(long param_1,uint param_2)

{
  undefined8 *puVar1;
  undefined8 *puVar2;
  undefined8 uVar3;
  undefined *apuStack_60 [2];
  long local_50;
  long local_48;
  int local_3c;
  undefined *local_30;
  uint local_24;
  long local_20;
  long local_18;
  
  local_30 = (undefined *)apuStack_60;
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_50 = (ulong)param_2 * 0x10;
  local_24 = param_2;
  local_20 = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_48 = (long)apuStack_60 - local_50;
  for (local_3c = 0; local_3c < (int)local_24; local_3c = local_3c + 1) {
    puVar1 = (undefined8 *)(local_20 + (long)local_3c * 0x10);
    uVar3 = puVar1[1];
    puVar2 = (undefined8 *)(local_48 + (long)local_3c * 0x10);
    *puVar2 = *puVar1;
    puVar2[1] = uVar3;
  }
  __fft(local_20,local_48,local_24,1);
  apuStack_60[1] = local_30;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void * _pad_two(long param_1,int param_2,int *param_3)

{
  undefined8 *puVar1;
  void *pvVar2;
  int local_3c;
  int local_2c;
  
  local_2c = 1;
  if (*param_3 == 0) {
    for (; local_2c < param_2; local_2c = local_2c << 1) {
    }
  }
  else {
    local_2c = *param_3;
  }
  pvVar2 = _calloc(0x10,(long)local_2c);
  for (local_3c = 0; local_3c < param_2; local_3c = local_3c + 1) {
    puVar1 = (undefined8 *)((long)pvVar2 + (long)local_3c * 0x10);
    *puVar1 = *(undefined8 *)(param_1 + (long)local_3c * 8);
    puVar1[1] = 0;
  }
  *param_3 = local_2c;
  return pvVar2;
}



void _deconv(undefined8 param_1,int param_2,undefined8 param_3,int param_4,long param_5,int param_6)

{
  undefined8 *puVar1;
  undefined8 *puVar2;
  int iVar3;
  undefined8 uVar4;
  double dVar5;
  undefined8 uVar6;
  undefined auStack_b0 [8];
  undefined *local_a8;
  uint *local_a0;
  long local_98;
  undefined *local_90;
  int local_84;
  undefined8 local_80;
  undefined8 local_78;
  int local_70;
  int local_6c;
  undefined *local_60;
  void *local_58;
  void *local_50;
  uint local_48;
  int local_44;
  long local_40;
  int local_34;
  undefined8 local_30;
  int local_24;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_a0 = &local_48;
  local_48 = 0;
  local_44 = param_6;
  local_40 = param_5;
  local_34 = param_4;
  local_30 = param_3;
  local_24 = param_2;
  local_20 = param_1;
  local_50 = (void *)_pad_two(param_1,param_2);
  local_58 = (void *)_pad_two(local_30,local_34,local_a0);
  _fft(local_50,local_48);
  _fft(local_58,local_48);
  local_98 = (ulong)local_48 * 0x10;
  local_60 = auStack_b0;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_90 = auStack_b0 + -local_98;
  for (local_6c = 0; local_6c < (int)local_48; local_6c = local_6c + 1) {
    puVar1 = (undefined8 *)((long)local_50 + (long)local_6c * 0x10);
    uVar6 = puVar1[1];
    puVar2 = (undefined8 *)((long)local_58 + (long)local_6c * 0x10);
    uVar4 = FUN_100003550(*puVar1,uVar6,*puVar2,puVar2[1]);
    *(undefined8 *)(local_90 + (long)local_6c * 0x10) = uVar4;
    *(undefined8 *)((long)(local_90 + (long)local_6c * 0x10) + 8) = uVar6;
  }
  _fft(local_90,local_48);
  for (local_70 = 0; local_70 < (int)local_48; local_70 = local_70 + 1) {
    local_80 = *(undefined8 *)(local_90 + (long)local_70 * 0x10);
    local_78 = 0;
    dVar5 = (double)_cabs(local_80,0);
    if (dVar5 < 1e-10) {
      *(undefined8 *)(local_90 + (long)local_70 * 0x10) = 0;
      *(undefined8 *)((long)(local_90 + (long)local_70 * 0x10) + 8) = 0;
    }
  }
  for (local_84 = 0; (local_34 - local_24) - local_44 < local_84; local_84 = local_84 + -1) {
    iVar3 = 0;
    if (local_48 != 0) {
      iVar3 = (int)(local_84 + local_48) / (int)local_48;
    }
    uVar4 = FUN_100003550(*(undefined8 *)
                           (local_90 + (long)(int)((local_84 + local_48) - iVar3 * local_48) * 0x10)
                          ,*(undefined8 *)
                            ((long)(local_90 +
                                   (long)(int)((local_84 + local_48) - iVar3 * local_48) * 0x10) + 8
                            ),0x4040000000000000,0);
    *(undefined8 *)(local_40 + (long)-local_84 * 8) = uVar4;
  }
  _free(local_50);
  _free(local_58);
  local_a8 = local_60;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void * _unpack2(long param_1,int param_2,uint param_3,int param_4)

{
  void *pvVar1;
  undefined4 local_38;
  undefined4 local_34;
  
  pvVar1 = _calloc(8,(long)(param_2 * param_4));
  for (local_34 = 0; local_34 < param_2; local_34 = local_34 + 1) {
    for (local_38 = 0; local_38 < (int)param_3; local_38 = local_38 + 1) {
      *(undefined8 *)((long)pvVar1 + (long)(local_34 * param_4 + local_38) * 8) =
           *(undefined8 *)(param_1 + (long)local_34 * (ulong)param_3 * 8 + (long)local_38 * 8);
    }
  }
  return pvVar1;
}



void _pack2(long param_1,int param_2,int param_3,uint param_4,long param_5)

{
  undefined4 local_28;
  undefined4 local_24;
  
  for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
    for (local_28 = 0; local_28 < (int)param_4; local_28 = local_28 + 1) {
      *(double *)(param_5 + (long)local_24 * (ulong)param_4 * 8 + (long)local_28 * 8) =
           *(double *)(param_1 + (long)(local_24 * param_3 + local_28) * 8) / 4.0;
    }
  }
  return;
}



void _deconv2(undefined8 param_1,int param_2,int param_3,undefined8 param_4,int param_5,int param_6,
             undefined8 param_7)

{
  undefined auStack_80 [8];
  ulong local_78;
  undefined *local_70;
  undefined *local_68;
  undefined *local_58;
  void *local_50;
  void *local_48;
  undefined8 local_40;
  int local_38;
  int local_34;
  undefined8 local_30;
  int local_28;
  int local_24;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_40 = param_7;
  local_38 = param_6;
  local_34 = param_5;
  local_30 = param_4;
  local_28 = param_3;
  local_24 = param_2;
  local_20 = param_1;
  local_48 = (void *)_unpack2(param_1,param_2,param_3,param_3);
  local_50 = (void *)_unpack2(local_30,local_34,local_38,local_28);
  local_78 = (ulong)(uint)(((local_24 - local_34) + 1) * local_28) * 8 + 0xf & 0xfffffffffffffff0;
  local_58 = auStack_80;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_70 = auStack_80 + -local_78;
  _deconv(local_48,local_24 * local_28,local_50,local_34 * local_28,local_70,local_28);
  _pack2(local_70,(local_24 - local_34) + 1,local_28,(local_28 - local_38) + 1,local_40);
  _free(local_48);
  _free(local_50);
  local_68 = local_58;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void * _unpack3(long param_1,int param_2,uint param_3,uint param_4,int param_5,int param_6)

{
  void *pvVar1;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  
  pvVar1 = _calloc(8,(long)(param_2 * param_5 * param_6));
  for (local_3c = 0; local_3c < param_2; local_3c = local_3c + 1) {
    for (local_40 = 0; local_40 < (int)param_3; local_40 = local_40 + 1) {
      for (local_44 = 0; local_44 < (int)param_4; local_44 = local_44 + 1) {
        *(undefined8 *)
         ((long)pvVar1 + (long)((local_3c * param_5 + local_40) * param_6 + local_44) * 8) =
             *(undefined8 *)
              (param_1 + (long)local_3c * (ulong)param_3 * (ulong)param_4 * 8 +
               (long)local_40 * (ulong)param_4 * 8 + (long)local_44 * 8);
      }
    }
  }
  return pvVar1;
}



void _pack3(long param_1,int param_2,int param_3,int param_4,uint param_5,uint param_6,long param_7)

{
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  
  for (local_2c = 0; local_2c < param_2; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < (int)param_5; local_30 = local_30 + 1) {
      for (local_34 = 0; local_34 < (int)param_6; local_34 = local_34 + 1) {
        *(double *)
         (param_7 + (long)local_2c * (ulong)param_5 * (ulong)param_6 * 8 +
          (long)local_30 * (ulong)param_6 * 8 + (long)local_34 * 8) =
             *(double *)(param_1 + (long)((local_2c * param_3 + local_30) * param_4 + local_34) * 8)
             / 4.0;
      }
    }
  }
  return;
}



void _deconv3(undefined8 param_1,int param_2,int param_3,int param_4,undefined8 param_5,int param_6,
             int param_7,int param_8,undefined8 param_9)

{
  undefined auStack_90 [8];
  ulong local_88;
  undefined *local_80;
  undefined *local_78;
  undefined *local_68;
  void *local_60;
  void *local_58;
  undefined8 local_50;
  int local_44;
  int local_40;
  int local_3c;
  undefined8 local_38;
  int local_2c;
  int local_28;
  int local_24;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_50 = param_9;
  local_44 = param_8;
  local_40 = param_7;
  local_3c = param_6;
  local_38 = param_5;
  local_2c = param_4;
  local_28 = param_3;
  local_24 = param_2;
  local_20 = param_1;
  local_58 = (void *)_unpack3(param_1,param_2,param_3,param_4,param_3,param_4);
  local_60 = (void *)_unpack3(local_38,local_3c,local_40,local_44,local_28,local_2c);
  local_88 = (ulong)(uint)(((local_24 - local_3c) + 1) * local_28 * local_2c) * 8 + 0xf &
             0xfffffffffffffff0;
  local_68 = auStack_90;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_80 = auStack_90 + -local_88;
  _deconv(local_58,local_24 * local_28 * local_2c,local_60,local_3c * local_28 * local_2c,local_80,
          local_28 * local_2c);
  _pack3(local_80,(local_24 - local_3c) + 1,local_28,local_2c,(local_28 - local_40) + 1,
         (local_2c - local_44) + 1,local_50);
  _free(local_58);
  _free(local_60);
  local_78 = local_68;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 entry(void)

{
  uint uVar1;
  undefined *puVar2;
  long lVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  undefined8 uVar10;
  long extraout_x12;
  long extraout_x12_00;
  long alStack_580 [2];
  undefined auStack_570 [4];
  undefined4 local_56c;
  uint local_568;
  uint local_564;
  ulong local_560;
  ulong local_558;
  ulong local_550;
  long local_548;
  int local_540;
  int local_53c;
  undefined *local_538;
  int local_52c;
  undefined *local_528;
  uint local_520;
  uint local_51c;
  ulong local_518;
  ulong local_510;
  ulong local_508;
  undefined *local_500;
  int local_4f4;
  int local_4f0;
  int local_4ec;
  ulong local_4e8;
  ulong local_4e0;
  ulong local_4d8;
  int local_4cc;
  int local_4c8;
  int local_4c4;
  ulong local_4c0;
  ulong local_4b8;
  ulong local_4b0;
  undefined *local_4a8;
  int local_4a0;
  int local_49c;
  int local_498;
  int local_494;
  int local_490;
  int local_48c;
  int local_488;
  int local_484;
  int local_480;
  undefined4 local_47c;
  undefined auStack_478 [768];
  undefined auStack_178 [144];
  undefined auStack_e8 [192];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004018;
  local_47c = 0;
  __PI = (double)_atan2(0x3ff0000000000000);
  __PI = __PI * 4.0;
  _memcpy(auStack_e8,&DAT_100003b08,0xc0);
  local_540 = 2;
  local_480 = 2;
  local_53c = 3;
  local_484 = 3;
  local_52c = 4;
  local_488 = 4;
  local_528 = auStack_178;
  _memcpy(local_528,&DAT_100003bc8,0x90);
  local_48c = local_53c;
  local_490 = local_540;
  local_494 = local_53c;
  local_538 = auStack_478;
  _memcpy(local_538,&DAT_100003c58,0x300);
  local_498 = local_52c;
  local_49c = local_52c;
  local_4a0 = 6;
  uVar1 = (local_52c - local_48c) + 1;
  local_518 = (ulong)uVar1;
  local_520 = (local_52c - local_490) + 1;
  local_510 = (ulong)local_520;
  local_51c = 7 - local_494;
  local_508 = (ulong)local_51c;
  local_4a8 = auStack_570;
  uVar10 = (*(code *)PTR____chkstk_darwin_100004000)
                     ((ulong)uVar1 * (ulong)local_520 * local_508 * 8 + 0xf,local_538);
  iVar5 = local_498;
  iVar4 = local_49c;
  iVar9 = local_4a0;
  lVar3 = -extraout_x12;
  puVar2 = auStack_570 + lVar3;
  local_4b0 = local_518;
  local_4b8 = local_510;
  local_4c0 = local_508;
  local_500 = puVar2;
  *(undefined **)((long)alStack_580 + lVar3) = puVar2;
  _deconv3(uVar10,iVar5,iVar4,iVar9);
  iVar9 = _printf("deconv3(g, f):\n");
  for (local_4c4 = 0; local_4c4 < (local_498 - local_48c) + 1; local_4c4 = local_4c4 + 1) {
    for (local_4c8 = 0; local_4c8 < (local_49c - local_490) + 1; local_4c8 = local_4c8 + 1) {
      for (local_4cc = 0; local_4cc < (local_4a0 - local_494) + 1; local_4cc = local_4cc + 1) {
        *(undefined8 *)((long)alStack_580 + lVar3) =
             *(undefined8 *)
              (local_500 +
              (long)local_4cc * 8 +
              (long)local_4c8 * local_508 * 8 +
              (long)local_4c4 * (ulong)local_520 * (ulong)local_51c * 8);
        _printf("%g ");
      }
      iVar9 = _printf("\n");
    }
    if (local_4c4 < local_498 - local_48c) {
      iVar9 = _printf("\n");
    }
  }
  uVar1 = (local_498 - local_480) + 1;
  local_560 = (ulong)uVar1;
  local_568 = (local_49c - local_484) + 1;
  local_558 = (ulong)local_568;
  local_564 = (local_4a0 - local_488) + 1;
  local_550 = (ulong)local_564;
  (*(code *)PTR____chkstk_darwin_100004000)
            ((ulong)uVar1 * (ulong)local_568 * local_550 * 8 + 0xf,iVar9);
  iVar8 = local_480;
  iVar7 = local_484;
  iVar6 = local_488;
  iVar5 = local_498;
  iVar4 = local_49c;
  iVar9 = local_4a0;
  lVar3 = (long)puVar2 - extraout_x12_00;
  local_4d8 = local_560;
  local_4e0 = local_558;
  local_4e8 = local_550;
  local_548 = lVar3;
  *(long *)(lVar3 + -0x10) = lVar3;
  _deconv3(auStack_478,iVar5,iVar4,iVar9,auStack_e8,iVar8,iVar7,iVar6);
  iVar9 = _printf("\ndeconv3(g, h):\n");
  for (local_4ec = 0; local_4ec < (local_498 - local_480) + 1; local_4ec = local_4ec + 1) {
    for (local_4f0 = 0; local_4f0 < (local_49c - local_484) + 1; local_4f0 = local_4f0 + 1) {
      for (local_4f4 = 0; local_4f4 < (local_4a0 - local_488) + 1; local_4f4 = local_4f4 + 1) {
        *(undefined8 *)(lVar3 + -0x10) =
             *(undefined8 *)
              (local_548 + (long)local_4ec * (ulong)local_568 * (ulong)local_564 * 8 +
               (long)local_4f0 * local_550 * 8 + (long)local_4f4 * 8);
        _printf("%g ");
      }
      iVar9 = _printf("\n");
    }
    if (local_4ec < local_498 - local_480) {
      iVar9 = _printf("\n");
    }
  }
  local_56c = local_47c;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar9);
  }
  return local_47c;
}



// WARNING: Removing unreachable block (ram,0x000100003894)
// WARNING: Removing unreachable block (ram,0x00010000389c)
// WARNING: Removing unreachable block (ram,0x0001000038a4)
// WARNING: Removing unreachable block (ram,0x0001000038b4)
// WARNING: Removing unreachable block (ram,0x0001000038cc)
// WARNING: Removing unreachable block (ram,0x0001000038e0)
// WARNING: Removing unreachable block (ram,0x0001000038f4)
// WARNING: Removing unreachable block (ram,0x00010000395c)
// WARNING: Removing unreachable block (ram,0x000100003970)
// WARNING: Removing unreachable block (ram,0x000100003978)
// WARNING: Removing unreachable block (ram,0x00010000398c)
// WARNING: Removing unreachable block (ram,0x0001000039ac)
// WARNING: Removing unreachable block (ram,0x0001000039b0)
// WARNING: Removing unreachable block (ram,0x0001000039c4)
// WARNING: Removing unreachable block (ram,0x0001000039c8)
// WARNING: Removing unreachable block (ram,0x0001000039e8)
// WARNING: Removing unreachable block (ram,0x0001000039ec)
// WARNING: Removing unreachable block (ram,0x0001000039f0)
// WARNING: Removing unreachable block (ram,0x000100003904)
// WARNING: Removing unreachable block (ram,0x000100003910)
// WARNING: Removing unreachable block (ram,0x000100003914)
// WARNING: Removing unreachable block (ram,0x000100003930)
// WARNING: Removing unreachable block (ram,0x000100003934)
// WARNING: Removing unreachable block (ram,0x0001000038ac)
// WARNING: Removing unreachable block (ram,0x0001000039fc)

undefined  [16]
FUN_100003550(double param_1,double param_2,undefined param_3 [16],undefined param_4 [16])

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  ulong uVar6;
  ulong uVar7;
  undefined auVar8 [16];
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  
  dVar9 = param_3._0_8_;
  dVar10 = param_4._0_8_;
  dVar11 = ABS(dVar9);
  if (ABS(dVar9) <= ABS(dVar10)) {
    dVar11 = ABS(dVar10);
  }
  uVar5 = (uint)((ulong)dVar11 >> 0x34) & 0x7ff;
  iVar4 = (((uint)((ulong)((long)dVar11 << ((ulong)((int)LZCOUNT(ABS(dVar11)) - 0xb) & 0x3f)) >>
                  0x34) & 0x7ff) - (int)LZCOUNT(ABS(dVar11))) + -0x3f4;
  if (uVar5 != 0) {
    iVar4 = uVar5 - 0x3ff;
  }
  dVar12 = -INFINITY;
  if (dVar11 != 0.0) {
    dVar12 = (double)iVar4;
  }
  if (dVar11 == -NAN || (long)dVar11 + 1 < 0 != SCARRY8((long)dVar11,1)) {
    dVar11 = -dVar11;
  }
  if (uVar5 == 0x7ff) {
    dVar12 = dVar11;
  }
  if ((ulong)ABS(dVar12) < 0x7ff0000000000000) {
    iVar4 = (int)dVar12;
    iVar3 = -iVar4;
    if ((dVar9 != 0.0) && (uVar5 = param_3._4_4_ >> 0x14 & 0x7ff, uVar5 != 0x7ff)) {
      uVar6 = (ulong)dVar9 & 0xfffffffffffff;
      if (uVar5 == 0) {
        uVar5 = 0xc - (int)LZCOUNT(uVar6);
        uVar6 = uVar6 << ((ulong)((int)LZCOUNT(uVar6) - 0xb) & 0x3f) & 0xffefffffffffffff;
      }
      uVar1 = (int)(uVar5 + iVar3) >> 0x1f ^ 0x80000000;
      if (!SCARRY4(uVar5,iVar3)) {
        uVar1 = uVar5 + iVar3;
      }
      uVar7 = (ulong)dVar9 & 0x8000000000000000;
      if ((int)uVar1 < 0x7ff) {
        if ((int)uVar1 < 1) {
          if (uVar1 == 0xfffffc03 || (int)(uVar1 + 0x3fd) < 0 != SCARRY4(uVar1,0x3fd)) {
            uVar1 = 0xfffffc03;
          }
          dVar9 = (double)(uVar6 | uVar7 | 0x10000000000000) *
                  (double)((ulong)(uVar1 + 0x3fe) << 0x34);
        }
        else {
          dVar9 = (double)(uVar7 | (ulong)uVar1 << 0x34 | uVar6);
        }
      }
      else {
        dVar9 = (double)(uVar7 | 0x7fe0000000000000) + (double)(uVar7 | 0x7fe0000000000000);
      }
    }
    if ((dVar10 != 0.0) && (uVar5 = param_4._4_4_ >> 0x14 & 0x7ff, uVar5 != 0x7ff)) {
      uVar6 = (ulong)dVar10 & 0xfffffffffffff;
      if (uVar5 == 0) {
        uVar5 = 0xc - (int)LZCOUNT(uVar6);
        uVar6 = uVar6 << ((ulong)((int)LZCOUNT(uVar6) - 0xb) & 0x3f) & 0xffefffffffffffff;
      }
      uVar1 = (int)(uVar5 + iVar3) >> 0x1f ^ 0x80000000;
      if (!SCARRY4(uVar5,iVar3)) {
        uVar1 = uVar5 + iVar3;
      }
      uVar7 = (ulong)dVar10 & 0x8000000000000000;
      if ((int)uVar1 < 0x7ff) {
        if ((int)uVar1 < 1) {
          if (uVar1 == 0xfffffc03 || (int)(uVar1 + 0x3fd) < 0 != SCARRY4(uVar1,0x3fd)) {
            uVar1 = 0xfffffc03;
          }
          dVar10 = (double)(uVar6 | uVar7 | 0x10000000000000) *
                   (double)((ulong)(uVar1 + 0x3fe) << 0x34);
        }
        else {
          dVar10 = (double)(uVar7 | (ulong)uVar1 << 0x34 | uVar6);
        }
      }
      else {
        dVar10 = (double)(uVar7 | 0x7fe0000000000000) + (double)(uVar7 | 0x7fe0000000000000);
      }
    }
  }
  else {
    iVar4 = 0;
  }
  dVar12 = (double)NEON_fmadd(dVar9,dVar9,dVar10 * dVar10);
  dVar11 = (double)NEON_fmadd(param_1,dVar9,dVar10 * param_2);
  dVar11 = dVar11 / dVar12;
  if ((dVar11 != 0.0) && (uVar5 = (uint)((ulong)dVar11 >> 0x34) & 0x7ff, uVar5 != 0x7ff)) {
    uVar7 = (ulong)dVar11 & 0xfffffffffffff;
    uVar6 = uVar7;
    if (uVar5 == 0) {
      uVar6 = uVar7 << ((ulong)((int)LZCOUNT(uVar7) - 0xb) & 0x3f) & 0xffefffffffffffff;
      uVar5 = 0xc - (int)LZCOUNT(uVar7);
    }
    uVar1 = uVar5 + -iVar4;
    uVar2 = (int)uVar1 >> 0x1f ^ 0x80000000;
    if (!SCARRY4(uVar5,-iVar4)) {
      uVar2 = uVar1;
    }
    uVar7 = (ulong)dVar11 & 0x8000000000000000;
    if (0x7fe < (int)uVar2) {
      dVar11 = (double)(uVar7 | 0x7fe0000000000000) + (double)(uVar7 | 0x7fe0000000000000);
      NEON_fmadd(param_2,dVar9,-(dVar10 * param_1));
      goto code_r0x000100003860;
    }
    if ((int)uVar2 < 1) {
      if (uVar2 == 0xfffffc03 || (int)(uVar2 + 0x3fd) < 0 != SCARRY4(uVar2,0x3fd)) {
        uVar2 = 0xfffffc03;
      }
      dVar11 = (double)(uVar6 | uVar7 | 0x10000000000000) * (double)((ulong)(uVar2 + 0x3fe) << 0x34)
      ;
      NEON_fmadd(param_2,dVar9,-(dVar10 * param_1));
      goto code_r0x000100003860;
    }
    dVar11 = (double)(uVar7 | (ulong)uVar2 << 0x34 | uVar6);
  }
  NEON_fmadd(param_2,dVar9,-(dVar10 * param_1));
code_r0x000100003860:
  auVar8._8_8_ = 0;
  auVar8._0_8_ = dVar11;
  return auVar8;
}



void ___muldc3(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003a8c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____muldc3_100004008)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003a98. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004010)();
  return;
}



void _atan2(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003aa4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__atan2_100004020)();
  return;
}



void _cabs(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ab0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cabs_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003abc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004030)();
  return pvVar1;
}



void _cexp(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ac8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cexp_100004038)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ad4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004040)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ae0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004048)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003aec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004050)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

/* should be 64-bit integers if going over 1 billion */
typedef unsigned long xint;
#define FMT "%lu"

xint total, prim, max_peri;

void new_tri(xint in[])
{
    int i;
    xint t[3], p;
    xint x = in[0], y = in[1], z = in[2];

recur:  p = x + y + z;
    if (p > max_peri) return;

    prim ++;
    total += max_peri / p;

    t[0] = x - 2 * y + 2 * z;
    t[1] = 2 * x - y + 2 * z;
    t[2] = t[1] - y + z;
    new_tri(t);

    t[0] += 4 * y;
    t[1] += 2 * y;
    t[2] += 4 * y;
    new_tri(t);

    z = t[2] - 4 * x;
    y = t[1] - 4 * x;
    x = t[0] - 2 * x;
    goto recur;
}

int main()
{
    xint seed[3] = {3, 4, 5};

    for (max_peri = 10; max_peri <= 100000000; max_peri *= 10) {
        total = prim = 0;
        new_tri(seed);

        printf( "Up to "FMT": "FMT" triples, "FMT" primitives.\n",
            max_peri, total, prim);
    }
    return 0;
}
`,`#include "pythagorean-triples-5.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _new_tri(long *param_1)

{
  ulong uVar1;
  ulong uVar2;
  long local_60;
  long local_58;
  long local_50;
  long local_30;
  long local_28;
  long local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_58 = param_1[1];
  local_60 = param_1[2];
  for (local_50 = *param_1; uVar1 = local_50 + local_58 + local_60, uVar1 <= __max_peri;
      local_50 = local_30 + local_50 * -2) {
    __prim = __prim + 1;
    uVar2 = 0;
    if (uVar1 != 0) {
      uVar2 = __max_peri / uVar1;
    }
    __total = __total + uVar2;
    local_30 = local_50 + local_58 * -2 + local_60 * 2;
    local_28 = (local_50 * 2 - local_58) + local_60 * 2;
    local_20 = (local_28 - local_58) + local_60;
    _new_tri();
    local_30 = local_30 + local_58 * 4;
    local_28 = local_28 + local_58 * 2;
    local_20 = local_20 + local_58 * 4;
    _new_tri(&local_30);
    local_60 = local_20 + local_50 * -4;
    local_58 = local_28 + local_50 * -4;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(ulong param_1)

{
  uint uVar1;
  undefined8 local_30;
  undefined8 uStack_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_28 = 4;
  local_30 = 3;
  local_20 = 5;
  for (__max_peri = 10; __max_peri < 0x5f5e101; __max_peri = __max_peri * 10) {
    __prim = 0;
    __total = 0;
    _new_tri(&local_30);
    uVar1 = _printf("Up to %lu: %lu triples, %lu primitives.\n");
    param_1 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int main(int c, char **v)
{
	int i, j, m, n, *s;

	/* default size: 5 */
	if (c < 2 || ((m = atoi(v[1]))) <= 0) m = 5;

	/* alloc array*/
	s = malloc(sizeof(int) * m * m);

	for (i = n = 0; i < m * 2; i++)
		for (j = (i < m) ? 0 : i-m+1; j <= i && j < m; j++)
			s[(i&1)? j*(m-1)+i : (i-j)*m+j ] = n++;

	for (i = 0; i < m * m; putchar((++i % m) ? ' ':'\n'))
		printf("%3d", s[i]);

	/* free(s) */
	return 0;
}
`,`#include "zig-zag-matrix.h"



undefined8 entry(int param_1,long param_2)

{
  int iVar1;
  void *pvVar2;
  int iVar3;
  int local_50;
  int local_3c;
  int local_30;
  int local_2c;
  int local_28;
  uint local_24;
  
  if ((param_1 < 2) || (local_2c = _atoi(*(char **)(param_2 + 8)), local_2c < 1)) {
    local_2c = 5;
  }
  pvVar2 = _malloc((long)local_2c * 4 * (long)local_2c);
  local_30 = 0;
  for (local_24 = 0; (int)(local_24 + local_2c * -2) < 0 != SBORROW4(local_24,local_2c * 2);
      local_24 = local_24 + 1) {
    if ((int)local_24 < local_2c) {
      local_3c = 0;
    }
    else {
      local_3c = (local_24 - local_2c) + 1;
    }
    for (local_28 = local_3c; local_28 <= (int)local_24 && local_28 < local_2c;
        local_28 = local_28 + 1) {
      if ((local_24 & 1) == 0) {
        local_50 = (local_24 - local_28) * local_2c + local_28;
      }
      else {
        local_50 = local_28 * (local_2c + -1) + local_24;
      }
      *(int *)((long)pvVar2 + (long)local_50 * 4) = local_30;
      local_30 = local_30 + 1;
    }
  }
  local_24 = 0;
  while ((int)local_24 < local_2c * local_2c) {
    _printf("%3d");
    local_24 = local_24 + 1;
    iVar1 = 0;
    if (local_2c != 0) {
      iVar1 = (int)local_24 / local_2c;
    }
    iVar3 = 0x20;
    if (local_24 == iVar1 * local_2c) {
      iVar3 = 10;
    }
    _putchar(iVar3);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004018)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

/* Generate (and memoize) the Padovan sequence using
 * the recurrence relationship */
int pRec(int n) {
    static int *memo = NULL;
    static size_t curSize = 0;

    /* grow memoization array when necessary and fill with zeroes */
    if (curSize <= (size_t) n) {
        size_t lastSize = curSize;
        while (curSize <= (size_t) n) curSize += 1024 * sizeof(int);
        memo = realloc(memo, curSize * sizeof(int));
        memset(memo + lastSize, 0, (curSize - lastSize) * sizeof(int));
    }

    /* if we don't have the value for N yet, calculate it */
    if (memo[n] == 0) {
        if (n<=2) memo[n] = 1;
        else memo[n] = pRec(n-2) + pRec(n-3);
    }

    return memo[n];
}

/* Calculate the Nth value of the Padovan sequence
 * using the floor function */
int pFloor(int n) {
    long double p = 1.324717957244746025960908854;
    long double s = 1.0453567932525329623;
    return powl(p, n-1)/s + 0.5;
}

/* Given the previous value for the L-system, generate the
 * next value */
void nextLSystem(const char *prev, char *buf) {
    while (*prev) {
        switch (*prev++) {
            case 'A': *buf++ = 'B'; break;
            case 'B': *buf++ = 'C'; break;
            case 'C': *buf++ = 'A'; *buf++ = 'B'; break;
        }
    }
    *buf = '\0';
}

int main() {
    // 8192 is enough up to P_33.
    #define BUFSZ 8192
    char buf1[BUFSZ], buf2[BUFSZ];
    int i;

    /* Print P_0..P_19 */
    printf("P_0 .. P_19: ");
    for (i=0; i<20; i++) printf("%d ", pRec(i));
    printf("\n");

    /* Check that functions match up to P_63 */
    printf("The floor- and recurrence-based functions ");
    for (i=0; i<64; i++) {
        if (pRec(i) != pFloor(i)) {
            printf("do not match at %d: %d != %d.\n",
                i, pRec(i), pFloor(i));
            break;
        }
    }
    if (i == 64) {
        printf("match from P_0 to P_63.\n");
    }

    /* Show first 10 L-system strings */
    printf("\nThe first 10 L-system strings are:\n");
    for (strcpy(buf1, "A"), i=0; i<10; i++) {
        printf("%s\n", buf1);
        strcpy(buf2, buf1);
        nextLSystem(buf2, buf1);
    }

    /* Check lengths of strings against pFloor up to P_31 */
    printf("\nThe floor- and L-system-based functions ");
    for (strcpy(buf1, "A"), i=0; i<32; i++) {
        if ((int)strlen(buf1) != pFloor(i)) {
            printf("do not match at %d: %d != %d\n",
                i, (int)strlen(buf1), pFloor(i));
            break;
        }
        strcpy(buf2, buf1);
        nextLSystem(buf2, buf1);
    }
    if (i == 32) {
        printf("match from P_0 to P_31.\n");
    }

    return 0;
}
`,`#include "padovan-sequence.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Restarted to delay deadcode elimination for space: ram

undefined4 _pRec(int param_1)

{
  ulong uVar1;
  int iVar2;
  int iVar3;
  
  uVar1 = _DAT_100008008;
  if (_DAT_100008008 <= (ulong)(long)param_1) {
    for (; _DAT_100008008 <= (ulong)(long)param_1; _DAT_100008008 = _DAT_100008008 + 0x1000) {
    }
    _DAT_100008000 = _realloc(_DAT_100008000,_DAT_100008008 << 2);
    ___memset_chk((void *)((long)_DAT_100008000 + uVar1 * 4),0,(_DAT_100008008 - uVar1) * 4,
                  0xffffffffffffffff);
  }
  if (*(int *)((long)_DAT_100008000 + (long)param_1 * 4) == 0) {
    if (param_1 < 3) {
      *(undefined4 *)((long)_DAT_100008000 + (long)param_1 * 4) = 1;
    }
    else {
      iVar2 = _pRec(param_1 + -2);
      iVar3 = _pRec(param_1 + -3);
      *(int *)((long)_DAT_100008000 + (long)param_1 * 4) = iVar2 + iVar3;
    }
  }
  return *(undefined4 *)((long)_DAT_100008000 + (long)param_1 * 4);
}



int _pFloor(int param_1)

{
  double dVar1;
  
  dVar1 = (double)_pow(0x3ff5320b74eca44b,(double)(param_1 + -1));
  return (int)(dVar1 / 1.045356793252533 + 0.5);
}



void _nextLSystem(char *param_1,undefined *param_2)

{
  char *pcVar1;
  char cVar2;
  undefined *local_10;
  char *local_8;
  
  local_10 = param_2;
  local_8 = param_1;
  while (*local_8 != '\0') {
    pcVar1 = local_8 + 1;
    cVar2 = *local_8;
    local_8 = pcVar1;
    if (cVar2 == 'A') {
      *local_10 = 0x42;
      local_10 = local_10 + 1;
    }
    else if (cVar2 == 'B') {
      *local_10 = 0x43;
      local_10 = local_10 + 1;
    }
    else if (cVar2 == 'C') {
      *local_10 = 0x41;
      local_10[1] = 0x42;
      local_10 = local_10 + 2;
    }
  }
  *local_10 = 0;
  return;
}



undefined8 entry(void)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  ulong uVar4;
  size_t sVar5;
  int local_4030;
  undefined auStack_4028 [8192];
  char acStack_2028 [8192];
  long local_28;
  
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_28 = *(long *)PTR____stack_chk_guard_100004018;
  _printf("P_0 .. P_19: ");
  for (local_4030 = 0; local_4030 < 0x14; local_4030 = local_4030 + 1) {
    _pRec(local_4030);
    _printf("%d ");
  }
  _printf("\n");
  _printf("The floor- and recurrence-based functions ");
  for (local_4030 = 0; local_4030 < 0x40; local_4030 = local_4030 + 1) {
    iVar1 = _pRec(local_4030);
    iVar2 = _pFloor(local_4030);
    if (iVar1 != iVar2) {
      _pRec(local_4030);
      _pFloor(local_4030);
      _printf("do not match at %d: %d != %d.\n");
      break;
    }
  }
  if (local_4030 == 0x40) {
    _printf("match from P_0 to P_63.\n");
  }
  _printf("\nThe first 10 L-system strings are:\n");
  ___strcpy_chk(acStack_2028,"A",0x2000);
  for (local_4030 = 0; local_4030 < 10; local_4030 = local_4030 + 1) {
    _printf("%s\n");
    ___strcpy_chk(auStack_4028,acStack_2028,0x2000);
    _nextLSystem(auStack_4028,acStack_2028);
  }
  _printf("\nThe floor- and L-system-based functions ");
  uVar4 = ___strcpy_chk(acStack_2028,"A",0x2000);
  local_4030 = 0;
  do {
    if (0x1f < local_4030) {
LAB_100003dcc:
      if (local_4030 == 0x20) {
        uVar3 = _printf("match from P_0 to P_31.\n");
        uVar4 = (ulong)uVar3;
      }
      if (*(long *)PTR____stack_chk_guard_100004018 != local_28) {
                    // WARNING: Subroutine does not return
        ___stack_chk_fail(uVar4);
      }
      return 0;
    }
    sVar5 = _strlen(acStack_2028);
    iVar1 = _pFloor(local_4030);
    if ((int)sVar5 != iVar1) {
      _strlen(acStack_2028);
      _pFloor(local_4030);
      uVar3 = _printf("do not match at %d: %d != %d\n");
      uVar4 = (ulong)uVar3;
      goto LAB_100003dcc;
    }
    ___strcpy_chk(auStack_4028,acStack_2028,0x2000);
    uVar4 = _nextLSystem(auStack_4028,acStack_2028);
    local_4030 = local_4030 + 1;
  } while( true );
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004008)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004010)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004020)();
  return;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e70. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004040)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INPUT_FILE_NAME     "Traceback.txt"
#define KEYWORD_STRING      "SystemError"
#define TRACEBACK_STRING    "Traceback (most recent call last):"
#define END_OF_PARAGRAPH    "\n----------------\n"

char *load_paragraph( FILE *f );

int main() {
    FILE *f   = fopen( INPUT_FILE_NAME, "r" );

    if( f ) {
        char *par = NULL;

        while( (par=load_paragraph(f)) ) {
            if( strstr(par,KEYWORD_STRING) ) {
                char *p = strstr( par, TRACEBACK_STRING );

                if( p ) printf( p );
                else printf( "%s\n%s", TRACEBACK_STRING, par );

                printf( END_OF_PARAGRAPH );
            }

            free( par ); par = NULL;
        }

        if( !feof(f) )
            puts( "End of file not reached." );

        fclose( f ); f = NULL;
    }
    else {
        puts( "Input file not opened." );
    }

    return 0;
}

/*===========================================================================
Starting from the current position, looks for the first occurrence of "\n\n"
in the file f, counting the number of characters from the current position
to "\n\n" itself (not included) or to the end of the file (whichever occurs
first). Resets the file to its original position, then returns the number of
characters.
If the funtions fails, it returns ((size_t)-1).
===========================================================================*/

size_t get_paragraph_length( FILE *f ) {
    size_t l = ((size_t)-1);

    if( f && !feof(f) ) {
        fpos_t ex_pos;

        if( 0==fgetpos(f,&ex_pos) ) {
            int c;

            for( c=fgetc(f); c!=EOF; c=fgetc(f) ) {
                if( '\n'==c ) {
                    if( '\n'!=(c=fgetc(f)) ) {
                        ungetc( c, f );
                    }
                    else {
                        ++l;
                        break;
                    }
                }

                ++l;
            }

            l += EOF==c;

            fsetpos( f, &ex_pos );
        }
    }

    return l;
}

/*===========================================================================
Loads a paragraph from the file f. Paragraphs are detected looking for the
occurrences of "\n\n" separators. The loaded paragraph is put into a chunk of
memory allocated with malloc(). The pointer to that memory is returned.
If the function fails, no memory is allocated and NULL is returned.
===========================================================================*/

char *load_paragraph( FILE *f ) {
    char *par = NULL;

    if( !feof(f) ) {
        size_t i, l = get_paragraph_length( f );

        if( ((size_t)-1)!=l ) {
            par = malloc( l+1 );

            if( par ) {
                for( i=0; i<l; ++i )
                    par[i] = fgetc( f );
                par[i] = '\0';

                /* just jump beyond the paragraph delimiter */
                fgetc( f ); fgetc( f );
            }
        }
    }

    return par;
}
`,`#include "search-in-paragraphs-text.h"



undefined8 entry(void)

{
  int iVar1;
  FILE *pFVar2;
  char *pcVar3;
  char *pcVar4;
  
  pFVar2 = _fopen("Traceback.txt","r");
  if (pFVar2 == (FILE *)0x0) {
    _puts("Input file not opened.");
  }
  else {
    while (pcVar3 = (char *)_load_paragraph(pFVar2), pcVar3 != (char *)0x0) {
      pcVar4 = _strstr(pcVar3,"SystemError");
      if (pcVar4 != (char *)0x0) {
        pcVar4 = _strstr(pcVar3,"Traceback (most recent call last):");
        if (pcVar4 == (char *)0x0) {
          _printf("%s\n%s");
        }
        else {
          _printf(pcVar4);
        }
        _printf("\n----------------\n");
      }
      _free(pcVar3);
    }
    iVar1 = _feof(pFVar2);
    if (iVar1 == 0) {
      _puts("End of file not reached.");
    }
    _fclose(pFVar2);
  }
  return 0;
}



void * _load_paragraph(FILE *param_1)

{
  int iVar1;
  ulong uVar2;
  ulong local_28;
  void *local_20;
  
  local_20 = (void *)0x0;
  iVar1 = _feof(param_1);
  if (((iVar1 == 0) && (uVar2 = _get_paragraph_length(param_1), uVar2 != 0xffffffffffffffff)) &&
     (local_20 = _malloc(uVar2 + 1), local_20 != (void *)0x0)) {
    for (local_28 = 0; local_28 < uVar2; local_28 = local_28 + 1) {
      iVar1 = _fgetc(param_1);
      *(char *)((long)local_20 + local_28) = (char)iVar1;
    }
    *(undefined *)((long)local_20 + local_28) = 0;
    _fgetc(param_1);
    _fgetc(param_1);
  }
  return local_20;
}



long _get_paragraph_length(FILE *param_1)

{
  int iVar1;
  int local_2c;
  fpos_t fStack_28;
  long local_20;
  FILE *local_18;
  
  local_20 = -1;
  if (((param_1 != (FILE *)0x0) && (local_18 = param_1, iVar1 = _feof(param_1), iVar1 == 0)) &&
     (iVar1 = _fgetpos(local_18,&fStack_28), iVar1 == 0)) {
    local_2c = _fgetc(local_18);
    while (local_2c != -1) {
      if (local_2c == 10) {
        iVar1 = _fgetc(local_18);
        if (iVar1 == 10) {
          local_20 = local_20 + 1;
          local_2c = 10;
          break;
        }
        _ungetc(iVar1,local_18);
      }
      local_20 = local_20 + 1;
      local_2c = _fgetc(local_18);
    }
    local_20 = local_20 + (ulong)(local_2c == -1);
    _fsetpos(local_18,&fStack_28);
  }
  return local_20;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _feof(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__feof_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetc_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetpos(FILE *param_1,fpos_t *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetpos_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004020)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fsetpos(FILE *param_1,fpos_t *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fsetpos_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strstr(char *param_1,char *param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strstr_100004050)();
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _ungetc(int param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__ungetc_100004058)(param_1);
  return iVar1;
}


`
`#include<stdio.h>

int main()
{
	int hyperCube[5][4][3][2];
	
	/*An element is set*/
	
	hyperCube[4][3][2][1] = 1;
	
	/*IMPORTANT : C ( and hence C++ and Java and everyone of the family ) arrays are zero based.
	The above element is thus actually the last element of the hypercube.*/
	
	/*Now we print out that element*/
	
	printf("\n%d",hyperCube[4][3][2][1]);
	
	/*But that's not the only way to get at that element*/
	printf("\n%d",*(*(*(*(hyperCube + 4) + 3) + 2) + 1));

	/*Yes, I know, it's beautiful*/
	*(*(*(*(hyperCube+3)+2)+1)) = 3;
	
	printf("\n%d",hyperCube[3][2][1][0]);
	
	return 0;
}
`,`#include "multi-dimensional-array-2.h"



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004008;
  _printf("\n%d");
  _printf("\n%d");
  iVar1 = _printf("\n%d");
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

size_t upper_bound(const int* array, size_t n, int value) {
    size_t start = 0;
    while (n > 0) {
        size_t step = n / 2;
        size_t index = start + step;
        if (value >= array[index]) {
            start = index + 1;
            n -= step + 1;
        } else {
            n = step;
        }
    }
    return start;
}

int* bins(const int* limits, size_t nlimits, const int* data, size_t ndata) {
    int* result = calloc(nlimits + 1, sizeof(int));
    if (result == NULL)
        return NULL;
    for (size_t i = 0; i < ndata; ++i)
        ++result[upper_bound(limits, nlimits, data[i])];
    return result;
}

void print_bins(const int* limits, size_t n, const int* bins) {
    if (n == 0)
        return;
    printf("           < %3d: %2d\n", limits[0], bins[0]);
    for (size_t i = 1; i < n; ++i)
        printf(">= %3d and < %3d: %2d\n", limits[i - 1], limits[i], bins[i]);
    printf(">= %3d          : %2d\n", limits[n - 1], bins[n]);
}

int main() {
    const int limits1[] = {23, 37, 43, 53, 67, 83};
    const int data1[] = {95, 21, 94, 12, 99, 4,  70, 75, 83, 93, 52, 80, 57,
                         5,  53, 86, 65, 17, 92, 83, 71, 61, 54, 58, 47, 16,
                         8,  9,  32, 84, 7,  87, 46, 19, 30, 37, 96, 6,  98,
                         40, 79, 97, 45, 64, 60, 29, 49, 36, 43, 55};

    printf("Example 1:\n");
    size_t n = sizeof(limits1) / sizeof(int);
    int* b = bins(limits1, n, data1, sizeof(data1) / sizeof(int));
    if (b == NULL) {
        fprintf(stderr, "Out of memory\n");
        return EXIT_FAILURE;
    }
    print_bins(limits1, n, b);
    free(b);

    const int limits2[] = {14, 18, 249, 312, 389, 392, 513, 591, 634, 720};
    const int data2[] = {
        445, 814, 519, 697, 700, 130, 255, 889, 481, 122, 932, 77,  323, 525,
        570, 219, 367, 523, 442, 933, 416, 589, 930, 373, 202, 253, 775, 47,
        731, 685, 293, 126, 133, 450, 545, 100, 741, 583, 763, 306, 655, 267,
        248, 477, 549, 238, 62,  678, 98,  534, 622, 907, 406, 714, 184, 391,
        913, 42,  560, 247, 346, 860, 56,  138, 546, 38,  985, 948, 58,  213,
        799, 319, 390, 634, 458, 945, 733, 507, 916, 123, 345, 110, 720, 917,
        313, 845, 426, 9,   457, 628, 410, 723, 354, 895, 881, 953, 677, 137,
        397, 97,  854, 740, 83,  216, 421, 94,  517, 479, 292, 963, 376, 981,
        480, 39,  257, 272, 157, 5,   316, 395, 787, 942, 456, 242, 759, 898,
        576, 67,  298, 425, 894, 435, 831, 241, 989, 614, 987, 770, 384, 692,
        698, 765, 331, 487, 251, 600, 879, 342, 982, 527, 736, 795, 585, 40,
        54,  901, 408, 359, 577, 237, 605, 847, 353, 968, 832, 205, 838, 427,
        876, 959, 686, 646, 835, 127, 621, 892, 443, 198, 988, 791, 466, 23,
        707, 467, 33,  670, 921, 180, 991, 396, 160, 436, 717, 918, 8,   374,
        101, 684, 727, 749};

    printf("\nExample 2:\n");
    n = sizeof(limits2) / sizeof(int);
    b = bins(limits2, n, data2, sizeof(data2) / sizeof(int));
    if (b == NULL) {
        fprintf(stderr, "Out of memory\n");
        return EXIT_FAILURE;
    }
    print_bins(limits2, n, b);
    free(b);

    return EXIT_SUCCESS;
}
`,`#include "bin-given-limits.h"



long _upper_bound(long param_1,ulong param_2,int param_3)

{
  ulong uVar1;
  long local_20;
  ulong local_10;
  
  local_20 = 0;
  uVar1 = param_2;
  while (local_10 = uVar1, local_10 != 0) {
    uVar1 = local_10 / 2;
    if (*(int *)(param_1 + (local_20 + uVar1) * 4) <= param_3) {
      local_20 = local_20 + uVar1 + 1;
      uVar1 = local_10 - (uVar1 + 1);
    }
  }
  return local_20;
}



void * _bins(undefined8 param_1,long param_2,long param_3,ulong param_4)

{
  int *piVar1;
  long lVar2;
  undefined8 local_48;
  undefined8 local_18;
  
  local_18 = _calloc(param_2 + 1,4);
  if (local_18 == (void *)0x0) {
    local_18 = (void *)0x0;
  }
  else {
    for (local_48 = 0; local_48 < param_4; local_48 = local_48 + 1) {
      lVar2 = _upper_bound(param_1,param_2,*(undefined4 *)(param_3 + local_48 * 4));
      piVar1 = (int *)((long)local_18 + lVar2 * 4);
      *piVar1 = *piVar1 + 1;
    }
  }
  return local_18;
}



ulong _print_bins(ulong param_1,ulong param_2)

{
  uint uVar1;
  ulong local_30;
  
  if (param_2 != 0) {
    _printf("           < %3d: %2d\n");
    for (local_30 = 1; local_30 < param_2; local_30 = local_30 + 1) {
      _printf(">= %3d and < %3d: %2d\n");
    }
    uVar1 = _printf(">= %3d          : %2d\n");
    param_1 = (ulong)uVar1;
  }
  return param_1;
}



undefined4 entry(void)

{
  void *pvVar1;
  undefined4 local_454;
  undefined auStack_450 [800];
  undefined auStack_130 [40];
  undefined auStack_108 [200];
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_38 = 0x350000002b;
  local_40 = 0x2500000017;
  local_30 = 0x5300000043;
  _memcpy(auStack_108,&DAT_100003b88,200);
  _printf("Example 1:\n");
  pvVar1 = (void *)_bins(&local_40,6,auStack_108,0x32);
  if (pvVar1 == (void *)0x0) {
    _fprintf(*(FILE **)PTR____stderrp_100004010,"Out of memory\n");
    local_454 = 1;
  }
  else {
    _print_bins(&local_40,6,pvVar1);
    _free(pvVar1);
    _memcpy(auStack_130,&DAT_100003c50,0x28);
    _memcpy(auStack_450,&DAT_100003c78,800);
    _printf("\nExample 2:\n");
    pvVar1 = (void *)_bins(auStack_130,10,auStack_450,200);
    if (pvVar1 == (void *)0x0) {
      _fprintf(*(FILE **)PTR____stderrp_100004010,"Out of memory\n");
      local_454 = 1;
    }
    else {
      _print_bins(auStack_130,10,pvVar1);
      _free(pvVar1);
      local_454 = 0;
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return local_454;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ac0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003acc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ad8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ae4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003af0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004030)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003afc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <complex.h>
#include <math.h>

typedef double complex cplx;

void quad_root
(double a, double b, double c, cplx * ra, cplx *rb)
{
	double d, e;
	if (!a) {
		*ra = b ? -c / b : 0;
		*rb = 0;
		return;
	}
	if (!c) {
		*ra = 0;
		*rb = -b / a;
		return;
	}

	b /= 2;
	if (fabs(b) > fabs(c)) {
		e = 1 - (a / b) * (c / b);
		d = sqrt(fabs(e)) * fabs(b);
	} else {
		e = (c > 0) ? a : -a;
		e = b * (b / fabs(c)) - e;
		d = sqrt(fabs(e)) * sqrt(fabs(c));
	}

	if (e < 0) {
		e = fabs(d / a);
		d = -b / a;
		*ra = d + I * e;
		*rb = d - I * e;
		return;
	}

	d = (b >= 0) ? d : -d;
	e = (d - b) / a;
	d = e ? (c / e) / a : 0;
	*ra = d;
	*rb = e;
	return;
}

int main()
{
	cplx ra, rb;
	quad_root(1, 1e12 + 1, 1e12, &ra, &rb);
	printf("(%g + %g i), (%g + %g i)\n",
		creal(ra), cimag(ra), creal(rb), cimag(rb));

	quad_root(1e300, -1e307 + 1, 1e300, &ra, &rb);
	printf("(%g + %g i), (%g + %g i)\n",
		creal(ra), cimag(ra), creal(rb), cimag(rb));

	return 0;
}
`,`#include "roots-of-a-quadratic-function-1.h"



void _quad_root(double param_1,double param_2,double param_3,double *param_4,double *param_5)

{
  double dVar1;
  double local_58;
  double local_50;
  double local_48;
  double local_40;
  double local_38;
  double local_30;
  
  if (param_1 == 0.0) {
    if (param_2 == 0.0) {
      local_40 = 0.0;
    }
    else {
      local_40 = -param_3 / param_2;
    }
    *param_4 = local_40;
    param_4[1] = 0.0;
    *param_5 = 0.0;
    param_5[1] = 0.0;
  }
  else if (param_3 == 0.0) {
    *param_4 = 0.0;
    param_4[1] = 0.0;
    *param_5 = -param_2 / param_1;
    param_5[1] = 0.0;
  }
  else {
    param_2 = param_2 / 2.0;
    if (ABS(param_2) <= ABS(param_3)) {
      local_48 = param_1;
      if (param_3 <= 0.0) {
        local_48 = -param_1;
      }
      local_38 = (double)NEON_fnmsub(param_2,param_2 / ABS(param_3),local_48);
      local_30 = SQRT(ABS(local_38)) * SQRT(ABS(param_3));
    }
    else {
      local_38 = (double)NEON_fmsub(param_1 / param_2,param_3 / param_2,0x3ff0000000000000);
      local_30 = SQRT(ABS(local_38)) * ABS(param_2);
    }
    if (0.0 <= local_38) {
      if (param_2 < 0.0) {
        local_50 = -local_30;
      }
      else {
        local_50 = local_30;
      }
      dVar1 = (local_50 - param_2) / param_1;
      if (dVar1 == 0.0) {
        local_58 = 0.0;
      }
      else {
        local_58 = (param_3 / dVar1) / param_1;
      }
      *param_4 = local_58;
      param_4[1] = 0.0;
      *param_5 = dVar1;
      param_5[1] = 0.0;
    }
    else {
      dVar1 = ABS(local_30 / param_1);
      *param_4 = -param_2 / param_1 + dVar1 * 0.0;
      param_4[1] = dVar1 * 1.0;
      *param_5 = -param_2 / param_1 - dVar1 * 0.0;
      param_5[1] = -(dVar1 * 1.0);
    }
  }
  return;
}



undefined4 entry(void)

{
  undefined local_38 [16];
  undefined local_28 [20];
  undefined4 local_14;
  
  local_14 = 0;
  _quad_root(0x3ff0000000000000,0x426d1a94a2002000,0x426d1a94a2000000);
  _printf("(%g + %g i), (%g + %g i)\n");
  _quad_root(0x7e37e43c8800759c,0xffac7b1f3cac7433,local_28,local_38);
  _printf("(%g + %g i), (%g + %g i)\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`/*Abhishek Ghosh, 7th December 2018*/

#include<stdio.h>

int totient(int n){
	int tot = n,i;
	
	for(i=2;i*i<=n;i+=2){
		if(n%i==0){
			while(n%i==0)
				n/=i;
			tot-=tot/i;
		}
		
		if(i==2)
			i=1;
	}
	
	if(n>1)
		tot-=tot/n;
	
	return tot;
}

int main()
{
	int count = 0,n,tot;
	
	printf(" n    %c   prime",237);
        printf("\n---------------\n");
	
	for(n=1;n<=25;n++){
		tot = totient(n);
		
		if(n-1 == tot)
			count++;
		
		printf("%2d   %2d   %s\n", n, tot, n-1 == tot?"True":"False");
	}
	
	printf("\nNumber of primes up to %6d =%4d\n", 25,count);
	
	for(n = 26; n <= 100000; n++){
        tot = totient(n);
        if(tot == n-1)
			count++;

        if(n == 100 || n == 1000 || n%10000 == 0){
            printf("\nNumber of primes up to %6d = %4d\n", n, count);
        }
    }
	
	return 0;
}
`,`#include "totient-function.h"



int _totient(int param_1)

{
  int iVar1;
  int iVar2;
  undefined4 local_c;
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = param_1;
  local_4 = param_1;
  for (local_c = 2; local_c * local_c <= local_4; local_c = local_c + 2) {
    iVar1 = 0;
    if (local_c != 0) {
      iVar1 = local_4 / local_c;
    }
    iVar2 = local_4;
    if (local_4 == iVar1 * local_c) {
      while( true ) {
        local_4 = iVar2;
        iVar1 = 0;
        if (local_c != 0) {
          iVar1 = local_4 / local_c;
        }
        if (local_4 != iVar1 * local_c) break;
        iVar2 = 0;
        if (local_c != 0) {
          iVar2 = local_4 / local_c;
        }
      }
      iVar1 = 0;
      if (local_c != 0) {
        iVar1 = local_8 / local_c;
      }
      local_8 = local_8 - iVar1;
    }
    if (local_c == 2) {
      local_c = 1;
    }
  }
  if (1 < local_4) {
    iVar1 = 0;
    if (local_4 != 0) {
      iVar1 = local_8 / local_4;
    }
    local_8 = local_8 - iVar1;
  }
  return local_8;
}



undefined8 entry(void)

{
  int local_1c;
  
  _printf(" n    %c   prime");
  _printf("\n---------------\n");
  for (local_1c = 1; local_1c < 0x1a; local_1c = local_1c + 1) {
    _totient(local_1c);
    _printf("%2d   %2d   %s\n");
  }
  _printf("\nNumber of primes up to %6d =%4d\n");
  for (local_1c = 0x1a; local_1c < 0x186a1; local_1c = local_1c + 1) {
    _totient(local_1c);
    if (((local_1c == 100) || (local_1c == 1000)) || (local_1c % 10000 == 0)) {
      _printf("\nNumber of primes up to %6d = %4d\n");
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

typedef char bool;

#define TRUE 1
#define FALSE 0

bool same_digits(int n, int b) {
    int f = n % b;
    n /= b;
    while (n > 0) {
        if (n % b != f) return FALSE;
        n /= b;
    }
    return TRUE;
}

bool is_brazilian(int n) {
    int b;
    if (n < 7) return FALSE;
    if (!(n % 2) && n >= 8) return TRUE;
    for (b = 2; b < n - 1; ++b) {
        if (same_digits(n, b)) return TRUE;
    }
    return FALSE;
}

bool is_prime(int n) {
    int d = 5;
    if (n < 2) return FALSE;
    if (!(n % 2)) return n == 2;
    if (!(n % 3)) return n == 3;
    while (d * d <= n) {
        if (!(n % d)) return FALSE;
        d += 2;
        if (!(n % d)) return FALSE;
        d += 4;
    }
    return TRUE;
}

int main() {
    int i, c, n;
    const char *kinds[3] = {" ", " odd ", " prime "};
    for (i = 0; i < 3; ++i) {
        printf("First 20%sBrazilian numbers:\n", kinds[i]);
        c = 0;
        n = 7;
        while (TRUE) {
            if (is_brazilian(n)) {
                printf("%d ", n);
                if (++c == 20) {
                    printf("\n\n");
                    break;
                }
            }
            switch (i) {
                case 0: n++; break;
                case 1: n += 2; break;
                case 2:
                    do {
                        n += 2;
                    } while (!is_prime(n));
                    break;
            }
        }
    }

    for (n = 7, c = 0; c < 100000; ++n) {
        if (is_brazilian(n)) c++;
    }
    printf("The 100,000th Brazilian number: %d\n", n - 1);
    return 0;
}
`,`#include "brazilian-numbers.h"



undefined _same_digits(int param_1,int param_2)

{
  int iVar1;
  int iVar2;
  int local_8;
  
  iVar1 = 0;
  if (param_2 != 0) {
    iVar1 = param_1 / param_2;
  }
  iVar2 = 0;
  if (param_2 != 0) {
    iVar2 = param_1 / param_2;
  }
  while( true ) {
    local_8 = iVar2;
    if (local_8 < 1) {
      return 1;
    }
    iVar2 = 0;
    if (param_2 != 0) {
      iVar2 = local_8 / param_2;
    }
    if (local_8 - iVar2 * param_2 != param_1 - iVar1 * param_2) break;
    iVar2 = 0;
    if (param_2 != 0) {
      iVar2 = local_8 / param_2;
    }
  }
  return 0;
}



undefined _is_brazilian(int param_1)

{
  char cVar1;
  int local_1c;
  undefined local_11;
  
  if (param_1 < 7) {
    local_11 = 0;
  }
  else if ((param_1 % 2 == 0) && (7 < param_1)) {
    local_11 = 1;
  }
  else {
    for (local_1c = 2; local_1c < param_1 + -1; local_1c = local_1c + 1) {
      cVar1 = _same_digits(param_1,local_1c);
      if (cVar1 != '\0') {
        return 1;
      }
    }
    local_11 = 0;
  }
  return local_11;
}



bool _is_prime(int param_1)

{
  int iVar1;
  int iVar2;
  int local_c;
  bool local_1;
  
  local_c = 5;
  if (param_1 < 2) {
    local_1 = false;
  }
  else if (param_1 % 2 == 0) {
    local_1 = param_1 == 2;
  }
  else if (param_1 % 3 == 0) {
    local_1 = param_1 == 3;
  }
  else {
    for (; local_c * local_c <= param_1; local_c = local_c + 6) {
      iVar1 = 0;
      if (local_c != 0) {
        iVar1 = param_1 / local_c;
      }
      if (param_1 == iVar1 * local_c) {
        return false;
      }
      iVar1 = local_c + 2;
      iVar2 = 0;
      if (iVar1 != 0) {
        iVar2 = param_1 / iVar1;
      }
      if (param_1 == iVar2 * iVar1) {
        return false;
      }
    }
    local_1 = true;
  }
  return local_1;
}



undefined8 entry(void)

{
  char cVar1;
  int iVar2;
  long lVar3;
  int local_40;
  int local_3c;
  int local_38;
  
  lVar3 = *(long *)PTR____stack_chk_guard_100004008;
  local_38 = 0;
LAB_100003d18:
  if (2 < local_38) {
    local_40 = 7;
    local_3c = 0;
    while (local_3c < 100000) {
      cVar1 = _is_brazilian(local_40);
      if (cVar1 != '\0') {
        local_3c = local_3c + 1;
      }
      local_40 = local_40 + 1;
    }
    iVar2 = _printf("The 100,000th Brazilian number: %d\n");
    if (*(long *)PTR____stack_chk_guard_100004008 == lVar3) {
      return 0;
    }
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  _printf("First 20%sBrazilian numbers:\n");
  local_3c = 0;
  local_40 = 7;
LAB_100003d5c:
  cVar1 = _is_brazilian(local_40);
  if (cVar1 != '\0') {
    _printf("%d ");
    local_3c = local_3c + 1;
    if (local_3c == 0x14) goto LAB_100003dac;
  }
  if (local_38 == 0) {
    local_40 = local_40 + 1;
  }
  else if (local_38 == 1) {
    local_40 = local_40 + 2;
  }
  else if (local_38 == 2) {
    do {
      local_40 = local_40 + 2;
      cVar1 = _is_prime(local_40);
    } while (cVar1 == '\0');
  }
  goto LAB_100003d5c;
LAB_100003dac:
  _printf("\n\n");
  local_38 = local_38 + 1;
  goto LAB_100003d18;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

typedef struct {
	char mask;    /* char data will be bitwise AND with this */
	char lead;    /* start bytes of current char in utf-8 encoded character */
	uint32_t beg; /* beginning of codepoint range */
	uint32_t end; /* end of codepoint range */
	int bits_stored; /* the number of bits from the codepoint that fits in char */
}utf_t;

utf_t * utf[] = {
	/*             mask        lead        beg      end       bits */
	[0] = &(utf_t){0b00111111, 0b10000000, 0,       0,        6    },
	[1] = &(utf_t){0b01111111, 0b00000000, 0000,    0177,     7    },
	[2] = &(utf_t){0b00011111, 0b11000000, 0200,    03777,    5    },
	[3] = &(utf_t){0b00001111, 0b11100000, 04000,   0177777,  4    },
	[4] = &(utf_t){0b00000111, 0b11110000, 0200000, 04177777, 3    },
	      &(utf_t){0},
};

/* All lengths are in bytes */
int codepoint_len(const uint32_t cp); /* len of associated utf-8 char */
int utf8_len(const char ch);          /* len of utf-8 encoded char */

char *to_utf8(const uint32_t cp);
uint32_t to_cp(const char chr[4]);

int codepoint_len(const uint32_t cp)
{
	int len = 0;
	for(utf_t **u = utf; *u; ++u) {
		if((cp >= (*u)->beg) && (cp <= (*u)->end)) {
			break;
		}
		++len;
	}
	if(len > 4) /* Out of bounds */
		exit(1);

	return len;
}

int utf8_len(const char ch)
{
	int len = 0;
	for(utf_t **u = utf; *u; ++u) {
		if((ch & ~(*u)->mask) == (*u)->lead) {
			break;
		}
		++len;
	}
	if(len > 4) { /* Malformed leading byte */
		exit(1);
	}
	return len;
}

char *to_utf8(const uint32_t cp)
{
	static char ret[5];
	const int bytes = codepoint_len(cp);

	int shift = utf[0]->bits_stored * (bytes - 1);
	ret[0] = (cp >> shift & utf[bytes]->mask) | utf[bytes]->lead;
	shift -= utf[0]->bits_stored;
	for(int i = 1; i < bytes; ++i) {
		ret[i] = (cp >> shift & utf[0]->mask) | utf[0]->lead;
		shift -= utf[0]->bits_stored;
	}
	ret[bytes] = '\0';
	return ret;
}

uint32_t to_cp(const char chr[4])
{
	int bytes = utf8_len(*chr);
	int shift = utf[0]->bits_stored * (bytes - 1);
	uint32_t codep = (*chr++ & utf[bytes]->mask) << shift;

	for(int i = 1; i < bytes; ++i, ++chr) {
		shift -= utf[0]->bits_stored;
		codep |= ((char)*chr & utf[0]->mask) << shift;
	}

	return codep;
}

int main(void)
{
	const uint32_t *in, input[] = {0x0041, 0x00f6, 0x0416, 0x20ac, 0x1d11e, 0x0};

	printf("Character  Unicode  UTF-8 encoding (hex)\n");
	printf("----------------------------------------\n");

	char *utf8;
	uint32_t codepoint;
	for(in = input; *in; ++in) {
		utf8 = to_utf8(*in);
		codepoint = to_cp(utf8);
		printf("%s          U+%-7.4x", utf8, codepoint);

		for(int i = 0; utf8[i] && i < 4; ++i) {
			printf("%hhx ", utf8[i]);
		}
		printf("\n");
	}
	return 0;
}
`,`#include "utf-8-encode-and-decode-1.h"



int _codepoint_len(uint param_1)

{
  undefined **local_20;
  int local_18;
  
  local_18 = 0;
  for (local_20 = &_utf;
      (*local_20 != (undefined *)0x0 &&
      ((param_1 < *(uint *)(*local_20 + 4) || (*(uint *)(*local_20 + 8) < param_1))));
      local_20 = local_20 + 1) {
    local_18 = local_18 + 1;
  }
  if (local_18 < 5) {
    return local_18;
  }
                    // WARNING: Subroutine does not return
  _exit(1);
}



int _utf8_len(byte param_1)

{
  undefined **local_20;
  int local_18;
  
  local_18 = 0;
  local_20 = &_utf;
  while ((*local_20 != (undefined *)0x0 &&
         (((uint)param_1 & ((int)(char)**local_20 ^ 0xffffffffU)) != (int)(char)(*local_20)[1]))) {
    local_18 = local_18 + 1;
    local_20 = local_20 + 1;
  }
  if (local_18 < 5) {
    return local_18;
  }
                    // WARNING: Subroutine does not return
  _exit(1);
}



void _to_utf8(uint param_1)

{
  int iVar1;
  int local_20;
  uint local_1c;
  
  iVar1 = _codepoint_len(param_1);
  local_1c = *(int *)(_utf + 0xc) * (iVar1 + -1);
  DAT_100008090 = (byte)(param_1 >> (ulong)(local_1c & 0x1f)) & *(&_utf)[iVar1] | (&_utf)[iVar1][1];
  local_1c = local_1c - *(int *)(_utf + 0xc);
  for (local_20 = 1; local_20 < iVar1; local_20 = local_20 + 1) {
    (&DAT_100008090)[local_20] = (byte)(param_1 >> (ulong)(local_1c & 0x1f)) & *_utf | _utf[1];
    local_1c = local_1c - *(int *)(_utf + 0xc);
  }
  (&DAT_100008090)[iVar1] = 0;
  return;
}



uint _to_cp(byte *param_1)

{
  int iVar1;
  int local_28;
  uint local_24;
  uint local_20;
  byte *local_18;
  
  iVar1 = _utf8_len((long)(char)*param_1);
  local_20 = *(int *)(_utf + 0xc) * (iVar1 + -1);
  local_18 = param_1 + 1;
  local_24 = (int)(char)(*param_1 & *(&_utf)[iVar1]) << (ulong)(local_20 & 0x1f);
  for (local_28 = 1; local_28 < iVar1; local_28 = local_28 + 1) {
    local_20 = local_20 - *(int *)(_utf + 0xc);
    local_24 = local_24 | (int)(char)(*local_18 & *_utf) << (ulong)(local_20 & 0x1f);
    local_18 = local_18 + 1;
  }
  return local_24;
}



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  int local_50;
  int *local_40;
  int local_30 [6];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_30[2] = 0x416;
  local_30[3] = 0x20ac;
  local_30[0] = 0x41;
  local_30[1] = 0xf6;
  local_30[4] = 0x1d11e;
  local_30[5] = 0;
  _printf("Character  Unicode  UTF-8 encoding (hex)\n");
  iVar1 = _printf("----------------------------------------\n");
  for (local_40 = local_30; *local_40 != 0; local_40 = local_40 + 1) {
    lVar2 = _to_utf8(*local_40);
    _to_cp(lVar2);
    _printf("%s          U+%-7.4x");
    for (local_50 = 0; *(char *)(lVar2 + local_50) != '\0' && local_50 < 4; local_50 = local_50 + 1)
    {
      _printf("%hhx ");
    }
    iVar1 = _printf("\n");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>

#define C 7
typedef struct { double x, y; } pt;

pt zero(void) { return (pt){ INFINITY, INFINITY }; }

// should be INFINITY, but numeric precision is very much in the way
int is_zero(pt p) { return p.x > 1e20 || p.x < -1e20; }

pt neg(pt p) { return (pt){ p.x, -p.y }; }

pt dbl(pt p) {
	if (is_zero(p)) return p;

	pt r;
	double L = (3 * p.x * p.x) / (2 * p.y);
	r.x = L * L - 2 * p.x;
	r.y = L * (p.x - r.x) - p.y;
	return r;
}

pt add(pt p, pt q) {
	if (p.x == q.x && p.y == q.y) return dbl(p);
	if (is_zero(p)) return q;
	if (is_zero(q)) return p;

	pt r;
	double L = (q.y - p.y) / (q.x - p.x);
	r.x = L * L - p.x - q.x;
	r.y = L * (p.x - r.x) - p.y;
	return r;
}

pt mul(pt p, int n) {
	int i;
	pt r = zero();

	for (i = 1; i <= n; i <<= 1) {
		if (i & n) r = add(r, p);
		p = dbl(p);
	}
	return r;
}

void show(const char *s, pt p) {
	printf("%s", s);
	printf(is_zero(p) ? "Zero\n" : "(%.3f, %.3f)\n", p.x, p.y);
}

pt from_y(double y) {
	pt r;
	r.x = pow(y * y - C, 1.0/3);
	r.y = y;
	return r;
}

int main(void) {
	pt a, b, c, d;

	a = from_y(1);
	b = from_y(2);

	show("a = ", a);
	show("b = ", b);
	show("c = a + b = ", c = add(a, b));
	show("d = -c = ", d = neg(c));
	show("c + d = ", add(c, d));
	show("a + b + d = ", add(a, add(b, d)));
	show("a * 12345 = ", mul(a, 12345));

	return 0;
}
`,`#include "elliptic-curve-arithmetic.h"



undefined  [16] _zero(void)

{
  return ZEXT816(0x7ff0000000000000);
}



bool _is_zero(double param_1)

{
  return 1e+20 < param_1 || param_1 < -1e+20;
}



undefined  [16] _neg(ulong param_1)

{
  undefined auVar1 [16];
  
  auVar1._8_8_ = 0;
  auVar1._0_8_ = param_1;
  return auVar1;
}



undefined  [16] _dbl(double param_1,double param_2)

{
  int iVar1;
  double dVar2;
  undefined auVar3 [16];
  undefined8 local_20;
  
  iVar1 = _is_zero(param_1,param_2);
  local_20 = param_1;
  if (iVar1 == 0) {
    dVar2 = (param_1 * 3.0 * param_1) / (param_2 * 2.0);
    local_20 = (double)NEON_fnmsub(dVar2,dVar2,param_1 * 2.0);
    NEON_fnmsub(dVar2,param_1 - local_20,param_2);
  }
  auVar3._8_8_ = 0;
  auVar3._0_8_ = local_20;
  return auVar3;
}



undefined  [16] _add(double param_1,double param_2,double param_3,double param_4)

{
  int iVar1;
  double dVar2;
  undefined auVar3 [16];
  double local_20;
  
  if ((param_1 == param_3) && (param_2 == param_4)) {
    local_20 = (double)_dbl(param_1);
  }
  else {
    iVar1 = _is_zero(param_1,param_2);
    local_20 = param_3;
    if ((iVar1 == 0) && (iVar1 = _is_zero(param_3,param_4), local_20 = param_1, iVar1 == 0)) {
      dVar2 = (param_4 - param_2) / (param_3 - param_1);
      local_20 = (double)NEON_fnmsub(dVar2,dVar2,param_1);
      local_20 = local_20 - param_3;
      NEON_fnmsub(dVar2,param_1 - local_20,param_2);
    }
  }
  auVar3._8_8_ = 0;
  auVar3._0_8_ = local_20;
  return auVar3;
}



undefined  [16] _mul(undefined8 param_1,undefined8 param_2,uint param_3)

{
  undefined auVar1 [16];
  undefined4 local_38;
  undefined8 local_30;
  undefined8 uStack_28;
  undefined8 local_20;
  undefined8 uStack_18;
  
  uStack_18 = param_2;
  local_20 = _zero();
  local_30 = param_1;
  uStack_28 = param_2;
  for (local_38 = 1; (int)local_38 <= (int)param_3; local_38 = local_38 << 1) {
    if ((local_38 & param_3) != 0) {
      local_20 = _add(local_20,uStack_18,local_30,uStack_28);
    }
    local_30 = _dbl(local_30);
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_20;
  return auVar1;
}



int _show(undefined8 param_1,undefined8 param_2)

{
  char *pcVar1;
  int iVar2;
  
  iVar2 = _printf("%s");
  iVar2 = _is_zero(param_1,param_2,iVar2);
  pcVar1 = "Zero\n";
  if (iVar2 == 0) {
    pcVar1 = "(%.3f, %.3f)\n";
  }
  iVar2 = _printf(pcVar1);
  return iVar2;
}



undefined  [16] _from_y(undefined8 param_1)

{
  undefined8 uVar1;
  undefined auVar2 [16];
  
  uVar1 = NEON_fmadd(param_1,param_1,0xc01c000000000000);
  auVar2._0_8_ = _pow(uVar1,0x3fd5555555555555);
  auVar2._8_8_ = 0;
  return auVar2;
}



undefined4 entry(undefined param_1 [16],undefined8 param_2)

{
  undefined8 uVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  undefined8 uVar4;
  undefined8 uVar5;
  undefined8 uVar6;
  undefined8 uVar7;
  
  uVar1 = _from_y(0x3ff0000000000000);
  uVar6 = param_2;
  uVar2 = _from_y(0x4000000000000000);
  _show(uVar1,param_2,"a = ");
  _show(uVar2,uVar6,"b = ");
  uVar7 = param_2;
  uVar3 = _add(uVar1,param_2,uVar2,uVar6);
  _show(uVar3,uVar7,"c = a + b = ");
  uVar5 = uVar7;
  uVar4 = _neg(uVar3);
  _show(uVar4,uVar5,"d = -c = ");
  uVar3 = _add(uVar3,uVar7,uVar4,uVar5);
  _show(uVar3,uVar7,"c + d = ");
  uVar5 = _add(uVar2,uVar6,uVar4,uVar5);
  uVar7 = param_2;
  uVar6 = _add(uVar1,param_2,uVar5,uVar6);
  _show(uVar6,uVar7,"a + b + d = ");
  uVar6 = _mul(uVar1,0x3039);
  _show(uVar6,param_2,"a * 12345 = ");
  return 0;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

int main()
{
	setlocale(LC_CTYPE, "");
	char moose[] = "mse";
	printf("bytes: %d\n", sizeof(moose) - 1);
	printf("chars: %d\n", (int)mbstowcs(0, moose, 0));

	return 0;
}
`,`#include "string-length-5.h"



undefined8 entry(void)

{
  int iVar1;
  char local_20 [8];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _setlocale(2,"");
  builtin_strncpy(local_20,"mse",8);
  _printf("bytes: %d\n");
  _mbstowcs((wchar_t *)0x0,local_20,0);
  iVar1 = _printf("chars: %d\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _mbstowcs(wchar_t *param_1,char *param_2,size_t param_3)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__mbstowcs_100004010)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004020)();
  return;
}


`
`#include <stdlib.h>
#include <stdio.h>

int main(int argc, const char *argv[]) {
  const int max = 1000;
  int *a = malloc(max * sizeof(int));
  for (int n = 0; n < max - 1; n ++) {
    for (int m = n - 1; m >= 0; m --) {
      if (a[m] == a[n]) {
        a[n+1] = n - m;
        break;
      }
    }
  }

  printf("The first ten terms of the Van Eck sequence are:\n");
  for (int i = 0; i < 10; i ++) printf("%d ", a[i]);
  printf("\n\nTerms 991 to 1000 of the sequence are:\n");
  for (int i = 990; i < 1000; i ++) printf("%d ", a[i]);
  putchar('\n');

  return 0;
}
`,`#include "van-eck-sequence.h"



undefined8 entry(void)

{
  void *pvVar1;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  
  pvVar1 = _malloc(4000);
  local_34 = 0;
  do {
    local_38 = local_34;
    if (0x3e6 < local_34) {
      _printf("The first ten terms of the Van Eck sequence are:\n");
      for (local_3c = 0; local_3c < 10; local_3c = local_3c + 1) {
        _printf("%d ");
      }
      _printf("\n\nTerms 991 to 1000 of the sequence are:\n");
      for (local_40 = 0x3de; local_40 < 1000; local_40 = local_40 + 1) {
        _printf("%d ");
      }
      _putchar(10);
      return 0;
    }
    do {
      local_38 = local_38 + -1;
      if (local_38 < 0) goto LAB_100003e38;
    } while (*(int *)((long)pvVar1 + (long)local_38 * 4) !=
             *(int *)((long)pvVar1 + (long)local_34 * 4));
    *(int *)((long)pvVar1 + (long)(local_34 + 1) * 4) = local_34 - local_38;
LAB_100003e38:
    local_34 = local_34 + 1;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004010)(param_1);
  return iVar1;
}


`
`#include<stdio.h>

int main()
{
  printf("\nHello world!");
  return 0;
}
`,`#include "hello-world-text-1.h"



undefined4 entry(void)

{
  _printf("\nHello world!");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv)
{
   int user1 = 0, user2 = 0;
   int *a1, **array, row;

   printf("Enter two integers.  Space delimited, please:  ");
   scanf("%d %d",&user1, &user2);

   a1 = malloc(user1*user2*sizeof(int));
   array = malloc(user1*sizeof(int*));
   for (row=0; row<user1; row++) array[row]=a1+row*user2;

   array[user1/2][user2/2] = user1 + user2;
   printf("array[%d][%d] is %d\n",user1/2,user2/2,array[user1/2][user2/2]);
   free(array);
   free(a1);
   return 0;
}
`,`#include "create-a-two-dimensional-array-at-runtime-3.h"



undefined8 entry(void)

{
  void *pvVar1;
  undefined8 *puVar2;
  int local_3c;
  
  _printf("Enter two integers.  Space delimited, please:  ");
  _scanf("%d %d");
  pvVar1 = _malloc(0);
  puVar2 = (undefined8 *)_malloc(0);
  for (local_3c = 0; local_3c < 0; local_3c = local_3c + 1) {
    puVar2[local_3c] = pvVar1;
  }
  *(undefined4 *)*puVar2 = 0;
  _printf("array[%d][%d] is %d\n");
  _free(puVar2);
  _free(pvVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double *cholesky(double *A, int n) {
    double *L = (double*)calloc(n * n, sizeof(double));
    if (L == NULL)
        exit(EXIT_FAILURE);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < (i+1); j++) {
            double s = 0;
            for (int k = 0; k < j; k++)
                s += L[i * n + k] * L[j * n + k];
            L[i * n + j] = (i == j) ?
                           sqrt(A[i * n + i] - s) :
                           (1.0 / L[j * n + j] * (A[i * n + j] - s));
        }

    return L;
}

void show_matrix(double *A, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            printf("%2.5f ", A[i * n + j]);
        printf("\n");
    }
}

int main() {
    int n = 3;
    double m1[] = {25, 15, -5,
                   15, 18,  0,
                   -5,  0, 11};
    double *c1 = cholesky(m1, n);
    show_matrix(c1, n);
    printf("\n");
    free(c1);

    n = 4;
    double m2[] = {18, 22,  54,  42,
                   22, 70,  86,  62,
                   54, 86, 174, 134,
                   42, 62, 134, 106};
    double *c2 = cholesky(m2, n);
    show_matrix(c2, n);
    free(c2);

    return 0;
}
`,`#include "cholesky-decomposition.h"



void * _cholesky(long param_1,int param_2)

{
  void *pvVar1;
  undefined8 local_48;
  undefined4 local_3c;
  undefined8 local_38;
  undefined4 local_30;
  undefined4 local_2c;
  
  pvVar1 = _calloc((long)(param_2 * param_2),8);
  if (pvVar1 == (void *)0x0) {
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  for (local_2c = 0; local_2c < param_2; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < local_2c + 1; local_30 = local_30 + 1) {
      local_38 = 0.0;
      for (local_3c = 0; local_3c < local_30; local_3c = local_3c + 1) {
        local_38 = (double)NEON_fmadd(*(undefined8 *)
                                       ((long)pvVar1 + (long)(local_2c * param_2 + local_3c) * 8),
                                      *(undefined8 *)
                                       ((long)pvVar1 + (long)(local_30 * param_2 + local_3c) * 8),
                                      local_38);
      }
      if (local_2c == local_30) {
        local_48 = SQRT(*(double *)(param_1 + (long)(local_2c * param_2 + local_2c) * 8) - local_38)
        ;
      }
      else {
        local_48 = (1.0 / *(double *)((long)pvVar1 + (long)(local_30 * param_2 + local_30) * 8)) *
                   (*(double *)(param_1 + (long)(local_2c * param_2 + local_30) * 8) - local_38);
      }
      *(double *)((long)pvVar1 + (long)(local_2c * param_2 + local_30) * 8) = local_48;
    }
  }
  return pvVar1;
}



ulong _show_matrix(ulong param_1,int param_2)

{
  uint uVar1;
  int local_24;
  int local_20;
  
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
      _printf("%2.5f ");
    }
    uVar1 = _printf("\n");
    param_1 = (ulong)uVar1;
  }
  return param_1;
}



undefined8 entry(void)

{
  void *pvVar1;
  undefined auStack_f0 [128];
  undefined auStack_70 [72];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_70,&DAT_100003ed8,0x48);
  pvVar1 = (void *)_cholesky(auStack_70,3);
  _show_matrix(pvVar1,3);
  _printf("\n");
  _free(pvVar1);
  _memcpy(auStack_f0,&DAT_100003f20,0x80);
  pvVar1 = (void *)_cholesky(auStack_f0,4);
  _show_matrix(pvVar1,4);
  _free(pvVar1);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e8c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e98. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004018)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define for_x for (int x = 0; x < w; x++)
#define for_y for (int y = 0; y < h; y++)
#define for_xy for_x for_y
void show(void *u, int w, int h)
{
	int (*univ)[w] = u;
	printf("\033[H");
	for_y {
		for_x printf(univ[y][x] ? "\033[07m  \033[m" : "  ");
		printf("\033[E");
	}
	fflush(stdout);
}

void evolve(void *u, int w, int h)
{
	unsigned (*univ)[w] = u;
	unsigned new[h][w];

	for_y for_x {
		int n = 0;
		for (int y1 = y - 1; y1 <= y + 1; y1++)
			for (int x1 = x - 1; x1 <= x + 1; x1++)
				if (univ[(y1 + h) % h][(x1 + w) % w])
					n++;

		if (univ[y][x]) n--;
		new[y][x] = (n == 3 || (n == 2 && univ[y][x]));
	}
	for_y for_x univ[y][x] = new[y][x];
}

void game(int w, int h)
{
	unsigned univ[h][w];
	for_xy univ[y][x] = rand() < RAND_MAX / 10 ? 1 : 0;
	while (1) {
		show(univ, w, h);
		evolve(univ, w, h);
		usleep(200000);
	}
}

int main(int c, char **v)
{
	int w = 0, h = 0;
	if (c > 1) w = atoi(v[1]);
	if (c > 2) h = atoi(v[2]);
	if (w <= 0) w = 30;
	if (h <= 0) h = 30;
	game(w, h);
}
`,`#include "conways-game-of-life-1.h"



int _show(long param_1,uint param_2,int param_3)

{
  char *pcVar1;
  int iVar2;
  int local_30;
  int local_2c;
  
  _printf("\x1b[H");
  for (local_2c = 0; local_2c < param_3; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < (int)param_2; local_30 = local_30 + 1) {
      pcVar1 = "\x1b[07m  \x1b[m";
      if (*(int *)(param_1 + (long)local_2c * (ulong)param_2 * 4 + (long)local_30 * 4) == 0) {
        pcVar1 = "  ";
      }
      _printf(pcVar1);
    }
    _printf("\x1b[E");
  }
  iVar2 = _fflush(*(FILE **)PTR____stdoutp_100004018);
  return iVar2;
}



void _evolve(long param_1,uint param_2,uint param_3)

{
  int iVar1;
  int iVar2;
  undefined *local_a0;
  uint local_98;
  uint local_94;
  ulong local_90;
  ulong local_88;
  ulong local_80;
  ulong local_78;
  long local_70;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  ulong local_40;
  undefined *local_38;
  long local_30;
  uint local_28;
  uint local_24;
  long local_20;
  long local_18;
  
  local_38 = (undefined *)&local_a0;
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_90 = (ulong)param_2;
  local_78 = (ulong)param_3;
  local_88 = (ulong)param_2;
  local_80 = local_78 * local_88 * 4 + 0xf & 0xfffffffffffffff0;
  local_30 = param_1;
  local_28 = param_3;
  local_24 = param_2;
  local_20 = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_70 = (long)&local_a0 - local_80;
  local_40 = local_78;
  for (local_4c = 0; local_4c < (int)local_28; local_4c = local_4c + 1) {
    for (local_50 = 0; local_50 < (int)local_24; local_50 = local_50 + 1) {
      local_54 = 0;
      for (local_58 = local_4c + -1; local_58 <= local_4c + 1; local_58 = local_58 + 1) {
        for (local_5c = local_50 + -1; local_5c <= local_50 + 1; local_5c = local_5c + 1) {
          iVar1 = 0;
          if (local_28 != 0) {
            iVar1 = (int)(local_58 + local_28) / (int)local_28;
          }
          iVar2 = 0;
          if (local_24 != 0) {
            iVar2 = (int)(local_5c + local_24) / (int)local_24;
          }
          if (*(int *)(local_30 +
                       (long)(int)((local_58 + local_28) - iVar1 * local_28) * local_90 * 4 +
                      (long)(int)((local_5c + local_24) - iVar2 * local_24) * 4) != 0) {
            local_54 = local_54 + 1;
          }
        }
      }
      if (*(int *)(local_30 + (long)local_4c * local_90 * 4 + (long)local_50 * 4) != 0) {
        local_54 = local_54 + -1;
      }
      local_94 = 1;
      if (local_54 != 3) {
        local_98 = 0;
        if (local_54 == 2) {
          local_98 = (uint)(*(int *)(local_30 + (long)local_4c * local_90 * 4 + (long)local_50 * 4)
                           != 0);
        }
        local_94 = local_98;
      }
      *(uint *)(local_70 + (long)local_4c * local_88 * 4 + (long)local_50 * 4) = local_94;
    }
  }
  for (local_60 = 0; local_60 < (int)local_28; local_60 = local_60 + 1) {
    for (local_64 = 0; local_64 < (int)local_24; local_64 = local_64 + 1) {
      *(undefined4 *)(local_30 + (long)local_60 * local_90 * 4 + (long)local_64 * 4) =
           *(undefined4 *)(local_70 + (long)local_60 * local_88 * 4 + (long)local_64 * 4);
    }
  }
  local_a0 = local_38;
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



void _game(uint param_1,uint param_2)

{
  int iVar1;
  undefined auStack_60 [8];
  ulong local_58;
  ulong local_50;
  ulong local_48;
  undefined *local_40;
  int local_38;
  int local_34;
  ulong local_28;
  undefined *local_20;
  uint local_18;
  uint local_14;
  
  local_20 = auStack_60;
  local_48 = (ulong)param_2;
  local_58 = (ulong)param_1;
  local_50 = local_48 * local_58 * 4 + 0xf & 0xfffffffffffffff0;
  local_18 = param_2;
  local_14 = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_40 = auStack_60 + -local_50;
  local_28 = local_48;
  for (local_34 = 0; local_34 < (int)local_14; local_34 = local_34 + 1) {
    for (local_38 = 0; local_38 < (int)local_18; local_38 = local_38 + 1) {
      iVar1 = _rand();
      *(uint *)(local_40 + (long)local_34 * 4 + (long)local_38 * local_58 * 4) =
           (uint)(iVar1 < 0xccccccc);
    }
  }
  do {
    _show(local_40,local_14,local_18);
    _evolve(local_40,local_14,local_18);
    _usleep(200000);
  } while( true );
}



undefined4 entry(int param_1,long param_2)

{
  undefined4 local_28;
  undefined4 local_24;
  
  local_24 = 0;
  local_28 = 0;
  if (1 < param_1) {
    local_24 = _atoi(*(char **)(param_2 + 8));
  }
  if (2 < param_1) {
    local_28 = _atoi(*(char **)(param_2 + 0x10));
  }
  if (local_24 < 1) {
    local_24 = 0x1e;
  }
  if (local_28 < 1) {
    local_28 = 0x1e;
  }
  _game(local_24,local_28);
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004038)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _usleep(useconds_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__usleep_100004040)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

const char * board =  "ET AON RIS"
                      "BCDFGHJKLM"
                      "PQ/UVWXYZ.";

char encode[128] = {0};
char decode[128] = {0};
int row[2] = {0};

void read_table(const char *s)
{
        int i, code;
        for (i = 0; i < 30; i++) {
                if (s[i] == '\0') {
                        fprintf(stderr, "Table too short\n");
                        exit(1);
                }

                if (s[i] == ' ') {
                        row[  row[0] ? 1 : 0 ] = i;
                        continue;
                }

                code = ((i < 10) ? 0 : i < 20 ? row[0] : row[1])
                                * 10 + (i % 10);
                encode[0 + s[i]] = code; /* guess what 0 + s[i] does, sigh */
                decode[code] = s[i];
        }
}

void encipher(const char *in, char *out, int strip)
{
#define PUTCODE(c) { if (c > 9) {*(out++) = c / 10 + '0'; c %= 10;} *(out++) = c + '0'; }
        int c, code;
        while ((c = *(in++)) != '\0') {
                if (c >= '0' && c <= '9') {
                        code = encode['.'];
                        c -= '0';
                        PUTCODE(code);
                        PUTCODE(c);
                        continue;
                }

                c &= ~0x20;

                if (c >= 'A' && c <= 'Z') code = encode[c];
                else if (strip && !c )    continue;
                else                      code = encode['/'];

                PUTCODE(code);
        }
        *(out++) = '\0';
}

void decipher(const char *in, char *out, int strip)
{
        int c;
        while ((c = *(in++)) != '\0') {
                c -= '0';
                if (c == row[0] || c == row[1])
                        c = c * 10 + *(in++) - '0';

                c = decode[c];

                if (c == '.') c = *(in++);
                if (c == '/' && !strip) c = ' ';
                *(out++) = c;
        }
        *(out++) = '\0';
}

int main()
{
        const char *msg = "In the winter 1965/we were hungry/just barely alive";
        char enc[100] = {0}, dec[100] = {0};
        read_table(board);

        printf("message: %s\n", msg);
        encipher(msg, enc, 0); printf("encoded: %s\n", enc);
        decipher(enc, dec, 0); printf("decoded: %s\n", dec);

        printf("\nNo spaces:\n");
        encipher(msg, enc, 1); printf("encoded: %s\n", enc);
        decipher(enc, dec, 1); printf("decoded: %s\n", dec);
        return 0;
}
`,`#include "straddling-checkerboard-2.h"



void _read_table(long param_1)

{
  int iVar1;
  int local_28;
  int local_24;
  int local_1c;
  
  local_1c = 0;
  while( true ) {
    if (0x1d < local_1c) {
      return;
    }
    if (*(char *)(param_1 + local_1c) == '\0') break;
    if (*(char *)(param_1 + local_1c) == ' ') {
      (&_row)[(int)(uint)(_row != 0)] = local_1c;
    }
    else {
      if (local_1c < 10) {
        local_24 = 0;
      }
      else {
        if (local_1c < 0x14) {
          local_28 = _row;
        }
        else {
          local_28 = DAT_10000810c;
        }
        local_24 = local_28;
      }
      iVar1 = local_24 * 10 + local_1c % 10;
      (&_encode)[(int)*(char *)(param_1 + local_1c)] = (char)iVar1;
      (&_decode)[iVar1] = *(undefined *)(param_1 + local_1c);
    }
    local_1c = local_1c + 1;
  }
  _fprintf(*(FILE **)PTR____stderrp_100004010,"Table too short\n");
                    // WARNING: Subroutine does not return
  _exit(1);
}



void _encipher(char *param_1,char *param_2,int param_3)

{
  char *pcVar1;
  uint uVar2;
  char local_1c;
  int local_18;
  char *local_10;
  char *local_8;
  
  local_10 = param_2;
  local_8 = param_1;
LAB_1000039c4:
  while( true ) {
    local_1c = DAT_100008036;
    pcVar1 = local_8 + 1;
    uVar2 = (uint)*local_8;
    if (uVar2 == 0) {
      *local_10 = '\0';
      return;
    }
    local_8 = pcVar1;
    if (((int)uVar2 < 0x30) || (0x39 < (int)uVar2)) break;
    local_18 = uVar2 - 0x30;
    if ('\t' < DAT_100008036) {
      *local_10 = DAT_100008036 / '\n' + '0';
      local_1c = local_1c % '\n';
      local_10 = local_10 + 1;
    }
    *local_10 = local_1c + '0';
    pcVar1 = local_10 + 1;
    if (9 < local_18) {
      local_10[1] = (char)(local_18 / 10) + '0';
      local_18 = local_18 % 10;
      pcVar1 = local_10 + 2;
    }
    local_10 = pcVar1;
    *local_10 = (char)local_18 + '0';
    local_10 = local_10 + 1;
  }
  uVar2 = uVar2 & 0xffffffdf;
  if (((int)uVar2 < 0x41) || (0x5a < (int)uVar2)) goto LAB_100003b44;
  local_1c = (&_encode)[(int)uVar2];
  goto LAB_100003b88;
LAB_100003b44:
  local_1c = DAT_100008037;
  if ((param_3 == 0) || (uVar2 != 0)) {
LAB_100003b88:
    if ('\t' < local_1c) {
      *local_10 = local_1c / '\n' + '0';
      local_1c = local_1c % '\n';
      local_10 = local_10 + 1;
    }
    *local_10 = local_1c + '0';
    local_10 = local_10 + 1;
  }
  goto LAB_1000039c4;
}



void _decipher(char *param_1,char *param_2,int param_3)

{
  char cVar1;
  char *pcVar2;
  int local_18;
  char *local_10;
  char *local_8;
  
  local_10 = param_2;
  local_8 = param_1;
  while( true ) {
    if (*local_8 == 0) break;
    local_18 = *local_8 + -0x30;
    if ((local_18 == _row) || (pcVar2 = local_8 + 1, local_18 == DAT_10000810c)) {
      local_18 = local_18 * 10 + (int)local_8[1] + -0x30;
      pcVar2 = local_8 + 2;
    }
    local_8 = pcVar2;
    cVar1 = (&_decode)[local_18];
    if (cVar1 == '.') {
      cVar1 = *local_8;
      local_8 = local_8 + 1;
    }
    if ((cVar1 == '/') && (param_3 == 0)) {
      cVar1 = ' ';
    }
    *local_10 = cVar1;
    local_10 = local_10 + 1;
  }
  *local_10 = '\0';
  return;
}



undefined8 entry(void)

{
  int iVar1;
  undefined auStack_f0 [100];
  undefined auStack_8c [100];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memset(auStack_8c,0,100);
  _memset(auStack_f0,0,100);
  _read_table(_board);
  _printf("message: %s\n");
  _encipher("In the winter 1965/we were hungry/just barely alive",auStack_8c,0);
  _printf("encoded: %s\n");
  _decipher(auStack_8c,auStack_f0,0);
  _printf("decoded: %s\n");
  _printf("\nNo spaces:\n");
  _encipher("In the winter 1965/we were hungry/just barely alive",auStack_8c);
  _printf("encoded: %s\n");
  _decipher(auStack_8c,auStack_f0,1);
  iVar1 = _printf("decoded: %s\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004018)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004028)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}


`
`#include <locale.h>
#include <stdbool.h>
#include <stdio.h>
#include <time.h>

bool colorful(int n) {
    // A colorful number cannot be greater than 98765432.
    if (n < 0 || n > 98765432)
        return false;
    int digit_count[10] = {};
    int digits[8] = {};
    int num_digits = 0;
    for (int m = n; m > 0; m /= 10) {
        int d = m % 10;
        if (n > 9 && (d == 0 || d == 1))
            return false;
        if (++digit_count[d] > 1)
            return false;
        digits[num_digits++] = d;
    }
    // Maximum number of products is (8 x 9) / 2.
    int products[36] = {};
    for (int i = 0, product_count = 0; i < num_digits; ++i) {
        for (int j = i, p = 1; j < num_digits; ++j) {
            p *= digits[j];
            for (int k = 0; k < product_count; ++k) {
                if (products[k] == p)
                    return false;
            }
            products[product_count++] = p;
        }
    }
    return true;
}

static int count[8];
static bool used[10];
static int largest = 0;

void count_colorful(int taken, int n, int digits) {
    if (taken == 0) {
        for (int d = 0; d < 10; ++d) {
            used[d] = true;
            count_colorful(d < 2 ? 9 : 1, d, 1);
            used[d] = false;
        }
    } else {
        if (colorful(n)) {
            ++count[digits - 1];
            if (n > largest)
                largest = n;
        }
        if (taken < 9) {
            for (int d = 2; d < 10; ++d) {
                if (!used[d]) {
                    used[d] = true;
                    count_colorful(taken + 1, n * 10 + d, digits + 1);
                    used[d] = false;
                }
            }
        }
    }
}

int main() {
    setlocale(LC_ALL, "");

    clock_t start = clock();

    printf("Colorful numbers less than 100:\n");
    for (int n = 0, count = 0; n < 100; ++n) {
        if (colorful(n))
            printf("%2d%c", n, ++count % 10 == 0 ? '\n' : ' ');
    }

    count_colorful(0, 0, 0);
    printf("\n\nLargest colorful number: %'d\n", largest);

    printf("\nCount of colorful numbers by number of digits:\n");
    int total = 0;
    for (int d = 0; d < 8; ++d) {
        printf("%d   %'d\n", d + 1, count[d]);
        total += count[d];
    }
    printf("\nTotal: %'d\n", total);

    clock_t end = clock();
    printf("\nElapsed time: %f seconds\n",
           (end - start + 0.0) / CLOCKS_PER_SEC);
    return 0;
}
`,`#include "colorful-numbers.h"



undefined _colorful(int param_1)

{
  int iVar1;
  int iVar2;
  long lVar3;
  int local_128;
  int local_124;
  int local_120;
  int local_11c;
  int local_118;
  int local_110;
  int local_10c;
  undefined local_101;
  int aiStack_100 [36];
  int local_70 [18];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  if ((param_1 < 0) || (0x5e30a78 < param_1)) {
    local_101 = 0;
  }
  else {
    _memset(local_70 + 8,0,0x28);
    local_70[2] = 0;
    local_70[3] = 0;
    local_70[0] = 0;
    local_70[1] = 0;
    local_70[6] = 0;
    local_70[7] = 0;
    local_70[4] = 0;
    local_70[5] = 0;
    local_10c = 0;
    for (local_110 = param_1; 0 < local_110; local_110 = local_110 / 10) {
      iVar2 = local_110 % 10;
      if ((9 < param_1) && ((iVar2 == 0 || (iVar2 == 1)))) {
        local_101 = 0;
        goto LAB_100003a80;
      }
      iVar1 = local_70[(long)iVar2 + 8] + 1;
      local_70[(long)iVar2 + 8] = iVar1;
      if (1 < iVar1) {
        local_101 = 0;
        goto LAB_100003a80;
      }
      lVar3 = (long)local_10c;
      local_10c = local_10c + 1;
      local_70[lVar3] = iVar2;
    }
    _memset(aiStack_100,0,0x90);
    local_11c = 0;
    for (local_118 = 0; local_118 < local_10c; local_118 = local_118 + 1) {
      local_124 = 1;
      for (local_120 = local_118; local_120 < local_10c; local_120 = local_120 + 1) {
        local_124 = local_124 * local_70[local_120];
        for (local_128 = 0; local_128 < local_11c; local_128 = local_128 + 1) {
          if (aiStack_100[local_128] == local_124) {
            local_101 = 0;
            goto LAB_100003a80;
          }
        }
        lVar3 = (long)local_11c;
        local_11c = local_11c + 1;
        aiStack_100[lVar3] = local_124;
      }
    }
    local_101 = 1;
  }
LAB_100003a80:
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return local_101;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _count_colorful(int param_1,int param_2,int param_3)

{
  int *piVar1;
  ulong uVar2;
  undefined4 uVar3;
  int local_24;
  int local_20;
  
  if (param_1 == 0) {
    for (local_20 = 0; local_20 < 10; local_20 = local_20 + 1) {
      *(undefined *)((long)local_20 + 0x100008000) = 1;
      uVar3 = 9;
      if (1 < local_20) {
        uVar3 = 1;
      }
      _count_colorful(uVar3,local_20,1);
      *(undefined *)((long)local_20 + 0x100008000) = 0;
    }
  }
  else {
    uVar2 = _colorful(param_2);
    if (((uVar2 & 1) != 0) &&
       (piVar1 = (int *)((long)(param_3 + -1) * 4 + 0x10000800c), *piVar1 = *piVar1 + 1,
       _DAT_10000802c < param_2)) {
      _DAT_10000802c = param_2;
    }
    if (param_1 < 9) {
      for (local_24 = 2; local_24 < 10; local_24 = local_24 + 1) {
        if ((*(byte *)((long)local_24 + 0x100008000) & 1) == 0) {
          *(undefined *)((long)local_24 + 0x100008000) = 1;
          _count_colorful(param_1 + 1,param_2 * 10 + local_24,param_3 + 1);
          *(undefined *)((long)local_24 + 0x100008000) = 0;
        }
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(void)

{
  ulong uVar1;
  int local_30;
  int local_24;
  
  _setlocale(0,"");
  _clock();
  _printf("Colorful numbers less than 100:\n");
  for (local_24 = 0; local_24 < 100; local_24 = local_24 + 1) {
    uVar1 = _colorful(local_24);
    if ((uVar1 & 1) != 0) {
      _printf("%2d%c");
    }
  }
  _count_colorful(0,0);
  _printf("\n\nLargest colorful number: %\'d\n");
  _printf("\nCount of colorful numbers by number of digits:\n");
  for (local_30 = 0; local_30 < 8; local_30 = local_30 + 1) {
    _printf("%d   %\'d\n");
  }
  _printf("\nTotal: %\'d\n");
  _clock();
  _printf("\nElapsed time: %f seconds\n");
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

clock_t _clock(void)

{
  clock_t cVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  cVar1 = (*(code *)PTR__clock_100004010)();
  return cVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004018)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004028)();
  return;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

void hue_to_rgb(double hue, double sat, unsigned char *p)
{
	double x;
	int c = 255 * sat;
	hue /= 60;
	x = (1 - fabs(fmod(hue, 2) - 1)) * 255;

	switch((int)hue) {
	case 0:	p[0] = c; p[1] = x; p[2] = 0; return;
	case 1:	p[0] = x; p[1] = c; p[2] = 0; return;
	case 2:	p[0] = 0; p[1] = c; p[2] = x; return;
	case 3:	p[0] = 0; p[1] = x; p[2] = c; return;
	case 4:	p[0] = x; p[1] = 0; p[2] = c; return;
	case 5:	p[0] = c; p[1] = 0; p[2] = x; return;
	}
}

int main(void)
{
	const int size = 512;
	int i, j;
	unsigned char *colors = malloc(size * 3);
	unsigned char *pix = malloc(size * size * 3), *p;
	FILE *fp;

	for (i = 0; i < size; i++)
		hue_to_rgb(i * 240. / size, i * 1. / size, colors + 3 * i);

	for (i = 0, p = pix; i < size; i++)
		for (j = 0; j < size; j++, p += 3)
			memcpy(p, colors + (i ^ j) * 3, 3);

	fp = fopen("xor.ppm", "wb");
	fprintf(fp, "P6\n%d %d\n255\n", size, size);
	fwrite(pix, size * size * 3, 1, fp);
	fclose(fp);

	return 0;
}
`,`#include "munching-squares.h"



void _hue_to_rgb(double param_1,double param_2,undefined *param_3)

{
  undefined uVar1;
  double dVar2;
  
  dVar2 = (double)_fmod(param_1 / 60.0,0x4000000000000000);
  dVar2 = (1.0 - ABS(dVar2 - 1.0)) * 255.0;
  uVar1 = (undefined)(int)(param_2 * 255.0);
  switch((int)(param_1 / 60.0)) {
  case 0:
    *param_3 = uVar1;
    param_3[1] = (char)(int)dVar2;
    param_3[2] = 0;
    break;
  case 1:
    *param_3 = (char)(int)dVar2;
    param_3[1] = uVar1;
    param_3[2] = 0;
    break;
  case 2:
    *param_3 = 0;
    param_3[1] = uVar1;
    param_3[2] = (char)(int)dVar2;
    break;
  case 3:
    *param_3 = 0;
    param_3[1] = (char)(int)dVar2;
    param_3[2] = uVar1;
    break;
  case 4:
    *param_3 = (char)(int)dVar2;
    param_3[1] = 0;
    param_3[2] = uVar1;
    break;
  case 5:
    *param_3 = uVar1;
    param_3[1] = 0;
    param_3[2] = (char)(int)dVar2;
  }
  return;
}



undefined8 entry(void)

{
  void *pvVar1;
  void *pvVar2;
  FILE *pFVar3;
  void *local_38;
  uint local_20;
  uint local_1c;
  
  pvVar1 = _malloc(0x600);
  pvVar2 = _malloc(0xc0000);
  for (local_1c = 0; (int)local_1c < 0x200; local_1c = local_1c + 1) {
    _hue_to_rgb(((double)(long)(int)local_1c * 240.0) / 512.0,
                ((double)(long)(int)local_1c * 1.0) / 512.0,(long)pvVar1 + (long)(int)(local_1c * 3)
               );
  }
  local_38 = pvVar2;
  for (local_1c = 0; (int)local_1c < 0x200; local_1c = local_1c + 1) {
    for (local_20 = 0; (int)local_20 < 0x200; local_20 = local_20 + 1) {
      ___memcpy_chk(local_38,(long)pvVar1 + (long)(int)((local_1c ^ local_20) * 3),3,
                    0xffffffffffffffff);
      local_38 = (void *)((long)local_38 + 3);
    }
  }
  pFVar3 = _fopen("xor.ppm","wb");
  _fprintf(pFVar3,"P6\n%d %d\n255\n");
  _fwrite(pvVar2,0xc0000,1,pFVar3);
  _fclose(pFVar3);
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004008)((int)param_1);
  return iVar1;
}



void _fmod(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__fmod_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004018)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fwrite(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fwrite_100004028)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004030)();
  return pvVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
int main(int argc,char* argv[]){
/* foreach macro viewing an array of int values as a collection of int values */
#define foreach( intpvar , intary ) int* intpvar; for( intpvar=intary; intpvar < (intary+(sizeof(intary)/sizeof(intary[0]))) ; intpvar++)
int a1[]={ 1 , 1 , 2 , 3 , 5 , 8 };
int a2[]={ 3 , 1 , 4 , 1, 5, 9 };
foreach( p1 , a1 ) {
 printf("loop 1 %d\n",*p1);
}
foreach( p2 , a2 ){
 printf("loop 2 %d\n",*p2);
}
exit(0);
return(0);
}
`,`#include "loops-foreach-3.h"



void entry(void)

{
  undefined8 *local_70;
  undefined8 *local_68;
  undefined8 local_50;
  undefined8 uStack_48;
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  undefined8 uStack_28;
  undefined8 local_20;
  undefined8 local_18;
  
  local_18 = *(undefined8 *)PTR____stack_chk_guard_100004000;
  uStack_28 = 0x300000002;
  local_30 = 0x100000001;
  local_20 = 0x800000005;
  uStack_48 = 0x100000004;
  local_50 = 0x100000003;
  local_40 = 0x900000005;
  for (local_68 = &local_30; local_68 < &local_18; local_68 = (undefined8 *)((long)local_68 + 4)) {
    _printf("loop 1 %d\n");
  }
  for (local_70 = &local_50; local_70 < &uStack_38; local_70 = (undefined8 *)((long)local_70 + 4)) {
    _printf("loop 2 %d\n");
  }
                    // WARNING: Subroutine does not return
  _exit(0);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004008)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
  int i;

  for(i=1; i <= 33; i++)
    printf("%6d %6x %6o\n", i, i, i);

  return 0;
}
`,`#include "non-decimal-radices-output.h"



undefined8 entry(void)

{
  int local_18;
  
  for (local_18 = 1; local_18 < 0x22; local_18 = local_18 + 1) {
    _printf("%6d %6x %6o\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int inc(int x) { return (int)&((char *)x)[1]; }
int dec(int x) { return (int)&((char *)x)[-1]; }
int gt(int x, int y)
{
	while (y && x) y = dec(y), x = dec(x);
	return x;
}

int eq(int x, int y)
{
	return !gt(x, y) && !gt(y, x);
}

int add(int x, int y)
{
	while(y) x = inc(x), y = dec(y);
	return x;
}

/* strlen(a) + 1 */
int length(const char *a)
{
	char *x = 0; // assuming (int)(char*)0 == 0
	if (!a) return 0;
	while (*a) a++, x++;
	return (int)x;
}

char *str_cat(char *a, const char *b)
{
	int len = add(1, add(length(a), length(b)));
	if (!(a = realloc(a, len))) abort();
	return strcat(a, b);
}

char *get_line(char *l, FILE *fp)
{
	int c, len = 0;
	char tmp[2] = {0};

	*l = 0;
	while ((c = fgetc(fp)) != EOF) {
		*tmp = c;
		len = inc(len);

		l = str_cat(l, tmp);
		if (eq(*tmp, '\n')) return l;
	}

	*tmp = '\n';
	return len ? str_cat(l, tmp) : l;
}

int main()
{
	int l1, l2;
	char *line = malloc(1), *buf = malloc(1), *longest = malloc(1);
	while (1) {
		line = get_line(line, stdin);

		if (!(l1 = length(line))) break;
		l2 = length(longest);

		if (gt(l1, l2)) {
			*buf = *longest = 0;
			longest = str_cat(longest, line);
		} else if (gt(l2, l1)) continue;

		buf = str_cat(buf, line);
	}
	printf("%s", buf);

	free(buf);
	free(longest);
	free(line);

	return 0;
}
`,`#include "longest-string-challenge-3.h"



long _inc(int param_1)

{
  return (long)param_1 + 1;
}



long _dec(int param_1)

{
  return (long)param_1 + -1;
}



int _gt(int param_1,int param_2)

{
  int local_18;
  int local_14;
  
  local_18 = param_2;
  for (local_14 = param_1; local_18 != 0 && local_14 != 0; local_14 = _dec(local_14)) {
    local_18 = _dec(local_18);
  }
  return local_14;
}



bool _eq(undefined4 param_1,undefined4 param_2)

{
  bool bVar1;
  int iVar2;
  
  iVar2 = _gt(param_1,param_2);
  bVar1 = false;
  if (iVar2 == 0) {
    iVar2 = _gt(param_2,param_1);
    bVar1 = iVar2 == 0;
  }
  return bVar1;
}



undefined4 _add(undefined4 param_1,int param_2)

{
  undefined4 local_18;
  undefined4 local_14;
  
  local_14 = param_1;
  for (local_18 = param_2; local_18 != 0; local_18 = _dec(local_18)) {
    local_14 = _inc(local_14);
  }
  return local_14;
}



int _length(char *param_1)

{
  char *local_10;
  int local_4;
  
  local_4 = 0;
  local_10 = param_1;
  if (param_1 == (char *)0x0) {
    local_4 = 0;
  }
  else {
    for (; *local_10 != '\0'; local_10 = local_10 + 1) {
      local_4 = local_4 + 1;
    }
  }
  return local_4;
}



void _str_cat(void *param_1,undefined8 param_2)

{
  undefined4 uVar1;
  int iVar2;
  undefined8 uVar3;
  void *pvVar4;
  
  uVar1 = _length(param_1);
  uVar3 = _length(param_2);
  uVar3 = _add(uVar1,uVar3);
  iVar2 = _add(1,uVar3);
  pvVar4 = _realloc(param_1,(long)iVar2);
  if (pvVar4 == (void *)0x0) {
                    // WARNING: Subroutine does not return
    _abort();
  }
  ___strcat_chk(pvVar4,param_2,0xffffffffffffffff);
  return;
}



undefined * _get_line(undefined *param_1,FILE *param_2)

{
  int iVar1;
  undefined *local_48;
  undefined2 local_32;
  int local_30;
  int local_2c;
  FILE *local_28;
  undefined *local_20;
  
  local_30 = 0;
  local_32 = 0;
  *param_1 = 0;
  local_28 = param_2;
  local_20 = param_1;
  do {
    local_2c = _fgetc(local_28);
    if (local_2c == -1) {
      local_32 = CONCAT11(local_32._1_1_,10);
      if (local_30 == 0) {
        local_48 = local_20;
      }
      else {
        local_48 = (undefined *)_str_cat(local_20,&local_32);
      }
      return local_48;
    }
    local_32 = CONCAT11(local_32._1_1_,(char)local_2c);
    local_30 = _inc(local_30);
    local_20 = (undefined *)_str_cat(local_20,&local_32);
    iVar1 = _eq((long)(char)local_32,10);
  } while (iVar1 == 0);
  return local_20;
}



undefined8 entry(void)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  undefined *local_38;
  undefined *local_30;
  void *local_28;
  
  local_28 = _malloc(1);
  local_30 = (undefined *)_malloc(1);
  local_38 = (undefined *)_malloc(1);
LAB_100003e44:
  local_28 = (void *)_get_line(local_28,*(undefined8 *)PTR____stdinp_100004000);
  iVar1 = _length(local_28);
  if (iVar1 == 0) {
    _printf("%s");
    _free(local_30);
    _free(local_38);
    _free(local_28);
    return 0;
  }
  uVar2 = _length(local_38);
  iVar3 = _gt(iVar1,uVar2);
  if (iVar3 == 0) goto LAB_100003ec8;
  *local_38 = 0;
  *local_30 = 0;
  local_38 = (undefined *)_str_cat(local_38,local_28);
  goto LAB_100003eec;
LAB_100003ec8:
  iVar1 = _gt(uVar2,iVar1);
  if (iVar1 == 0) {
LAB_100003eec:
    local_30 = (undefined *)_str_cat(local_30,local_28);
  }
  goto LAB_100003e44;
}



void ___strcat_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcat_chk_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _abort(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__abort_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fgetc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fgetc_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004038)();
  return pvVar1;
}


`
`#include <sys/types.h>
#include <err.h>
#include <errno.h>
#include <fnmatch.h>
#include <fts.h>
#include <string.h>
#include <stdio.h>

/* Compare files by name. */
int
entcmp(const FTSENT **a, const FTSENT **b)
{
	return strcmp((*a)->fts_name, (*b)->fts_name);
}

/*
 * Print all files in the directory tree that match the glob pattern.
 * Example: pmatch("/usr/src", "*.c");
 */
void
pmatch(char *dir, const char *pattern)
{
	FTS *tree;
	FTSENT *f;
	char *argv[] = { dir, NULL };

	/*
	 * FTS_LOGICAL follows symbolic links, including links to other
	 * directories. It detects cycles, so we never have an infinite
	 * loop. FTS_NOSTAT is because we never use f->statp. It uses
	 * our entcmp() to sort files by name.
	 */
	tree = fts_open(argv, FTS_LOGICAL | FTS_NOSTAT, entcmp);
	if (tree == NULL)
		err(1, "fts_open");

	/*
	 * Iterate files in tree. This iteration always skips
	 * "." and ".." because we never use FTS_SEEDOT.
	 */
	while ((f = fts_read(tree))) {
		switch (f->fts_info) {
		case FTS_DNR:	/* Cannot read directory */
		case FTS_ERR:	/* Miscellaneous error */
		case FTS_NS:	/* stat() error */
			/* Show error, then continue to next files. */
			warn("%s", f->fts_path);
			continue;
		case FTS_DP:
			/* Ignore post-order visit to directory. */
			continue;
		}

		/*
		 * Check if name matches pattern. If so, then print
		 * path. This check uses FNM_PERIOD, so "*.c" will not
		 * match ".invisible.c".
		 */
		if (fnmatch(pattern, f->fts_name, FNM_PERIOD) == 0)
			puts(f->fts_path);

		/*
		 * A cycle happens when a symbolic link (or perhaps a
		 * hard link) puts a directory inside itself. Tell user
		 * when this happens.
		 */
		if (f->fts_info == FTS_DC)
			warnx("%s: cycle in directory tree", f->fts_path);
	}

	/* fts_read() sets errno = 0 unless it has error. */
	if (errno != 0)
		err(1, "fts_read");

	if (fts_close(tree) < 0)
		err(1, "fts_close");
}

int
main()
{
	pmatch(".", "*.c");
	return 0;
}
`,`#include "walk-a-directory-recursively-2.h"



int _entcmp(long *param_1,long *param_2)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)(*param_1 + 0x68),(char *)(*param_2 + 0x68));
  return iVar1;
}



void _pmatch(char *param_1,undefined8 param_2)

{
  int iVar1;
  FTS *pFVar2;
  FTSENT *pFVar3;
  int *piVar4;
  char *local_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_20 = 0;
  local_28 = param_1;
  pFVar2 = _fts_open(&local_28,10,(int *)_entcmp);
  if (pFVar2 == (FTS *)0x0) {
    _err(1,"fts_open");
  }
  while (pFVar3 = _fts_read(pFVar2), pFVar3 != (FTSENT *)0x0) {
    switch(pFVar3->fts_info) {
    case 4:
    case 7:
    case 10:
      _warn("%s");
      break;
    default:
      iVar1 = _fnmatch(param_2,pFVar3->fts_name,4);
      if (iVar1 == 0) {
        _puts(pFVar3->fts_path);
      }
      if (pFVar3->fts_info == 2) {
        _warnx("%s: cycle in directory tree");
      }
      break;
    case 6:
    }
  }
  piVar4 = ___error();
  if (*piVar4 != 0) {
    _err(1,"fts_read");
  }
  iVar1 = _fts_close(pFVar2);
  if (iVar1 < 0) {
    _err(1,"fts_close");
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



undefined4 entry(void)

{
  _pmatch(".","*.c");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * ___error(void)

{
  int *piVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  piVar1 = (int *)(*(code *)PTR____error_100004000)();
  return piVar1;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



void _err(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__err_100004018)();
  return;
}



void _fnmatch(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__fnmatch_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fts_close(FTS *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fts_close_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FTS * _fts_open(char **param_1,int param_2,int *param_3)

{
  FTS *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FTS *)(*(code *)PTR__fts_open_100004030)(param_1,param_2);
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FTSENT * _fts_read(FTS *param_1)

{
  FTSENT *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FTSENT *)(*(code *)PTR__fts_read_100004038)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004048)((int)param_1);
  return iVar1;
}



void _warn(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__warn_100004050)();
  return;
}



void _warnx(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__warnx_100004058)();
  return;
}


`
`#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

uint64_t factorial(uint64_t n) {
    uint64_t product = 1;

    if (n < 2) {
        return 1;
    }

    for (; n > 0; n--) {
        uint64_t prev = product;
        product *= n;
        if (product < prev) {
            fprintf(stderr, "Overflowed\n");
            return product;
        }
    }

    return product;
}

// uses wilson's theorem
bool isPrime(uint64_t n) {
    uint64_t large = factorial(n - 1) + 1;
    return (large % n) == 0;
}

int main() {
    uint64_t n;

    // Can check up to 21, more will require a big integer library
    for (n = 2; n < 22; n++) {
        printf("Is %llu prime: %d\n", n, isPrime(n));
    }

    return 0;
}
`,`#include "primality-by-wilsons-theorem.h"



ulong _factorial(ulong param_1)

{
  ulong uVar1;
  ulong local_28;
  ulong local_20;
  ulong local_18;
  
  local_28 = 1;
  local_20 = param_1;
  if (param_1 < 2) {
    local_18 = 1;
  }
  else {
    for (; local_20 != 0; local_20 = local_20 - 1) {
      uVar1 = local_28 * local_20;
      if (uVar1 < local_28) {
        _fprintf(*(FILE **)PTR____stderrp_100004000,"Overflowed\n");
        return uVar1;
      }
      local_28 = uVar1;
    }
    local_18 = local_28;
  }
  return local_18;
}



bool _isPrime(ulong param_1)

{
  ulong uVar1;
  long lVar2;
  
  lVar2 = _factorial(param_1 - 1);
  uVar1 = 0;
  if (param_1 != 0) {
    uVar1 = (lVar2 + 1U) / param_1;
  }
  return lVar2 + 1U == uVar1 * param_1;
}



undefined8 entry(void)

{
  ulong local_20;
  
  for (local_20 = 2; local_20 < 0x16; local_20 = local_20 + 1) {
    _isPrime(local_20);
    _printf("Is %llu prime: %d\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned uint;
typedef struct { uint i, v; } filt_t;

// ludics with at least so many elements and reach at least such value
uint* ludic(uint min_len, uint min_val, uint *len)
{
	uint cap, i, v, active = 1, nf = 0;
	filt_t *f = calloc(cap = 2, sizeof(*f));
	f[1].i = 4;

	for (v = 1; ; ++v) {
		for (i = 1; i < active && --f[i].i; i++);

		if (i < active)
			f[i].i = f[i].v;
		else if (nf == f[i].i)
			f[i].i = f[i].v, ++active;  // enable one more filter
		else {
			if (nf >= cap)
				f = realloc(f, sizeof(*f) * (cap*=2));
			f[nf] = (filt_t){ v + nf, v };
			if (++nf >= min_len && v >= min_val) break;
		}
	}

	// pack the sequence into a uint[]
	// filt_t struct was used earlier for cache locality in loops
	uint *x = (void*) f;
	for (i = 0; i < nf; i++) x[i] = f[i].v;
	x = realloc(x, sizeof(*x) * nf);

	*len = nf;
	return x;
}

int find(uint *a, uint v)
{
	uint i;
	for (i = 0; a[i] <= v; i++)
		if (v == a[i]) return 1;
	return 0;
}

int main(void)
{
	uint len, i, *x = ludic(2005, 1000, &len);

	printf("First 25:");
	for (i = 0; i < 25; i++) printf(" %u", x[i]);
	putchar('\n');

	for (i = 0; x[i] <= 1000; i++);
	printf("Ludics below 1000: %u\n", i);

	printf("Ludic 2000 to 2005:");
	for (i = 2000; i <= 2005; i++) printf(" %u", x[i - 1]);
	putchar('\n');

	printf("Triples below 250:");
	for (i = 0; x[i] + 6 <= 250; i++)
		if (find(x, x[i] + 2) && find(x, x[i] + 6))
			printf(" (%u %u %u)", x[i], x[i] + 2, x[i] + 6);

	putchar('\n');

	free(x);
	return 0;
}
`,`#include "ludic-numbers.h"



void * _ludic(uint param_1,uint param_2,uint *param_3)

{
  int *piVar1;
  int iVar2;
  bool bVar3;
  void *pvVar4;
  void *local_40;
  uint local_34;
  uint local_30;
  uint local_2c;
  uint local_28;
  uint local_24;
  
  local_30 = 1;
  local_34 = 0;
  local_24 = 2;
  local_40 = _calloc(2,8);
  *(undefined4 *)((long)local_40 + 8) = 4;
  local_2c = 1;
  do {
    local_28 = 1;
    while( true ) {
      bVar3 = false;
      if (local_28 < local_30) {
        piVar1 = (int *)((long)local_40 + (ulong)local_28 * 8);
        iVar2 = *piVar1 + -1;
        *piVar1 = iVar2;
        bVar3 = iVar2 != 0;
      }
      if (!bVar3) break;
      local_28 = local_28 + 1;
    }
    if (local_28 < local_30) {
      *(undefined4 *)((long)local_40 + (ulong)local_28 * 8) =
           *(undefined4 *)((long)local_40 + (ulong)local_28 * 8 + 4);
    }
    else if (local_34 == *(uint *)((long)local_40 + (ulong)local_28 * 8)) {
      *(undefined4 *)((long)local_40 + (ulong)local_28 * 8) =
           *(undefined4 *)((long)local_40 + (ulong)local_28 * 8 + 4);
      local_30 = local_30 + 1;
    }
    else {
      if (local_24 <= local_34) {
        local_24 = local_24 << 1;
        local_40 = _realloc(local_40,(ulong)local_24 * 8);
      }
      *(ulong *)((long)local_40 + (ulong)local_34 * 8) = CONCAT44(local_2c,local_2c + local_34);
      local_34 = local_34 + 1;
      if ((param_1 <= local_34) && (param_2 <= local_2c)) {
        for (local_28 = 0; local_28 < local_34; local_28 = local_28 + 1) {
          *(undefined4 *)((long)local_40 + (ulong)local_28 * 4) =
               *(undefined4 *)((long)local_40 + (ulong)local_28 * 8 + 4);
        }
        pvVar4 = _realloc(local_40,(ulong)local_34 * 4);
        *param_3 = local_34;
        return pvVar4;
      }
    }
    local_2c = local_2c + 1;
  } while( true );
}



undefined4 _find(long param_1,uint param_2)

{
  uint local_18;
  
  local_18 = 0;
  while( true ) {
    if (param_2 < *(uint *)(param_1 + (ulong)local_18 * 4)) {
      return 0;
    }
    if (param_2 == *(uint *)(param_1 + (ulong)local_18 * 4)) break;
    local_18 = local_18 + 1;
  }
  return 1;
}



undefined8 entry(void)

{
  int iVar1;
  void *pvVar2;
  uint local_1c;
  undefined auStack_18 [4];
  undefined4 local_14;
  
  local_14 = 0;
  pvVar2 = (void *)_ludic(0x7d5,1000,auStack_18);
  _printf("First 25:");
  for (local_1c = 0; local_1c < 0x19; local_1c = local_1c + 1) {
    _printf(" %u");
  }
  _putchar(10);
  local_1c = 0;
  while (*(uint *)((long)pvVar2 + (ulong)local_1c * 4) < 0x3e9) {
    local_1c = local_1c + 1;
  }
  _printf("Ludics below 1000: %u\n");
  _printf("Ludic 2000 to 2005:");
  for (local_1c = 2000; local_1c < 0x7d6; local_1c = local_1c + 1) {
    _printf(" %u");
  }
  _putchar(10);
  _printf("Triples below 250:");
  local_1c = 0;
  while (*(int *)((long)pvVar2 + (ulong)local_1c * 4) + 6U < 0xfb) {
    iVar1 = _find(pvVar2,*(int *)((long)pvVar2 + (ulong)local_1c * 4) + 2);
    if ((iVar1 != 0) &&
       (iVar1 = _find(pvVar2,*(int *)((long)pvVar2 + (ulong)local_1c * 4) + 6), iVar1 != 0)) {
      _printf(" (%u %u %u)");
    }
    local_1c = local_1c + 1;
  }
  _putchar(10);
  _free(pvVar2);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004020)();
  return pvVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BYTES 256

struct huffcode {
  int nbits;
  int code;
};
typedef struct huffcode huffcode_t;

struct huffheap {
  int *h;
  int n, s, cs;
  long *f;
};
typedef struct huffheap heap_t;

/* heap handling funcs */
static heap_t *_heap_create(int s, long *f)
{
  heap_t *h;
  h = malloc(sizeof(heap_t));
  h->h = malloc(sizeof(int)*s);
  h->s = h->cs = s;
  h->n = 0;
  h->f = f;
  return h;
}

static void _heap_destroy(heap_t *heap)
{
  free(heap->h);
  free(heap);
}

#define swap_(I,J) do { int t_; t_ = a[(I)];	\
      a[(I)] = a[(J)]; a[(J)] = t_; } while(0)
static void _heap_sort(heap_t *heap)
{
  int i=1, j=2; /* gnome sort */
  int *a = heap->h;

  while(i < heap->n) { /* smaller values are kept at the end */
    if ( heap->f[a[i-1]] >= heap->f[a[i]] ) {
      i = j; j++;
    } else {
      swap_(i-1, i);
      i--;
      i = (i==0) ? j++ : i;
    }
  }
}
#undef swap_

static void _heap_add(heap_t *heap, int c)
{
  if ( (heap->n + 1) > heap->s ) {
    heap->h = realloc(heap->h, heap->s + heap->cs);
    heap->s += heap->cs;
  }
  heap->h[heap->n] = c;
  heap->n++;
  _heap_sort(heap);
}

static int _heap_remove(heap_t *heap)
{
  if ( heap->n > 0 ) {
    heap->n--;
    return heap->h[heap->n];
  }
  return -1;
}

/* huffmann code generator */
huffcode_t **create_huffman_codes(long *freqs)
{
  huffcode_t **codes;
  heap_t *heap;
  long efreqs[BYTES*2];
  int preds[BYTES*2];
  int i, extf=BYTES;
  int r1, r2;

  memcpy(efreqs, freqs, sizeof(long)*BYTES);
  memset(&efreqs[BYTES], 0, sizeof(long)*BYTES);

  heap = _heap_create(BYTES*2, efreqs);
  if ( heap == NULL ) return NULL;

  for(i=0; i < BYTES; i++) if ( efreqs[i] > 0 ) _heap_add(heap, i);

  while( heap->n > 1 )
  {
    r1 = _heap_remove(heap);
    r2 = _heap_remove(heap);
    efreqs[extf] = efreqs[r1] + efreqs[r2];
    _heap_add(heap, extf);
    preds[r1] = extf;
    preds[r2] = -extf;
    extf++;
  }
  r1 = _heap_remove(heap);
  preds[r1] = r1;
  _heap_destroy(heap);

  codes = malloc(sizeof(huffcode_t *)*BYTES);

  int bc, bn, ix;
  for(i=0; i < BYTES; i++) {
    bc=0; bn=0;
    if ( efreqs[i] == 0 ) { codes[i] = NULL; continue; }
    ix = i;
    while( abs(preds[ix]) != ix ) {
      bc |= ((preds[ix] >= 0) ? 1 : 0 ) << bn;
      ix = abs(preds[ix]);
      bn++;
    }
    codes[i] = malloc(sizeof(huffcode_t));
    codes[i]->nbits = bn;
    codes[i]->code = bc;
  }
  return codes;
}

void free_huffman_codes(huffcode_t **c)
{
  int i;

  for(i=0; i < BYTES; i++) free(c[i]);
  free(c);
}

#define MAXBITSPERCODE 100

void inttobits(int c, int n, char *s)
{
  s[n] = 0;
  while(n > 0) {
    s[n-1] = (c%2) + '0';
    c >>= 1; n--;
  }
}

const char *test = "this is an example for huffman encoding";

int main()
{
  huffcode_t **r;
  int i;
  char strbit[MAXBITSPERCODE];
  const char *p;
  long freqs[BYTES];

  memset(freqs, 0, sizeof freqs);

  p = test;
  while(*p != '\0') freqs[*p++]++;

  r = create_huffman_codes(freqs);

  for(i=0; i < BYTES; i++) {
    if ( r[i] != NULL ) {
      inttobits(r[i]->code, r[i]->nbits, strbit);
      printf("%c (%d) %s\n", i, r[i]->code, strbit);
    }
  }

  free_huffman_codes(r);

  return 0;
}
`,`#include "huffman-coding-1.h"



void * _create_huffman_codes(void)

{
  int iVar1;
  int iVar2;
  void *pvVar3;
  long lVar4;
  int local_1864;
  uint local_1860;
  uint local_185c;
  int local_1850;
  int local_184c;
  void *local_1830;
  int aiStack_1828 [512];
  long alStack_1028 [256];
  undefined auStack_828 [2048];
  long local_28;
  
  pvVar3 = (void *)(*(code *)PTR____chkstk_darwin_100004000)();
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_1850 = 0x100;
  _memcpy(alStack_1028,pvVar3,0x800);
  _bzero(auStack_828,0x800);
  lVar4 = FUN_100003984(0x200,alStack_1028);
  if (lVar4 == 0) {
    local_1830 = (void *)0x0;
  }
  else {
    for (local_184c = 0; local_184c < 0x100; local_184c = local_184c + 1) {
      if (0 < alStack_1028[local_184c]) {
        FUN_1000039f4(lVar4,local_184c);
      }
    }
    while (1 < *(int *)(lVar4 + 8)) {
      iVar1 = FUN_100003ab4(lVar4);
      iVar2 = FUN_100003ab4(lVar4);
      alStack_1028[local_1850] = alStack_1028[iVar1] + alStack_1028[iVar2];
      FUN_1000039f4(lVar4,local_1850);
      aiStack_1828[iVar1] = local_1850;
      aiStack_1828[iVar2] = -local_1850;
      local_1850 = local_1850 + 1;
    }
    iVar1 = FUN_100003ab4(lVar4);
    aiStack_1828[iVar1] = iVar1;
    FUN_100003b18(lVar4);
    local_1830 = _malloc(0x800);
    for (local_184c = 0; local_184c < 0x100; local_184c = local_184c + 1) {
      local_185c = 0;
      local_1860 = 0;
      if (alStack_1028[local_184c] == 0) {
        *(undefined8 *)((long)local_1830 + (long)local_184c * 8) = 0;
      }
      else {
        local_1864 = local_184c;
        while (iVar1 = _abs(aiStack_1828[local_1864]), iVar1 != local_1864) {
          local_185c = local_185c |
                       (uint)(-1 < aiStack_1828[local_1864]) << (ulong)(local_1860 & 0x1f);
          local_1864 = _abs(aiStack_1828[local_1864]);
          local_1860 = local_1860 + 1;
        }
        pvVar3 = _malloc(8);
        *(void **)((long)local_1830 + (long)local_184c * 8) = pvVar3;
        **(uint **)((long)local_1830 + (long)local_184c * 8) = local_1860;
        *(uint *)(*(long *)((long)local_1830 + (long)local_184c * 8) + 4) = local_185c;
      }
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return local_1830;
}



undefined8 * FUN_100003984(int param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  void *pvVar2;
  
  puVar1 = (undefined8 *)_malloc(0x20);
  pvVar2 = _malloc((long)param_1 * 4);
  *puVar1 = pvVar2;
  *(int *)(puVar1 + 2) = param_1;
  *(int *)((long)puVar1 + 0xc) = param_1;
  *(undefined4 *)(puVar1 + 1) = 0;
  puVar1[3] = param_2;
  return puVar1;
}



void FUN_1000039f4(long *param_1,undefined4 param_2)

{
  void *pvVar1;
  
  if (*(int *)((long)param_1 + 0xc) < *(int *)(param_1 + 1) + 1) {
    pvVar1 = _realloc((void *)*param_1,(long)(*(int *)((long)param_1 + 0xc) + *(int *)(param_1 + 2))
                     );
    *param_1 = (long)pvVar1;
    *(int *)((long)param_1 + 0xc) = *(int *)((long)param_1 + 0xc) + *(int *)(param_1 + 2);
  }
  *(undefined4 *)(*param_1 + (long)*(int *)(param_1 + 1) * 4) = param_2;
  *(int *)(param_1 + 1) = *(int *)(param_1 + 1) + 1;
  FUN_100003db4(param_1);
  return;
}



undefined4 FUN_100003ab4(long *param_1)

{
  undefined4 local_4;
  
  if (*(int *)(param_1 + 1) < 1) {
    local_4 = 0xffffffff;
  }
  else {
    *(int *)(param_1 + 1) = *(int *)(param_1 + 1) + -1;
    local_4 = *(undefined4 *)(*param_1 + (long)*(int *)(param_1 + 1) * 4);
  }
  return local_4;
}



void FUN_100003b18(undefined8 *param_1)

{
  _free((void *)*param_1);
  _free(param_1);
  return;
}



void _free_huffman_codes(void *param_1)

{
  undefined4 local_1c;
  
  for (local_1c = 0; local_1c < 0x100; local_1c = local_1c + 1) {
    _free(*(void **)((long)param_1 + (long)local_1c * 8));
  }
  _free(param_1);
  return;
}



void _inttobits(int param_1,int param_2,long param_3)

{
  undefined4 local_8;
  undefined4 local_4;
  
  *(undefined *)(param_3 + param_2) = 0;
  local_4 = param_1;
  for (local_8 = param_2; 0 < local_8; local_8 = local_8 + -1) {
    *(char *)(param_3 + (local_8 + -1)) = (char)local_4 + (char)(local_4 / 2) * -2 + '0';
    local_4 = local_4 >> 1;
  }
  return;
}



undefined8 entry(void)

{
  long lVar1;
  char *local_8b0;
  int local_8a4;
  long alStack_890 [269];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _bzero(alStack_890,0x800);
  local_8b0 = _test;
  while (*local_8b0 != '\0') {
    alStack_890[*local_8b0] = alStack_890[*local_8b0] + 1;
    local_8b0 = local_8b0 + 1;
  }
  lVar1 = _create_huffman_codes(alStack_890);
  for (local_8a4 = 0; local_8a4 < 0x100; local_8a4 = local_8a4 + 1) {
    if (*(long *)(lVar1 + (long)local_8a4 * 8) != 0) {
      _inttobits(*(undefined4 *)(*(long *)(lVar1 + (long)local_8a4 * 8) + 4),
                 **(undefined4 **)(lVar1 + (long)local_8a4 * 8));
      _printf("%c (%d) %s\n");
    }
  }
  _free_huffman_codes(lVar1);
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void FUN_100003db4(long *param_1)

{
  undefined4 uVar1;
  long lVar2;
  int local_20;
  int local_10;
  int local_c;
  
  local_c = 1;
  local_10 = 2;
  lVar2 = *param_1;
  while (local_c < *(int *)(param_1 + 1)) {
    if (*(long *)(param_1[3] + (long)*(int *)(lVar2 + (long)(local_c + -1) * 4) * 8) <
        *(long *)(param_1[3] + (long)*(int *)(lVar2 + (long)local_c * 4) * 8)) {
      uVar1 = *(undefined4 *)(lVar2 + (long)(local_c + -1) * 4);
      *(undefined4 *)(lVar2 + (long)(local_c + -1) * 4) = *(undefined4 *)(lVar2 + (long)local_c * 4)
      ;
      *(undefined4 *)(lVar2 + (long)local_c * 4) = uVar1;
      local_20 = local_c + -1;
      if (local_20 == 0) {
        local_20 = local_10;
        local_10 = local_10 + 1;
      }
      local_c = local_20;
    }
    else {
      local_c = local_10;
      local_10 = local_10 + 1;
    }
  }
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _abs(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__abs_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _bzero(void *param_1,size_t param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__bzero_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004030)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004048)();
  return pvVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define KeyType const char *
#define ValType int

#define HASH_SIZE 4096

// hash function useful when KeyType is char * (string)
unsigned strhashkey( const char * key, int max)
{
    unsigned h=0;
    unsigned hl, hr;

    while(*key) {
        h += *key;
        hl= 0x5C5 ^ (h&0xfff00000 )>>18;
        hr =(h&0x000fffff );
        h = hl ^ hr ^ *key++;
    }
    return h % max;
}

typedef struct sHme {
    KeyType    key;
    ValType    value;
    struct sHme  *link;
} *MapEntry;

typedef struct he {
    MapEntry  first, last;
} HashElement;

HashElement hash[HASH_SIZE];

typedef void (*KeyCopyF)(KeyType *kdest, KeyType ksrc);
typedef void (*ValCopyF)(ValType *vdest, ValType vsrc);
typedef unsigned (*KeyHashF)( KeyType key, int upperBound );
typedef int (*KeyCmprF)(KeyType key1, KeyType key2);

void HashAddH( KeyType key, ValType value,
        KeyCopyF copyKey, ValCopyF copyVal, KeyHashF hashKey, KeyCmprF keySame )
{
    unsigned hix = (*hashKey)(key, HASH_SIZE);
    MapEntry m_ent;

    for (m_ent= hash[hix].first;
            m_ent && !(*keySame)(m_ent->key,key); m_ent=m_ent->link);
    if (m_ent) {
        (*copyVal)(&m_ent->value, value);
    }
    else {
        MapEntry last;
        MapEntry hme = malloc(sizeof(struct sHme));
        (*copyKey)(&hme->key, key);
        (*copyVal)(&hme->value, value);
        hme->link = NULL;
        last = hash[hix].last;
        if (last) {
//	    printf("Dup. hash key\n");
            last->link = hme;
        }
        else
            hash[hix].first = hme;
        hash[hix].last = hme;
    }
}

int HashGetH(ValType *val, KeyType key, KeyHashF hashKey, KeyCmprF keySame )
{
    unsigned hix = (*hashKey)(key, HASH_SIZE);
    MapEntry m_ent;
    for (m_ent= hash[hix].first;
            m_ent && !(*keySame)(m_ent->key,key); m_ent=m_ent->link);
    if (m_ent) {
        *val = m_ent->value;
    }
    return (m_ent != NULL);
}

void copyStr(const char**dest, const char *src)
{
    *dest = strdup(src);
}
void copyInt( int *dest, int src)
{
    *dest = src;
}
int strCompare( const char *key1, const char *key2)
{
    return strcmp(key1, key2) == 0;
}

void HashAdd( KeyType key, ValType value )
{
    HashAddH( key, value, &copyStr, &copyInt, &strhashkey, &strCompare);
}

int HashGet(ValType *val, KeyType key)
{
    return HashGetH( val, key, &strhashkey, &strCompare);
}

int main()
{
    static const char * keyList[] = {"red","orange","yellow","green", "blue", "violet" };
    static int valuList[] = {1,43,640, 747, 42, 42};
    int ix;

    for (ix=0; ix<6; ix++) {
        HashAdd(keyList[ix], valuList[ix]);
    }
    return 0;
}
`,`#include "hash-from-two-arrays.h"



int _strhashkey(char *param_1,uint param_2)

{
  uint uVar1;
  uint local_10;
  char *local_8;
  
  local_10 = 0;
  for (local_8 = param_1; *local_8 != '\0'; local_8 = local_8 + 1) {
    local_10 = (local_10 + (int)*local_8 & 0xfff00000) >> 0x12 ^ 0x5c5 ^
               local_10 + (int)*local_8 & 0xfffff ^ (int)*local_8;
  }
  uVar1 = 0;
  if (param_2 != 0) {
    uVar1 = local_10 / param_2;
  }
  return local_10 - uVar1 * param_2;
}



void _HashAddH(undefined8 param_1,undefined4 param_2,code *param_3,code *param_4,code *param_5,
              code *param_6)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  void *pvVar4;
  undefined8 *local_50;
  
  uVar2 = (*param_5)(param_1,0x1000);
  local_50 = *(undefined8 **)(&_hash + (ulong)uVar2 * 0x10);
  while( true ) {
    bVar1 = false;
    if (local_50 != (undefined8 *)0x0) {
      iVar3 = (*param_6)(*local_50,param_1);
      bVar1 = iVar3 == 0;
    }
    if (!bVar1) break;
    local_50 = (undefined8 *)local_50[2];
  }
  if (local_50 == (undefined8 *)0x0) {
    pvVar4 = _malloc(0x18);
    (*param_3)(pvVar4,param_1);
    (*param_4)((long)pvVar4 + 8,param_2);
    *(undefined8 *)((long)pvVar4 + 0x10) = 0;
    if (*(long *)(&DAT_100008050 + (ulong)uVar2 * 0x10) == 0) {
      *(void **)(&_hash + (ulong)uVar2 * 0x10) = pvVar4;
    }
    else {
      *(void **)(*(long *)(&DAT_100008050 + (ulong)uVar2 * 0x10) + 0x10) = pvVar4;
    }
    *(void **)(&DAT_100008050 + (ulong)uVar2 * 0x10) = pvVar4;
  }
  else {
    (*param_4)(local_50 + 1,param_2);
  }
  return;
}



bool _HashGetH(undefined4 *param_1,undefined8 param_2,code *param_3,code *param_4)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  undefined8 *local_40;
  
  uVar2 = (*param_3)(param_2,0x1000);
  local_40 = *(undefined8 **)(&_hash + (ulong)uVar2 * 0x10);
  while( true ) {
    bVar1 = false;
    if (local_40 != (undefined8 *)0x0) {
      iVar3 = (*param_4)(*local_40,param_2);
      bVar1 = iVar3 == 0;
    }
    if (!bVar1) break;
    local_40 = (undefined8 *)local_40[2];
  }
  if (local_40 != (undefined8 *)0x0) {
    *param_1 = *(undefined4 *)(local_40 + 1);
  }
  return local_40 != (undefined8 *)0x0;
}



void _copyStr(undefined8 *param_1,char *param_2)

{
  char *pcVar1;
  
  pcVar1 = _strdup(param_2);
  *param_1 = pcVar1;
  return;
}



void _copyInt(undefined4 *param_1,undefined4 param_2)

{
  *param_1 = param_2;
  return;
}



bool _strCompare(char *param_1,char *param_2)

{
  int iVar1;
  
  iVar1 = _strcmp(param_1,param_2);
  return iVar1 == 0;
}



void _HashAdd(undefined8 param_1,undefined4 param_2)

{
  _HashAddH(param_1,param_2,_copyStr,_copyInt,_strhashkey,_strCompare);
  return;
}



void _HashGet(undefined8 param_1,undefined8 param_2)

{
  _HashGetH(param_1,param_2,_strhashkey,_strCompare);
  return;
}



undefined8 entry(void)

{
  int local_18;
  
  for (local_18 = 0; local_18 < 6; local_18 = local_18 + 1) {
    _HashAdd((&PTR_s_red_100008000)[local_18],*(undefined4 *)(&DAT_100008030 + (long)local_18 * 4));
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strdup(char *param_1)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strdup_100004010)();
  return pcVar1;
}


`
`#include <math.h>
#include <stdio.h>

int p(int l, int n) {
    int test = 0;
    double logv = log(2.0) / log(10.0);
    int factor = 1;
    int loop = l;
    while (loop > 10) {
        factor *= 10;
        loop /= 10;
    }
    while (n > 0) {
        int val;

        test++;
        val = (int)(factor * pow(10.0, fmod(test * logv, 1)));
        if (val == l) {
            n--;
        }
    }
    return test;
}

void runTest(int l, int n) {
    printf("p(%d, %d) = %d\n", l, n, p(l, n));
}

int main() {
    runTest(12, 1);
    runTest(12, 2);
    runTest(123, 45);
    runTest(123, 12345);
    runTest(123, 678910);

    return 0;
}
`,`#include "first-power-of-2-that-has-leading-decimal-digits-of-12.h"



int _p(int param_1,int param_2)

{
  double dVar1;
  double dVar2;
  undefined8 uVar3;
  double dVar4;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_1c;
  undefined4 local_18;
  
  local_1c = 0;
  dVar1 = (double)_log(0x4000000000000000);
  dVar2 = (double)_log(0x4024000000000000);
  local_2c = 1;
  for (local_30 = param_1; local_18 = param_2, 10 < local_30; local_30 = local_30 / 10) {
    local_2c = local_2c * 10;
  }
  while (0 < local_18) {
    local_1c = local_1c + 1;
    uVar3 = _fmod((double)(long)local_1c * (dVar1 / dVar2),0x3ff0000000000000);
    dVar4 = (double)_pow(0x4024000000000000,uVar3);
    if ((int)((double)(long)local_2c * dVar4) == param_1) {
      local_18 = local_18 + -1;
    }
  }
  return local_1c;
}



int _runTest(undefined4 param_1,undefined4 param_2)

{
  int iVar1;
  
  _p(param_1,param_2);
  iVar1 = _printf("p(%d, %d) = %d\n");
  return iVar1;
}



undefined4 entry(void)

{
  _runTest(0xc,1);
  _runTest(0xc,2);
  _runTest(0x7b,0x2d);
  _runTest(0x7b,0x3039);
  _runTest(0x7b,0xa5bfe);
  return 0;
}



void _fmod(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__fmod_100004000)();
  return;
}



void _log(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__log_100004008)();
  return;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int width = 80, year = 1969;
int cols, lead, gap;

const char *wdays[] = { "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" };
struct months {
	const char *name;
	int days, start_wday, at;
} months[12] = {
	{ "January",	31, 0, 0 },
	{ "February",	28, 0, 0 },
	{ "March",	31, 0, 0 },
	{ "April",	30, 0, 0 },
	{ "May",	31, 0, 0 },
	{ "June",	30, 0, 0 },
	{ "July",	31, 0, 0 },
	{ "August",	31, 0, 0 },
	{ "September",	30, 0, 0 },
	{ "October",	31, 0, 0 },
	{ "November",	30, 0, 0 },
	{ "December",	31, 0, 0 }
};

void space(int n) { while (n-- > 0) putchar(' '); }

void init_months()
{
	int i;

	if ((!(year % 4) && (year % 100)) || !(year % 400))
		months[1].days = 29;

	year--;
	months[0].start_wday
		= (year * 365 + year/4 - year/100 + year/400 + 1) % 7;

	for (i = 1; i < 12; i++)
		months[i].start_wday =
			(months[i-1].start_wday + months[i-1].days) % 7;

	cols = (width + 2) / 22;
	while (12 % cols) cols--;
	gap = cols - 1 ? (width - 20 * cols) / (cols - 1) : 0;
	if (gap > 4) gap = 4;
	lead = (width - (20 + gap) * cols + gap + 1) / 2;
        year++;
}

void print_row(int row)
{
	int c, i, from = row * cols, to = from + cols;
	space(lead);
	for (c = from; c < to; c++) {
		i = strlen(months[c].name);
		space((20 - i)/2);
		printf("%s", months[c].name);
		space(20 - i - (20 - i)/2 + ((c == to - 1) ? 0 : gap));
	}
	putchar('\n');

	space(lead);
	for (c = from; c < to; c++) {
		for (i = 0; i < 7; i++)
			printf("%s%s", wdays[i], i == 6 ? "" : " ");
		if (c < to - 1) space(gap);
		else putchar('\n');
	}

	while (1) {
		for (c = from; c < to; c++)
			if (months[c].at < months[c].days) break;
		if (c == to) break;

		space(lead);
		for (c = from; c < to; c++) {
			for (i = 0; i < months[c].start_wday; i++) space(3);
			while(i++ < 7 && months[c].at < months[c].days) {
				printf("%2d", ++months[c].at);
				if (i < 7 || c < to - 1) putchar(' ');
			}
			while (i++ <= 7 && c < to - 1) space(3);
			if (c < to - 1) space(gap - 1);
			months[c].start_wday = 0;
		}
		putchar('\n');
	}
	putchar('\n');
}

void print_year()
{
	int row;
	char buf[32];
	sprintf(buf, "%d", year);
	space((width - strlen(buf)) / 2);
	printf("%s\n\n", buf);
	for (row = 0; row * cols < 12; row++)
		print_row(row);
}

int main(int c, char **v)
{
	int i, year_set = 0;
	for (i = 1; i < c; i++) {
		if (!strcmp(v[i], "-w")) {
			if (++i == c || (width = atoi(v[i])) < 20)
				goto bail;
		} else if (!year_set) {
			if (!sscanf(v[i], "%d", &year) || year <= 0)
				year = 1969;
			year_set = 1;
		} else
			goto bail;
	}

	init_months();
	print_year();
	return 0;

bail:	fprintf(stderr, "bad args\nUsage: %s year [-w width (>= 20)]\n", v[0]);
	exit(1);
}
`,`#include "calendar-1.h"



ulong _space(ulong param_1)

{
  uint uVar1;
  undefined4 local_14;
  
  local_14 = (int)param_1;
  while (0 < local_14) {
    uVar1 = _putchar(0x20);
    param_1 = (ulong)uVar1;
    local_14 = local_14 + -1;
  }
  return param_1;
}



void _init_months(void)

{
  int iVar1;
  int local_8;
  int local_4;
  
  if (((_year % 4 == 0) && (_year % 100 != 0)) || (_year % 400 == 0)) {
    DAT_100008060 = 0x1d;
  }
  _year = _year + -1;
  DAT_10000804c = (((_year * 0x16d + _year / 4) - _year / 100) + _year / 400 + 1) % 7;
  for (local_4 = 1; local_4 < 0xc; local_4 = local_4 + 1) {
    (&DAT_10000804c)[(long)local_4 * 6] =
         ((&DAT_10000804c)[(long)(local_4 + -1) * 6] + (&DAT_100008048)[(long)(local_4 + -1) * 6]) %
         7;
  }
  _cols = (_width + 2) / 0x16;
  while( true ) {
    iVar1 = 0;
    if (_cols != 0) {
      iVar1 = 0xc / _cols;
    }
    if (iVar1 * _cols == 0xc) break;
    _cols = _cols + -1;
  }
  if (_cols == 1) {
    local_8 = 0;
  }
  else {
    local_8 = 0;
    if (_cols + -1 != 0) {
      local_8 = (_width + _cols * -0x14) / (_cols + -1);
    }
  }
  _gap = local_8;
  if (4 < local_8) {
    _gap = 4;
  }
  _lead = ((_width - (_gap + 0x14) * _cols) + _gap + 1) / 2;
  _year = _year + 1;
  return;
}



int _print_row(int param_1)

{
  bool bVar1;
  int iVar2;
  size_t sVar3;
  int iVar4;
  int local_44;
  int local_1c;
  int local_18;
  
  param_1 = param_1 * _cols;
  iVar2 = param_1 + _cols;
  _space(_lead);
  for (local_18 = param_1; local_18 < iVar2; local_18 = local_18 + 1) {
    sVar3 = _strlen((&_months)[(long)local_18 * 3]);
    iVar4 = (int)sVar3;
    _space((0x14 - iVar4) / 2);
    _printf("%s");
    if (local_18 == iVar2 + -1) {
      local_44 = 0;
    }
    else {
      local_44 = _gap;
    }
    _space(((0x14 - iVar4) - (0x14 - iVar4) / 2) + local_44);
  }
  _putchar(10);
  _space(_lead);
  for (local_18 = param_1; iVar4 = param_1, local_18 < iVar2; local_18 = local_18 + 1) {
    for (local_1c = 0; local_1c < 7; local_1c = local_1c + 1) {
      _printf("%s%s");
    }
    if (local_18 < iVar2 + -1) {
      _space(_gap);
    }
    else {
      _putchar(10);
    }
  }
  while( true ) {
    while ((local_18 = iVar4, local_18 < iVar2 &&
           ((int)(&DAT_100008048)[(long)local_18 * 6] <=
            *(int *)(&DAT_100008050 + (long)local_18 * 0x18)))) {
      iVar4 = local_18 + 1;
    }
    if (local_18 == iVar2) break;
    _space(_lead);
    for (local_18 = param_1; local_18 < iVar2; local_18 = local_18 + 1) {
      for (local_1c = 0; local_1c < (int)(&DAT_10000804c)[(long)local_18 * 6];
          local_1c = local_1c + 1) {
        _space(3);
      }
      while( true ) {
        iVar4 = local_1c + 1;
        bVar1 = false;
        if (local_1c < 7) {
          bVar1 = *(int *)(&DAT_100008050 + (long)local_18 * 0x18) <
                  (int)(&DAT_100008048)[(long)local_18 * 6];
        }
        local_1c = iVar4;
        if (!bVar1) break;
        *(int *)(&DAT_100008050 + (long)local_18 * 0x18) =
             *(int *)(&DAT_100008050 + (long)local_18 * 0x18) + 1;
        _printf("%2d");
        if ((iVar4 < 7) || (local_18 < iVar2 + -1)) {
          _putchar(0x20);
        }
      }
      while( true ) {
        bVar1 = false;
        if (local_1c < 8) {
          bVar1 = local_18 < iVar2 + -1;
        }
        if (!bVar1) break;
        _space(3);
        local_1c = local_1c + 1;
      }
      if (local_18 < iVar2 + -1) {
        _space(_gap + -1);
      }
      (&DAT_10000804c)[(long)local_18 * 6] = 0;
    }
    _putchar(10);
    iVar4 = param_1;
  }
  iVar2 = _putchar(10);
  return iVar2;
}



void _print_year(void)

{
  uint uVar1;
  size_t sVar2;
  ulong uVar3;
  long lVar4;
  int local_3c;
  char acStack_38 [32];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  ___sprintf_chk(acStack_38,0,0x20,"%d");
  lVar4 = (long)_width;
  sVar2 = _strlen(acStack_38);
  _space((lVar4 - sVar2) / 2);
  uVar1 = _printf("%s\n\n");
  uVar3 = (ulong)uVar1;
  for (local_3c = 0; local_3c * _cols < 0xc; local_3c = local_3c + 1) {
    uVar3 = _print_row(local_3c);
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(uVar3);
}



undefined8 entry(int param_1,long param_2)

{
  bool bVar1;
  int iVar2;
  int local_24;
  
  bVar1 = false;
  local_24 = 1;
  do {
    if (param_1 <= local_24) {
      _init_months();
      _print_year();
      return 0;
    }
    iVar2 = _strcmp(*(char **)(param_2 + (long)local_24 * 8),"-w");
    if (iVar2 == 0) {
      local_24 = local_24 + 1;
      if ((local_24 == param_1) ||
         (_width = _atoi(*(char **)(param_2 + (long)local_24 * 8)), _width < 0x14))
      goto LAB_100003e44;
    }
    else {
      if (bVar1) {
LAB_100003e44:
        _fprintf(*(FILE **)PTR____stderrp_100004018,"bad args\nUsage: %s year [-w width (>= 20)]\n")
        ;
                    // WARNING: Subroutine does not return
        _exit(1);
      }
      iVar2 = _sscanf(*(char **)(param_2 + (long)local_24 * 8),"%d");
      if ((iVar2 == 0) || (_year < 1)) {
        _year = 0x7b1;
      }
      bVar1 = true;
    }
    local_24 = local_24 + 1;
  } while( true );
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004028)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eac. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004040)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _sscanf(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__sscanf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003edc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee8. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004058)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <locale.h>

bool *primeSieve(int limit) {
    int i, p;
    limit++;
    // True denotes composite, false denotes prime.
    bool *c = calloc(limit, sizeof(bool)); // all false by default
    c[0] = true;
    c[1] = true;
    for (i = 4; i < limit; i += 2) c[i] = true;
    p = 3; // Start from 3.
    while (true) {
        int p2 = p * p;
        if (p2 >= limit) break;
        for (i = p2; i < limit; i += 2 * p) c[i] = true;
        while (true) {
            p += 2;
            if (!c[p]) break;
        }
    }
    return c;
}

int main() {
    const int limit = 1000000;
    int i, j, n, uc = 2, p = 10, m = 63, ul = 151000;
    bool *c = primeSieve(limit);
    n = m * limit + 1;
    int *sumDivs = (int *)calloc(n, sizeof(int));
    for (i = 1; i < n; ++i) {
        for (j = i; j < n; j += i) sumDivs[j] += i;
    }
    bool *s = (bool *)calloc(n, sizeof(bool)); // all false
    for (i = 1; i < n; ++i) {
        int sum = sumDivs[i] - i; // proper divs sum
        if (sum <= n) s[sum] = true;
    }
    free(sumDivs);
    int *untouchable = (int *)malloc(ul * sizeof(int));
    untouchable[0] = 2;
    untouchable[1] = 5;
    for (n = 6; n <= limit; n += 2) {
        if (!s[n] && c[n-1] && c[n-3]) untouchable[uc++] = n;
    }
    setlocale(LC_NUMERIC, "");
    printf("List of untouchable numbers <= 2,000:\n");
    for (i = 0; i < uc; ++i) {
        j = untouchable[i];
        if (j > 2000) break;
        printf("%'6d ", j);
        if (!((i+1) % 10)) printf("\n");
    }
    printf("\n\n%'7d untouchable numbers were found  <=     2,000\n", i);
    for (i = 0; i < uc; ++i) {
        j = untouchable[i];
        if (j > p) {
            printf("%'7d untouchable numbers were found  <= %'9d\n", i, p);
            p *= 10;
            if (p == limit) break;
        }
    }
    printf("%'7d untouchable numbers were found  <= %'d\n", uc, limit);
    free(c);
    free(s);
    free(untouchable);
    return 0;
}
`,`#include "untouchable-numbers.h"



undefined * _primeSieve(int param_1)

{
  undefined *puVar1;
  int local_1c;
  int local_18;
  
  param_1 = param_1 + 1;
  puVar1 = (undefined *)_calloc((long)param_1,1);
  *puVar1 = 1;
  puVar1[1] = 1;
  for (local_18 = 4; local_18 < param_1; local_18 = local_18 + 2) {
    puVar1[local_18] = 1;
  }
  local_1c = 3;
  while (local_18 = local_1c * local_1c, local_18 < param_1) {
    for (; local_18 < param_1; local_18 = local_18 + local_1c * 2) {
      puVar1[local_18] = 1;
    }
    do {
      local_1c = local_1c + 2;
    } while ((puVar1[local_1c] & 1) != 0);
  }
  return puVar1;
}



undefined8 entry(void)

{
  int *piVar1;
  int iVar2;
  void *pvVar3;
  void *pvVar4;
  void *pvVar5;
  undefined4 *puVar6;
  long lVar7;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  
  local_28 = 2;
  local_2c = 10;
  pvVar3 = (void *)_primeSieve();
  pvVar4 = _calloc(0x3c14dc1,4);
  for (local_1c = 1; local_1c < 0x3c14dc1; local_1c = local_1c + 1) {
    for (local_20 = local_1c; local_20 < 0x3c14dc1; local_20 = local_20 + local_1c) {
      piVar1 = (int *)((long)pvVar4 + (long)local_20 * 4);
      *piVar1 = *piVar1 + local_1c;
    }
  }
  pvVar5 = _calloc(0x3c14dc1,1);
  for (local_1c = 1; local_1c < 0x3c14dc1; local_1c = local_1c + 1) {
    iVar2 = *(int *)((long)pvVar4 + (long)local_1c * 4) - local_1c;
    if (iVar2 < 0x3c14dc2) {
      *(undefined *)((long)pvVar5 + (long)iVar2) = 1;
    }
  }
  _free(pvVar4);
  puVar6 = (undefined4 *)_malloc(0x93760);
  *puVar6 = 2;
  puVar6[1] = 5;
  for (local_24 = 6; local_24 < 0xf4241; local_24 = local_24 + 2) {
    if ((((*(byte *)((long)pvVar5 + (long)local_24) & 1) == 0) &&
        ((*(byte *)((long)pvVar3 + (long)(local_24 + -1)) & 1) != 0)) &&
       ((*(byte *)((long)pvVar3 + (long)(local_24 + -3)) & 1) != 0)) {
      lVar7 = (long)local_28;
      local_28 = local_28 + 1;
      puVar6[lVar7] = local_24;
    }
  }
  _setlocale(4,"");
  _printf("List of untouchable numbers <= 2,000:\n");
  for (local_1c = 0; (local_1c < local_28 && ((int)puVar6[local_1c] < 0x7d1));
      local_1c = local_1c + 1) {
    _printf("%\'6d ");
    if ((local_1c + 1) % 10 == 0) {
      _printf("\n");
    }
  }
  _printf("\n\n%\'7d untouchable numbers were found  <=     2,000\n");
  for (local_1c = 0; local_1c < local_28; local_1c = local_1c + 1) {
    if (local_2c < (int)puVar6[local_1c]) {
      _printf("%\'7d untouchable numbers were found  <= %\'9d\n");
      local_2c = local_2c * 10;
      if (local_2c == 1000000) break;
    }
  }
  _printf("%\'7d untouchable numbers were found  <= %\'d\n");
  _free(pvVar3);
  _free(pvVar5);
  _free(puVar6);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ec0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004020)();
  return;
}


`
`/*
 * Write Entire File -- RossetaCode -- dirty hackish solution
 */
#define _CRT_SECURE_NO_WARNINGS  // turn off MS Visual Studio restrictions
#include <stdio.h>

int main(void)
{
    return 0 >= fputs("ANY STRING TO WRITE TO A FILE AT ONCE.",
        freopen("sample.txt","wb",stdout));
}
`,`#include "write-entire-file-1.h"



bool entry(void)

{
  int iVar1;
  FILE *pFVar2;
  
  pFVar2 = _freopen("sample.txt","wb",*(FILE **)PTR____stdoutp_100004000);
  iVar1 = _fputs("ANY STRING TO WRITE TO A FILE AT ONCE.",pFVar2);
  return iVar1 < 1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fputs(char *param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fputs_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _freopen(char *param_1,char *param_2,FILE *param_3)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__freopen_100004010)();
  return pFVar1;
}


`
`// http://stackoverflow.com/questions/3385515/static-assert-in-c
#define STATIC_ASSERT(COND,MSG) typedef char static_assertion_##MSG[(!!(COND))*2-1]
// token pasting madness:
#define COMPILE_TIME_ASSERT3(X,L) STATIC_ASSERT(X,static_assertion_at_line_##L)
#define COMPILE_TIME_ASSERT2(X,L) COMPILE_TIME_ASSERT3(X,L)
#define COMPILE_TIME_ASSERT(X)    COMPILE_TIME_ASSERT2(X,__LINE__)

COMPILE_TIME_ASSERT(sizeof(long)==8);
int main()
{
    COMPILE_TIME_ASSERT(sizeof(int)==4);
}
`,`#include "metaprogramming-1.h"



undefined8 entry(void)

{
  return 0;
}


`
`#include <stdio.h>
#include <stdint.h>

typedef uint64_t u64;

void primeFactors(u64 n, u64 *factors, int *length) {
    if (n < 2) return;
    int count = 0;
    int inc[8] = {4, 2, 4, 2, 4, 6, 2, 6};
    while (!(n%2)) {
        factors[count++] = 2;
        n /= 2;
    }
    while (!(n%3)) {
        factors[count++] = 3;
        n /= 3;
    }
    while (!(n%5)) {
        factors[count++] = 5;
        n /= 5;
    }
    for (u64 k = 7, i = 0; k*k <= n; ) {
        if (!(n%k)) {
            factors[count++] = k;
            n /= k;
        } else {
            k += inc[i];
            i = (i + 1) % 8;
        }
    }
    if (n > 1) {
        factors[count++] = n;
    }
    *length = count;
}

double D(double n) {
    if (n < 0) return -D(-n);
    if (n < 2) return 0;
    int i, length;
    double d;
    u64 f[80], g;
    if (n < 1e19) {
        primeFactors((u64)n, f, &length);
    } else {
        g = (u64)(n / 100);
        primeFactors(g, f, &length);
        f[length+1] = f[length] = 2;
        f[length+3] = f[length+2] = 5;
        length += 4;
    }
    if (length == 1) return 1;
    if (length == 2) return (double)(f[0] + f[1]);
    d = n / (double)f[0];
    return D(d) * (double)f[0] + d;
}

int main() {
    u64 ad[200];
    int n, m;
    double pow;
    for (n = -99; n < 101; ++n) {
        ad[n+99] = (int)D((double)n);
    }
    for (n = 0; n < 200; ++n) {
        printf("%4ld ", ad[n]);
        if (!((n+1)%10)) printf("\n");
    }
    printf("\n");
    pow = 1;
    for (m = 1; m < 21; ++m) {
        pow *= 10;
        printf("D(10^%-2d) / 7 = %.0f\n", m, D(pow)/7);
    }
    return 0;
}
`,`#include "arithmetic-derivative.h"



void _primeFactors(ulong param_1,long param_2,int *param_3)

{
  ulong uVar1;
  long lVar2;
  ulong local_70;
  ulong local_68;
  int local_5c;
  ulong local_48;
  int local_40 [10];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  if (1 < param_1) {
    local_5c = 0;
    local_40[2] = 4;
    local_40[3] = 2;
    local_40[0] = 4;
    local_40[1] = 2;
    local_40[6] = 2;
    local_40[7] = 6;
    local_40[4] = 4;
    local_40[5] = 6;
    for (local_48 = param_1; local_48 % 2 == 0; local_48 = local_48 / 2) {
      lVar2 = (long)local_5c;
      local_5c = local_5c + 1;
      *(undefined8 *)(param_2 + lVar2 * 8) = 2;
    }
    for (; local_48 % 3 == 0; local_48 = local_48 / 3) {
      lVar2 = (long)local_5c;
      local_5c = local_5c + 1;
      *(undefined8 *)(param_2 + lVar2 * 8) = 3;
    }
    for (; local_48 % 5 == 0; local_48 = local_48 / 5) {
      lVar2 = (long)local_5c;
      local_5c = local_5c + 1;
      *(undefined8 *)(param_2 + lVar2 * 8) = 5;
    }
    local_68 = 7;
    local_70 = 0;
    uVar1 = local_48;
    while (local_48 = uVar1, local_68 * local_68 < local_48 || local_68 * local_68 - local_48 == 0)
    {
      uVar1 = 0;
      if (local_68 != 0) {
        uVar1 = local_48 / local_68;
      }
      if (local_48 == uVar1 * local_68) {
        lVar2 = (long)local_5c;
        local_5c = local_5c + 1;
        *(ulong *)(param_2 + lVar2 * 8) = local_68;
        uVar1 = 0;
        if (local_68 != 0) {
          uVar1 = local_48 / local_68;
        }
      }
      else {
        local_68 = local_68 + (long)local_40[local_70];
        local_70 = (local_70 + 1) % 8;
        uVar1 = local_48;
      }
    }
    if (1 < local_48) {
      lVar2 = (long)local_5c;
      local_5c = local_5c + 1;
      *(ulong *)(param_2 + lVar2 * 8) = local_48;
    }
    *param_3 = local_5c;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



undefined  [16] _D(double param_1)

{
  undefined8 uVar1;
  undefined auVar2 [16];
  double dVar3;
  undefined8 uVar4;
  int local_2c0 [2];
  double local_2b8;
  double local_2b0;
  long local_2a8 [80];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_2b8 = param_1;
  if (0.0 <= param_1) {
    if (2.0 <= param_1) {
      if (1e+19 <= param_1) {
        _primeFactors((long)(param_1 / 100.0),local_2a8,local_2c0);
        local_2a8[local_2c0[0]] = 2;
        local_2a8[local_2c0[0] + 1] = 2;
        local_2a8[local_2c0[0] + 2] = 5;
        local_2a8[local_2c0[0] + 3] = 5;
        local_2c0[0] = local_2c0[0] + 4;
      }
      else {
        _primeFactors((long)param_1,local_2a8,local_2c0);
      }
      if (local_2c0[0] == 1) {
        local_2b0 = 1.0;
      }
      else if (local_2c0[0] == 2) {
        local_2b0 = (double)(ulong)(local_2a8[0] + local_2a8[1]);
      }
      else {
        dVar3 = (double)NEON_ucvtf(local_2a8[0]);
        dVar3 = local_2b8 / dVar3;
        uVar1 = _D(dVar3);
        uVar4 = NEON_ucvtf(local_2a8[0]);
        local_2b0 = (double)NEON_fmadd(uVar1,uVar4,dVar3);
      }
    }
    else {
      local_2b0 = 0.0;
    }
  }
  else {
    local_2b0 = (double)_D(-param_1);
    local_2b0 = -local_2b0;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  auVar2._8_8_ = 0;
  auVar2._0_8_ = local_2b0;
  return auVar2;
}



undefined8 entry(void)

{
  int iVar1;
  double dVar2;
  double local_680;
  int local_674;
  int local_670;
  long local_668 [200];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_670 = -99; local_670 < 0x65; local_670 = local_670 + 1) {
    dVar2 = (double)_D((double)(long)local_670);
    local_668[local_670 + 99] = (long)(int)dVar2;
  }
  for (local_670 = 0; local_670 < 200; local_670 = local_670 + 1) {
    _printf("%4ld ");
    if ((local_670 + 1) % 10 == 0) {
      _printf("\n");
    }
  }
  iVar1 = _printf("\n");
  local_680 = 1.0;
  for (local_674 = 1; local_674 < 0x15; local_674 = local_674 + 1) {
    local_680 = local_680 * 10.0;
    _D(local_680);
    iVar1 = _printf("D(10^%-2d) / 7 = %.0f\n");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar1);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int mul_inv(int a, int b)
{
	int b0 = b, t, q;
	int x0 = 0, x1 = 1;
	if (b == 1) return 1;
	while (a > 1) {
		q = a / b;
		t = b, b = a % b, a = t;
		t = x0, x0 = x1 - q * x0, x1 = t;
	}
	if (x1 < 0) x1 += b0;
	return x1;
}

int main(void) {
	printf("%d\n", mul_inv(42, 2017));
	return 0;
}
`,`#include "modular-inverse-1.h"



int _mul_inv(int param_1,int param_2)

{
  int iVar1;
  int iVar2;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_c;
  undefined4 local_8;
  undefined4 local_4;
  
  local_1c = 0;
  local_20 = 1;
  local_c = param_2;
  local_8 = param_1;
  if (param_2 == 1) {
    local_4 = 1;
  }
  else {
    while (1 < local_8) {
      iVar1 = 0;
      if (local_c != 0) {
        iVar1 = local_8 / local_c;
      }
      iVar2 = 0;
      if (local_c != 0) {
        iVar2 = local_8 / local_c;
      }
      iVar2 = local_8 - iVar2 * local_c;
      iVar1 = local_20 - iVar1 * local_1c;
      local_20 = local_1c;
      local_8 = local_c;
      local_1c = iVar1;
      local_c = iVar2;
    }
    if (local_20 < 0) {
      local_20 = local_20 + param_2;
    }
    local_4 = local_20;
  }
  return local_4;
}



undefined4 entry(void)

{
  _mul_inv(0x2a,0x7e1);
  _printf("%d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef unsigned int uint;
uint count = 0;

#define ulen sizeof(uint) * 8

/* could have defined as int solve(...), but void may have less
   chance to confuse poor optimizer */
void solve(int n)
{
	int cnt = 0;
	const uint full = -(int)(1 << (ulen - n));
	register uint bits, pos, *m, d, e;

	uint b0, b1, l[32], r[32], c[32], mm[33] = {0};
	n -= 3;
	/* require second queen to be left of the first queen, so
	   we ever only test half of the possible solutions. This
	   is why we can't handle n=1 here */
	for (b0 = 1U << (ulen - n - 3); b0; b0 <<= 1) {
		for (b1 = b0 << 2; b1; b1 <<= 1) {
			d = n;
			/* c: columns occupied by previous queens.
			   l: columns attacked by left diagonals
			   r: by right diagnoals */
			c[n] = b0 | b1;
			l[n] = (b0 << 2) | (b1 << 1);
			r[n] = (b0 >> 2) | (b1 >> 1);

			/* availabe columns on current row. m is stack */
			bits = *(m = mm + 1) = full & ~(l[n] | r[n] | c[n]);

			while (bits) {
				/* d: depth, aka row. counting backwards
				   because !d is often faster than d != n */
				while (d) {
					/* pos is right most nonzero bit */
					pos = -(int)bits & bits;

					/* mark bit used. only put current bits
					   on stack if not zero, so backtracking
					   will skip exhausted rows (because reading
					   stack variable is sloooow compared to
					   registers) */
					if ((bits &= ~pos))
						*m++ = bits | d;

					/* faster than l[d+1] = l[d]... */
					e = d--;
					l[d] = (l[e] | pos) << 1;
					r[d] = (r[e] | pos) >> 1;
					c[d] =  c[e] | pos;

					bits = full & ~(l[d] | r[d] | c[d]);

					if (!bits) break;
					if (!d) { cnt++; break; }
				}
				/* Bottom of stack m is a zero'd field acting
				   as sentinel.  When saving to stack, left
				   27 bits are the available columns, while
				   right 5 bits is the depth. Hence solution
				   is limited to size 27 board -- not that it
				   matters in foreseeable future. */
				d = (bits = *--m) & 31U;
				bits &= ~31U;
			}
		}
	}
	count = cnt * 2;
}

int main(int c, char **v)
{
	int nn;
	if (c <= 1 || (nn = atoi(v[1])) <= 0) nn = 8;

	if (nn > 27) {
		fprintf(stderr, "Value too large, abort\n");
		exit(1);
	}

	/* Can't solve size 1 board; might as well skip 2 and 3 */
	if (nn < 4) count = nn == 1;
	else	    solve(nn);

	printf("\nSolutions: %d\n", count);
	return 0;
}
`,`#include "n-queens-problem-4.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _solve(int param_1)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint local_258;
  uint local_254;
  uint local_24c;
  uint *local_248;
  uint local_23c;
  int local_234;
  undefined auStack_22c [4];
  uint local_228 [32];
  uint auStack_1a8 [32];
  uint auStack_128 [32];
  uint auStack_a8 [32];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_234 = 0;
  uVar4 = -(1 << (ulong)(0x20U - param_1 & 0x1f));
  _memset(auStack_22c,0,0x84);
  uVar2 = param_1 - 3;
  local_254 = 1 << (ulong)(0x1d - uVar2 & 0x1f);
  do {
    if (local_254 == 0) {
      __count = local_234 << 1;
      if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
        return;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    for (local_258 = local_254 << 2; local_258 != 0; local_258 = local_258 << 1) {
      auStack_1a8[(int)uVar2] = local_254 | local_258;
      auStack_a8[(int)uVar2] = local_258 << 1 | local_254 << 2;
      auStack_128[(int)uVar2] = local_258 >> 1 | local_254 >> 2;
      local_23c = uVar4 & ((auStack_a8[(int)uVar2] | auStack_128[(int)uVar2] |
                           auStack_1a8[(int)uVar2]) ^ 0xffffffff);
      local_228[0] = local_23c;
      local_24c = uVar2;
      local_248 = local_228;
      while (local_23c != 0) {
        do {
          if (local_24c == 0) goto LAB_100003da0;
          uVar1 = -local_23c & local_23c;
          if ((local_23c & ~uVar1) != 0) {
            *local_248 = local_23c & (uVar1 ^ 0xffffffff) | local_24c;
            local_248 = local_248 + 1;
          }
          uVar3 = local_24c - 1;
          auStack_a8[uVar3] = (auStack_a8[local_24c] | uVar1) << 1;
          auStack_128[uVar3] = (auStack_128[local_24c] | uVar1) >> 1;
          auStack_1a8[uVar3] = auStack_1a8[local_24c] | uVar1;
          local_23c = uVar4 & ((auStack_a8[uVar3] | auStack_128[uVar3] | auStack_1a8[uVar3]) ^
                              0xffffffff);
          if (local_23c == 0) goto LAB_100003da0;
          local_24c = uVar3;
        } while (uVar3 != 0);
        local_234 = local_234 + 1;
LAB_100003da0:
        local_24c = local_248[-1] & 0x1f;
        local_23c = local_248[-1] & 0xffffffe0;
        local_248 = local_248 + -1;
      }
    }
    local_254 = local_254 << 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(int param_1,long param_2)

{
  int local_24;
  
  if ((param_1 < 2) || (local_24 = _atoi(*(char **)(param_2 + 8)), local_24 < 1)) {
    local_24 = 8;
  }
  if (local_24 < 0x1c) {
    if (local_24 < 4) {
      __count = (uint)(local_24 == 1);
    }
    else {
      _solve(local_24);
    }
    _printf("\nSolutions: %d\n");
    return 0;
  }
  _fprintf(*(FILE **)PTR____stderrp_100004010,"Value too large, abort\n");
                    // WARNING: Subroutine does not return
  _exit(1);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004030)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <unistd.h>

int main()
{
	int i;
	printf("\033[?1049h\033[H");
	printf("Alternate screen buffer\n");
	for (i = 5; i; i--) {
		printf("\rgoing back in %d...", i);
		fflush(stdout);
		sleep(1);
	}
	printf("\033[?1049l");

	return 0;
}
`,`#include "terminal-control-preserve-screen.h"



undefined8 entry(void)

{
  int local_18;
  
  _printf("\x1b[?1049h\x1b[H");
  _printf("Alternate screen buffer\n");
  for (local_18 = 5; local_18 != 0; local_18 = local_18 + -1) {
    _printf("\rgoing back in %d...");
    _fflush(*(FILE **)PTR____stdoutp_100004000);
    _sleep(1);
  }
  _printf("\x1b[?1049l");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint _sleep(uint param_1)

{
  uint uVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*(code *)PTR__sleep_100004018)(param_1);
  return uVar1;
}


`
`#include <stdio.h>

#define N 10000000
#define CS N	/* cache size */

typedef unsigned long ulong;
ulong cache[CS] = {0};

ulong hailstone(ulong n)
{
	int x;
	if (n == 1) return 1;
	if (n < CS && cache[n]) return cache[n];

	x = 1 + hailstone((n & 1) ? 3 * n + 1 : n / 2);
	if (n < CS) cache[n] = x;
	return x;
}

int main()
{
	int i, l, max = 0, mi;
	for (i = 1; i < N; i++) {
		if ((l = hailstone(i)) > max) {
			max = l;
			mi = i;
		}
	}
	printf("max below %d: %d, length %d\n", N, mi, max);
	return 0;
}
`,`#include "hailstone-sequence-2.h"



long _hailstone(ulong param_1)

{
  int iVar1;
  ulong local_30;
  long local_18;
  
  if (param_1 == 1) {
    local_18 = 1;
  }
  else if ((param_1 < 10000000) && (*(long *)(&_cache + param_1 * 8) != 0)) {
    local_18 = *(long *)(&_cache + param_1 * 8);
  }
  else {
    if ((param_1 & 1) == 0) {
      local_30 = param_1 / 2;
    }
    else {
      local_30 = param_1 * 3 + 1;
    }
    iVar1 = _hailstone(local_30);
    if (param_1 < 10000000) {
      *(long *)(&_cache + param_1 * 8) = (long)(iVar1 + 1);
    }
    local_18 = (long)(iVar1 + 1);
  }
  return local_18;
}



undefined8 entry(void)

{
  int iVar1;
  int local_20;
  int local_18;
  
  local_20 = 0;
  for (local_18 = 1; local_18 < 10000000; local_18 = local_18 + 1) {
    iVar1 = _hailstone((long)local_18);
    if (local_20 < iVar1) {
      local_20 = iVar1;
    }
  }
  _printf("max below %d: %d, length %d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include<stdlib.h>
#include<stdio.h>
#include<math.h>

typedef struct{
	double x,y;
}point;

double shoelace(char* inputFile){
	int i,numPoints;
	double leftSum = 0,rightSum = 0;
	
	point* pointSet;
	FILE* fp = fopen(inputFile,"r");
	
	fscanf(fp,"%d",&numPoints);
	
	pointSet = (point*)malloc((numPoints + 1)*sizeof(point));
	
	for(i=0;i<numPoints;i++){
		fscanf(fp,"%lf %lf",&pointSet[i].x,&pointSet[i].y);
	}
	
	fclose(fp);
	
	pointSet[numPoints] = pointSet[0];
	
	for(i=0;i<numPoints;i++){
		leftSum += pointSet[i].x*pointSet[i+1].y;
		rightSum += pointSet[i+1].x*pointSet[i].y;
	}
	
	free(pointSet);
	
	return 0.5*fabs(leftSum - rightSum);
}

int main(int argC,char* argV[])
{
	if(argC==1)
		printf("\nUsage : %s <full path of polygon vertices file>",argV[0]);
	
	else
		printf("The polygon area is %lf square units.",shoelace(argV[1]));
	
	return 0;
}
`,`#include "shoelace-formula-for-polygonal-area.h"



undefined  [16] _shoelace(char *param_1)

{
  FILE *pFVar1;
  undefined8 *puVar2;
  undefined8 uVar3;
  undefined auVar4 [16];
  double local_30;
  double local_28;
  int local_20;
  int local_1c;
  
  local_28 = 0.0;
  local_30 = 0.0;
  pFVar1 = _fopen(param_1,"r");
  _fscanf(pFVar1,"%d");
  puVar2 = (undefined8 *)_malloc((long)(local_20 + 1) << 4);
  for (local_1c = 0; local_1c < local_20; local_1c = local_1c + 1) {
    _fscanf(pFVar1,"%lf %lf");
  }
  _fclose(pFVar1);
  uVar3 = *puVar2;
  (puVar2 + (long)local_20 * 2)[1] = puVar2[1];
  puVar2[(long)local_20 * 2] = uVar3;
  for (local_1c = 0; local_1c < local_20; local_1c = local_1c + 1) {
    local_28 = (double)NEON_fmadd(puVar2[(long)local_1c * 2],puVar2[(long)(local_1c + 1) * 2 + 1],
                                  local_28);
    local_30 = (double)NEON_fmadd(puVar2[(long)(local_1c + 1) * 2],puVar2[(long)local_1c * 2 + 1],
                                  local_30);
  }
  _free(puVar2);
  auVar4._0_8_ = ABS(local_28 - local_30) * 0.5;
  auVar4._8_8_ = 0;
  return auVar4;
}



undefined8 entry(int param_1,long param_2)

{
  if (param_1 == 1) {
    _printf("\nUsage : %s <full path of polygon vertices file>");
  }
  else {
    _shoelace(*(undefined8 *)(param_2 + 8));
    _printf("The polygon area is %lf square units.");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004008)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fscanf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fscanf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <wctype.h>
#include <string.h>
#include <locale.h>

typedef struct wstr {
	wchar_t *s;
	int n, alloc;
} wstr;

#define w_del(w) { free(w->s); free(w); }
#define forchars(i, c, w) for(i = 0, c = w->s[0]; i < w->n && c; c = w->s[++i])
wstr *w_new()
{
	wstr *w = malloc(sizeof(wstr));
	w->alloc = 1;
	w->n = 0;
	w->s = malloc(sizeof(wchar_t));
	w->s[0] = 0;
	return w;
}

void w_append(wstr *w, wchar_t c)
{
	int n = w->n + 1;
	if (n >= w->alloc) {
		w->alloc *= 2;
		w->s = realloc(w->s, w->alloc * sizeof(wchar_t));
	}
	w->s[w->n++] = c;
	w->s[w->n] = 0;
}

wstr *w_make(wchar_t *s)
{
	int i, len = wcslen(s);
	wstr *w = w_new();
	for (i = 0; i < len; i++) w_append(w, s[i]);
	return w;
}

typedef void (*wtrans_func)(wstr *, wstr *);
void w_transform(wstr *in, wtrans_func f)
{
	wstr t, *out = w_new();
	f(in, out);
	t = *in; *in = *out; *out = t;
	w_del(out);
}
#define transfunc(x) void w_##x(wstr *in, wstr *out)

transfunc(nocase) {
	int i;
	wchar_t c;
	forchars(i, c, in) w_append(out, towlower(c));
}

transfunc(despace) {
	int i, gotspace = 0;
	wchar_t c;
	forchars(i, c, in) {
		if (!iswspace(c)) {
			if (gotspace && out->n)
				w_append(out, L' ');
			w_append(out, c);
			gotspace = 0;
		} else	gotspace = 1;
	}
}

static const wchar_t *const tbl_accent[] = { /* copied from Raku code */
	L"", L"TH", L"", L"th", L"", L"TH", L"", L"th", L"", L"A",
	L"", L"A", L"", L"A", L"", L"A", L"", L"A", L"", L"A", L"",
	L"a", L"", L"a", L"", L"a", L"", L"a", L"", L"a", L"", L"a",
	L"", L"C", L"", L"c", L"", L"E", L"", L"E", L"", L"E", L"",
	L"E", L"", L"e", L"", L"e", L"", L"e", L"", L"e", L"",
	L"I", L"", L"I", L"", L"I", L"", L"I", L"", L"i", L"",
	L"i", L"", L"i", L"", L"i", L"", L"O", L"", L"O", L"",
	L"O", L"", L"O", L"", L"O", L"", L"O", L"", L"o", L"", L"o",
	L"", L"o", L"", L"o", L"", L"o", L"", L"o", L"", L"N", L"", L"n",
	L"", L"U", L"", L"U", L"", L"U", L"", L"U", L"", L"u", L"", L"u",
	L"", L"u", L"", L"u", L"", L"Y", L"", L"y", L"", L"y" };

static const wchar_t *const tbl_ligature[] = {
	L"", L"AE", L"", L"ae", L"", L"ss",
	L"", L"ffl", L"", L"ffi", L"", L"fi", L"", L"ff", L"", L"fl",
	L"", L"s", L"", L"z", L"", L"st", /* ... come on ... */
};

void w_char_repl(wstr *in, wstr *out, const wchar_t *const *tbl, int len)
{
	int i, j, k;
	wchar_t c;
	forchars(i, c, in) {
		for (j = k = 0; j < len; j += 2) {
			if (c != tbl[j][0]) continue;
			for (k = 0; tbl[j + 1][k]; k++)
				w_append(out, tbl[j + 1][k]);
			break;
		}
		if (!k) w_append(out, c);
	}
}

transfunc(noaccent) {
	w_char_repl(in, out, tbl_accent, sizeof(tbl_accent)/sizeof(wchar_t*));
}

transfunc(noligature) {
	w_char_repl(in, out, tbl_ligature, sizeof(tbl_ligature)/sizeof(wchar_t*));
}

static const wchar_t *const tbl_article[] = {
	L"the", L"a", L"of", L"to", L"is", L"it" };
#define N_ARTICLES sizeof(tbl_article)/sizeof(tbl_article[0])
transfunc(noarticle) {
	int i, j, n;
	wchar_t c, c0 = 0;
	forchars(i, c, in) {
		if (!c0 || (iswalnum(c) && !iswalnum(c0))) { /* word boundary */
			for (j = N_ARTICLES - 1; j >= 0; j--) {
				n = wcslen(tbl_article[j]);
				if (wcsncasecmp(in->s + i, tbl_article[j], n))
					continue;
				if (iswalnum(in->s[i + n])) continue;
				i += n;
				break;
			}
			if (j < 0) w_append(out, c);
		} else
			w_append(out, c);
		c0 = c;
	}
}

enum { wi_space = 0, wi_case, wi_accent, wi_lig, wi_article, wi_numeric };
#define WS_NOSPACE	(1 << wi_space)
#define WS_NOCASE	(1 << wi_case)
#define WS_ACCENT	(1 << wi_accent)
#define WS_LIGATURE	(1 << wi_lig)
#define WS_NOARTICLE	(1 << wi_article)
#define WS_NUMERIC	(1 << wi_numeric)
const wtrans_func trans_funcs[] = {
	w_despace, w_nocase, w_noaccent, w_noligature, w_noarticle, 0
};
const char *const flagnames[] = {
	"collapse spaces",
	"case insensitive",
	"disregard accent",
	"decompose ligatures",
	"discard common words",
	"numeric",
};

typedef struct { wchar_t* s; wstr *w; } kw_t;
int w_numcmp(const void *a, const void *b)
{
	wchar_t *pa = ((const kw_t*)a)->w->s, *pb = ((const kw_t*)b)->w->s;
	int sa, sb, ea, eb;
	while (*pa && *pb) {
		if (iswdigit(*pa) && iswdigit(*pb)) {
			/* skip leading zeros */
			sa = sb = 0;
			while (pa[sa] == L'0') sa++;
			while (pb[sb] == L'0') sb++;
			/* find end of numbers */
			ea = sa; eb = sb;
			while (iswdigit(pa[ea])) ea++;
			while (iswdigit(pb[eb])) eb++;
			if (eb - sb > ea - sa) return -1;
			if (eb - sb < ea - sa) return 1;
			while (sb < eb) {
				if (pa[sa] > pb[sb]) return 1;
				if (pa[sa] < pb[sb]) return -1;
				sa++; sb++;
			}

			pa += ea; pb += eb;
		}
		else if (iswdigit(*pa)) return 1;
		else if (iswdigit(*pb)) return -1;
		else {
			if (*pa > *pb) return 1;
			if (*pa < *pb) return -1;
			pa++; pb++;
		}
	}
	return (!*pa && !*pb) ? 0 : *pa ?  1 : -1;
}

int w_cmp(const void *a, const void *b)
{
	return wcscmp(((const kw_t*)a)->w->s, ((const kw_t*)b)->w->s);
}

void natural_sort(wchar_t **strings, int len, int flags)
{
	int i, j;
	kw_t *kws = malloc(sizeof(kw_t) * len);

	for (i = 0; i < len; i++) {
		kws[i].s = strings[i];
		kws[i].w = w_make(strings[i]);
		for (j = 0; j < wi_numeric; j++)
			if (flags & (1 << j) && trans_funcs[j])
				w_transform(kws[i].w, trans_funcs[j]);
	}

	qsort(kws, len, sizeof(kw_t), (flags & WS_NUMERIC) ? w_numcmp : w_cmp);
	for (i = 0; i < len; i++) {
		w_del(kws[i].w);
		strings[i] = kws[i].s;
	}
	free(kws);
}

const wchar_t *const test[] = {
	L" 0000098 nina", L"100 nio", L"99 Ninja", L"100 NINA",
	L" The work is so dicult to do it took ome 100 aeons.  ",
	L"The work is so difficult it took some 100 aeons.",
	L"  The work is so dicult   it took ome 99 ons.  ",
};
#define N_STRINGS sizeof(test)/sizeof(*test)

void test_sort(int flags)
{
	int i, j;
	const wchar_t *str[N_STRINGS];
	memcpy(str, test, sizeof(test));

	printf("Sort flags: (");
	for (i = 0, j = flags; j; i++, j >>= 1)
		if ((j & 1))
			printf("%s%s", flagnames[i], j > 1 ? ", ":")\n");

	natural_sort((wchar_t **)str, N_STRINGS, flags);

	for (i = 0; i < N_STRINGS; i++)
		printf("%ls\n", str[i]);
	printf("\n");
}

int main()
{
	setlocale(LC_CTYPE, "");

	test_sort(WS_NOSPACE);
	test_sort(WS_NOCASE);
	test_sort(WS_NUMERIC);
	test_sort(WS_NOARTICLE|WS_NOSPACE);
	test_sort(WS_NOCASE|WS_NOSPACE|WS_ACCENT);
	test_sort(WS_LIGATURE|WS_NOCASE|WS_NOSPACE|WS_NUMERIC|WS_ACCENT|WS_NOARTICLE);

	return 0;
}
`,`#include "natural-sorting-1.h"



undefined8 * _w_new(void)

{
  undefined8 *puVar1;
  void *pvVar2;
  
  puVar1 = (undefined8 *)_malloc(0x10);
  *(undefined4 *)((long)puVar1 + 0xc) = 1;
  *(undefined4 *)(puVar1 + 1) = 0;
  pvVar2 = _malloc(4);
  *puVar1 = pvVar2;
  *(undefined4 *)*puVar1 = 0;
  return puVar1;
}



void _w_append(long *param_1,undefined4 param_2)

{
  int iVar1;
  void *pvVar2;
  
  if (*(int *)((long)param_1 + 0xc) <= *(int *)(param_1 + 1) + 1) {
    *(int *)((long)param_1 + 0xc) = *(int *)((long)param_1 + 0xc) << 1;
    pvVar2 = _realloc((void *)*param_1,(long)*(int *)((long)param_1 + 0xc) << 2);
    *param_1 = (long)pvVar2;
  }
  iVar1 = *(int *)(param_1 + 1);
  *(int *)(param_1 + 1) = iVar1 + 1;
  *(undefined4 *)(*param_1 + (long)iVar1 * 4) = param_2;
  *(undefined4 *)(*param_1 + (long)*(int *)(param_1 + 1) * 4) = 0;
  return;
}



undefined8 _w_make(wchar_t *param_1)

{
  size_t sVar1;
  undefined8 uVar2;
  int local_1c;
  
  sVar1 = _wcslen(param_1);
  uVar2 = _w_new();
  for (local_1c = 0; local_1c < (int)sVar1; local_1c = local_1c + 1) {
    _w_append(uVar2,param_1[local_1c]);
  }
  return uVar2;
}



void _w_transform(undefined8 *param_1,code *param_2)

{
  undefined8 *puVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  undefined8 uVar4;
  
  puVar1 = (undefined8 *)_w_new();
  (*param_2)(param_1,puVar1);
  uVar4 = param_1[1];
  uVar2 = *param_1;
  uVar3 = *puVar1;
  param_1[1] = puVar1[1];
  *param_1 = uVar3;
  puVar1[1] = uVar4;
  *puVar1 = uVar2;
  _free((void *)*puVar1);
  _free(puVar1);
  return;
}



void _w_nocase(long *param_1,undefined8 param_2)

{
  wint_t wVar1;
  wint_t local_28;
  int local_24;
  
  local_24 = 0;
  local_28 = *(wint_t *)*param_1;
  while (local_24 < *(int *)(param_1 + 1) && local_28 != 0) {
    wVar1 = _towlower(local_28);
    _w_append(param_2,wVar1);
    local_24 = local_24 + 1;
    local_28 = *(wint_t *)(*param_1 + (long)local_24 * 4);
  }
  return;
}



void _w_despace(long *param_1,long param_2)

{
  bool bVar1;
  int iVar2;
  wint_t local_2c;
  int local_24;
  
  bVar1 = false;
  local_24 = 0;
  local_2c = *(wint_t *)*param_1;
  while (local_24 < *(int *)(param_1 + 1) && local_2c != 0) {
    iVar2 = _iswspace(local_2c);
    if (iVar2 == 0) {
      if ((bVar1) && (*(int *)(param_2 + 8) != 0)) {
        _w_append(param_2,0x20);
      }
      _w_append(param_2,local_2c);
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    local_24 = local_24 + 1;
    local_2c = *(wint_t *)(*param_1 + (long)local_24 * 4);
  }
  return;
}



void _w_char_repl(long *param_1,undefined8 param_2,long param_3,int param_4)

{
  int local_3c;
  int local_38;
  int local_34;
  int local_30;
  
  local_30 = 0;
  local_3c = *(int *)*param_1;
  do {
    if (*(int *)(param_1 + 1) <= local_30 || local_3c == 0) {
      return;
    }
    local_38 = 0;
    local_34 = 0;
    while( true ) {
      if (param_4 <= local_34) goto LAB_100002cdc;
      if (local_3c == **(int **)(param_3 + (long)local_34 * 8)) break;
      local_34 = local_34 + 2;
    }
    local_38 = 0;
    while (*(int *)(*(long *)(param_3 + (long)(local_34 + 1) * 8) + (long)local_38 * 4) != 0) {
      _w_append(param_2,*(undefined4 *)
                         (*(long *)(param_3 + (long)(local_34 + 1) * 8) + (long)local_38 * 4));
      local_38 = local_38 + 1;
    }
LAB_100002cdc:
    if (local_38 == 0) {
      _w_append(param_2,local_3c);
    }
    local_30 = local_30 + 1;
    local_3c = *(int *)(*param_1 + (long)local_30 * 4);
  } while( true );
}



void _w_noaccent(undefined8 param_1,undefined8 param_2)

{
  _w_char_repl(param_1,param_2,&PTR_DAT_100004080,0x76);
  return;
}



void _w_noligature(undefined8 param_1,undefined8 param_2)

{
  _w_char_repl(param_1,param_2,&PTR_DAT_100004430,0x16);
  return;
}



void _w_noarticle(long *param_1,undefined8 param_2)

{
  int iVar1;
  size_t sVar2;
  int iVar3;
  int local_34;
  wint_t local_30;
  int local_28;
  int local_24;
  
  local_34 = 0;
  local_24 = 0;
  local_30 = *(wint_t *)*param_1;
  do {
    if (*(int *)(param_1 + 1) <= local_24 || local_30 == 0) {
      return;
    }
    if ((local_34 == 0) ||
       ((iVar1 = _iswalnum(local_30), iVar1 != 0 && (iVar1 = _iswalnum(local_34), iVar1 == 0)))) {
      for (local_28 = 5; -1 < local_28; local_28 = local_28 + -1) {
        sVar2 = _wcslen((wchar_t *)(&PTR_DAT_1000044e0)[local_28]);
        iVar3 = (int)sVar2;
        iVar1 = _wcsncasecmp((wchar_t *)(*param_1 + (long)local_24 * 4),
                             (wchar_t *)(&PTR_DAT_1000044e0)[local_28],(long)iVar3);
        if ((iVar1 == 0) &&
           (iVar1 = _iswalnum(*(wint_t *)(*param_1 + (long)(local_24 + iVar3) * 4)), iVar1 == 0)) {
          local_24 = local_24 + iVar3;
          break;
        }
      }
      if (local_28 < 0) {
        _w_append(param_2,local_30);
      }
    }
    else {
      _w_append(param_2,local_30);
    }
    local_34 = local_30;
    local_24 = local_24 + 1;
    local_30 = *(wint_t *)(*param_1 + (long)local_24 * 4);
  } while( true );
}



undefined4 _w_numcmp(long param_1,long param_2)

{
  bool bVar1;
  int iVar2;
  undefined4 local_50;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int *local_38;
  int *local_30;
  
  local_30 = (int *)**(undefined8 **)(param_1 + 8);
  local_38 = (int *)**(undefined8 **)(param_2 + 8);
  while( true ) {
    while( true ) {
      bVar1 = false;
      if (*local_30 != 0) {
        bVar1 = *local_38 != 0;
      }
      if (!bVar1) {
        if ((*local_30 == 0) && (*local_38 == 0)) {
          local_50 = 0;
        }
        else {
          local_50 = 0xffffffff;
          if (*local_30 != 0) {
            local_50 = 1;
          }
        }
        return local_50;
      }
      iVar2 = _iswdigit(*local_30);
      if ((iVar2 == 0) || (iVar2 = _iswdigit(*local_38), iVar2 == 0)) break;
      local_40 = 0;
      for (local_3c = 0; local_30[local_3c] == 0x30; local_3c = local_3c + 1) {
      }
      for (; local_38[local_40] == 0x30; local_40 = local_40 + 1) {
      }
      local_44 = local_3c;
      local_48 = local_40;
      while (iVar2 = _iswdigit(local_30[local_44]), iVar2 != 0) {
        local_44 = local_44 + 1;
      }
      while (iVar2 = _iswdigit(local_38[local_48]), iVar2 != 0) {
        local_48 = local_48 + 1;
      }
      if (local_44 - local_3c < local_48 - local_40) {
        return 0xffffffff;
      }
      if (local_48 - local_40 < local_44 - local_3c) {
        return 1;
      }
      for (; local_40 < local_48; local_40 = local_40 + 1) {
        if (local_38[local_40] < local_30[local_3c]) {
          return 1;
        }
        if (local_30[local_3c] < local_38[local_40]) {
          return 0xffffffff;
        }
        local_3c = local_3c + 1;
      }
      local_30 = local_30 + local_44;
      local_38 = local_38 + local_48;
    }
    iVar2 = _iswdigit(*local_30);
    if (iVar2 != 0) {
      return 1;
    }
    iVar2 = _iswdigit(*local_38);
    if (iVar2 != 0) {
      return 0xffffffff;
    }
    if (*local_38 < *local_30) {
      return 1;
    }
    if (*local_30 < *local_38) break;
    local_30 = local_30 + 1;
    local_38 = local_38 + 1;
  }
  return 0xffffffff;
}



int _w_cmp(long param_1,long param_2)

{
  int iVar1;
  
  iVar1 = _wcscmp((wchar_t *)**(undefined8 **)(param_1 + 8),
                  (wchar_t *)**(undefined8 **)(param_2 + 8));
  return iVar1;
}



void _natural_sort(long param_1,int param_2,uint param_3)

{
  code *pcVar1;
  void *pvVar2;
  undefined8 uVar3;
  uint local_28;
  int local_24;
  
  pvVar2 = _malloc((long)param_2 * 0x10);
  for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
    *(undefined8 *)((long)pvVar2 + (long)local_24 * 0x10) =
         *(undefined8 *)(param_1 + (long)local_24 * 8);
    uVar3 = _w_make(*(undefined8 *)(param_1 + (long)local_24 * 8));
    *(undefined8 *)((long)pvVar2 + (long)local_24 * 0x10 + 8) = uVar3;
    for (local_28 = 0; (int)local_28 < 5; local_28 = local_28 + 1) {
      if (((param_3 & 1 << (ulong)(local_28 & 0x1f)) != 0) &&
         ((&_trans_funcs)[(int)local_28] != (undefined *)0x0)) {
        _w_transform(*(undefined8 *)((long)pvVar2 + (long)local_24 * 0x10 + 8),
                     (&_trans_funcs)[(int)local_28]);
      }
    }
  }
  pcVar1 = _w_numcmp;
  if ((param_3 & 0x20) == 0) {
    pcVar1 = _w_cmp;
  }
  _qsort(pvVar2,(long)param_2,0x10,(int *)pcVar1);
  for (local_24 = 0; local_24 < param_2; local_24 = local_24 + 1) {
    _free((void *)**(undefined8 **)((long)pvVar2 + (long)local_24 * 0x10 + 8));
    _free(*(void **)((long)pvVar2 + (long)local_24 * 0x10 + 8));
    *(undefined8 *)(param_1 + (long)local_24 * 8) =
         *(undefined8 *)((long)pvVar2 + (long)local_24 * 0x10);
  }
  _free(pvVar2);
  return;
}



void _test_sort(uint param_1)

{
  int iVar1;
  uint local_5c;
  uint local_58;
  undefined auStack_50 [56];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_50,&_test,0x38);
  _printf("Sort flags: (");
  for (local_5c = param_1; local_5c != 0; local_5c = (int)local_5c >> 1) {
    if ((local_5c & 1) != 0) {
      _printf("%s%s");
    }
  }
  _natural_sort(auStack_50,7,param_1);
  for (local_58 = 0; local_58 < 7; local_58 = local_58 + 1) {
    _printf("%ls\n");
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined4 entry(void)

{
  _setlocale(2,"");
  _test_sort(1);
  _test_sort(2);
  _test_sort(0x20);
  _test_sort(0x11);
  _test_sort(7);
  _test_sort(0x3f);
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x0001000037d8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x0001000037e4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _iswalnum(wint_t _wc)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0001000037f0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__iswalnum_100004018)(_wc);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _iswdigit(wint_t _wc)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x0001000037fc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__iswdigit_100004020)(_wc);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _iswspace(wint_t _wc)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003808. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__iswspace_100004028)(_wc);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003814. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004030)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003820. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004038)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x00010000382c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003838. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004048)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003844. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004050)();
  return pvVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003850. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004058)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

wint_t _towlower(wint_t _wc)

{
  wint_t wVar1;
  
                    // WARNING: Could not recover jumptable at 0x00010000385c. Too many branches
                    // WARNING: Treating indirect jump as call
  wVar1 = (*(code *)PTR__towlower_100004060)(_wc);
  return wVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _wcscmp(wchar_t *param_1,wchar_t *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003868. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__wcscmp_100004068)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _wcslen(wchar_t *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003874. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__wcslen_100004070)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _wcsncasecmp(wchar_t *param_1,wchar_t *param_2,size_t n)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003880. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__wcsncasecmp_100004078)((int)param_1);
  return iVar1;
}


`
`/*
 * Write Entire File -- RossetaCode -- ASCII version with BUFFERED files
 */

#define _CRT_SECURE_NO_WARNINGS

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

/**
 *  Write entire file at once.
 *
 *  @param fileName file name
 *  @param data     buffer with data
 *  @param size     number of bytes to write
 *
 *  @return Number of bytes have been written.
 */
int writeEntireFile(char* fileName, const void* data, size_t size)
{
    size_t numberBytesWritten = 0; // will be updated

    // Notice: assertions can be turned off by #define NDEBUG
    //
    assert( fileName != NULL );
    assert( data != NULL );
    assert( size >  0 );

    // Check for a null pointer or an empty file name.
    //
    // BTW, should we write  if ( ptr != NULL)  or simply  if ( ptr )  ?
    // Both of these forms are correct. At issue is which is more readable.
    //
    if ( fileName != NULL && *fileName != '\0' )
    {
        // Try to open file in BINARY MODE
        //
        FILE* file = fopen(fileName,"wb");

        // There is a possibility to allocate a big buffer to speed up i/o ops:
        //
        // const size_t BIG_BUFFER_SIZE = 0x20000; // 128KiB
        // void* bigBuffer = malloc(BIG_BUFFER_SIZE);
        // if ( bigBuffer != NULL )
        // {
        //     setvbuf(file,bigBuffer,_IOFBF,BIG_BUFFER_SIZE);
        // }
        //
        // Of course, you should release the malloc allocated buffer somewhere.
        // Otherwise, bigBuffer will be released after the end of the program.


        if ( file != NULL )
        {
            // Return value from fwrite( data, 1, size, file ) is the number
            // of bytes written. Return value from fwrite( data, size, 1, file )
            // is the number of blocks (either 0 or 1) written.
            //
            // Notice, that write (see io.h) is less capable than fwrite.
            //

            if ( data != NULL )
            {
                numberBytesWritten = fwrite( data, 1, size, file );
            }
            fclose( file );
        }
    }
    return numberBytesWritten;
}

#define DATA_LENGTH 8192 /* 8KiB */

int main(void)
{
    // Large arrays can exhaust memory on the stack. This is why the static
    // keyword is used.Static variables are allocated outside the stack.
    //
    static char data[DATA_LENGTH];

    // Filling data array with 'A' character.
    // Of course, you can use any other data here.
    //
    int i;
    for ( i = 0; i < DATA_LENGTH; i++ )
    {
        data[i] = 'A';
    }

    // Write entire file at once.
    //
    if ( writeEntireFile("sample.txt", data, DATA_LENGTH ) == DATA_LENGTH )
        return EXIT_SUCCESS;
    else
        return EXIT_FAILURE;
}
`,`#include "write-entire-file-2.h"



size_t _writeEntireFile(char *param_1,void *param_2,size_t param_3)

{
  FILE *pFVar1;
  size_t local_30;
  
  local_30 = 0;
  if (param_1 == (char *)0x0) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("writeEntireFile","write-entire-file-2.c",0x1a,"fileName != NULL");
  }
  if (param_2 != (void *)0x0) {
    if (param_3 != 0) {
      if (((param_1 != (char *)0x0) && (*param_1 != '\0')) &&
         (pFVar1 = _fopen(param_1,"wb"), pFVar1 != (FILE *)0x0)) {
        if (param_2 != (void *)0x0) {
          local_30 = _fwrite(param_2,1,param_3,pFVar1);
        }
        _fclose(pFVar1);
      }
      return local_30;
    }
                    // WARNING: Subroutine does not return
    ___assert_rtn("writeEntireFile","write-entire-file-2.c",0x1c,"size > 0");
  }
                    // WARNING: Subroutine does not return
  ___assert_rtn("writeEntireFile","write-entire-file-2.c",0x1b,"data != NULL");
}



bool entry(void)

{
  int iVar1;
  int local_18;
  
  for (local_18 = 0; local_18 < 0x2000; local_18 = local_18 + 1) {
    *(undefined *)((long)local_18 + 0x100008000) = 0x41;
  }
  iVar1 = _writeEntireFile("sample.txt",0x100008000,0x2000);
  return iVar1 != 0x2000;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004010)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fwrite(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fwrite_100004018)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int icmp(const void *a, const void *b)
{
#define _I(x) *(const int*)x
	return _I(a) < _I(b) ? -1 : _I(a) > _I(b);
#undef _I
}

/* filter items in place and return number of uniques.  if a separate
   list is desired, duplicate it before calling this function */
int uniq(int *a, int len)
{
	int i, j;
	qsort(a, len, sizeof(int), icmp);
	for (i = j = 0; i < len; i++)
		if (a[i] != a[j]) a[++j] = a[i];
	return j + 1;
}

int main()
{
	int x[] = {1, 2, 1, 4, 5, 2, 15, 1, 3, 4};
	int i, len = uniq(x, sizeof(x) / sizeof(x[0]));
	for (i = 0; i < len; i++) printf("%d\n", x[i]);

	return 0;
}
`,`#include "remove-duplicate-elements-3.h"



uint _icmp(int *param_1,int *param_2)

{
  undefined4 local_14;
  
  if (*param_1 < *param_2) {
    local_14 = 0xffffffff;
  }
  else {
    local_14 = (uint)(*param_2 < *param_1);
  }
  return local_14;
}



int _uniq(void *param_1,int param_2)

{
  int local_24;
  int local_20;
  
  _qsort(param_1,(long)param_2,4,(int *)_icmp);
  local_24 = 0;
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    if (*(int *)((long)param_1 + (long)local_20 * 4) != *(int *)((long)param_1 + (long)local_24 * 4)
       ) {
      local_24 = local_24 + 1;
      *(undefined4 *)((long)param_1 + (long)local_24 * 4) =
           *(undefined4 *)((long)param_1 + (long)local_20 * 4);
    }
  }
  return local_24 + 1;
}



undefined8 entry(void)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  int local_48;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_40,&DAT_100003f74,0x28);
  uVar3 = _uniq(auStack_40,10);
  iVar1 = (int)uVar3;
  for (local_48 = 0; local_48 < iVar1; local_48 = local_48 + 1) {
    uVar2 = _printf("%d\n");
    uVar3 = (ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar3);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004020)();
  return;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define MAXBUF 256  /* limit */
#define STR_SZ 100  /* string size */


/* function prototypes */
int ascii (const unsigned char c);

int ascii_ext (const unsigned char c);

unsigned char* strip(unsigned char* str, const size_t n, int ext );


/* check a character
   return 1 for true
          0 for false
*/
int ascii (const unsigned char c)
{
  unsigned char min = 32;   /* <space> */
  unsigned char max = 126;  /* ~ tilde */

  if ( c>=min && c<=max ) return 1;

  return 0;
}


/* check if extended character
   return 1 for true
          0 for false
*/
int ascii_ext (const unsigned char c)
{
  unsigned char min_ext = 128;
  unsigned char max_ext = 255;

  if ( c>=min_ext && c<=max_ext )
       return 1;

  return 0;
}


/* fill buffer with only ASCII valid characters
   then rewrite string from buffer
   limit to n < MAX chars
*/

unsigned char* strip( unsigned char* str, const size_t n, int ext)
{

  unsigned char buffer[MAXBUF] = {'\0'};

  size_t i = 0;  // source index
  size_t j = 0;  // dest   index

  size_t max = (n<MAXBUF)? n : MAXBUF -1;  // limit size

  while (i < max )
    {
      if ( (ext && ascii_ext(str[i]) ) ||  (ascii(str[i]) ) )    // check
	{
	  buffer[j++] = str[i]; // assign
	}
      i++;
    }

  memset(str, '\0', max); // wipe string

  i = 0;               // reset count

  while( i < j)
    {
      str[i] = buffer[i]; // copy back
      i++;
    }

  str[j] = '\0';  // terminate properly

  return str;
}

/* try it out */
int main( int argc, char** argv)
{
  enum {ASCII=0, EXT=1}; /* enumeration makes easier reading */

  unsigned int seed = 134529;  // RNG seed value

  /* variables and storage */
  unsigned char badstring[STR_SZ] = {'\0'};
  unsigned char bs_2[STR_SZ]      = {'\0'};

  unsigned char* goodstring = NULL;
  unsigned char* goodstring_ext = NULL;

  size_t i = 0;

  srand(seed); /* seed RNG */

  fprintf(stdout, "Original:\t" );

  /* generate a random string */
  for (i = 0; i < STR_SZ; i++)
    {
      badstring[i] = (unsigned char) ( rand () & (unsigned char)0xFF );
      fprintf(stdout, "%c", badstring[i] );
    }
  fprintf(stdout, "\n");


   memcpy(bs_2, badstring, STR_SZ * sizeof(unsigned char) ); /* copy string */

   goodstring_ext = strip( badstring, STR_SZ, EXT); /* remove non-extended and non-ascii */

   fprintf(stdout, "\nEXT:\t%s\n" , goodstring_ext );

   goodstring = strip( bs_2, STR_SZ, ASCII); /* remove all non-ascii */

   fprintf(stdout, "\nASCII:\t%s\n" , goodstring );

return 0;
}
`,`#include "strip-control-codes-and-extended-characters-from-a-string-1.h"



undefined4 _ascii(byte param_1)

{
  undefined4 local_4;
  
  if ((param_1 < 0x20) || (0x7e < param_1)) {
    local_4 = 0;
  }
  else {
    local_4 = 1;
  }
  return local_4;
}



bool _ascii_ext(byte param_1)

{
  return 0x7f < param_1;
}



long _strip(long param_1,ulong param_2,int param_3)

{
  int iVar1;
  ulong local_160;
  ulong local_150;
  ulong local_148;
  undefined auStack_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _memset(auStack_128,0,0x100);
  local_148 = 0;
  local_150 = 0;
  local_160 = param_2;
  if (0xff < param_2) {
    local_160 = 0xff;
  }
  for (; local_148 < local_160; local_148 = local_148 + 1) {
    if (((param_3 != 0) && (iVar1 = _ascii_ext(*(undefined *)(param_1 + local_148)), iVar1 != 0)) ||
       (iVar1 = _ascii(*(undefined *)(param_1 + local_148)), iVar1 != 0)) {
      auStack_128[local_150] = *(undefined *)(param_1 + local_148);
      local_150 = local_150 + 1;
    }
  }
  ___memset_chk(param_1,0,local_160,0xffffffffffffffff);
  for (local_148 = 0; local_148 < local_150; local_148 = local_148 + 1) {
    *(undefined *)(param_1 + local_148) = auStack_128[local_148];
  }
  *(undefined *)(param_1 + local_150) = 0;
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return param_1;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  undefined *puVar1;
  int iVar2;
  ulong local_120;
  undefined auStack_f0 [100];
  undefined auStack_8c [100];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  _memset(auStack_8c,0,100);
  _memset(auStack_f0,0,100);
  _srand(0x20d81);
  _fprintf(*(FILE **)PTR____stdoutp_100004018,"Original:\t");
  for (local_120 = 0; puVar1 = PTR____stdoutp_100004018, local_120 < 100; local_120 = local_120 + 1)
  {
    iVar2 = _rand();
    auStack_8c[local_120] = (char)iVar2;
    _fprintf(*(FILE **)PTR____stdoutp_100004018,"%c");
  }
  _fprintf(*(FILE **)PTR____stdoutp_100004018,"\n");
  _memcpy(auStack_f0,auStack_8c,100);
  _strip(auStack_8c,100,1);
  _fprintf(*(FILE **)puVar1,"\nEXT:\t%s\n");
  _strip(auStack_f0,100,0);
  iVar2 = _fprintf(*(FILE **)puVar1,"\nASCII:\t%s\n");
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004030)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004038)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004040)(param_1);
  return;
}


`
`#include <stdint.h>
#include <stdio.h>

int64_t isqrt(int64_t x) {
    int64_t q = 1, r = 0;
    while (q <= x) {
        q <<= 2;
    }
    while (q > 1) {
        int64_t t;
        q >>= 2;
        t = x - r - q;
        r >>= 1;
        if (t >= 0) {
            x = t;
            r += q;
        }
    }
    return r;
}

int main() {
    int64_t p;
    int n;

    printf("Integer square root for numbers 0 to 65:\n");
    for (n = 0; n <= 65; n++) {
        printf("%lld ", isqrt(n));
    }
    printf("\n\n");

    printf("Integer square roots of odd powers of 7 from 1 to 21:\n");
    printf(" n |              7 ^ n | isqrt(7 ^ n)\n");
    p = 7;
    for (n = 1; n <= 21; n += 2, p *= 49) {
        printf("%2d | %18lld | %12lld\n", n, p, isqrt(p));
    }
}
`,`#include "isqrt-integer-square-root-of-x.h"



long _isqrt(long param_1)

{
  long lVar1;
  undefined8 local_18;
  undefined8 local_10;
  undefined8 local_8;
  
  local_18 = 0;
  for (local_10 = 1; local_8 = param_1, (long)local_10 <= param_1; local_10 = local_10 << 2) {
  }
  while (1 < local_10) {
    local_10 = (long)local_10 >> 2;
    lVar1 = (local_8 - local_18) - local_10;
    local_18 = local_18 >> 1;
    if (-1 < lVar1) {
      local_18 = local_18 + local_10;
      local_8 = lVar1;
    }
  }
  return local_18;
}



undefined4 entry(void)

{
  int local_24;
  long local_20;
  
  _printf("Integer square root for numbers 0 to 65:\n");
  for (local_24 = 0; local_24 < 0x42; local_24 = local_24 + 1) {
    _isqrt((long)local_24);
    _printf("%lld ");
  }
  _printf("\n\n");
  _printf("Integer square roots of odd powers of 7 from 1 to 21:\n");
  _printf(" n |              7 ^ n | isqrt(7 ^ n)\n");
  local_20 = 7;
  for (local_24 = 1; local_24 < 0x16; local_24 = local_24 + 2) {
    _isqrt(local_20);
    _printf("%2d | %18lld | %12lld\n");
    local_20 = local_20 * 0x31;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main() {
  int c;
  while ((c = getchar()) != EOF) {
    putchar(c);
  }
  return 0;
}
`,`#include "copy-stdin-to-stdout.h"



undefined8 entry(void)

{
  int iVar1;
  
  while( true ) {
    iVar1 = _getchar();
    if (iVar1 == -1) break;
    _putchar(iVar1);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004000)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
  int a, b;
  scanf("%d %d", &a, &b);

  if (a < b)
    printf("%d is less than %d\n", a, b);

  if (a == b)
    printf("%d is equal to %d\n", a, b);

  if (a > b)
    printf("%d is greater than %d\n", a, b);

  return 0;
}
`,`#include "integer-comparison.h"



undefined8 entry(void)

{
  int local_1c;
  int local_18;
  
  _scanf("%d %d");
  if (local_18 < local_1c) {
    _printf("%d is less than %d\n");
  }
  if (local_18 == local_1c) {
    _printf("%d is equal to %d\n");
  }
  if (local_1c < local_18) {
    _printf("%d is greater than %d\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>

typedef double (*deriv_f)(double, double);
#define FMT " %7.3f"

void ivp_euler(deriv_f f, double y, int step, int end_t)
{
	int t = 0;

	printf(" Step %2d: ", (int)step);
	do {
		if (t % 10 == 0) printf(FMT, y);
		y += step * f(t, y);
	} while ((t += step) <= end_t);
	printf("\n");
}

void analytic()
{
	double t;
	printf("    Time: ");
	for (t = 0; t <= 100; t += 10) printf(" %7g", t);
	printf("\nAnalytic: ");

	for (t = 0; t <= 100; t += 10)
		printf(FMT, 20 + 80 * exp(-0.07 * t));
	printf("\n");
}

double cooling(double t, double temp)
{
	return -0.07 * (temp - 20);
}

int main()
{
	analytic();
	ivp_euler(cooling, 100, 2, 100);
	ivp_euler(cooling, 100, 5, 100);
	ivp_euler(cooling, 100, 10, 100);

	return 0;
}
`,`#include "euler-method-1.h"



int _ivp_euler(undefined8 param_1,code *param_2,int param_3,int param_4)

{
  uint uVar1;
  int iVar2;
  ulong uVar3;
  undefined8 extraout_d0;
  int local_2c;
  undefined8 local_20;
  
  local_2c = 0;
  uVar1 = _printf(" Step %2d: ");
  uVar3 = (ulong)uVar1;
  local_20 = param_1;
  do {
    if (local_2c % 10 == 0) {
      uVar1 = _printf(" %7.3f");
      uVar3 = (ulong)uVar1;
    }
    uVar3 = (*param_2)((double)(long)local_2c,local_20,uVar3);
    local_20 = NEON_fmadd((double)(long)param_3,extraout_d0,local_20);
    local_2c = local_2c + param_3;
  } while (local_2c <= param_4);
  iVar2 = _printf("\n");
  return iVar2;
}



int _analytic(void)

{
  int iVar1;
  undefined8 uVar2;
  double local_18;
  
  _printf("    Time: ");
  local_18 = 0.0;
  while( true ) {
    if (100.0 < local_18) break;
    _printf(" %7g");
    local_18 = local_18 + 10.0;
  }
  iVar1 = _printf("\nAnalytic: ");
  local_18 = 0.0;
  while( true ) {
    if (100.0 < local_18) break;
    uVar2 = _exp(local_18 * -0.07,iVar1);
    NEON_fmadd(0x4054000000000000,uVar2,0x4034000000000000);
    iVar1 = _printf(" %7.3f");
    local_18 = local_18 + 10.0;
  }
  iVar1 = _printf("\n");
  return iVar1;
}



undefined  [16] _cooling(undefined param_1 [16],double param_2)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = (param_2 - 20.0) * -0.07;
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined4 entry(void)

{
  _analytic();
  _ivp_euler(_cooling,2);
  _ivp_euler(0x4059000000000000,_cooling,5,100);
  _ivp_euler(0x4059000000000000,_cooling,10,100);
  return 0;
}



void _exp(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exp_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
int main()
{
    for (int i=0;++i<101;puts(""))
    {
        char f[] = "FizzBuzz%d";
        f[8-i%5&12]=0;
        printf (f+(-i%3&4+f[8]/8), i);
    }
}
`,`#include "fizzbuzz-10.h"



undefined4 entry(ulong param_1)

{
  uint uVar1;
  int local_30;
  char local_28 [16];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_30 = 0;
  while (local_30 = local_30 + 1, local_30 < 0x65) {
    builtin_strncpy(local_28,"FizzBuzz%d",0xb);
    local_28[(int)(8U - local_30 % 5 & 0xc)] = '\0';
    _printf(local_28 + (int)(-local_30 % 3 & (int)local_28[8] / 8 + 4U));
    uVar1 = _puts("");
    param_1 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <math.h>

int main() {
    for (int i = 1; i < 5000; i++) {
        // loop through each digit in i
        // e.g. for 1000 we get 0, 0, 0, 1.
        int sum = 0;
        for (int number = i; number > 0; number /= 10) {
            int digit = number % 10;
            // find the sum of the digits
            // raised to themselves
            sum += pow(digit, digit);
        }
        if (sum == i) {
            // the sum is equal to the number
            // itself; thus it is a
            // munchausen number
            printf("%i\n", i);
        }
    }
    return 0;
}
`,`#include "munchausen-numbers.h"



undefined8 entry(ulong param_1)

{
  uint uVar1;
  double extraout_d0;
  int local_20;
  int local_1c;
  int local_18;
  
  for (local_18 = 1; local_18 < 5000; local_18 = local_18 + 1) {
    local_1c = 0;
    for (local_20 = local_18; 0 < local_20; local_20 = local_20 / 10) {
      param_1 = _pow((double)(long)(local_20 % 10),(double)(long)(local_20 % 10),param_1);
      local_1c = (int)((double)(long)local_1c + extraout_d0);
    }
    if (local_1c == local_18) {
      uVar1 = _printf("%i\n");
      param_1 = (ulong)uVar1;
    }
  }
  return 0;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

typedef unsigned int set_t; /* probably 32 bits; change according to need */

void show_set(set_t x, const char *name)
{
	int i;
	printf("%s is:", name);
	for (i = 0; (1U << i) <= x; i++)
		if (x & (1U << i))
			printf(" %d", i);
	putchar('\n');
}

int main(void)
{
	int i;
	set_t a, b, c;
	
	a = 0; /* empty set */
	for (i = 0; i < 10; i += 3) /* add 0 3 6 9 to set a */
		a |= (1U << i);
	show_set(a, "a");

	for (i = 0; i < 5; i++)
		printf("\t%d%s in set a\n", i, (a & (1U << i)) ? "":" not");

	b = a;
	b |= (1U << 5); b |= (1U << 10); /* b is a plus 5, 10 */
	b &= ~(1U << 0);	/* sans 0 */
	show_set(b, "b");

	show_set(a | b, "union(a, b)");
	show_set(c = a & b, "c = common(a, b)");
	show_set(a & ~b, "a - b"); /* diff, not arithmetic minus */
	show_set(b & ~a, "b - a");
	printf("b is%s a subset of a\n", !(b & ~a) ? "" : " not");
	printf("c is%s a subset of a\n", !(c & ~a) ? "" : " not");

	printf("union(a, b) - common(a, b) %s union(a - b, b - a)\n",
		((a | b) & ~(a & b)) == ((a & ~b) | (b & ~a))
			? "equals" : "does not equal");

	return 0;
}
`,`#include "set.h"



int _show_set(uint param_1)

{
  int iVar1;
  uint local_24;
  
  _printf("%s is:");
  for (local_24 = 0; (uint)(1 << (ulong)(local_24 & 0x1f)) <= param_1; local_24 = local_24 + 1) {
    if ((param_1 & 1 << (ulong)(local_24 & 0x1f)) != 0) {
      _printf(" %d");
    }
  }
  iVar1 = _putchar(10);
  return iVar1;
}



undefined4 entry(void)

{
  uint uVar1;
  uint local_1c;
  uint local_18;
  
  local_1c = 0;
  for (local_18 = 0; (int)local_18 < 10; local_18 = local_18 + 3) {
    local_1c = local_1c | 1 << (ulong)(local_18 & 0x1f);
  }
  _show_set(local_1c,"a");
  for (local_18 = 0; (int)local_18 < 5; local_18 = local_18 + 1) {
    _printf("\t%d%s in set a\n");
  }
  uVar1 = local_1c & 0xfffffffe | 0x420;
  _show_set(uVar1,"b");
  _show_set(local_1c | uVar1,"union(a, b)");
  _show_set(local_1c & uVar1,"c = common(a, b)");
  _show_set(local_1c & (uVar1 ^ 0xffffffff),"a - b");
  _show_set(uVar1 & (local_1c ^ 0xffffffff),"b - a");
  _printf("b is%s a subset of a\n");
  _printf("c is%s a subset of a\n");
  _printf("union(a, b) - common(a, b) %s union(a - b, b - a)\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <setjmp.h>
#include <time.h>

jmp_buf ctx;
const char *msg;

enum { OP_NONE = 0, OP_NUM, OP_ADD, OP_SUB, OP_MUL, OP_DIV };

typedef struct expr_t *expr, expr_t;
struct expr_t {
	int op, val, used;
	expr left, right;
};

#define N_DIGITS 4
expr_t digits[N_DIGITS];

void gen_digits()
{
	int i;
	for (i = 0; i < N_DIGITS; i++)
		digits[i].val = 1 + rand() % 9;
}

#define MAX_INPUT 64
char str[MAX_INPUT];
int pos;

#define POOL_SIZE 8
expr_t pool[POOL_SIZE];
int pool_ptr;

void reset()
{
	int i;
	msg = 0;
	pool_ptr = pos = 0;
	for (i = 0; i < POOL_SIZE; i++) {
		pool[i].op = OP_NONE;
		pool[i].left = pool[i].right = 0;
	}
	for (i = 0; i < N_DIGITS; i++)
		digits[i].used = 0;
}

/* longish jumpish back to input cycle */
void bail(const char *s)
{
	msg = s;
	longjmp(ctx, 1);
}

expr new_expr()
{
	if (pool_ptr < POOL_SIZE)
		return pool + pool_ptr++;
	return 0;
}

/* check next input char */
int next_tok()
{
	while (isspace(str[pos])) pos++;
	return str[pos];
}

/* move input pointer forward */
int take()
{
	if (str[pos] != '\0') return ++pos;
	return 0;
}

/* BNF(ish)
expr = term { ("+")|("-") term }
term = fact { ("*")|("/") expr }
fact =	number
	| '(' expr ')'
*/

expr get_fact();
expr get_term();
expr get_expr();

expr get_expr()
{
	int c;
	expr l, r, ret;
	if (!(ret = get_term())) bail("Expected term");
	while ((c = next_tok()) == '+' || c == '-') {
		if (!take()) bail("Unexpected end of input");
		if (!(r = get_term())) bail("Expected term");

		l = ret;
		ret = new_expr();
		ret->op = (c == '+') ? OP_ADD : OP_SUB;
		ret->left = l;
		ret->right = r;
	}
	return ret;
}

expr get_term()
{
	int c;
	expr l, r, ret;
	ret = get_fact();
	while((c = next_tok()) == '*' || c == '/') {
		if (!take()) bail("Unexpected end of input");

		r = get_fact();
		l = ret;
		ret = new_expr();
		ret->op = (c == '*') ? OP_MUL : OP_DIV;
		ret->left = l;
		ret->right = r;
	}
	return ret;
}

expr get_digit()
{
	int i, c = next_tok();
	expr ret;
	if (c >= '0' && c <= '9') {
		take();
		ret = new_expr();
		ret->op = OP_NUM;
		ret->val = c - '0';
		for (i = 0; i < N_DIGITS; i++)
			if (digits[i].val == ret->val && !digits[i].used) {
				digits[i].used = 1;
				return ret;
			}
		bail("Invalid digit");
	}
	return 0;
}

expr get_fact()
{
	int c;
	expr l = get_digit();
	if (l) return l;
	if ((c = next_tok()) == '(') {
		take();
		l = get_expr();
		if (next_tok() != ')') bail("Unbalanced parens");
		take();
		return l;
	}
	return 0;
}

expr parse()
{
	int i;
	expr ret = get_expr();
	if (next_tok() != '\0')
		bail("Trailing garbage");
	for (i = 0; i < N_DIGITS; i++)
		if (!digits[i].used)
			bail("Not all digits are used");
	return ret;
}

typedef struct frac_t frac_t, *frac;
struct frac_t { int denom, num; };

int gcd(int m, int n)
{
	int t;
	while (m) {
		t = m; m = n % m; n = t;
	}
	return n;
}

/* evaluate expression tree.  result in fraction form */
void eval_tree(expr e, frac res)
{
	frac_t l, r;
	int t;
	if (e->op == OP_NUM) {
		res->num = e->val;
		res->denom = 1;
		return;
	}

	eval_tree(e->left, &l);
	eval_tree(e->right, &r);

	switch(e->op) {
	case OP_ADD:
		res->num = l.num * r.denom + l.denom * r.num;
		res->denom = l.denom * r.denom;
		break;
	case OP_SUB:
		res->num = l.num * r.denom - l.denom * r.num;
		res->denom = l.denom * r.denom;
		break;
	case OP_MUL:
		res->num = l.num * r.num;
		res->denom = l.denom * r.denom;
		break;
	case OP_DIV:
		res->num = l.num * r.denom;
		res->denom = l.denom * r.num;
		break;
	}
	if ((t = gcd(res->denom, res->num))) {
		res->denom /= t;
		res->num /= t;
	}
}

void get_input()
{
	int i;
reinput:
	reset();
	printf("\nAvailable digits are:");
	for (i = 0; i < N_DIGITS; i++)
		printf(" %d", digits[i].val);
	printf(". Type an expression and I'll check it for you, or make new numbers.\n"
		"Your choice? [Expr/n/q] ");

	while (1) {
		for (i = 0; i < MAX_INPUT; i++) str[i] = '\n';
		fgets(str, MAX_INPUT, stdin);
		if (*str == '\0') goto reinput;
		if (str[MAX_INPUT - 1] != '\n')
			bail("string too long");

		for (i = 0; i < MAX_INPUT; i++)
			if (str[i] == '\n') str[i] = '\0';
		if (str[0] == 'q') {
			printf("Bye\n");
			exit(0);
		}
		if (str[0] == 'n') {
			gen_digits();
			goto reinput;
		}
		return;
	}
}

int main()
{
	frac_t f;
	srand(time(0));

	gen_digits();
	while(1) {
		get_input();
		setjmp(ctx); /* if parse error, jump back here with err msg set */
		if (msg) {
			/* after error jump; announce, reset, redo */
			printf("%s at '%.*s'\n", msg, pos, str);
			continue;
		}

		eval_tree(parse(), &f);

		if (f.denom == 0) bail("Divide by zero");
		if (f.denom == 1 && f.num == 24)
			printf("You got 24.  Very good.\n");
		else {
			if (f.denom == 1)
				printf("Eval to: %d, ", f.num);
			else
				printf("Eval to: %d/%d, ", f.num, f.denom);
			printf("no good.  Try again.\n");
		}
	}
	return 0;
}
`,`#include "24-game.h"



void _gen_digits(void)

{
  int iVar1;
  undefined4 local_14;
  
  for (local_14 = 0; local_14 < 4; local_14 = local_14 + 1) {
    iVar1 = _rand();
    *(int *)((long)local_14 * 0x20 + 0x1000080c4) = iVar1 % 9 + 1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _reset(void)

{
  int local_4;
  
  __msg = 0;
  __pos = 0;
  __pool_ptr = 0;
  for (local_4 = 0; local_4 < 8; local_4 = local_4 + 1) {
    *(undefined4 *)(&_pool + (long)local_4 * 0x20) = 0;
    *(undefined8 *)((long)local_4 * 0x20 + 0x100008160) = 0;
    *(undefined8 *)((long)local_4 * 0x20 + 0x100008158) = 0;
  }
  for (local_4 = 0; local_4 < 4; local_4 = local_4 + 1) {
    *(undefined4 *)((long)local_4 * 0x20 + 0x1000080c8) = 0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _bail(undefined8 param_1)

{
  __msg = param_1;
                    // WARNING: Subroutine does not return
  _longjmp((int *)&_ctx,1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined * _new_expr(void)

{
  long lVar1;
  undefined *local_8;
  
  if (__pool_ptr < 8) {
    lVar1 = (long)__pool_ptr;
    __pool_ptr = __pool_ptr + 1;
    local_8 = &_pool + lVar1 * 0x20;
  }
  else {
    local_8 = (undefined *)0x0;
  }
  return local_8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long _next_tok(void)

{
  int iVar1;
  
  while (iVar1 = _isspace((int)(char)(&_str)[__pos]), iVar1 != 0) {
    __pos = __pos + 1;
  }
  return (long)(char)(&_str)[__pos];
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _take(void)

{
  int local_4;
  
  if ((&_str)[__pos] == '\0') {
    local_4 = 0;
  }
  else {
    __pos = __pos + 1;
    local_4 = __pos;
  }
  return local_4;
}



undefined4 * _get_expr(void)

{
  int iVar1;
  int iVar2;
  long lVar3;
  undefined4 *puVar4;
  undefined4 uVar5;
  undefined4 *local_30;
  
  local_30 = (undefined4 *)_get_term();
  if (local_30 == (undefined4 *)0x0) {
    _bail("Expected term");
  }
  while (iVar1 = _next_tok(), iVar1 == 0x2b || iVar1 == 0x2d) {
    iVar2 = _take();
    if (iVar2 == 0) {
      _bail("Unexpected end of input");
    }
    lVar3 = _get_term();
    if (lVar3 == 0) {
      _bail("Expected term");
    }
    puVar4 = (undefined4 *)_new_expr();
    uVar5 = 2;
    if (iVar1 != 0x2b) {
      uVar5 = 3;
    }
    *puVar4 = uVar5;
    *(undefined4 **)(puVar4 + 4) = local_30;
    *(long *)(puVar4 + 6) = lVar3;
    local_30 = puVar4;
  }
  return local_30;
}



undefined4 * _get_term(void)

{
  int iVar1;
  int iVar2;
  undefined8 uVar3;
  undefined4 *puVar4;
  undefined4 uVar5;
  undefined4 *local_30;
  
  local_30 = (undefined4 *)_get_fact();
  while (iVar1 = _next_tok(), iVar1 == 0x2a || iVar1 == 0x2f) {
    iVar2 = _take();
    if (iVar2 == 0) {
      _bail("Unexpected end of input");
    }
    uVar3 = _get_fact();
    puVar4 = (undefined4 *)_new_expr();
    uVar5 = 4;
    if (iVar1 != 0x2a) {
      uVar5 = 5;
    }
    *puVar4 = uVar5;
    *(undefined4 **)(puVar4 + 4) = local_30;
    *(undefined8 *)(puVar4 + 6) = uVar3;
    local_30 = puVar4;
  }
  return local_30;
}



undefined4 * _get_digit(void)

{
  int iVar1;
  undefined4 *puVar2;
  int local_1c;
  
  iVar1 = _next_tok();
  if ((0x2f < iVar1) && (iVar1 < 0x3a)) {
    _take();
    puVar2 = (undefined4 *)_new_expr();
    *puVar2 = 1;
    puVar2[1] = iVar1 + -0x30;
    for (local_1c = 0; local_1c < 4; local_1c = local_1c + 1) {
      if ((*(int *)((long)local_1c * 0x20 + 0x1000080c4) == puVar2[1]) &&
         (*(int *)((long)local_1c * 0x20 + 0x1000080c8) == 0)) {
        *(undefined4 *)((long)local_1c * 0x20 + 0x1000080c8) = 1;
        return puVar2;
      }
    }
    _bail("Invalid digit");
  }
  return (undefined4 *)0x0;
}



long _get_fact(void)

{
  int iVar1;
  long local_18;
  
  local_18 = _get_digit();
  if (local_18 == 0) {
    iVar1 = _next_tok();
    if (iVar1 == 0x28) {
      _take();
      local_18 = _get_expr();
      iVar1 = _next_tok();
      if (iVar1 != 0x29) {
        _bail("Unbalanced parens");
      }
      _take();
    }
    else {
      local_18 = 0;
    }
  }
  return local_18;
}



undefined8 _parse(void)

{
  int iVar1;
  undefined8 uVar2;
  int local_14;
  
  uVar2 = _get_expr();
  iVar1 = _next_tok();
  if (iVar1 != 0) {
    _bail("Trailing garbage");
  }
  for (local_14 = 0; local_14 < 4; local_14 = local_14 + 1) {
    if (*(int *)((long)local_14 * 0x20 + 0x1000080c8) == 0) {
      _bail("Not all digits are used");
    }
  }
  return uVar2;
}



int _gcd(int param_1,int param_2)

{
  int iVar1;
  undefined4 local_8;
  undefined4 local_4;
  
  local_8 = param_2;
  local_4 = param_1;
  while (local_4 != 0) {
    iVar1 = 0;
    if (local_4 != 0) {
      iVar1 = local_8 / local_4;
    }
    iVar1 = local_8 - iVar1 * local_4;
    local_8 = local_4;
    local_4 = iVar1;
  }
  return local_8;
}



void _eval_tree(int *param_1,int *param_2)

{
  int iVar1;
  int iVar2;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  int *local_20;
  int *local_18;
  
  if (*param_1 == 1) {
    param_2[1] = param_1[1];
    *param_2 = 1;
  }
  else {
    local_20 = param_2;
    local_18 = param_1;
    _eval_tree(*(undefined8 *)(param_1 + 4),&local_28);
    _eval_tree(*(undefined8 *)(local_18 + 6),&local_30);
    switch(*local_18) {
    case 2:
      local_20[1] = local_24 * local_30 + local_28 * local_2c;
      *local_20 = local_28 * local_30;
      break;
    case 3:
      local_20[1] = local_24 * local_30 - local_28 * local_2c;
      *local_20 = local_28 * local_30;
      break;
    case 4:
      local_20[1] = local_24 * local_2c;
      *local_20 = local_28 * local_30;
      break;
    case 5:
      local_20[1] = local_24 * local_30;
      *local_20 = local_28 * local_2c;
    }
    iVar2 = _gcd(*local_20,local_20[1]);
    if (iVar2 != 0) {
      iVar1 = 0;
      if (iVar2 != 0) {
        iVar1 = *local_20 / iVar2;
      }
      *local_20 = iVar1;
      iVar1 = 0;
      if (iVar2 != 0) {
        iVar1 = local_20[1] / iVar2;
      }
      local_20[1] = iVar1;
    }
  }
  return;
}



void _get_input(void)

{
  int local_14;
  
  while( true ) {
    do {
      _reset();
      _printf("\nAvailable digits are:");
      for (local_14 = 0; local_14 < 4; local_14 = local_14 + 1) {
        _printf(" %d");
      }
      _printf(
             ". Type an expression and I\'ll check it for you, or make new numbers.\nYour choice? [Expr/n/q] "
             );
      for (local_14 = 0; local_14 < 0x40; local_14 = local_14 + 1) {
        (&_str)[local_14] = 10;
      }
      _fgets(&_str,0x40,*(FILE **)PTR____stdinp_100004000);
    } while (_str == '\0');
    if (DAT_10000828f != '\n') {
      _bail("string too long");
    }
    for (local_14 = 0; local_14 < 0x40; local_14 = local_14 + 1) {
      if ((&_str)[local_14] == '\n') {
        (&_str)[local_14] = 0;
      }
    }
    if (_str == 'q') break;
    if (_str != 'n') {
      return;
    }
    _gen_digits();
  }
  _printf("Bye\n");
                    // WARNING: Subroutine does not return
  _exit(0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void entry(void)

{
  int iVar1;
  uint uVar2;
  time_t tVar3;
  ulong uVar4;
  undefined8 uVar5;
  int local_1c;
  int local_18;
  undefined4 local_14;
  
  local_14 = 0;
  tVar3 = _time((time_t *)0x0);
  _srand((uint)tVar3);
  uVar4 = _gen_digits();
  do {
    while( true ) {
      _get_input(uVar4);
      iVar1 = _setjmp((int *)&_ctx);
      if (__msg == 0) break;
      uVar2 = _printf("%s at \'%.*s\'\n");
      uVar4 = (ulong)uVar2;
    }
    uVar5 = _parse(iVar1);
    _eval_tree(uVar5,&local_1c);
    if (local_1c == 0) {
      _bail("Divide by zero");
    }
    if ((local_1c == 1) && (local_18 == 0x18)) {
      uVar2 = _printf("You got 24.  Very good.\n");
    }
    else {
      if (local_1c == 1) {
        _printf("Eval to: %d, ");
      }
      else {
        _printf("Eval to: %d/%d, ");
      }
      uVar2 = _printf("no good.  Try again.\n");
    }
    uVar4 = (ulong)uVar2;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003dac. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004008)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003db8. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004010)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _isspace(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dc4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__isspace_100004018)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _longjmp(int *param_1,int param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003dd0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__longjmp_100004020)(param_1,param_2);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ddc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003de8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004030)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _setjmp(int *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003df4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__setjmp_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e00. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004040)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e0c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004048)();
  return tVar1;
}


`
`#include <stdio.h>

#define N 32
#define K 3
#define MAX N * K

typedef struct { int x; int y; } point;

void rot(int n, point *p, int rx, int ry) {
    int t;
    if (!ry) {
        if (rx == 1) {
            p->x = n - 1 - p->x;
            p->y = n - 1 - p->y;
        }
        t = p->x;
        p->x = p->y;
        p->y = t;
    }
}

void d2pt(int n, int d, point *p) {
    int s = 1, t = d, rx, ry;
    p->x = 0;
    p->y = 0;
    while (s < n) {
        rx = 1 & (t / 2);
        ry = 1 & (t ^ rx);
        rot(s, p, rx, ry);
        p->x += s * rx;
        p->y += s * ry;
        t /= 4;
        s *= 2;
    }
}

int main() {
    int d, x, y, cx, cy, px, py;
    char pts[MAX][MAX];
    point curr, prev;
    for (x = 0; x < MAX; ++x)
        for (y = 0; y < MAX; ++y) pts[x][y] = ' ';
    prev.x = prev.y = 0;
    pts[0][0] = '.';
    for (d = 1; d < N * N; ++d) {
        d2pt(N, d, &curr);
        cx = curr.x * K;
        cy = curr.y * K;
        px = prev.x * K;
        py = prev.y * K;
        pts[cx][cy] = '.';
        if (cx == px ) {
            if (py < cy)
                for (y = py + 1; y < cy; ++y) pts[cx][y] = '|';
            else
                for (y = cy + 1; y < py; ++y) pts[cx][y] = '|';
        }
        else {
            if (px < cx)
                for (x = px + 1; x < cx; ++x) pts[x][cy] = '_';
            else
                for (x = cx + 1; x < px; ++x) pts[x][cy] = '_';
        }
        prev = curr;
    }
    for (x = 0; x < MAX; ++x) {
        for (y = 0; y < MAX; ++y) printf("%c", pts[y][x]);
        printf("\n");
    }
    return 0;
}
`,`#include "hilbert-curve.h"



void _rot(int param_1,int *param_2,int param_3,int param_4)

{
  int iVar1;
  
  if (param_4 == 0) {
    if (param_3 == 1) {
      *param_2 = (param_1 + -1) - *param_2;
      param_2[1] = (param_1 + -1) - param_2[1];
    }
    iVar1 = *param_2;
    *param_2 = param_2[1];
    param_2[1] = iVar1;
  }
  return;
}



void _d2pt(int param_1,uint param_2,int *param_3)

{
  uint uVar1;
  uint uVar2;
  uint local_28;
  int local_24;
  
  local_24 = 1;
  *param_3 = 0;
  param_3[1] = 0;
  local_28 = param_2;
  for (; local_24 < param_1; local_24 = local_24 << 1) {
    uVar1 = (int)local_28 / 2 & 1;
    uVar2 = (local_28 ^ uVar1) & 1;
    _rot(local_24,param_3,uVar1,uVar2);
    *param_3 = *param_3 + local_24 * uVar1;
    param_3[1] = param_3[1] + local_24 * uVar2;
    local_28 = (int)local_28 / 4;
  }
  return;
}



undefined8 entry(void)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  int local_2458;
  int iStack_2454;
  int local_2450;
  int iStack_244c;
  int local_2448;
  int local_2444;
  int local_2440;
  int local_243c;
  int local_2438;
  int local_2434;
  int local_2430;
  undefined4 local_242c;
  undefined local_2428 [9216];
  long local_28;
  
  uVar3 = (*(code *)PTR____chkstk_darwin_100004000)();
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  local_242c = 0;
  for (local_2434 = 0; local_2434 < 0x60; local_2434 = local_2434 + 1) {
    for (local_2438 = 0; local_2438 < 0x60; local_2438 = local_2438 + 1) {
      local_2428[(long)local_2438 + (long)local_2434 * 0x60] = 0x20;
    }
  }
  local_2458 = 0;
  iStack_2454 = 0;
  local_2428[0] = 0x2e;
  for (local_2430 = 1; local_2430 < 0x400; local_2430 = local_2430 + 1) {
    uVar3 = _d2pt(0x20,local_2430,&local_2450);
    local_243c = local_2450 * 3;
    local_2440 = iStack_244c * 3;
    local_2444 = local_2458 * 3;
    local_2448 = iStack_2454 * 3;
    local_2428[(long)local_2440 + (long)local_243c * 0x60] = 0x2e;
    if (local_243c == local_2444) {
      local_2438 = local_2448;
      iVar1 = local_2440;
      if (local_2448 < local_2440) {
        while (local_2438 = local_2438 + 1, local_2438 < local_2440) {
          local_2428[(long)local_2438 + (long)local_243c * 0x60] = 0x7c;
        }
      }
      else {
        while (local_2438 = iVar1 + 1, local_2438 < local_2448) {
          local_2428[(long)local_2438 + (long)local_243c * 0x60] = 0x7c;
          iVar1 = local_2438;
        }
      }
    }
    else {
      local_2434 = local_2444;
      iVar1 = local_243c;
      if (local_2444 < local_243c) {
        while (local_2434 = local_2434 + 1, local_2434 < local_243c) {
          local_2428[(long)local_2440 + (long)local_2434 * 0x60] = 0x5f;
        }
      }
      else {
        while (local_2434 = iVar1 + 1, local_2434 < local_2444) {
          local_2428[(long)local_2440 + (long)local_2434 * 0x60] = 0x5f;
          iVar1 = local_2434;
        }
      }
    }
    local_2458 = local_2450;
    iStack_2454 = iStack_244c;
  }
  for (local_2434 = 0; local_2434 < 0x60; local_2434 = local_2434 + 1) {
    for (local_2438 = 0; local_2438 < 0x60; local_2438 = local_2438 + 1) {
      _printf("%c");
    }
    uVar2 = _printf("\n");
    uVar3 = (ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_28) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(uVar3);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`/*

  David Lambert, 2010-Dec-09

  filter producing morse beep commands.

  build:
    make morse

  use:
    $ echo tie a. | ./morse
    beep -n -f 440 -l 300 -D 100 -n -D 200 -n -f 440 -l 100 -D 100 -n -f 440 -l 100 -D 100 -n -D 200 -n -f 440 -l 100 -D 100 -n -D 200 -n -D 400 -n -f 440 -l 100 -D 100 -n -f 440 -l 300 -D 100 -n -D 200 -n -f 440 -l 100 -D 100 -n -f 440 -l 300 -D 100 -n -f 440 -l 100 -D 100 -n -f 440 -l 300 -D 100 -n -f 440 -l 100 -D 100 -n -f 440 -l 300 -D 100 -n -D 200 -n -D 400 -n -D 400

  bugs:
    What is the space between letter and punctuation?
    Demo truncates input lines at 71 characters or so.

 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BIND(A,L,H) ((L)<(A)?(A)<(H)?(A):(H):(L))
/*
  BIND(-1,0,9) is 0
  BIND( 7,0,9) is 7
  BIND(77,0,9) is 9
*/

char
  /* beep args for */
  /* dit  dah     extra space */
  dih[50],dah[50],medium[30],word[30],
  *dd[2] = {dih,dah};
const char
  *ascii = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,?'!/()&:;=+-_\"$@",
  *itu[] = {
     "13","3111","3131","311","1","1131","331","1111","11","1333","313","1311","33","31","333","1331","3313","131","111","3","113","1113","133","3113","3133","3311","33333","13333","11333","11133","11113","11111","31111","33111","33311","33331","131313","331133","113311","133331","313133","31131","31331","313313","13111","333111","313131","31113","13131","311113","113313","131131","1113113","133131"
  };

void append(char*s,const char*morse) {
  for (; *morse; ++morse)
    strcat(s,dd['3'==*morse]);
  strcat(s,medium);
}

char*translate(const char*i,char*o) {
  const char*pc;
  sprintf(o,"beep");
  for (; *i; ++i)
    if (NULL == (pc = strchr(ascii,toupper(*i))))
      strcat(o,word);
    else
      append(o,itu[pc-ascii]);
  strcat(o,word);
  return o;
}

int main(int ac,char*av[]) {
  char
    sin[73],sout[100000];
  int
    dit = 100;
  if (1 < ac) {
    if (strlen(av[1]) != strspn(av[1],"0123456789"))
      return 0*fprintf(stderr,"use: %s [duration]   dit in ms, default %d\n",*av,dit);
    dit = BIND(atoi(av[1]),1,1000);
  }
  sprintf(dah," -n -f 440 -l %d -D %d",3*dit,dit);
  sprintf(dih," -n -f 440 -l %d -D %d",dit,dit);
  sprintf(medium," -n -D %d",(3-1)*dit);
  sprintf(word," -n -D %d",(7-(3-1)-1)*dit);
  while (NULL != fgets(sin,72,stdin))
    puts(translate(sin,sout));
  return 0;
}
`,`#include "morse-code.h"



void _append(undefined8 param_1,char *param_2)

{
  char *local_20;
  
  for (local_20 = param_2; *local_20 != '\0'; local_20 = local_20 + 1) {
    ___strcat_chk(param_1,(&_dd)[*local_20 == '3'],0xffffffffffffffff);
  }
  ___strcat_chk(param_1,&_medium,0xffffffffffffffff);
  return;
}



undefined8 _translate(char *param_1,undefined8 param_2)

{
  undefined *puVar1;
  int iVar2;
  char *pcVar3;
  char *local_18;
  
  ___sprintf_chk(param_2,0,0xffffffffffffffff,"beep");
  for (local_18 = param_1; puVar1 = _ascii, *local_18 != '\0'; local_18 = local_18 + 1) {
    iVar2 = _toupper((int)*local_18);
    pcVar3 = _strchr(puVar1,iVar2);
    if (pcVar3 == (char *)0x0) {
      ___strcat_chk(param_2,&_word,0xffffffffffffffff);
    }
    else {
      _append(param_2,(&_itu)[(long)pcVar3 - (long)_ascii]);
    }
  }
  ___strcat_chk(param_2,&_word,0xffffffffffffffff);
  return param_2;
}



undefined4 entry(void)

{
  int iVar1;
  size_t sVar2;
  size_t sVar3;
  char *pcVar4;
  long extraout_x1;
  undefined auStack_18711 [100000];
  char acStack_71 [73];
  long local_28;
  
  iVar1 = (*(code *)PTR____chkstk_darwin_100004000)();
  local_28 = *(long *)PTR____stack_chk_guard_100004018;
  if (1 < iVar1) {
    sVar2 = _strlen(*(char **)(extraout_x1 + 8));
    sVar3 = _strspn(*(char **)(extraout_x1 + 8),"0123456789");
    if (sVar2 != sVar3) {
      _fprintf(*(FILE **)PTR____stderrp_100004020,"use: %s [duration]   dit in ms, default %d\n");
      goto LAB_100003d20;
    }
    iVar1 = _atoi(*(char **)(extraout_x1 + 8));
    if ((1 < iVar1) && (iVar1 = _atoi(*(char **)(extraout_x1 + 8)), iVar1 < 1000)) {
      _atoi(*(char **)(extraout_x1 + 8));
    }
  }
  ___sprintf_chk(&_dah);
  ___sprintf_chk(&_dih,0,0x32," -n -f 440 -l %d -D %d");
  ___sprintf_chk(&_medium,0);
  ___sprintf_chk(&_word,0,0x1e," -n -D %d");
  while (pcVar4 = _fgets(acStack_71,0x48,*(FILE **)PTR____stdinp_100004028), pcVar4 != (char *)0x0)
  {
    pcVar4 = (char *)_translate(acStack_71,auStack_18711);
    _puts(pcVar4);
  }
LAB_100003d20:
  if (*(long *)PTR____stack_chk_guard_100004018 == local_28) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003d6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004008)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003d78. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004010)();
  return;
}



void ___strcat_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003d84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcat_chk_100004030)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d9c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004040)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003da8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003db4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004050)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strchr(char *param_1,int param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dc0. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strchr_100004058)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dcc. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004060)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strspn(char *param_1,char *param_2)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dd8. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strspn_100004068)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _toupper(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003de4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__toupper_100004070)(_c);
  return iVar1;
}


`
`#include <stdio.h>
#include <time.h>

// We only get one-second precision on most systems, as
// time_t only holds seconds.
struct rate_state_s
{
    time_t lastFlush;
    time_t period;
    size_t tickCount;
};

void tic_rate(struct rate_state_s* pRate)
{
    pRate->tickCount += 1;

    time_t now = time(NULL);

    if((now - pRate->lastFlush) >= pRate->period)
    {
        //TPS Report
        size_t tps = 0.0;
        if(pRate->tickCount > 0)
            tps = pRate->tickCount / (now - pRate->lastFlush);

        printf("%u tics per second.\n", tps);

        //Reset
        pRate->tickCount = 0;
        pRate->lastFlush = now;
    }
}

// A stub function that simply represents whatever it is
// that we want to multiple times.
void something_we_do()
{
    // We use volatile here, as many compilers will optimize away
    // the for() loop otherwise, even without optimizations
    // explicitly enabled.
    //
    // volatile tells the compiler not to make any assumptions
    // about the variable, implying that the programmer knows more
    // about that variable than the compiler, in this case.
    volatile size_t anchor = 0;
    size_t x = 0;
    for(x = 0; x < 0xffff; ++x)
    {
        anchor = x;
    }
}

int main()
{
    time_t start = time(NULL);

    struct rate_state_s rateWatch;
    rateWatch.lastFlush = start;
    rateWatch.tickCount = 0;
    rateWatch.period = 5; // Report every five seconds.

    time_t latest = start;
    // Loop for twenty seconds
    for(latest = start; (latest - start) < 20; latest = time(NULL))
    {
        // Do something.
        something_we_do();

        // Note that we did something.
        tic_rate(&rateWatch);
    }

    return 0;
}
`,`#include "rate-counter.h"



ulong _tic_rate(ulong *param_1)

{
  uint uVar1;
  ulong uVar2;
  ulong uVar3;
  
  param_1[2] = param_1[2] + 1;
  uVar2 = _time((time_t *)0x0);
  uVar3 = uVar2;
  if ((long)param_1[1] <= (long)(uVar2 - *param_1)) {
    uVar1 = _printf("%u tics per second.\n");
    uVar3 = (ulong)uVar1;
    param_1[2] = 0;
    *param_1 = uVar2;
  }
  return uVar3;
}



void _something_we_do(void)

{
  undefined8 local_10;
  
  for (local_10 = 0; local_10 < 0xffff; local_10 = local_10 + 1) {
  }
  return;
}



undefined8 entry(void)

{
  long local_40;
  time_t local_38 [3];
  long local_20;
  undefined4 local_14;
  
  local_14 = 0;
  local_40 = _time((time_t *)0x0);
  local_38[2] = 0;
  local_38[1] = 5;
  local_38[0] = local_40;
  local_20 = local_40;
  while (local_40 - local_20 < 0x14) {
    _something_we_do();
    _tic_rate(local_38);
    local_40 = _time((time_t *)0x0);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004008)();
  return tVar1;
}


`
`#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>

const char *msg = "hello socket world";

int main()
{
   int i, sock, len, slen;

   struct addrinfo hints, *addrs;
   memset(&hints, 0, sizeof(struct addrinfo));
   hints.ai_family = AF_UNSPEC;
   hints.ai_socktype = SOCK_STREAM;

   if (0 == getaddrinfo("localhost", "256", &hints, &addrs))
   {
       sock = socket(addrs->ai_family, addrs->ai_socktype, addrs->ai_protocol);
       if ( sock >= 0 )
       {
           if ( connect(sock, addrs->ai_addr, addrs->ai_addrlen) >= 0 )
           {
               const char *pm = msg;
               do
               {
                  len = strlen(pm);
                  slen = send(sock, pm, len, 0);
                  pm += slen;
               } while ((0 <= slen) && (slen < len));
           }
           close(sock);
       }
       freeaddrinfo(addrs);
   }
}
`,`#include "sockets.h"



undefined4 entry(void)

{
  int iVar1;
  size_t sVar2;
  ssize_t sVar3;
  char *local_68;
  addrinfo *local_60;
  addrinfo aStack_58;
  int local_24;
  int local_20;
  int local_1c;
  undefined4 local_14;
  
  local_14 = 0;
  _memset(&aStack_58,0,0x30);
  aStack_58.ai_family = 0;
  aStack_58.ai_socktype = 1;
  iVar1 = _getaddrinfo("localhost","256",&aStack_58,&local_60);
  if (iVar1 == 0) {
    local_1c = _socket(local_60->ai_family,local_60->ai_socktype,local_60->ai_protocol);
    if (-1 < local_1c) {
      iVar1 = _connect(local_1c,local_60->ai_addr,local_60->ai_addrlen);
      if (-1 < iVar1) {
        local_68 = _msg;
        do {
          sVar2 = _strlen(local_68);
          local_20 = (int)sVar2;
          sVar3 = _send(local_1c,local_68,(long)local_20,0);
          local_24 = (int)sVar3;
          local_68 = local_68 + local_24;
        } while (-1 < local_24 && local_24 < local_20);
      }
      _close(local_1c);
    }
    _freeaddrinfo(local_60);
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004000)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _connect(int param_1,sockaddr *param_2,socklen_t param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__connect_100004008)(param_1,param_2,param_3);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _freeaddrinfo(addrinfo *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__freeaddrinfo_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getaddrinfo(char *param_1,char *param_2,addrinfo *param_3,addrinfo **param_4)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getaddrinfo_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004020)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t _send(int param_1,void *param_2,size_t param_3,int param_4)

{
  ssize_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__send_100004028)(param_1,param_2,param_3,param_4);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _socket(int param_1,int param_2,int param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__socket_100004030)(param_1,param_2,param_3);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004038)();
  return sVar1;
}


`
`#include  <stdio.h>

int playerTurn(int numTokens, int take);
int computerTurn(int numTokens);

int main(void)
{
	printf("Nim Game\n\n");
	
	int Tokens = 12;
	
	while(Tokens > 0)
	{
		printf("How many tokens would you like to take?: ");
		
		int uin;
		scanf("%i", &uin);
		
		int nextTokens = playerTurn(Tokens, uin);
		
		if (nextTokens == Tokens)
		{
			continue;
		}
		
		Tokens = nextTokens;
		
		Tokens = computerTurn(Tokens);
	}
	printf("Computer wins.");
	
	return 0;
}

int playerTurn(int numTokens, int take)
{
	if (take < 1 || take > 3)
	{
		printf("\nTake must be between 1 and 3.\n\n");
		return numTokens;
	}
	int remainingTokens = numTokens - take;
	
	printf("\nPlayer takes %i tokens.\n", take);
	printf("%i tokens remaining.\n\n", remainingTokens);
	
	return remainingTokens;
}

int computerTurn(int numTokens)
{
	int take = numTokens % 4;
	int remainingTokens = numTokens - take;
	
	printf("Computer takes %u tokens.\n", take);
	printf("%i tokens remaining.\n\n", remainingTokens);
	
	return remainingTokens;
}
`,`#include "nim-game.h"



undefined8 entry(void)

{
  int iVar1;
  undefined4 local_1c;
  int local_18;
  
  _printf("Nim Game\n\n");
  local_18 = 0xc;
  while (0 < local_18) {
    _printf("How many tokens would you like to take?: ");
    _scanf("%i");
    iVar1 = _playerTurn(local_18,local_1c);
    if (iVar1 != local_18) {
      local_18 = _computerTurn(iVar1);
    }
  }
  _printf("Computer wins.");
  return 0;
}



int _playerTurn(int param_1,int param_2)

{
  int local_14;
  
  if ((param_2 < 1) || (3 < param_2)) {
    _printf("\nTake must be between 1 and 3.\n\n");
    local_14 = param_1;
  }
  else {
    local_14 = param_1 - param_2;
    _printf("\nPlayer takes %i tokens.\n");
    _printf("%i tokens remaining.\n\n");
  }
  return local_14;
}



int _computerTurn(int param_1)

{
  _printf("Computer takes %u tokens.\n");
  _printf("%i tokens remaining.\n\n");
  return param_1 - param_1 % 4;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void divisor_count_and_sum(unsigned int n, unsigned int* pcount,
                           unsigned int* psum) {
    unsigned int divisor_count = 1;
    unsigned int divisor_sum = 1;
    unsigned int power = 2;
    for (; (n & 1) == 0; power <<= 1, n >>= 1) {
        ++divisor_count;
        divisor_sum += power;
    }
    for (unsigned int p = 3; p * p <= n; p += 2) {
        unsigned int count = 1, sum = 1;
        for (power = p; n % p == 0; power *= p, n /= p) {
            ++count;
            sum += power;
        }
        divisor_count *= count;
        divisor_sum *= sum;
    }
    if (n > 1) {
        divisor_count *= 2;
        divisor_sum *= n + 1;
    }
    *pcount = divisor_count;
    *psum = divisor_sum;
}

int main() {
    unsigned int arithmetic_count = 0;
    unsigned int composite_count = 0;

    for (unsigned int n = 1; arithmetic_count <= 1000000; ++n) {
        unsigned int divisor_count;
        unsigned int divisor_sum;
        divisor_count_and_sum(n, &divisor_count, &divisor_sum);
        if (divisor_sum % divisor_count != 0)
            continue;
        ++arithmetic_count;
        if (divisor_count > 2)
            ++composite_count;
        if (arithmetic_count <= 100) {
            printf("%3u ", n);
            if (arithmetic_count % 10 == 0)
                printf("\n");
        }
        if (arithmetic_count == 1000 || arithmetic_count == 10000 ||
            arithmetic_count == 100000 || arithmetic_count == 1000000) {
            printf("\n%uth arithmetic number is %u\n", arithmetic_count, n);
            printf("Number of composite arithmetic numbers <= %u: %u\n", n,
                   composite_count);
        }
    }
    return 0;
}
`,`#include "arithmetic-numbers.h"



void _divisor_count_and_sum(uint param_1,int *param_2,int *param_3)

{
  uint uVar1;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_4;
  
  local_1c = 1;
  local_20 = 1;
  local_24 = 2;
  for (local_4 = param_1; (local_4 & 1) == 0; local_4 = local_4 >> 1) {
    local_1c = local_1c + 1;
    local_20 = local_20 + local_24;
    local_24 = local_24 << 1;
  }
  for (local_28 = 3; local_28 * local_28 <= local_4; local_28 = local_28 + 2) {
    local_2c = 1;
    local_30 = 1;
    local_24 = local_28;
    uVar1 = local_4;
    while( true ) {
      local_4 = uVar1;
      uVar1 = 0;
      if (local_28 != 0) {
        uVar1 = local_4 / local_28;
      }
      if (local_4 != uVar1 * local_28) break;
      local_2c = local_2c + 1;
      local_30 = local_30 + local_24;
      local_24 = local_24 * local_28;
      uVar1 = 0;
      if (local_28 != 0) {
        uVar1 = local_4 / local_28;
      }
    }
    local_1c = local_1c * local_2c;
    local_20 = local_20 * local_30;
  }
  if (1 < local_4) {
    local_1c = local_1c << 1;
    local_20 = local_20 * (local_4 + 1);
  }
  *param_2 = local_1c;
  *param_3 = local_20;
  return;
}



undefined8 entry(void)

{
  uint uVar1;
  uint local_28;
  uint local_24;
  int local_20;
  int local_1c;
  uint local_18;
  undefined4 local_14;
  
  local_14 = 0;
  local_18 = 0;
  local_1c = 0;
  local_20 = 1;
  while (local_18 < 0xf4241) {
    _divisor_count_and_sum(local_20,&local_24,&local_28);
    uVar1 = 0;
    if (local_24 != 0) {
      uVar1 = local_28 / local_24;
    }
    if (local_28 == uVar1 * local_24) {
      local_18 = local_18 + 1;
      if (2 < local_24) {
        local_1c = local_1c + 1;
      }
      if ((local_18 < 0x65) && (_printf("%3u "), local_18 % 10 == 0)) {
        _printf("\n");
      }
      if ((((local_18 == 1000) || (local_18 == 10000)) || (local_18 == 100000)) ||
         (local_18 == 1000000)) {
        _printf("\n%uth arithmetic number is %u\n");
        _printf("Number of composite arithmetic numbers <= %u: %u\n");
      }
    }
    local_20 = local_20 + 1;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>  // we include the library string.h to the use of string

void saisie(
    char *cpointeur);  // Prototypes of the three functions used in the program
int compte(char *s);
char *miroir(char *s);

int main(int argc, char *argv[])
{
    char chaine[20];
    saisie(chaine);
    printf("miroir est %s", miroir(chaine));
}
// this function is used to put a string
void saisie(char *cpointeur)
{
    printf("saisir une chaine\n");
    scanf("%s", cpointeur);
}
/* the function miroir (in french ) it means "mirror" , the major idea is to
permute the first caractere with the last using an auxilary variable (aux) the
the 2nd character with the penultimate one and so on . we made a call to the
function (compte) which counts the length of the string . As you can see clearly
, I substruct 1 from the equation k = compte(s)-1 ; to get rid of the EOF
caractere which is '\0' because it is not a caractere from the string typed */
char *miroir(char *s)
{
    int i;
    char aux;
    int k;
    k = compte(s) - 1;
    i = 0;
    while (i <= k)
    {
        aux = s[i];
        s[i] = s[k];
        s[k] = aux;
        k--;
        i++;
    }

    return s;
}

// compte plays the role of strlen so we can change it by an strlen function if
// you want that
int compte(char *s)
{
    char *p;
    int k;
    p = s;
    k = 0;
    while (*p != '\0')
    {
        p++;
        k++;
    }
    return k;
}
`,`#include "mirror.h"



undefined8 entry(void)

{
  int iVar1;
  undefined auStack_2c [20];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _saisie();
  _miroir(auStack_2c);
  iVar1 = _printf("miroir est %s");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



int _saisie(void)

{
  int iVar1;
  
  _printf("saisir une chaine\n");
  iVar1 = _scanf("%s");
  return iVar1;
}



long _miroir(long param_1)

{
  undefined uVar1;
  undefined4 local_24;
  undefined4 local_1c;
  
  local_24 = _compte(param_1);
  for (local_1c = 0; local_24 = local_24 + -1, local_1c <= local_24; local_1c = local_1c + 1) {
    uVar1 = *(undefined *)(param_1 + local_1c);
    *(undefined *)(param_1 + local_1c) = *(undefined *)(param_1 + local_24);
    *(undefined *)(param_1 + local_24) = uVar1;
  }
  return param_1;
}



int _compte(char *param_1)

{
  int local_14;
  char *local_10;
  
  local_14 = 0;
  for (local_10 = param_1; *local_10 != '\0'; local_10 = local_10 + 1) {
    local_14 = local_14 + 1;
  }
  return local_14;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int even_sel(int x) { return !(x & 1); }
int tri_sel(int x) { return x % 3; }

/* using a predicate function sel() to select elements */
int* grep(int *in, int len, int *outlen, int (*sel)(int), int inplace)
{
	int i, j, *out;

	if (inplace)	out = in;
	else		out = malloc(sizeof(int) * len);

	for (i = j = 0; i < len; i++)
		if (sel(in[i]))
			out[j++] = in[i];

	if (!inplace && j < len)
		out = realloc(out, sizeof(int) * j);

	*outlen = j;
	return out;
}

int main()
{
	int in[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int i, len;

	int *even = grep(in, 10, &len, even_sel, 0);
	printf("Filtered even:");
	for (i = 0; i < len; i++) printf(" %d", even[i]);
	printf("\n");

	grep(in, 8, &len, tri_sel, 1);
	printf("In-place filtered not multiple of 3:");
	for (i = 0; i < len; i++) printf(" %d", in[i]);

	printf("\n");

	return 0;
}
`,`#include "filter.h"



bool _even_sel(uint param_1)

{
  return (param_1 & 1) == 0;
}



int _tri_sel(int param_1)

{
  return param_1 % 3;
}



void * _grep(void *param_1,int param_2,int *param_3,code *param_4,int param_5)

{
  int iVar1;
  long lVar2;
  void *local_48;
  int local_3c;
  int local_38;
  
  local_48 = param_1;
  if (param_5 == 0) {
    local_48 = _malloc((long)param_2 * 4);
  }
  local_3c = 0;
  for (local_38 = 0; local_38 < param_2; local_38 = local_38 + 1) {
    iVar1 = (*param_4)(*(undefined4 *)((long)param_1 + (long)local_38 * 4));
    if (iVar1 != 0) {
      lVar2 = (long)local_3c;
      local_3c = local_3c + 1;
      *(undefined4 *)((long)local_48 + lVar2 * 4) =
           *(undefined4 *)((long)param_1 + (long)local_38 * 4);
    }
  }
  if ((param_5 == 0) && (local_3c < param_2)) {
    local_48 = _realloc(local_48,(long)local_3c * 4);
  }
  *param_3 = local_3c;
  return local_48;
}



undefined8 entry(void)

{
  int iVar1;
  int local_4c;
  int local_48;
  undefined4 local_44;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_44 = 0;
  _memcpy(auStack_40,&DAT_100003f3c,0x28);
  _grep(auStack_40,10,&local_4c,_even_sel,0);
  _printf("Filtered even:");
  for (local_48 = 0; local_48 < local_4c; local_48 = local_48 + 1) {
    _printf(" %d");
  }
  _printf("\n");
  _grep(auStack_40,8,&local_4c,_tri_sel,1);
  _printf("In-place filtered not multiple of 3:");
  for (local_48 = 0; local_48 < local_4c; local_48 = local_48 + 1) {
    _printf(" %d");
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004028)();
  return pvVar1;
}


`
`#include<string.h>
#include<stdlib.h>
#include<stdio.h>

#define COLLAPSE 0
#define SQUEEZE 1

typedef struct charList{
    char c;
    struct charList *next;
} charList;

/*
Implementing strcmpi, the case insensitive string comparator, as it is not part of the C Standard Library.

Comment this out if testing on a compiler where it is already defined.
*/

int strcmpi(char str1[100],char str2[100]){
    int len1 = strlen(str1), len2 = strlen(str2), i;

    if(len1!=len2){
        return 1;
    }

    else{
        for(i=0;i<len1;i++){
            if((str1[i]>='A'&&str1[i]<='Z')&&(str2[i]>='a'&&str2[i]<='z')&&(str2[i]-65!=str1[i]))
                return 1;
            else if((str2[i]>='A'&&str2[i]<='Z')&&(str1[i]>='a'&&str1[i]<='z')&&(str1[i]-65!=str2[i]))
                return 1;
            else if(str1[i]!=str2[i])
                return 1;
        }
    }

    return 0;
}

charList *strToCharList(char* str){
    int len = strlen(str),i;

    charList *list, *iterator, *nextChar;

    list = (charList*)malloc(sizeof(charList));
    list->c = str[0];
    list->next = NULL;

    iterator = list;

    for(i=1;i<len;i++){
        nextChar = (charList*)malloc(sizeof(charList));
        nextChar->c = str[i];
        nextChar->next = NULL;

        iterator->next = nextChar;
        iterator = nextChar;
    }

    return list;
}

char* charListToString(charList* list){
    charList* iterator = list;
    int count = 0,i;
    char* str;

    while(iterator!=NULL){
        count++;
        iterator = iterator->next;
    }

    str = (char*)malloc((count+1)*sizeof(char));
    iterator = list;

    for(i=0;i<count;i++){
        str[i] = iterator->c;
        iterator = iterator->next;
    }

    free(list);
    str[i] = '\0';

    return str;
}

char* processString(char str[100],int operation, char squeezeChar){
    charList *strList = strToCharList(str),*iterator = strList, *scout;

    if(operation==SQUEEZE){
        while(iterator!=NULL){
            if(iterator->c==squeezeChar){
                scout = iterator->next;

                while(scout!=NULL && scout->c==squeezeChar){
                        iterator->next = scout->next;
                        scout->next = NULL;
                        free(scout);
                        scout = iterator->next;
                }
            }
            iterator = iterator->next;
        }
    }

    else{
        while(iterator!=NULL && iterator->next!=NULL){
            if(iterator->c == (iterator->next)->c){
                scout = iterator->next;
                squeezeChar = iterator->c;

                while(scout!=NULL && scout->c==squeezeChar){
                        iterator->next = scout->next;
                        scout->next = NULL;
                        free(scout);
                        scout = iterator->next;
                }
            }
            iterator = iterator->next;
        }
    }

    return charListToString(strList);
}

void printResults(char originalString[100], char finalString[100], int operation, char squeezeChar){
    if(operation==SQUEEZE){
        printf("Specified Operation : SQUEEZE\nTarget Character : %c",squeezeChar);
    }

    else
        printf("Specified Operation : COLLAPSE");

    printf("\nOriginal %c%c%c%s%c%c%c\nLength : %d",174,174,174,originalString,175,175,175,(int)strlen(originalString));
    printf("\nFinal    %c%c%c%s%c%c%c\nLength : %d\n",174,174,174,finalString,175,175,175,(int)strlen(finalString));
}

int main(int argc, char** argv){
    int operation;
    char squeezeChar;

    if(argc<3||argc>4){
        printf("Usage : %s <SQUEEZE|COLLAPSE> <String to be processed> <Character to be squeezed, if operation is SQUEEZE>\n",argv[0]);
        return 0;
    }

    if(strcmpi(argv[1],"SQUEEZE")==0 && argc!=4){
        scanf("Please enter characted to be squeezed : %c",&squeezeChar);
        operation = SQUEEZE;
    }

    else if(argc==4){
        operation = SQUEEZE;
        squeezeChar = argv[3][0];
    }

    else if(strcmpi(argv[1],"COLLAPSE")==0){
        operation = COLLAPSE;
    }

    if(strlen(argv[2])<2){
        printResults(argv[2],argv[2],operation,squeezeChar);
    }

    else{
        printResults(argv[2],processString(argv[2],operation,squeezeChar),operation,squeezeChar);
    }

    return 0;
}
`,`#include "determine-if-a-string-is-squeezable.h"



undefined4 _strcmpi(char *param_1,char *param_2)

{
  size_t sVar1;
  size_t sVar2;
  int local_34;
  undefined4 local_14;
  
  sVar1 = _strlen(param_1);
  sVar2 = _strlen(param_2);
  if ((int)sVar1 == (int)sVar2) {
    for (local_34 = 0; local_34 < (int)sVar1; local_34 = local_34 + 1) {
      if (((('@' < param_1[local_34]) && (param_1[local_34] < '[')) && ('' < param_2[local_34])) &&
         ((param_2[local_34] < '{' && (param_2[local_34] + -0x41 != (int)param_1[local_34])))) {
        return 1;
      }
      if ((('@' < param_2[local_34]) && (param_2[local_34] < '[')) &&
         (('' < param_1[local_34] &&
          ((param_1[local_34] < '{' && (param_1[local_34] + -0x41 != (int)param_2[local_34])))))) {
        return 1;
      }
      if (param_1[local_34] != param_2[local_34]) {
        return 1;
      }
    }
    local_14 = 0;
  }
  else {
    local_14 = 1;
  }
  return local_14;
}



char * _strToCharList(char *param_1)

{
  size_t sVar1;
  char *pcVar2;
  char *pcVar3;
  char *local_30;
  int local_20;
  
  sVar1 = _strlen(param_1);
  pcVar2 = (char *)_malloc(0x10);
  *pcVar2 = *param_1;
  pcVar2[8] = '\0';
  pcVar2[9] = '\0';
  pcVar2[10] = '\0';
  pcVar2[0xb] = '\0';
  pcVar2[0xc] = '\0';
  pcVar2[0xd] = '\0';
  pcVar2[0xe] = '\0';
  pcVar2[0xf] = '\0';
  local_30 = pcVar2;
  for (local_20 = 1; local_20 < (int)sVar1; local_20 = local_20 + 1) {
    pcVar3 = (char *)_malloc(0x10);
    *pcVar3 = param_1[local_20];
    pcVar3[8] = '\0';
    pcVar3[9] = '\0';
    pcVar3[10] = '\0';
    pcVar3[0xb] = '\0';
    pcVar3[0xc] = '\0';
    pcVar3[0xd] = '\0';
    pcVar3[0xe] = '\0';
    pcVar3[0xf] = '\0';
    *(char **)(local_30 + 8) = pcVar3;
    local_30 = pcVar3;
  }
  return pcVar2;
}



void * _charListToString(undefined *param_1)

{
  void *pvVar1;
  int local_28;
  int local_24;
  undefined *local_20;
  
  local_24 = 0;
  for (local_20 = param_1; local_20 != (undefined *)0x0; local_20 = *(undefined **)(local_20 + 8)) {
    local_24 = local_24 + 1;
  }
  pvVar1 = _malloc((long)(local_24 + 1));
  local_20 = param_1;
  for (local_28 = 0; local_28 < local_24; local_28 = local_28 + 1) {
    *(undefined *)((long)pvVar1 + (long)local_28) = *local_20;
    local_20 = *(undefined **)(local_20 + 8);
  }
  _free(param_1);
  *(undefined *)((long)pvVar1 + (long)local_28) = 0;
  return pvVar1;
}



void _processString(undefined8 param_1,int param_2,byte param_3)

{
  byte bVar1;
  bool bVar2;
  byte *pbVar3;
  char *local_38;
  byte *local_30;
  
  pbVar3 = (byte *)_strToCharList(param_1);
  local_30 = pbVar3;
  if (param_2 == 1) {
    for (; local_30 != (byte *)0x0; local_30 = *(byte **)(local_30 + 8)) {
      if ((int)(char)*local_30 == (uint)param_3) {
        local_38 = *(char **)(local_30 + 8);
        while( true ) {
          bVar2 = false;
          if (local_38 != (char *)0x0) {
            bVar2 = (int)*local_38 == (uint)param_3;
          }
          if (!bVar2) break;
          *(undefined8 *)(local_30 + 8) = *(undefined8 *)(local_38 + 8);
          local_38[8] = '\0';
          local_38[9] = '\0';
          local_38[10] = '\0';
          local_38[0xb] = '\0';
          local_38[0xc] = '\0';
          local_38[0xd] = '\0';
          local_38[0xe] = '\0';
          local_38[0xf] = '\0';
          _free(local_38);
          local_38 = *(char **)(local_30 + 8);
        }
      }
    }
  }
  else {
    while( true ) {
      bVar2 = false;
      if (local_30 != (byte *)0x0) {
        bVar2 = *(long *)(local_30 + 8) != 0;
      }
      if (!bVar2) break;
      if (*local_30 == **(byte **)(local_30 + 8)) {
        local_38 = *(char **)(local_30 + 8);
        bVar1 = *local_30;
        while( true ) {
          bVar2 = false;
          if (local_38 != (char *)0x0) {
            bVar2 = (int)*local_38 == (uint)bVar1;
          }
          if (!bVar2) break;
          *(undefined8 *)(local_30 + 8) = *(undefined8 *)(local_38 + 8);
          local_38[8] = '\0';
          local_38[9] = '\0';
          local_38[10] = '\0';
          local_38[0xb] = '\0';
          local_38[0xc] = '\0';
          local_38[0xd] = '\0';
          local_38[0xe] = '\0';
          local_38[0xf] = '\0';
          _free(local_38);
          local_38 = *(char **)(local_30 + 8);
        }
      }
      local_30 = *(byte **)(local_30 + 8);
    }
  }
  _charListToString(pbVar3);
  return;
}



int _printResults(char *param_1,char *param_2,int param_3)

{
  int iVar1;
  
  if (param_3 == 1) {
    _printf("Specified Operation : SQUEEZE\nTarget Character : %c");
  }
  else {
    _printf("Specified Operation : COLLAPSE");
  }
  _strlen(param_1);
  _printf("\nOriginal %c%c%c%s%c%c%c\nLength : %d");
  _strlen(param_2);
  iVar1 = _printf("\nFinal    %c%c%c%s%c%c%c\nLength : %d\n");
  return iVar1;
}



undefined4 entry(int param_1,long param_2)

{
  int iVar1;
  size_t sVar2;
  undefined8 uVar3;
  undefined8 uVar4;
  undefined local_25;
  undefined4 local_24;
  
  if ((param_1 < 3) || (4 < param_1)) {
    _printf(
           "Usage : %s <SQUEEZE|COLLAPSE> <String to be processed> <Character to be squeezed, if operation is SQUEEZE>\n"
           );
  }
  else {
    iVar1 = _strcmpi(*(undefined8 *)(param_2 + 8),"SQUEEZE");
    if ((iVar1 == 0) && (param_1 != 4)) {
      _scanf("Please enter characted to be squeezed : %c");
      local_24 = 1;
    }
    else if (param_1 == 4) {
      local_24 = 1;
      local_25 = **(undefined **)(param_2 + 0x18);
    }
    else {
      iVar1 = _strcmpi(*(undefined8 *)(param_2 + 8),"COLLAPSE");
      if (iVar1 == 0) {
        local_24 = 0;
      }
    }
    sVar2 = _strlen(*(char **)(param_2 + 0x10));
    if (sVar2 < 2) {
      _printResults(*(undefined8 *)(param_2 + 0x10),*(undefined8 *)(param_2 + 0x10),local_24,
                    local_25);
    }
    else {
      uVar4 = *(undefined8 *)(param_2 + 0x10);
      uVar3 = _processString(*(undefined8 *)(param_2 + 0x10),local_24,local_25);
      _printResults(uVar4,uVar3,local_24,local_25);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e38. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e5c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004020)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BASE_MIN 2
#define BASE_MAX 94

void selfdesc(unsigned long);

const char *ref = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{|}~";
char *digs;
unsigned long *nums, *inds, inds_sum, inds_val, base;

int main(int argc, char *argv[]) {
int used[BASE_MAX];
unsigned long digs_n, i;
	if (argc != 2) {
		fprintf(stderr, "Usage is %s <digits>\n", argv[0]);
		return EXIT_FAILURE;
	}
	digs = argv[1];
	digs_n = strlen(digs);
	if (digs_n < BASE_MIN || digs_n > BASE_MAX) {
		fprintf(stderr, "Invalid number of digits\n");
		return EXIT_FAILURE;
	}
	for (i = 0; i < BASE_MAX; i++) {
		used[i] = 0;
	}
	for (i = 0; i < digs_n && strchr(ref, digs[i]) && !used[digs[i]-*ref]; i++) {
		used[digs[i]-*ref] = 1;
	}
	if (i < digs_n) {
		fprintf(stderr, "Invalid digits\n");
		return EXIT_FAILURE;
	}
	nums = calloc(digs_n, sizeof(unsigned long));
	if (!nums) {
		fprintf(stderr, "Could not allocate memory for nums\n");
		return EXIT_FAILURE;
	}
	inds = malloc(sizeof(unsigned long)*digs_n);
	if (!inds) {
		fprintf(stderr, "Could not allocate memory for inds\n");
		free(nums);
		return EXIT_FAILURE;
	}
	inds_sum = 0;
	inds_val = 0;
	for (base = BASE_MIN; base <= digs_n; base++) {
		selfdesc(base);
	}
	free(inds);
	free(nums);
	return EXIT_SUCCESS;
}

void selfdesc(unsigned long i) {
unsigned long diff_sum, upper_min, j, lower, upper, k;
	if (i) {
		diff_sum = base-inds_sum;
		upper_min = inds_sum ? diff_sum:base-1;
		j = i-1;
		if (j) {
			lower = 0;
			upper = (base-inds_val)/j;
		}
		else {
			lower = diff_sum;
			upper = diff_sum;
		}
		if (upper < upper_min) {
			upper_min = upper;
		}
		for (inds[j] = lower; inds[j] <= upper_min; inds[j]++) {
			nums[inds[j]]++;
			inds_sum += inds[j];
			inds_val += inds[j]*j;
			for (k = base-1; k > j && nums[k] <= inds[k] && inds[k]-nums[k] <= i; k--);
			if (k == j) {
				selfdesc(i-1);
			}
			inds_val -= inds[j]*j;
			inds_sum -= inds[j];
			nums[inds[j]]--;
		}
	}
	else {
		for (j = 0; j < base; j++) {
			putchar(digs[inds[j]]);
		}
		puts("");
	}
}
`,`#include "self-describing-numbers-2.h"



undefined4 entry(int param_1,long param_2)

{
  bool bVar1;
  size_t sVar2;
  char *pcVar3;
  int aiStack_59c [247];
  ulong local_1c0;
  undefined4 local_1a4;
  int aiStack_1a0 [94];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  if (param_1 == 2) {
    _digs = *(char **)(param_2 + 8);
    sVar2 = _strlen(_digs);
    if ((sVar2 < 2) || (0x5e < sVar2)) {
      _fprintf(*(FILE **)PTR____stderrp_100004010,"Invalid number of digits\n");
      local_1a4 = 1;
    }
    else {
      for (local_1c0 = 0; local_1c0 < 0x5e; local_1c0 = local_1c0 + 1) {
        aiStack_1a0[local_1c0] = 0;
      }
      local_1c0 = 0;
      while( true ) {
        bVar1 = false;
        if (local_1c0 < sVar2) {
          pcVar3 = _strchr(_ref,(int)_digs[local_1c0]);
          bVar1 = false;
          if (pcVar3 != (char *)0x0) {
            bVar1 = aiStack_1a0[(int)_digs[local_1c0] - (int)(char)*_ref] == 0;
          }
        }
        if (!bVar1) break;
        aiStack_1a0[(int)_digs[local_1c0] - (int)(char)*_ref] = 1;
        local_1c0 = local_1c0 + 1;
      }
      if (local_1c0 < sVar2) {
        _fprintf(*(FILE **)PTR____stderrp_100004010,"Invalid digits\n");
        local_1a4 = 1;
      }
      else {
        _nums = _calloc(sVar2,8);
        if (_nums == (void *)0x0) {
          _fprintf(*(FILE **)PTR____stderrp_100004010,"Could not allocate memory for nums\n");
          local_1a4 = 1;
        }
        else {
          _inds = _malloc(sVar2 * 8);
          if (_inds == (void *)0x0) {
            _fprintf(*(FILE **)PTR____stderrp_100004010,"Could not allocate memory for inds\n");
            _free(_nums);
            local_1a4 = 1;
          }
          else {
            _inds_sum = 0;
            _inds_val = 0;
            for (_base = 2; _base <= sVar2; _base = _base + 1) {
              _selfdesc(_base);
            }
            _free(_inds);
            _free(_nums);
            local_1a4 = 0;
          }
        }
      }
    }
  }
  else {
    _fprintf(*(FILE **)PTR____stderrp_100004010,"Usage is %s <digits>\n");
    local_1a4 = 1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return local_1a4;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



ulong _selfdesc(ulong param_1)

{
  bool bVar1;
  long *plVar2;
  ulong uVar3;
  uint uVar4;
  ulong uVar5;
  ulong local_50;
  ulong local_48;
  ulong local_40;
  ulong local_38;
  ulong local_30;
  ulong local_28;
  
  if (param_1 == 0) {
    for (local_30 = 0; local_30 < _base; local_30 = local_30 + 1) {
      _putchar((int)*(char *)(_digs + *(long *)(_inds + local_30 * 8)));
    }
    uVar4 = _puts("");
    uVar5 = (ulong)uVar4;
  }
  else {
    local_40 = _base - _inds_sum;
    local_50 = local_40;
    if (_inds_sum == 0) {
      local_50 = _base - 1;
    }
    local_28 = local_50;
    uVar3 = param_1 - 1;
    local_38 = local_40;
    if (uVar3 != 0) {
      local_38 = 0;
      local_40 = 0;
      if (uVar3 != 0) {
        local_40 = (_base - _inds_val) / uVar3;
      }
    }
    if (local_40 < local_50) {
      local_28 = local_40;
    }
    *(ulong *)(_inds + uVar3 * 8) = local_38;
    uVar5 = param_1;
    while (*(ulong *)(_inds + uVar3 * 8) <= local_28) {
      plVar2 = (long *)(_nums + *(long *)(_inds + uVar3 * 8) * 8);
      *plVar2 = *plVar2 + 1;
      _inds_sum = _inds_sum + *(long *)(_inds + uVar3 * 8);
      _inds_val = _inds_val + *(long *)(_inds + uVar3 * 8) * uVar3;
      local_48 = _base;
      do {
        local_48 = local_48 - 1;
        bVar1 = false;
        if ((uVar3 < local_48) &&
           (bVar1 = false, *(ulong *)(_nums + local_48 * 8) <= *(ulong *)(_inds + local_48 * 8))) {
          bVar1 = (ulong)(*(long *)(_inds + local_48 * 8) - *(long *)(_nums + local_48 * 8)) <=
                  param_1;
        }
      } while (bVar1);
      if (local_48 == uVar3) {
        uVar5 = _selfdesc(param_1 - 1);
      }
      _inds_val = _inds_val - *(long *)(_inds + uVar3 * 8) * uVar3;
      _inds_sum = _inds_sum - *(long *)(_inds + uVar3 * 8);
      plVar2 = (long *)(_nums + *(long *)(_inds + uVar3 * 8) * 8);
      *plVar2 = *plVar2 + -1;
      plVar2 = (long *)(_inds + uVar3 * 8);
      *plVar2 = *plVar2 + 1;
    }
  }
  return uVar5;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e60. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e78. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e84. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004030)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004038)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strchr(char *param_1,int param_2)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ea8. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strchr_100004048)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb4. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004050)();
  return sVar1;
}


`
`#include <stdio.h>
#include <math.h>
#include <complex.h>

double PI;
typedef double complex cplx;

void _fft(cplx buf[], cplx out[], int n, int step)
{
	if (step < n) {
		_fft(out, buf, n, step * 2);
		_fft(out + step, buf + step, n, step * 2);

		for (int i = 0; i < n; i += 2 * step) {
			cplx t = cexp(-I * PI * i / n) * out[i + step];
			buf[i / 2]     = out[i] + t;
			buf[(i + n)/2] = out[i] - t;
		}
	}
}

void fft(cplx buf[], int n)
{
	cplx out[n];
	for (int i = 0; i < n; i++) out[i] = buf[i];

	_fft(buf, out, n, 1);
}


void show(const char * s, cplx buf[]) {
	printf("%s", s);
	for (int i = 0; i < 8; i++)
		if (!cimag(buf[i]))
			printf("%g ", creal(buf[i]));
		else
			printf("(%g, %g) ", creal(buf[i]), cimag(buf[i]));
}

int main()
{
	PI = atan2(1, 1) * 4;
	cplx buf[] = {1, 1, 1, 1, 0, 0, 0, 0};

	show("Data: ", buf);
	fft(buf, 8);
	show("\nFFT : ", buf);

	return 0;
}
`,`#include "fast-fourier-transform-1.h"



// WARNING: Removing unreachable block (ram,0x000100003540)
// WARNING: Removing unreachable block (ram,0x000100003560)
// WARNING: Removing unreachable block (ram,0x000100003620)
// WARNING: Removing unreachable block (ram,0x000100003640)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fft(long param_1,long param_2,int param_3,int param_4)

{
  double *pdVar1;
  double *pdVar2;
  undefined8 uVar3;
  double dVar4;
  double dVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  int local_2c;
  
  if (param_4 < param_3) {
    __fft(param_2,param_1,param_3,param_4 << 1);
    __fft(param_2 + (long)param_4 * 0x10,param_1 + (long)param_4 * 0x10,param_3,param_4 << 1);
    for (local_2c = 0; local_2c < param_3; local_2c = local_2c + param_4 * 2) {
      dVar6 = __PI * -0.0 * 0.0 + __PI * -1.0 * (double)(long)local_2c;
      uVar3 = FUN_1000039fc(__PI * -0.0 * (double)(long)local_2c - __PI * -1.0 * 0.0,dVar6,
                            (double)(long)param_3,0);
      dVar4 = (double)_cexp(uVar3);
      pdVar1 = (double *)(param_2 + (long)(local_2c + param_4) * 0x10);
      dVar7 = *pdVar1;
      dVar8 = pdVar1[1];
      dVar5 = dVar4 * dVar7 - dVar6 * dVar8;
      dVar6 = dVar4 * dVar8 + dVar6 * dVar7;
      pdVar2 = (double *)(param_2 + (long)local_2c * 0x10);
      dVar4 = pdVar2[1];
      pdVar1 = (double *)(param_1 + (long)(local_2c / 2) * 0x10);
      *pdVar1 = *pdVar2 + dVar5;
      pdVar1[1] = dVar4 + dVar6;
      pdVar2 = (double *)(param_2 + (long)local_2c * 0x10);
      dVar4 = pdVar2[1];
      pdVar1 = (double *)(param_1 + (long)((local_2c + param_3) / 2) * 0x10);
      *pdVar1 = *pdVar2 - dVar5;
      pdVar1[1] = dVar4 - dVar6;
    }
  }
  return;
}



void _fft(long param_1,uint param_2)

{
  undefined8 *puVar1;
  undefined8 *puVar2;
  undefined8 uVar3;
  undefined *apuStack_60 [2];
  long local_50;
  long local_48;
  int local_3c;
  undefined *local_30;
  uint local_24;
  long local_20;
  long local_18;
  
  local_30 = (undefined *)apuStack_60;
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_50 = (ulong)param_2 * 0x10;
  local_24 = param_2;
  local_20 = param_1;
  (*(code *)PTR____chkstk_darwin_100004000)();
  local_48 = (long)apuStack_60 - local_50;
  for (local_3c = 0; local_3c < (int)local_24; local_3c = local_3c + 1) {
    puVar1 = (undefined8 *)(local_20 + (long)local_3c * 0x10);
    uVar3 = puVar1[1];
    puVar2 = (undefined8 *)(local_48 + (long)local_3c * 0x10);
    *puVar2 = *puVar1;
    puVar2[1] = uVar3;
  }
  __fft(local_20,local_48,local_24,1);
  apuStack_60[1] = local_30;
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



int _show(undefined8 param_1,long param_2)

{
  int iVar1;
  int local_24;
  
  iVar1 = _printf("%s");
  for (local_24 = 0; local_24 < 8; local_24 = local_24 + 1) {
    if (*(double *)(param_2 + (long)local_24 * 0x10 + 8) == 0.0) {
      iVar1 = _printf("%g ");
    }
    else {
      iVar1 = _printf("(%g, %g) ");
    }
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(void)

{
  undefined8 local_98 [2];
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  __PI = (double)_atan2(0x3ff0000000000000);
  __PI = __PI * 4.0;
  _memset(local_98,0,0x80);
  local_98[0] = 0x3ff0000000000000;
  local_88 = 0x3ff0000000000000;
  local_78 = 0x3ff0000000000000;
  local_68 = 0x3ff0000000000000;
  _show("Data: ",local_98);
  _fft(local_98,8);
  _show("\nFFT : ",local_98);
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x000100003d40)
// WARNING: Removing unreachable block (ram,0x000100003d48)
// WARNING: Removing unreachable block (ram,0x000100003d50)
// WARNING: Removing unreachable block (ram,0x000100003d60)
// WARNING: Removing unreachable block (ram,0x000100003d78)
// WARNING: Removing unreachable block (ram,0x000100003d8c)
// WARNING: Removing unreachable block (ram,0x000100003da0)
// WARNING: Removing unreachable block (ram,0x000100003e08)
// WARNING: Removing unreachable block (ram,0x000100003e1c)
// WARNING: Removing unreachable block (ram,0x000100003e24)
// WARNING: Removing unreachable block (ram,0x000100003e38)
// WARNING: Removing unreachable block (ram,0x000100003e58)
// WARNING: Removing unreachable block (ram,0x000100003e5c)
// WARNING: Removing unreachable block (ram,0x000100003e70)
// WARNING: Removing unreachable block (ram,0x000100003e74)
// WARNING: Removing unreachable block (ram,0x000100003e94)
// WARNING: Removing unreachable block (ram,0x000100003e98)
// WARNING: Removing unreachable block (ram,0x000100003e9c)
// WARNING: Removing unreachable block (ram,0x000100003db0)
// WARNING: Removing unreachable block (ram,0x000100003dbc)
// WARNING: Removing unreachable block (ram,0x000100003dc0)
// WARNING: Removing unreachable block (ram,0x000100003ddc)
// WARNING: Removing unreachable block (ram,0x000100003de0)
// WARNING: Removing unreachable block (ram,0x000100003d58)
// WARNING: Removing unreachable block (ram,0x000100003ea8)

undefined  [16]
FUN_1000039fc(double param_1,double param_2,undefined param_3 [16],undefined param_4 [16])

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  ulong uVar6;
  ulong uVar7;
  undefined auVar8 [16];
  double dVar9;
  double dVar10;
  double dVar11;
  double dVar12;
  
  dVar9 = param_3._0_8_;
  dVar10 = param_4._0_8_;
  dVar11 = ABS(dVar9);
  if (ABS(dVar9) <= ABS(dVar10)) {
    dVar11 = ABS(dVar10);
  }
  uVar5 = (uint)((ulong)dVar11 >> 0x34) & 0x7ff;
  iVar4 = (((uint)((ulong)((long)dVar11 << ((ulong)((int)LZCOUNT(ABS(dVar11)) - 0xb) & 0x3f)) >>
                  0x34) & 0x7ff) - (int)LZCOUNT(ABS(dVar11))) + -0x3f4;
  if (uVar5 != 0) {
    iVar4 = uVar5 - 0x3ff;
  }
  dVar12 = -INFINITY;
  if (dVar11 != 0.0) {
    dVar12 = (double)iVar4;
  }
  if (dVar11 == -NAN || (long)dVar11 + 1 < 0 != SCARRY8((long)dVar11,1)) {
    dVar11 = -dVar11;
  }
  if (uVar5 == 0x7ff) {
    dVar12 = dVar11;
  }
  if ((ulong)ABS(dVar12) < 0x7ff0000000000000) {
    iVar4 = (int)dVar12;
    iVar3 = -iVar4;
    if ((dVar9 != 0.0) && (uVar5 = param_3._4_4_ >> 0x14 & 0x7ff, uVar5 != 0x7ff)) {
      uVar6 = (ulong)dVar9 & 0xfffffffffffff;
      if (uVar5 == 0) {
        uVar5 = 0xc - (int)LZCOUNT(uVar6);
        uVar6 = uVar6 << ((ulong)((int)LZCOUNT(uVar6) - 0xb) & 0x3f) & 0xffefffffffffffff;
      }
      uVar1 = (int)(uVar5 + iVar3) >> 0x1f ^ 0x80000000;
      if (!SCARRY4(uVar5,iVar3)) {
        uVar1 = uVar5 + iVar3;
      }
      uVar7 = (ulong)dVar9 & 0x8000000000000000;
      if ((int)uVar1 < 0x7ff) {
        if ((int)uVar1 < 1) {
          if (uVar1 == 0xfffffc03 || (int)(uVar1 + 0x3fd) < 0 != SCARRY4(uVar1,0x3fd)) {
            uVar1 = 0xfffffc03;
          }
          dVar9 = (double)(uVar6 | uVar7 | 0x10000000000000) *
                  (double)((ulong)(uVar1 + 0x3fe) << 0x34);
        }
        else {
          dVar9 = (double)(uVar7 | (ulong)uVar1 << 0x34 | uVar6);
        }
      }
      else {
        dVar9 = (double)(uVar7 | 0x7fe0000000000000) + (double)(uVar7 | 0x7fe0000000000000);
      }
    }
    if ((dVar10 != 0.0) && (uVar5 = param_4._4_4_ >> 0x14 & 0x7ff, uVar5 != 0x7ff)) {
      uVar6 = (ulong)dVar10 & 0xfffffffffffff;
      if (uVar5 == 0) {
        uVar5 = 0xc - (int)LZCOUNT(uVar6);
        uVar6 = uVar6 << ((ulong)((int)LZCOUNT(uVar6) - 0xb) & 0x3f) & 0xffefffffffffffff;
      }
      uVar1 = (int)(uVar5 + iVar3) >> 0x1f ^ 0x80000000;
      if (!SCARRY4(uVar5,iVar3)) {
        uVar1 = uVar5 + iVar3;
      }
      uVar7 = (ulong)dVar10 & 0x8000000000000000;
      if ((int)uVar1 < 0x7ff) {
        if ((int)uVar1 < 1) {
          if (uVar1 == 0xfffffc03 || (int)(uVar1 + 0x3fd) < 0 != SCARRY4(uVar1,0x3fd)) {
            uVar1 = 0xfffffc03;
          }
          dVar10 = (double)(uVar6 | uVar7 | 0x10000000000000) *
                   (double)((ulong)(uVar1 + 0x3fe) << 0x34);
        }
        else {
          dVar10 = (double)(uVar7 | (ulong)uVar1 << 0x34 | uVar6);
        }
      }
      else {
        dVar10 = (double)(uVar7 | 0x7fe0000000000000) + (double)(uVar7 | 0x7fe0000000000000);
      }
    }
  }
  else {
    iVar4 = 0;
  }
  dVar12 = (double)NEON_fmadd(dVar9,dVar9,dVar10 * dVar10);
  dVar11 = (double)NEON_fmadd(param_1,dVar9,dVar10 * param_2);
  dVar11 = dVar11 / dVar12;
  if ((dVar11 != 0.0) && (uVar5 = (uint)((ulong)dVar11 >> 0x34) & 0x7ff, uVar5 != 0x7ff)) {
    uVar7 = (ulong)dVar11 & 0xfffffffffffff;
    uVar6 = uVar7;
    if (uVar5 == 0) {
      uVar6 = uVar7 << ((ulong)((int)LZCOUNT(uVar7) - 0xb) & 0x3f) & 0xffefffffffffffff;
      uVar5 = 0xc - (int)LZCOUNT(uVar7);
    }
    uVar1 = uVar5 + -iVar4;
    uVar2 = (int)uVar1 >> 0x1f ^ 0x80000000;
    if (!SCARRY4(uVar5,-iVar4)) {
      uVar2 = uVar1;
    }
    uVar7 = (ulong)dVar11 & 0x8000000000000000;
    if (0x7fe < (int)uVar2) {
      dVar11 = (double)(uVar7 | 0x7fe0000000000000) + (double)(uVar7 | 0x7fe0000000000000);
      NEON_fmadd(param_2,dVar9,-(dVar10 * param_1));
      goto code_r0x000100003d0c;
    }
    if ((int)uVar2 < 1) {
      if (uVar2 == 0xfffffc03 || (int)(uVar2 + 0x3fd) < 0 != SCARRY4(uVar2,0x3fd)) {
        uVar2 = 0xfffffc03;
      }
      dVar11 = (double)(uVar6 | uVar7 | 0x10000000000000) * (double)((ulong)(uVar2 + 0x3fe) << 0x34)
      ;
      NEON_fmadd(param_2,dVar9,-(dVar10 * param_1));
      goto code_r0x000100003d0c;
    }
    dVar11 = (double)(uVar7 | (ulong)uVar2 << 0x34 | uVar6);
  }
  NEON_fmadd(param_2,dVar9,-(dVar10 * param_1));
code_r0x000100003d0c:
  auVar8._8_8_ = 0;
  auVar8._0_8_ = dVar11;
  return auVar8;
}



void ___muldc3(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____muldc3_100004008)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004010)();
  return;
}



void _atan2(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__atan2_100004020)();
  return;
}



void _cexp(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__cexp_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004030)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}


`
`#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

typedef uint32_t pint;
typedef uint64_t xint;
typedef unsigned int uint;
#define PRIuPINT PRIu32     /* printf macro for pint */
#define PRIuXINT PRIu64     /* printf macro for xint */
#define MAX_FACTORS 63      /* because 2^64 is too large for xint */

uint8_t *pbits;

#define MAX_PRIME (~(pint)0)
#define MAX_PRIME_SQ 65535U
#define PBITS (MAX_PRIME / 30 + 1)

pint next_prime(pint);
int is_prime(xint);
void sieve(pint);

uint8_t bit_pos[30] = {
    0, 1<<0, 0, 0, 0,    0,
    0, 1<<1, 0, 0, 0, 1<<2,
    0, 1<<3, 0, 0, 0, 1<<4,
    0, 1<<5, 0, 0, 0, 1<<6,
    0,    0, 0, 0, 0, 1<<7,
};

uint8_t rem_num[] = { 1, 7, 11, 13, 17, 19, 23, 29 };

void init_primes()
{
    FILE *fp;
    pint s, tgt = 4;

    if (!(pbits = malloc(PBITS))) {
        perror("malloc");
        exit(1);
    }

    if ((fp = fopen("primebits", "r"))) {
        fread(pbits, 1, PBITS, fp);
        fclose(fp);
        return;
    }

    memset(pbits, 255, PBITS);
    for (s = 7; s <= MAX_PRIME_SQ; s = next_prime(s)) {
        if (s > tgt) {
            tgt *= 2;
            fprintf(stderr, "sieve %"PRIuPINT"\n", s);
        }
        sieve(s);
    }
    fp = fopen("primebits", "w");
    fwrite(pbits, 1, PBITS, fp);
    fclose(fp);
}

int is_prime(xint x)
{
    pint p;
    if (x > 5) {
        if (x < MAX_PRIME)
            return pbits[x/30] & bit_pos[x % 30];

        for (p = 2; p && (xint)p * p <= x; p = next_prime(p))
            if (x % p == 0) return 0;

        return 1;
    }
    return x == 2 || x == 3 || x == 5;
}

void sieve(pint p)
{
    unsigned char b[8];
    off_t ofs[8];
    int i, q;

    for (i = 0; i < 8; i++) {
        q = rem_num[i] * p;
        b[i] = ~bit_pos[q % 30];
        ofs[i] = q / 30;
    }

    for (q = ofs[1], i = 7; i; i--)
        ofs[i] -= ofs[i-1];

    for (ofs[0] = p, i = 1; i < 8; i++)
        ofs[0] -= ofs[i];

    for (i = 1; q < PBITS; q += ofs[i = (i + 1) & 7])
        pbits[q] &= b[i];
}

pint next_prime(pint p)
{
    off_t addr;
    uint8_t bits, rem;

    if (p > 5) {
        addr = p / 30;
        bits = bit_pos[ p % 30 ] << 1;
        for (rem = 0; (1 << rem) < bits; rem++);
        while (pbits[addr] < bits || !bits) {
            if (++addr >= PBITS) return 0;
            bits = 1;
            rem = 0;
        }
        if (addr >= PBITS) return 0;
        while (!(pbits[addr] & bits)) {
            rem++;
            bits <<= 1;
        }
        return p = addr * 30 + rem_num[rem];
    }

    switch(p) {
        case 2: return 3;
        case 3: return 5;
        case 5: return 7;
    }
    return 2;
}

int decompose(xint n, xint *f)
{
    pint p = 0;
    int i = 0;

    /* check small primes: not strictly necessary */
    if (n <= MAX_PRIME && is_prime(n)) {
        f[0] = n;
        return 1;
    }

    while (n >= (xint)p * p) {
        if (!(p = next_prime(p))) break;
        while (n % p == 0) {
            n /= p;
            f[i++] = p;
        }
    }
    if (n > 1) f[i++] = n;
    return i;
}

int main()
{
    int i, len;
    pint p = 0;
    xint f[MAX_FACTORS], po;

    init_primes();

    for (p = 1; p < 64; p++) {
        po = (1LLU << p) - 1;
        printf("2^%"PRIuPINT" - 1 = %"PRIuXINT, p, po);
        fflush(stdout);
        if ((len = decompose(po, f)) > 1)
            for (i = 0; i < len; i++)
                printf(" %c %"PRIuXINT, i?'x':'=', f[i]);
        putchar('\n');
    }

    return 0;
}
`,`#include "prime-decomposition-1.h"



int _init_primes(void)

{
  int iVar1;
  FILE *pFVar2;
  uint local_20;
  uint local_1c;
  
  local_20 = 4;
  _pbits = _malloc(0x8888889);
  if (_pbits == (void *)0x0) {
    _perror("malloc");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  pFVar2 = _fopen("primebits","r");
  if (pFVar2 == (FILE *)0x0) {
    ___memset_chk(_pbits,0xff,0x8888889,0xffffffffffffffff);
    for (local_1c = 7; local_1c < 0x10000; local_1c = _next_prime(local_1c)) {
      if (local_20 < local_1c) {
        local_20 = local_20 << 1;
        _fprintf(*(FILE **)PTR____stderrp_100004018,"sieve %u\n");
      }
      _sieve(local_1c);
    }
    pFVar2 = _fopen("primebits","w");
    _fwrite(_pbits,1,0x8888889,pFVar2);
    iVar1 = _fclose(pFVar2);
  }
  else {
    _fread(_pbits,1,0x8888889,pFVar2);
    iVar1 = _fclose(pFVar2);
  }
  return iVar1;
}



void _sieve(uint param_1)

{
  byte bVar1;
  uint local_6c;
  uint local_68;
  ulong local_60 [8];
  byte abStack_20 [8];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  for (local_68 = 0; (int)local_68 < 8; local_68 = local_68 + 1) {
    bVar1 = (&_rem_num)[(int)local_68];
    abStack_20[(int)local_68] = ~(&_bit_pos)[(int)(bVar1 * param_1) % 0x1e];
    local_60[(int)local_68] = (long)((int)(bVar1 * param_1) / 0x1e);
  }
  local_6c = (uint)local_60[1];
  for (local_68 = 7; local_68 != 0; local_68 = local_68 + -1) {
    local_60[(int)local_68] = local_60[(int)local_68] - local_60[(int)(local_68 + -1)];
  }
  local_60[0] = (ulong)param_1;
  for (local_68 = 1; (int)local_68 < 8; local_68 = local_68 + 1) {
    local_60[0] = local_60[0] - local_60[(int)local_68];
  }
  local_68 = 1;
  for (; local_6c < 0x8888889; local_6c = local_6c + (int)local_60[(int)local_68]) {
    *(byte *)(_pbits + (int)local_6c) =
         *(byte *)(_pbits + (int)local_6c) & abStack_20[(int)local_68];
    local_68 = local_68 + 1 & 7;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return;
}



int _next_prime(uint param_1)

{
  byte local_12;
  byte local_11;
  ulong local_10;
  int local_4;
  
  if (param_1 < 6) {
    if (param_1 == 2) {
      local_4 = 3;
    }
    else if (param_1 == 3) {
      local_4 = 5;
    }
    else if (param_1 == 5) {
      local_4 = 7;
    }
    else {
      local_4 = 2;
    }
  }
  else {
    local_10 = (ulong)(param_1 / 0x1e);
    local_11 = (&_bit_pos)[param_1 % 0x1e] << 1;
    local_12 = 0;
    while (1 << (ulong)(local_12 & 0x1f) < (int)(uint)local_11) {
      local_12 = local_12 + 1;
    }
    while (*(byte *)(_pbits + local_10) < local_11 || local_11 == 0) {
      local_10 = local_10 + 1;
      if (0x8888888 < (long)local_10) {
        return 0;
      }
      local_12 = 0;
      local_11 = 1;
    }
    if ((long)local_10 < 0x8888889) {
      for (; (*(byte *)(_pbits + local_10) & local_11) == 0; local_11 = local_11 << 1) {
        local_12 = local_12 + 1;
      }
      local_4 = (int)local_10 * 0x1e + (uint)(byte)(&_rem_num)[local_12];
    }
    else {
      local_4 = 0;
    }
  }
  return local_4;
}



byte _is_prime(ulong param_1)

{
  bool bVar1;
  ulong uVar2;
  byte bVar3;
  ulong uVar4;
  uint local_24;
  
  if (param_1 < 6) {
    bVar3 = 1;
    if ((param_1 != 2) && (bVar3 = 1, param_1 != 3)) {
      bVar3 = param_1 == 5;
    }
  }
  else if (param_1 < 0xffffffff) {
    bVar3 = *(byte *)(_pbits + param_1 / 0x1e) & (&_bit_pos)[param_1 % 0x1e];
  }
  else {
    local_24 = 2;
    while( true ) {
      bVar1 = false;
      if (local_24 != 0) {
        bVar1 = (ulong)local_24 * (ulong)local_24 < param_1 ||
                (ulong)local_24 * (ulong)local_24 - param_1 == 0;
      }
      if (!bVar1) {
        return 1;
      }
      uVar4 = (ulong)local_24;
      uVar2 = 0;
      if (uVar4 != 0) {
        uVar2 = param_1 / uVar4;
      }
      if (param_1 == uVar2 * uVar4) break;
      local_24 = _next_prime(local_24);
    }
    bVar3 = 0;
  }
  return bVar3;
}



int _decompose(ulong param_1,ulong *param_2)

{
  ulong uVar1;
  int iVar2;
  ulong uVar3;
  long lVar4;
  int local_30;
  uint local_2c;
  ulong local_20;
  int local_14;
  
  local_2c = 0;
  local_30 = 0;
  local_20 = param_1;
  if ((param_1 < 0x100000000) && (iVar2 = _is_prime(param_1), iVar2 != 0)) {
    *param_2 = param_1;
    local_14 = 1;
  }
  else {
    while (((ulong)local_2c * (ulong)local_2c <= local_20 &&
           (local_2c = _next_prime(local_2c), local_2c != 0))) {
      while( true ) {
        uVar3 = (ulong)local_2c;
        uVar1 = 0;
        if (uVar3 != 0) {
          uVar1 = local_20 / uVar3;
        }
        if (local_20 != uVar1 * uVar3) break;
        uVar1 = 0;
        if ((ulong)local_2c != 0) {
          uVar1 = local_20 / local_2c;
        }
        lVar4 = (long)local_30;
        local_30 = local_30 + 1;
        param_2[lVar4] = (ulong)local_2c;
        local_20 = uVar1;
      }
    }
    if (1 < local_20) {
      lVar4 = (long)local_30;
      local_30 = local_30 + 1;
      param_2[lVar4] = local_20;
    }
    local_14 = local_30;
  }
  return local_14;
}



undefined8 entry(void)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  uint local_230;
  int local_228;
  undefined auStack_220 [504];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004010;
  uVar3 = _init_primes();
  for (local_230 = 1; local_230 < 0x40; local_230 = local_230 + 1) {
    _printf("2^%u - 1 = %llu");
    _fflush(*(FILE **)PTR____stdoutp_100004020);
    iVar1 = _decompose((1L << ((ulong)local_230 & 0x3f)) + -1,auStack_220);
    if (1 < iVar1) {
      for (local_228 = 0; local_228 < iVar1; local_228 = local_228 + 1) {
        _printf(" %c %llu");
      }
    }
    uVar2 = _putchar(10);
    uVar3 = (ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar3);
  }
  return 0;
}



void ___memset_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ecc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memset_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ee4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004028)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004040)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004048)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fread(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fread_100004050)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fwrite(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fwrite_100004058)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004060)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _perror(char *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__perror_100004068)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004070)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004078)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <termios.h>  /* general terminal interface: tcgetattr, tcsetattr, tcflush */
#include <unistd.h>   /* synchronous I/O multiplexing: select, FD_CLR, FD_ISSET, FD_SET, FD_ZERO */
#include <fcntl.h>

void set_mode(int want_key)
{
	static struct termios old, new;
	if (!want_key) {
		tcsetattr(STDIN_FILENO, TCSANOW, &old);
		return;
	}

	tcgetattr(STDIN_FILENO, &old);
	new = old;
	new.c_lflag &= ~(ICANON | ECHO);
	tcsetattr(STDIN_FILENO, TCSANOW, &new);
}

int get_key()
{
	int c = 0;
	struct timeval tv;
	fd_set fs;
	tv.tv_usec = tv.tv_sec = 0;

	FD_ZERO(&fs);
	FD_SET(STDIN_FILENO, &fs);
	select(STDIN_FILENO + 1, &fs, 0, 0, &tv);

	if (FD_ISSET(STDIN_FILENO, &fs)) {
		c = getchar();
		set_mode(0);
	}
	return c;
}

int main()
{
	int c;
	while(1) {
		set_mode(1);
                /* force C library buffers to be written to kernel buffers,
                   and flush pending input to avoid previously pressed keys */
                fflush(stdout);
		while (!(c = get_key())) usleep(10000);
		printf("key %d\n", c);
	}
}
`,`#include "keyboard-input-keypress-check.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _set_mode(int param_1)

{
  int iVar1;
  
  if (param_1 == 0) {
    iVar1 = _tcsetattr(0,0,(termios *)0x100008000);
  }
  else {
    _tcgetattr(0,(termios *)0x100008000);
    _memcpy((void *)0x100008048,(void *)0x100008000,0x48);
    _DAT_100008060 = _DAT_100008060 & 0xfffffffffffffef7;
    iVar1 = _tcsetattr(0,0,(termios *)0x100008048);
  }
  return iVar1;
}



int _get_key(void)

{
  bool bVar1;
  fd_set afStack_f8 [32];
  timeval local_78;
  int local_64;
  fd_set *local_60;
  int local_54;
  fd_set *local_50;
  int local_48;
  uint local_44;
  fd_set *local_40;
  undefined4 local_38;
  int local_34;
  fd_set *local_30;
  undefined4 local_28;
  int local_24;
  
  bVar1 = PTR____darwin_check_fd_set_overflow_100004000 == (undefined *)0x0;
  local_64 = 0;
  local_78.tv_sec = 0;
  local_78.tv_usec = 0;
  _memset(afStack_f8,0,0x80);
  local_54 = 0;
  local_28 = 0;
  local_60 = afStack_f8;
  local_30 = afStack_f8;
  if (bVar1) {
    local_24 = 1;
  }
  else {
    local_24 = ___darwin_check_fd_set_overflow(0,afStack_f8,0);
  }
  if (local_24 != 0) {
    *(uint *)(local_60 + (ulong)(long)local_54 / 0x20) =
         *(uint *)(local_60 + (ulong)(long)local_54 / 0x20) |
         (uint)(1L << (ulong)(long)local_54 % 0x20);
  }
  _select(1,afStack_f8,(fd_set *)0x0,(fd_set *)0x0,&local_78);
  local_48 = 0;
  local_38 = 0;
  local_50 = afStack_f8;
  local_40 = afStack_f8;
  if (bVar1) {
    local_34 = 1;
  }
  else {
    local_34 = ___darwin_check_fd_set_overflow(0,afStack_f8,0);
  }
  if (local_34 == 0) {
    local_44 = 0;
  }
  else {
    local_44 = *(uint *)(local_50 + (ulong)(long)local_48 / 0x20) &
               (uint)(1L << (ulong)(long)local_48 % 0x20);
  }
  if (local_44 != 0) {
    local_64 = _getchar();
    _set_mode(0);
  }
  return local_64;
}



void entry(void)

{
  int iVar1;
  
  do {
    _set_mode(1);
    iVar1 = _fflush(*(FILE **)PTR____stdoutp_100004008);
    while( true ) {
      iVar1 = _get_key(iVar1);
      if (iVar1 != 0) break;
      iVar1 = _usleep(10000);
    }
    _printf("key %d\n");
  } while( true );
}



void ___darwin_check_fd_set_overflow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____darwin_check_fd_set_overflow_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fflush(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fflush_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004018)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004028)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _select(int param_1,fd_set *param_2,fd_set *param_3,fd_set *param_4,timeval *param_5)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__select_100004038)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tcgetattr(int param_1,termios *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tcgetattr_100004040)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _tcsetattr(int param_1,int param_2,termios *param_3)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__tcsetattr_100004048)(param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _usleep(useconds_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__usleep_100004050)(param_1);
  return iVar1;
}


`
`#include <stdio.h>

#define WIDTH 81
#define HEIGHT 5

char lines[HEIGHT][WIDTH];

void init() {
    int i, j;
    for (i = 0; i < HEIGHT; ++i) {
        for (j = 0; j < WIDTH; ++j) lines[i][j] = '*';
    }
}

void cantor(int start, int len, int index) {
    int i, j, seg = len / 3;
    if (seg == 0) return;
    for (i = index; i < HEIGHT; ++i) {
        for (j = start + seg; j < start + seg * 2; ++j) lines[i][j] = ' ';
    }
    cantor(start, seg, index + 1);
    cantor(start + seg * 2, seg, index + 1);
}

void print() {
    int i, j;
    for (i = 0; i < HEIGHT; ++i) {
        for (j = 0; j < WIDTH; ++j) printf("%c", lines[i][j]);
        printf("\n");
    }
}

int main() {
    init();
    cantor(0, WIDTH, 1);
    print();
    return 0;
}
`,`#include "cantor-set.h"



void _init(void)

{
  int local_8;
  int local_4;
  
  for (local_4 = 0; local_4 < 5; local_4 = local_4 + 1) {
    for (local_8 = 0; local_8 < 0x51; local_8 = local_8 + 1) {
      (&_lines)[(long)local_8 + (long)local_4 * 0x51] = 0x2a;
    }
  }
  return;
}



void _cantor(int param_1,int param_2,int param_3)

{
  int local_24;
  int local_20;
  
  param_2 = param_2 / 3;
  local_20 = param_3;
  if (param_2 != 0) {
    for (; local_20 < 5; local_20 = local_20 + 1) {
      for (local_24 = param_1 + param_2; local_24 < param_1 + param_2 * 2; local_24 = local_24 + 1)
      {
        (&_lines)[(long)local_24 + (long)local_20 * 0x51] = 0x20;
      }
    }
    _cantor(param_1,param_2,param_3 + 1);
    _cantor(param_1 + param_2 * 2,param_2,param_3 + 1);
  }
  return;
}



ulong _print(ulong param_1)

{
  uint uVar1;
  int local_18;
  int local_14;
  
  for (local_14 = 0; local_14 < 5; local_14 = local_14 + 1) {
    for (local_18 = 0; local_18 < 0x51; local_18 = local_18 + 1) {
      _printf("%c");
    }
    uVar1 = _printf("\n");
    param_1 = (ulong)uVar1;
  }
  return param_1;
}



undefined4 entry(void)

{
  _init();
  _cantor(0,0x51,1);
  _print();
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <err.h>

int main()
{
	pid_t pid;

	if (!(pid = fork())) {
		usleep(10000);
		printf("\tchild process: done\n");
	} else if (pid < 0) {
		err(1, "fork error");
	} else {
		printf("waiting for child %d...\n", (int)pid);
		printf("child %d finished\n", (int)wait(0));
	}

	return 0;
}
`,`#include "fork-1.h"



undefined8 entry(void)

{
  pid_t pVar1;
  
  pVar1 = _fork();
  if (pVar1 == 0) {
    _usleep(10000);
    _printf("\tchild process: done\n");
  }
  else {
    if (pVar1 < 0) {
      _err(1,"fork error");
    }
    _printf("waiting for child %d...\n");
    _wait((int *)0x0);
    _printf("child %d finished\n");
  }
  return 0;
}



void _err(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__err_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

pid_t _fork(void)

{
  pid_t pVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  pVar1 = (*(code *)PTR__fork_100004008)();
  return pVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _usleep(useconds_t param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__usleep_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

pid_t _wait(int *param_1)

{
  pid_t pVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  pVar1 = (*(code *)PTR__wait_100004020)((int)param_1);
  return pVar1;
}


`
`#include <stdio.h>

int pangram(const char *s)
{
	int c, mask = (1 << 26) - 1;
	while ((c = (*s++)) != '\0') /* 0x20 converts lowercase to upper */
		if ((c &= ~0x20) <= 'Z' && c >= 'A')
			mask &= ~(1 << (c - 'A'));

	return !mask;
}

int main()
{
	int i;
	const char *s[] = {	"The quick brown fox jumps over lazy dogs.",
				"The five boxing wizards dump quickly.",  };

	for (i = 0; i < 2; i++)
		printf("%s: %s\n", pangram(s[i]) ? "yes" : "no ", s[i]);

	return 0;
}
`,`#include "pangram-checker-2.h"



bool _pangram(char *param_1)

{
  char *pcVar1;
  uint uVar2;
  uint local_10;
  char *local_8;
  
  local_10 = 0x3ffffff;
  local_8 = param_1;
  while( true ) {
    pcVar1 = local_8 + 1;
    if ((int)*local_8 == 0) break;
    uVar2 = (int)*local_8 & 0xffffffdf;
    local_8 = pcVar1;
    if (((int)uVar2 < 0x5b) && (0x40 < (int)uVar2)) {
      local_10 = local_10 & (1 << (ulong)(uVar2 - 0x41 & 0x1f) ^ 0xffffffffU);
    }
  }
  return local_10 == 0;
}



undefined8 entry(ulong param_1)

{
  uint uVar1;
  int local_38;
  char *local_30 [3];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_30[1] = "The five boxing wizards dump quickly.";
  local_30[0] = "The quick brown fox jumps over lazy dogs.";
  for (local_38 = 0; local_38 < 2; local_38 = local_38 + 1) {
    _pangram(local_30[local_38]);
    uVar1 = _printf("%s: %s\n");
    param_1 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

void swap(char* p1, char* p2, size_t size) {
    for (; size-- > 0; ++p1, ++p2) {
        char tmp = *p1;
        *p1 = *p2;
        *p2 = tmp;
    }
}

void cocktail_shaker_sort(void* base, size_t count, size_t size,
                          int (*cmp)(const void*, const void*)) {
    char* begin = base;
    char* end = base + size * count;
    if (end == begin)
        return;
    for (end -= size; begin < end; ) {
        char* new_begin = end;
        char* new_end = begin;
        for (char* p = begin; p < end; p += size) {
            char* q = p + size;
            if (cmp(p, q) > 0) {
                swap(p, q, size);
                new_end = p;
            }
        }
        end = new_end;
        for (char* p = end; p > begin; p -= size) {
            char* q = p - size;
            if (cmp(q, p) > 0) {
                swap(p, q, size);
                new_begin = p;
            }
        }
        begin = new_begin;
    }
}

int string_compare(const void* p1, const void* p2) {
    const char* const* s1 = p1;
    const char* const* s2 = p2;
    return strcmp(*s1, *s2);
}

void print(const char** a, size_t len) {
    for (size_t i = 0; i < len; ++i)
        printf("%s ", a[i]);
    printf("\n");
}

int main() {
    const char* a[] = { "one", "two", "three", "four", "five",
        "six", "seven", "eight" };
    const size_t len = sizeof(a)/sizeof(a[0]);
    printf("before: ");
    print(a, len);
    cocktail_shaker_sort(a, len, sizeof(char*), string_compare);
    printf("after: ");
    print(a, len);
    return 0;
}
`,`#include "sorting-algorithms-cocktail-sort-with-shifting-bounds.h"



void _swap(undefined *param_1,undefined *param_2,long param_3)

{
  undefined uVar1;
  long local_18;
  undefined *local_10;
  undefined *local_8;
  
  local_18 = param_3;
  local_10 = param_2;
  local_8 = param_1;
  while (local_18 != 0) {
    uVar1 = *local_8;
    *local_8 = *local_10;
    *local_10 = uVar1;
    local_8 = local_8 + 1;
    local_10 = local_10 + 1;
    local_18 = local_18 + -1;
  }
  return;
}



void _cocktail_shaker_sort(ulong param_1,long param_2,long param_3,code *param_4)

{
  int iVar1;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_50;
  undefined8 local_48;
  undefined8 local_40;
  undefined8 local_38;
  
  local_40 = param_1 + param_3 * param_2;
  if (local_40 != param_1) {
    local_40 = local_40 - param_3;
    local_38 = param_1;
    while (local_38 < local_40) {
      local_48 = local_40;
      local_50 = local_38;
      for (local_58 = local_38; local_58 < local_40; local_58 = local_58 + param_3) {
        iVar1 = (*param_4)(local_58,local_58 + param_3);
        if (0 < iVar1) {
          _swap(local_58,local_58 + param_3,param_3);
          local_50 = local_58;
        }
      }
      local_40 = local_50;
      for (local_68 = local_50; local_38 < local_68; local_68 = local_68 - param_3) {
        iVar1 = (*param_4)(local_68 - param_3,local_68);
        if (0 < iVar1) {
          _swap(local_68,local_68 - param_3,param_3);
          local_48 = local_68;
        }
      }
      local_38 = local_48;
    }
  }
  return;
}



int _string_compare(undefined8 *param_1,undefined8 *param_2)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)*param_1,(char *)*param_2);
  return iVar1;
}



int _print(undefined8 param_1,ulong param_2)

{
  int iVar1;
  ulong local_28;
  
  for (local_28 = 0; local_28 < param_2; local_28 = local_28 + 1) {
    _printf("%s ");
  }
  iVar1 = _printf("\n");
  return iVar1;
}



undefined8 entry(void)

{
  undefined auStack_58 [64];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_58,&PTR_s_one_100004028,0x40);
  _printf("before: ");
  _print(auStack_58,8);
  _cocktail_shaker_sort(auStack_58,8,8,_string_compare);
  _printf("after: ");
  _print(auStack_58,8);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

// ad hoc 128 bit integer type; faster than using GMP because of low
// overhead
typedef struct { uint64_t x[2]; } i128;

// display in decimal
void show(i128 v) {
	uint32_t x[4] = {v.x[0], v.x[0] >> 32, v.x[1], v.x[1] >> 32};
	int i, j = 0, len = 4;
	char buf[100];
	do {
		uint64_t c = 0;
		for (i = len; i--; ) {
			c = (c << 32) + x[i];
			x[i] = c / 10, c %= 10;
		}

		buf[j++] = c + '0';
		for (len = 4; !x[len - 1]; len--);
	} while (len);

	while (j--) putchar(buf[j]);
	putchar('\n');
}

i128 count(int sum, int *coins)
{
	int n, i, k;
	for (n = 0; coins[n]; n++);

	i128 **v = malloc(sizeof(int*) * n);
	int *idx = malloc(sizeof(int) * n);

	for (i = 0; i < n; i++) {
		idx[i] = coins[i];
		// each v[i] is a cyclic buffer
		v[i] = calloc(sizeof(i128), coins[i]);
	}

	v[0][coins[0] - 1] = (i128) {{1, 0}};

	for (k = 0; k <= sum; k++) {
		for (i = 0; i < n; i++)
			if (!idx[i]--) idx[i] = coins[i] - 1;

		i128 c = v[0][ idx[0] ];

		for (i = 1; i < n; i++) {
			i128 *p = v[i] + idx[i];

			// 128 bit addition
			p->x[0] += c.x[0];
			p->x[1] += c.x[1];
			if (p->x[0] < c.x[0]) // carry
				p->x[1] ++;
			c = *p;
		}
	}

	i128 r = v[n - 1][idx[n-1]];

	for (i = 0; i < n; i++) free(v[i]);
	free(v);
	free(idx);

	return r;
}

// simple recursive method; slow
int count2(int sum, int *coins)
{
	if (!*coins || sum < 0) return 0;
	if (!sum) return 1;
	return count2(sum - *coins, coins) + count2(sum, coins + 1);
}

int main(void)
{
	int us_coins[] = { 100, 50, 25, 10, 5, 1, 0 };
	int eu_coins[] = { 200, 100, 50, 20, 10, 5, 2, 1, 0 };

	show(count(   100, us_coins + 2));
	show(count(  1000, us_coins));

	show(count(  1000 * 100, us_coins));
	show(count( 10000 * 100, us_coins));
	show(count(100000 * 100, us_coins));

	putchar('\n');

	show(count(     1 * 100, eu_coins));
	show(count(  1000 * 100, eu_coins));
	show(count( 10000 * 100, eu_coins));
	show(count(100000 * 100, eu_coins));

	return 0;
}
`,`#include "count-the-coins-1.h"



void _show(undefined8 param_1,undefined8 param_2)

{
  int iVar1;
  long lVar2;
  ulong local_b8;
  int local_ac;
  int local_a8;
  int local_a4;
  char acStack_8c [100];
  uint local_28 [4];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_28[0] = (uint)param_1;
  local_28[1] = (int)((ulong)param_1 >> 0x20);
  local_28[2] = (int)param_2;
  local_28[3] = (int)((ulong)param_2 >> 0x20);
  local_a8 = 0;
  local_ac = 4;
  do {
    local_b8 = 0;
    local_a4 = local_ac;
    while (iVar1 = local_a4 + -1, local_a4 != 0) {
      local_b8 = (ulong)local_28[iVar1] + (local_b8 << 0x20);
      local_28[iVar1] = (uint)(local_b8 / 10);
      local_b8 = local_b8 % 10;
      local_a4 = iVar1;
    }
    lVar2 = (long)local_a8;
    local_a8 = local_a8 + 1;
    acStack_8c[lVar2] = (char)local_b8 + '0';
    local_ac = 4;
    while (local_28[local_ac + -1] == 0) {
      local_ac = local_ac + -1;
    }
  } while (local_ac != 0);
  while (local_a8 != 0) {
    _putchar((int)acStack_8c[local_a8 + -1]);
    local_a8 = local_a8 + -1;
  }
  iVar1 = _putchar(10);
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar1);
}



undefined  [16] _count(int param_1,int *param_2)

{
  int iVar1;
  ulong *puVar2;
  undefined8 *puVar3;
  undefined auVar4 [16];
  long *plVar5;
  int *piVar6;
  void *pvVar7;
  ulong local_70;
  ulong uStack_68;
  int local_3c;
  int local_38;
  int local_34;
  
  for (local_34 = 0; param_2[local_34] != 0; local_34 = local_34 + 1) {
  }
  plVar5 = (long *)_malloc((long)local_34 * 8);
  piVar6 = (int *)_malloc((long)local_34 * 4);
  for (local_38 = 0; local_38 < local_34; local_38 = local_38 + 1) {
    piVar6[local_38] = param_2[local_38];
    pvVar7 = _calloc(0x10,(long)param_2[local_38]);
    plVar5[local_38] = (long)pvVar7;
  }
  puVar3 = (undefined8 *)(*plVar5 + (long)(*param_2 + -1) * 0x10);
  puVar3[1] = 0;
  *puVar3 = 1;
  for (local_3c = 0; local_3c <= param_1; local_3c = local_3c + 1) {
    for (local_38 = 0; local_38 < local_34; local_38 = local_38 + 1) {
      iVar1 = piVar6[local_38];
      piVar6[local_38] = iVar1 + -1;
      if (iVar1 == 0) {
        piVar6[local_38] = param_2[local_38] + -1;
      }
    }
    puVar2 = (ulong *)(*plVar5 + (long)*piVar6 * 0x10);
    uStack_68 = puVar2[1];
    local_70 = *puVar2;
    for (local_38 = 1; local_38 < local_34; local_38 = local_38 + 1) {
      puVar2 = (ulong *)(plVar5[local_38] + (long)piVar6[local_38] * 0x10);
      *puVar2 = *puVar2 + local_70;
      puVar2[1] = puVar2[1] + uStack_68;
      if (*puVar2 < local_70) {
        puVar2[1] = puVar2[1] + 1;
      }
      uStack_68 = puVar2[1];
      local_70 = *puVar2;
    }
  }
  auVar4 = *(undefined (*) [16])(plVar5[local_34 + -1] + (long)piVar6[local_34 + -1] * 0x10);
  for (local_38 = 0; local_38 < local_34; local_38 = local_38 + 1) {
    _free((void *)plVar5[local_38]);
  }
  _free(plVar5);
  _free(piVar6);
  return auVar4;
}



int _count2(int param_1,int *param_2)

{
  int iVar1;
  int local_14;
  
  if ((*param_2 == 0) || (param_1 < 0)) {
    local_14 = 0;
  }
  else if (param_1 == 0) {
    local_14 = 1;
  }
  else {
    local_14 = _count2(param_1 - *param_2,param_2);
    iVar1 = _count2(param_1,param_2 + 1);
    local_14 = local_14 + iVar1;
  }
  return local_14;
}



undefined8 entry(void)

{
  undefined auVar1 [16];
  undefined auStack_74 [36];
  undefined8 local_50;
  undefined4 uStack_48;
  undefined4 uStack_44;
  undefined4 uStack_40;
  undefined8 uStack_3c;
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_48 = 0x19;
  local_50 = 0x3200000064;
  uStack_3c = 1;
  uStack_44 = 10;
  uStack_40 = 5;
  _memcpy(auStack_74,&DAT_100003f7c,0x24);
  auVar1 = _count(100,&uStack_48);
  _show(auVar1._0_8_,auVar1._8_8_);
  auVar1 = _count(1000,&local_50);
  _show(auVar1._0_8_,auVar1._8_8_);
  auVar1 = _count(100000,&local_50);
  _show(auVar1._0_8_,auVar1._8_8_);
  auVar1 = _count(1000000,&local_50);
  _show(auVar1._0_8_,auVar1._8_8_);
  auVar1 = _count(10000000,&local_50);
  _show(auVar1._0_8_,auVar1._8_8_);
  _putchar(10);
  auVar1 = _count(100,auStack_74);
  _show(auVar1._0_8_,auVar1._8_8_);
  auVar1 = _count(100000,auStack_74);
  _show(auVar1._0_8_,auVar1._8_8_);
  auVar1 = _count(1000000,auStack_74);
  _show(auVar1._0_8_,auVar1._8_8_);
  auVar1 = _count(10000000,auStack_74);
  _show(auVar1._0_8_,auVar1._8_8_);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f38. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004030)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/mman.h>

typedef int (*f_int)();

#define TAG 0xdeadbeef
int _tmpl() {
	volatile int x = TAG;
	return x * x;
}

#define PROT (PROT_EXEC | PROT_WRITE)
#define FLAGS (MAP_PRIVATE | MAP_ANONYMOUS)
f_int dupf(int v)
{
	size_t len = (void*)dupf - (void*)_tmpl;
	f_int ret = mmap(NULL, len, PROT, FLAGS, 0, 0);
	char *p;
	if(ret == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}
	memcpy(ret, _tmpl, len);
	for (p = (char*)ret; p < (char*)ret + len - sizeof(int); p++)
		if (*(int *)p == TAG) *(int *)p = v;
	return ret;
}

int main()
{
	f_int funcs[10];
	int i;
	for (i = 0; i < 10; i++) funcs[i] = dupf(i);

	for (i = 0; i < 9; i++)
		printf("func[%d]: %d\n", i, funcs[i]());

	return 0;
}
`,`#include "closures-value-capture-1.h"



undefined4 __tmpl(void)

{
  return 0x216da321;
}



int * _dupf(int param_1)

{
  int *piVar1;
  int *local_30;
  
  piVar1 = (int *)_mmap(0,0x24,6,0x1002,0,0);
  if (piVar1 == (int *)0xffffffffffffffff) {
    _perror("mmap");
                    // WARNING: Subroutine does not return
    _exit(-1);
  }
  ___memcpy_chk(piVar1,__tmpl,0x24,0xffffffffffffffff);
  for (local_30 = piVar1; local_30 < piVar1 + 8; local_30 = (int *)((long)local_30 + 1)) {
    if (*local_30 == -0x21524111) {
      *local_30 = param_1;
    }
  }
  return piVar1;
}



undefined8 entry(ulong param_1)

{
  uint uVar1;
  int local_70;
  ulong auStack_68 [10];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  for (local_70 = 0; local_70 < 10; local_70 = local_70 + 1) {
    param_1 = _dupf(local_70);
    auStack_68[local_70] = param_1;
  }
  for (local_70 = 0; local_70 < 9; local_70 = local_70 + 1) {
    (*(code *)auStack_68[local_70])();
    uVar1 = _printf("func[%d]: %d\n");
    param_1 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004018)(param_1);
  return;
}



void _mmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__mmap_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _perror(char *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__perror_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004030)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>

void
subleq(int *code)
{
	int ip = 0, a, b, c, nextIP;
	char ch;
	while(0 <= ip) {
		nextIP = ip + 3;
		a = code[ip];
		b = code[ip + 1];
		c = code[ip + 2];
		if(a == -1) {
			scanf("%c", &ch);
			code[b] = (int)ch;
		} else if(b == -1) {
			printf("%c", (char)code[a]);
		} else {
			code[b] -= code[a];
			if(code[b] <= 0)
				nextIP = c;
		}
		ip = nextIP;
	}
}

void
processFile(char *fileName)
{
	int *dataSet, i, num;
	FILE *fp = fopen(fileName, "r");
	fscanf(fp, "%d", &num);
	dataSet = (int *)malloc(num * sizeof(int));
	for(i = 0; i < num; i++)
		fscanf(fp, "%d", &dataSet[i]);
	fclose(fp);
	subleq(dataSet);
}

int
main(int argC, char *argV[])
{
	if(argC != 2)
		printf("Usage : %s <subleq code file>\n", argV[0]);
	else
		processFile(argV[1]);
	return 0;
}
`,`#include "subleq.h"



ulong _subleq(ulong param_1)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  char local_2d;
  int local_2c;
  int local_1c;
  ulong uVar6;
  
  local_1c = 0;
  uVar6 = param_1;
  while (-1 < local_1c) {
    local_2c = local_1c + 3;
    iVar2 = *(int *)(param_1 + (long)local_1c * 4);
    iVar3 = *(int *)(param_1 + (long)(local_1c + 1) * 4);
    iVar4 = *(int *)(param_1 + (long)(local_1c + 2) * 4);
    if (iVar2 == -1) {
      uVar5 = _scanf("%c");
      uVar6 = (ulong)uVar5;
      *(int *)(param_1 + (long)iVar3 * 4) = (int)local_2d;
    }
    else if (iVar3 == -1) {
      uVar5 = _printf("%c");
      uVar6 = (ulong)uVar5;
    }
    else {
      piVar1 = (int *)(param_1 + (long)iVar3 * 4);
      *piVar1 = *piVar1 - *(int *)(param_1 + (long)iVar2 * 4);
      if (*(int *)(param_1 + (long)iVar3 * 4) < 1) {
        local_2c = iVar4;
      }
    }
    local_1c = local_2c;
  }
  return uVar6;
}



void _processFile(char *param_1)

{
  FILE *pFVar1;
  void *pvVar2;
  int local_28;
  int local_24;
  
  pFVar1 = _fopen(param_1,"r");
  _fscanf(pFVar1,"%d");
  pvVar2 = _malloc((long)local_28 << 2);
  for (local_24 = 0; local_24 < local_28; local_24 = local_24 + 1) {
    _fscanf(pFVar1,"%d");
  }
  _fclose(pFVar1);
  _subleq(pvVar2);
  return;
}



undefined8 entry(int param_1,long param_2)

{
  if (param_1 == 2) {
    _processFile(*(undefined8 *)(param_2 + 8));
  }
  else {
    _printf("Usage : %s <subleq code file>\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004008)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fscanf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fscanf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004028)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int* mertens_numbers(int max) {
    int* m = malloc((max + 1) * sizeof(int));
    if (m == NULL)
        return m;
    m[1] = 1;
    for (int n = 2; n <= max; ++n) {
        m[n] = 1;
        for (int k = 2; k <= n; ++k)
            m[n] -= m[n/k];
    }
    return m;
}

int main() {
    const int max = 1000;
    int* mertens = mertens_numbers(max);
    if (mertens == NULL) {
        fprintf(stderr, "Out of memory\n");
        return 1;
    }
    printf("First 199 Mertens numbers:\n");
    const int count = 200;
    for (int i = 0, column = 0; i < count; ++i) {
        if (column > 0)
            printf(" ");
        if (i == 0)
            printf("  ");
        else
            printf("%2d", mertens[i]);
        ++column;
        if (column == 20) {
            printf("\n");
            column = 0;
        }
    }
    int zero = 0, cross = 0, previous = 0;
    for (int i = 1; i <= max; ++i) {
        int m = mertens[i];
        if (m == 0) {
            ++zero;
            if (previous != 0)
                ++cross;
        }
        previous = m;
    }
    free(mertens);
    printf("M(n) is zero %d times for 1 <= n <= %d.\n", zero, max);
    printf("M(n) crosses zero %d times for 1 <= n <= %d.\n", cross, max);
    return 0;
}
`,`#include "mertens-function.h"



void * _mertens_numbers(int param_1)

{
  int *piVar1;
  int iVar2;
  void *pvVar3;
  undefined4 local_30;
  undefined4 local_2c;
  
  pvVar3 = _malloc((long)(param_1 + 1) << 2);
  if (pvVar3 != (void *)0x0) {
    *(undefined4 *)((long)pvVar3 + 4) = 1;
    for (local_2c = 2; local_2c <= param_1; local_2c = local_2c + 1) {
      *(undefined4 *)((long)pvVar3 + (long)local_2c * 4) = 1;
      for (local_30 = 2; local_30 <= local_2c; local_30 = local_30 + 1) {
        iVar2 = 0;
        if (local_30 != 0) {
          iVar2 = local_2c / local_30;
        }
        piVar1 = (int *)((long)pvVar3 + (long)local_2c * 4);
        *piVar1 = *piVar1 - *(int *)((long)pvVar3 + (long)iVar2 * 4);
      }
    }
  }
  return pvVar3;
}



undefined4 entry(void)

{
  void *pvVar1;
  int local_3c;
  int local_2c;
  int local_28;
  undefined4 local_14;
  
  pvVar1 = (void *)_mertens_numbers();
  if (pvVar1 == (void *)0x0) {
    _fprintf(*(FILE **)PTR____stderrp_100004000,"Out of memory\n");
    local_14 = 1;
  }
  else {
    _printf("First 199 Mertens numbers:\n");
    local_2c = 0;
    for (local_28 = 0; local_28 < 200; local_28 = local_28 + 1) {
      if (0 < local_2c) {
        _printf(" ");
      }
      if (local_28 == 0) {
        _printf("  ");
      }
      else {
        _printf("%2d");
      }
      local_2c = local_2c + 1;
      if (local_2c == 0x14) {
        _printf("\n");
        local_2c = 0;
      }
    }
    for (local_3c = 1; local_3c < 0x3e9; local_3c = local_3c + 1) {
    }
    _free(pvVar1);
    _printf("M(n) is zero %d times for 1 <= n <= %d.\n");
    _printf("M(n) crosses zero %d times for 1 <= n <= %d.\n");
    local_14 = 0;
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

typedef struct node_t {
	struct node_t *left, *right;
	int freq;
	char c;
} *node;

struct node_t pool[256] = {{0}};
node qqq[255], *q = qqq - 1;
int n_nodes = 0, qend = 1;
char *code[128] = {0}, buf[1024];

node new_node(int freq, char c, node a, node b)
{
	node n = pool + n_nodes++;
	if (freq) n->c = c, n->freq = freq;
	else {
		n->left = a, n->right = b;
		n->freq = a->freq + b->freq;
	}
	return n;
}

/* priority queue */
void qinsert(node n)
{
	int j, i = qend++;
	while ((j = i / 2)) {
		if (q[j]->freq <= n->freq) break;
		q[i] = q[j], i = j;
	}
	q[i] = n;
}

node qremove()
{
	int i, l;
	node n = q[i = 1];

	if (qend < 2) return 0;
	qend--;
	while ((l = i * 2) < qend) {
		if (l + 1 < qend && q[l + 1]->freq < q[l]->freq) l++;
		q[i] = q[l], i = l;
	}
	q[i] = q[qend];
	return n;
}

/* walk the tree and put 0s and 1s */
void build_code(node n, char *s, int len)
{
	static char *out = buf;
	if (n->c) {
		s[len] = 0;
		strcpy(out, s);
		code[n->c] = out;
		out += len + 1;
		return;
	}

	s[len] = '0'; build_code(n->left,  s, len + 1);
	s[len] = '1'; build_code(n->right, s, len + 1);
}

void init(const char *s)
{
	int i, freq[128] = {0};
	char c[16];

	while (*s) freq[(int)*s++]++;

	for (i = 0; i < 128; i++)
		if (freq[i]) qinsert(new_node(freq[i], i, 0, 0));

	while (qend > 2)
		qinsert(new_node(0, 0, qremove(), qremove()));

	build_code(q[1], c, 0);
}

void encode(const char *s, char *out)
{
	while (*s) {
		strcpy(out, code[*s]);
		out += strlen(code[*s++]);
	}
}

void decode(const char *s, node t)
{
	node n = t;
	while (*s) {
		if (*s++ == '0') n = n->left;
		else n = n->right;

		if (n->c) putchar(n->c), n = t;
	}

	putchar('\n');
	if (t != n) printf("garbage input\n");
}

int main(void)
{
	int i;
	const char *str = "this is an example for huffman encoding";
        char buf[1024];

	init(str);
	for (i = 0; i < 128; i++)
		if (code[i]) printf("'%c': %s\n", i, code[i]);

	encode(str, buf);
	printf("encoded: %s\n", buf);

	printf("decoded: ");
	decode(buf, q[1]);

	return 0;
}
`,`#include "huffman-coding-2.h"



long * _new_node(int param_1,undefined param_2,long param_3,long param_4)

{
  long lVar1;
  
  lVar1 = (long)_n_nodes;
  _n_nodes = _n_nodes + 1;
  lVar1 = lVar1 * 0x18;
  if (param_1 == 0) {
    *(long *)(&_pool + lVar1) = param_3;
    *(long *)(&DAT_100008020 + lVar1) = param_4;
    *(int *)(&DAT_100008028 + lVar1) = *(int *)(param_3 + 0x10) + *(int *)(param_4 + 0x10);
  }
  else {
    (&DAT_10000802c)[lVar1] = param_2;
    *(int *)(&DAT_100008028 + lVar1) = param_1;
  }
  return (long *)(&_pool + lVar1);
}



void _qinsert(long param_1)

{
  int iVar1;
  int local_10;
  
  local_10 = _qend;
  _qend = _qend + 1;
  while ((iVar1 = local_10 / 2, iVar1 != 0 &&
         (*(int *)(param_1 + 0x10) < *(int *)(*(long *)(_q + (long)iVar1 * 8) + 0x10)))) {
    *(undefined8 *)(_q + (long)local_10 * 8) = *(undefined8 *)(_q + (long)iVar1 * 8);
    local_10 = iVar1;
  }
  *(long *)(_q + (long)local_10 * 8) = param_1;
  return;
}



undefined8 _qremove(void)

{
  int local_10;
  int local_c;
  undefined8 local_8;
  
  local_c = 1;
  local_8 = *(undefined8 *)(_q + 8);
  if (_qend < 2) {
    local_8 = 0;
  }
  else {
    _qend = _qend + -1;
    while (local_10 = local_c * 2, local_10 < _qend) {
      if ((local_10 + 1 < _qend) &&
         (*(int *)(*(long *)(_q + (long)(local_10 + 1) * 8) + 0x10) <
          *(int *)(*(long *)(_q + (long)local_10 * 8) + 0x10))) {
        local_10 = local_10 + 1;
      }
      *(undefined8 *)(_q + (long)local_c * 8) = *(undefined8 *)(_q + (long)local_10 * 8);
      local_c = local_10;
    }
    *(undefined8 *)(_q + (long)local_c * 8) = *(undefined8 *)(_q + (long)_qend * 8);
  }
  return local_8;
}



void _build_code(undefined8 *param_1,long param_2,int param_3)

{
  if (*(char *)((long)param_1 + 0x14) == '\0') {
    *(undefined *)(param_2 + param_3) = 0x30;
    _build_code(*param_1,param_2,param_3 + 1);
    *(undefined *)(param_2 + param_3) = 0x31;
    _build_code(param_1[1],param_2,param_3 + 1);
  }
  else {
    *(undefined *)(param_2 + param_3) = 0;
    ___strcpy_chk(PTR__buf_100008010,param_2,0xffffffffffffffff);
    *(undefined **)(&_code + (long)*(char *)((long)param_1 + 0x14) * 8) = PTR__buf_100008010;
    PTR__buf_100008010 = PTR__buf_100008010 + (param_3 + 1);
  }
  return;
}



void _init(char *param_1)

{
  undefined8 uVar1;
  undefined8 uVar2;
  int local_244;
  char *local_240;
  undefined auStack_238 [16];
  int aiStack_228 [128];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _bzero(aiStack_228,0x200);
  local_240 = param_1;
  while (*local_240 != '\0') {
    aiStack_228[*local_240] = aiStack_228[*local_240] + 1;
    local_240 = local_240 + 1;
  }
  for (local_244 = 0; local_244 < 0x80; local_244 = local_244 + 1) {
    if (aiStack_228[local_244] != 0) {
      _new_node(aiStack_228[local_244],(int)(char)local_244,0);
      _qinsert();
    }
  }
  while (2 < _qend) {
    uVar1 = _qremove();
    uVar2 = _qremove();
    _new_node(0,0,uVar1,uVar2);
    _qinsert();
  }
  _build_code(*(undefined8 *)(_q + 8),auStack_238,0);
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



void _encode(char *param_1,long param_2)

{
  size_t sVar1;
  long local_20;
  char *local_18;
  
  local_20 = param_2;
  local_18 = param_1;
  while (*local_18 != '\0') {
    ___strcpy_chk(local_20,*(undefined8 *)(&_code + (long)*local_18 * 8),0xffffffffffffffff);
    sVar1 = _strlen(*(char **)(&_code + (long)*local_18 * 8));
    local_20 = local_20 + sVar1;
    local_18 = local_18 + 1;
  }
  return;
}



int _decode(char *param_1,undefined8 *param_2)

{
  char *pcVar1;
  int iVar2;
  undefined8 *local_28;
  char *local_18;
  
  local_28 = param_2;
  local_18 = param_1;
  while (*local_18 != '\0') {
    pcVar1 = local_18 + 1;
    if (*local_18 == '0') {
      local_28 = (undefined8 *)*local_28;
    }
    else {
      local_28 = (undefined8 *)local_28[1];
    }
    local_18 = pcVar1;
    if (*(char *)((long)local_28 + 0x14) != '\0') {
      _putchar((int)*(char *)((long)local_28 + 0x14));
      local_28 = param_2;
    }
  }
  iVar2 = _putchar(10);
  if (param_2 != local_28) {
    iVar2 = _printf("garbage input\n");
  }
  return iVar2;
}



undefined8 entry(void)

{
  int local_430;
  undefined auStack_428 [1024];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _init("this is an example for huffman encoding");
  for (local_430 = 0; local_430 < 0x80; local_430 = local_430 + 1) {
    if (*(long *)(&_code + (long)local_430 * 8) != 0) {
      _printf("\'%c\': %s\n");
    }
  }
  _encode("this is an example for huffman encoding");
  _printf("encoded: %s\n");
  _printf("decoded: ");
  _decode(auStack_428,*(undefined8 *)(_q + 8));
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _bzero(void *param_1,size_t param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__bzero_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004028)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f2c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004030)();
  return sVar1;
}


`
`#include <stdio.h>

#define GRID_SIZE 15
char canvas[GRID_SIZE][GRID_SIZE];

void initN() {
    int i, j;
    for (i = 0; i < GRID_SIZE; i++) {
        for (j = 0; j < GRID_SIZE; j++) {
            canvas[i][j] = ' ';
        }
        canvas[i][5] = 'x';
    }
}

void horizontal(size_t c1, size_t c2, size_t r) {
    size_t c;
    for (c = c1; c <= c2; c++) {
        canvas[r][c] = 'x';
    }
}

void vertical(size_t r1, size_t r2, size_t c) {
    size_t r;
    for (r = r1; r <= r2; r++) {
        canvas[r][c] = 'x';
    }
}

void diagd(size_t c1, size_t c2, size_t r) {
    size_t c;
    for (c = c1; c <= c2; c++) {
        canvas[r + c - c1][c] = 'x';
    }
}

void diagu(size_t c1, size_t c2, size_t r) {
    size_t c;
    for (c = c1; c <= c2; c++) {
        canvas[r - c + c1][c] = 'x';
    }
}

void drawOnes(int v) {
    switch (v) {
    case 1:
        horizontal(6, 10, 0);
        break;
    case 2:
        horizontal(6, 10, 4);
        break;
    case 3:
        diagd(6, 10, 0);
        break;
    case 4:
        diagu(6, 10, 4);
        break;
    case 5:
        drawOnes(1);
        drawOnes(4);
        break;
    case 6:
        vertical(0, 4, 10);
        break;
    case 7:
        drawOnes(1);
        drawOnes(6);
        break;
    case 8:
        drawOnes(2);
        drawOnes(6);
        break;
    case 9:
        drawOnes(1);
        drawOnes(8);
        break;
    default:
        break;
    }
}

void drawTens(int v) {
    switch (v) {
    case 1:
        horizontal(0, 4, 0);
        break;
    case 2:
        horizontal(0, 4, 4);
        break;
    case 3:
        diagu(0, 4, 4);
        break;
    case 4:
        diagd(0, 4, 0);
        break;
    case 5:
        drawTens(1);
        drawTens(4);
        break;
    case 6:
        vertical(0, 4, 0);
        break;
    case 7:
        drawTens(1);
        drawTens(6);
        break;
    case 8:
        drawTens(2);
        drawTens(6);
        break;
    case 9:
        drawTens(1);
        drawTens(8);
        break;
    default:
        break;
    }
}

void drawHundreds(int hundreds) {
    switch (hundreds) {
    case 1:
        horizontal(6, 10, 14);
        break;
    case 2:
        horizontal(6, 10, 10);
        break;
    case 3:
        diagu(6, 10, 14);
        break;
    case 4:
        diagd(6, 10, 10);
        break;
    case 5:
        drawHundreds(1);
        drawHundreds(4);
        break;
    case 6:
        vertical(10, 14, 10);
        break;
    case 7:
        drawHundreds(1);
        drawHundreds(6);
        break;
    case 8:
        drawHundreds(2);
        drawHundreds(6);
        break;
    case 9:
        drawHundreds(1);
        drawHundreds(8);
        break;
    default:
        break;
    }
}

void drawThousands(int thousands) {
    switch (thousands) {
    case 1:
        horizontal(0, 4, 14);
        break;
    case 2:
        horizontal(0, 4, 10);
        break;
    case 3:
        diagd(0, 4, 10);
        break;
    case 4:
        diagu(0, 4, 14);
        break;
    case 5:
        drawThousands(1);
        drawThousands(4);
        break;
    case 6:
        vertical(10, 14, 0);
        break;
    case 7:
        drawThousands(1);
        drawThousands(6);
        break;
    case 8:
        drawThousands(2);
        drawThousands(6);
        break;
    case 9:
        drawThousands(1);
        drawThousands(8);
        break;
    default:
        break;
    }
}

void draw(int v) {
    int thousands = v / 1000;
    v %= 1000;

    int hundreds = v / 100;
    v %= 100;

    int tens = v / 10;
    int ones = v % 10;

    if (thousands > 0) {
        drawThousands(thousands);
    }
    if (hundreds > 0) {
        drawHundreds(hundreds);
    }
    if (tens > 0) {
        drawTens(tens);
    }
    if (ones > 0) {
        drawOnes(ones);
    }
}

void write(FILE *out) {
    int i;
    for (i = 0; i < GRID_SIZE; i++) {
        fprintf(out, "%-.*s", GRID_SIZE, canvas[i]);
        putc('\n', out);
    }
}

void test(int n) {
    printf("%d:\n", n);
    initN();
    draw(n);
    write(stdout);
    printf("\n\n");
}

int main() {
    test(0);
    test(1);
    test(20);
    test(300);
    test(4000);
    test(5555);
    test(6789);
    test(9999);

    return 0;
}
`,`#include "cistercian-numerals.h"



void _initN(void)

{
  int local_8;
  int local_4;
  
  for (local_4 = 0; local_4 < 0xf; local_4 = local_4 + 1) {
    for (local_8 = 0; local_8 < 0xf; local_8 = local_8 + 1) {
      (&_canvas)[(long)local_8 + (long)local_4 * 0xf] = 0x20;
    }
    *(undefined *)((long)local_4 * 0xf + 0x100008005) = 0x78;
  }
  return;
}



void _horizontal(ulong param_1,ulong param_2,long param_3)

{
  ulong local_20;
  
  for (local_20 = param_1; local_20 <= param_2; local_20 = local_20 + 1) {
    (&_canvas)[local_20 + param_3 * 0xf] = 0x78;
  }
  return;
}



void _vertical(ulong param_1,ulong param_2,long param_3)

{
  ulong local_20;
  
  for (local_20 = param_1; local_20 <= param_2; local_20 = local_20 + 1) {
    (&_canvas)[param_3 + local_20 * 0xf] = 0x78;
  }
  return;
}



void _diagd(ulong param_1,ulong param_2,long param_3)

{
  ulong local_20;
  
  for (local_20 = param_1; local_20 <= param_2; local_20 = local_20 + 1) {
    (&_canvas)[param_3 * 0xf + local_20 * 0x10 + param_1 * -0xf] = 0x78;
  }
  return;
}



void _diagu(ulong param_1,ulong param_2,long param_3)

{
  ulong local_20;
  
  for (local_20 = param_1; local_20 <= param_2; local_20 = local_20 + 1) {
    (&_canvas)[param_3 * 0xf + local_20 * -0xe + param_1 * 0xf] = 0x78;
  }
  return;
}



void _drawOnes(undefined4 param_1)

{
  switch(param_1) {
  case 1:
    _horizontal(6,10,0);
    break;
  case 2:
    _horizontal(6,10,4);
    break;
  case 3:
    _diagd(6,10,0);
    break;
  case 4:
    _diagu(6,10,4);
    break;
  case 5:
    _drawOnes(1);
    _drawOnes(4);
    break;
  case 6:
    _vertical(0,4,10);
    break;
  case 7:
    _drawOnes(1);
    _drawOnes(6);
    break;
  case 8:
    _drawOnes(2);
    _drawOnes(6);
    break;
  case 9:
    _drawOnes(1);
    _drawOnes(8);
  }
  return;
}



void _drawTens(undefined4 param_1)

{
  switch(param_1) {
  case 1:
    _horizontal(0,4);
    break;
  case 2:
    _horizontal(0,4);
    break;
  case 3:
    _diagu(0,4);
    break;
  case 4:
    _diagd(0,4);
    break;
  case 5:
    _drawTens(1);
    _drawTens(4);
    break;
  case 6:
    _vertical(0,4);
    break;
  case 7:
    _drawTens(1);
    _drawTens(6);
    break;
  case 8:
    _drawTens(2);
    _drawTens(6);
    break;
  case 9:
    _drawTens(1);
    _drawTens(8);
  }
  return;
}



void _drawHundreds(undefined4 param_1)

{
  switch(param_1) {
  case 1:
    _horizontal(6,10,0xe);
    break;
  case 2:
    _horizontal(6,10);
    break;
  case 3:
    _diagu(6,10,0xe);
    break;
  case 4:
    _diagd(6,10);
    break;
  case 5:
    _drawHundreds(1);
    _drawHundreds(4);
    break;
  case 6:
    _vertical(10,0xe);
    break;
  case 7:
    _drawHundreds(1);
    _drawHundreds(6);
    break;
  case 8:
    _drawHundreds(2);
    _drawHundreds(6);
    break;
  case 9:
    _drawHundreds(1);
    _drawHundreds(8);
  }
  return;
}



void _drawThousands(undefined4 param_1)

{
  switch(param_1) {
  case 1:
    _horizontal(0,4,0xe);
    break;
  case 2:
    _horizontal(0,4,10);
    break;
  case 3:
    _diagd(0,4,10);
    break;
  case 4:
    _diagu(0,4,0xe);
    break;
  case 5:
    _drawThousands(1);
    _drawThousands(4);
    break;
  case 6:
    _vertical(10,0xe,0);
    break;
  case 7:
    _drawThousands(1);
    _drawThousands(6);
    break;
  case 8:
    _drawThousands(2);
    _drawThousands(6);
    break;
  case 9:
    _drawThousands(1);
    _drawThousands(8);
  }
  return;
}



void _draw(int param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  iVar1 = (param_1 % 1000) / 100;
  iVar3 = (param_1 % 1000) % 100;
  iVar2 = iVar3 / 10;
  iVar3 = iVar3 % 10;
  if (0 < param_1 / 1000) {
    _drawThousands(param_1 / 1000);
  }
  if (0 < iVar1) {
    _drawHundreds(iVar1);
  }
  if (0 < iVar2) {
    _drawTens(iVar2);
  }
  if (0 < iVar3) {
    _drawOnes(iVar3);
  }
  return;
}



ssize_t _write(int param_1,void *param_2,size_t param_3)

{
  uint uVar1;
  FILE *pFVar2;
  int local_1c;
  FILE *pFVar3;
  
  pFVar2 = (FILE *)(ulong)(uint)param_1;
  pFVar3 = pFVar2;
  for (local_1c = 0; local_1c < 0xf; local_1c = local_1c + 1) {
    _fprintf(pFVar2,"%-.*s");
    uVar1 = _putc(10,pFVar2);
    pFVar3 = (FILE *)(ulong)uVar1;
  }
  return (ssize_t)pFVar3;
}



int _test(undefined4 param_1,undefined8 param_2,size_t param_3)

{
  int iVar1;
  void *extraout_x1;
  
  iVar1 = _printf("%d:\n");
  _initN(iVar1);
  _draw(param_1);
  _write((int)*(undefined8 *)PTR____stdoutp_100004000,extraout_x1,param_3);
  iVar1 = _printf("\n\n");
  return iVar1;
}



undefined4 entry(void)

{
  _test();
  _test(1);
  _test(0x14);
  _test(300);
  _test(4000);
  _test(0x15b3);
  _test(0x1a85);
  _test(9999);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putc(int param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putc_100004018)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int i, j;

void fliprow(int **b, int sz, int n)
{
	for(i = 0; i < sz; i++)
		b[n+1][i] = !b[n+1][i];
}

void flipcol(int **b, int sz, int n)
{
	for(i = 1; i <= sz; i++)
		b[i][n] = !b[i][n];
}

void initt(int **t, int sz)
{
	for(i = 1; i <= sz; i++)
		for(j = 0; j < sz; j++)
			t[i][j] = rand()%2;
}

void initb(int **t, int **b, int sz)
{
	for(i = 1; i <= sz; i++)
		for(j = 0; j < sz; j++)
			b[i][j] = t[i][j];
	
	for(i = 1; i <= sz; i++)
		fliprow(b, sz, rand()%sz+1);
	for(i = 0; i < sz; i++)
		flipcol(b, sz, rand()%sz);
}

void printb(int **b, int sz)
{
	printf(" ");
	for(i = 0; i < sz; i++)
		printf(" %d", i);
	printf("\n");

	for(i = 1; i <= sz; i++)
	{
		printf("%d", i-1);
		for(j = 0; j < sz; j++)
			printf(" %d", b[i][j]);
		printf("\n");
	}
	
	printf("\n");
}

int eq(int **t, int **b, int sz)
{
	for(i = 1; i <= sz; i++)
		for(j = 0; j < sz; j++)
			if(b[i][j] != t[i][j])
				return 0;
	return 1;
}

void main()
{
	int sz = 3;
	int eql = 0;
	int mov = 0;
	int **t = malloc(sz*(sizeof(int)+1));
	for(i = 1; i <= sz; i++)
		t[i] = malloc(sz*sizeof(int));

	int **b = malloc(sz*(sizeof(int)+1));
	for(i = 1; i <= sz; i++)
		b[i] = malloc(sz*sizeof(int));
	char roc;
	int n;
	initt(t, sz);
	initb(t, b, sz);
	
	while(eq(t, b, sz))
		initb(t, b, sz);
	
	while(!eql)
	{
		printf("Target: \n");
		printb(t, sz);
		printf("Board: \n");
		printb(b, sz);
		printf("What to flip: ");
		scanf(" %c", &roc);
		scanf(" %d", &n);

		switch(roc)
		{
			case 'r':
				fliprow(b, sz, n);
				break;
			case 'c':
				flipcol(b, sz, n);
				break;
			default:
				perror("Please specify r or c and an number");
				break;
		}

		printf("Moves Taken: %d\n", ++mov);

		if(eq(t, b, sz))
		{
			printf("You win!\n");
			eql = 1;
		}
	}
}
`,`#include "flipping-bits-game.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _fliprow(long param_1,int param_2,int param_3)

{
  for (__i = 0; __i < param_2; __i = __i + 1) {
    *(uint *)(*(long *)(param_1 + (long)(param_3 + 1) * 8) + (long)__i * 4) =
         (uint)(*(int *)(*(long *)(param_1 + (long)(param_3 + 1) * 8) + (long)__i * 4) == 0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _flipcol(long param_1,int param_2,int param_3)

{
  for (__i = 1; __i <= param_2; __i = __i + 1) {
    *(uint *)(*(long *)(param_1 + (long)__i * 8) + (long)param_3 * 4) =
         (uint)(*(int *)(*(long *)(param_1 + (long)__i * 8) + (long)param_3 * 4) == 0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _initt(long param_1,int param_2)

{
  int iVar1;
  
  for (__i = 1; __i <= param_2; __i = __i + 1) {
    for (__j = 0; __j < param_2; __j = __j + 1) {
      iVar1 = _rand();
      *(int *)(*(long *)(param_1 + (long)__i * 8) + (long)__j * 4) = iVar1 % 2;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _initb(long param_1,long param_2,int param_3)

{
  int iVar1;
  int iVar2;
  
  for (__i = 1; __i <= param_3; __i = __i + 1) {
    for (__j = 0; __j < param_3; __j = __j + 1) {
      *(undefined4 *)(*(long *)(param_2 + (long)__i * 8) + (long)__j * 4) =
           *(undefined4 *)(*(long *)(param_1 + (long)__i * 8) + (long)__j * 4);
    }
  }
  for (__i = 1; __i <= param_3; __i = __i + 1) {
    iVar2 = _rand();
    iVar1 = 0;
    if (param_3 != 0) {
      iVar1 = iVar2 / param_3;
    }
    _fliprow(param_2,param_3,(iVar2 - iVar1 * param_3) + 1);
  }
  for (__i = 0; __i < param_3; __i = __i + 1) {
    iVar2 = _rand();
    iVar1 = 0;
    if (param_3 != 0) {
      iVar1 = iVar2 / param_3;
    }
    _flipcol(param_2,param_3,iVar2 - iVar1 * param_3);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int _printb(undefined8 param_1,int param_2)

{
  int iVar1;
  
  _printf(" ");
  for (__i = 0; __i < param_2; __i = __i + 1) {
    _printf(" %d");
  }
  _printf("\n");
  for (__i = 1; __i <= param_2; __i = __i + 1) {
    _printf("%d");
    for (__j = 0; __j < param_2; __j = __j + 1) {
      _printf(" %d");
    }
    _printf("\n");
  }
  iVar1 = _printf("\n");
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 _eq(long param_1,long param_2,int param_3)

{
  __i = 1;
  do {
    if (param_3 < __i) {
      return 1;
    }
    for (__j = 0; __j < param_3; __j = __j + 1) {
      if (*(int *)(*(long *)(param_2 + (long)__i * 8) + (long)__j * 4) !=
          *(int *)(*(long *)(param_1 + (long)__i * 8) + (long)__j * 4)) {
        return 0;
      }
    }
    __i = __i + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong entry(void)

{
  bool bVar1;
  uint uVar2;
  void *pvVar3;
  void *pvVar4;
  void *pvVar5;
  ulong uVar6;
  undefined4 local_38;
  char local_31;
  
  bVar1 = false;
  pvVar3 = _malloc(0xf);
  for (__i = 1; __i < 4; __i = __i + 1) {
    pvVar4 = _malloc(0xc);
    *(void **)((long)pvVar3 + (long)__i * 8) = pvVar4;
  }
  pvVar4 = _malloc(0xf);
  for (__i = 1; __i < 4; __i = __i + 1) {
    pvVar5 = _malloc(0xc);
    *(void **)((long)pvVar4 + (long)__i * 8) = pvVar5;
  }
  _initt(pvVar3,3);
  _initb(pvVar3,pvVar4,3);
  while (uVar6 = _eq(pvVar3,pvVar4,3), (int)uVar6 != 0) {
    _initb(pvVar3,pvVar4,3);
  }
  while (!bVar1) {
    _printf("Target: \n");
    _printb(pvVar3,3);
    _printf("Board: \n");
    _printb(pvVar4,3);
    _printf("What to flip: ");
    _scanf(" %c");
    _scanf(" %d");
    if (local_31 == 'c') {
      _flipcol(pvVar4,3,local_38);
    }
    else if (local_31 == 'r') {
      _fliprow(pvVar4,3,local_38);
    }
    else {
      _perror("Please specify r or c and an number");
    }
    _printf("Moves Taken: %d\n");
    uVar6 = _eq(pvVar3,pvVar4,3);
    if ((int)uVar6 != 0) {
      uVar2 = _printf("You win!\n");
      uVar6 = (ulong)uVar2;
      bVar1 = true;
    }
  }
  return uVar6;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ef4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _perror(char *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__perror_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004018)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004020)((int)param_1);
  return iVar1;
}


`
`/*
 * RossetaCode: Law of cosines - triples
 *
 * An quick and dirty brute force solutions with O(N^3) cost.
 * Anyway it is possible set MAX_SIDE_LENGTH equal to 10000
 * and use fast computer to obtain the "extra credit" badge.
 *
 * Obviously, there are better algorithms.
 */

#include <stdio.h>
#include <math.h>

#define MAX_SIDE_LENGTH 13
//#define DISPLAY_TRIANGLES 1

int main(void)
{
    static char description[3][80] = {
        "gamma =  90 degrees,  a*a + b*b       == c*c",
        "gamma =  60 degrees,  a*a + b*b - a*b == c*c",
        "gamma = 120 degrees,  a*a + b*b + a*b == c*c"
    };
    static int coeff[3] = { 0, 1, -1 };

    for (int k = 0; k < 3; k++)
    {
        int counter = 0;
        for (int a = 1; a <= MAX_SIDE_LENGTH; a++)
            for (int b = 1; b <= a; b++)
                for (int c = 1; c <= MAX_SIDE_LENGTH; c++)
                    if (a * a + b * b - coeff[k] * a * b == c * c)
                    {
                        counter++;
#ifdef DISPLAY_TRIANGLES
                        printf("  %d  %d  %d\n", a, b, c);
#endif
                    }
        printf("%s,  number of triangles = %d\n", description[k], counter);
    }

    return 0;
}
`,`#include "law-of-cosines---triples-1.h"



undefined8 entry(void)

{
  int local_28;
  int local_24;
  int local_20;
  int local_18;
  
  for (local_18 = 0; local_18 < 3; local_18 = local_18 + 1) {
    for (local_20 = 1; local_20 < 0xe; local_20 = local_20 + 1) {
      for (local_24 = 1; local_24 <= local_20; local_24 = local_24 + 1) {
        for (local_28 = 1; local_28 < 0xe; local_28 = local_28 + 1) {
        }
      }
    }
    _printf("%s,  number of triangles = %d\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

struct RealSet {
    bool(*contains)(struct RealSet*, struct RealSet*, double);
    struct RealSet *left;
    struct RealSet *right;
    double low, high;
};

typedef enum {
    CLOSED,
    LEFT_OPEN,
    RIGHT_OPEN,
    BOTH_OPEN,
} RangeType;

double length(struct RealSet *self) {
    const double interval = 0.00001;
    double p = self->low;
    int count = 0;

    if (isinf(self->low) || isinf(self->high)) return -1.0;
    if (self->high <= self->low) return 0.0;

    do {
        if (self->contains(self, NULL, p)) count++;
        p += interval;
    } while (p < self->high);
    return count * interval;
}

bool empty(struct RealSet *self) {
    if (self->low == self->high) {
        return !self->contains(self, NULL, self->low);
    }
    return length(self) == 0.0;
}

static bool contains_closed(struct RealSet *self, struct RealSet *_, double d) {
    return self->low <= d && d <= self->high;
}

static bool contains_left_open(struct RealSet *self, struct RealSet *_, double d) {
    return self->low < d && d <= self->high;
}

static bool contains_right_open(struct RealSet *self, struct RealSet *_, double d) {
    return self->low <= d && d < self->high;
}

static bool contains_both_open(struct RealSet *self, struct RealSet *_, double d) {
    return self->low < d && d < self->high;
}

static bool contains_intersect(struct RealSet *self, struct RealSet *_, double d) {
    return self->left->contains(self->left, NULL, d) && self->right->contains(self->right, NULL, d);
}

static bool contains_union(struct RealSet *self, struct RealSet *_, double d) {
    return self->left->contains(self->left, NULL, d) || self->right->contains(self->right, NULL, d);
}

static bool contains_subtract(struct RealSet *self, struct RealSet *_, double d) {
    return self->left->contains(self->left, NULL, d) && !self->right->contains(self->right, NULL, d);
}

struct RealSet* makeSet(double low, double high, RangeType type) {
    bool(*contains)(struct RealSet*, struct RealSet*, double);
    struct RealSet *rs;

    switch (type) {
    case CLOSED:
        contains = contains_closed;
        break;
    case LEFT_OPEN:
        contains = contains_left_open;
        break;
    case RIGHT_OPEN:
        contains = contains_right_open;
        break;
    case BOTH_OPEN:
        contains = contains_both_open;
        break;
    default:
        return NULL;
    }

    rs = malloc(sizeof(struct RealSet));
    rs->contains = contains;
    rs->left = NULL;
    rs->right = NULL;
    rs->low = low;
    rs->high = high;
    return rs;
}

struct RealSet* makeIntersect(struct RealSet *left, struct RealSet *right) {
    struct RealSet *rs = malloc(sizeof(struct RealSet));
    rs->contains = contains_intersect;
    rs->left = left;
    rs->right = right;
    rs->low = fmin(left->low, right->low);
    rs->high = fmin(left->high, right->high);
    return rs;
}

struct RealSet* makeUnion(struct RealSet *left, struct RealSet *right) {
    struct RealSet *rs = malloc(sizeof(struct RealSet));
    rs->contains = contains_union;
    rs->left = left;
    rs->right = right;
    rs->low = fmin(left->low, right->low);
    rs->high = fmin(left->high, right->high);
    return rs;
}

struct RealSet* makeSubtract(struct RealSet *left, struct RealSet *right) {
    struct RealSet *rs = malloc(sizeof(struct RealSet));
    rs->contains = contains_subtract;
    rs->left = left;
    rs->right = right;
    rs->low = left->low;
    rs->high = left->high;
    return rs;
}

int main() {
    struct RealSet *a = makeSet(0.0, 1.0, LEFT_OPEN);
    struct RealSet *b = makeSet(0.0, 2.0, RIGHT_OPEN);
    struct RealSet *c = makeSet(1.0, 2.0, LEFT_OPEN);
    struct RealSet *d = makeSet(0.0, 3.0, RIGHT_OPEN);
    struct RealSet *e = makeSet(0.0, 1.0, BOTH_OPEN);
    struct RealSet *f = makeSet(0.0, 1.0, CLOSED);
    struct RealSet *g = makeSet(0.0, 0.0, CLOSED);
    int i;

    for (i = 0; i < 3; ++i) {
        struct RealSet *t;

        t = makeUnion(a, b);
        printf("(0, 1]   union   [0, 2) contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        t = makeIntersect(b, c);
        printf("[0, 2) intersect (1, 2] contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        t = makeSubtract(d, e);
        printf("[0, 3)     -     (0, 1) contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        t = makeSubtract(d, f);
        printf("[0, 3)     -     [0, 1] contains %d is %d\n", i, t->contains(t, NULL, i));
        free(t);

        printf("\n");
    }

    printf("[0, 0] is empty %d\n", empty(g));

    free(a);
    free(b);
    free(c);
    free(d);
    free(e);
    free(f);
    free(g);

    return 0;
}
`,`#include "set-of-real-numbers.h"



// WARNING: Removing unreachable block (ram,0x00010000342c)
// WARNING: Removing unreachable block (ram,0x00010000345c)
// WARNING: Removing unreachable block (ram,0x000100003374)
// WARNING: Removing unreachable block (ram,0x0001000033a4)
// WARNING: Removing unreachable block (ram,0x0001000032f8)
// WARNING: Removing unreachable block (ram,0x000100003330)
// WARNING: Removing unreachable block (ram,0x0001000033b0)
// WARNING: Removing unreachable block (ram,0x0001000033e8)

undefined  [16] _length(undefined8 *param_1)

{
  ulong uVar1;
  undefined auVar2 [16];
  int local_5c;
  double local_58;
  double local_40;
  
  local_58 = (double)param_1[3];
  local_5c = 0;
  if ((ABS((double)param_1[3]) == INFINITY) || (ABS((double)param_1[4]) == INFINITY)) {
    local_40 = -1.0;
  }
  else if ((double)param_1[3] < (double)param_1[4]) {
    do {
      uVar1 = (*(code *)*param_1)(local_58,param_1,0);
      if ((uVar1 & 1) != 0) {
        local_5c = local_5c + 1;
      }
      local_58 = local_58 + 1e-05;
    } while (local_58 < (double)param_1[4]);
    local_40 = (double)(long)local_5c * 1e-05;
  }
  else {
    local_40 = 0.0;
  }
  auVar2._8_8_ = 0;
  auVar2._0_8_ = local_40;
  return auVar2;
}



bool _empty(undefined8 *param_1)

{
  byte bVar1;
  double dVar2;
  bool local_11;
  
  if ((double)param_1[3] == (double)param_1[4]) {
    bVar1 = (*(code *)*param_1)(param_1[3],param_1,0);
    local_11 = (bool)((bVar1 ^ 1) & 1);
  }
  else {
    dVar2 = (double)_length(param_1);
    local_11 = dVar2 == 0.0;
  }
  return local_11;
}



undefined8 * _makeSet(undefined8 param_1,undefined8 param_2,undefined4 param_3)

{
  undefined8 *puVar1;
  code *local_38;
  
  switch(param_3) {
  case 0:
    local_38 = FUN_1000036d0;
    break;
  case 1:
    local_38 = FUN_100003730;
    break;
  case 2:
    local_38 = FUN_100003790;
    break;
  case 3:
    local_38 = FUN_1000037f0;
    break;
  default:
    return (undefined8 *)0x0;
  }
  puVar1 = (undefined8 *)_malloc(0x28);
  *puVar1 = local_38;
  puVar1[1] = 0;
  puVar1[2] = 0;
  puVar1[3] = param_1;
  puVar1[4] = param_2;
  return puVar1;
}



bool FUN_1000036d0(double param_1,long param_2)

{
  bool bVar1;
  
  bVar1 = false;
  if (*(double *)(param_2 + 0x18) <= param_1) {
    bVar1 = param_1 <= *(double *)(param_2 + 0x20);
  }
  return bVar1;
}



bool FUN_100003730(double param_1,long param_2)

{
  bool bVar1;
  
  bVar1 = false;
  if (*(double *)(param_2 + 0x18) < param_1) {
    bVar1 = param_1 <= *(double *)(param_2 + 0x20);
  }
  return bVar1;
}



bool FUN_100003790(double param_1,long param_2)

{
  bool bVar1;
  
  bVar1 = false;
  if (*(double *)(param_2 + 0x18) <= param_1) {
    bVar1 = param_1 < *(double *)(param_2 + 0x20);
  }
  return bVar1;
}



bool FUN_1000037f0(double param_1,long param_2)

{
  bool bVar1;
  
  bVar1 = false;
  if (*(double *)(param_2 + 0x18) < param_1) {
    bVar1 = param_1 < *(double *)(param_2 + 0x20);
  }
  return bVar1;
}



undefined8 * _makeIntersect(long param_1,long param_2)

{
  undefined8 *puVar1;
  undefined8 uVar2;
  
  puVar1 = (undefined8 *)_malloc(0x28);
  *puVar1 = FUN_1000038e0;
  puVar1[1] = param_1;
  puVar1[2] = param_2;
  uVar2 = NEON_fminnm(*(undefined8 *)(param_1 + 0x18),*(undefined8 *)(param_2 + 0x18));
  puVar1[3] = uVar2;
  uVar2 = NEON_fminnm(*(undefined8 *)(param_1 + 0x20),*(undefined8 *)(param_2 + 0x20));
  puVar1[4] = uVar2;
  return puVar1;
}



uint FUN_1000038e0(undefined8 param_1,long param_2)

{
  ulong uVar1;
  undefined4 local_2c;
  
  uVar1 = (*(code *)**(undefined8 **)(param_2 + 8))(param_1,*(undefined8 *)(param_2 + 8),0);
  local_2c = 0;
  if ((uVar1 & 1) != 0) {
    local_2c = (*(code *)**(undefined8 **)(param_2 + 0x10))
                         (param_1,*(undefined8 *)(param_2 + 0x10),0);
  }
  return local_2c & 1;
}



undefined8 * _makeUnion(long param_1,long param_2)

{
  undefined8 *puVar1;
  undefined8 uVar2;
  
  puVar1 = (undefined8 *)_malloc(0x28);
  *puVar1 = FUN_1000039f4;
  puVar1[1] = param_1;
  puVar1[2] = param_2;
  uVar2 = NEON_fminnm(*(undefined8 *)(param_1 + 0x18),*(undefined8 *)(param_2 + 0x18));
  puVar1[3] = uVar2;
  uVar2 = NEON_fminnm(*(undefined8 *)(param_1 + 0x20),*(undefined8 *)(param_2 + 0x20));
  puVar1[4] = uVar2;
  return puVar1;
}



uint FUN_1000039f4(undefined8 param_1,long param_2)

{
  ulong uVar1;
  undefined4 local_2c;
  
  uVar1 = (*(code *)**(undefined8 **)(param_2 + 8))(param_1,*(undefined8 *)(param_2 + 8),0);
  local_2c = 1;
  if ((uVar1 & 1) == 0) {
    local_2c = (*(code *)**(undefined8 **)(param_2 + 0x10))
                         (param_1,*(undefined8 *)(param_2 + 0x10),0);
  }
  return local_2c & 1;
}



undefined8 * _makeSubtract(long param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(0x28);
  *puVar1 = FUN_100003af0;
  puVar1[1] = param_1;
  puVar1[2] = param_2;
  puVar1[3] = *(undefined8 *)(param_1 + 0x18);
  puVar1[4] = *(undefined8 *)(param_1 + 0x20);
  return puVar1;
}



uint FUN_100003af0(undefined8 param_1,long param_2)

{
  ulong uVar1;
  undefined4 local_2c;
  
  uVar1 = (*(code *)**(undefined8 **)(param_2 + 8))(param_1,*(undefined8 *)(param_2 + 8),0);
  local_2c = 0;
  if ((uVar1 & 1) != 0) {
    local_2c = (*(code *)**(undefined8 **)(param_2 + 0x10))
                         (param_1,*(undefined8 *)(param_2 + 0x10),0);
    local_2c = local_2c ^ 1;
  }
  return local_2c & 1;
}



undefined8 entry(void)

{
  void *pvVar1;
  void *pvVar2;
  void *pvVar3;
  void *pvVar4;
  void *pvVar5;
  void *pvVar6;
  void *pvVar7;
  undefined8 *puVar8;
  int local_54;
  
  pvVar1 = (void *)_makeSet();
  pvVar2 = (void *)_makeSet(0);
  pvVar3 = (void *)_makeSet(0x3ff0000000000000,0x4000000000000000,1);
  pvVar4 = (void *)_makeSet(0,0x4008000000000000,2);
  pvVar5 = (void *)_makeSet(0,0x3ff0000000000000,3);
  pvVar6 = (void *)_makeSet(0,0x3ff0000000000000,0);
  pvVar7 = (void *)_makeSet(0,0);
  for (local_54 = 0; local_54 < 3; local_54 = local_54 + 1) {
    puVar8 = (undefined8 *)_makeUnion(pvVar1,pvVar2);
    (*(code *)*puVar8)((double)(long)local_54,puVar8);
    _printf("(0, 1]   union   [0, 2) contains %d is %d\n");
    _free(puVar8);
    puVar8 = (undefined8 *)_makeIntersect(pvVar2,pvVar3);
    (*(code *)*puVar8)((double)(long)local_54,puVar8,0);
    _printf("[0, 2) intersect (1, 2] contains %d is %d\n");
    _free(puVar8);
    puVar8 = (undefined8 *)_makeSubtract(pvVar4,pvVar5);
    (*(code *)*puVar8)((double)(long)local_54,puVar8,0);
    _printf("[0, 3)     -     (0, 1) contains %d is %d\n");
    _free(puVar8);
    puVar8 = (undefined8 *)_makeSubtract(pvVar4,pvVar6);
    (*(code *)*puVar8)((double)(long)local_54,puVar8,0);
    _printf("[0, 3)     -     [0, 1] contains %d is %d\n");
    _free(puVar8);
    _printf("\n");
  }
  _empty(pvVar7);
  _printf("[0, 0] is empty %d\n");
  _free(pvVar1);
  _free(pvVar2);
  _free(pvVar3);
  _free(pvVar4);
  _free(pvVar5);
  _free(pvVar6);
  _free(pvVar7);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ea4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eb0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>

static const int d[][10] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, {1, 2, 3, 4, 0, 6, 7, 8, 9, 5},
    {2, 3, 4, 0, 1, 7, 8, 9, 5, 6}, {3, 4, 0, 1, 2, 8, 9, 5, 6, 7},
    {4, 0, 1, 2, 3, 9, 5, 6, 7, 8}, {5, 9, 8, 7, 6, 0, 4, 3, 2, 1},
    {6, 5, 9, 8, 7, 1, 0, 4, 3, 2}, {7, 6, 5, 9, 8, 2, 1, 0, 4, 3},
    {8, 7, 6, 5, 9, 3, 2, 1, 0, 4}, {9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
};

static const int inv[] = {0, 4, 3, 2, 1, 5, 6, 7, 8, 9};

static const int p[][10] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, {1, 5, 7, 6, 2, 8, 3, 0, 9, 4},
    {5, 8, 0, 3, 7, 9, 6, 1, 4, 2}, {8, 9, 1, 6, 0, 4, 3, 5, 2, 7},
    {9, 4, 5, 3, 1, 2, 6, 8, 7, 0}, {4, 2, 8, 6, 5, 7, 3, 9, 0, 1},
    {2, 7, 9, 3, 8, 0, 6, 4, 1, 5}, {7, 0, 4, 6, 9, 1, 3, 2, 5, 8},
};

int verhoeff(const char* s, bool validate, bool verbose) {
    if (verbose) {
        const char* t = validate ? "Validation" : "Check digit";
        printf("%s calculations for '%s':\n\n", t, s);
        puts(u8" i  n\xE1\xB5\xA2  p[i,n\xE1\xB5\xA2]  c");
        puts("------------------");
    }
    int len = strlen(s);
    if (validate)
        --len;
    int c = 0;
    for (int i = len; i >= 0; --i) {
        int ni = (i == len && !validate) ? 0 : s[i] - '0';
        assert(ni >= 0 && ni < 10);
        int pi = p[(len - i) % 8][ni];
        c = d[c][pi];
        if (verbose)
            printf("%2d  %d      %d     %d\n", len - i, ni, pi, c);
    }
    if (verbose && !validate)
        printf("\ninv[%d] = %d\n", c, inv[c]);
    return validate ? c == 0 : inv[c];
}

int main() {
    const char* ss[3] = {"236", "12345", "123456789012"};
    for (int i = 0; i < 3; ++i) {
        const char* s = ss[i];
        bool verbose = i < 2;
        int c = verhoeff(s, false, verbose);
        printf("\nThe check digit for '%s' is '%d'.\n", s, c);
        int len = strlen(s);
        char sc[len + 2];
        strncpy(sc, s, len + 2);
        for (int j = 0; j < 2; ++j) {
            sc[len] = (j == 0) ? c + '0' : '9';
            int v = verhoeff(sc, true, verbose);
            printf("\nThe validation for '%s' is %s.\n", sc,
                   v ? "correct" : "incorrect");
        }
    }
    return 0;
}
`,`#include "verhoeff-algorithm.h"



uint _verhoeff(char *param_1,byte param_2,byte param_3)

{
  size_t sVar1;
  uint local_48;
  uint local_40;
  int local_34;
  int local_30;
  int local_2c;
  
  param_2 = param_2 & 1;
  param_3 = param_3 & 1;
  if (param_3 != 0) {
    _printf("%s calculations for \'%s\':\n\n");
    _puts(s_i_n_p_i_n___c_100003bbf);
    _puts("------------------");
  }
  sVar1 = _strlen(param_1);
  local_2c = (int)sVar1;
  if (param_2 != 0) {
    local_2c = local_2c + -1;
  }
  local_30 = 0;
  local_34 = local_2c;
  while( true ) {
    if (local_34 < 0) {
      if ((param_3 != 0) && (param_2 == 0)) {
        _printf("\ninv[%d] = %d\n");
      }
      if (param_2 == 0) {
        local_48 = *(uint *)(&DAT_100003f80 + (long)local_30 * 4);
      }
      else {
        local_48 = (uint)(local_30 == 0);
      }
      return local_48;
    }
    if ((local_34 == local_2c) && (param_2 == 0)) {
      local_40 = 0;
    }
    else {
      local_40 = (int)param_1[local_34] - 0x30;
    }
    if (9 < local_40) break;
    local_30 = *(int *)(&UNK_100003df0 +
                       (long)*(int *)((long)&PTR___mh_execute_header_100003cb0 +
                                     (long)(int)local_40 * 4 +
                                     (long)((local_2c - local_34) % 8) * 0x28) * 4 +
                       (long)local_30 * 0x28);
    if (param_3 != 0) {
      _printf("%2d  %d      %d     %d\n");
    }
    local_34 = local_34 + -1;
  }
                    // WARNING: Subroutine does not return
  ___assert_rtn("verhoeff","verhoeff-algorithm.c",0x24,"ni >= 0 && ni < 10");
}



undefined8 entry(ulong param_1)

{
  char *pcVar1;
  long lVar2;
  undefined *puVar3;
  uint uVar4;
  size_t sVar5;
  ulong uVar6;
  undefined auStack_80 [4];
  int local_7c;
  ulong local_78;
  long local_70;
  int local_68;
  int local_64;
  undefined *local_58;
  int local_4c;
  uint local_48;
  byte local_41;
  char *local_40;
  int local_38;
  undefined4 local_34;
  char *local_30 [3];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004018;
  local_34 = 0;
  local_30[1] = "12345";
  local_30[0] = "236";
  local_30[2] = "123456789012";
  puVar3 = auStack_80;
  for (local_38 = 0; local_38 < 3; local_38 = local_38 + 1) {
    local_40 = local_30[local_38];
    local_41 = local_38 < 2;
    local_48 = _verhoeff(local_40,0,local_41);
    uVar6 = (ulong)local_48;
    *(char **)(puVar3 + -0x10) = local_40;
    *(ulong *)(puVar3 + -8) = uVar6;
    _printf("\nThe check digit for \'%s\' is \'%d\'.\n");
    sVar5 = _strlen(local_40);
    local_4c = (int)sVar5;
    local_78 = (ulong)(local_4c + 2) + 0xf & 0xfffffffffffffff0;
    local_58 = puVar3;
    (*(code *)PTR____chkstk_darwin_100004008)();
    lVar2 = (long)puVar3 - local_78;
    local_70 = lVar2;
    param_1 = ___strncpy_chk(lVar2,local_40,(long)(local_4c + 2),0xffffffffffffffff);
    for (local_64 = 0; local_64 < 2; local_64 = local_64 + 1) {
      if (local_64 == 0) {
        local_7c = local_48 + 0x30;
      }
      else {
        local_7c = 0x39;
      }
      *(char *)(local_70 + local_4c) = (char)local_7c;
      local_68 = _verhoeff(local_70,1,local_41 & 1);
      pcVar1 = "correct";
      if (local_68 == 0) {
        pcVar1 = "incorrect";
      }
      *(long *)(lVar2 + -0x10) = local_70;
      *(char **)(lVar2 + -8) = pcVar1;
      uVar4 = _printf("\nThe validation for \'%s\' is %s.\n");
      param_1 = (ulong)uVar4;
    }
    puVar3 = local_58;
  }
  if (*(long *)PTR____stack_chk_guard_100004018 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003b4c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003b58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004010)();
  return;
}



void ___strncpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003b64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strncpy_chk_100004020)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b88. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004038)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h> /* for NaN */

enum fps_type {
        FPS_CONST = 0,
        FPS_ADD,
        FPS_SUB,
        FPS_MUL,
        FPS_DIV,
        FPS_DERIV,
        FPS_INT,
};

typedef struct fps_t *fps;
typedef struct fps_t {
        int type;
        fps s1, s2;
        double a0;
} fps_t;

fps fps_new()
{
        fps x = malloc(sizeof(fps_t));
        x->a0 = 0;
        x->s1 = x->s2 = 0;
        x->type = 0;
        return x;
}

/* language limit of C; when self or mutual recursive definition is needed,
 * one has to be defined, then defined again after it's used.  See how
 * sin and cos are defined this way below
 */
void fps_redefine(fps x, int op, fps y, fps z)
{
        x->type = op;
        x->s1 = y;
        x->s2 = z;
}

fps _binary(fps x, fps y, int op)
{
        fps s = fps_new();
        s->s1 = x;
        s->s2 = y;
        s->type = op;
        return s;
}

fps _unary(fps x, int op)
{
        fps s = fps_new();
        s->s1 = x;
        s->type = op;
        return s;
}

/* Taking the n-th term of series.  This is where actual work is done. */
double term(fps x, int n)
{
        double ret = 0;
        int i;

        switch (x->type) {
        case FPS_CONST: return n > 0 ? 0 : x->a0;
        case FPS_ADD:
                ret = term(x->s1, n) + term(x->s2, n); break;

        case FPS_SUB:
                ret = term(x->s1, n) - term(x->s2, n); break;

        case FPS_MUL:
                for (i = 0; i <= n; i++)
                        ret += term(x->s1, i) * term(x->s2, n - i);
                break;

        case FPS_DIV:
                if (! term(x->s2, 0)) return NAN;

                ret = term(x->s1, n);
                for (i = 1; i <= n; i++)
                        ret -= term(x->s2, i) * term(x, n - i) / term(x->s2, 0);
                break;

        case FPS_DERIV:
                ret = n * term(x->s1, n + 1);
                break;

        case FPS_INT:
                if (!n) return x->a0;
                ret = term(x->s1, n - 1) / n;
                break;

        default:
                fprintf(stderr, "Unknown operator %d\n", x->type);
                exit(1);
        }

        return ret;
}

#define _add(x, y) _binary(x, y, FPS_ADD)
#define _sub(x, y) _binary(x, y, FPS_SUB)
#define _mul(x, y) _binary(x, y, FPS_MUL)
#define _div(x, y) _binary(x, y, FPS_DIV)
#define _integ(x)  _unary(x, FPS_INT)
#define _deriv(x)  _unary(x, FPS_DERIV)

fps fps_const(double a0)
{
        fps x = fps_new();
        x->type = FPS_CONST;
        x->a0 = a0;
        return x;
}

int main()
{
        int i;
        fps one = fps_const(1);
        fps fcos = fps_new();           /* cosine */
        fps fsin = _integ(fcos);        /* sine */
        fps ftan = _div(fsin, fcos);    /* tangent */

        /* redefine cos to complete the mutual recursion; maybe it looks
         * better if I said
         *     *fcos = *( _sub(one, _integ(fsin)) );
         */
        fps_redefine(fcos, FPS_SUB, one, _integ(fsin));

        fps fexp = fps_const(1);        /* exponential */
        /* make exp recurse on self */
        fps_redefine(fexp, FPS_INT, fexp, 0);

        printf("Sin:");   for (i = 0; i < 10; i++) printf(" %g", term(fsin, i));
        printf("\nCos:"); for (i = 0; i < 10; i++) printf(" %g", term(fcos, i));
        printf("\nTan:"); for (i = 0; i < 10; i++) printf(" %g", term(ftan, i));
        printf("\nExp:"); for (i = 0; i < 10; i++) printf(" %g", term(fexp, i));

        return 0;
}
`,`#include "formal-power-series.h"



undefined4 * _fps_new(void)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)_malloc(0x20);
  *(undefined8 *)(puVar1 + 6) = 0;
  *(undefined8 *)(puVar1 + 4) = 0;
  *(undefined8 *)(puVar1 + 2) = 0;
  *puVar1 = 0;
  return puVar1;
}



void _fps_redefine(undefined4 *param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4)

{
  *param_1 = param_2;
  *(undefined8 *)(param_1 + 2) = param_3;
  *(undefined8 *)(param_1 + 4) = param_4;
  return;
}



undefined4 * __binary(undefined8 param_1,undefined8 param_2,undefined4 param_3)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)_fps_new();
  *(undefined8 *)(puVar1 + 2) = param_1;
  *(undefined8 *)(puVar1 + 4) = param_2;
  *puVar1 = param_3;
  return puVar1;
}



undefined4 * __unary(undefined8 param_1,undefined4 param_2)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)_fps_new();
  *(undefined8 *)(puVar1 + 2) = param_1;
  *puVar1 = param_2;
  return puVar1;
}



undefined  [16] _term(undefined4 *param_1,int param_2)

{
  undefined8 uVar1;
  undefined8 uVar2;
  double dVar3;
  double dVar4;
  double dVar5;
  undefined auVar6 [16];
  double local_48;
  int local_34;
  double local_30;
  double local_18;
  
  local_30 = 0.0;
  switch(*param_1) {
  case 0:
    if (param_2 < 1) {
      local_48 = *(double *)(param_1 + 6);
    }
    else {
      local_48 = 0.0;
    }
    local_18 = local_48;
    goto LAB_100003ca0;
  case 1:
    local_30 = (double)_term(*(undefined8 *)(param_1 + 2),param_2);
    dVar3 = (double)_term(*(undefined8 *)(param_1 + 4),param_2);
    local_30 = local_30 + dVar3;
    break;
  case 2:
    local_30 = (double)_term(*(undefined8 *)(param_1 + 2),param_2);
    dVar3 = (double)_term(*(undefined8 *)(param_1 + 4),param_2);
    local_30 = local_30 - dVar3;
    break;
  case 3:
    for (local_34 = 0; local_34 <= param_2; local_34 = local_34 + 1) {
      uVar1 = _term(*(undefined8 *)(param_1 + 2),local_34);
      uVar2 = _term(*(undefined8 *)(param_1 + 4),param_2 - local_34);
      local_30 = (double)NEON_fmadd(uVar1,uVar2,local_30);
    }
    break;
  case 4:
    dVar3 = (double)_term(*(undefined8 *)(param_1 + 4),0);
    if (dVar3 == 0.0) {
      local_18 = NAN;
      goto LAB_100003ca0;
    }
    local_30 = (double)_term(*(undefined8 *)(param_1 + 2),param_2);
    for (local_34 = 1; local_34 <= param_2; local_34 = local_34 + 1) {
      dVar3 = (double)_term(*(undefined8 *)(param_1 + 4),local_34);
      dVar4 = (double)_term(param_1,param_2 - local_34);
      dVar5 = (double)_term(*(undefined8 *)(param_1 + 4),0);
      local_30 = local_30 - (dVar3 * dVar4) / dVar5;
    }
    break;
  case 5:
    local_30 = (double)_term(*(undefined8 *)(param_1 + 2),param_2 + 1);
    local_30 = (double)(long)param_2 * local_30;
    break;
  case 6:
    if (param_2 == 0) {
      local_18 = *(double *)(param_1 + 6);
      goto LAB_100003ca0;
    }
    local_30 = (double)_term(*(undefined8 *)(param_1 + 2),param_2 + -1);
    local_30 = local_30 / (double)(long)param_2;
    break;
  default:
    _fprintf(*(FILE **)PTR____stderrp_100004000,"Unknown operator %d\n");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  local_18 = local_30;
LAB_100003ca0:
  auVar6._8_8_ = 0;
  auVar6._0_8_ = local_18;
  return auVar6;
}



undefined4 * _fps_const(undefined8 param_1)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)_fps_new();
  *puVar1 = 0;
  *(undefined8 *)(puVar1 + 6) = param_1;
  return puVar1;
}



undefined8 entry(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  undefined8 uVar4;
  undefined8 uVar5;
  int local_18;
  
  uVar1 = _fps_const();
  uVar2 = _fps_new();
  uVar3 = __unary(uVar2);
  uVar4 = __binary(uVar3,uVar2,4);
  uVar5 = __unary(uVar3,6);
  _fps_redefine(uVar2,2,uVar1,uVar5);
  uVar1 = _fps_const(0x3ff0000000000000);
  _fps_redefine(uVar1,6,uVar1,0);
  _printf("Sin:");
  for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
    _term(uVar3,local_18);
    _printf(" %g");
  }
  _printf("\nCos:");
  for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
    _term(uVar2,local_18);
    _printf(" %g");
  }
  _printf("\nTan:");
  for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
    _term(uVar4,local_18);
    _printf(" %g");
  }
  _printf("\nExp:");
  for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
    _term(uVar1,local_18);
    _printf(" %g");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004008)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int count = 0;
void solve(int n, int col, int *hist)
{
	if (col == n) {
		printf("\nNo. %d\n-----\n", ++count);
		for (int i = 0; i < n; i++, putchar('\n'))
			for (int j = 0; j < n; j++)
				putchar(j == hist[i] ? 'Q' : ((i + j) & 1) ? ' ' : '.');

		return;
	}

#	define attack(i, j) (hist[j] == i || abs(hist[j] - i) == col - j)
	for (int i = 0, j = 0; i < n; i++) {
		for (j = 0; j < col && !attack(i, j); j++);
		if (j < col) continue;

		hist[col] = i;
		solve(n, col + 1, hist);
	}
}

int main(int n, char **argv)
{
	if (n <= 1 || (n = atoi(argv[1])) <= 0) n = 8;
	int hist[n];
	solve(n, 0, hist);
}
`,`#include "n-queens-problem-2.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong _solve(ulong param_1,int param_2,long param_3)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int local_24;
  
  iVar2 = (int)param_1;
  if (param_2 == iVar2) {
    __count = __count + 1;
    uVar3 = _printf("\nNo. %d\n-----\n");
    local_24 = 0;
    while (param_1 = (ulong)uVar3, local_24 < iVar2) {
      for (local_28 = 0; local_28 < iVar2; local_28 = local_28 + 1) {
        if (local_28 == *(int *)(param_3 + (long)local_24 * 4)) {
          local_34 = 0x51;
        }
        else {
          local_34 = 0x20;
          if ((local_24 + local_28 & 1U) == 0) {
            local_34 = 0x2e;
          }
        }
        _putchar(local_34);
      }
      local_24 = local_24 + 1;
      uVar3 = _putchar(10);
    }
  }
  else {
    for (local_2c = 0; local_2c < iVar2; local_2c = local_2c + 1) {
      local_30 = 0;
      while( true ) {
        bVar1 = false;
        if (local_30 < param_2) {
          bVar1 = true;
          if (*(int *)(param_3 + (long)local_30 * 4) != local_2c) {
            uVar3 = _abs(*(int *)(param_3 + (long)local_30 * 4) - local_2c);
            param_1 = (ulong)uVar3;
            bVar1 = uVar3 == param_2 - local_30;
          }
          bVar1 = (bool)(bVar1 ^ 1);
        }
        if (!bVar1) break;
        local_30 = local_30 + 1;
      }
      if (param_2 <= local_30) {
        *(int *)(param_3 + (long)param_2 * 4) = local_2c;
        param_1 = _solve(iVar2,param_2 + 1,param_3);
      }
    }
  }
  return param_1;
}



undefined4 entry(int param_1,long param_2)

{
  undefined auStack_50 [8];
  ulong local_48;
  undefined4 local_3c;
  undefined *local_30;
  long local_28;
  uint local_20;
  undefined4 local_1c;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_1c = 0;
  local_28 = param_2;
  if ((param_1 < 2) ||
     (local_20 = param_1, local_20 = _atoi(*(char **)(param_2 + 8)), (int)local_20 < 1)) {
    local_20 = 8;
  }
  local_48 = (ulong)local_20 * 4 + 0xf & 0xfffffffffffffff0;
  local_30 = auStack_50;
  (*(code *)PTR____chkstk_darwin_100004000)();
  _solve(local_20,0);
  local_3c = local_1c;
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return local_1c;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _abs(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__abs_100004018)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004030)(param_1);
  return iVar1;
}


`
`#include <math.h>
#include <stdio.h>

const double K = 7.8e9;
const int n0 = 27;
const double actual[] = {
    27, 27, 27, 44, 44, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60,
    61, 61, 66, 83, 219, 239, 392, 534, 631, 897, 1350, 2023, 2820,
    4587, 6067, 7823, 9826, 11946, 14554, 17372, 20615, 24522, 28273,
    31491, 34933, 37552, 40540, 43105, 45177, 60328, 64543, 67103,
    69265, 71332, 73327, 75191, 75723, 76719, 77804, 78812, 79339,
    80132, 80995, 82101, 83365, 85203, 87024, 89068, 90664, 93077,
    95316, 98172, 102133, 105824, 109695, 114232, 118610, 125497,
    133852, 143227, 151367, 167418, 180096, 194836, 213150, 242364,
    271106, 305117, 338133, 377918, 416845, 468049, 527767, 591704,
    656866, 715353, 777796, 851308, 928436, 1000249, 1082054, 1174652
};
const size_t actual_size = sizeof(actual) / sizeof(double);

double f(double r) {
    double sq = 0;
    size_t i;
    for (i = 0; i < actual_size; ++i) {
        double eri = exp(r * i);
        double guess = (n0 * eri) / (1 + n0 * (eri - 1) / K);
        double diff = guess - actual[i];
        sq += diff * diff;
    }
    return sq;
}

double solve(double (*fn)(double), double guess, double epsilon) {
    double delta, f0, factor;
    for (delta = guess ? guess : 1, f0 = fn(guess), factor = 2;
        delta > epsilon && guess != guess - delta;
        delta *= factor) {
        double nf = (*fn)(guess - delta);
        if (nf < f0) {
            f0 = nf;
            guess -= delta;
        } else {
            nf = fn(guess + delta);
            if (nf < f0) {
                f0 = nf;
                guess += delta;
            } else {
                factor = 0.5;
            }
        }
    }
    return guess;
}

double solve_default(double (*fn)(double)) {
    return solve(fn, 0.5, 0);
}

int main() {
    double r = solve_default(f);
    double R0 = exp(12 * r);
    printf("r = %f, R0 = %f\n", r, R0);
    return 0;
}
`,`#include "logistic-curve-fitting-in-epidemiology.h"



undefined  [16] _f(double param_1)

{
  undefined auVar1 [16];
  double dVar2;
  ulong local_28;
  ulong local_20;
  
  local_20 = 0;
  for (local_28 = 0; local_28 < 0x61; local_28 = local_28 + 1) {
    dVar2 = (double)NEON_ucvtf(local_28);
    dVar2 = (double)_exp(param_1 * dVar2);
    dVar2 = (dVar2 * 27.0) / (((dVar2 - 1.0) * 27.0) / 7800000000.0 + 1.0) -
            *(double *)(&_actual + local_28 * 8);
    local_20 = NEON_fmadd(dVar2,dVar2,local_20);
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_20;
  return auVar1;
}



undefined  [16] _solve(double param_1,double param_2,code *param_3)

{
  bool bVar1;
  double dVar2;
  undefined auVar3 [16];
  undefined8 local_50;
  undefined8 local_40;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_20;
  
  local_50 = param_1;
  if (param_1 == 0.0) {
    local_50 = 1.0;
  }
  local_30 = local_50;
  local_38 = (double)(*param_3)(param_1);
  local_40 = 2.0;
  local_20 = param_1;
  while( true ) {
    bVar1 = false;
    if (param_2 < local_30) {
      bVar1 = local_20 != local_20 - local_30;
    }
    if (!bVar1) break;
    dVar2 = (double)(*param_3)(local_20 - local_30);
    if (local_38 <= dVar2) {
      dVar2 = (double)(*param_3)(local_20 + local_30);
      if (local_38 <= dVar2) {
        local_40 = 0.5;
      }
      else {
        local_20 = local_20 + local_30;
        local_38 = dVar2;
      }
    }
    else {
      local_20 = local_20 - local_30;
      local_38 = dVar2;
    }
    local_30 = local_30 * local_40;
  }
  auVar3._8_8_ = 0;
  auVar3._0_8_ = local_20;
  return auVar3;
}



void _solve_default(undefined8 param_1)

{
  _solve(0x3fe0000000000000,0,param_1);
  return;
}



undefined4 entry(void)

{
  double dVar1;
  
  dVar1 = (double)_solve_default(_f);
  _exp(dVar1 * 12.0);
  _printf("r = %f, R0 = %f\n");
  return 0;
}



void _exp(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003c58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exp_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003c64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

const char *haystack[] = {
  "Zig", "Zag", "Wally", "Ronald", "Bush", "Krusty", "Charlie",
  "Bush", "Boz", "Zag", NULL
};

int search_needle(const char *needle, const char **hs)
{
  int i = 0;
  while( hs[i] != NULL ) {
    if ( strcmp(hs[i], needle) == 0 ) return i;
    i++;
  }
  return -1;
}

int search_last_needle(const char *needle, const char **hs)
{
  int i, last=0;
  i = last = search_needle(needle, hs);
  if ( last < 0 ) return -1;
  while( hs[++i] != NULL ) {
    if ( strcmp(needle, hs[i]) == 0 ) {
      last = i;
    }
  }
  return last;
}

int main()
{
  printf("Bush is at %d\n", search_needle("Bush", haystack));
  if ( search_needle("Washington", haystack) == -1 )
    printf("Washington is not in the haystack\n");
  printf("First index for Zag: %d\n", search_needle("Zag", haystack));
  printf("Last index for Zag: %d\n", search_last_needle("Zag", haystack));
  return 0;
}
`,`#include "search-a-list.h"



int _search_needle(char *param_1,long param_2)

{
  int iVar1;
  int local_2c;
  
  local_2c = 0;
  while( true ) {
    if (*(long *)(param_2 + (long)local_2c * 8) == 0) {
      return -1;
    }
    iVar1 = _strcmp(*(char **)(param_2 + (long)local_2c * 8),param_1);
    if (iVar1 == 0) break;
    local_2c = local_2c + 1;
  }
  return local_2c;
}



int _search_last_needle(char *param_1,long param_2)

{
  int iVar1;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_14;
  
  local_2c = _search_needle(param_1,param_2);
  local_30 = local_2c;
  if (local_2c < 0) {
    local_14 = -1;
  }
  else {
    while (local_2c = local_2c + 1, *(long *)(param_2 + (long)local_2c * 8) != 0) {
      iVar1 = _strcmp(param_1,*(char **)(param_2 + (long)local_2c * 8));
      if (iVar1 == 0) {
        local_30 = local_2c;
      }
    }
    local_14 = local_30;
  }
  return local_14;
}



undefined8 entry(void)

{
  int iVar1;
  
  _search_needle("Bush");
  _printf("Bush is at %d\n");
  iVar1 = _search_needle("Washington",&_haystack);
  if (iVar1 == -1) {
    _printf("Washington is not in the haystack\n");
  }
  _search_needle();
  _printf("First index for Zag: %d\n");
  _search_last_needle("Zag",&_haystack);
  _printf("Last index for Zag: %d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void insertion_sort(int*, const size_t);

void insertion_sort(int *a, const size_t n) {
	for(size_t i = 1; i < n; ++i) {
		int key = a[i];
		size_t j = i;
		while( (j > 0) && (key < a[j - 1]) ) {
			a[j] = a[j - 1];
			--j;
		}
		a[j] = key;
	}
}

int main (int argc, char** argv) {

    int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};

    const size_t n = sizeof(a) / sizeof(a[0]) ;   // array extent

    for (size_t i = 0; i < n; i++)
        printf("%d%s", a[i], (i == (n - 1))? "\n" : " ");

    insertion_sort(a, n);

    for (size_t i = 0; i < n; i++)
        printf("%d%s", a[i], (i == (n - 1))? "\n" : " ");

    return 0;
}
`,`#include "sorting-algorithms-insertion-sort.h"



void _insertion_sort(long param_1,ulong param_2)

{
  bool bVar1;
  int iVar2;
  undefined8 local_28;
  undefined8 local_18;
  
  for (local_18 = 1; local_18 < param_2; local_18 = local_18 + 1) {
    iVar2 = *(int *)(param_1 + local_18 * 4);
    local_28 = local_18;
    while( true ) {
      bVar1 = false;
      if (local_28 != 0) {
        bVar1 = iVar2 < *(int *)(param_1 + (local_28 - 1) * 4);
      }
      if (!bVar1) break;
      *(undefined4 *)(param_1 + local_28 * 4) = *(undefined4 *)(param_1 + (local_28 - 1) * 4);
      local_28 = local_28 - 1;
    }
    *(int *)(param_1 + local_28 * 4) = iVar2;
  }
  return;
}



undefined8 entry(void)

{
  uint uVar1;
  ulong uVar2;
  ulong local_68;
  ulong local_60;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_40,&DAT_100003f6c,0x28);
  for (local_60 = 0; local_60 < 10; local_60 = local_60 + 1) {
    _printf("%d%s");
  }
  uVar2 = _insertion_sort(auStack_40,10);
  for (local_68 = 0; local_68 < 10; local_68 = local_68 + 1) {
    uVar1 = _printf("%d%s");
    uVar2 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

void binprint(unsigned int n, unsigned int m)
{
	char c[sizeof(n) * 8 + 1];
	int i = 0;
	while (m >>= 1)	c[i++] = n & m ? '#' : '-';
	c[i] = 0;
	puts(c);
}

int main(int c, char **v)
{
	unsigned int n, gap, left, right;
	if (c < 2 || ! (n = 1 << atoi(v[1]))) n = 16;

	for (gap = 2; gap < n; gap <<= 1)
		for (left = gap << 1; left < n; left |= left << 1)
			for (right = 1; right < gap; right++)
				binprint(left | right, n);

	return 0;
}
`,`#include "non-continuous-subsequences-2.h"



void _binprint(uint param_1,uint param_2)

{
  int iVar1;
  char cVar2;
  long lVar3;
  int local_48;
  uint local_44;
  char acStack_39 [33];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_48 = 0;
  local_44 = param_2;
  while (local_44 = local_44 >> 1, local_44 != 0) {
    cVar2 = '#';
    if ((param_1 & local_44) == 0) {
      cVar2 = '-';
    }
    lVar3 = (long)local_48;
    local_48 = local_48 + 1;
    acStack_39[lVar3] = cVar2;
  }
  acStack_39[local_48] = '\0';
  iVar1 = _puts(acStack_39);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined8 entry(int param_1,long param_2)

{
  uint uVar1;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  
  if (1 < param_1) {
    uVar1 = _atoi(*(char **)(param_2 + 8));
    local_24 = 1 << (ulong)(uVar1 & 0x1f);
    if (local_24 != 0) goto LAB_100003eb0;
  }
  local_24 = 0x10;
LAB_100003eb0:
  for (local_28 = 2; local_28 < local_24; local_28 = local_28 << 1) {
    for (local_2c = local_28 << 1; local_2c < local_24; local_2c = local_2c | local_2c << 1) {
      for (local_30 = 1; local_30 < local_28; local_30 = local_30 + 1) {
        _binprint(local_2c | local_30,local_24);
      }
    }
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

/* define a shuffle function. e.g. decl_shuffle(double).
 * advantage: compiler is free to optimize the swap operation without
 *            indirection with pointers, which could be much faster.
 * disadvantage: each datatype needs a separate instance of the function.
 *            for a small funciton like this, it's not very big a deal.
 */
#define decl_shuffle(type)				\
void shuffle_##type(type *list, size_t len) {		\
	int j;						\
	type tmp;					\
	while(len) {					\
		j = irand(len);				\
		if (j != len - 1) {			\
			tmp = list[j];			\
			list[j] = list[len - 1];	\
			list[len - 1] = tmp;		\
		}					\
		len--;					\
	}						\
}							\

/* random integer from 0 to n-1 */
int irand(int n)
{
	int r, rand_max = RAND_MAX - (RAND_MAX % n);
	/* reroll until r falls in a range that can be evenly
	 * distributed in n bins.  Unless n is comparable to
	 * to RAND_MAX, it's not *that* important really. */
	while ((r = rand()) >= rand_max);
	return r / (rand_max / n);
}

/* declare and define int type shuffle function from macro */
decl_shuffle(int);

int main()
{
	int i, x[20];

	for (i = 0; i < 20; i++) x[i] = i;
	for (printf("before:"), i = 0; i < 20 || !printf("\n"); i++)
		printf(" %d", x[i]);

	shuffle_int(x, 20);

	for (printf("after: "), i = 0; i < 20 || !printf("\n"); i++)
		printf(" %d", x[i]);
	return 0;
}
`,`#include "knuth-shuffle-2.h"



int _irand(int param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  iVar1 = 0;
  if (param_1 != 0) {
    iVar1 = 0x7fffffff / param_1;
  }
  iVar1 = 0x7fffffff - (0x7fffffff - iVar1 * param_1);
  do {
    iVar3 = _rand();
  } while (iVar1 <= iVar3);
  iVar2 = 0;
  if (param_1 != 0) {
    iVar2 = iVar1 / param_1;
  }
  iVar1 = 0;
  if (iVar2 != 0) {
    iVar1 = iVar3 / iVar2;
  }
  return iVar1;
}



void _shuffle_int(long param_1,long param_2)

{
  undefined4 uVar1;
  int iVar2;
  undefined8 local_20;
  
  for (local_20 = param_2; local_20 != 0; local_20 = local_20 + -1) {
    iVar2 = _irand(local_20);
    if ((long)iVar2 != local_20 + -1) {
      uVar1 = *(undefined4 *)(param_1 + (long)iVar2 * 4);
      *(undefined4 *)(param_1 + (long)iVar2 * 4) = *(undefined4 *)(param_1 + (local_20 + -1) * 4);
      *(undefined4 *)(param_1 + (local_20 + -1) * 4) = uVar1;
    }
  }
  return;
}



undefined8 entry(void)

{
  bool bVar1;
  int iVar2;
  int local_70;
  int aiStack_68 [20];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_70 = 0; local_70 < 0x14; local_70 = local_70 + 1) {
    aiStack_68[local_70] = local_70;
  }
  _printf("before:");
  local_70 = 0;
  while( true ) {
    bVar1 = true;
    if (0x13 < local_70) {
      iVar2 = _printf("\n");
      bVar1 = iVar2 == 0;
    }
    if (!bVar1) break;
    _printf(" %d");
    local_70 = local_70 + 1;
  }
  _shuffle_int(aiStack_68,0x14);
  iVar2 = _printf("after: ");
  local_70 = 0;
  while( true ) {
    bVar1 = true;
    if (0x13 < local_70) {
      iVar2 = _printf("\n");
      bVar1 = iVar2 == 0;
    }
    if (!bVar1) break;
    iVar2 = _printf(" %d");
    local_70 = local_70 + 1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004018)();
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char *split(char *str);
int main(int argc,char **argv)
{
	char input[13]="gHHH5YY++///\\";
	printf("%s\n",split(input));
}
char *split(char *str)
{
	char last=*str,*result=malloc(3*strlen(str)),*counter=result;
	for (char *c=str;*c;c++) {
		if (*c!=last) {
			strcpy(counter,", ");
			counter+=2;
			last=*c;
		}
		*counter=*c;
		counter++;
	}
	*(counter--)='\0';
	return realloc(result,strlen(result));
}
`,`#include "split-a-character-string-based-on-change-of-character.h"



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004008;
  _split();
  iVar1 = _printf("%s\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void _split(byte *param_1)

{
  size_t sVar1;
  byte *pbVar2;
  byte *local_38;
  byte *local_30;
  byte local_19;
  
  local_19 = *param_1;
  sVar1 = _strlen((char *)param_1);
  pbVar2 = (byte *)_malloc(sVar1 * 3);
  local_30 = pbVar2;
  for (local_38 = param_1; *local_38 != 0; local_38 = local_38 + 1) {
    if ((int)(char)*local_38 != (uint)local_19) {
      ___strcpy_chk(local_30,", ",0xffffffffffffffff);
      local_30 = local_30 + 2;
      local_19 = *local_38;
    }
    *local_30 = *local_38;
    local_30 = local_30 + 1;
  }
  *local_30 = 0;
  sVar1 = _strlen((char *)pbVar2);
  _realloc(pbVar2,sVar1);
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _realloc(void *param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__realloc_100004028)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004030)();
  return sVar1;
}


`
`#include <stdio.h>

/* yes, bubble sort */
void bubble_sort(int *idx, int n_idx, int *buf)
{
        int i, j, tmp;
#define for_ij for (i = 0; i < n_idx; i++) for (j = i + 1; j < n_idx; j++)
#define sort(a, b) if (a < b) { tmp = a; a = b; b = tmp;}
        for_ij { sort(idx[j], idx[i]);          }
        for_ij { sort(buf[idx[j]], buf[idx[i]]);}
#undef for_ij
#undef sort
}

int main()
{
        int values[] = {7, 6, 5, 4, 3, 2, 1, 0};
        int idx[] = {6, 1, 7};
        int i;

        printf("before sort:\n");
        for (i = 0; i < 8; i++)
                printf("%d ", values[i]);

        printf("\n\nafter sort:\n");
        bubble_sort(idx, 3, values);

        for (i = 0; i < 8; i++)
                printf("%d ", values[i]);
        printf("\n");

        return 0;
}
`,`#include "sort-disjoint-sublist.h"



void _bubble_sort(long param_1,int param_2,long param_3)

{
  undefined4 uVar1;
  undefined4 local_20;
  undefined4 local_1c;
  
  for (local_1c = 0; local_20 = local_1c, local_1c < param_2; local_1c = local_1c + 1) {
    while (local_20 = local_20 + 1, local_20 < param_2) {
      if (*(int *)(param_1 + (long)local_20 * 4) < *(int *)(param_1 + (long)local_1c * 4)) {
        uVar1 = *(undefined4 *)(param_1 + (long)local_20 * 4);
        *(undefined4 *)(param_1 + (long)local_20 * 4) =
             *(undefined4 *)(param_1 + (long)local_1c * 4);
        *(undefined4 *)(param_1 + (long)local_1c * 4) = uVar1;
      }
    }
  }
  for (local_1c = 0; local_20 = local_1c, local_1c < param_2; local_1c = local_1c + 1) {
    while (local_20 = local_20 + 1, local_20 < param_2) {
      if (*(int *)(param_3 + (long)*(int *)(param_1 + (long)local_20 * 4) * 4) <
          *(int *)(param_3 + (long)*(int *)(param_1 + (long)local_1c * 4) * 4)) {
        uVar1 = *(undefined4 *)(param_3 + (long)*(int *)(param_1 + (long)local_20 * 4) * 4);
        *(undefined4 *)(param_3 + (long)*(int *)(param_1 + (long)local_20 * 4) * 4) =
             *(undefined4 *)(param_3 + (long)*(int *)(param_1 + (long)local_1c * 4) * 4);
        *(undefined4 *)(param_3 + (long)*(int *)(param_1 + (long)local_1c * 4) * 4) = uVar1;
      }
    }
  }
  return;
}



undefined8 entry(void)

{
  int iVar1;
  int local_58;
  undefined8 local_50;
  undefined4 local_48;
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  undefined8 uStack_28;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_38 = 0x400000005;
  local_40 = 0x600000007;
  uStack_28 = 1;
  local_30 = 0x200000003;
  local_50 = 0x100000006;
  local_48 = 7;
  _printf("before sort:\n");
  for (local_58 = 0; local_58 < 8; local_58 = local_58 + 1) {
    _printf("%d ");
  }
  _printf("\n\nafter sort:\n");
  _bubble_sort(&local_50,3,&local_40);
  for (local_58 = 0; local_58 < 8; local_58 = local_58 + 1) {
    _printf("%d ");
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int main(int c, char *v[])
{
	int days[] = {31,29,31,30,31,30,31,31,30,31,30,31};
	int m, y, w;

	if (c < 2 || (y = atoi(v[1])) <= 1700) return 1;
 	days[1] -= (y % 4) || (!(y % 100) && (y % 400));
	w = y * 365 + (y - 1) / 4 - (y - 1) / 100 + (y - 1) / 400 + 6;

	for(m = 0; m < 12; m++) {
		w = (w + days[m]) % 7;
		printf("%d-%02d-%d\n", y, m + 1,
			days[m] + (w < 5 ? -2 : 5) - w);
	}

	return 0;
}
`,`#include "last-friday-of-each-month.h"



undefined4 entry(int param_1,long param_2)

{
  uint uVar1;
  void *pvVar2;
  uint local_6c;
  uint local_68;
  int local_5c;
  undefined4 local_4c;
  undefined auStack_48 [4];
  int local_44;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar2 = _memcpy(auStack_48,&DAT_100003f6c,0x30);
  if (1 < param_1) {
    uVar1 = _atoi(*(char **)(param_2 + 8));
    pvVar2 = (void *)(ulong)uVar1;
    if (0x6a4 < (int)uVar1) {
      local_68 = 1;
      if ((int)uVar1 % 4 == 0) {
        local_6c = 0;
        if ((int)uVar1 % 100 == 0) {
          local_6c = (uint)((int)uVar1 % 400 != 0);
        }
        local_68 = local_6c;
      }
      local_44 = local_44 - local_68;
      for (local_5c = 0; local_5c < 0xc; local_5c = local_5c + 1) {
        uVar1 = _printf("%d-%02d-%d\n");
        pvVar2 = (void *)(ulong)uVar1;
      }
      local_4c = 0;
      goto LAB_100003f00;
    }
  }
  local_4c = 1;
LAB_100003f00:
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return local_4c;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(pvVar2);
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f44. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`/* 2009-09-27 <kaz@kylheku.com> */
#define ANIMATE_VT100_POSIX
#include <stdio.h>
#include <string.h>
#ifdef ANIMATE_VT100_POSIX
#include <time.h>
#endif

char world_7x14[2][512] = {
  {
    "+-----------+\n"
    "|tH.........|\n"
    "|.   .      |\n"
    "|   ...     |\n"
    "|.   .      |\n"
    "|Ht.. ......|\n"
    "+-----------+\n"
  }
};

void next_world(const char *in, char *out, int w, int h)
{
  int i;

  for (i = 0; i < w*h; i++) {
    switch (in[i]) {
    case ' ': out[i] = ' '; break;
    case 't': out[i] = '.'; break;
    case 'H': out[i] = 't'; break;
    case '.': {
      int hc = (in[i-w-1] == 'H') + (in[i-w] == 'H') + (in[i-w+1] == 'H') +
               (in[i-1]   == 'H')                    + (in[i+1]   == 'H') +
               (in[i+w-1] == 'H') + (in[i+w] == 'H') + (in[i+w+1] == 'H');
      out[i] = (hc == 1 || hc == 2) ? 'H' : '.';
      break;
    }
    default:
      out[i] = in[i];
    }
  }
  out[i] = in[i];
}

int main()
{
  int f;

  for (f = 0; ; f = 1 - f) {
    puts(world_7x14[f]);
    next_world(world_7x14[f], world_7x14[1-f], 14, 7);
#ifdef ANIMATE_VT100_POSIX
    printf("\x1b[%dA", 8);
    printf("\x1b[%dD", 14);
    {
      static const struct timespec ts = { 0, 100000000 };
      nanosleep(&ts, 0);
    }
#endif
  }

  return 0;
}
`,`#include "wireworld.h"



void _next_world(long param_1,long param_2,int param_3,int param_4)

{
  char cVar1;
  undefined uVar2;
  int local_1c;
  
  for (local_1c = 0; local_1c < param_3 * param_4; local_1c = local_1c + 1) {
    cVar1 = *(char *)(param_1 + local_1c);
    if (cVar1 == ' ') {
      *(undefined *)(param_2 + local_1c) = 0x20;
    }
    else if (cVar1 == '.') {
      cVar1 = (*(char *)(param_1 + ((local_1c - param_3) + -1)) == 'H') +
              (*(char *)(param_1 + (local_1c - param_3)) == 'H') +
              (*(char *)(param_1 + ((local_1c - param_3) + 1)) == 'H') +
              (*(char *)(param_1 + (local_1c + -1)) == 'H') +
              (*(char *)(param_1 + (local_1c + 1)) == 'H') +
              (*(char *)(param_1 + (local_1c + param_3 + -1)) == 'H') +
              (*(char *)(param_1 + (local_1c + param_3)) == 'H') +
              (*(char *)(param_1 + (local_1c + param_3 + 1)) == 'H');
      uVar2 = 0x48;
      if (cVar1 != '\x01' && cVar1 != '\x02') {
        uVar2 = 0x2e;
      }
      *(undefined *)(param_2 + local_1c) = uVar2;
    }
    else if (cVar1 == 'H') {
      *(undefined *)(param_2 + local_1c) = 0x74;
    }
    else if (cVar1 == 't') {
      *(undefined *)(param_2 + local_1c) = 0x2e;
    }
    else {
      *(undefined *)(param_2 + local_1c) = *(undefined *)(param_1 + local_1c);
    }
  }
  *(undefined *)(param_2 + local_1c) = *(undefined *)(param_1 + local_1c);
  return;
}



void entry(void)

{
  int local_18;
  
  local_18 = 0;
  do {
    _puts(_world_7x14 + (long)local_18 * 0x200);
    _next_world(_world_7x14 + (long)local_18 * 0x200,_world_7x14 + (long)(1 - local_18) * 0x200,0xe,
                7);
    _printf("\x1b[%dA");
    _printf("\x1b[%dD");
    _nanosleep((timespec *)&DAT_100003f90,(timespec *)0x0);
    local_18 = 1 - local_18;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _nanosleep(timespec *param_1,timespec *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__nanosleep_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int main()
{
	int i;
	printf("<table style=\"text-align:center; border: 1px solid\"><th></th>"
		"<th>X</th><th>Y</th><th>Z</th>");
	for (i = 0; i < 4; i++) {
		printf("<tr><th>%d</th><td>%d</td><td>%d</td><td>%d</td></tr>", i,
			rand() % 10000, rand() % 10000, rand() % 10000);
	}
	printf("</table>");

	return 0;
}
`,`#include "create-an-html-table.h"



undefined8 entry(void)

{
  int local_18;
  
  _printf(
         "<table style=\"text-align:center; border: 1px solid\"><th></th><th>X</th><th>Y</th><th>Z</th>"
         );
  for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
    _rand();
    _rand();
    _rand();
    _printf("<tr><th>%d</th><td>%d</td><td>%d</td><td>%d</td></tr>");
  }
  _printf("</table>");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003efc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004008)();
  return iVar1;
}


`
`#include <stdio.h>

int main(void)
{
	int i, j, n = 12;

	for (j = 1; j <= n; j++) printf("%3d%c", j, j != n ? ' ' : '\n');
	for (j = 0; j <= n; j++) printf(j != n ? "----" : "+\n");

	for (i = 1; i <= n; i++) {
		for (j = 1; j <= n; j++)
			printf(j < i ? "    " : "%3d ", i * j);
                printf("| %d\n", i);
        }

	return 0;
}
`,`#include "multiplication-tables.h"



undefined8 entry(void)

{
  char *pcVar1;
  int local_1c;
  int local_18;
  
  for (local_1c = 1; local_1c < 0xd; local_1c = local_1c + 1) {
    _printf("%3d%c");
  }
  for (local_1c = 0; local_1c < 0xd; local_1c = local_1c + 1) {
    pcVar1 = "----";
    if (local_1c == 0xc) {
      pcVar1 = "+\n";
    }
    _printf(pcVar1);
  }
  for (local_18 = 1; local_18 < 0xd; local_18 = local_18 + 1) {
    for (local_1c = 1; local_1c < 0xd; local_1c = local_1c + 1) {
      pcVar1 = "    ";
      if (local_18 <= local_1c) {
        pcVar1 = "%3d ";
      }
      _printf(pcVar1);
    }
    _printf("| %d\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`/*
 * 99 Bottles, C, KISS (i.e. keep it simple and straightforward) version
 */

#include <stdio.h>

int main(void)
{
  int n;

  for( n = 99; n > 2; n-- )
    printf(
      "%d bottles of beer on the wall, %d bottles of beer.\n"
      "Take one down and pass it around, %d bottles of beer on the wall.\n\n",
       n, n, n - 1);

  printf(
      "2 bottles of beer on the wall, 2 bottles of beer.\n"
      "Take one down and pass it around, 1 bottle of beer on the wall.\n\n"

      "1 bottle of beer on the wall, 1 bottle of beer.\n"
      "Take one down and pass it around, no more bottles of beer on the wall.\n\n"

      "No more bottles of beer on the wall, no more bottles of beer.\n"
      "Go to the store and buy some more, 99 bottles of beer on the wall.\n");

      return 0;
}
`,`#include "99-bottles-of-beer-1.h"



undefined8 entry(void)

{
  int local_18;
  
  for (local_18 = 99; 2 < local_18; local_18 = local_18 + -1) {
    _printf(
           "%d bottles of beer on the wall, %d bottles of beer.\nTake one down and pass it around, %d bottles of beer on the wall.\n\n"
           );
  }
  _printf(
         "2 bottles of beer on the wall, 2 bottles of beer.\nTake one down and pass it around, 1 bottle of beer on the wall.\n\n1 bottle of beer on the wall, 1 bottle of beer.\nTake one down and pass it around, no more bottles of beer on the wall.\n\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\n"
         );
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dbc. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <math.h>
#include <stdio.h>
#include <assert.h>

int nonsqr(int n) {
    return n + (int)(0.5 + sqrt(n));
    /* return n + (int)round(sqrt(n)); in C99 */
}

int main() {
    int i;

    /* first 22 values (as a list) has no squares: */
    for (i = 1; i < 23; i++)
        printf("%d ", nonsqr(i));
    printf("\n");

    /* The following check shows no squares up to one million: */
    for (i = 1; i < 1000000; i++) {
        double j = sqrt(nonsqr(i));
        assert(j != floor(j));
    }
    return 0;
}
`,`#include "sequence-of-non-squares.h"



int _nonsqr(int param_1)

{
  return param_1 + (int)(SQRT((double)(long)param_1) + 0.5);
}



undefined8 entry(void)

{
  int iVar1;
  int local_18;
  
  for (local_18 = 1; local_18 < 0x17; local_18 = local_18 + 1) {
    _nonsqr(local_18);
    _printf("%d ");
  }
  _printf("\n");
  local_18 = 1;
  while( true ) {
    if (999999 < local_18) {
      return 0;
    }
    iVar1 = _nonsqr(local_18);
    if (SQRT((double)iVar1) == (double)(long)SQRT((double)iVar1)) break;
    local_18 = local_18 + 1;
  }
                    // WARNING: Subroutine does not return
  ___assert_rtn("main","sequence-of-non-squares.c",0x15,"j != floor(j)");
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#define EMPTY_TILE 0
#define ROWS 4
#define COLUMNS 4


/*
 *                                     GENERAL CONCEPT
 *
 * How do you add up tiles when there is whitespace between them?
 * You sort the array so that there are no empty tiles between them while stacking them all to one side
 * then the addition function always adds up from left to right or up to bottom. It does not care
 * about the left movements or the down movement. This can be achieved by reversing the array
 * whenever the player chooses to move to the right or down, when the addition is finished
 * the array gets reversed back and its like it had been added from right to left or bottom to top
 * When the addition is done, the program scans for the number of empty tiles and uses that
 * in its selection of the next tile to be filled. 10% of times a tile gets occupied with a 4
 *
*/



/*
 * the remove_whitespace functions; it is pretty clear what they do.
 * they use a bubble short algorith to move the 0's or empty tiles to the end of the array
 * depending on the direction moved (without carring about going right or up
 *
*/

void remove_whitespace_horizontaly(int board[ROWS][COLUMNS], int rows, int columns)
{
  int a = columns;
  int tmp;


  for (; a < COLUMNS - 1; ++a) {
    tmp = board[rows][a];
    board[rows][a] = board[rows][a+1];
    board[rows][a+1] = tmp;
  }
}

void remove_whitespace_verticaly(int board[ROWS][COLUMNS], int columns, int rows)
{
  int a = rows;
  int tmp;

  for (; a < ROWS - 1; ++a) {
    tmp = board[a][columns];
    board[a][columns] = board[a+1][columns];
    board[a+1][columns] = tmp;
  }
}

/*
 * the add_tiles functions. those functions do the heavy work of adding the tiles and
 * taking care of special situations such as when adding two equal tiles a 0 gets generated
 * they are quite difficult to understand i think (which means not that you need to be too clever
 * but that i have done a poor job of creating them) and it took around 4 hours to get the
 * proper result
*/

void add_tiles_horizontaly(int board[ROWS][COLUMNS])
{
  int a, b, flag;

  for (a = 0; a < ROWS; ++a) {
    for (b = 0, flag = 0; b < COLUMNS - 1 && flag != 4; ++b) {
      if (board[a][b] == EMPTY_TILE) {
	remove_whitespace_horizontaly(board, a, b);
	--b;
	++flag;
      }
      else {
	if (board[a][b+1] == EMPTY_TILE) {
	  board[a][b+1] = board[a][b];
	  board[a][b] = EMPTY_TILE;
	  --b;
	} else if (board[a][b] == board[a][b+1]) {
	  board[a][b] += board[a][b+1];
	  board[a][b+1] = EMPTY_TILE;
	}
      }
    }
  }
}

void add_tiles_verticaly(int board[ROWS][COLUMNS])
{
  int a, b, flag;

  for (a = 0; a < COLUMNS; ++a) {
    for (b = 0, flag = 0; b < ROWS-1 && flag != 4; ++b) {
      if (board[b][a] == EMPTY_TILE) {
	remove_whitespace_verticaly(board, a, b);
	--b;
	++flag;
      }
      else {
	if (board[b+1][a] == EMPTY_TILE) {
	  board[b+1][a] = board[b][a];
	  board[b][a] = EMPTY_TILE;
	  --b;
	} else if (board[b][a] == board[b+1][a]) {
	  board[b][a] += board[b+1][a];
	  board[b+1][a] = EMPTY_TILE;
	}
      }
    }
  }
}
	
/*
 * ... print the board
 */

void print_board(int board[ROWS][COLUMNS])
{
  int a, b;

  for (a = 0; a < ROWS; ++a) {
    printf("\n");
    for (b = 0; b < COLUMNS; ++b) {
      printf("%5i", board[a][b]);
    }
  }
  printf("\n");
}

/*
 * The reverse_board function reverses the array
 * if the movement is right or down reverse the array
*/

void reverse_board(char input[], int board[ROWS][COLUMNS])
{
  int a, b, c, tmp;

  if (!strcmp(input, "right")) {
    for (a = 0; a < ROWS; ++a) {
      for (b = 0, c = 3; b < 2; ++b, --c) {
	tmp = board[a][b];
	board[a][b] = board[a][c];
	board[a][c] = tmp;
      }
    }
  }
  else if  (!strcmp(input, "down")) {
    for (a = 0; a < COLUMNS; ++a) {
      for (b = 0, c = 3; b < 2; ++b, --c) {
	tmp = board[b][a];
	board[b][a] = board[c][a];
	board[c][a] = tmp;
      }
    }
  }
}

/*
 * the check_board function is the one which evaluates the win or lose condition
 * for each turn and at the same time providing the number of empty tiles for the random generator
 * function
*/

int check_board (int board[ROWS][COLUMNS])
{
  int a, b;

  int result = 0;
  int empty_tiles = 0;


  for (a = 0; a < ROWS; ++a)
    for (b = 0; b < COLUMNS; ++b)
      if (board[a][b] == 2048)
	result = -1;
      else if (board[a][b] == EMPTY_TILE)
	++empty_tiles;

  result = result == -1 ? result : empty_tiles;

  return result;
}

/*
 * the generate_random functin generates a random number between 0 and the number of
 * empty tiles. the generated number will assign to the Nth empty tile = (random_number)
 * the new value, it also takes care of the 10% chance for producing a 4 tile
*/

void generate_random(int board[ROWS][COLUMNS], int empty_tiles )
{

  srand(time(NULL));

  int a, b;
  int random = 0;
  int tile = 0;

  random = rand() % empty_tiles;
  tile = (rand() % 9 == 4) ? 4 : 2;

  for (a = 0; a < ROWS; ++a)
    for (b = 0; b < COLUMNS; ++b)
      if (board[a][b] == EMPTY_TILE && random != 0)
	--random;
      else if (board[a][b] == EMPTY_TILE && random == 0) {
	board[a][b] = tile;
	return;
      }
}

/*
 * infinite loop, get the movements or exit code and act accordingly
*/

int play_game(int board[ROWS][COLUMNS])
{

  char movement[81];
  int tiles = 0;

  printf("this is the 2048 game\n"					\
	 "The goal of this game is make a tile reach the value of 2048\n"\
	 "The board starts of with only one occupied tile.\n"\
	 "On each round a new tile gets added with the value of 2\n"\
	 "or at 10%% of the times with the value of 4\n"\
	 "If you run out of tiles you lose\n"\
	 "There are 4 movements you can supply to the game\n"\
	 "right, left, up, and down.\n"\
	 "For each of this movements the tiles move to the direction specified\n"\
	 "If two tiles have the same value the get added up just once.\n"\
	 "If 2 occupied tiles share the same row or column but are seperated by empty tiles\n"\
	 "then the occupied tiles travel along the empty tiles stacking in the direction\n"\
	 "they were directed\n"\
	 "For a more visual explanation you can check the wikipedia entry\n"
	 " if you search for 2058 board game\n"	\
	 "Here we go\n");

  print_board(board);
  while (1) {
    printf("(enter: left,right,up,down,exit)>> ");
    scanf("%s", movement);
    if (!strcmp(movement, "down")) {
      reverse_board(movement,board);
      add_tiles_verticaly(board);
      tiles = check_board(board);
      if (tiles == -1)
	return -1;
      else if (tiles == 0)
	return 0;
      generate_random(board,tiles);
      reverse_board(movement, board);
    }
    else if (!strcmp(movement, "up")) {
      add_tiles_verticaly(board);
      tiles = check_board(board);
      if (tiles == -1)
	return -1;
      else if (tiles == 0)
	return 0;
      generate_random(board,tiles);
    }
    else if (!strcmp(movement, "right")) {
      reverse_board(movement,board);
      add_tiles_horizontaly(board);
      tiles = check_board(board);
      if (tiles == -1)
	return -1;
      else if (tiles == 0)
	return 0;
      generate_random(board,tiles);
      reverse_board(movement, board);
    }
    else if (!strcmp(movement, "left")) {
      add_tiles_horizontaly(board);
      tiles = check_board(board);
      if (tiles == -1)
	return -1;
      else if (tiles == 0)
	return 0;
      generate_random(board,tiles);
    }
    else if (!strcmp(movement, "exit")) {
      return 1;
    }
    else {
      printf("Do not recognize this movement please type again\n");
      continue;
    }
    print_board(board);
  }
}


int main(void)
{
  int play_game(int board[ROWS][COLUMNS]);
  void generate_random(int board[ROWS][COLUMNS], int empty_tiles );
  int check_board (int board[ROWS][COLUMNS]);
  void reverse_board(char input[], int board[ROWS][COLUMNS]);
  void print_board(int board[ROWS][COLUMNS]);
  void add_tiles_verticaly(int board[ROWS][COLUMNS]);
  void add_tiles_horizontaly(int board[ROWS][COLUMNS]);
  void remove_whitespace_verticaly(int board[ROWS][COLUMNS], int columns, int rows);
  void remove_whitespace_horizontaly(int board[ROWS][COLUMNS], int rows, int columns);

  int win_condition;
  int board[ROWS][COLUMNS] = {
    {0,0,0,0},
    {0,0,0,0},
    {0,0,0,0},
    {0,0,0,0}
  };


  generate_random(board, 16); /* initialize the board */

  win_condition = play_game(board);
  switch (win_condition) {
  case 1:
    printf("But you are not done yet!!!\n"	\
	   "Fine, see you another day\n");
    break;
  case 0:
    printf("Ohh noo, you run out of tiles\n"	\
	   "Run me agan to play some more\n"	\
	   "Byyyeee\n");
    break;
  case -1:
    printf("WooooW you did it, Good job!!!\n"	\
	   "See ya later homie\n");
    break;
  }

  return 0;
}
`,`#include "2048-2.h"



void _remove_whitespace_horizontaly(long param_1,int param_2,int param_3)

{
  undefined4 uVar1;
  undefined4 local_14;
  
  for (local_14 = param_3; local_14 < 3; local_14 = local_14 + 1) {
    uVar1 = *(undefined4 *)(param_1 + (long)param_2 * 0x10 + (long)local_14 * 4);
    *(undefined4 *)(param_1 + (long)param_2 * 0x10 + (long)local_14 * 4) =
         *(undefined4 *)(param_1 + (long)param_2 * 0x10 + (long)(local_14 + 1) * 4);
    *(undefined4 *)(param_1 + (long)param_2 * 0x10 + (long)(local_14 + 1) * 4) = uVar1;
  }
  return;
}



void _remove_whitespace_verticaly(long param_1,int param_2,int param_3)

{
  undefined4 uVar1;
  undefined4 local_14;
  
  for (local_14 = param_3; local_14 < 3; local_14 = local_14 + 1) {
    uVar1 = *(undefined4 *)(param_1 + (long)local_14 * 0x10 + (long)param_2 * 4);
    *(undefined4 *)(param_1 + (long)local_14 * 0x10 + (long)param_2 * 4) =
         *(undefined4 *)(param_1 + (long)(local_14 + 1) * 0x10 + (long)param_2 * 4);
    *(undefined4 *)(param_1 + (long)(local_14 + 1) * 0x10 + (long)param_2 * 4) = uVar1;
  }
  return;
}



void _add_tiles_horizontaly(long param_1)

{
  int *piVar1;
  int local_24;
  int local_20;
  int local_1c;
  
  for (local_1c = 0; local_1c < 4; local_1c = local_1c + 1) {
    local_24 = 0;
    for (local_20 = 0; local_20 < 3 && local_24 != 4; local_20 = local_20 + 1) {
      if (*(int *)(param_1 + (long)local_1c * 0x10 + (long)local_20 * 4) == 0) {
        _remove_whitespace_horizontaly(param_1,local_1c,local_20);
        local_20 = local_20 + -1;
        local_24 = local_24 + 1;
      }
      else if (*(int *)(param_1 + (long)local_1c * 0x10 + (long)(local_20 + 1) * 4) == 0) {
        *(undefined4 *)(param_1 + (long)local_1c * 0x10 + (long)(local_20 + 1) * 4) =
             *(undefined4 *)(param_1 + (long)local_1c * 0x10 + (long)local_20 * 4);
        *(undefined4 *)(param_1 + (long)local_1c * 0x10 + (long)local_20 * 4) = 0;
        local_20 = local_20 + -1;
      }
      else if (*(int *)(param_1 + (long)local_1c * 0x10 + (long)local_20 * 4) ==
               *(int *)(param_1 + (long)local_1c * 0x10 + (long)(local_20 + 1) * 4)) {
        piVar1 = (int *)(param_1 + (long)local_1c * 0x10 + (long)local_20 * 4);
        *piVar1 = *piVar1 + *(int *)(param_1 + (long)local_1c * 0x10 + (long)(local_20 + 1) * 4);
        *(undefined4 *)(param_1 + (long)local_1c * 0x10 + (long)(local_20 + 1) * 4) = 0;
      }
    }
  }
  return;
}



void _add_tiles_verticaly(long param_1)

{
  int *piVar1;
  int local_24;
  int local_20;
  int local_1c;
  
  for (local_1c = 0; local_1c < 4; local_1c = local_1c + 1) {
    local_24 = 0;
    for (local_20 = 0; local_20 < 3 && local_24 != 4; local_20 = local_20 + 1) {
      if (*(int *)(param_1 + (long)local_20 * 0x10 + (long)local_1c * 4) == 0) {
        _remove_whitespace_verticaly(param_1,local_1c,local_20);
        local_20 = local_20 + -1;
        local_24 = local_24 + 1;
      }
      else if (*(int *)(param_1 + (long)(local_20 + 1) * 0x10 + (long)local_1c * 4) == 0) {
        *(undefined4 *)(param_1 + (long)(local_20 + 1) * 0x10 + (long)local_1c * 4) =
             *(undefined4 *)(param_1 + (long)local_20 * 0x10 + (long)local_1c * 4);
        *(undefined4 *)(param_1 + (long)local_20 * 0x10 + (long)local_1c * 4) = 0;
        local_20 = local_20 + -1;
      }
      else if (*(int *)(param_1 + (long)local_20 * 0x10 + (long)local_1c * 4) ==
               *(int *)(param_1 + (long)(local_20 + 1) * 0x10 + (long)local_1c * 4)) {
        piVar1 = (int *)(param_1 + (long)local_20 * 0x10 + (long)local_1c * 4);
        *piVar1 = *piVar1 + *(int *)(param_1 + (long)(local_20 + 1) * 0x10 + (long)local_1c * 4);
        *(undefined4 *)(param_1 + (long)(local_20 + 1) * 0x10 + (long)local_1c * 4) = 0;
      }
    }
  }
  return;
}



int _print_board(void)

{
  int iVar1;
  int local_20;
  int local_1c;
  
  for (local_1c = 0; local_1c < 4; local_1c = local_1c + 1) {
    _printf("\n");
    for (local_20 = 0; local_20 < 4; local_20 = local_20 + 1) {
      _printf("%5i");
    }
  }
  iVar1 = _printf("\n");
  return iVar1;
}



void _reverse_board(char *param_1,long param_2)

{
  undefined4 uVar1;
  int iVar2;
  int local_2c;
  int local_28;
  int local_24;
  
  iVar2 = _strcmp(param_1,"right");
  if (iVar2 == 0) {
    for (local_24 = 0; local_24 < 4; local_24 = local_24 + 1) {
      local_2c = 3;
      for (local_28 = 0; local_28 < 2; local_28 = local_28 + 1) {
        uVar1 = *(undefined4 *)(param_2 + (long)local_24 * 0x10 + (long)local_28 * 4);
        *(undefined4 *)(param_2 + (long)local_24 * 0x10 + (long)local_28 * 4) =
             *(undefined4 *)(param_2 + (long)local_24 * 0x10 + (long)local_2c * 4);
        *(undefined4 *)(param_2 + (long)local_24 * 0x10 + (long)local_2c * 4) = uVar1;
        local_2c = local_2c + -1;
      }
    }
  }
  else {
    iVar2 = _strcmp(param_1,"down");
    if (iVar2 == 0) {
      for (local_24 = 0; local_24 < 4; local_24 = local_24 + 1) {
        local_2c = 3;
        for (local_28 = 0; local_28 < 2; local_28 = local_28 + 1) {
          uVar1 = *(undefined4 *)(param_2 + (long)local_28 * 0x10 + (long)local_24 * 4);
          *(undefined4 *)(param_2 + (long)local_28 * 0x10 + (long)local_24 * 4) =
               *(undefined4 *)(param_2 + (long)local_2c * 0x10 + (long)local_24 * 4);
          *(undefined4 *)(param_2 + (long)local_2c * 0x10 + (long)local_24 * 4) = uVar1;
          local_2c = local_2c + -1;
        }
      }
    }
  }
  return;
}



int _check_board(long param_1)

{
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 local_c;
  
  local_14 = 0;
  local_18 = 0;
  for (local_c = 0; local_c < 4; local_c = local_c + 1) {
    for (local_10 = 0; local_10 < 4; local_10 = local_10 + 1) {
      if (*(int *)(param_1 + (long)local_c * 0x10 + (long)local_10 * 4) == 0x800) {
        local_14 = -1;
      }
      else if (*(int *)(param_1 + (long)local_c * 0x10 + (long)local_10 * 4) == 0) {
        local_18 = local_18 + 1;
      }
    }
  }
  if (local_14 == -1) {
    local_1c = local_14;
  }
  else {
    local_1c = local_18;
  }
  return local_1c;
}



void _generate_random(long param_1,int param_2)

{
  int iVar1;
  time_t tVar2;
  undefined4 uVar3;
  int local_28;
  int local_24;
  int local_20;
  
  tVar2 = _time((time_t *)0x0);
  _srand((uint)tVar2);
  local_28 = _rand();
  iVar1 = 0;
  if (param_2 != 0) {
    iVar1 = local_28 / param_2;
  }
  local_28 = local_28 - iVar1 * param_2;
  iVar1 = _rand();
  uVar3 = 4;
  if (iVar1 % 9 != 4) {
    uVar3 = 2;
  }
  local_20 = 0;
  do {
    if (3 < local_20) {
      return;
    }
    for (local_24 = 0; local_24 < 4; local_24 = local_24 + 1) {
      if ((*(int *)(param_1 + (long)local_20 * 0x10 + (long)local_24 * 4) == 0) && (local_28 != 0))
      {
        local_28 = local_28 + -1;
      }
      else if ((*(int *)(param_1 + (long)local_20 * 0x10 + (long)local_24 * 4) == 0) &&
              (local_28 == 0)) {
        *(undefined4 *)(param_1 + (long)local_20 * 0x10 + (long)local_24 * 4) = uVar3;
        return;
      }
    }
    local_20 = local_20 + 1;
  } while( true );
}



undefined4 _play_game(undefined8 param_1)

{
  int iVar1;
  undefined4 local_70;
  char acStack_69 [81];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _printf(
         "this is the 2048 game\nThe goal of this game is make a tile reach the value of 2048\nThe board starts of with only one occupied tile.\nOn each round a new tile gets added with the value of 2\nor at 10%% of the times with the value of 4\nIf you run out of tiles you lose\nThere are 4 movements you can supply to the game\nright, left, up, and down.\nFor each of this movements the tiles move to the direction specified\nIf two tiles have the same value the get added up just once.\nIf 2 occupied tiles share the same row or column but are seperated by empty tiles\nthen the occupied tiles travel along the empty tiles stacking in the direction\nthey were directed\nFor a more visual explanation you can check the wikipedia entry\n if you search for 2058 board game\nHere we go\n"
         );
  _print_board(param_1);
  do {
    while( true ) {
      _printf("(enter: left,right,up,down,exit)>> ");
      _scanf("%s");
      iVar1 = _strcmp(acStack_69,"down");
      if (iVar1 != 0) break;
      _reverse_board(acStack_69,param_1);
      _add_tiles_verticaly(param_1);
      iVar1 = _check_board(param_1);
      if (iVar1 == -1) {
        local_70 = 0xffffffff;
        goto LAB_1000039ec;
      }
      if (iVar1 == 0) {
        local_70 = 0;
        goto LAB_1000039ec;
      }
      _generate_random(param_1,iVar1);
      _reverse_board(acStack_69,param_1);
LAB_1000039e0:
      _print_board(param_1);
    }
    iVar1 = _strcmp(acStack_69,"up");
    if (iVar1 == 0) {
      _add_tiles_verticaly(param_1);
      iVar1 = _check_board(param_1);
      if (iVar1 == -1) {
        local_70 = 0xffffffff;
      }
      else {
        if (iVar1 != 0) {
          _generate_random(param_1,iVar1);
          goto LAB_1000039e0;
        }
        local_70 = 0;
      }
      goto LAB_1000039ec;
    }
    iVar1 = _strcmp(acStack_69,"right");
    if (iVar1 == 0) {
      _reverse_board(acStack_69,param_1);
      _add_tiles_horizontaly(param_1);
      iVar1 = _check_board(param_1);
      if (iVar1 == -1) {
        local_70 = 0xffffffff;
      }
      else {
        if (iVar1 != 0) {
          _generate_random(param_1,iVar1);
          _reverse_board(acStack_69,param_1);
          goto LAB_1000039e0;
        }
        local_70 = 0;
      }
      goto LAB_1000039ec;
    }
    iVar1 = _strcmp(acStack_69,"left");
    if (iVar1 == 0) {
      _add_tiles_horizontaly(param_1);
      iVar1 = _check_board(param_1);
      if (iVar1 == -1) {
        local_70 = 0xffffffff;
      }
      else {
        if (iVar1 != 0) {
          _generate_random(param_1,iVar1);
          goto LAB_1000039e0;
        }
        local_70 = 0;
      }
      goto LAB_1000039ec;
    }
    iVar1 = _strcmp(acStack_69,"exit");
    if (iVar1 == 0) {
      local_70 = 1;
LAB_1000039ec:
      if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
        return local_70;
      }
                    // WARNING: Subroutine does not return
      ___stack_chk_fail();
    }
    _printf("Do not recognize this movement please type again\n");
  } while( true );
}



undefined8 entry(void)

{
  int iVar1;
  uint uVar2;
  ulong uVar3;
  undefined auStack_58 [64];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memset(auStack_58,0,0x40);
  _generate_random(auStack_58,0x10);
  uVar3 = _play_game(auStack_58);
  iVar1 = (int)uVar3;
  if (iVar1 == -1) {
    uVar2 = _printf("WooooW you did it, Good job!!!\nSee ya later homie\n");
    uVar3 = (ulong)uVar2;
  }
  else if (iVar1 == 0) {
    uVar2 = _printf("Ohh noo, you run out of tiles\nRun me agan to play some more\nByyyeee\n");
    uVar3 = (ulong)uVar2;
  }
  else if (iVar1 == 1) {
    uVar2 = _printf("But you are not done yet!!!\nFine, see you another day\n");
    uVar3 = (ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar3);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003b20. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b2c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004010)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b44. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004020)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b50. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003b5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004030)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b74. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004040)();
  return tVar1;
}


`
`#include<stdio.h>

void generateGaps(unsigned long long int start,int count){

    int counter = 0;
    unsigned long long int i = start;
    char str[100];

    printf("\nFirst %d Gapful numbers >= %llu :\n",count,start);

    while(counter<count){
        sprintf(str,"%llu",i);
        if((i%(10*(str[0]-'0') + i%10))==0L){
            printf("\n%3d : %llu",counter+1,i);
            counter++;
        }
        i++;
    }
}

int main()
{
    unsigned long long int i = 100;
    int count = 0;
    char str[21];

    generateGaps(100,30);
    printf("\n");
    generateGaps(1000000,15);
    printf("\n");
    generateGaps(1000000000,15);
    printf("\n");

    return 0;
}
`,`#include "gapful-numbers.h"



void _generateGaps(ulong param_1,int param_2)

{
  ulong uVar1;
  ulong uVar2;
  uint uVar3;
  ulong uVar4;
  ulong local_98;
  int local_90;
  char local_7c [100];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_90 = 0;
  uVar3 = _printf("\nFirst %d Gapful numbers >= %llu :\n");
  uVar4 = (ulong)uVar3;
  local_98 = param_1;
  while (local_90 < param_2) {
    uVar4 = ___sprintf_chk(local_7c,0,100,"%llu");
    uVar1 = local_98 % 10 + (long)((local_7c[0] + -0x30) * 10);
    uVar2 = 0;
    if (uVar1 != 0) {
      uVar2 = local_98 / uVar1;
    }
    if (local_98 == uVar2 * uVar1) {
      uVar3 = _printf("\n%3d : %llu");
      uVar4 = (ulong)uVar3;
      local_90 = local_90 + 1;
    }
    local_98 = local_98 + 1;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(uVar4);
}



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004010;
  _generateGaps(100,0x1e);
  _printf("\n");
  _generateGaps(1000000);
  _printf("\n");
  _generateGaps(1000000000,0xf);
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004010 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___sprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____sprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
    const char *fruit[2] = { "apples", "oranges" };

    // Acquire the length of the array by dividing the size of all elements (found
    // with sizeof(fruit)) by the size of the first element.

    // Note that since the array elements are pointers to null-terminated character
    // arrays, the size of the first element is actually the size of the pointer
    // type - not the length of the string.

    // This size, regardless of the type being pointed to, is 8 bytes, 4 bytes, or
    // 2 bytes on 64-bit, 32-bit, or 16-bit platforms respectively.
    int length = sizeof(fruit) / sizeof(fruit[0]);

    printf("%d\n", length);

    return 0;
}
`,`#include "array-length-1.h"



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004008;
  iVar1 = _printf("%d\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct sCarpet {
    int dim;      // dimension
    char *data;   // character data
    char **rows;  // pointers to data rows
} *Carpet;

/* Clones a tile into larger carpet, or blank if center */
void TileCarpet( Carpet d, int r, int c, Carpet tile )
{
    int y0 = tile->dim*r;
    int x0 = tile->dim*c;
    int k,m;

    if ((r==1) && (c==1)) {
        for(k=0; k < tile->dim; k++) {
           for (m=0; m < tile->dim; m++) {
               d->rows[y0+k][x0+m] = ' ';
           }
        }
    }
    else {
        for(k=0; k < tile->dim; k++) {
           for (m=0; m < tile->dim; m++) {
               d->rows[y0+k][x0+m] = tile->rows[k][m];
           }
        }
    }
}

/* define a 1x1 starting carpet */
static char s1[]= "#";
static char *r1[] = {s1};
static struct sCarpet single = { 1, s1, r1};

Carpet Sierpinski( int n )
{
   Carpet carpet;
   Carpet subCarpet;
   int row,col, rb;
   int spc_rqrd;

   subCarpet = (n > 1) ? Sierpinski(n-1) : &single;

   carpet = malloc(sizeof(struct sCarpet));
   carpet->dim = 3*subCarpet->dim;
   spc_rqrd = (2*subCarpet->dim) * (carpet->dim);
   carpet->data = malloc(spc_rqrd*sizeof(char));
   carpet->rows = malloc( carpet->dim*sizeof(char *));
   for (row=0; row<subCarpet->dim; row++) {
       carpet->rows[row] = carpet->data + row*carpet->dim;
       rb = row+subCarpet->dim;
       carpet->rows[rb] = carpet->data + rb*carpet->dim;
       rb = row+2*subCarpet->dim;
       carpet->rows[rb] = carpet->data + row*carpet->dim;
   }

    for (col=0; col < 3; col++) {
      /* 2 rows of tiles to copy - third group points to same data a first */
      for (row=0; row < 2; row++)
         TileCarpet( carpet, row, col, subCarpet );
    }
    if (subCarpet != &single ) {
       free(subCarpet->rows);
       free(subCarpet->data);
       free(subCarpet);
    }

    return carpet;
}

void CarpetPrint( FILE *fout, Carpet carp)
{
    char obuf[730];
    int row;
    for (row=0; row < carp->dim; row++) {
       strncpy(obuf, carp->rows[row], carp->dim);
       fprintf(fout, "%s\n", obuf);
    }
    fprintf(fout,"\n");
}

int main(int argc, char *argv[])
{
//    FILE *f = fopen("sierp.txt","w");
    CarpetPrint(stdout, Sierpinski(3));
//    fclose(f);
    return 0;
}
`,`#include "sierpinski-carpet-2.h"



void _TileCarpet(long param_1,int param_2,int param_3,int *param_4)

{
  int iVar1;
  int iVar2;
  int local_28;
  int local_24;
  
  iVar1 = *param_4;
  iVar2 = *param_4;
  if ((param_2 == 1) && (param_3 == 1)) {
    for (local_24 = 0; local_24 < *param_4; local_24 = local_24 + 1) {
      for (local_28 = 0; local_28 < *param_4; local_28 = local_28 + 1) {
        *(undefined *)
         (*(long *)(*(long *)(param_1 + 0x10) + (long)(iVar1 * param_2 + local_24) * 8) +
         (long)(iVar2 * param_3 + local_28)) = 0x20;
      }
    }
  }
  else {
    for (local_24 = 0; local_24 < *param_4; local_24 = local_24 + 1) {
      for (local_28 = 0; local_28 < *param_4; local_28 = local_28 + 1) {
        *(undefined *)
         (*(long *)(*(long *)(param_1 + 0x10) + (long)(iVar1 * param_2 + local_24) * 8) +
         (long)(iVar2 * param_3 + local_28)) =
             *(undefined *)(*(long *)(*(long *)(param_4 + 4) + (long)local_24 * 8) + (long)local_28)
        ;
      }
    }
  }
  return;
}



int * _Sierpinski(int param_1)

{
  int *piVar1;
  void *pvVar2;
  int *local_40;
  int local_30;
  int local_2c;
  
  if (param_1 < 2) {
    local_40 = (int *)&DAT_100008000;
  }
  else {
    local_40 = (int *)_Sierpinski(param_1 + -1);
  }
  piVar1 = (int *)_malloc(0x18);
  *piVar1 = *local_40 * 3;
  pvVar2 = _malloc((long)(*local_40 * 2 * *piVar1));
  *(void **)(piVar1 + 2) = pvVar2;
  pvVar2 = _malloc((long)*piVar1 << 3);
  *(void **)(piVar1 + 4) = pvVar2;
  for (local_2c = 0; local_2c < *local_40; local_2c = local_2c + 1) {
    *(long *)(*(long *)(piVar1 + 4) + (long)local_2c * 8) =
         *(long *)(piVar1 + 2) + (long)(local_2c * *piVar1);
    *(long *)(*(long *)(piVar1 + 4) + (long)(local_2c + *local_40) * 8) =
         *(long *)(piVar1 + 2) + (long)((local_2c + *local_40) * *piVar1);
    *(long *)(*(long *)(piVar1 + 4) + (long)(local_2c + *local_40 * 2) * 8) =
         *(long *)(piVar1 + 2) + (long)(local_2c * *piVar1);
  }
  for (local_30 = 0; local_30 < 3; local_30 = local_30 + 1) {
    for (local_2c = 0; local_2c < 2; local_2c = local_2c + 1) {
      _TileCarpet(piVar1,local_2c,local_30,local_40);
    }
  }
  if (local_40 != (int *)&DAT_100008000) {
    _free(*(void **)(local_40 + 4));
    _free(*(void **)(local_40 + 2));
    _free(local_40);
  }
  return piVar1;
}



void _CarpetPrint(FILE *param_1,int *param_2)

{
  int iVar1;
  int local_31c;
  undefined auStack_302 [730];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  for (local_31c = 0; local_31c < *param_2; local_31c = local_31c + 1) {
    ___strncpy_chk(auStack_302,*(undefined8 *)(*(long *)(param_2 + 4) + (long)local_31c * 8),
                   (long)*param_2,0x2da);
    _fprintf(param_1,"%s\n");
  }
  iVar1 = _fprintf(param_1,"\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



undefined4 entry(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  
  uVar2 = *(undefined8 *)PTR____stdoutp_100004010;
  uVar1 = _Sierpinski(3);
  _CarpetPrint(uVar2,uVar1);
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strncpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strncpy_chk_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004030)();
  return pvVar1;
}


`
`#include <stdio.h>

int main()
{
  int i;
  for (i = 1; i <= 10; i++) {
    printf("%d", i);
    printf(i == 10 ? "\n" : ", ");
  }
  return 0;
}
`,`#include "loops-n-plus-one-half.h"



undefined8 entry(void)

{
  char *pcVar1;
  int local_18;
  
  for (local_18 = 1; local_18 < 0xb; local_18 = local_18 + 1) {
    _printf("%d");
    pcVar1 = "\n";
    if (local_18 != 10) {
      pcVar1 = ", ";
    }
    _printf(pcVar1);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int pancake(int n) {
    int gap = 2, sum = 2, adj = -1;
    while (sum < n) {
        adj++;
        gap = gap * 2 - 1;
        sum += gap;
    }
    return n + adj;
}

int main() {
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 1; j < 6; j++) {
            int n = i * 5 + j;
            printf("p(%2d) = %2d  ", n, pancake(n));
        }
        printf("\n");
    }
    return 0;
}
`,`#include "pancake-numbers.h"



int _pancake(int param_1)

{
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  local_8 = 2;
  local_10 = -1;
  for (local_c = 2; local_c < param_1; local_c = local_c + local_8) {
    local_10 = local_10 + 1;
    local_8 = local_8 * 2 + -1;
  }
  return param_1 + local_10;
}



undefined8 entry(void)

{
  int local_1c;
  int local_18;
  
  for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
    for (local_1c = 1; local_1c < 6; local_1c = local_1c + 1) {
      _pancake(local_18 * 5 + local_1c);
      _printf("p(%2d) = %2d  ");
    }
    _printf("\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include<stdlib.h>
#include<stdio.h>

typedef struct elem{
	int data;
	struct elem* next;
}cell;

typedef cell* list;

void addToList(list *a,int num){
	list temp, holder;
	
	if(*a==NULL){
		*a = (list)malloc(sizeof(cell));
		(*a)->data = num;
		(*a)->next = NULL;
	}
	else{
		temp = *a;
		
		while(temp->next!=NULL)
			temp = temp->next;
		
		holder = (list)malloc(sizeof(cell));
		holder->data = num;
		holder->next = NULL;
		
		temp->next = holder;
	}
}

list copyList(list a){
	list b, tempA, tempB, temp;
	
	if(a!=NULL){
		b = (list)malloc(sizeof(cell));
		b->data = a->data;
		b->next = NULL;
		
		tempA = a->next;
		tempB = b;
		
		while(tempA!=NULL){
			temp = (list)malloc(sizeof(cell));
			temp->data = tempA->data;
			temp->next = NULL;
		
			tempB->next = temp;
			tempB = temp;
		
			tempA = tempA->next;
		}
	}
	
	return b;
}

void printList(list a){
	list temp = a;
	
	while(temp!=NULL){
		printf("%d,",temp->data);
		temp = temp->next;
	}
	printf("\b");
}

int main()
{
	list a,b;
	int i;
	
	for(i=1;i<=5;i++)
		addToList(&a,i);
	
	printf("List a is : ");
	
	printList(a);
	
	b = copyList(a);
	
	free(a);
	
	printf("\nList a destroyed, List b is : ");
	
	printList(b);
	
	return 0;
}
`,`#include "deepcopy-2.h"



void _addToList(long *param_1,undefined4 param_2)

{
  void *pvVar1;
  undefined4 *puVar2;
  long local_28;
  
  if (*param_1 == 0) {
    pvVar1 = _malloc(0x10);
    *param_1 = (long)pvVar1;
    *(undefined4 *)*param_1 = param_2;
    *(undefined8 *)(*param_1 + 8) = 0;
  }
  else {
    for (local_28 = *param_1; *(long *)(local_28 + 8) != 0; local_28 = *(long *)(local_28 + 8)) {
    }
    puVar2 = (undefined4 *)_malloc(0x10);
    *puVar2 = param_2;
    *(undefined8 *)(puVar2 + 2) = 0;
    *(undefined4 **)(local_28 + 8) = puVar2;
  }
  return;
}



undefined4 * _copyList(undefined4 *param_1)

{
  undefined4 *puVar1;
  undefined4 *local_30;
  undefined4 *local_28;
  undefined4 *local_20;
  
  if (param_1 != (undefined4 *)0x0) {
    local_20 = (undefined4 *)_malloc(0x10);
    *local_20 = *param_1;
    *(undefined8 *)(local_20 + 2) = 0;
    local_30 = local_20;
    for (local_28 = *(undefined4 **)(param_1 + 2); local_28 != (undefined4 *)0x0;
        local_28 = *(undefined4 **)(local_28 + 2)) {
      puVar1 = (undefined4 *)_malloc(0x10);
      *puVar1 = *local_28;
      *(undefined8 *)(puVar1 + 2) = 0;
      *(undefined4 **)(local_30 + 2) = puVar1;
      local_30 = puVar1;
    }
  }
  return local_20;
}



int _printList(long param_1)

{
  int iVar1;
  long local_20;
  
  for (local_20 = param_1; local_20 != 0; local_20 = *(long *)(local_20 + 8)) {
    _printf("%d,");
  }
  iVar1 = _printf("\b");
  return iVar1;
}



undefined8 entry(void)

{
  undefined8 uVar1;
  int local_2c;
  void *local_20;
  undefined4 local_14;
  
  local_14 = 0;
  for (local_2c = 1; local_2c < 6; local_2c = local_2c + 1) {
    _addToList(&local_20,local_2c);
  }
  _printf("List a is : ");
  _printList(local_20);
  uVar1 = _copyList(local_20);
  _free(local_20);
  _printf("\nList a destroyed, List b is : ");
  _printList(uVar1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

/* should be 64-bit integers if going over 1 billion */
typedef unsigned long xint;
#define FMT "%lu"

xint total, prim, max_peri;
xint U[][9] =  {{ 1, -2, 2,  2, -1, 2,  2, -2, 3},
        { 1,  2, 2,  2,  1, 2,  2,  2, 3},
        {-1,  2, 2, -2,  1, 2, -2,  2, 3}};

void new_tri(xint in[])
{
    int i;
    xint t[3], p = in[0] + in[1] + in[2];

    if (p > max_peri) return;

    prim ++;

    /* for every primitive triangle, its multiples would be right-angled too;
     * count them up to the max perimeter */
    total += max_peri / p;

    /* recursively produce next tier by multiplying the matrices */
    for (i = 0; i < 3; i++) {
        t[0] = U[i][0] * in[0] + U[i][1] * in[1] + U[i][2] * in[2];
        t[1] = U[i][3] * in[0] + U[i][4] * in[1] + U[i][5] * in[2];
        t[2] = U[i][6] * in[0] + U[i][7] * in[1] + U[i][8] * in[2];
        new_tri(t);
    }
}

int main()
{
    xint seed[3] = {3, 4, 5};

    for (max_peri = 10; max_peri <= 100000000; max_peri *= 10) {
        total = prim = 0;
        new_tri(seed);

        printf( "Up to "FMT": "FMT" triples, "FMT" primitives.\n",
            max_peri, total, prim);
    }
    return 0;
}
`,`#include "pythagorean-triples-3.h"



void _new_tri(long *param_1)

{
  ulong uVar1;
  ulong uVar2;
  int local_3c;
  long local_30;
  long local_28;
  long local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uVar1 = *param_1 + param_1[1] + param_1[2];
  if (uVar1 <= _max_peri) {
    _prim = _prim + 1;
    uVar2 = 0;
    if (uVar1 != 0) {
      uVar2 = _max_peri / uVar1;
    }
    _total = _total + uVar2;
    for (local_3c = 0; local_3c < 3; local_3c = local_3c + 1) {
      local_30 = *(long *)(&_U + (long)local_3c * 0x48) * *param_1 +
                 *(long *)(&DAT_100008008 + (long)local_3c * 0x48) * param_1[1] +
                 *(long *)(&DAT_100008010 + (long)local_3c * 0x48) * param_1[2];
      local_28 = *(long *)(&DAT_100008018 + (long)local_3c * 0x48) * *param_1 +
                 *(long *)(&DAT_100008020 + (long)local_3c * 0x48) * param_1[1] +
                 *(long *)(&DAT_100008028 + (long)local_3c * 0x48) * param_1[2];
      local_20 = *(long *)(&DAT_100008030 + (long)local_3c * 0x48) * *param_1 +
                 *(long *)(&DAT_100008038 + (long)local_3c * 0x48) * param_1[1] +
                 *(long *)(&DAT_100008040 + (long)local_3c * 0x48) * param_1[2];
      _new_tri(&local_30);
    }
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(ulong param_1)

{
  uint uVar1;
  undefined8 local_30;
  undefined8 uStack_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  uStack_28 = 4;
  local_30 = 3;
  local_20 = 5;
  for (_max_peri = 10; _max_peri < 0x5f5e101; _max_peri = _max_peri * 10) {
    _prim = 0;
    _total = 0;
    _new_tri(&local_30);
    uVar1 = _printf("Up to %lu: %lu triples, %lu primitives.\n");
    param_1 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>

int main(void)
{
  char s[] = "Hello, world!";
  size_t length = sizeof s - 1;

  return 0;
}
`,`#include "string-length-3.h"



undefined8 entry(void)

{
  if (*(long *)PTR____stack_chk_guard_100004008 != *(long *)PTR____stack_chk_guard_100004008) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}


`
`#include <stdio.h>

int main()
{
	char *object = 0;

	if (object == NULL) {
		puts("object is null");
	}
	return 0;
}
`,`#include "null-object.h"



undefined8 entry(void)

{
  _puts("object is null");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#define MAX_N 20
#define TIMES 1000000

double factorial(int n) {
	double f = 1;
	int i;
	for (i = 1; i <= n; i++) f *= i;
	return f;
}

double expected(int n) {
	double sum = 0;
	int i;
	for (i = 1; i <= n; i++)
		sum += factorial(n) / pow(n, i) / factorial(n - i);
	return sum;
}

int randint(int n) {
	int r, rmax = RAND_MAX / n * n;
	while ((r = rand()) >= rmax);
	return r / (RAND_MAX / n);
}

int test(int n, int times) {
	int i, count = 0;
	for (i = 0; i < times; i++) {
		int x = 1, bits = 0;
		while (!(bits & x)) {
			count++;
			bits |= x;
			x = 1 << randint(n);
		}
	}
	return count;
}

int main(void) {
	srand(time(0));
	puts(" n\tavg\texp.\tdiff\n-------------------------------");

	int n;
	for (n = 1; n <= MAX_N; n++) {
		int cnt = test(n, TIMES);
		double avg = (double)cnt / TIMES;
		double theory = expected(n);
		double diff = (avg / theory - 1) * 100;
		printf("%2d %8.4f %8.4f %6.3f%%\n", n, avg, theory, diff);
	}
	return 0;
}
`,`#include "average-loop-length.h"



undefined  [16] _factorial(int param_1)

{
  undefined auVar1 [16];
  undefined4 local_14;
  undefined8 local_10;
  
  local_10 = 1.0;
  for (local_14 = 1; local_14 <= param_1; local_14 = local_14 + 1) {
    local_10 = local_10 * (double)(long)local_14;
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_10;
  return auVar1;
}



undefined  [16] _expected(int param_1)

{
  double dVar1;
  double dVar2;
  double dVar3;
  undefined auVar4 [16];
  undefined4 local_24;
  undefined8 local_20;
  
  local_20 = 0.0;
  for (local_24 = 1; local_24 <= param_1; local_24 = local_24 + 1) {
    dVar1 = (double)_factorial(param_1);
    dVar2 = (double)_pow((double)(long)param_1,(double)(long)local_24);
    dVar3 = (double)_factorial(param_1 - local_24);
    local_20 = local_20 + (dVar1 / dVar2) / dVar3;
  }
  auVar4._8_8_ = 0;
  auVar4._0_8_ = local_20;
  return auVar4;
}



int _randint(int param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  iVar1 = 0;
  if (param_1 != 0) {
    iVar1 = 0x7fffffff / param_1;
  }
  do {
    iVar3 = _rand();
  } while (iVar1 * param_1 <= iVar3);
  iVar1 = 0;
  if (param_1 != 0) {
    iVar1 = 0x7fffffff / param_1;
  }
  iVar2 = 0;
  if (iVar1 != 0) {
    iVar2 = iVar3 / iVar1;
  }
  return iVar2;
}



int _test(undefined4 param_1,int param_2)

{
  uint uVar1;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  
  local_20 = 0;
  for (local_1c = 0; local_1c < param_2; local_1c = local_1c + 1) {
    local_28 = 0;
    local_24 = 1;
    while ((local_28 & local_24) == 0) {
      local_20 = local_20 + 1;
      local_28 = local_28 | local_24;
      uVar1 = _randint(param_1);
      local_24 = 1 << (ulong)(uVar1 & 0x1f);
    }
  }
  return local_20;
}



undefined8 entry(void)

{
  time_t tVar1;
  int local_18;
  
  tVar1 = _time((time_t *)0x0);
  _srand((uint)tVar1);
  _puts(" n\tavg\texp.\tdiff\n-------------------------------");
  for (local_18 = 1; local_18 < 0x15; local_18 = local_18 + 1) {
    _test(local_18,1000000);
    _expected(local_18);
    _printf("%2d %8.4f %8.4f %6.3f%%\n");
  }
  return 0;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f00. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004018)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004020)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004028)();
  return tVar1;
}


`
`#include <stdio.h>

int max (int *a, int n, int i, int j, int k) {
    int m = i;
    if (j < n && a[j] > a[m]) {
        m = j;
    }
    if (k < n && a[k] > a[m]) {
        m = k;
    }
    return m;
}

void downheap (int *a, int n, int i) {
    while (1) {
        int j = max(a, n, i, 2 * i + 1, 2 * i + 2);
        if (j == i) {
            break;
        }
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
        i = j;
    }
}

void heapsort (int *a, int n) {
    int i;
    for (i = (n - 2) / 2; i >= 0; i--) {
        downheap(a, n, i);
    }
    for (i = 0; i < n; i++) {
        int t = a[n - i - 1];
        a[n - i - 1] = a[0];
        a[0] = t;
        downheap(a, n - i - 1, 0);
    }
}

int main () {
    int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};
    int n = sizeof a / sizeof a[0];
    int i;
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    heapsort(a, n);
    for (i = 0; i < n; i++)
        printf("%d%s", a[i], i == n - 1 ? "\n" : " ");
    return 0;
}
`,`#include "sorting-algorithms-heapsort.h"



int _max(long param_1,int param_2,int param_3,int param_4,int param_5)

{
  undefined4 local_1c;
  
  local_1c = param_3;
  if ((param_4 < param_2) &&
     (*(int *)(param_1 + (long)param_3 * 4) < *(int *)(param_1 + (long)param_4 * 4))) {
    local_1c = param_4;
  }
  if ((param_5 < param_2) &&
     (*(int *)(param_1 + (long)local_1c * 4) < *(int *)(param_1 + (long)param_5 * 4))) {
    local_1c = param_5;
  }
  return local_1c;
}



void _downheap(long param_1,undefined4 param_2,int param_3)

{
  undefined4 uVar1;
  int iVar2;
  undefined4 local_20;
  
  local_20 = param_3;
  while( true ) {
    iVar2 = _max(param_1,param_2,local_20,local_20 * 2 + 1,local_20 * 2 + 2);
    if (iVar2 == local_20) break;
    uVar1 = *(undefined4 *)(param_1 + (long)local_20 * 4);
    *(undefined4 *)(param_1 + (long)local_20 * 4) = *(undefined4 *)(param_1 + (long)iVar2 * 4);
    *(undefined4 *)(param_1 + (long)iVar2 * 4) = uVar1;
    local_20 = iVar2;
  }
  return;
}



int _heapsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
  undefined4 uVar1;
  void *pvVar2;
  int iVar3;
  undefined4 local_20;
  
  iVar3 = (int)param_2;
  pvVar2 = param_1;
  for (local_20 = (iVar3 + -2) / 2; -1 < local_20; local_20 = local_20 + -1) {
    pvVar2 = (void *)_downheap(param_1,iVar3,local_20);
  }
  for (local_20 = 0; local_20 < iVar3; local_20 = local_20 + 1) {
    uVar1 = *(undefined4 *)((long)param_1 + (long)((iVar3 - local_20) + -1) * 4);
                    // WARNING: Load size is inaccurate
    *(undefined4 *)((long)param_1 + (long)((iVar3 - local_20) + -1) * 4) = *param_1;
    *(undefined4 *)param_1 = uVar1;
    pvVar2 = (void *)_downheap(param_1,(iVar3 - local_20) + -1,0);
  }
  return (int)pvVar2;
}



undefined8 entry(void)

{
  int iVar1;
  size_t sVar2;
  int *in_x3;
  int local_4c;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  sVar2 = 0x28;
  _memcpy(auStack_40,&DAT_100003f6c,0x28);
  for (local_4c = 0; local_4c < 10; local_4c = local_4c + 1) {
    _printf("%d%s");
  }
  iVar1 = _heapsort(auStack_40,10,sVar2,in_x3);
  for (local_4c = 0; local_4c < 10; local_4c = local_4c + 1) {
    iVar1 = _printf("%d%s");
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f50. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <string.h>

typedef struct link link_t;
struct link {
	int len;
	char letter;
	link_t *next;
};

// Stores a copy of a SCS of x and y in out.  Caller needs to make sure out is long enough.
int scs(char *x, char *y, char *out)
{
	int lx = strlen(x), ly = strlen(y);
	link_t lnk[ly + 1][lx + 1];
	
	for (int i = 0; i < ly; i++)
		lnk[i][lx] = (link_t) {ly - i, y[i], &lnk[i + 1][lx]};

	for (int j = 0; j < lx; j++)
		lnk[ly][j] = (link_t) {lx - j, x[j], &lnk[ly][j + 1]};

	lnk[ly][lx] = (link_t) {0};

	for (int i = ly; i--; ) {
		for (int j = lx; j--; ) {
			link_t *lp = &lnk[i][j];
			if (y[i] == x[j]) {
				lp->next = &lnk[i+1][j+1];
				lp->letter = x[j];
			} else if (lnk[i][j+1].len < lnk[i+1][j].len) {
				lp->next = &lnk[i][j+1];
				lp->letter = x[j];
			} else {
				lp->next = &lnk[i+1][j];
				lp->letter = y[i];
			}
			lp->len = lp->next->len + 1;
		}
	}

	for (link_t *lp = &lnk[0][0]; lp; lp = lp->next)
		*out++ = lp->letter;

	return 0;
}

int main(void)
{
	char x[] = "abcbdab", y[] = "bdcaba", res[128];
	scs(x, y, res);
	printf("SCS(%s, %s) -> %s\n", x, y, res);
	return 0;
}
`,`#include "shortest-common-supersequence.h"



undefined8 _scs(char *param_1,char *param_2,undefined *param_3)

{
  long lVar1;
  long lVar2;
  int iVar3;
  undefined8 *puVar4;
  long *plVar5;
  size_t sVar6;
  undefined *local_d0;
  ulong local_c8 [4];
  long local_a8;
  int *local_a0;
  int local_98;
  int local_94;
  undefined4 local_90;
  uint uStack_8c;
  undefined8 uStack_88;
  int local_80;
  undefined4 uStack_7c;
  long lStack_78;
  int local_6c;
  int local_68;
  undefined4 uStack_64;
  long lStack_60;
  int local_54;
  ulong local_48;
  undefined *local_40;
  int local_38;
  int local_34;
  undefined *local_30;
  char *local_28;
  char *local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_30 = param_3;
  local_28 = param_2;
  local_20 = param_1;
  sVar6 = _strlen(param_1);
  local_34 = (int)sVar6;
  sVar6 = _strlen(local_28);
  local_38 = (int)sVar6;
  local_c8[2] = (ulong)(local_38 + 1U);
  local_c8[0] = (ulong)(local_34 + 1U);
  local_c8[1] = (ulong)(local_38 + 1U) * (ulong)(local_34 + 1U) * 0x10;
  local_40 = (undefined *)&local_d0;
  (*(code *)PTR____chkstk_darwin_100004000)();
  lVar1 = (long)&local_d0 - local_c8[1];
  local_48 = local_c8[2];
  for (local_54 = 0; local_54 < local_38; local_54 = local_54 + 1) {
    iVar3 = local_38 - local_54;
    uStack_64 = CONCAT31(uStack_64._1_3_,local_28[local_54]);
    lVar2 = lVar1 + (long)(local_54 + 1) * local_c8[0] * 0x10 + (long)local_34 * 0x10;
    puVar4 = (undefined8 *)(lVar1 + (long)local_54 * local_c8[0] * 0x10 + (long)local_34 * 0x10);
    puVar4[1] = lVar2;
    *puVar4 = CONCAT44(uStack_64,iVar3);
    local_68 = iVar3;
    lStack_60 = lVar2;
  }
  for (local_6c = 0; local_6c < local_34; local_6c = local_6c + 1) {
    iVar3 = local_34 - local_6c;
    uStack_7c = CONCAT31(uStack_7c._1_3_,local_20[local_6c]);
    lVar2 = lVar1 + (long)local_38 * local_c8[0] * 0x10 + (long)(local_6c + 1) * 0x10;
    puVar4 = (undefined8 *)(lVar1 + (long)local_38 * local_c8[0] * 0x10 + (long)local_6c * 0x10);
    puVar4[1] = lVar2;
    *puVar4 = CONCAT44(uStack_7c,iVar3);
    local_80 = iVar3;
    lStack_78 = lVar2;
  }
  local_90 = 0;
  uStack_8c = uStack_8c & 0xffffff00;
  uStack_88 = 0;
  plVar5 = (long *)(lVar1 + (long)local_38 * local_c8[0] * 0x10 + (long)local_34 * 0x10);
  plVar5[1] = 0;
  *plVar5 = (ulong)uStack_8c << 0x20;
  local_94 = local_38;
  local_c8[3] = lVar1;
  iVar3 = local_98;
  while (local_98 = iVar3, local_94 != 0) {
    local_98 = local_34;
    local_94 = local_94 + -1;
    while (iVar3 = local_98 + -1, local_98 != 0) {
      local_a0 = (int *)(local_c8[3] + (long)local_94 * local_c8[0] * 0x10 + (long)iVar3 * 0x10);
      if (local_28[local_94] == local_20[iVar3]) {
        lVar1 = (long)local_98;
        local_98 = iVar3;
        *(ulong *)(local_a0 + 2) =
             local_c8[3] + (long)(local_94 + 1) * local_c8[0] * 0x10 + lVar1 * 0x10;
        *(char *)(local_a0 + 1) = local_20[local_98];
      }
      else if (*(int *)(local_c8[3] + (long)local_94 * local_c8[0] * 0x10 + (long)local_98 * 0x10) <
               *(int *)(local_c8[3] + (long)(local_94 + 1) * local_c8[0] * 0x10 + (long)iVar3 * 0x10
                       )) {
        lVar1 = (long)local_98;
        local_98 = iVar3;
        *(ulong *)(local_a0 + 2) = local_c8[3] + (long)local_94 * local_c8[0] * 0x10 + lVar1 * 0x10;
        *(char *)(local_a0 + 1) = local_20[local_98];
      }
      else {
        local_98 = iVar3;
        *(ulong *)(local_a0 + 2) =
             local_c8[3] + (long)(local_94 + 1) * local_c8[0] * 0x10 + (long)iVar3 * 0x10;
        *(char *)(local_a0 + 1) = local_28[local_94];
      }
      *local_a0 = **(int **)(local_a0 + 2) + 1;
    }
  }
  for (local_a8 = local_c8[3]; local_a8 != 0; local_a8 = *(long *)(local_a8 + 8)) {
    *local_30 = *(undefined *)(local_a8 + 4);
    local_30 = local_30 + 1;
  }
  local_d0 = local_40;
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return 0;
  }
  local_94 = local_94 + -1;
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  int iVar1;
  long lVar2;
  
  lVar2 = *(long *)PTR____stack_chk_guard_100004010;
  _scs();
  iVar1 = _printf("SCS(%s, %s) -> %s\n");
  if (*(long *)PTR____stack_chk_guard_100004010 != lVar2) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004020)();
  return sVar1;
}


`
`#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>

// VERY rudimentary C memory management independent of C library's malloc.

// Linked list (yes, this is inefficient)
struct __ALLOCC_ENTRY__
{
    void * allocatedAddr;
    size_t size;
    struct __ALLOCC_ENTRY__ * next;
};
typedef struct __ALLOCC_ENTRY__ __ALLOCC_ENTRY__;

// Keeps track of allocated memory and metadata
__ALLOCC_ENTRY__ * __ALLOCC_ROOT__ = NULL;
__ALLOCC_ENTRY__ * __ALLOCC_TAIL__ = NULL;

// Add new metadata to the table
void _add_mem_entry(void * location, size_t size)
{

    __ALLOCC_ENTRY__ * newEntry = (__ALLOCC_ENTRY__ *) mmap(NULL, sizeof(__ALLOCC_ENTRY__), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

    if (__ALLOCC_TAIL__ != NULL)
    {
        __ALLOCC_TAIL__ -> next = newEntry;
        __ALLOCC_TAIL__ = __ALLOCC_TAIL__ -> next;
    }
    else
    {
        // Create new table
        __ALLOCC_ROOT__ = newEntry;
        __ALLOCC_TAIL__ = newEntry;
    }

    __ALLOCC_ENTRY__ * tail = __ALLOCC_TAIL__;
    tail -> allocatedAddr = location;
    tail -> size = size;
    tail -> next = NULL;
    __ALLOCC_TAIL__ = tail;
}

// Remove metadata from the table given pointer
size_t _remove_mem_entry(void * location)
{
    __ALLOCC_ENTRY__ * curNode = __ALLOCC_ROOT__;

    // Nothing to do
    if (curNode == NULL)
    {
        return 0;
    }

    // First entry matches
    if (curNode -> allocatedAddr == location)
    {
        __ALLOCC_ROOT__ = curNode -> next;
        size_t chunkSize = curNode -> size;

        // No nodes left
        if (__ALLOCC_ROOT__ == NULL)
        {
            __ALLOCC_TAIL__ = NULL;
        }
        munmap(curNode, sizeof(__ALLOCC_ENTRY__));

        return chunkSize;
    }

    // If next node is null, remove it
    while (curNode -> next != NULL)
    {
        __ALLOCC_ENTRY__ * nextNode = curNode -> next;

        if (nextNode -> allocatedAddr == location)
        {
            size_t chunkSize = nextNode -> size;

            if(curNode -> next == __ALLOCC_TAIL__)
            {
                __ALLOCC_TAIL__ = curNode;
            }
            curNode -> next = nextNode -> next;
            munmap(nextNode, sizeof(__ALLOCC_ENTRY__));

            return chunkSize;
        }

        curNode = nextNode;
    }

    // Nothing was found
    return 0;
}

// Allocate a block of memory with size
// When customMalloc an already mapped location, causes undefined behavior
void * customMalloc(size_t size)
{
    // Now we can use 0 as our error state
    if (size == 0)
    {
        return NULL;
    }

    void * mapped = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

    // Store metadata
    _add_mem_entry(mapped, size);

    return mapped;
}

// Free a block of memory that has been customMalloc'ed
void customFree(void * addr)
{
    size_t size = _remove_mem_entry(addr);

    munmap(addr, size);
}

int main(int argc, char const *argv[])
{
    int *p1 = customMalloc(4*sizeof(int));  // allocates enough for an array of 4 int
    int *p2 = customMalloc(sizeof(int[4])); // same, naming the type directly
    int *p3 = customMalloc(4*sizeof *p3);   // same, without repeating the type name

    if(p1) {
        for(int n=0; n<4; ++n) // populate the array
            p1[n] = n*n;
        for(int n=0; n<4; ++n) // print it back out
            printf("p1[%d] == %d\n", n, p1[n]);
    }

    customFree(p1);
    customFree(p2);
    customFree(p3);

    return 0;
}
`,`#include "arena-storage-pool-7.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __add_mem_entry(undefined8 param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  undefined8 *puVar2;
  
  puVar2 = (undefined8 *)_mmap(0,0x18,3,0x1002,0xffffffff,0);
  puVar1 = puVar2;
  if (____ALLOCC_TAIL__ != (undefined8 *)0x0) {
    *(undefined8 **)((long)____ALLOCC_TAIL__ + 0x10) = puVar2;
    puVar2 = ____ALLOCC_ROOT__;
    puVar1 = *(undefined8 **)((long)____ALLOCC_TAIL__ + 0x10);
  }
  ____ALLOCC_TAIL__ = puVar1;
  ____ALLOCC_ROOT__ = puVar2;
  *____ALLOCC_TAIL__ = param_1;
  ____ALLOCC_TAIL__[1] = param_2;
  ____ALLOCC_TAIL__[2] = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long __remove_mem_entry(long param_1)

{
  long *plVar1;
  long *local_28;
  long local_18;
  
  plVar1 = ____ALLOCC_ROOT__;
  local_28 = ____ALLOCC_ROOT__;
  if (____ALLOCC_ROOT__ == (long *)0x0) {
    local_18 = 0;
  }
  else if (*____ALLOCC_ROOT__ == param_1) {
    local_18 = ____ALLOCC_ROOT__[1];
    if ((long *)____ALLOCC_ROOT__[2] == (long *)0x0) {
      ____ALLOCC_TAIL__ = (long *)0x0;
    }
    ____ALLOCC_ROOT__ = (long *)____ALLOCC_ROOT__[2];
    _munmap(plVar1,0x18);
  }
  else {
    do {
      local_28 = plVar1;
      if (local_28[2] == 0) {
        return 0;
      }
      plVar1 = (long *)local_28[2];
    } while (*plVar1 != param_1);
    local_18 = plVar1[1];
    if ((long *)local_28[2] == ____ALLOCC_TAIL__) {
      ____ALLOCC_TAIL__ = local_28;
    }
    local_28[2] = plVar1[2];
    _munmap(plVar1,0x18);
  }
  return local_18;
}



undefined8 _customMalloc(long param_1)

{
  undefined8 local_18;
  
  if (param_1 == 0) {
    local_18 = 0;
  }
  else {
    local_18 = _mmap(0,param_1,3,0x1002,0xffffffff,0);
    __add_mem_entry(local_18,param_1);
  }
  return local_18;
}



void _customFree(undefined8 param_1)

{
  undefined8 uVar1;
  
  uVar1 = __remove_mem_entry(param_1);
  _munmap(param_1,uVar1);
  return;
}



undefined8 entry(void)

{
  long lVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  int local_40;
  int local_3c;
  
  lVar1 = _customMalloc();
  uVar2 = _customMalloc(0x10);
  uVar3 = _customMalloc(0x10);
  if (lVar1 != 0) {
    for (local_3c = 0; local_3c < 4; local_3c = local_3c + 1) {
      *(int *)(lVar1 + (long)local_3c * 4) = local_3c * local_3c;
    }
    for (local_40 = 0; local_40 < 4; local_40 = local_40 + 1) {
      _printf("p1[%d] == %d\n");
    }
  }
  _customFree(lVar1);
  _customFree(uVar2);
  _customFree(uVar3);
  return 0;
}



void _mmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__mmap_100004000)();
  return;
}



void _munmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__munmap_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

typedef int bool;

int next_in_cycle(int *c, int len, int index) {
    return c[index % len];
}

void kolakoski(int *c, int *s, int clen, int slen) {
    int i = 0, j, k = 0;
    while (TRUE) {
        s[i] = next_in_cycle(c, clen, k);
        if (s[k] > 1) {
            for (j = 1; j < s[k]; ++j) {
                if (++i == slen) return;
                s[i] = s[i - 1];
            }
        }
        if (++i == slen) return;
        k++;
    }
}

bool possible_kolakoski(int *s, int len) {
    int i, j = 0, prev = s[0], count = 1;
    int *rle = calloc(len, sizeof(int));
    bool result = TRUE;
    for (i = 1; i < len; ++i) {
        if (s[i] == prev) {
            count++;
        }
        else {
            rle[j++] = count;
            count = 1;
            prev = s[i];
        }
    }
    /* no point adding final 'count' to rle as we're not going to compare it anyway */
    for (i = 0; i < j; i++) {
        if (rle[i] != s[i]) {
           result = FALSE;
           break;
        }
    }
    free(rle);
    return result;
}

void print_array(int *a, int len) {
    int i;
    printf("[");
    for (i = 0; i < len; ++i) {
       printf("%d", a[i]);
       if (i < len - 1) printf(", ");
    }
    printf("]");
}

int main() {
    int i, clen, slen, *s;
    int c0[2] = {1, 2};
    int c1[2] = {2, 1};
    int c2[4] = {1, 3, 1, 2};
    int c3[4] = {1, 3, 2, 1};
    int *cs[4] = {c0, c1, c2, c3};
    bool p;
    int clens[4] = {2, 2, 4, 4};
    int slens[4] = {20, 20, 30, 30};
    for (i = 0; i < 4; ++i) {
        clen = clens[i];
        slen = slens[i];
        s = calloc(slen, sizeof(int));
        kolakoski(cs[i], s, clen, slen);
        printf("First %d members of the sequence generated by ", slen);
        print_array(cs[i], clen);
        printf(":\n");
        print_array(s, slen);
        printf("\n");
        p = possible_kolakoski(s, slen);
        printf("Possible Kolakoski sequence? %s\n\n", p ? "True" : "False");
        free(s);
    }
    return 0;
}
`,`#include "kolakoski-sequence.h"



undefined4 _next_in_cycle(long param_1,int param_2,int param_3)

{
  int iVar1;
  
  iVar1 = 0;
  if (param_2 != 0) {
    iVar1 = param_3 / param_2;
  }
  return *(undefined4 *)(param_1 + (long)(param_3 - iVar1 * param_2) * 4);
}



void _kolakoski(undefined8 param_1,long param_2,undefined4 param_3,int param_4)

{
  int iVar1;
  undefined4 uVar2;
  int local_34;
  int local_30;
  int local_2c;
  
  local_2c = 0;
  local_34 = 0;
  while( true ) {
    uVar2 = _next_in_cycle(param_1,param_3,local_34);
    *(undefined4 *)(param_2 + (long)local_2c * 4) = uVar2;
    if (1 < *(int *)(param_2 + (long)local_34 * 4)) {
      for (local_30 = 1; local_30 < *(int *)(param_2 + (long)local_34 * 4); local_30 = local_30 + 1)
      {
        iVar1 = local_2c + 1;
        if (iVar1 == param_4) {
          return;
        }
        *(undefined4 *)(param_2 + (long)iVar1 * 4) = *(undefined4 *)(param_2 + (long)local_2c * 4);
        local_2c = iVar1;
      }
    }
    local_2c = local_2c + 1;
    if (local_2c == param_4) break;
    local_34 = local_34 + 1;
  }
  return;
}



undefined4 _possible_kolakoski(int *param_1,int param_2)

{
  void *pvVar1;
  long lVar2;
  undefined4 local_3c;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  
  local_24 = 0;
  local_28 = *param_1;
  local_2c = 1;
  pvVar1 = _calloc((long)param_2,4);
  local_3c = 1;
  for (local_20 = 1; local_20 < param_2; local_20 = local_20 + 1) {
    if (param_1[local_20] == local_28) {
      local_2c = local_2c + 1;
    }
    else {
      lVar2 = (long)local_24;
      local_24 = local_24 + 1;
      *(int *)((long)pvVar1 + lVar2 * 4) = local_2c;
      local_2c = 1;
      local_28 = param_1[local_20];
    }
  }
  local_20 = 0;
  do {
    if (local_24 <= local_20) {
LAB_100003be0:
      _free(pvVar1);
      return local_3c;
    }
    if (*(int *)((long)pvVar1 + (long)local_20 * 4) != param_1[local_20]) {
      local_3c = 0;
      goto LAB_100003be0;
    }
    local_20 = local_20 + 1;
  } while( true );
}



int _print_array(undefined8 param_1,int param_2)

{
  int iVar1;
  int local_20;
  
  _printf("[");
  for (local_20 = 0; local_20 < param_2; local_20 = local_20 + 1) {
    _printf("%d");
    if (local_20 < param_2 + -1) {
      _printf(", ");
    }
  }
  iVar1 = _printf("]");
  return iVar1;
}



undefined8 entry(void)

{
  int iVar1;
  int iVar2;
  void *pvVar3;
  int local_98;
  int local_90 [8];
  undefined8 *local_70 [4];
  undefined8 local_50;
  undefined8 uStack_48;
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_20 = 0x200000001;
  local_28 = 0x100000002;
  uStack_38 = 0x200000001;
  local_40 = 0x300000001;
  uStack_48 = 0x100000002;
  local_50 = 0x300000001;
  local_70[0] = &local_20;
  local_70[1] = &local_28;
  local_70[2] = &local_40;
  local_70[3] = &local_50;
  local_90[6] = 4;
  local_90[7] = 4;
  local_90[4] = 2;
  local_90[5] = 2;
  local_90[2] = 0x1e;
  local_90[3] = 0x1e;
  local_90[0] = 0x14;
  local_90[1] = 0x14;
  for (local_98 = 0; local_98 < 4; local_98 = local_98 + 1) {
    iVar1 = local_90[(long)local_98 + 4];
    iVar2 = local_90[local_98];
    pvVar3 = _calloc((long)iVar2,4);
    _kolakoski(local_70[local_98],pvVar3,iVar1,iVar2);
    _printf("First %d members of the sequence generated by ");
    _print_array(local_70[local_98],iVar1);
    _printf(":\n");
    _print_array(pvVar3,iVar2);
    _printf("\n");
    _possible_kolakoski(pvVar3,iVar2);
    _printf("Possible Kolakoski sequence? %s\n\n");
    _free(pvVar3);
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ebc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ec8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

void quicksort(int *A, int len);

int main (void) {
  int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};
  int n = sizeof a / sizeof a[0];

  int i;
  for (i = 0; i < n; i++) {
    printf("%d ", a[i]);
  }
  printf("\n");

  quicksort(a, n);

  for (i = 0; i < n; i++) {
    printf("%d ", a[i]);
  }
  printf("\n");

  return 0;
}

void quicksort(int *A, int len) {
  if (len < 2) return;

  int pivot = A[len / 2];

  int i, j;
  for (i = 0, j = len - 1; ; i++, j--) {
    while (A[i] < pivot) i++;
    while (A[j] > pivot) j--;

    if (i >= j) break;

    int temp = A[i];
    A[i]     = A[j];
    A[j]     = temp;
  }

  quicksort(A, i);
  quicksort(A + i, len - i);
}
`,`#include "sorting-algorithms-quicksort-1.h"



undefined8 entry(void)

{
  int iVar1;
  int local_4c;
  undefined auStack_40 [40];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(auStack_40,&DAT_100003f78,0x28);
  for (local_4c = 0; local_4c < 10; local_4c = local_4c + 1) {
    _printf("%d ");
  }
  _printf("\n");
  _quicksort(auStack_40,10);
  for (local_4c = 0; local_4c < 10; local_4c = local_4c + 1) {
    _printf("%d ");
  }
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void _quicksort(long param_1,int param_2)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 local_28;
  undefined4 local_24;
  
  if (1 < param_2) {
    iVar1 = *(int *)(param_1 + (long)(param_2 / 2) * 4);
    local_24 = 0;
    local_28 = param_2 + -1;
    while( true ) {
      while (*(int *)(param_1 + (long)local_24 * 4) < iVar1) {
        local_24 = local_24 + 1;
      }
      while (iVar1 < *(int *)(param_1 + (long)local_28 * 4)) {
        local_28 = local_28 + -1;
      }
      if (local_28 <= local_24) break;
      uVar2 = *(undefined4 *)(param_1 + (long)local_24 * 4);
      *(undefined4 *)(param_1 + (long)local_24 * 4) = *(undefined4 *)(param_1 + (long)local_28 * 4);
      *(undefined4 *)(param_1 + (long)local_28 * 4) = uVar2;
      local_24 = local_24 + 1;
      local_28 = local_28 + -1;
    }
    _quicksort(param_1,local_24);
    _quicksort(param_1 + (long)local_24 * 4,param_2 - local_24);
  }
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <locale.h>

bool *sieve(uint64_t limit) {
    uint64_t i, p;
    limit++;
    // True denotes composite, false denotes prime.
    bool *c = calloc(limit, sizeof(bool)); // all false by default
    c[0] = true;
    c[1] = true;
    for (i = 4; i < limit; i += 2) c[i] = true;
    p = 3; // Start from 3.
    while (true) {
        uint64_t p2 = p * p;
        if (p2 >= limit) break;
        for (i = p2; i < limit; i += 2 * p) c[i] = true;
        while (true) {
            p += 2;
            if (!c[p]) break;
        }
    }
    return c;
}

typedef struct {
    char digs[20];
    int count;
} digits;

digits getDigits(uint64_t n) {
    if (n == 0) return (digits){ {0}, 1 };
    digits d;
    d.count = 0;
    while (n > 0) {
        d.digs[d.count++] = n % 10;
        n = n / 10;
    }
    return d; // note digits are in reverse order
}

int main() {
    const uint64_t limit = 10000000000;
    uint64_t i, j, pc = 0, p1, p2, p3, key1, key2, key3;
    int k, count, count2;
    digits d;
    bool *c = sieve(limit);
    for (i = 0; i < limit; ++i) {
        if (!c[i]) ++pc;
    }
    uint64_t *primes = (uint64_t *)malloc(pc * sizeof(uint64_t));
    for (i = 0, j = 0; i < limit; ++i) {
        if (!c[i]) primes[j++] = i;
    }
    free(c);
    uint64_t orm25[25];
    int counts[2];
    j = limit/10;
    for (i = 0; i < pc-2; ++i) {
        p1 = primes[i];
        p2 = primes[i+1];
        p3 = primes[i+2];
        if ((p2 - p1) % 18 || (p3 - p2) % 18) continue;
        key1 = 1;
        d = getDigits(p1);
        for (k = 0; k < d.count; ++k) key1 *= primes[d.digs[k]];
        key2 = 1;
        d = getDigits(p2);
        for (k = 0; k < d.count; ++k) key2 *= primes[d.digs[k]];
        if (key1 != key2) continue;
        key3 = 1;
        d = getDigits(p3);
        for (k = 0; k < d.count; ++k) key3 *= primes[d.digs[k]];
        if (key2 == key3) {
            if (count < 25) orm25[count] = p1;
            if (p1 >= j) {
                counts[count2++] = count;
                j *= 10;
            }
            ++count;
        }
    }
    counts[count2] = count;
    printf("Smallest members of first 25 Ormiston triples:\n");
    setlocale(LC_NUMERIC, "");
    for (i = 0; i < 25; ++i) {
        printf("%'10ld  ", orm25[i]);
        if (!((i+1) % 5)) printf("\n");
    }
    printf("\n");
    j = limit/10;
    for (i = 0; i < 2; ++i) {
        printf("%'d Ormiston triples before %'ld\n", counts[i], j);
        j *= 10;
        printf("\n");
    }
    free(primes);
    return 0;
}
`,`#include "ormiston-triples.h"



undefined * _sieve(long param_1)

{
  size_t sVar1;
  undefined *puVar2;
  long local_28;
  ulong local_20;
  
  sVar1 = param_1 + 1;
  puVar2 = (undefined *)_calloc(sVar1,1);
  *puVar2 = 1;
  puVar2[1] = 1;
  for (local_20 = 4; local_20 < sVar1; local_20 = local_20 + 2) {
    puVar2[local_20] = 1;
  }
  local_28 = 3;
  while (local_20 = local_28 * local_28, local_20 < sVar1) {
    for (; local_20 < sVar1; local_20 = local_20 + local_28 * 2) {
      puVar2[local_20] = 1;
    }
    do {
      local_28 = local_28 + 2;
    } while ((puVar2[local_28] & 1) != 0);
  }
  return puVar2;
}



void _getDigits(undefined8 *param_1,ulong param_2)

{
  int iVar1;
  ulong local_8;
  
  if (param_2 == 0) {
    *param_1 = 0;
    param_1[1] = 0;
    param_1[2] = 0;
    *(undefined4 *)((long)param_1 + 0x14) = 1;
  }
  else {
    *(undefined4 *)((long)param_1 + 0x14) = 0;
    for (local_8 = param_2; local_8 != 0; local_8 = local_8 / 10) {
      iVar1 = *(int *)((long)param_1 + 0x14);
      *(int *)((long)param_1 + 0x14) = iVar1 + 1;
      *(char *)((long)param_1 + (long)iVar1) = (char)local_8 + (char)(local_8 / 10) * -10;
    }
  }
  return;
}



undefined8 entry(void)

{
  undefined8 uVar1;
  void *pvVar2;
  void *pvVar3;
  ulong uVar4;
  long lVar5;
  long lVar6;
  int local_1bc;
  int local_1b8;
  int local_1b4;
  long local_1b0;
  long local_1a8;
  long local_1a0;
  long local_180;
  ulong local_178;
  ulong local_170;
  undefined8 local_158;
  undefined8 uStack_150;
  undefined8 local_148;
  undefined8 local_140;
  undefined8 uStack_138;
  undefined8 local_130;
  undefined8 local_128;
  undefined8 uStack_120;
  undefined8 local_118;
  int aiStack_110 [2];
  ulong auStack_108 [25];
  undefined8 local_40;
  undefined8 uStack_38;
  undefined8 local_30;
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_180 = 0;
  pvVar2 = (void *)_sieve();
  for (local_170 = 0; local_170 < 10000000000; local_170 = local_170 + 1) {
    if ((*(byte *)((long)pvVar2 + local_170) & 1) == 0) {
      local_180 = local_180 + 1;
    }
  }
  pvVar3 = _malloc(local_180 << 3);
  local_178 = 0;
  for (local_170 = 0; local_170 < 10000000000; local_170 = local_170 + 1) {
    if ((*(byte *)((long)pvVar2 + local_170) & 1) == 0) {
      *(ulong *)((long)pvVar3 + local_178 * 8) = local_170;
      local_178 = local_178 + 1;
    }
  }
  _free(pvVar2);
  local_178 = 1000000000;
  for (local_170 = 0; local_170 < local_180 - 2U; local_170 = local_170 + 1) {
    uVar4 = *(ulong *)((long)pvVar3 + local_170 * 8);
    lVar5 = *(long *)((long)pvVar3 + (local_170 + 1) * 8);
    lVar6 = *(long *)((long)pvVar3 + (local_170 + 2) * 8);
    if (((lVar5 - uVar4) % 0x12 == 0) && ((ulong)(lVar6 - lVar5) % 0x12 == 0)) {
      local_1a0 = 1;
      _getDigits(&local_128,uVar4);
      uStack_38 = uStack_120;
      local_40 = local_128;
      local_30 = local_118;
      uVar1 = local_30;
      for (local_1b4 = 0; local_30._4_4_ = (int)((ulong)local_118 >> 0x20),
          local_1b4 < local_30._4_4_; local_1b4 = local_1b4 + 1) {
        local_1a0 = local_1a0 *
                    *(long *)((long)pvVar3 + (long)*(char *)((long)&local_40 + (long)local_1b4) * 8)
        ;
      }
      local_1a8 = 1;
      local_30 = uVar1;
      _getDigits(&local_140,lVar5);
      uStack_38 = uStack_138;
      local_40 = local_140;
      local_30 = local_130;
      uVar1 = local_30;
      for (local_1b4 = 0; local_30._4_4_ = (int)((ulong)local_130 >> 0x20),
          local_1b4 < local_30._4_4_; local_1b4 = local_1b4 + 1) {
        local_1a8 = local_1a8 *
                    *(long *)((long)pvVar3 + (long)*(char *)((long)&local_40 + (long)local_1b4) * 8)
        ;
      }
      local_30 = uVar1;
      if (local_1a0 == local_1a8) {
        local_1b0 = 1;
        _getDigits(&local_158,lVar6);
        uStack_38 = uStack_150;
        local_40 = local_158;
        local_30 = local_148;
        uVar1 = local_30;
        for (local_1b4 = 0; local_30._4_4_ = (int)((ulong)local_148 >> 0x20),
            local_1b4 < local_30._4_4_; local_1b4 = local_1b4 + 1) {
          local_1b0 = local_1b0 *
                      *(long *)((long)pvVar3 +
                               (long)*(char *)((long)&local_40 + (long)local_1b4) * 8);
        }
        local_30 = uVar1;
        if (local_1a8 == local_1b0) {
          if (local_1b8 < 0x19) {
            auStack_108[local_1b8] = uVar4;
          }
          if (local_178 <= uVar4) {
            lVar5 = (long)local_1bc;
            local_1bc = local_1bc + 1;
            aiStack_110[lVar5] = local_1b8;
            local_178 = local_178 * 10;
          }
          local_1b8 = local_1b8 + 1;
        }
      }
    }
  }
  aiStack_110[local_1bc] = local_1b8;
  _printf("Smallest members of first 25 Ormiston triples:\n");
  _setlocale(4,"");
  for (local_170 = 0; local_170 < 0x19; local_170 = local_170 + 1) {
    _printf("%\'10ld  ");
    if ((local_170 + 1) % 5 == 0) {
      _printf("\n");
    }
  }
  _printf("\n");
  for (local_170 = 0; local_170 < 2; local_170 = local_170 + 1) {
    _printf("%\'d Ormiston triples before %\'ld\n");
    _printf("\n");
  }
  _free(pvVar3);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003ef8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _calloc(size_t param_1,size_t param_2)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__calloc_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



void _setlocale(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__setlocale_100004030)();
  return;
}


`
`#include <stdio.h>
#include <stdbool.h>

bool a(bool in)
{
  printf("I am a\n");
  return in;
}

bool b(bool in)
{
  printf("I am b\n");
  return in;
}

#define TEST(X,Y,O)						\
  do {								\
    x = a(X) O b(Y);						\
    printf(#X " " #O " " #Y " = %s\n\n", x ? "true" : "false");	\
  } while(false);

int main()
{
  bool x;

  TEST(false, true, &&); // b is not evaluated
  TEST(true, false, ||); // b is not evaluated
  TEST(true, false, &&); // b is evaluated
  TEST(false, false, ||); // b is evaluated

  return 0;
}
`,`#include "short-circuit-evaluation.h"



byte _a(byte param_1)

{
  _printf("I am a\n");
  return param_1 & 1;
}



byte _b(byte param_1)

{
  _printf("I am b\n");
  return param_1 & 1;
}



undefined8 entry(void)

{
  ulong uVar1;
  
  uVar1 = _a(0);
  if ((uVar1 & 1) != 0) {
    _b(1);
  }
  _printf("false && true = %s\n\n");
  uVar1 = _a(1);
  if ((uVar1 & 1) == 0) {
    _b(0);
  }
  _printf("true || false = %s\n\n");
  uVar1 = _a(1);
  if ((uVar1 & 1) != 0) {
    _b(0);
  }
  _printf("true && false = %s\n\n");
  uVar1 = _a(0);
  if ((uVar1 & 1) == 0) {
    _b(0);
  }
  _printf("false || false = %s\n\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`// C program to find LCM of two numbers
/*
    suppose we have two numbers a and b.
    Property: Since product of LCM and GCD of two numbers are equal to product
   of that number itself. i.e, LCM(a,b)*GCD(a,b)=a*b. So,here we first find the
   GCD of two numbers and using above property we find LCM of that two numbers.
*/
#include <stdio.h>

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

// Function to return LCM of two numbers
int lcm(int a, int b) { return (a * b) / gcd(a, b); }

// Driver program
int main()
{
    int a, b;
    printf("Enter two numbers to find their LCM \n");
    scanf("%d%d", &a, &b);
    printf("LCM of %d and %d is %d ", a, b, lcm(a, b));
    return 0;
}
/*
Test Case1:
a=15,b=20
LCM(a,b)=60
Test Case2:
a=12,b=18
LCM(a,b)=36
*/
`,`#include "lcm.h"



int _gcd(int param_1,int param_2)

{
  int iVar1;
  undefined4 local_14;
  
  local_14 = param_2;
  if (param_1 != 0) {
    iVar1 = 0;
    if (param_1 != 0) {
      iVar1 = param_2 / param_1;
    }
    local_14 = _gcd(param_2 - iVar1 * param_1,param_1);
  }
  return local_14;
}



int _lcm(int param_1,int param_2)

{
  int iVar1;
  int iVar2;
  
  iVar2 = _gcd(param_1,param_2);
  iVar1 = 0;
  if (iVar2 != 0) {
    iVar1 = (param_1 * param_2) / iVar2;
  }
  return iVar1;
}



undefined4 entry(void)

{
  undefined4 local_1c;
  undefined4 local_18;
  
  _printf("Enter two numbers to find their LCM \n");
  _scanf("%d%d");
  _lcm(local_18,local_1c);
  _printf("LCM of %d and %d is %d ");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f54. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int main() {
    const int maxNumber = 100000000;
    int *dsum = (int *)malloc((maxNumber + 1) * sizeof(int));
    int *dcount = (int *)malloc((maxNumber + 1) * sizeof(int));
    int i, j;
    for (i = 0; i <= maxNumber; ++i) {
        dsum[i] = 1;
        dcount[i] = 1;
    }
    for (i = 2; i <= maxNumber; ++i) {
        for (j = i + i; j <= maxNumber; j += i) {
            if (dsum[j] == j) {
                printf("%8d equals the sum of its first %d divisors\n", j, dcount[j]);
            }
            dsum[j] += i;
            ++dcount[j];
        }
    }
    free(dsum);
    free(dcount);
    return 0;
}
`,`#include "erd-s-nicolas-numbers-1.h"



undefined8 entry(void)

{
  int *piVar1;
  void *pvVar2;
  void *pvVar3;
  int local_30;
  int local_2c;
  
  pvVar2 = _malloc(0x17d78404);
  pvVar3 = _malloc(0x17d78404);
  for (local_2c = 0; local_2c < 0x5f5e101; local_2c = local_2c + 1) {
    *(undefined4 *)((long)pvVar2 + (long)local_2c * 4) = 1;
    *(undefined4 *)((long)pvVar3 + (long)local_2c * 4) = 1;
  }
  for (local_2c = 2; local_2c < 0x5f5e101; local_2c = local_2c + 1) {
    for (local_30 = local_2c * 2; local_30 < 0x5f5e101; local_30 = local_30 + local_2c) {
      if (*(int *)((long)pvVar2 + (long)local_30 * 4) == local_30) {
        _printf("%8d equals the sum of its first %d divisors\n");
      }
      piVar1 = (int *)((long)pvVar2 + (long)local_30 * 4);
      *piVar1 = *piVar1 + local_2c;
      piVar1 = (int *)((long)pvVar3 + (long)local_30 * 4);
      *piVar1 = *piVar1 + 1;
    }
  }
  _free(pvVar2);
  _free(pvVar3);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

typedef double (*f_dbl)(double);
#define TAGF (f_dbl)0xdeadbeef
#define TAGG (f_dbl)0xbaddecaf

double dummy(double x)
{
	f_dbl f = TAGF;
	f_dbl g = TAGG;
	return f(g(x));
}

f_dbl composite(f_dbl f, f_dbl g)
{
	size_t len = (void*)composite - (void*)dummy;
	f_dbl ret = malloc(len);
	char *ptr;
	memcpy(ret, dummy, len);
	for (ptr = (char*)ret; ptr < (char*)ret + len - sizeof(f_dbl); ptr++) {
		if (*(f_dbl*)ptr == TAGF)      *(f_dbl*)ptr = f;
		else if (*(f_dbl*)ptr == TAGG) *(f_dbl*)ptr = g;
	}
	return ret;
}

double cube(double x)
{
	return x * x * x;
}

/* uncomment next line if your math.h doesn't have cbrt() */
/* double cbrt(double x) { return pow(x, 1/3.); } */

int main()
{
	int i;
	double x;

	f_dbl A[3] = { cube, exp, sin };
	f_dbl B[3] = { cbrt, log, asin}; /* not sure about availablity of cbrt() */
	f_dbl C[3];

	for (i = 0; i < 3; i++)
		C[i] = composite(A[i], B[i]);

	for (i = 0; i < 3; i++) {
		for (x = .2; x <= 1; x += .2)
			printf("C%d(%g) = %g\n", i, x, C[i](x));
		printf("\n");
	}
	return 0;
}
`,`#include "first-class-functions-2.h"



void _dummy(undefined8 param_1)

{
  (*(code *)&SUB_baddecaf)(param_1);
  (*(code *)&SUB_deadbeef)();
  return;
}



undefined8 * _composite(undefined8 param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  undefined8 *local_38;
  
  puVar1 = (undefined8 *)_malloc(0x50);
  ___memcpy_chk(puVar1,_dummy,0x50,0xffffffffffffffff);
  for (local_38 = puVar1; local_38 < puVar1 + 9; local_38 = (undefined8 *)((long)local_38 + 1)) {
    if ((undefined *)*local_38 == &SUB_deadbeef) {
      *local_38 = param_1;
    }
    else if ((undefined *)*local_38 == &SUB_baddecaf) {
      *local_38 = param_2;
    }
  }
  return puVar1;
}



undefined  [16] _cube(double param_1)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 * param_1 * param_1;
  auVar1._8_8_ = 0;
  return auVar1;
}



undefined8 entry(ulong param_1)

{
  uint uVar1;
  double local_78;
  int local_70;
  ulong auStack_68 [3];
  undefined *local_50 [4];
  code *local_30 [3];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_30[1] = (code *)&_exp;
  local_30[0] = _cube;
  local_30[2] = (code *)&_sin;
  local_50[1] = &_log;
  local_50[0] = &_cbrt;
  local_50[2] = &_asin;
  for (local_70 = 0; local_70 < 3; local_70 = local_70 + 1) {
    param_1 = _composite(local_30[local_70],local_50[local_70]);
    auStack_68[local_70] = param_1;
  }
  for (local_70 = 0; local_70 < 3; local_70 = local_70 + 1) {
    local_78 = 0.2;
    while( true ) {
      if (1.0 < local_78) break;
      (*(code *)auStack_68[local_70])(local_78,param_1);
      uVar1 = _printf("C%d(%g) = %g\n");
      param_1 = (ulong)uVar1;
      local_78 = local_78 + 0.2;
    }
    uVar1 = _printf("\n");
    param_1 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(param_1);
  }
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004018)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004020)((int)param_1);
  return iVar1;
}


`
`/**
 * @file
 * @brief [Matrix Chain
 * Order](https://en.wikipedia.org/wiki/Matrix_chain_multiplication)
 * @details
 * From Wikipedia: Matrix chain multiplication (or the matrix chain ordering
 * problem) is an optimization problem concerning the most efficient way to
 * multiply a given sequence of matrices. The problem is not actually to perform
 * the multiplications, but merely to decide the sequence of the matrix
 * multiplications involved.
 * @author [CascadingCascade](https://github.com/CascadingCascade)
 */

#include <assert.h>  /// for assert
#include <limits.h>  /// for INT_MAX macro
#include <stdio.h>   /// for IO operations
#include <stdlib.h>  /// for malloc() and free()

/**
 * @brief Finds the optimal sequence using the classic O(n^3) algorithm.
 * @param l length of cost array
 * @param p costs of each matrix
 * @param s location to store results
 * @returns number of operations
 */
int matrixChainOrder(int l, const int *p, int *s)
{
    // mat stores the cost for a chain that starts at i and ends on j (inclusive
    // on both ends)
    int **mat = malloc(l * sizeof(int *));
    for (int i = 0; i < l; ++i)
    {
        mat[i] = malloc(l * sizeof(int));
    }

    for (int i = 0; i < l; ++i)
    {
        mat[i][i] = 0;
    }
    // cl denotes the difference between start / end indices, cl + 1 would be
    // chain length.
    for (int cl = 1; cl < l; ++cl)
    {
        for (int i = 0; i < l - cl; ++i)
        {
            int j = i + cl;
            mat[i][j] = INT_MAX;
            for (int div = i; div < j; ++div)
            {
                int q = mat[i][div] + mat[div + 1][j] + p[i] * p[div] * p[j];
                if (q < mat[i][j])
                {
                    mat[i][j] = q;
                    s[i * l + j] = div;
                }
            }
        }
    }
    int result = mat[0][l - 1];

    // Free dynamically allocated memory
    for (int i = 0; i < l; ++i)
    {
        free(mat[i]);
    }
    free(mat);

    return result;
}

/**
 * @brief Recursively prints the solution
 * @param l dimension of the solutions array
 * @param s solutions
 * @param i starting index
 * @param j ending index
 * @returns void
 */
void printSolution(int l, int *s, int i, int j)
{
    if (i == j)
    {
        printf("A%d", i);
        return;
    }
    putchar('(');
    printSolution(l, s, i, s[i * l + j]);
    printSolution(l, s, s[i * l + j] + 1, j);
    putchar(')');
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    int sizes[] = {35, 15, 5, 10, 20, 25};
    int len = 6;
    int *sol = malloc(len * len * sizeof(int));
    int r = matrixChainOrder(len, sizes, sol);
    assert(r == 18625);
    printf("Result : %d\n", r);
    printf("Optimal ordering : ");
    printSolution(len, sol, 0, 5);
    free(sol);

    printf("\n");
}

/**
 * @brief Main function
 * @returns 0
 */
int main()
{
    test();  // run self-test implementations
    return 0;
}
`,`#include "matrix_chain_order.h"



undefined4 _matrixChainOrder(int param_1,long param_2,long param_3)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  long *plVar4;
  void *pvVar5;
  int local_54;
  int local_48;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  
  plVar4 = (long *)_malloc((long)param_1 << 3);
  for (local_34 = 0; local_34 < param_1; local_34 = local_34 + 1) {
    pvVar5 = _malloc((long)param_1 << 2);
    plVar4[local_34] = (long)pvVar5;
  }
  for (local_38 = 0; local_38 < param_1; local_38 = local_38 + 1) {
    *(undefined4 *)(plVar4[local_38] + (long)local_38 * 4) = 0;
  }
  for (local_3c = 1; local_3c < param_1; local_3c = local_3c + 1) {
    for (local_40 = 0; local_40 < param_1 - local_3c; local_40 = local_40 + 1) {
      iVar1 = local_40 + local_3c;
      *(undefined4 *)(plVar4[local_40] + (long)iVar1 * 4) = 0x7fffffff;
      for (local_48 = local_40; local_48 < iVar1; local_48 = local_48 + 1) {
        iVar2 = *(int *)(plVar4[local_40] + (long)local_48 * 4) +
                *(int *)(plVar4[local_48 + 1] + (long)iVar1 * 4) +
                *(int *)(param_2 + (long)local_40 * 4) * *(int *)(param_2 + (long)local_48 * 4) *
                *(int *)(param_2 + (long)iVar1 * 4);
        if (iVar2 < *(int *)(plVar4[local_40] + (long)iVar1 * 4)) {
          *(int *)(plVar4[local_40] + (long)iVar1 * 4) = iVar2;
          *(int *)(param_3 + (long)(local_40 * param_1 + iVar1) * 4) = local_48;
        }
      }
    }
  }
  uVar3 = *(undefined4 *)(*plVar4 + (long)(param_1 + -1) * 4);
  for (local_54 = 0; local_54 < param_1; local_54 = local_54 + 1) {
    _free((void *)plVar4[local_54]);
  }
  _free(plVar4);
  return uVar3;
}



int _printSolution(int param_1,long param_2,int param_3,int param_4)

{
  int iVar1;
  
  if (param_3 == param_4) {
    iVar1 = _printf("A%d");
  }
  else {
    _putchar(0x28);
    _printSolution(param_1,param_2,param_3,
                   *(undefined4 *)(param_2 + (long)(param_3 * param_1 + param_4) * 4));
    _printSolution(param_1,param_2,*(int *)(param_2 + (long)(param_3 * param_1 + param_4) * 4) + 1,
                   param_4);
    iVar1 = _putchar(0x29);
  }
  return iVar1;
}



undefined4 entry(void)

{
  FUN_100003dbc();
  return 0;
}



void FUN_100003dbc(void)

{
  int iVar1;
  void *pvVar2;
  undefined8 local_30;
  undefined8 uStack_28;
  undefined8 local_20;
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  uStack_28 = 0xa00000005;
  local_30 = 0xf00000023;
  local_20 = 0x1900000014;
  pvVar2 = _malloc(0x90);
  iVar1 = _matrixChainOrder(6,&local_30,pvVar2);
  if (iVar1 != 0x48c1) {
                    // WARNING: Subroutine does not return
    ___assert_rtn("test","matrix_chain_order.c",0x66,"r == 18625");
  }
  _printf("Result : %d\n");
  _printf("Optimal ordering : ");
  _printSolution(6,pvVar2,0,5);
  _free(pvVar2);
  iVar1 = _printf("\n");
  if (*(long *)PTR____stack_chk_guard_100004010 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ___assert_rtn(char *param_1,char *param_2,int param_3,char *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____assert_rtn_100004000)(param_1,param_2,param_3);
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004020)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004030)(param_1);
  return iVar1;
}


`
`#include <stdio.h>

void t(int n)
{
	int i, j, c, len;

	i = n * (n - 1) / 2;
	for (len = c = 1; c < i; c *= 10, len++);
	c -= i; // c is the col where width changes

#define SPEED_MATTERS 0
#if SPEED_MATTERS	// in case we really, really wanted to print huge triangles often
	char tmp[32], s[4096], *p;

	sprintf(tmp, "%*d", len, 0);

	inline void inc_numstr(void) {
		int k = len;

	redo:	if (!k--) return;

		if (tmp[k] == '9') {
			tmp[k] = '0';
			goto redo;
		}

		if (++tmp[k] == '!')
			tmp[k] = '1';
	}

	for (p = s, i = 1; i <= n; i++) {
		for (j = 1; j <= i; j++) {
			inc_numstr();
			__builtin_memcpy(p, tmp + 1 - (j >= c), len - (j < c));
			p += len - (j < c);

			*(p++) = (i - j)? ' ' : '\n';

			if (p - s + len >= 4096) {
				fwrite(s, 1, p - s, stdout);
				p = s;
			}
		}
	}

	fwrite(s, 1, p - s, stdout);
#else // NO_IT_DOESN'T
	int num;
	for (num = i = 1; i <= n; i++)
		for (j = 1; j <= i; j++)
			printf("%*d%c",	len - (j < c), num++, i - j ? ' ':'\n');
#endif
}

int main(void)
{
	t(5), t(14);

	// maybe not
	// t(10000);
	return 0;
}
`,`#include "floyds-triangle.h"



ulong _t(ulong param_1)

{
  int iVar1;
  uint uVar2;
  int local_20;
  int local_1c;
  int local_18;
  
  iVar1 = (int)param_1;
  for (local_20 = 1; local_20 < (iVar1 * (iVar1 + -1)) / 2; local_20 = local_20 * 10) {
  }
  for (local_18 = 1; local_18 <= iVar1; local_18 = local_18 + 1) {
    for (local_1c = 1; local_1c <= local_18; local_1c = local_1c + 1) {
      uVar2 = _printf("%*d%c");
      param_1 = (ulong)uVar2;
    }
  }
  return param_1;
}



undefined4 entry(void)

{
  _t(5);
  _t(0xe);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int
main()
{
	puts("");
	puts("\302\243"); /* if your terminal is utf-8 */
	return 0;
}
`,`#include "terminal-control-display-an-extended-character.h"



undefined4 entry(void)

{
  _puts(s__100003fa4);
  _puts(s__100003fa4);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

#define SIDE 600
#define NUM_PARTICLES 10000

bool W[SIDE][SIDE];

int main() {
    srand((unsigned)time(NULL));
    W[SIDE / 2][SIDE / 2] = true;

    for (int i = 0; i < NUM_PARTICLES; i++) {
        unsigned int x, y;
        OVER: do {
            x = rand() % (SIDE - 2) + 1;
            y = rand() % (SIDE - 2) + 1;
        } while (W[y][x]);

        while (W[y-1][x-1] + W[y-1][x] + W[y-1][x+1] +
               W[y][x-1]               + W[y][x+1] +
               W[y+1][x-1] + W[y+1][x] + W[y+1][x+1] == 0) {
            unsigned int dxy = rand() % 8;
            if (dxy > 3) dxy++;
            x += (dxy % 3) - 1;
            y += (dxy / 3) - 1;
            if (x < 1 || x >= SIDE - 1 || y < 1 || y >= SIDE - 1)
                goto OVER;
        }

        W[y][x] = true;
    }

    printf("P1\n%d %d\n", SIDE, SIDE);
    for (int r = 0; r < SIDE; r++) {
        for (int c = 0; c < SIDE; c++)
            printf("%d ", W[r][c]);
        putchar('\n');
    }
    return 0;
}
`,`#include "brownian-tree-2.h"



undefined8 entry(void)

{
  int iVar1;
  time_t tVar2;
  int local_2c;
  int local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  int local_18;
  
  tVar2 = _time((time_t *)0x0);
  _srand((uint)tVar2);
  DAT_10003404c = 1;
  local_18 = 0;
LAB_100003b70:
  if (9999 < local_18) {
    _printf("P1\n%d %d\n");
    for (local_28 = 0; local_28 < 600; local_28 = local_28 + 1) {
      for (local_2c = 0; local_2c < 600; local_2c = local_2c + 1) {
        _printf("%d ");
      }
      _putchar(10);
    }
    return 0;
  }
  do {
    do {
      iVar1 = _rand();
      local_1c = iVar1 % 0x256 + 1;
      iVar1 = _rand();
      local_20 = iVar1 % 0x256 + 1;
    } while (((&_W)[(ulong)local_1c + (ulong)local_20 * 600] & 1) != 0);
    do {
      if ((byte)(((&_W)[(ulong)(local_1c - 1) + (ulong)(local_20 - 1) * 600] & 1) +
                 ((&_W)[(ulong)local_1c + (ulong)(local_20 - 1) * 600] & 1) +
                 ((&_W)[(ulong)(local_1c + 1) + (ulong)(local_20 - 1) * 600] & 1) +
                 ((&_W)[(ulong)(local_1c - 1) + (ulong)local_20 * 600] & 1) +
                 ((&_W)[(ulong)(local_1c + 1) + (ulong)local_20 * 600] & 1) +
                 ((&_W)[(ulong)(local_1c - 1) + (ulong)(local_20 + 1) * 600] & 1) +
                 ((&_W)[(ulong)local_1c + (ulong)(local_20 + 1) * 600] & 1) +
                ((&_W)[(ulong)(local_1c + 1) + (ulong)(local_20 + 1) * 600] & 1)) != '\0') {
        (&_W)[(ulong)local_1c + (ulong)local_20 * 600] = 1;
        local_18 = local_18 + 1;
        goto LAB_100003b70;
      }
      iVar1 = _rand();
      local_24 = iVar1 % 8;
      if (3 < local_24) {
        local_24 = local_24 + 1;
      }
      local_1c = local_1c + (local_24 % 3 - 1);
      local_20 = local_20 + (local_24 / 3 - 1);
    } while ((((local_1c != 0) && (local_1c < 599)) && (local_20 != 0)) && (local_20 < 599));
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004008)(param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004010)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004018)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004020)();
  return tVar1;
}


`
`// Input file: input.txt
// Output file: output.txt
#include <stdio.h>
int main()
{
   freopen("input.txt", "rt", stdin);
   freopen("output.txt", "wt", stdout);
   int a, b;
   scanf("%d%d", &a, &b);
   printf("%d\n", a + b);
   return 0;
}
`,`#include "a+b-2.h"



undefined4 entry(void)

{
  _freopen("input.txt","rt",*(FILE **)PTR____stdinp_100004000);
  _freopen("output.txt","wt",*(FILE **)PTR____stdoutp_100004008);
  _scanf("%d%d");
  _printf("%d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _freopen(char *param_1,char *param_2,FILE *param_3)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__freopen_100004010)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004020)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define NUM_ROOMS 20
#define ARROWS 5

typedef enum { false, true } bool;

typedef struct {
    int connected[3];
    bool has_wumpus;
    bool has_bat;
    bool has_pit;
} Room;

Room cave[NUM_ROOMS + 1]; // Cave rooms are numbered from 1 to 20

void initialize_cave() {
    int i, j;
    // Initialize cave rooms
    for (i = 1; i <= NUM_ROOMS; i++) {
        for (j = 0; j < 3; j++) {
            cave[i].connected[j] = (i + j) % NUM_ROOMS + 1; // Circular connections
        }
        cave[i].has_wumpus = false;
        cave[i].has_bat = false;
        cave[i].has_pit = false;
    }
    // Randomly place wumpus, bats, and pits
    cave[rand() % NUM_ROOMS + 1].has_wumpus = true;
    for (i = 0; i < 2; i++) {
        cave[rand() % NUM_ROOMS + 1].has_bat = true;
        cave[rand() % NUM_ROOMS + 1].has_pit = true;
    }
}

void sense(int room) {
    printf("You are in room %d.\n", room);
    int i, adjacent_room;
    for (i = 0; i < 3; i++) {
        adjacent_room = cave[room].connected[i];
        if (cave[adjacent_room].has_wumpus)
            printf("You smell something terrible nearby.\n");
        if (cave[adjacent_room].has_bat)
            printf("You hear a rustling.\n");
        if (cave[adjacent_room].has_pit)
            printf("You feel a cold wind blowing from a nearby cavern.\n");
    }
}

void move(int *room) {
    int choice;
    printf("Choose an adjacent room to move into: ");
    scanf("%d", &choice);
    if (choice < 1 || choice > 3) {
        printf("Invalid choice. Please choose a number between 1 and 3.\n");
        move(room);
        return;
    }
    *room = cave[*room].connected[choice - 1];
}

void shoot(int room, int *arrows, bool *game_over) {
    int choice, adjacent_room;
    printf("Choose an adjacent room to shoot into: ");
    scanf("%d", &choice);
    if (choice < 1 || choice > 3) {
        printf("Invalid choice. Please choose a number between 1 and 3.\n");
        shoot(room, arrows, game_over);
        return;
    }
    adjacent_room = cave[room].connected[choice - 1];
    if (cave[adjacent_room].has_wumpus) {
        printf("Congratulations! You've killed the Wumpus!\n");
        *game_over = true;
        return;
    }
    else {
        if (rand() % 4 != 0) { // 75% chance of waking up the wumpus
            if (cave[adjacent_room].has_wumpus) {
                printf("The Wumpus has woken up and eaten you!\n");
                *game_over = true;
                return;
            }
        }
        printf("You missed! The Wumpus is still asleep.\n");
    }
    (*arrows)--;
}

int main() {
    srand(time(NULL));
    initialize_cave();
    int current_room = 1;
    int arrows = ARROWS;
    bool game_over = false;

    printf("Welcome to Hunt the Wumpus!\n");

    while (!game_over) {
        sense(current_room);
        printf("Choose your action:\n");
        printf("1. Move to an adjacent room\n");
        printf("2. Shoot into an adjacent room\n");

        int choice;
        printf("Enter your choice (1 or 2): ");
        scanf("%d", &choice);

        switch(choice) {
            case 1:
                move(&current_room);
                break;
            case 2:
                if (arrows > 0) {
                    shoot(current_room, &arrows, &game_over);
                } else {
                    printf("You're out of arrows! You lost the game.\n");
                    game_over = true;
                }
                break;
            default:
                printf("Invalid choice. Please choose 1 or 2.\n");
        }
    }

    return 0;
}
`,`#include "hunt-the-wumpus.h"



void _initialize_cave(void)

{
  int iVar1;
  int local_18;
  int local_14;
  
  for (local_14 = 1; local_14 < 0x15; local_14 = local_14 + 1) {
    for (local_18 = 0; local_18 < 3; local_18 = local_18 + 1) {
      *(int *)(&_cave + (long)local_18 * 4 + (long)local_14 * 0x18) =
           (local_14 + local_18) % 0x14 + 1;
    }
    *(undefined4 *)((long)local_14 * 0x18 + 0x10000800c) = 0;
    *(undefined4 *)((long)local_14 * 0x18 + 0x100008010) = 0;
    *(undefined4 *)((long)local_14 * 0x18 + 0x100008014) = 0;
  }
  iVar1 = _rand();
  *(undefined4 *)((long)(iVar1 % 0x14 + 1) * 0x18 + 0x10000800c) = 1;
  for (local_14 = 0; local_14 < 2; local_14 = local_14 + 1) {
    iVar1 = _rand();
    *(undefined4 *)((long)(iVar1 % 0x14 + 1) * 0x18 + 0x100008010) = 1;
    iVar1 = _rand();
    *(undefined4 *)((long)(iVar1 % 0x14 + 1) * 0x18 + 0x100008014) = 1;
  }
  return;
}



int _sense(int param_1)

{
  int iVar1;
  int iVar2;
  int local_18;
  
  iVar2 = _printf("You are in room %d.\n");
  for (local_18 = 0; local_18 < 3; local_18 = local_18 + 1) {
    iVar1 = *(int *)(&_cave + (long)local_18 * 4 + (long)param_1 * 0x18);
    if (*(int *)((long)iVar1 * 0x18 + 0x10000800c) != 0) {
      iVar2 = _printf("You smell something terrible nearby.\n");
    }
    if (*(int *)((long)iVar1 * 0x18 + 0x100008010) != 0) {
      iVar2 = _printf("You hear a rustling.\n");
    }
    if (*(int *)((long)iVar1 * 0x18 + 0x100008014) != 0) {
      iVar2 = _printf("You feel a cold wind blowing from a nearby cavern.\n");
    }
  }
  return iVar2;
}



int _move(int param_1,int param_2)

{
  int iVar1;
  int local_1c;
  
  _printf("Choose an adjacent room to move into: ");
  iVar1 = _scanf("%d");
  if ((local_1c < 1) || (3 < local_1c)) {
    _printf("Invalid choice. Please choose a number between 1 and 3.\n");
    iVar1 = _move(param_1,param_2);
  }
  else {
    *(int *)(ulong)(uint)param_1 =
         *(int *)(&_cave + (long)(local_1c + -1) * 4 + (long)*(int *)(ulong)(uint)param_1 * 0x18);
  }
  return iVar1;
}



ulong _shoot(int param_1,int *param_2,undefined4 *param_3)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  ulong uVar4;
  int local_2c;
  
  _printf("Choose an adjacent room to shoot into: ");
  _scanf("%d");
  if ((local_2c < 1) || (3 < local_2c)) {
    _printf("Invalid choice. Please choose a number between 1 and 3.\n");
    uVar4 = _shoot(param_1,param_2,param_3);
  }
  else {
    iVar1 = *(int *)(&_cave + (long)(local_2c + -1) * 4 + (long)param_1 * 0x18);
    if (*(int *)((long)iVar1 * 0x18 + 0x10000800c) == 0) {
      iVar3 = _rand();
      if ((iVar3 % 4 == 0) || (*(int *)((long)iVar1 * 0x18 + 0x10000800c) == 0)) {
        uVar2 = _printf("You missed! The Wumpus is still asleep.\n");
        uVar4 = (ulong)uVar2;
        *param_2 = *param_2 + -1;
      }
      else {
        uVar2 = _printf("The Wumpus has woken up and eaten you!\n");
        uVar4 = (ulong)uVar2;
        *param_3 = 1;
      }
    }
    else {
      uVar2 = _printf("Congratulations! You\'ve killed the Wumpus!\n");
      uVar4 = (ulong)uVar2;
      *param_3 = 1;
    }
  }
  return uVar4;
}



undefined8 entry(void)

{
  time_t tVar1;
  int extraout_w1;
  int iVar2;
  int local_24;
  int local_20;
  int local_1c;
  undefined4 local_18;
  undefined4 local_14;
  
  local_14 = 0;
  tVar1 = _time((time_t *)0x0);
  _srand((uint)tVar1);
  _initialize_cave();
  local_18 = 1;
  local_1c = 5;
  local_20 = 0;
  _printf("Welcome to Hunt the Wumpus!\n");
  while (local_20 == 0) {
    _sense(local_18);
    iVar2 = extraout_w1;
    _printf("Choose your action:\n");
    _printf("1. Move to an adjacent room\n");
    _printf("2. Shoot into an adjacent room\n");
    _printf("Enter your choice (1 or 2): ");
    _scanf("%d");
    if (local_24 == 1) {
      _move((int)&stack0xfffffffffffffff0 + -8,iVar2);
    }
    else if (local_24 == 2) {
      if (local_1c < 1) {
        _printf("You\'re out of arrows! You lost the game.\n");
        local_20 = 1;
      }
      else {
        _shoot(local_18,&local_1c,&local_20);
      }
    }
    else {
      _printf("Invalid choice. Please choose 1 or 2.\n");
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004008)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d20. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003d2c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004018)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d38. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004020)();
  return tVar1;
}


`
`#include <stdio.h>
#include <string.h>

void wrap_text(char *line_start, int width) {
  char *last_space = 0;
  char *p;

  for (p = line_start; *p; p++) {
    if (*p == '\n') {
      line_start = p + 1;
    }

    if (*p == ' ') {
      last_space = p;
    }

    if (p - line_start > width && last_space) {
      *last_space = '\n';
      line_start = last_space + 1;
      last_space = 0;
    }
  }
}

char const text[] =
    "In olden times when wishing still helped one, there lived a king whose "
    "daughters were all beautiful, but the youngest was so beautiful that the "
    "sun itself, which has seen so much, was astonished whenever it shone in "
    "her face. Close by the king's castle lay a great dark forest, and under "
    "an old lime-tree in the forest was a well, and when the day was very "
    "warm, the king's child went out into the forest and sat down by the side "
    "of the cool fountain, and when she was bored she took a golden ball, and "
    "threw it up on high and caught it, and this ball was her favorite "
    "plaything.";

int main(void) {
  char buf[sizeof(text)];

  puts("--- 80 ---");
  memcpy(buf, text, sizeof(text));
  wrap_text(buf, 80);
  puts(buf);

  puts("\n--- 72 ---");
  memcpy(buf, text, sizeof(text));
  wrap_text(buf, 72);
  puts(buf);
}
`,`#include "word-wrap-2.h"



void _wrap_text(char *param_1,int param_2)

{
  char *local_20;
  char *local_18;
  char *local_8;
  
  local_18 = (char *)0x0;
  local_8 = param_1;
  for (local_20 = param_1; *local_20 != '\0'; local_20 = local_20 + 1) {
    if (*local_20 == '\n') {
      local_8 = local_20 + 1;
    }
    if (*local_20 == ' ') {
      local_18 = local_20;
    }
    if (((long)param_2 < (long)local_20 - (long)local_8) && (local_18 != (char *)0x0)) {
      *local_18 = '\n';
      local_8 = local_18 + 1;
      local_18 = (char *)0x0;
    }
  }
  return;
}



undefined8 entry(void)

{
  int iVar1;
  char acStack_26c [580];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _puts("--- 80 ---");
  _memcpy(acStack_26c,
          "In olden times when wishing still helped one, there lived a king whose daughters were all beautiful, but the youngest was so beautiful that the sun itself, which has seen so much, was astonished whenever it shone in her face. Close by the king\'s castle lay a great dark forest, and under an old lime-tree in the forest was a well, and when the day was very warm, the king\'s child went out into the forest and sat down by the side of the cool fountain, and when she was bored she took a golden ball, and threw it up on high and caught it, and this ball was her favorite plaything."
          ,0x244);
  _wrap_text(acStack_26c,0x50);
  _puts(acStack_26c);
  _puts("\n--- 72 ---");
  _memcpy(acStack_26c,
          "In olden times when wishing still helped one, there lived a king whose daughters were all beautiful, but the youngest was so beautiful that the sun itself, which has seen so much, was astonished whenever it shone in her face. Close by the king\'s castle lay a great dark forest, and under an old lime-tree in the forest was a well, and when the day was very warm, the king\'s child went out into the forest and sat down by the side of the cool fountain, and when she was bored she took a golden ball, and threw it up on high and caught it, and this ball was her favorite plaything."
          ,0x244);
  _wrap_text(acStack_26c,0x48);
  iVar1 = _puts(acStack_26c);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003d28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d34. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d40. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdlib.h>
#include <stdio.h>
#include <sys/stat.h>

int main(void)
{
  struct stat foo;
  stat("input.txt", &foo);
  printf("%ld\n", foo.st_size);
  stat("/input.txt", &foo);
  printf("%ld\n", foo.st_size);
  return 0;
}
`,`#include "file-size-2.h"



undefined4 entry(void)

{
  stat sStack_a8;
  undefined4 local_14;
  
  local_14 = 0;
  _stat("input.txt",&sStack_a8);
  _printf("%ld\n");
  _stat("/input.txt",&sStack_a8);
  _printf("%ld\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _stat(char *param_1,stat *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__stat_100004008)((int)param_1);
  return iVar1;
}


`
`//This code implements the print of 15 first Catalan's Numbers
//Formula used:
//  __n__
//   | |  (n + k) / k  n>0
//   k=2

#include <stdio.h>
#include <stdlib.h>

//the number of Catalan's Numbers to be printed
const int N = 15;

int main()
{
    //loop variables (in registers)
    register int k, n;

    //necessarily ull for reach big values
    unsigned long long int num, den;

    //the nmmber
    int catalan;

    //the first is not calculated for the formula
    printf("1 ");

    //iterating from 2 to 15
    for (n=2; n<=N; ++n) {
        //initializaing for products
        num = den = 1;
        //applying the formula
        for (k=2; k<=n; ++k) {
            num *= (n+k);
            den *= k;
            catalan = num /den;
        }

        //output
        printf("%d ", catalan);
    }

    //the end
    printf("\n");
    return 0;
}
`,`#include "catalan-numbers-pascals-triangle.h"



undefined8 entry(void)

{
  int local_1c;
  int local_18;
  
  _printf("1 ");
  for (local_1c = 2; local_1c < 0x10; local_1c = local_1c + 1) {
    for (local_18 = 2; local_18 <= local_1c; local_18 = local_18 + 1) {
    }
    _printf("%d ");
  }
  _printf("\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main(void)
{
  printf("%s\n",
         ( (727 == 0x2d7) &&
           (727 == 01327)    ) ? "true" : "false");

  return 0;
}
`,`#include "literals-integer.h"



undefined4 entry(void)

{
  _printf("%s\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Wheel {
    char *seq;
    int len;
    int pos;
};

struct Wheel *create(char *seq) {
    struct Wheel *w = malloc(sizeof(struct Wheel));
    if (w == NULL) {
        return NULL;
    }

    w->seq = seq;
    w->len = strlen(seq);
    w->pos = 0;

    return w;
}

char cycle(struct Wheel *w) {
    char c = w->seq[w->pos];
    w->pos = (w->pos + 1) % w->len;
    return c;
}

struct Map {
    struct Wheel *v;
    struct Map *next;
    char k;
};

struct Map *insert(char k, struct Wheel *v, struct Map *head) {
    struct Map *m = malloc(sizeof(struct Map));
    if (m == NULL) {
        return NULL;
    }

    m->k = k;
    m->v = v;
    m->next = head;

    return m;
}

struct Wheel *find(char k, struct Map *m) {
    struct Map *ptr = m;

    while (ptr != NULL) {
        if (ptr->k == k) {
            return ptr->v;
        }
        ptr = ptr->next;
    }

    return NULL;
}

void printOne(char k, struct Map *m) {
    struct Wheel *w = find(k, m);
    char c;

    if (w == NULL) {
        printf("Missing the wheel for: %c\n", k);
        exit(1);
    }

    c = cycle(w);
    if ('0' <= c && c <= '9') {
        printf(" %c", c);
    } else {
        printOne(c, m);
    }
}

void exec(char start, struct Map *m) {
    struct Wheel *w;
    int i;

    if (m == NULL) {
        printf("Unable to proceed.");
        return;
    }

    for (i = 0; i < 20; i++) {
        printOne(start, m);
    }
    printf("\n");
}

void group1() {
    struct Wheel *a = create("123");

    struct Map *m = insert('A', a, NULL);

    exec('A', m);
}

void group2() {
    struct Wheel *a = create("1B2");
    struct Wheel *b = create("34");

    struct Map *m = insert('A', a, NULL);
    m = insert('B', b, m);

    exec('A', m);
}

void group3() {
    struct Wheel *a = create("1DD");
    struct Wheel *d = create("678");

    struct Map *m = insert('A', a, NULL);
    m = insert('D', d, m);

    exec('A', m);
}

void group4() {
    struct Wheel *a = create("1BC");
    struct Wheel *b = create("34");
    struct Wheel *c = create("5B");

    struct Map *m = insert('A', a, NULL);
    m = insert('B', b, m);
    m = insert('C', c, m);

    exec('A', m);
}

int main() {
    group1();
    group2();
    group3();
    group4();

    return 0;
}
`,`#include "intersecting-number-wheels.h"



undefined8 * _create(char *param_1)

{
  size_t sVar1;
  undefined8 *local_18;
  
  local_18 = (undefined8 *)_malloc(0x10);
  if (local_18 == (undefined8 *)0x0) {
    local_18 = (undefined8 *)0x0;
  }
  else {
    *local_18 = param_1;
    sVar1 = _strlen(param_1);
    *(int *)(local_18 + 1) = (int)sVar1;
    *(undefined4 *)((long)local_18 + 0xc) = 0;
  }
  return local_18;
}



long _cycle(long *param_1)

{
  int iVar1;
  int iVar2;
  char cVar3;
  int iVar4;
  
  cVar3 = *(char *)(*param_1 + (long)*(int *)((long)param_1 + 0xc));
  iVar1 = *(int *)((long)param_1 + 0xc) + 1;
  iVar2 = *(int *)(param_1 + 1);
  iVar4 = 0;
  if (iVar2 != 0) {
    iVar4 = iVar1 / iVar2;
  }
  *(int *)((long)param_1 + 0xc) = iVar1 - iVar4 * iVar2;
  return (long)cVar3;
}



undefined8 * _insert(undefined param_1,undefined8 param_2,undefined8 param_3)

{
  undefined8 *local_18;
  
  local_18 = (undefined8 *)_malloc(0x18);
  if (local_18 == (undefined8 *)0x0) {
    local_18 = (undefined8 *)0x0;
  }
  else {
    *(undefined *)(local_18 + 2) = param_1;
    *local_18 = param_2;
    local_18[1] = param_3;
  }
  return local_18;
}



undefined8 _find(char param_1,undefined8 *param_2)

{
  undefined8 *local_20;
  
  local_20 = param_2;
  while( true ) {
    if (local_20 == (undefined8 *)0x0) {
      return 0;
    }
    if (*(char *)(local_20 + 2) == param_1) break;
    local_20 = (undefined8 *)local_20[1];
  }
  return *local_20;
}



ulong _printOne(undefined param_1,undefined8 param_2)

{
  char cVar1;
  uint uVar2;
  long lVar3;
  ulong uVar4;
  
  lVar3 = _find(param_1,param_2);
  if (lVar3 == 0) {
    _printf("Missing the wheel for: %c\n");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  cVar1 = _cycle(lVar3);
  if ((cVar1 < '0') || ('9' < cVar1)) {
    uVar4 = _printOne((long)cVar1,param_2);
  }
  else {
    uVar2 = _printf(" %c");
    uVar4 = (ulong)uVar2;
  }
  return uVar4;
}



int _exec(undefined param_1,long param_2)

{
  int iVar1;
  int local_2c;
  
  if (param_2 == 0) {
    iVar1 = _printf("Unable to proceed.");
  }
  else {
    for (local_2c = 0; local_2c < 0x14; local_2c = local_2c + 1) {
      _printOne(param_1,param_2);
    }
    iVar1 = _printf("\n");
  }
  return iVar1;
}



void _group1(void)

{
  undefined8 uVar1;
  
  uVar1 = _create("123");
  uVar1 = _insert(0x41,uVar1,0);
  _exec(0x41,uVar1);
  return;
}



void _group2(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  
  uVar1 = _create("1B2");
  uVar2 = _create("34");
  uVar1 = _insert(0x41,uVar1,0);
  uVar1 = _insert(0x42,uVar2,uVar1);
  _exec(0x41,uVar1);
  return;
}



void _group3(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  
  uVar1 = _create("1DD");
  uVar2 = _create("678");
  uVar1 = _insert(0x41,uVar1,0);
  uVar1 = _insert(0x44,uVar2,uVar1);
  _exec(0x41,uVar1);
  return;
}



void _group4(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  
  uVar1 = _create("1BC");
  uVar2 = _create("34");
  uVar3 = _create("5B");
  uVar1 = _insert(0x41,uVar1,0);
  uVar1 = _insert(0x42,uVar2,uVar1);
  uVar1 = _insert(0x43,uVar3,uVar1);
  _exec(0x41,uVar1);
  return;
}



undefined4 entry(void)

{
  _group1();
  _group2();
  _group3();
  _group4();
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f18. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004000)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f24. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_100004018)();
  return sVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

#define decl_tree_type(T)                                                       \
        typedef struct node_##T##_t node_##T##_t, *node_##T;                    \
        struct node_##T##_t { node_##T left, right; T value; };                 \
                                                                                \
        node_##T node_##T##_new(T v) {                                          \
                node_##T node = malloc(sizeof(node_##T##_t));                   \
                node->value = v;                                                \
                node->left = node->right = 0;                                   \
                return node;                                                    \
        }                                                                       \
        node_##T node_##T##_insert(node_##T root, T v) {                        \
                node_##T n = node_##T##_new(v);                                 \
                while (root) {                                                  \
                        if (root->value < n->value)                             \
                                if (!root->left) return root->left = n;         \
                                else root = root->left;                         \
                        else                                                    \
                                if (!root->right) return root->right = n;       \
                                else root = root->right;                        \
                }                                                               \
                return 0;                                                       \
        }

#define tree_node(T) node_##T
#define node_insert(T, r, x) node_##T##_insert(r, x)
#define node_new(T, x) node_##T##_new(x)

decl_tree_type(double);
decl_tree_type(int);

int main()
{
        int i;
        tree_node(double) root_d = node_new(double, (double)rand() / RAND_MAX);

        for (i = 0; i < 10000; i++)
                node_insert(double, root_d, (double)rand() / RAND_MAX);

        tree_node(int) root_i = node_new(int, rand());
        for (i = 0; i < 10000; i++)
                node_insert(int, root_i, rand());

        return 0;
}
`,`#include "parametric-polymorphism.h"



undefined8 * _node_double_new(undefined8 param_1)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(0x18);
  puVar1[2] = param_1;
  puVar1[1] = 0;
  *puVar1 = 0;
  return puVar1;
}



long _node_double_insert(undefined8 param_1,long *param_2)

{
  long lVar1;
  long *local_20;
  
  lVar1 = _node_double_new(param_1);
  local_20 = param_2;
  while( true ) {
    while( true ) {
      if (local_20 == (long *)0x0) {
        return 0;
      }
      if (*(double *)(lVar1 + 0x10) <= (double)local_20[2]) break;
      if (*local_20 == 0) {
        *local_20 = lVar1;
        return lVar1;
      }
      local_20 = (long *)*local_20;
    }
    if (local_20[1] == 0) break;
    local_20 = (long *)local_20[1];
  }
  local_20[1] = lVar1;
  return lVar1;
}



undefined8 * _node_int_new(undefined4 param_1)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(0x18);
  *(undefined4 *)(puVar1 + 2) = param_1;
  puVar1[1] = 0;
  *puVar1 = 0;
  return puVar1;
}



long _node_int_insert(long *param_1,undefined4 param_2)

{
  long lVar1;
  long *local_20;
  
  lVar1 = _node_int_new(param_2);
  local_20 = param_1;
  while( true ) {
    while( true ) {
      if (local_20 == (long *)0x0) {
        return 0;
      }
      if (*(int *)(lVar1 + 0x10) <= *(int *)(local_20 + 2)) break;
      if (*local_20 == 0) {
        *local_20 = lVar1;
        return lVar1;
      }
      local_20 = (long *)*local_20;
    }
    if (local_20[1] == 0) break;
    local_20 = (long *)local_20[1];
  }
  local_20[1] = lVar1;
  return lVar1;
}



undefined8 entry(void)

{
  int iVar1;
  undefined8 uVar2;
  undefined4 local_18;
  
  iVar1 = _rand();
  uVar2 = _node_double_new((double)iVar1 / 2147483647.0);
  for (local_18 = 0; local_18 < 10000; local_18 = local_18 + 1) {
    iVar1 = _rand();
    _node_double_insert((double)iVar1 / 2147483647.0,uVar2);
  }
  iVar1 = _rand();
  uVar2 = _node_int_new(iVar1);
  for (local_18 = 0; local_18 < 10000; local_18 = local_18 + 1) {
    iVar1 = _rand();
    _node_int_insert(uVar2,iVar1);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f90. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004000)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004008)();
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int compareInts(const void *i1, const void *i2) {
    int a = *((int *)i1);
    int b = *((int *)i2);
    return a - b;
}

int main() {
    int i, j, nsum, vsum, vcount, values[6], numbers[4];
    srand(time(NULL));
    for (;;) {
        vsum = 0;
        for (i = 0; i < 6; ++i) {
            for (j = 0; j < 4; ++j) {
                numbers[j] = 1 + rand() % 6;
            }
            qsort(numbers, 4, sizeof(int), compareInts);
            nsum = 0;
            for (j = 1; j < 4; ++j) {
                nsum += numbers[j];
            }
            values[i] = nsum;
            vsum += values[i];
        }
        if (vsum < 75) continue;
        vcount = 0;
        for (j = 0; j < 6; ++j) {
            if (values[j] >= 15) vcount++;
        }
        if (vcount < 2) continue;
        printf("The 6 random numbers generated are:\n");
        printf("[");
        for (j = 0; j < 6; ++j) printf("%d ", values[j]);
        printf("\b]\n");
        printf("\nTheir sum is %d and %d of them are >= 15\n", vsum, vcount);
        break;
    }
    return 0;
}
`,`#include "rpg-attributes-generator.h"



int _compareInts(int *param_1,int *param_2)

{
  return *param_1 - *param_2;
}



undefined8 entry(void)

{
  int iVar1;
  time_t tVar2;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int aiStack_40 [4];
  int aiStack_30 [6];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  tVar2 = _time((time_t *)0x0);
  _srand((uint)tVar2);
  do {
    do {
      local_54 = 0;
      for (local_48 = 0; local_48 < 6; local_48 = local_48 + 1) {
        for (local_4c = 0; local_4c < 4; local_4c = local_4c + 1) {
          iVar1 = _rand();
          aiStack_40[local_4c] = iVar1 % 6 + 1;
        }
        _qsort(aiStack_40,4,4,(int *)_compareInts);
        local_50 = 0;
        for (local_4c = 1; local_4c < 4; local_4c = local_4c + 1) {
          local_50 = local_50 + aiStack_40[local_4c];
        }
        aiStack_30[local_48] = local_50;
        local_54 = local_54 + aiStack_30[local_48];
      }
    } while (local_54 < 0x4b);
    local_58 = 0;
    for (local_4c = 0; local_4c < 6; local_4c = local_4c + 1) {
      if (0xe < aiStack_30[local_4c]) {
        local_58 = local_58 + 1;
      }
    }
  } while (local_58 < 2);
  _printf("The 6 random numbers generated are:\n");
  _printf("[");
  for (local_4c = 0; local_4c < 6; local_4c = local_4c + 1) {
    _printf("%d ");
  }
  _printf("\b]\n");
  iVar1 = _printf("\nTheir sum is %d and %d of them are >= 15\n");
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar1);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f04. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f10. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004020)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004028)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004030)();
  return tVar1;
}


`
`#include <stdio.h>

typedef unsigned long long ull;

ull binomial(ull m, ull n)
{
	ull r = 1, d = m - n;
	if (d > n) { n = d; d = m - n; }

	while (m > n) {
		r *= m--;
		while (d > 1 && ! (r%d) ) r /= d--;
	}

	return r;
}

ull catalan1(int n) {
	return binomial(2 * n, n) / (1 + n);
}

ull catalan2(int n) {
	int i;
	ull r = !n;

	for (i = 0; i < n; i++)
		r += catalan2(i) * catalan2(n - 1 - i);
	return r;
}

ull catalan3(int n)
{
	return n ? 2 * (2 * n - 1) * catalan3(n - 1) / (1 + n) : 1;
}

int main(void)
{
	int i;
	puts("\tdirect\tsumming\tfrac");
	for (i = 0; i < 16; i++) {
		printf("%d\t%llu\t%llu\t%llu\n", i,
			catalan1(i), catalan2(i), catalan3(i));
	}

	return 0;
}
`,`#include "catalan-numbers.h"



ulong _binomial(ulong param_1,ulong param_2)

{
  ulong uVar1;
  ulong uVar2;
  ulong uVar3;
  bool bVar4;
  undefined8 local_20;
  undefined8 local_18;
  undefined8 local_10;
  undefined8 local_8;
  
  local_18 = 1;
  uVar1 = param_1 - param_2;
  local_20 = uVar1;
  local_8 = param_1;
  local_10 = param_2;
  if (param_2 < uVar1) {
    local_20 = param_1 - uVar1;
    local_8 = param_1;
    local_10 = uVar1;
  }
  while (local_10 < local_8) {
    uVar1 = local_8 - 1;
    uVar2 = local_20;
    uVar3 = local_18 * local_8;
    while( true ) {
      local_18 = uVar3;
      local_20 = uVar2;
      bVar4 = false;
      if (1 < local_20) {
        uVar2 = 0;
        if (local_20 != 0) {
          uVar2 = local_18 / local_20;
        }
        bVar4 = local_18 == uVar2 * local_20;
      }
      local_8 = uVar1;
      if (!bVar4) break;
      uVar2 = local_20 - 1;
      uVar3 = 0;
      if (local_20 != 0) {
        uVar3 = local_18 / local_20;
      }
    }
  }
  return local_18;
}



ulong _catalan1(int param_1)

{
  ulong uVar1;
  ulong uVar2;
  
  uVar2 = _binomial((long)(param_1 * 2),(long)param_1);
  uVar1 = 0;
  if ((long)(param_1 + 1) != 0) {
    uVar1 = uVar2 / (ulong)(long)(param_1 + 1);
  }
  return uVar1;
}



ulong _catalan2(int param_1)

{
  long lVar1;
  long lVar2;
  undefined8 local_20;
  undefined4 local_18;
  
  local_20 = (ulong)(param_1 == 0);
  for (local_18 = 0; local_18 < param_1; local_18 = local_18 + 1) {
    lVar1 = _catalan2(local_18);
    lVar2 = _catalan2((param_1 + -1) - local_18);
    local_20 = local_20 + lVar1 * lVar2;
  }
  return local_20;
}



ulong _catalan3(int param_1)

{
  long lVar1;
  undefined8 local_20;
  
  if (param_1 == 0) {
    local_20 = 1;
  }
  else {
    lVar1 = _catalan3(param_1 + -1);
    local_20 = 0;
    if ((long)(param_1 + 1) != 0) {
      local_20 = (ulong)(((param_1 * 2 + -1) * 2) * lVar1) / (ulong)(long)(param_1 + 1);
    }
  }
  return local_20;
}



undefined8 entry(void)

{
  int local_18;
  
  _puts("\tdirect\tsumming\tfrac");
  for (local_18 = 0; local_18 < 0x10; local_18 = local_18 + 1) {
    _catalan1(local_18);
    _catalan2(local_18);
    _catalan3(local_18);
    _printf("%d\t%llu\t%llu\t%llu\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f68. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

int spiral(int w, int h, int x, int y)
{
	return y ? w + spiral(h - 1, w, y - 1, w - x - 1) : x;
}

int main(int argc, char **argv)
{
	int w = atoi(argv[1]), h = atoi(argv[2]), i, j;
	for (i = 0; i < h; i++) {
		for (j = 0; j < w; j++)
			printf("%4d", spiral(w, h, j, i));
		putchar('\n');
	}
	return 0;
}
`,`#include "spiral-matrix-2.h"



int _spiral(int param_1,int param_2,int param_3,int param_4)

{
  int local_24;
  
  local_24 = param_3;
  if (param_4 != 0) {
    local_24 = _spiral(param_2 + -1,param_1,param_4 + -1,(param_1 - param_3) + -1);
    local_24 = param_1 + local_24;
  }
  return local_24;
}



undefined8 entry(undefined8 param_1,long param_2)

{
  int iVar1;
  int iVar2;
  int local_30;
  int local_2c;
  
  iVar1 = _atoi(*(char **)(param_2 + 8));
  iVar2 = _atoi(*(char **)(param_2 + 0x10));
  for (local_2c = 0; local_2c < iVar2; local_2c = local_2c + 1) {
    for (local_30 = 0; local_30 < iVar1; local_30 = local_30 + 1) {
      _spiral(iVar1,iVar2,local_30,local_2c);
      _printf("%4d");
    }
    _putchar(10);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _atoi(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__atoi_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004008)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putchar(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putchar_100004010)(param_1);
  return iVar1;
}


`
`#include<stdio.h>

int main()
{
	int num = 9876432,diff[] = {4,2,2,2},i,j,k=0;
	char str[10];
	
		start:snprintf(str,10,"%d",num);

		for(i=0;str[i+1]!=00;i++){
			if(str[i]=='0'||str[i]=='5'||num%(str[i]-'0')!=0){
				num -= diff[k];
				k = (k+1)%4;
				goto start;
			}
			for(j=i+1;str[j]!=00;j++)
				if(str[i]==str[j]){
					num -= diff[k];
					k = (k+1)%4;
					goto start;
			}
		}	
	
	printf("Number found : %d",num);
	return 0;
}
`,`#include "largest-number-divisible-by-its-digits-1.h"



undefined8 entry(void)

{
  int iVar1;
  int iVar2;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  char acStack_3a [10];
  int local_30 [6];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_44 = 0x96b3d0;
  local_30[2] = 2;
  local_30[3] = 2;
  local_30[0] = 4;
  local_30[1] = 2;
  local_50 = 0;
LAB_100003d68:
  do {
    ___snprintf_chk(acStack_3a,10,0,10,"%d");
    local_48 = 0;
    while( true ) {
      if (acStack_3a[local_48 + 1] == '\0') {
        iVar2 = _printf("Number found : %d");
        if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
          return 0;
        }
                    // WARNING: Subroutine does not return
        ___stack_chk_fail(iVar2);
      }
      if ((acStack_3a[local_48] == '0') || (acStack_3a[local_48] == '5')) break;
      iVar1 = acStack_3a[local_48] + -0x30;
      iVar2 = 0;
      if (iVar1 != 0) {
        iVar2 = local_44 / iVar1;
      }
      local_4c = local_48;
      if (local_44 != iVar2 * iVar1) break;
      while (local_4c = local_4c + 1, acStack_3a[local_4c] != '\0') {
        if (acStack_3a[local_48] == acStack_3a[local_4c]) {
          local_44 = local_44 - local_30[local_50];
          local_50 = (local_50 + 1) % 4;
          goto LAB_100003d68;
        }
      }
      local_48 = local_48 + 1;
    }
    local_44 = local_44 - local_30[local_50];
    local_50 = (local_50 + 1) % 4;
  } while( true );
}



void ___snprintf_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____snprintf_chk_100004000)();
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include<stdlib.h>
#include<stdio.h>
#include<math.h>

typedef struct{
	double x,y;
}point;

double lineSlope(point a,point b){
	
	if(a.x-b.x == 0.0)
		return NAN;
	else
		return (a.y-b.y)/(a.x-b.x);
}

point extractPoint(char* str){
	int i,j,start,end,length;
	char* holder;
	point c;
	
	for(i=0;str[i]!=00;i++){
		if(str[i]=='(')
			start = i;
		if(str[i]==','||str[i]==')')
		{
			end = i;
			
			length = end - start;
			
			holder = (char*)malloc(length*sizeof(char));
			
			for(j=0;j<length-1;j++)
				holder[j] = str[start + j + 1];
			holder[j] = 00;
			
			if(str[i]==','){
				start = i;
				c.x = atof(holder);
			}
			else
				c.y = atof(holder);
		}
	}
	
	return c;
}

point intersectionPoint(point a1,point a2,point b1,point b2){
	point c;
	
	double slopeA = lineSlope(a1,a2), slopeB = lineSlope(b1,b2);
	
	if(slopeA==slopeB){
		c.x = NAN;
		c.y = NAN;
	}
	else if(isnan(slopeA) && !isnan(slopeB)){
		c.x = a1.x;
		c.y = (a1.x-b1.x)*slopeB + b1.y;
	}
	else if(isnan(slopeB) && !isnan(slopeA)){
		c.x = b1.x;
		c.y = (b1.x-a1.x)*slopeA + a1.y;
	}
	else{
		c.x = (slopeA*a1.x - slopeB*b1.x + b1.y - a1.y)/(slopeA - slopeB);
		c.y = slopeB*(c.x - b1.x) + b1.y;
	}
	
	return c;
}

int main(int argC,char* argV[])
{
	point c;
	
	if(argC < 5)
		printf("Usage : %s <four points specified as (x,y) separated by a space>",argV[0]);
	else{
		c = intersectionPoint(extractPoint(argV[1]),extractPoint(argV[2]),extractPoint(argV[3]),extractPoint(argV[4]));
		
		if(isnan(c.x))
			printf("The lines do not intersect, they are either parallel or co-incident.");
		else
			printf("Point of intersection : (%lf,%lf)",c.x,c.y);
	}
	
	return 0;
}
`,`#include "find-the-intersection-of-two-lines.h"



undefined  [16] _lineSlope(double param_1,double param_2,double param_3,double param_4)

{
  undefined auVar1 [16];
  undefined8 local_8;
  
  if (param_1 - param_3 == 0.0) {
    local_8 = NAN;
  }
  else {
    local_8 = (param_2 - param_4) / (param_1 - param_3);
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_8;
  return auVar1;
}



undefined  [16] _extractPoint(long param_1)

{
  char *pcVar1;
  undefined auVar2 [16];
  int local_34;
  int local_30;
  int local_2c;
  double local_20;
  
  for (local_2c = 0; *(char *)(param_1 + local_2c) != '\0'; local_2c = local_2c + 1) {
    if (*(char *)(param_1 + local_2c) == '(') {
      local_34 = local_2c;
    }
    if ((*(char *)(param_1 + local_2c) == ',') || (*(char *)(param_1 + local_2c) == ')')) {
      pcVar1 = (char *)_malloc((long)(local_2c - local_34));
      for (local_30 = 0; local_30 < (local_2c - local_34) + -1; local_30 = local_30 + 1) {
        pcVar1[local_30] = *(char *)(param_1 + (local_34 + local_30 + 1));
      }
      pcVar1[local_30] = '\0';
      if (*(char *)(param_1 + local_2c) == ',') {
        local_34 = local_2c;
        local_20 = _atof(pcVar1);
      }
      else {
        _atof(pcVar1);
      }
    }
  }
  auVar2._8_8_ = 0;
  auVar2._0_8_ = local_20;
  return auVar2;
}



// WARNING: Removing unreachable block (ram,0x000100003c58)
// WARNING: Removing unreachable block (ram,0x000100003c7c)
// WARNING: Removing unreachable block (ram,0x000100003bc4)
// WARNING: Removing unreachable block (ram,0x000100003be8)
// WARNING: Removing unreachable block (ram,0x000100003b08)
// WARNING: Removing unreachable block (ram,0x000100003b2c)
// WARNING: Removing unreachable block (ram,0x000100003a74)
// WARNING: Removing unreachable block (ram,0x000100003a98)
// WARNING: Removing unreachable block (ram,0x000100003a10)
// WARNING: Removing unreachable block (ram,0x000100003a3c)
// WARNING: Removing unreachable block (ram,0x000100003aa4)
// WARNING: Removing unreachable block (ram,0x000100003ad0)
// WARNING: Removing unreachable block (ram,0x000100003b60)
// WARNING: Removing unreachable block (ram,0x000100003b8c)
// WARNING: Removing unreachable block (ram,0x000100003bf4)
// WARNING: Removing unreachable block (ram,0x000100003c20)
// WARNING: Removing unreachable block (ram,0x000100003a9c)
// WARNING: Removing unreachable block (ram,0x000100003b04)
// WARNING: Removing unreachable block (ram,0x000100003bec)

undefined  [16]
_intersectionPoint(undefined8 param_1,double param_2,undefined8 param_3,undefined8 param_4,
                  double param_5,double param_6,undefined8 param_7,undefined8 param_8)

{
  double dVar1;
  double dVar2;
  double dVar3;
  undefined auVar4 [16];
  undefined8 local_70;
  
  dVar1 = (double)_lineSlope(param_1,param_2,param_3,param_4);
  dVar2 = (double)_lineSlope(param_5,param_6,param_7,param_8);
  if (dVar1 == dVar2) {
    local_70 = NAN;
  }
  else {
    dVar3 = (double)NEON_fnmsub(dVar1,param_1,dVar2 * param_5);
    local_70 = ((dVar3 + param_6) - param_2) / (dVar1 - dVar2);
    NEON_fmadd(dVar2,local_70 - param_5,param_6);
  }
  auVar4._8_8_ = 0;
  auVar4._0_8_ = local_70;
  return auVar4;
}



// WARNING: Removing unreachable block (ram,0x000100003e5c)
// WARNING: Removing unreachable block (ram,0x000100003e80)
// WARNING: Removing unreachable block (ram,0x000100003df8)
// WARNING: Removing unreachable block (ram,0x000100003e24)
// WARNING: Removing unreachable block (ram,0x000100003e84)

undefined8 entry(undefined param_1 [16],undefined8 param_2,int param_3,long param_4)

{
  undefined8 uVar1;
  undefined8 uVar2;
  undefined8 uVar3;
  undefined8 uVar4;
  undefined8 uVar5;
  undefined8 uVar6;
  undefined8 uVar7;
  
  if (param_3 < 5) {
    _printf("Usage : %s <four points specified as (x,y) separated by a space>");
  }
  else {
    uVar1 = _extractPoint(*(undefined8 *)(param_4 + 8));
    uVar5 = param_2;
    uVar2 = _extractPoint(*(undefined8 *)(param_4 + 0x10));
    uVar6 = uVar5;
    uVar3 = _extractPoint(*(undefined8 *)(param_4 + 0x18));
    uVar7 = uVar6;
    uVar4 = _extractPoint(*(undefined8 *)(param_4 + 0x20));
    _intersectionPoint(uVar1,param_2,uVar2,uVar5,uVar3,uVar6,uVar4,uVar7);
    _printf("Point of intersection : (%lf,%lf)");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double _atof(char *param_1)

{
  double dVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ed4. Too many branches
                    // WARNING: Treating indirect jump as call
  dVar1 = (double)(*(code *)PTR__atof_100004000)();
  return dVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ee0. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004008)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003eec. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>

int main()
{
  char is_open[100] = { 0 };
  int pass, door;

  /* do the 100 passes */
  for (pass = 0; pass < 100; ++pass)
    for (door = pass; door < 100; door += pass+1)
      is_open[door] = !is_open[door];

  /* output the result */
  for (door = 0; door < 100; ++door)
    printf("door #%d is %s.\n", door+1, (is_open[door]? "open" : "closed"));

  return 0;
}
`,`#include "100-doors-1.h"



undefined8 entry(void)

{
  uint uVar1;
  void *pvVar2;
  int local_88;
  int local_84;
  char acStack_7c [100];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar2 = _memset(acStack_7c,0,100);
  for (local_84 = 0; local_84 < 100; local_84 = local_84 + 1) {
    for (local_88 = local_84; local_88 < 100; local_88 = local_88 + local_84 + 1) {
      acStack_7c[local_88] = acStack_7c[local_88] == '\0';
    }
  }
  for (local_88 = 0; local_88 < 100; local_88 = local_88 + 1) {
    uVar1 = _printf("door #%d is %s.\n");
    pvVar2 = (void *)(ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pvVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004010)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f84. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef int (*seq_func)(void *);
#define SEQ_BASE seq_func f; int output

/* sort of polymorphing data structure */
typedef struct { SEQ_BASE; } gen_t;

int seq_next(void *state)
{
	return ((gen_t*)state)->output = (*(seq_func*)state)(state);
}

typedef struct {
	SEQ_BASE;
	int pos, n;
} power_gen_t;

int power_next(void *s)
{
	return (int)pow(++((power_gen_t*)s)->pos, ((power_gen_t*)s)->n);
}

void *power_seq(int n)
{
	power_gen_t *s = malloc(sizeof(power_gen_t));
	s->output = -1;
	s->f = power_next;
	s->n = n;
	s->pos = -1;
	return s;
}

typedef struct {
	SEQ_BASE;
	void *in, *without;
} filter_gen_t;

int filter_next(void *s)
{
	gen_t *in = ((filter_gen_t*)s)->in, *wo = ((filter_gen_t*)s)->without;

	do{
		seq_next(in);
		while (wo->output < in->output)
			seq_next(wo);
	} while(wo->output == in->output);

	return in->output;
}

void* filter_seq(gen_t *in, gen_t *without)
{
	filter_gen_t *filt = malloc(sizeof(filter_gen_t));
	filt->in = in;
	filt->without = without;
	filt->f = filter_next;
	filt->output = -1;
	return filt;
}

int main()
{
	int i;
	void *s = filter_seq(power_seq(2), power_seq(3));

	for (i = 0; i < 20; i++) seq_next(s);
	for (i = 0; i < 10; i++)
		printf("%d\n", seq_next(s));

	return 0;
}
`,`#include "generator-exponential-2.h"



void _seq_next(undefined8 *param_1)

{
  undefined4 uVar1;
  
  uVar1 = (*(code *)*param_1)(param_1);
  *(undefined4 *)(param_1 + 1) = uVar1;
  return;
}



int _power_next(long param_1)

{
  int iVar1;
  double dVar2;
  
  iVar1 = *(int *)(param_1 + 0xc) + 1;
  *(int *)(param_1 + 0xc) = iVar1;
  dVar2 = (double)_pow((double)iVar1,(double)(long)*(int *)(param_1 + 0x10));
  return (int)dVar2;
}



undefined8 * _power_seq(undefined4 param_1)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(0x18);
  *(undefined4 *)(puVar1 + 1) = 0xffffffff;
  *puVar1 = _power_next;
  *(undefined4 *)(puVar1 + 2) = param_1;
  *(undefined4 *)((long)puVar1 + 0xc) = 0xffffffff;
  return puVar1;
}



undefined4 _filter_next(long param_1)

{
  long lVar1;
  long lVar2;
  
  lVar1 = *(long *)(param_1 + 0x10);
  lVar2 = *(long *)(param_1 + 0x18);
  do {
    _seq_next(lVar1);
    while (*(int *)(lVar2 + 8) < *(int *)(lVar1 + 8)) {
      _seq_next(lVar2);
    }
  } while (*(int *)(lVar2 + 8) == *(int *)(lVar1 + 8));
  return *(undefined4 *)(lVar1 + 8);
}



undefined8 * _filter_seq(undefined8 param_1,undefined8 param_2)

{
  undefined8 *puVar1;
  
  puVar1 = (undefined8 *)_malloc(0x20);
  puVar1[2] = param_1;
  puVar1[3] = param_2;
  *puVar1 = _filter_next;
  *(undefined4 *)(puVar1 + 1) = 0xffffffff;
  return puVar1;
}



undefined8 entry(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  int local_18;
  
  uVar1 = _power_seq(2);
  uVar2 = _power_seq(3);
  uVar1 = _filter_seq(uVar1,uVar2);
  for (local_18 = 0; local_18 < 0x14; local_18 = local_18 + 1) {
    _seq_next(uVar1);
  }
  for (local_18 = 0; local_18 < 10; local_18 = local_18 + 1) {
    _seq_next(uVar1);
    _printf("%d\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f88. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004000)();
  return pvVar1;
}



void _pow(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__pow_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004010)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>

typedef struct stream_t stream_t, *stream;
struct stream_t {
	/* get function is supposed to return a byte value (0-255),
		or -1 to signify end of input */
	int (*get)(stream);
	/* put function does output, one byte at a time */
	int (*put)(stream, int);
};

/* next two structs inherit from stream_t */
typedef struct {
	int (*get)(stream);
	int (*put)(stream, int);
	char *string;
	int pos;
} string_stream;

typedef struct {
	int (*get)(stream);
	int (*put)(stream, int);
	FILE *fp;
} file_stream;

/* methods for above streams */
int sget(stream in)
{
	int c;
	string_stream* s = (string_stream*) in;
	c = (unsigned char)(s->string[s->pos]);
	if (c == '\0') return -1;
	s->pos++;
	return c;
}

int sput(stream out, int c)
{
	string_stream* s = (string_stream*) out;
	s->string[s->pos++] = (c == -1) ? '\0' : c;
	if (c == -1) s->pos = 0;
	return 0;
}

int file_put(stream out, int c)
{
	file_stream *f = (file_stream*) out;
	return fputc(c, f->fp);
}

/* helper function */
void output(stream out, unsigned char* buf, int len)
{
	int i;
	out->put(out, 128 + len);
	for (i = 0; i < len; i++)
		out->put(out, buf[i]);
}

/* Specification: encoded stream are unsigned bytes consisting of sequences.
 * First byte of each sequence is the length, followed by a number of bytes.
 * If length <=128, the next byte is to be repeated length times;
 * If length > 128, the next (length - 128) bytes are not repeated.
 * this is to improve efficiency for long non-repeating sequences.
 * This scheme can encode arbitrary byte values efficiently.
 * c.f. Adobe PDF spec RLE stream encoding (not exactly the same)
 */
void encode(stream in, stream out)
{
	unsigned char buf[256];
	int len = 0, repeat = 0, end = 0, c;
	int (*get)(stream) = in->get;
	int (*put)(stream, int) = out->put;

	while (!end) {
		end = ((c = get(in)) == -1);
		if (!end) {
			buf[len++] = c;
			if (len <= 1) continue;
		}

		if (repeat) {
			if (buf[len - 1] != buf[len - 2])
				repeat = 0;
			if (!repeat || len == 129 || end) {
				/* write out repeating bytes */
				put(out, end ? len : len - 1);
				put(out, buf[0]);
				buf[0] = buf[len - 1];
				len = 1;
			}
		} else {
			if (buf[len - 1] == buf[len - 2]) {
				repeat = 1;
				if (len > 2) {
					output(out, buf, len - 2);
					buf[0] = buf[1] = buf[len - 1];
					len = 2;
				}
				continue;
			}
			if (len == 128 || end) {
				output(out, buf, len);
				len = 0;
				repeat = 0;
			}
		}
	}
	put(out, -1);
}

void decode(stream in, stream out)
{
	int c, i, cnt;
	while (1) {
		c = in->get(in);
		if (c == -1) return;
		if (c > 128) {
			cnt = c - 128;
			for (i = 0; i < cnt; i++)
				out->put(out, in->get(in));
		} else {
			cnt = c;
			c = in->get(in);
			for (i = 0; i < cnt; i++)
				out->put(out, c);
		}
	}
}

int main()
{
	char buf[256];
	string_stream str_in = { sget, 0,
		"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW", 0};
	string_stream str_out = { sget, sput, buf, 0 };
	file_stream file = { 0, file_put, stdout };

	/* encode from str_in to str_out */
	encode((stream)&str_in, (stream)&str_out);

	/* decode from str_out to file (stdout) */
	decode((stream)&str_out, (stream)&file);

	return 0;
}
`,`#include "run-length-encoding.h"



uint _sget(long param_1)

{
  undefined4 local_4;
  
  local_4 = (uint)*(byte *)(*(long *)(param_1 + 0x10) + (long)*(int *)(param_1 + 0x18));
  if (local_4 == 0) {
    local_4 = 0xffffffff;
  }
  else {
    *(int *)(param_1 + 0x18) = *(int *)(param_1 + 0x18) + 1;
  }
  return local_4;
}



undefined8 _sput(long param_1,int param_2)

{
  int iVar1;
  int local_1c;
  
  local_1c = param_2;
  if (param_2 == -1) {
    local_1c = 0;
  }
  iVar1 = *(int *)(param_1 + 0x18);
  *(int *)(param_1 + 0x18) = iVar1 + 1;
  *(char *)(*(long *)(param_1 + 0x10) + (long)iVar1) = (char)local_1c;
  if (param_2 == -1) {
    *(undefined4 *)(param_1 + 0x18) = 0;
  }
  return 0;
}



int _file_put(long param_1,int param_2)

{
  int iVar1;
  
  iVar1 = _fputc(param_2,*(FILE **)(param_1 + 0x10));
  return iVar1;
}



void _output(long param_1,long param_2,int param_3)

{
  undefined4 local_28;
  
  (**(code **)(param_1 + 8))(param_1,param_3 + 0x80);
  for (local_28 = 0; local_28 < param_3; local_28 = local_28 + 1) {
    (**(code **)(param_1 + 8))(param_1,*(undefined *)(param_2 + local_28));
  }
  return;
}



void _encode(undefined8 *param_1,long param_2)

{
  bool bVar1;
  bool bVar2;
  int iVar3;
  code *pcVar4;
  code *pcVar5;
  long lVar6;
  int local_16c;
  int local_13c;
  char local_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_13c = 0;
  bVar1 = false;
  bVar2 = false;
  pcVar4 = (code *)*param_1;
  pcVar5 = *(code **)(param_2 + 8);
LAB_100003a5c:
  if (bVar2) {
    (*pcVar5)(param_2,0xffffffff);
    if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
      return;
    }
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  iVar3 = (*pcVar4)(param_1);
  bVar2 = iVar3 == -1;
  if (!bVar2) goto LAB_100003aa4;
  goto LAB_100003adc;
LAB_100003aa4:
  lVar6 = (long)local_13c;
  local_13c = local_13c + 1;
  local_128[lVar6] = (char)iVar3;
  if (1 < local_13c) {
LAB_100003adc:
    if (bVar1) {
      if (local_128[local_13c + -1] != local_128[local_13c + -2]) {
        bVar1 = false;
      }
      if (((!bVar1) || (local_13c == 0x81)) || (bVar2)) {
        if (bVar2) {
          local_16c = local_13c;
        }
        else {
          local_16c = local_13c + -1;
        }
        (*pcVar5)(param_2,local_16c);
        (*pcVar5)(param_2,local_128[0]);
        local_128[0] = local_128[local_13c + -1];
        local_13c = 1;
      }
    }
    else if (local_128[local_13c + -1] == local_128[local_13c + -2]) {
      bVar1 = true;
      if (2 < local_13c) {
        _output(param_2,local_128,local_13c + -2);
        local_128[0] = local_128[local_13c + -1];
        local_13c = 2;
        local_128[1] = local_128[0];
      }
    }
    else if ((local_13c == 0x80) || (bVar2)) {
      _output(param_2,local_128,local_13c);
      local_13c = 0;
      bVar1 = false;
    }
  }
  goto LAB_100003a5c;
}



void _decode(undefined8 *param_1,long param_2)

{
  int iVar1;
  undefined4 uVar2;
  undefined8 uVar3;
  code *pcVar4;
  int local_28;
  
  while (iVar1 = (*(code *)*param_1)(param_1), iVar1 != -1) {
    if (iVar1 < 0x81) {
      uVar2 = (*(code *)*param_1)(param_1);
      for (local_28 = 0; local_28 < iVar1; local_28 = local_28 + 1) {
        (**(code **)(param_2 + 8))(param_2,uVar2);
      }
    }
    else {
      for (local_28 = 0; local_28 < iVar1 + -0x80; local_28 = local_28 + 1) {
        pcVar4 = *(code **)(param_2 + 8);
        uVar3 = (*(code *)*param_1)(param_1);
        (*pcVar4)(param_2,uVar3);
      }
    }
  }
  return;
}



undefined8 entry(void)

{
  undefined8 local_188;
  code *local_180;
  undefined8 local_178;
  code *local_170;
  code *local_168;
  undefined *local_160;
  undefined4 local_158;
  code *local_150;
  undefined8 uStack_148;
  char *local_140;
  undefined8 uStack_138;
  undefined4 local_12c;
  undefined auStack_128 [256];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_12c = 0;
  uStack_148 = 0;
  local_150 = _sget;
  uStack_138 = 0;
  local_140 = "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW";
  local_170 = _sget;
  local_168 = _sput;
  local_160 = auStack_128;
  local_158 = 0;
  local_188 = 0;
  local_180 = _file_put;
  local_178 = *(undefined8 *)PTR____stdoutp_100004010;
  _encode(&local_150);
  _decode(&local_170,&local_188);
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail();
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f3c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fputc(int param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fputc_100004018)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>

/* f : number to convert.
 * num, denom: returned parts of the rational.
 * md: max denominator value.  Note that machine floating point number
 *     has a finite resolution (10e-16 ish for 64 bit double), so specifying
 *     a "best match with minimal error" is often wrong, because one can
 *     always just retrieve the significand and return that divided by
 *     2**52, which is in a sense accurate, but generally not very useful:
 *     1.0/7.0 would be "2573485501354569/18014398509481984", for example.
 */
void rat_approx(double f, int64_t md, int64_t *num, int64_t *denom)
{
	/*  a: continued fraction coefficients. */
	int64_t a, h[3] = { 0, 1, 0 }, k[3] = { 1, 0, 0 };
	int64_t x, d, n = 1;
	int i, neg = 0;

	if (md <= 1) { *denom = 1; *num = (int64_t) f; return; }

	if (f < 0) { neg = 1; f = -f; }

	while (f != floor(f)) { n <<= 1; f *= 2; }
	d = f;

	/* continued fraction and check denominator each step */
	for (i = 0; i < 64; i++) {
		a = n ? d / n : 0;
		if (i && !a) break;

		x = d; d = n; n = x % n;

		x = a;
		if (k[1] * a + k[0] >= md) {
			x = (md - k[0]) / k[1];
			if (x * 2 >= a || k[1] >= md)
				i = 65;
			else
				break;
		}

		h[2] = x * h[1] + h[0]; h[0] = h[1]; h[1] = h[2];
		k[2] = x * k[1] + k[0]; k[0] = k[1]; k[1] = k[2];
	}
	*denom = k[1];
	*num = neg ? -h[1] : h[1];
}

int main()
{
	int i;
	int64_t d, n;
	double f;

	printf("f = %16.14f\n", f = 1.0/7);
	for (i = 1; i <= 20000000; i *= 16) {
		printf("denom <= %d: ", i);
		rat_approx(f, i, &n, &d);
		printf("%lld/%lld\n", n, d);
	}

	printf("\nf = %16.14f\n", f = atan2(1,1) * 4);
	for (i = 1; i <= 20000000; i *= 16) {
		printf("denom <= %d: ", i);
		rat_approx(f, i, &n, &d);
		printf("%lld/%lld\n", n, d);
	}

	return 0;
}
`,`#include "convert-decimal-number-to-rational-1.h"



void _rat_approx(double param_1,long param_2,long *param_3,long *param_4)

{
  long lVar1;
  long lVar2;
  long lVar3;
  long local_a8;
  long local_a0;
  int local_94;
  long local_90;
  long local_88;
  long local_80;
  double local_58;
  long local_50;
  long lStack_48;
  long local_30;
  long lStack_28;
  
  lVar3 = *(long *)PTR____stack_chk_guard_100004008;
  lStack_28 = 1;
  local_30 = 0;
  lStack_48 = 0;
  local_50 = 1;
  local_90 = 1;
  if (param_2 < 2) {
    *param_4 = 1;
    *param_3 = (long)param_1;
  }
  else {
    local_58 = param_1;
    if (param_1 < 0.0) {
      local_58 = -param_1;
    }
    for (; local_58 != (double)(long)local_58; local_58 = local_58 * 2.0) {
      local_90 = local_90 << 1;
    }
    local_88 = (long)local_58;
    for (local_94 = 0; lVar1 = local_88, local_94 < 0x40; local_94 = local_94 + 1) {
      if (local_90 == 0) {
        local_a0 = 0;
      }
      else {
        local_a0 = 0;
        if (local_90 != 0) {
          local_a0 = local_88 / local_90;
        }
      }
      if ((local_94 != 0) && (local_a0 == 0)) break;
      local_88 = local_90;
      lVar2 = 0;
      if (local_90 != 0) {
        lVar2 = lVar1 / local_90;
      }
      local_90 = lVar1 - lVar2 * local_90;
      local_80 = local_a0;
      if (param_2 <= lStack_48 * local_a0 + local_50) {
        local_80 = 0;
        if (lStack_48 != 0) {
          local_80 = (param_2 - local_50) / lStack_48;
        }
        if ((local_a0 != local_80 * 2 &&
             local_a0 + local_80 * -2 < 0 == SBORROW8(local_a0,local_80 * 2)) &&
           (lStack_48 < param_2)) break;
        local_94 = 0x41;
      }
      lVar1 = local_80 * lStack_28 + local_30;
      local_30 = lStack_28;
      lVar2 = local_80 * lStack_48 + local_50;
      local_50 = lStack_48;
      lStack_48 = lVar2;
      lStack_28 = lVar1;
    }
    *param_4 = lStack_48;
    if (param_1 < 0.0) {
      local_a8 = -lStack_28;
    }
    else {
      local_a8 = lStack_28;
    }
    *param_3 = local_a8;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 == lVar3) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



undefined8 entry(void)

{
  int iVar1;
  double dVar2;
  undefined local_28 [8];
  undefined local_20 [8];
  int local_18;
  undefined4 local_14;
  
  local_14 = 0;
  iVar1 = _printf("f = %16.14f\n");
  local_18 = 1;
  while( true ) {
    if (20000000 < local_18) break;
    _printf("denom <= %d: ");
    _rat_approx(0x3fc2492492492492,(long)local_18,local_28,local_20);
    iVar1 = _printf("%lld/%lld\n");
    local_18 = local_18 << 4;
  }
  dVar2 = (double)_atan2(0x3ff0000000000000,iVar1);
  _printf("\nf = %16.14f\n");
  for (local_18 = 1; local_18 < 0x1312d01; local_18 = local_18 << 4) {
    _printf("denom <= %d: ");
    _rat_approx(dVar2 * 4.0,(long)local_18,local_28,local_20);
    _printf("%lld/%lld\n");
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void _atan2(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__atan2_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DEFAULT_LENGTH 4
#define DEFAULT_COUNT 1

char* symbols[] = {"ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz", "0123456789", "!\"#$%&'()*+,-./:;<=>?@[]^_{|}~"};
int length = DEFAULT_LENGTH;
int count = DEFAULT_COUNT;
unsigned seed;
char exSymbols = 0;

void GetPassword () {
    //create an array of values that determine the number of characters from each category
    int lengths[4] = {1, 1, 1, 1};
    int count = 4;
    while (count < length) {
        lengths[rand()%4]++;
        count++;
    }

    //loop through the array of lengths and set the characters in password
    char password[length + 1];
    for (int i = 0; i < length; ) {
        //pick which string to read from
        int str = rand()%4;
        if (!lengths[str])continue;   //if the number of characters for that string have been reached, continue to the next interation

        char c;
        switch (str) {
            case 2:
                c = symbols[str][rand()%10];
                while (exSymbols && (c == 'I' || c == 'l' || c == '1' || c == 'O' || c == '0' || c == '5' || c == 'S' || c == '2' || c == 'Z'))
                    c = symbols[str][rand()%10];
                password[i] = c;
            break;

            case 3:
                c = symbols[str][rand()%30];
                while (exSymbols && (c == 'I' || c == 'l' || c == '1' || c == 'O' || c == '0' || c == '5' || c == 'S' || c == '2' || c == 'Z'))
                    c = symbols[str][rand()%30];
                password[i] = c;
            break;

            default:
                c = symbols[str][rand()%26];
                while (exSymbols && (c == 'I' || c == 'l' || c == '1' || c == 'O' || c == '0' || c == '5' || c == 'S' || c == '2' || c == 'Z'))
                    c = symbols[str][rand()%26];
                password[i] = c;
            break;
        }

        i++;
        lengths[str]--;
    }

    password [length] = '\0';
    printf ("%s\n", password);
}

int main (int argc, char* argv[]) {
    seed = (unsigned)time(NULL);

    //handle user input from the command line
    for (int i = 1; i < argc; i++) {
        switch (argv[i][1]) {
            case 'l':
                if (sscanf (argv[i+1], "%d", &length) != 1) {
                    puts ("Unrecognized input. Syntax: -l [integer]");
                    return -1;
                }

                if (length < 4) {
                    puts ("Password length must be at least 4 characters.");
                    return -1;
                }
                i++;
            break;

            case 'c':
                if (sscanf (argv[i+1], "%d", &count) != 1) {
                    puts ("Unrecognized input. Syntax: -c [integer]");
                    return -1;
                }

                if (count <= 0) {
                    puts ("Count must be at least 1.");
                    return -1;
                }
                i++;
            break;

            case 's':
                if (sscanf (argv[i+1], "%d", &seed) != 1) {
                    puts ("Unrecognized input. Syntax: -s [integer]");
                    return -1;
                }
                i++;
            break;

            case 'e':
                exSymbols = 1;
            break;

            default:
                help:
                printf ("Help:\nThis program generates a random password.\n"
                "Commands:"
                   "Set password length: -l [integer]\n"
                   "Set password count: -c [integer]\n"
                   "Set seed: -s [integer]\n"
                   "Exclude similiar characters: -e\n"
                   "Display help: -h");
                return 0;
            break;
        }
    }

    srand (seed);

    for (int i = 0; i < count; i++)
        GetPassword();

    return 0;
}
`,`#include "password-generator.h"



void _GetPassword(void)

{
  long lVar1;
  int iVar2;
  long alStack_d0 [2];
  undefined *local_c0;
  undefined *local_b8;
  uint local_b0;
  uint local_ac;
  undefined *local_a8;
  undefined *local_a0;
  uint local_98;
  uint local_94;
  undefined *local_90;
  undefined *local_88;
  uint local_80;
  uint local_7c;
  undefined *local_78;
  int local_6c;
  ulong local_68;
  long local_60;
  char local_51;
  int local_50;
  int local_4c;
  undefined *local_40;
  int local_34;
  int local_30 [6];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004010;
  local_30[2] = 1;
  local_30[3] = 1;
  local_30[0] = 1;
  local_30[1] = 1;
  for (local_34 = 4; local_34 < _length; local_34 = local_34 + 1) {
    iVar2 = _rand();
    local_30[iVar2 % 4] = local_30[iVar2 % 4] + 1;
  }
  local_68 = (ulong)(_length + 1) + 0xf & 0xfffffffffffffff0;
  local_40 = (undefined *)&local_c0;
  (*(code *)PTR____chkstk_darwin_100004000)();
  lVar1 = -local_68;
  local_60 = (long)&local_c0 + lVar1;
  local_4c = 0;
  while (local_4c < _length) {
    local_50 = _rand();
    local_50 = local_50 % 4;
    if (local_30[local_50] != 0) {
      local_6c = local_50;
      if (local_50 == 2) {
        local_78 = PTR_s_0123456789_100008010;
        iVar2 = _rand();
        local_51 = local_78[iVar2 % 10];
        while( true ) {
          local_7c = 0;
          if (_exSymbols != '\0') {
            local_80 = 1;
            if ((((((local_51 != 'I') && (local_80 = 1, local_51 != 'l')) &&
                  (local_80 = 1, local_51 != '1')) &&
                 ((local_80 = 1, local_51 != 'O' && (local_80 = 1, local_51 != '0')))) &&
                (local_80 = 1, local_51 != '5')) &&
               ((local_80 = 1, local_51 != 'S' && (local_80 = 1, local_51 != '2')))) {
              local_80 = (uint)(local_51 == 'Z');
            }
            local_7c = local_80;
          }
          if (local_7c == 0) break;
          local_88 = (&_symbols)[local_50];
          iVar2 = _rand();
          local_51 = local_88[iVar2 % 10];
        }
        *(char *)(local_60 + local_4c) = local_51;
      }
      else if (local_50 == 3) {
        local_90 = PTR_s__________________<_>___________100008018;
        iVar2 = _rand();
        local_51 = local_90[iVar2 % 0x1e];
        while( true ) {
          local_94 = 0;
          if (_exSymbols != '\0') {
            local_98 = 1;
            if ((((local_51 != 'I') && (local_98 = 1, local_51 != 'l')) &&
                (local_98 = 1, local_51 != '1')) &&
               (((local_98 = 1, local_51 != 'O' && (local_98 = 1, local_51 != '0')) &&
                ((local_98 = 1, local_51 != '5' &&
                 ((local_98 = 1, local_51 != 'S' && (local_98 = 1, local_51 != '2')))))))) {
              local_98 = (uint)(local_51 == 'Z');
            }
            local_94 = local_98;
          }
          if (local_94 == 0) break;
          local_a0 = (&_symbols)[local_50];
          iVar2 = _rand();
          local_51 = local_a0[iVar2 % 0x1e];
        }
        *(char *)(local_60 + local_4c) = local_51;
      }
      else {
        local_a8 = (&_symbols)[local_50];
        iVar2 = _rand();
        local_51 = local_a8[iVar2 % 0x1a];
        while( true ) {
          local_ac = 0;
          if (_exSymbols != '\0') {
            local_b0 = 1;
            if ((((local_51 != 'I') && (local_b0 = 1, local_51 != 'l')) &&
                (local_b0 = 1, local_51 != '1')) &&
               (((local_b0 = 1, local_51 != 'O' && (local_b0 = 1, local_51 != '0')) &&
                ((local_b0 = 1, local_51 != '5' &&
                 ((local_b0 = 1, local_51 != 'S' && (local_b0 = 1, local_51 != '2')))))))) {
              local_b0 = (uint)(local_51 == 'Z');
            }
            local_ac = local_b0;
          }
          if (local_ac == 0) break;
          local_b8 = (&_symbols)[local_50];
          iVar2 = _rand();
          local_51 = local_b8[iVar2 % 0x1a];
        }
        *(char *)(local_60 + local_4c) = local_51;
      }
      local_4c = local_4c + 1;
      local_30[local_50] = local_30[local_50] + -1;
    }
  }
  *(undefined *)(local_60 + _length) = 0;
  *(long *)((long)alStack_d0 + lVar1) = local_60;
  iVar2 = _printf("%s\n");
  local_c0 = local_40;
  if (*(long *)PTR____stack_chk_guard_100004010 == local_18) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail(iVar2);
}



undefined4 entry(int param_1,long param_2)

{
  int iVar1;
  time_t tVar2;
  int local_28;
  int local_24;
  
  tVar2 = _time((time_t *)0x0);
  _seed = (uint)tVar2;
  local_24 = 1;
  do {
    if (param_1 <= local_24) {
      _srand(_seed);
      for (local_28 = 0; local_28 < _count; local_28 = local_28 + 1) {
        _GetPassword();
      }
      return 0;
    }
    switch(*(undefined *)(*(long *)(param_2 + (long)local_24 * 8) + 1)) {
    case 99:
      iVar1 = _sscanf(*(char **)(param_2 + (long)(local_24 + 1) * 8),"%d");
      if (iVar1 != 1) {
        _puts("Unrecognized input. Syntax: -c [integer]");
        return 0xffffffff;
      }
      if (_count < 1) {
        _puts("Count must be at least 1.");
        return 0xffffffff;
      }
      local_24 = local_24 + 1;
      break;
    default:
      _printf(
             "Help:\nThis program generates a random password.\nCommands:Set password length: -l [integer]\nSet password count: -c [integer]\nSet seed: -s [integer]\nExclude similiar characters: -e\nDisplay help: -h"
             );
      return 0;
    case 0x65:
      _exSymbols = 1;
      break;
    case 0x6c:
      iVar1 = _sscanf(*(char **)(param_2 + (long)(local_24 + 1) * 8),"%d");
      if (iVar1 != 1) {
        _puts("Unrecognized input. Syntax: -l [integer]");
        return 0xffffffff;
      }
      if (_length < 4) {
        _puts("Password length must be at least 4 characters.");
        return 0xffffffff;
      }
      local_24 = local_24 + 1;
      break;
    case 0x73:
      iVar1 = _sscanf(*(char **)(param_2 + (long)(local_24 + 1) * 8),"%d");
      if (iVar1 != 1) {
        _puts("Unrecognized input. Syntax: -s [integer]");
        return 0xffffffff;
      }
      local_24 = local_24 + 1;
    }
    local_24 = local_24 + 1;
  } while( true );
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003d54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004028)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003d84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004030)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _sscanf(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__sscanf_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d9c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004040)();
  return tVar1;
}


`
`#include <stdio.h>
#include <ctype.h>

static int
owp(int odd)
{
        int ch, ret;
        ch = getc(stdin);
        if (!odd) {
                putc(ch, stdout);
                if (ch == EOF || ch == '.')
                        return EOF;
                if (ispunct(ch))
                        return 0;
                owp(odd);
                return 0;
        } else {
                if (ispunct(ch))
                        return ch;
                ret = owp(odd);
                putc(ch, stdout);
                return ret;
        }
}

int
main(int argc, char **argv)
{
        int ch = 1;
        while ((ch = owp(!ch)) != EOF) {
                if (ch)
                        putc(ch, stdout);
                if (ch == '.')
                        break;
        }
        return 0;
}
`,`#include "odd-word-problem.h"



undefined8 entry(void)

{
  int local_24;
  
  local_24 = 1;
  do {
    local_24 = FUN_100003e74(local_24 == 0);
    if (local_24 == -1) {
      return 0;
    }
    if (local_24 != 0) {
      _putc(local_24,*(FILE **)PTR____stdoutp_100004008);
    }
  } while (local_24 != 0x2e);
  return 0;
}



int FUN_100003e74(int param_1)

{
  int iVar1;
  int local_14;
  
  local_14 = _getc(*(FILE **)PTR____stdinp_100004000);
  if (param_1 == 0) {
    _putc(local_14,*(FILE **)PTR____stdoutp_100004008);
    if ((local_14 == -1) || (local_14 == 0x2e)) {
      local_14 = -1;
    }
    else {
      iVar1 = _ispunct(local_14);
      if (iVar1 == 0) {
        FUN_100003e74(0);
        local_14 = 0;
      }
      else {
        local_14 = 0;
      }
    }
  }
  else {
    iVar1 = _ispunct(local_14);
    if (iVar1 == 0) {
      iVar1 = FUN_100003e74(param_1);
      _putc(local_14,*(FILE **)PTR____stdoutp_100004008);
      local_14 = iVar1;
    }
  }
  return local_14;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getc(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f8c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getc_100004010)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _ispunct(int _c)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f98. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__ispunct_100004018)(_c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _putc(int param_1,FILE *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003fa4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__putc_100004020)(param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h> /* malloc */
#include <string.h> /* strlen */
#define _XOPEN_SOURCE /* requred for time functions */
#define __USE_XOPEN
#include <time.h>
#define DB "database.csv" /* database name */
#define TRY(a)  if (!(a)) {perror(#a);exit(1);}
#define TRY2(a) if((a)<0) {perror(#a);exit(1);}
#define FREE(a) if(a) {free(a);a=NULL;}
#define sort_by(foo) \
static int by_##foo (const void*p1, const void*p2) { \
    return strcmp ((*(const pdb_t*)p1)->foo, (*(const pdb_t*)p2)->foo); }
typedef struct db {
    char title[26];
    char first_name[26];
    char last_name[26];
    time_t date;
    char publ[100];
    struct db *next;
}
db_t,*pdb_t;
typedef int (sort)(const void*, const void*);
enum {CREATE,PRINT,TITLE,DATE,AUTH,READLINE,READ,SORT,DESTROY};
static pdb_t dao (int cmd, FILE *f, pdb_t db, sort sortby);
static char *time2str (time_t *time);
static time_t str2time (char *date);
/* qsort callbacks */
sort_by(last_name);
sort_by(title);
static int by_date(pdb_t *p1, pdb_t *p2);
/* main */
int main (int argc, char **argv) {
    char buf[100];
    const char *commands[]={"-c", "-p", "-t", "-d", "-a", NULL};
    db_t db;
    db.next=NULL;
    pdb_t dblist;
    int i;
    FILE *f;
    TRY (f=fopen(DB,"a+"));
    if (argc<2) {
usage:  printf ("Usage: %s [commands]\n"
        "-c  Create new entry.\n"
        "-p  Print the latest entry.\n"
        "-t  Print all entries sorted by title.\n"
        "-d  Print all entries sorted by date.\n"
        "-a  Print all entries sorted by author.\n",argv[0]);
        fclose (f);
        return 0;
    }
    for (i=0;commands[i]&&strcmp(argv[1],commands[i]);i++);
    switch (i) {
        case CREATE:
        printf("-c  Create a new entry.\n");
        printf("Title           :");if((scanf(" %25[^\n]",db.title     ))<0)break;
        printf("Author Firstname:");if((scanf(" %25[^\n]",db.first_name))<0)break;
        printf("Author Lastname :");if((scanf(" %25[^\n]",db.last_name ))<0)break;
        printf("Date 10-12-2000 :");if((scanf(" %10[^\n]",buf          ))<0)break;
        printf("Publication     :");if((scanf(" %99[^\n]",db.publ      ))<0)break;
        db.date=str2time (buf);
        dao (CREATE,f,&db,NULL);
        break;
        case PRINT:
        printf ("-p  Print the latest entry.\n");
        while (!feof(f)) dao (READLINE,f,&db,NULL);
        dao (PRINT,f,&db,NULL);
        break;
        case TITLE:
        printf ("-t  Print all entries sorted by title.\n");
        dblist = dao (READ,f,&db,NULL);
        dblist = dao (SORT,f,dblist,by_title);
        dao (PRINT,f,dblist,NULL);
        dao (DESTROY,f,dblist,NULL);
        break;
        case DATE:
        printf ("-d  Print all entries sorted by date.\n");
        dblist = dao (READ,f,&db,NULL);
        dblist = dao (SORT,f,dblist,(int (*)(const void *,const  void *)) by_date);
        dao (PRINT,f,dblist,NULL);
        dao (DESTROY,f,dblist,NULL);
        break;
        case AUTH:
        printf ("-a  Print all entries sorted by author.\n");
        dblist = dao (READ,f,&db,NULL);
        dblist = dao (SORT,f,dblist,by_last_name);
        dao (PRINT,f,dblist,NULL);
        dao (DESTROY,f,dblist,NULL);
        break;
        default: {
            printf ("Unknown command: %s.\n",strlen(argv[1])<10?argv[1]:"");
            goto usage;
    }   }
    fclose (f);
    return 0;
}
/* Data Access Object (DAO) */
static pdb_t dao (int cmd, FILE *f, pdb_t in_db, sort sortby) {
    pdb_t *pdb=NULL,rec=NULL,hd=NULL;
    int i=0,ret;
    char buf[100];
    switch (cmd) {
        case CREATE:
        fprintf (f,"\"%s\",",in_db->title);
        fprintf (f,"\"%s\",",in_db->first_name);
        fprintf (f,"\"%s\",",in_db->last_name);
        fprintf (f,"\"%s\",",time2str(&in_db->date));
        fprintf (f,"\"%s\" \n",in_db->publ);
        break;
        case PRINT:
        for (;in_db;i++) {
            printf ("Title       : %s\n",     in_db->title);
            printf ("Author      : %s %s\n",  in_db->first_name, in_db->last_name);
            printf ("Date        : %s\n",     time2str(&in_db->date));
            printf ("Publication : %s\n\n",   in_db->publ);
            if (!((i+1)%3)) {
                printf ("Press Enter to continue.\n");
                ret = scanf ("%*[^\n]");
                if (ret<0) return rec; /* handle EOF */
                else getchar();
            }
            in_db=in_db->next;
        }
        break;
        case READLINE:
        if((fscanf(f," \"%[^\"]\",",in_db->title     ))<0)break;
        if((fscanf(f," \"%[^\"]\",",in_db->first_name))<0)break;
        if((fscanf(f," \"%[^\"]\",",in_db->last_name ))<0)break;
        if((fscanf(f," \"%[^\"]\",",buf              ))<0)break;
        if((fscanf(f," \"%[^\"]\" ",in_db->publ      ))<0)break;
        in_db->date=str2time (buf);
        break;
        case READ:
        while (!feof(f)) {
            dao (READLINE,f,in_db,NULL);
            TRY (rec=malloc(sizeof(db_t)));
            *rec=*in_db; /* copy contents */
            rec->next=hd;/* to linked list */
            hd=rec;i++;
        }
        if (i<2) {
            puts ("Empty database. Please create some entries.");
            fclose (f);
            exit (0);
        }
        break;
        case SORT:
        rec=in_db;
        for (;in_db;i++) in_db=in_db->next;
        TRY (pdb=malloc(i*sizeof(pdb_t)));
        in_db=rec;
        for (i=0;in_db;i++) {
            pdb[i]=in_db;
            in_db=in_db->next;
        }
        qsort (pdb,i,sizeof in_db,sortby);
        pdb[i-1]->next=NULL;
        for (i=i-1;i;i--) {
            pdb[i-1]->next=pdb[i];
        }
        rec=pdb[0];
        FREE (pdb);
        pdb=NULL;
        break;
        case DESTROY: {
            while ((rec=in_db)) {
                in_db=in_db->next;
                FREE (rec);
    }   }   }
    return rec;
}
/* convert numeric time to date string */
static char *time2str (time_t *time) {
    static char buf[255];
    struct tm *ptm;
    ptm=localtime (time);
    strftime(buf, 255, "%m-%d-%Y", ptm);
    return buf;
}
/* convert date string to numeric time */
static time_t str2time (char *date) {
    struct tm tm;
    memset (&tm, 0, sizeof(struct tm));
    strptime(date, "%m-%d-%Y", &tm);
    return mktime(&tm);
}
/* sort by date callback for qsort */
static int by_date (pdb_t *p1, pdb_t *p2) {
    if ((*p1)->date < (*p2)->date) {
        return -1;
    }
    else return ((*p1)->date > (*p2)->date);
}
`,`#include "simple-database.h"



undefined4 entry(int param_1,long param_2)

{
  bool bVar1;
  int iVar2;
  FILE *pFVar3;
  undefined8 uVar4;
  int local_1a4;
  undefined auStack_188 [80];
  undefined8 local_138;
  undefined8 local_c8;
  long alStack_c0 [6];
  undefined auStack_8c [100];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _memcpy(alStack_c0,&PTR_s__c_1000040c0,0x30);
  local_c8 = 0;
  pFVar3 = _fopen("database.csv","a+");
  if (pFVar3 == (FILE *)0x0) {
    _perror("f=fopen(DB,\"a+\")");
                    // WARNING: Subroutine does not return
    _exit(1);
  }
  if (param_1 < 2) {
LAB_100002ecc:
    _printf(
           "Usage: %s [commands]\n-c  Create new entry.\n-p  Print the latest entry.\n-t  Print all entries sorted by title.\n-d  Print all entries sorted by date.\n-a  Print all entries sorted by author.\n"
           );
    iVar2 = _fclose(pFVar3);
  }
  else {
    local_1a4 = 0;
    while( true ) {
      bVar1 = false;
      if (alStack_c0[local_1a4] != 0) {
        iVar2 = _strcmp(*(char **)(param_2 + 8),(char *)alStack_c0[local_1a4]);
        bVar1 = iVar2 != 0;
      }
      if (!bVar1) break;
      local_1a4 = local_1a4 + 1;
    }
    switch(local_1a4) {
    case 0:
      _printf("-c  Create a new entry.\n");
      _printf("Title           :");
      iVar2 = _scanf(" %25[^\n]");
      if (-1 < iVar2) {
        _printf("Author Firstname:");
        iVar2 = _scanf(" %25[^\n]");
        if (-1 < iVar2) {
          _printf("Author Lastname :");
          iVar2 = _scanf(" %25[^\n]");
          if (-1 < iVar2) {
            _printf("Date 10-12-2000 :");
            iVar2 = _scanf(" %10[^\n]");
            if (-1 < iVar2) {
              _printf("Publication     :");
              iVar2 = _scanf(" %99[^\n]");
              if (-1 < iVar2) {
                local_138 = FUN_10000335c(auStack_8c);
                FUN_1000033a8(0,pFVar3,auStack_188,0);
              }
            }
          }
        }
      }
      break;
    case 1:
      _printf("-p  Print the latest entry.\n");
      while (iVar2 = _feof(pFVar3), iVar2 == 0) {
        FUN_1000033a8(5,pFVar3,auStack_188,0);
      }
      FUN_1000033a8(1,pFVar3,auStack_188,0);
      break;
    case 2:
      _printf("-t  Print all entries sorted by title.\n");
      uVar4 = FUN_1000033a8(6,pFVar3,auStack_188);
      uVar4 = FUN_1000033a8(7,pFVar3,uVar4,FUN_100003a18);
      FUN_1000033a8(1,pFVar3,uVar4,0);
      FUN_1000033a8(8,pFVar3,uVar4,0);
      break;
    case 3:
      _printf("-d  Print all entries sorted by date.\n");
      uVar4 = FUN_1000033a8(6,pFVar3,auStack_188);
      uVar4 = FUN_1000033a8(7,pFVar3,uVar4,FUN_100003a4c);
      FUN_1000033a8(1,pFVar3,uVar4,0);
      FUN_1000033a8(8,pFVar3,uVar4,0);
      break;
    case 4:
      _printf("-a  Print all entries sorted by author.\n");
      uVar4 = FUN_1000033a8(6,pFVar3,auStack_188);
      uVar4 = FUN_1000033a8(7,pFVar3,uVar4,FUN_100003ac4);
      FUN_1000033a8(1,pFVar3,uVar4,0);
      FUN_1000033a8(8,pFVar3,uVar4,0);
      break;
    default:
      _strlen(*(char **)(param_2 + 8));
      _printf("Unknown command: %s.\n");
      goto LAB_100002ecc;
    }
    iVar2 = _fclose(pFVar3);
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar2);
  }
  return 0;
}



void FUN_10000335c(char *param_1)

{
  tm tStack_50;
  char *local_18;
  
  local_18 = param_1;
  _memset(&tStack_50,0,0x38);
  _strptime(local_18,"%m-%d-%Y",&tStack_50);
  _mktime(&tStack_50);
  return;
}



void * FUN_1000033a8(undefined4 param_1,FILE *param_2,void *param_3,int *param_4)

{
  int iVar1;
  undefined8 uVar2;
  undefined8 *puVar3;
  void *pvVar4;
  int local_d4;
  void *local_c8;
  void *local_b0;
  undefined auStack_8c [100];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_c8 = (void *)0x0;
  local_d4 = 0;
  local_b0 = param_3;
  switch(param_1) {
  case 0:
    _fprintf(param_2,"\"%s\",");
    _fprintf(param_2,"\"%s\",");
    _fprintf(param_2,"\"%s\",");
    FUN_100003b00((long)param_3 + 0x50);
    _fprintf(param_2,"\"%s\",");
    _fprintf(param_2,"\"%s\" \n");
    break;
  case 1:
    for (; local_b0 != (void *)0x0; local_b0 = *(void **)((long)local_b0 + 0xc0)) {
      _printf("Title       : %s\n");
      _printf("Author      : %s %s\n");
      FUN_100003b00((long)local_b0 + 0x50);
      _printf("Date        : %s\n");
      _printf("Publication : %s\n\n");
      if ((local_d4 + 1) % 3 == 0) {
        _printf("Press Enter to continue.\n");
        iVar1 = _scanf("%*[^\n]");
        if (iVar1 < 0) goto LAB_1000039b4;
        _getchar();
      }
      local_d4 = local_d4 + 1;
    }
    break;
  case 5:
    iVar1 = _fscanf(param_2," \"%[^\"]\",");
    if ((((-1 < iVar1) && (iVar1 = _fscanf(param_2," \"%[^\"]\","), -1 < iVar1)) &&
        (iVar1 = _fscanf(param_2," \"%[^\"]\","), -1 < iVar1)) &&
       ((iVar1 = _fscanf(param_2," \"%[^\"]\","), -1 < iVar1 &&
        (iVar1 = _fscanf(param_2," \"%[^\"]\" "), -1 < iVar1)))) {
      uVar2 = FUN_10000335c(auStack_8c);
      *(undefined8 *)((long)param_3 + 0x50) = uVar2;
    }
    break;
  case 6:
    while (iVar1 = _feof(param_2), iVar1 == 0) {
      FUN_1000033a8(5,param_2,param_3,0);
      pvVar4 = _malloc(200);
      if (pvVar4 == (void *)0x0) {
        _perror("rec=malloc(sizeof(db_t))");
                    // WARNING: Subroutine does not return
        _exit(1);
      }
      _memcpy(pvVar4,param_3,200);
      *(void **)((long)pvVar4 + 0xc0) = local_c8;
      local_d4 = local_d4 + 1;
      local_c8 = pvVar4;
    }
    if (local_d4 < 2) {
      _puts("Empty database. Please create some entries.");
      _fclose(param_2);
                    // WARNING: Subroutine does not return
      _exit(0);
    }
    break;
  case 7:
    for (; local_b0 != (void *)0x0; local_b0 = *(void **)((long)local_b0 + 0xc0)) {
      local_d4 = local_d4 + 1;
    }
    puVar3 = (undefined8 *)_malloc((long)local_d4 << 3);
    if (puVar3 == (undefined8 *)0x0) {
      _perror("pdb=malloc(i*sizeof(pdb_t))");
                    // WARNING: Subroutine does not return
      _exit(1);
    }
    local_d4 = 0;
    for (local_b0 = param_3; local_b0 != (void *)0x0; local_b0 = *(void **)((long)local_b0 + 0xc0))
    {
      puVar3[local_d4] = local_b0;
      local_d4 = local_d4 + 1;
    }
    _qsort(puVar3,(long)local_d4,8,param_4);
    *(undefined8 *)(puVar3[local_d4 + -1] + 0xc0) = 0;
    iVar1 = local_d4;
    while (local_d4 = iVar1 + -1, local_d4 != 0) {
      *(undefined8 *)(puVar3[iVar1 + -2] + 0xc0) = puVar3[local_d4];
      iVar1 = local_d4;
    }
    local_c8 = (void *)*puVar3;
    if (puVar3 != (undefined8 *)0x0) {
      _free(puVar3);
    }
    break;
  case 8:
    pvVar4 = param_3;
    while (local_b0 = pvVar4, local_c8 = local_b0, local_b0 != (void *)0x0) {
      pvVar4 = *(void **)((long)local_b0 + 0xc0);
      if (local_b0 != (void *)0x0) {
        _free(local_b0);
      }
    }
  }
LAB_1000039b4:
  if (*(long *)PTR____stack_chk_guard_100004008 == local_28) {
    return local_c8;
  }
                    // WARNING: Subroutine does not return
  ___stack_chk_fail();
}



int FUN_100003a18(undefined8 *param_1,undefined8 *param_2)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)*param_1,(char *)*param_2);
  return iVar1;
}



uint FUN_100003a4c(long *param_1,long *param_2)

{
  undefined4 local_4;
  
  if (*(long *)(*param_1 + 0x50) < *(long *)(*param_2 + 0x50)) {
    local_4 = 0xffffffff;
  }
  else {
    local_4 = (uint)(*(long *)(*param_2 + 0x50) < *(long *)(*param_1 + 0x50));
  }
  return local_4;
}



int FUN_100003ac4(long *param_1,long *param_2)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)(*param_1 + 0x34),(char *)(*param_2 + 0x34));
  return iVar1;
}



undefined8 FUN_100003b00(time_t *param_1)

{
  tm *ptVar1;
  
  ptVar1 = _localtime(param_1);
  _strftime((char *)0x100008000,0xff,"%m-%d-%Y",ptVar1);
  return 0x100008000;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003b54. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003b60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__exit_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _feof(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__feof_100004020)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b84. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004028)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003b90. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004030)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _free(void *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003b9c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__free_100004038)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fscanf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003ba8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fscanf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _getchar(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003bb4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__getchar_100004048)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * _localtime(time_t *param_1)

{
  tm *ptVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003bc0. Too many branches
                    // WARNING: Treating indirect jump as call
  ptVar1 = (tm *)(*(code *)PTR__localtime_100004050)();
  return ptVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _malloc(size_t param_1)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003bcc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__malloc_100004058)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003bd8. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004060)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memset(void *param_1,int param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003be4. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memset_100004068)(param_1,param_2);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _mktime(tm *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003bf0. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__mktime_100004070)();
  return tVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _perror(char *param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003bfc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__perror_100004078)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003c08. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004080)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _puts(char *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003c14. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__puts_100004088)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003c20. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004090)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _scanf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003c2c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__scanf_100004098)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _strcmp(char *param_1,char *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003c38. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__strcmp_1000040a0)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strftime(char *param_1,size_t param_2,char *param_3,tm *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003c44. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strftime_1000040a8)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _strlen(char *param_1)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003c50. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__strlen_1000040b0)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _strptime(char *param_1,char *param_2,tm *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003c5c. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__strptime_1000040b8)();
  return pcVar1;
}


`
`#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>
#include <string.h>

int ordered(char *s, char **end)
{
	int r = 1;
	while (*++s != '\n' && *s != '\r' && *s != '\0')
		if (s[0] < s[-1]) r = 0;

	*end = s;
	return r;
}

int main()
{
	char *buf, *word, *end, *tail;
	struct stat st;
	int longest = 0, len, fd;

	if ((fd = open("unixdict.txt", O_RDONLY)) == -1) err(1, "read error");

	fstat(fd, &st);
	if (!(buf = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0)))
		err(1, "mmap");

	for (word = end = buf; end < buf + st.st_size; word = end) {
		while (*word == '\r' || *word == '\n') word++;
		if (!ordered(word, &end)) continue;
		if ((len = end - word + 1) < longest) continue;
		if (len > longest) {
			tail = buf;  /* longer words found; reset out buffer */
			longest = len;
		}
		/* use the same mmap'd region to store output.  because of MAP_PRIVATE,
		 * change will not go back to file.  mmap is copy on write, and we are using
		 * only the head space to store output, so kernel doesn't need to copy more
		 * than the words we saved--in this case, one page tops.
		 */
		memcpy(tail, word, len);
		tail += len;
		*tail = '\0';
	}
	printf(buf);

	munmap(buf, st.st_size);
	close(fd);
	return 0;
}
`,`#include "ordered-words-3.h"



undefined4 _ordered(byte *param_1,long *param_2)

{
  byte *pbVar1;
  byte bVar2;
  bool bVar3;
  undefined4 local_14;
  byte *local_8;
  
  local_14 = 1;
  local_8 = param_1;
  while( true ) {
    pbVar1 = local_8 + 1;
    bVar3 = false;
    if ((local_8[1] != 10) && (bVar3 = false, *pbVar1 != 0xd)) {
      bVar3 = *pbVar1 != 0;
    }
    if (!bVar3) break;
    bVar2 = *local_8;
    local_8 = pbVar1;
    if ((int)(char)*pbVar1 < (int)(uint)bVar2) {
      local_14 = 0;
    }
  }
  *param_2 = (long)pbVar1;
  return local_14;
}



undefined8 entry(void)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  int local_cc;
  stat sStack_c8;
  char *local_38;
  char *local_30;
  char *local_28;
  char *local_20;
  undefined4 local_14;
  
  local_14 = 0;
  local_cc = 0;
  iVar2 = _open("unixdict.txt",0);
  if (iVar2 == -1) {
    _err(1,"read error");
  }
  _fstat(iVar2,&sStack_c8);
  local_20 = (char *)_mmap(0,sStack_c8.st_size,3,2,iVar2,0);
  if (local_20 == (char *)0x0) {
    _err(1,"mmap");
  }
  local_28 = local_20;
  while (local_30 = local_28, local_28 < local_20 + sStack_c8.st_size) {
    while( true ) {
      bVar1 = true;
      if (*local_28 != '\r') {
        bVar1 = *local_28 == '\n';
      }
      if (!bVar1) break;
      local_28 = local_28 + 1;
    }
    iVar3 = _ordered(local_28,&local_30);
    if ((iVar3 != 0) && (iVar3 = ((int)local_30 - (int)local_28) + 1, local_cc <= iVar3)) {
      if (local_cc < iVar3) {
        local_38 = local_20;
        local_cc = iVar3;
      }
      ___memcpy_chk(local_38,local_28,(long)iVar3,0xffffffffffffffff);
      local_38 = local_38 + iVar3;
      *local_38 = '\0';
    }
    local_28 = local_30;
  }
  _printf(local_20);
  _munmap(local_20,sStack_c8.st_size);
  _close(iVar2);
  return 0;
}



void ___memcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____memcpy_chk_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _close(int param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__close_100004008)(param_1);
  return iVar1;
}



void _err(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__err_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fstat(int param_1,stat *param_2)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fstat_100004018)(param_1);
  return iVar1;
}



void _mmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f58. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__mmap_100004020)();
  return;
}



void _munmap(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f64. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__munmap_100004028)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _open(char *param_1,int param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f70. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__open_100004030)((int)param_1,param_2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f7c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}


`
`//SquFoF: minimalistic version without queue.
//Classical heuristic. Tested: tcc 0.9.27
#include <math.h>
#include <stdio.h>

//input maximum
#define MxN ((unsigned long long) 1 << 62)

//reduce indefinite form
#define rho(a, b, c) {        \
  t = c; c = a; a = t; t = b; \
   q = (rN + b) / a;          \
   b = q * a - b;             \
   c += q * (t - b); }

//initialize
#define rhoin(a, b, c) {      \
   rho(a, b, c)  h = b;       \
   c = (mN - h * h) / a; }

#define gcd(a, b) while (b) { \
   t = a % b; a = b; b = t; }

//multipliers
const unsigned long m[] = {1, 3, 5, 7, 11, 0};

//square form factorization
unsigned long squfof( unsigned long long N ) {
unsigned long a, b, c, u, v, w, rN, q, t, r;
unsigned long long mN, h;
int i, ix, k = 0;

   if ((N & 1)==0) return 2;

   h = floor(sqrt(N)+ 0.5);
   if (h * h == N) return h;

   while (m[k]) {
      if (k && N % m[k]==0) return m[k];
      //check overflow m * N
      if (N > MxN / m[k]) break;
      mN = N * m[k++];

      r = floor(sqrt(mN));
      h = r; //float64 fix
      if (h * h > mN) r -= 1;
      rN = r;

      //principal form
      b = r; c = 1;
      rhoin(a, b, c)

      //iteration bound
      ix = floor(sqrt(2*r)) * 4;

      //search principal cycle
      for (i = 2; i < ix; i += 2) {
         rho(a, b, c)
         //even step

         r = floor(sqrt(c)+ 0.5);
         if (r * r == c) {
            //square form found

            //inverse square root
            v = -b; w = r;
            rhoin(u, v, w)

            //search ambiguous cycle
            do { r = v;
              rho(u, v, w)
            } while (v != r);
            //symmetry point

            h = N; gcd(h, u)
            if (h != 1) return h;
         }
         rho(a, b, c)
         //odd step
      }
   }
   return 1;
}

void main(void) {
const unsigned long long data[] = {
   2501,
   12851,
   13289,
   75301,
   120787,
   967009,
   997417,
   7091569,

   5214317,
   20834839,
   23515517,
   33409583,
   44524219,

   13290059,
   223553581,
   2027651281,
   11111111111,
   100895598169,
   1002742628021,
   60012462237239,
   287129523414791,
   9007199254740931,
   11111111111111111,
   314159265358979323,
   384307168202281507,
   419244183493398773,
   658812288346769681,
   922337203685477563,
   1000000000000000127,
   1152921505680588799,
   1537228672809128917,
   4611686018427387877,
   0};

   unsigned long long N, f;
   int i = 0;

   while (1) {
      N = data[i++];
      //scanf("%llu", &N);
      if (N < 2) break;

      printf("N = %llu\n", N);

      f = squfof(N);
      if (N % f) f = 1;

      if (f == 1) printf("fail\n\n");
      else printf("f = %llu  N/f = %llu\n\n", f, N/f);
   }
}
`,`#include "square-form-factorization-2.h"



ulong _squfof(ulong param_1)

{
  long lVar1;
  ulong uVar2;
  bool bVar3;
  ulong uVar4;
  ulong uVar5;
  long lVar6;
  double dVar7;
  int local_7c;
  int local_74;
  ulong local_70;
  long local_60;
  ulong local_40;
  long local_38;
  ulong local_30;
  ulong local_28;
  long local_20;
  ulong local_18;
  ulong local_8;
  
  local_7c = 0;
  if ((param_1 & 1) == 0) {
    local_8 = 2;
  }
  else {
    dVar7 = (double)NEON_ucvtf(param_1);
    local_8 = (ulong)(SQRT(dVar7) + 0.5);
    if (local_8 * local_8 - param_1 != 0) {
      while (*(long *)(&_m + (long)local_7c * 8) != 0) {
        if (local_7c != 0) {
          uVar5 = *(ulong *)(&_m + (long)local_7c * 8);
          uVar4 = 0;
          if (uVar5 != 0) {
            uVar4 = param_1 / uVar5;
          }
          if (param_1 == uVar4 * uVar5) {
            return *(ulong *)(&_m + (long)local_7c * 8);
          }
        }
        uVar4 = 0;
        if (*(ulong *)(&_m + (long)local_7c * 8) != 0) {
          uVar4 = 0x4000000000000000 / *(ulong *)(&_m + (long)local_7c * 8);
        }
        if (uVar4 < param_1) break;
        lVar6 = (long)local_7c;
        local_7c = local_7c + 1;
        uVar4 = param_1 * *(long *)(&_m + lVar6 * 8);
        dVar7 = (double)NEON_ucvtf(uVar4);
        local_60 = (long)SQRT(dVar7);
        if (uVar4 <= (ulong)(local_60 * local_60) && local_60 * local_60 - uVar4 != 0) {
          local_60 = local_60 + -1;
        }
        local_18 = 1;
        local_20 = (ulong)(local_60 * 2) / 1 - local_60;
        local_28 = (uVar4 - local_20 * local_20) / 1;
        for (local_74 = 2; local_74 < (int)((double)(long)SQRT((double)(ulong)(local_60 * 2)) * 4.0)
            ; local_74 = local_74 + 2) {
          uVar5 = 0;
          if (local_28 != 0) {
            uVar5 = (ulong)(local_60 + local_20) / local_28;
          }
          lVar6 = uVar5 * local_28 - local_20;
          local_18 = local_18 + uVar5 * (local_20 - lVar6);
          dVar7 = (double)NEON_ucvtf(local_18);
          local_30 = (ulong)(SQRT(dVar7) + 0.5);
          if (local_30 * local_30 - local_18 == 0) {
            uVar5 = 0;
            if (local_30 != 0) {
              uVar5 = (ulong)(local_60 - lVar6) / local_30;
            }
            local_38 = uVar5 * local_30 + lVar6;
            local_40 = 0;
            if (local_30 != 0) {
              local_40 = (uVar4 - local_38 * local_38) / local_30;
            }
            do {
              uVar2 = local_30;
              local_30 = local_40;
              uVar5 = 0;
              if (local_40 != 0) {
                uVar5 = (ulong)(local_60 + local_38) / local_40;
              }
              lVar1 = uVar5 * local_40 - local_38;
              local_40 = uVar2 + uVar5 * (local_38 - lVar1);
              bVar3 = lVar1 != local_38;
              local_70 = param_1;
              local_38 = lVar1;
            } while (bVar3);
            while (local_30 != 0) {
              uVar5 = 0;
              if (local_30 != 0) {
                uVar5 = local_70 / local_30;
              }
              uVar5 = local_70 - uVar5 * local_30;
              local_70 = local_30;
              local_30 = uVar5;
            }
            if (local_70 != 1) {
              return local_70;
            }
          }
          uVar5 = 0;
          if (local_18 != 0) {
            uVar5 = (ulong)(local_60 + lVar6) / local_18;
          }
          local_20 = uVar5 * local_18 - lVar6;
          local_28 = local_28 + uVar5 * (lVar6 - local_20);
        }
      }
      local_8 = 1;
    }
  }
  return local_8;
}



void entry(void)

{
  ulong uVar1;
  uint uVar2;
  void *pvVar3;
  ulong uVar4;
  long lVar5;
  int local_144;
  ulong local_140;
  ulong auStack_130 [33];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  pvVar3 = _memcpy(auStack_130,&DAT_100003e70,0x108);
  local_144 = 0;
  while( true ) {
    lVar5 = (long)local_144;
    local_144 = local_144 + 1;
    uVar4 = auStack_130[lVar5];
    if (uVar4 < 2) break;
    _printf("N = %llu\n");
    local_140 = _squfof(uVar4);
    uVar1 = 0;
    if (local_140 != 0) {
      uVar1 = uVar4 / local_140;
    }
    if (uVar4 != uVar1 * local_140) {
      local_140 = 1;
    }
    if (local_140 == 1) {
      uVar2 = _printf("fail\n\n");
    }
    else {
      uVar2 = _printf("f = %llu  N/f = %llu\n\n");
    }
    pvVar3 = (void *)(ulong)uVar2;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(pvVar3);
  }
  return;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * _memcpy(void *param_1,void *param_2,size_t param_3)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e30. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)PTR__memcpy_100004010)();
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`typedef unsigned long long int ulong; // define a type that represent the limit (64-bit)

ulong mod_mul(ulong a, ulong b, const ulong mod) {
	ulong res = 0, c; // return (a * b) % mod, avoiding overflow errors while doing modular multiplication.
	for (b %= mod; a; a & 1 ? b >= mod - res ? res -= mod : 0, res += b : 0, a >>= 1, (c = b) >= mod - b ? c -= mod : 0, b += c);
	return res % mod;
}

ulong mod_pow(ulong n, ulong exp, const ulong mod) {
	ulong res = 1; // return (n ^ exp) % mod
	for (n %= mod; exp; exp & 1 ? res = mod_mul(res, n, mod) : 0, n = mod_mul(n, n, mod), exp >>= 1);
	return res;
}

ulong square_root(const ulong N) {
	ulong res = 0, rem = N, c, d;
	for (c = 1 << 62; c; c >>= 2) {
		d = res + c;
		res >>= 1;
		if (rem >= d)
			rem -= d, res += c;
	} // returns the square root of N.
	return res;
}

int is_prime(const ulong N) {
	ulong i = 1; // return a truthy value about the primality of N.
	if (N > 1) for (; i < 64 && mod_pow(i, N - 1, N) <= 1; ++i);
	return i == 64;
}

ulong pollard_rho(const ulong N) {
	// Require : N is a composite number, not a square.
	// Ensure : res is a non-trivial factor of N.
	// Option : change the timeout, change the rand function.
	static const int timeout = 18;
	static unsigned long long rand_val = 2994439072U;
	rand_val = (rand_val * 1025416097U + 286824428U) % 4294967291LLU;
	ulong res = 1, a, b, c, i = 0, j = 1, x = 1, y = 1 + rand_val % (N - 1);
	for (; res == 1; ++i) {
		if (i == j) {
			if (j >> timeout)
				break;
			j <<= 1;
			x = y;
		}
		a = y, b = y; // performs y = (y * y) % N
		for (y = 0; a; a & 1 ? b >= N - y ? y -= N : 0, y += b : 0, a >>= 1, (c = b) >= N - b ? c -= N : 0, b += c);
		y = (1 + y) % N;
		for (a = y > x ? y - x : x - y, b = N; (a %= b) && (b %= a);); // compute the gcd(abs(y - x), N);
		res = a | b;
	}
	return res;
}

void factor(const ulong N, ulong *array) {
	// very basic manager that fill the given array (the size of the result is the first array element)	
	// it does not perform initial trial divisions, which is generally highly recommended.
	if (N < 4 || is_prime(N)) {
		if (N > 1 || !*array) array[++*array] = N;
		return;
	}
	ulong x = square_root(N);
	if (x * x != N) x = pollard_rho(N);
	factor(x, array);
	factor(N / x, array);
}

#include <stdio.h>

int main(void) {
	// simple test.
	unsigned long long n = 18446744073709551615U;
	ulong fac[65] = {0};
	factor(n, fac);
	for (ulong i = 1; i <= *fac; ++i)
		printf("* %llu\n", fac[i]);
}
`,`#include "prime-decomposition-4.h"



long _mod_mul(ulong param_1,ulong param_2,ulong param_3)

{
  ulong uVar1;
  ulong local_28;
  ulong local_20;
  ulong local_10;
  ulong local_8;
  
  local_20 = 0;
  uVar1 = 0;
  if (param_3 != 0) {
    uVar1 = param_2 / param_3;
  }
  local_10 = param_2 - uVar1 * param_3;
  local_8 = param_1;
  while (local_8 != 0) {
    if ((local_8 & 1) != 0) {
      if (param_3 - local_20 <= local_10) {
        local_20 = local_20 - param_3;
      }
      local_20 = local_20 + local_10;
    }
    local_8 = local_8 >> 1;
    local_28 = local_10;
    if (param_3 - local_10 <= local_10) {
      local_28 = local_10 - param_3;
    }
    local_10 = local_10 + local_28;
  }
  uVar1 = 0;
  if (param_3 != 0) {
    uVar1 = local_20 / param_3;
  }
  return local_20 - uVar1 * param_3;
}



undefined8 _mod_pow(ulong param_1,ulong param_2,ulong param_3)

{
  ulong uVar1;
  undefined8 local_30;
  ulong local_20;
  long local_18;
  
  local_30 = 1;
  uVar1 = 0;
  if (param_3 != 0) {
    uVar1 = param_1 / param_3;
  }
  local_18 = param_1 - uVar1 * param_3;
  for (local_20 = param_2; local_20 != 0; local_20 = local_20 >> 1) {
    if ((local_20 & 1) != 0) {
      local_30 = _mod_mul(local_30,local_18,param_3);
    }
    local_18 = _mod_mul(local_18,local_18,param_3);
  }
  return local_30;
}



ulong _square_root(ulong param_1,ulong param_2)

{
  ulong uVar1;
  undefined8 local_20;
  undefined8 local_18;
  undefined8 local_10;
  
  local_10 = 0;
  local_18 = param_2;
  for (local_20 = param_1; local_20 != 0; local_20 = local_20 >> 2) {
    uVar1 = local_10 + local_20;
    local_10 = local_10 >> 1;
    if (uVar1 <= local_18) {
      local_18 = local_18 - uVar1;
      local_10 = local_10 + local_20;
    }
  }
  return local_10;
}



bool _is_prime(ulong param_1)

{
  bool bVar1;
  ulong uVar2;
  undefined8 local_20;
  
  local_20 = 1;
  if (1 < param_1) {
    while( true ) {
      bVar1 = false;
      if (local_20 < 0x40) {
        uVar2 = _mod_pow(local_20,param_1 - 1,param_1);
        bVar1 = uVar2 < 2;
      }
      if (!bVar1) break;
      local_20 = local_20 + 1;
    }
  }
  return local_20 == 0x40;
}



ulong _pollard_rho(ulong param_1)

{
  ulong uVar1;
  ulong uVar2;
  bool bVar3;
  ulong local_50;
  ulong local_48;
  ulong local_40;
  ulong local_38;
  ulong local_30;
  ulong local_28;
  ulong local_20;
  ulong local_18;
  ulong local_10;
  
  DAT_100008000 = (DAT_100008000 * 0x3d1e9ba1 + 0x111897ec) % 0xfffffffb;
  local_10 = 1;
  local_30 = 0;
  local_38 = 1;
  local_40 = 1;
  uVar1 = param_1 - 1;
  uVar2 = 0;
  if (uVar1 != 0) {
    uVar2 = DAT_100008000 / uVar1;
  }
  local_48 = (DAT_100008000 - uVar2 * uVar1) + 1;
  do {
    if (local_10 != 1) {
      return local_10;
    }
    if (local_30 == local_38) {
      if (local_38 >> 0x12 != 0) {
        return 1;
      }
      local_38 = local_38 << 1;
      local_40 = local_48;
    }
    local_18 = local_48;
    local_20 = local_48;
    local_48 = 0;
    while (local_18 != 0) {
      if ((local_18 & 1) != 0) {
        if (param_1 - local_48 <= local_20) {
          local_48 = local_48 - param_1;
        }
        local_48 = local_48 + local_20;
      }
      local_18 = local_18 >> 1;
      local_28 = local_20;
      if (param_1 - local_20 <= local_20) {
        local_28 = local_20 - param_1;
      }
      local_20 = local_20 + local_28;
    }
    uVar1 = 0;
    if (param_1 != 0) {
      uVar1 = (local_48 + 1) / param_1;
    }
    local_48 = (local_48 + 1) - uVar1 * param_1;
    if (local_40 < local_48) {
      local_50 = local_48 - local_40;
    }
    else {
      local_50 = local_40 - local_48;
    }
    local_18 = local_50;
    local_20 = param_1;
    do {
      uVar1 = 0;
      if (local_20 != 0) {
        uVar1 = local_18 / local_20;
      }
      local_18 = local_18 - uVar1 * local_20;
      bVar3 = false;
      if (local_18 != 0) {
        uVar1 = 0;
        if (local_18 != 0) {
          uVar1 = local_20 / local_18;
        }
        local_20 = local_20 - uVar1 * local_18;
        bVar3 = local_20 != 0;
      }
    } while (bVar3);
    local_10 = local_18 | local_20;
    local_30 = local_30 + 1;
  } while( true );
}



void _factor(ulong param_1,long *param_2)

{
  ulong uVar1;
  int iVar2;
  long lVar3;
  ulong local_28;
  
  if ((param_1 < 4) || (iVar2 = _is_prime(param_1), iVar2 != 0)) {
    if ((1 < param_1) || (*param_2 == 0)) {
      lVar3 = *param_2;
      *param_2 = lVar3 + 1;
      param_2[lVar3 + 1] = param_1;
    }
  }
  else {
    local_28 = _square_root(param_1);
    if (local_28 * local_28 - param_1 != 0) {
      local_28 = _pollard_rho(param_1);
    }
    _factor(local_28,param_2);
    uVar1 = 0;
    if (local_28 != 0) {
      uVar1 = param_1 / local_28;
    }
    _factor(uVar1,param_2);
  }
  return;
}



undefined4 entry(void)

{
  uint uVar1;
  ulong uVar2;
  ulong local_248;
  ulong local_230 [65];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  _bzero(local_230,0x208);
  uVar2 = _factor(0xffffffffffffffff,local_230);
  for (local_248 = 1; local_248 <= local_230[0]; local_248 = local_248 + 1) {
    uVar1 = _printf("* %llu\n");
    uVar2 = (ulong)uVar1;
  }
  if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(uVar2);
  }
  return 0;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003f60. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _bzero(void *param_1,size_t param_2)

{
                    // WARNING: Could not recover jumptable at 0x000100003f6c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__bzero_100004010)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f78. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004018)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <stdbool.h>

typedef double Fp;
typedef struct { Fp x, y, r; } Circle;

Circle circles[] = {
    { 1.6417233788,  1.6121789534, 0.0848270516},
    {-1.4944608174,  1.2077959613, 1.1039549836},
    { 0.6110294452, -0.6907087527, 0.9089162485},
    { 0.3844862411,  0.2923344616, 0.2375743054},
    {-0.2495892950, -0.3832854473, 1.0845181219},
    { 1.7813504266,  1.6178237031, 0.8162655711},
    {-0.1985249206, -0.8343333301, 0.0538864941},
    {-1.7011985145, -0.1263820964, 0.4776976918},
    {-0.4319462812,  1.4104420482, 0.7886291537},
    { 0.2178372997, -0.9499557344, 0.0357871187},
    {-0.6294854565, -1.3078893852, 0.7653357688},
    { 1.7952608455,  0.6281269104, 0.2727652452},
    { 1.4168575317,  1.0683357171, 1.1016025378},
    { 1.4637371396,  0.9463877418, 1.1846214562},
    {-0.5263668798,  1.7315156631, 1.4428514068},
    {-1.2197352481,  0.9144146579, 1.0727263474},
    {-0.1389358881,  0.1092805780, 0.7350208828},
    { 1.5293954595,  0.0030278255, 1.2472867347},
    {-0.5258728625,  1.3782633069, 1.3495508831},
    {-0.1403562064,  0.2437382535, 1.3804956588},
    { 0.8055826339, -0.0482092025, 0.3327165165},
    {-0.6311979224,  0.7184578971, 0.2491045282},
    { 1.4685857879, -0.8347049536, 1.3670667538},
    {-0.6855727502,  1.6465021616, 1.0593087096},
    { 0.0152957411,  0.0638919221, 0.9771215985}};

const size_t n_circles = sizeof(circles) / sizeof(Circle);

static inline Fp min(const Fp a, const Fp b) { return a <= b ? a : b; }

static inline Fp max(const Fp a, const Fp b) { return a >= b ? a : b; }

static inline Fp sq(const Fp a) { return a * a; }

// Return an uniform random value in [a, b).
static inline double uniform(const double a, const double b) {
    const double r01 = rand() / (double)RAND_MAX;
    return a + (b - a) * r01;
}

static inline bool is_inside_circles(const Fp x, const Fp y) {
    for (size_t i = 0; i < n_circles; i++)
        if (sq(x - circles[i].x) + sq(y - circles[i].y) < circles[i].r)
            return true;
    return false;
}

int main() {
    // Initialize the bounding box (bbox) of the circles.
    Fp x_min = INFINITY, x_max = -INFINITY;
    Fp y_min = x_min, y_max = x_max;

    // Compute the bounding box of the circles.
    for (size_t i = 0; i < n_circles; i++) {
        Circle *c = &circles[i];
        x_min = min(x_min, c->x - c->r);
        x_max = max(x_max, c->x + c->r);
        y_min = min(y_min, c->y - c->r);
        y_max = max(y_max, c->y + c->r);

        c->r *= c->r; // Square the radii to speed up testing.
    }

    const Fp bbox_area = (x_max - x_min) * (y_max - y_min);

    // Montecarlo sampling.
    srand(time(0));
    size_t to_try = 1U << 16;
    size_t n_tries = 0;
    size_t n_hits = 0;

    while (true) {
        n_hits += is_inside_circles(uniform(x_min, x_max),
                                    uniform(y_min, y_max));
        n_tries++;

        if (n_tries == to_try) {
            const Fp area = bbox_area * n_hits / n_tries;
            const Fp r = (Fp)n_hits / n_tries;
            const Fp s = area * sqrt(r * (1 - r) / n_tries);
            printf("%.4f +/- %.4f (%zd samples)\n", area, s, n_tries);
            if (s * 3 <= 1e-3) // Stop at 3 sigmas.
                break;
            to_try *= 2;
        }
    }

    return 0;
}
`,`#include "total-circles-area-1.h"



undefined8 entry(void)

{
  time_t tVar1;
  ulong uVar2;
  long lVar3;
  undefined8 uVar4;
  undefined8 uVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  double dVar9;
  double dVar10;
  long local_68;
  long local_60;
  long local_58;
  ulong local_40;
  double local_38;
  double local_30;
  double local_28;
  double local_20;
  
  local_20 = INFINITY;
  local_28 = -INFINITY;
  local_30 = INFINITY;
  local_38 = -INFINITY;
  for (local_40 = 0; local_40 < 0x19; local_40 = local_40 + 1) {
    lVar3 = local_40 * 0x18;
    local_20 = (double)FUN_100003d1c(local_20,*(double *)(&_circles + lVar3) -
                                              *(double *)(&DAT_100008010 + lVar3));
    local_28 = (double)FUN_100003d64(local_28,*(double *)(&_circles + lVar3) +
                                              *(double *)(&DAT_100008010 + lVar3));
    local_30 = (double)FUN_100003d1c(local_30,*(double *)(&DAT_100008008 + lVar3) -
                                              *(double *)(&DAT_100008010 + lVar3));
    local_38 = (double)FUN_100003d64(local_38,*(double *)(&DAT_100008008 + lVar3) +
                                              *(double *)(&DAT_100008010 + lVar3));
    *(double *)(&DAT_100008010 + lVar3) =
         *(double *)(&DAT_100008010 + lVar3) * *(double *)(&DAT_100008010 + lVar3);
  }
  tVar1 = _time((time_t *)0x0);
  _srand((uint)tVar1);
  local_58 = 0x10000;
  local_60 = 0;
  local_68 = 0;
  while( true ) {
    do {
      uVar4 = FUN_100003eb4(local_20,local_28);
      uVar5 = FUN_100003eb4(local_30,local_38);
      uVar2 = FUN_100003dac(uVar4,uVar5);
      local_68 = local_68 + (uVar2 & 1);
      local_60 = local_60 + 1;
    } while (local_60 != local_58);
    dVar7 = (double)NEON_ucvtf(local_68);
    dVar8 = (double)NEON_ucvtf(local_60);
    dVar6 = (double)NEON_ucvtf(local_68);
    dVar9 = (double)NEON_ucvtf(local_60);
    dVar10 = (double)NEON_ucvtf(local_60);
    _printf("%.4f +/- %.4f (%zd samples)\n");
    if ((((local_28 - local_20) * (local_38 - local_30) * dVar7) / dVar8) *
        SQRT(((dVar6 / dVar9) * (1.0 - dVar6 / dVar9)) / dVar10) * 3.0 <= 0.001) break;
    local_58 = local_58 << 1;
  }
  return 0;
}



undefined  [16] FUN_100003d1c(double param_1,double param_2)

{
  undefined auVar1 [16];
  double local_18;
  
  local_18 = param_2;
  if (param_1 <= param_2) {
    local_18 = param_1;
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_18;
  return auVar1;
}



undefined  [16] FUN_100003d64(double param_1,double param_2)

{
  undefined auVar1 [16];
  double local_18;
  
  local_18 = param_2;
  if (param_2 <= param_1) {
    local_18 = param_1;
  }
  auVar1._8_8_ = 0;
  auVar1._0_8_ = local_18;
  return auVar1;
}



undefined FUN_100003dac(double param_1,double param_2)

{
  double dVar1;
  double dVar2;
  ulong local_30;
  
  local_30 = 0;
  while( true ) {
    if (0x18 < local_30) {
      return 0;
    }
    dVar1 = (double)FUN_100003f04(param_1 - *(double *)(&_circles + local_30 * 0x18));
    dVar2 = (double)FUN_100003f04(param_2 - *(double *)(&DAT_100008008 + local_30 * 0x18));
    if (dVar1 + dVar2 < *(double *)(&DAT_100008010 + local_30 * 0x18)) break;
    local_30 = local_30 + 1;
  }
  return 1;
}



undefined  [16] FUN_100003eb4(double param_1,double param_2)

{
  int iVar1;
  undefined auVar2 [16];
  
  iVar1 = _rand();
  auVar2._0_8_ = NEON_fmadd(param_2 - param_1,(double)iVar1 / 2147483647.0,param_1);
  auVar2._8_8_ = 0;
  return auVar2;
}



undefined  [16] FUN_100003f04(double param_1)

{
  undefined auVar1 [16];
  
  auVar1._0_8_ = param_1 * param_1;
  auVar1._8_8_ = 0;
  return auVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004008)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004010)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004018)();
  return tVar1;
}


`
`#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#define SIM_N           5  /* Run 5 simulations */
#define PRINT_DISCARDED 1  /* Whether or not to print the discard pile */

#define min(x,y) ((x<y)?(x):(y))

typedef uint8_t card_t;

/* Return a random number from an uniform distribution (0..n-1) */
unsigned int rand_n(unsigned int n) {
    unsigned int out, mask = 1;
    /* Find how many bits to mask off */
    while (mask < n) mask = mask<<1 | 1;
    /* Generate random number */
    do {
        out = rand() & mask;
    } while (out >= n);
    return out;
}

/* Return a random card (0..51) from an uniform distribution */
card_t rand_card() {
    return rand_n(52);
}

/* Print a card */
void print_card(card_t card) {
    static char *suits = "HCDS"; /* hearts, clubs, diamonds and spades */
    static char *cards[] = {"A","2","3","4","5","6","7","8","9","10","J","Q","K"};
    printf(" %s%c", cards[card>>2], suits[card&3]);
}

/* Shuffle a pack */
void shuffle(card_t *pack) {
    int card;
    card_t temp, randpos;
    for (card=0; card<52; card++) {
        randpos = rand_card();
        temp = pack[card];
        pack[card] = pack[randpos];
        pack[randpos] = temp;
    }
}

/* Do the card trick, return whether cards match */
int trick() {
    card_t pack[52];
    card_t blacks[52/4], reds[52/4];
    card_t top, x, card;
    int blackn=0, redn=0, blacksw=0, redsw=0, result;

    /* Create and shuffle a pack */
    for (card=0; card<52; card++) pack[card] = card;
    shuffle(pack);

    /* Deal cards */
#if PRINT_DISCARDED
    printf("Discarded:"); /* Print the discard pile */
#endif
    for (card=0; card<52; card += 2) {
        top = pack[card]; /* Take card */
        if (top & 1) { /* Add next card to black or red pile */
            blacks[blackn++] = pack[card+1];
        } else {
            reds[redn++] = pack[card+1];
        }
#if PRINT_DISCARDED
        print_card(top); /* Show which card is discarded */
#endif
    }
#if PRINT_DISCARDED
    printf("\n");
#endif

    /* Swap an amount of cards */
    x = rand_n(min(blackn, redn));
    for (card=0; card<x; card++) {
        /* Pick a random card from the black and red pile to swap */
        blacksw = rand_n(blackn);
        redsw = rand_n(redn);
        /* Swap them */
        top = blacks[blacksw];
        blacks[blacksw] = reds[redsw];
        reds[redsw] = top;
    }

    /* Verify the assertion */
    result = 0;
    for (card=0; card<blackn; card++)
        result += (blacks[card] & 1) == 1;
    for (card=0; card<redn; card++)
        result -= (reds[card] & 1) == 0;
    result = !result;

    printf("The number of black cards in the 'black' pile"
           " %s the number of red cards in the 'red' pile.\n",
           result? "equals" : "does not equal");
    return result;
}

int main() {
    unsigned int seed, i, successes = 0;
    FILE *r;

    /* Seed the RNG with bytes from from /dev/urandom */
    if ((r = fopen("/dev/urandom", "r")) == NULL) {
        fprintf(stderr, "cannot open /dev/urandom\n");
        return 255;
    }
    if (fread(&seed, sizeof(unsigned int), 1, r) != 1) {
        fprintf(stderr, "failed to read from /dev/urandom\n");
        return 255;
    }
    fclose(r);
    srand(seed);

    /* Do simulations. */
    for (i=1; i<=SIM_N; i++) {
        printf("Simulation %d\n", i);
        successes += trick();
        printf("\n");
    }

    printf("Result: %d successes out of %d simulations\n",
        successes, SIM_N);

    return 0;
}
`,`#include "mind-boggling-card-trick.h"



uint _rand_n(uint param_1)

{
  uint uVar1;
  undefined4 local_1c;
  
  for (local_1c = 1; local_1c < param_1; local_1c = local_1c << 1 | 1) {
  }
  do {
    uVar1 = _rand();
  } while (param_1 <= (uVar1 & local_1c));
  return uVar1 & local_1c;
}



undefined _rand_card(void)

{
  undefined uVar1;
  
  uVar1 = _rand_n(0x34);
  return uVar1;
}



int _print_card(void)

{
  int iVar1;
  
  iVar1 = _printf(" %s%c");
  return iVar1;
}



void _shuffle(long param_1)

{
  undefined uVar1;
  byte bVar2;
  int local_1c;
  
  for (local_1c = 0; local_1c < 0x34; local_1c = local_1c + 1) {
    bVar2 = _rand_card();
    uVar1 = *(undefined *)(param_1 + local_1c);
    *(undefined *)(param_1 + local_1c) = *(undefined *)(param_1 + (ulong)bVar2);
    *(undefined *)(param_1 + (ulong)bVar2) = uVar1;
  }
  return;
}



bool _trick(void)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  long lVar5;
  int local_84;
  int local_80;
  int local_74;
  int local_70;
  byte local_69;
  byte abStack_66 [13];
  byte abStack_59 [13];
  byte abStack_4c [52];
  long local_18;
  
  local_18 = *(long *)PTR____stack_chk_guard_100004008;
  local_70 = 0;
  local_74 = 0;
  for (local_69 = 0; local_69 < 0x34; local_69 = local_69 + 1) {
    abStack_4c[local_69] = local_69;
  }
  _shuffle(abStack_4c);
  _printf("Discarded:");
  for (local_69 = 0; local_69 < 0x34; local_69 = local_69 + 2) {
    bVar2 = abStack_4c[local_69];
    if ((bVar2 & 1) == 0) {
      lVar5 = (long)local_74;
      local_74 = local_74 + 1;
      abStack_66[lVar5] = abStack_4c[(int)(local_69 + 1)];
    }
    else {
      lVar5 = (long)local_70;
      local_70 = local_70 + 1;
      abStack_59[lVar5] = abStack_4c[(int)(local_69 + 1)];
    }
    _print_card(bVar2);
  }
  _printf("\n");
  if (local_70 < local_74) {
    local_84 = local_70;
  }
  else {
    local_84 = local_74;
  }
  bVar2 = _rand_n(local_84);
  for (local_69 = 0; local_69 < bVar2; local_69 = local_69 + 1) {
    iVar3 = _rand_n(local_70);
    iVar4 = _rand_n(local_74);
    bVar1 = abStack_59[iVar3];
    abStack_59[iVar3] = abStack_66[iVar4];
    abStack_66[iVar4] = bVar1;
  }
  local_80 = 0;
  for (local_69 = 0; (int)(uint)local_69 < local_70; local_69 = local_69 + 1) {
    local_80 = local_80 + (uint)((abStack_59[local_69] & 1) == 1);
  }
  for (local_69 = 0; (int)(uint)local_69 < local_74; local_69 = local_69 + 1) {
    local_80 = local_80 - (uint)((abStack_66[local_69] & 1) == 0);
  }
  iVar3 = _printf(
                 "The number of black cards in the \'black\' pile %s the number of red cards in the \'red\' pile.\n"
                 );
  if (*(long *)PTR____stack_chk_guard_100004008 != local_18) {
                    // WARNING: Subroutine does not return
    ___stack_chk_fail(iVar3);
  }
  return local_80 == 0;
}



undefined4 entry(void)

{
  int iVar1;
  FILE *pFVar2;
  size_t sVar3;
  uint local_1c;
  uint local_18;
  undefined4 local_14;
  
  local_14 = 0;
  pFVar2 = _fopen("/dev/urandom","r");
  if (pFVar2 == (FILE *)0x0) {
    _fprintf(*(FILE **)PTR____stderrp_100004010,"cannot open /dev/urandom\n");
    local_14 = 0xff;
  }
  else {
    sVar3 = _fread(&local_18,4,1,pFVar2);
    if (sVar3 == 1) {
      _fclose(pFVar2);
      _srand(local_18);
      for (local_1c = 1; local_1c < 6; local_1c = local_1c + 1) {
        iVar1 = _printf("Simulation %d\n");
        _trick(iVar1);
        _printf("\n");
      }
      _printf("Result: %d successes out of %d simulations\n");
      local_14 = 0;
    }
    else {
      _fprintf(*(FILE **)PTR____stderrp_100004010,"failed to read from /dev/urandom\n");
      local_14 = 0xff;
    }
  }
  return local_14;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003e24. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fclose(FILE *param_1)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e30. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fclose_100004018)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * _fopen(char *param_1,char *param_2)

{
  FILE *pFVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e3c. Too many branches
                    // WARNING: Treating indirect jump as call
  pFVar1 = (FILE *)(*(code *)PTR__fopen_100004020)();
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _fprintf(FILE *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e48. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__fprintf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t _fread(void *param_1,size_t param_2,size_t param_3,FILE *param_4)

{
  size_t sVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e54. Too many branches
                    // WARNING: Treating indirect jump as call
  sVar1 = (*(code *)PTR__fread_100004030)();
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e60. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004038)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003e6c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004040)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003e78. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004048)(param_1);
  return;
}


`
`#include <stdio.h>

int main()
{
  int num;

  sscanf("0123459", "%d", &num);
  printf("%d\n", num); /* prints 123459 */

  sscanf("abcf123", "%x", &num);
  printf("%d\n", num); /* prints 180154659 */

  sscanf("7651", "%o", &num);
  printf("%d\n", num); /* prints 4009 */

  /* binary not supported */

  return 0;
}
`,`#include "non-decimal-radices-input-1.h"



undefined4 entry(void)

{
  _sscanf("0123459","%d");
  _printf("%d\n");
  _sscanf("abcf123","%x");
  _printf("%d\n");
  _sscanf("7651","%o");
  _printf("%d\n");
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f74. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _sscanf(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f80. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__sscanf_100004008)((int)param_1);
  return iVar1;
}


`
`#include <stdio.h> // Standard IO
#include <stdlib.h> // other stuff
#include <time.h>
#include <string.h>

//This should add weighted random function to "The Elite Noob"'s code, stolen from above code because it does calculation so well
//closest I could make it to original but without pointless attempt to make code look smaller than above code by putting code on the same lines

int rand_i(int n)
{
	int rand_max = RAND_MAX - (RAND_MAX % n);
	int ret;
	while ((ret = rand()) >= rand_max);
	return ret/(rand_max / n);
}

int weighed_rand(int *tbl, int len)
{
	int i, sum, r;
	for (i = 0, sum = 0; i < len; sum += tbl[i++]);
	if (!sum) return rand_i(len);

	r = rand_i(sum) + 1;
	for (i = 0; i < len && (r -= tbl[i]) > 0; i++);
	return i;
}



int main(int argc, const char *argv[])
{
	char umove[10], cmove[10], line[255];
	int user, comp;
	int tbl[]={0,0,0};
	int tbllen=3;
	printf("Hello, Welcome to rock-paper-scissors\nBy The Elite Noob\n");
mainloop:
	while(1)
	{ // infinite loop :)
		printf("\n\nPlease type in 1 for Rock, 2 For Paper, 3 for Scissors, 4 to quit\n");
		srand(time(NULL));
		comp = (weighed_rand(tbl, tbllen) + 1) % 3;
		fgets(line, sizeof(line), stdin);	
		while(sscanf(line, "%d", &user) != 1) //1 match of defined specifier on input line
		{
  			printf("You have not entered an integer.\n");
			fgets(line, sizeof(line), stdin);
		}				
		if( (user > 4) || (user < 1) )
		{
			printf("Please enter a valid number!\n");
			continue;
		}
		switch (comp)
		{
			case 1 :
				strcpy(cmove, "Rock");
				break;
			case 2 :
				strcpy(cmove, "Paper");
				break;
			case 3 :
				strcpy(cmove, "Scissors");
				break;
			default :
				printf("Computer Error, set comp=1\n");
				comp=1;
				strcpy(cmove, "Rock");
				break;
		}
		switch (user)
		{
			case 1 :
				strcpy(umove, "Rock");
				break;
			case 2 :
				strcpy(umove, "Paper");
				break;
			case 3 :
				strcpy(umove, "Scissors");
				break;
			case 4 :
				printf("Goodbye! Thanks for playing!\n");
				return 0;
			default :
				printf("Error, user number not between 1-4 exiting...");
				goto mainloop;
		}
		if( (user+1)%3 == comp )
		{
			printf("Comp Played: %s\nYou Played: %s\nSorry, You Lost!\n", cmove, umove);
		}	
		else if(comp == user)
		{
			printf("Comp Played: %s\nYou Played: %s\nYou Tied :p\n", cmove, umove);
		}
		else
		{
			printf("Comp Played: %s\nYou Played: %s\nYay, You Won!\n", cmove, umove);
		}
		tbl[user-1]++;
	}
}
`,`#include "rock-paper-scissors-2.h"



int _rand_i(int param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  iVar1 = 0;
  if (param_1 != 0) {
    iVar1 = 0x7fffffff / param_1;
  }
  iVar1 = 0x7fffffff - (0x7fffffff - iVar1 * param_1);
  do {
    iVar3 = _rand();
  } while (iVar1 <= iVar3);
  iVar2 = 0;
  if (param_1 != 0) {
    iVar2 = iVar1 / param_1;
  }
  iVar1 = 0;
  if (iVar2 != 0) {
    iVar1 = iVar3 / iVar2;
  }
  return iVar1;
}



int _weighed_rand(long param_1,int param_2)

{
  bool bVar1;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_14;
  
  local_2c = 0;
  for (local_28 = 0; local_28 < param_2; local_28 = local_28 + 1) {
    local_2c = local_2c + *(int *)(param_1 + (long)local_28 * 4);
  }
  if (local_2c == 0) {
    local_14 = _rand_i(param_2);
  }
  else {
    local_30 = _rand_i(local_2c);
    local_30 = local_30 + 1;
    local_28 = 0;
    while( true ) {
      bVar1 = false;
      if (local_28 < param_2) {
        local_30 = local_30 - *(int *)(param_1 + (long)local_28 * 4);
        bVar1 = 0 < local_30;
      }
      if (!bVar1) break;
      local_28 = local_28 + 1;
    }
    local_14 = local_28;
  }
  return local_14;
}



undefined8 entry(void)

{
  int iVar1;
  time_t tVar2;
  int local_160;
  int local_15c;
  int local_148 [3];
  char acStack_13b [255];
  undefined auStack_3c [10];
  undefined auStack_32 [10];
  long local_28;
  
  local_28 = *(long *)PTR____stack_chk_guard_100004008;
  local_148[0] = 0;
  local_148[1] = 0;
  local_148[2] = 0;
  _printf("Hello, Welcome to rock-paper-scissors\nBy The Elite Noob\n");
LAB_100003a20:
  do {
    while( true ) {
      _printf("\n\nPlease type in 1 for Rock, 2 For Paper, 3 for Scissors, 4 to quit\n");
      tVar2 = _time((time_t *)0x0);
      _srand((uint)tVar2);
      iVar1 = _weighed_rand(local_148,3);
      local_160 = (iVar1 + 1) % 3;
      _fgets(acStack_13b,0xff,*(FILE **)PTR____stdinp_100004010);
      while (iVar1 = _sscanf(acStack_13b,"%d"), iVar1 != 1) {
        _printf("You have not entered an integer.\n");
        _fgets(acStack_13b,0xff,*(FILE **)PTR____stdinp_100004010);
      }
      if ((local_15c < 5) && (0 < local_15c)) break;
      _printf("Please enter a valid number!\n");
    }
    if (local_160 == 1) {
      ___strcpy_chk(auStack_3c,"Rock",10);
    }
    else if (local_160 == 2) {
      ___strcpy_chk(auStack_3c,"Paper",10);
    }
    else if (local_160 == 3) {
      ___strcpy_chk(auStack_3c,"Scissors",10);
    }
    else {
      _printf("Computer Error, set comp=1\n");
      local_160 = 1;
      ___strcpy_chk(auStack_3c,"Rock",10);
    }
    switch(local_15c) {
    case 1:
      ___strcpy_chk(auStack_32,"Rock",10);
      break;
    case 2:
      ___strcpy_chk(auStack_32,"Paper",10);
      break;
    case 3:
      ___strcpy_chk(auStack_32,"Scissors",10);
      break;
    case 4:
      iVar1 = _printf("Goodbye! Thanks for playing!\n");
      if (*(long *)PTR____stack_chk_guard_100004008 != local_28) {
                    // WARNING: Subroutine does not return
        ___stack_chk_fail(iVar1);
      }
      return 0;
    default:
      goto switchD_100003bec_caseD_4;
    }
    if ((local_15c + 1) % 3 == local_160) {
      _printf("Comp Played: %s\nYou Played: %s\nSorry, You Lost!\n");
    }
    else if (local_160 == local_15c) {
      _printf("Comp Played: %s\nYou Played: %s\nYou Tied :p\n");
    }
    else {
      _printf("Comp Played: %s\nYou Played: %s\nYay, You Won!\n");
    }
    local_148[local_15c + -1] = local_148[local_15c + -1] + 1;
  } while( true );
switchD_100003bec_caseD_4:
  _printf("Error, user number not between 1-4 exiting...");
  goto LAB_100003a20;
}



void ___stack_chk_fail(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003d78. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____stack_chk_fail_100004000)();
  return;
}



void ___strcpy_chk(void)

{
                    // WARNING: Could not recover jumptable at 0x000100003d84. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR____strcpy_chk_100004018)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * _fgets(char *param_1,int param_2,FILE *param_3)

{
  char *pcVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d90. Too many branches
                    // WARNING: Treating indirect jump as call
  pcVar1 = (char *)(*(code *)PTR__fgets_100004020)(param_1,param_2);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003d9c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004028)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003da8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004030)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003db4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004038)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _sscanf(char *param_1,char *param_2,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dc0. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__sscanf_100004040)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003dcc. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004048)();
  return tVar1;
}


`
`#include <stdio.h> //printf()
#include <stdlib.h> //srand(), rand(), RAND_MAX, qsort()
#include <stdbool.h> //true, false
#include <time.h> //time()

#define NUMBALLS 5 //NUMBALLS>1

int compar(const void *a, const void *b){
	char c1=*(const char*)a, c2=*(const char*)b; //first cast void* to char*, then dereference
	return c1-c2;
}

_Bool issorted(char *balls){
	int i,state;
	state=0;
	for(i=0;i<NUMBALLS;i++){
		if(balls[i]<state)return false;
		if(balls[i]>state)state=balls[i];
	}
	return true;
}

void printout(char *balls){
	int i;
	char str[NUMBALLS+1];
	for(i=0;i<NUMBALLS;i++)str[i]=balls[i]==0?'r':balls[i]==1?'w':'b';
	printf("%s\n",str);
}

int main(void) {
	char balls[NUMBALLS]; //0=r, 1=w, 2=b
	int i;
	srand(time(NULL)); //not a good seed but good enough for the example
	rand(); //rand() always starts with the same values for certain seeds, making
	        //  testing pretty irritating
	// Generate balls
	for(i=0;i<NUMBALLS;i++)balls[i]=(double)rand()/RAND_MAX*3;
	while(issorted(balls)){ //enforce that we start with non-sorted balls
		printf("Accidentally still sorted: ");
		printout(balls);
		for(i=0;i<NUMBALLS;i++)balls[i]=(double)rand()/RAND_MAX*3;
	}
	printf("Non-sorted: ");
	printout(balls);
	qsort(balls,NUMBALLS,sizeof(char),compar); //sort them using quicksort (stdlib)
	if(issorted(balls)){ //unnecessary check but task enforces it
		printf("Sorted: ");
		printout(balls);
	} else {
		printf("Sort failed: ");
		printout(balls);
	}
	return 0;
}
`,`#include "dutch-national-flag-problem.h"



int _compar(char *param_1,char *param_2)

{
  return (int)*param_1 - (int)*param_2;
}



undefined _issorted(long param_1)

{
  char cVar1;
  int local_14;
  
  cVar1 = '\0';
  local_14 = 0;
  while( true ) {
    if (4 < local_14) {
      return 1;
    }
    if (*(char *)(param_1 + local_14) < cVar1) break;
    if (cVar1 < *(char *)(param_1 + local_14)) {
      cVar1 = *(char *)(param_1 + local_14);
    }
    local_14 = local_14 + 1;
  }
  return 0;
}



int _printout(long param_1)

{
  int iVar1;
  undefined local_28;
  undefined auStack_22 [6];
  int local_1c;
  long local_18;
  
  for (local_1c = 0; local_1c < 5; local_1c = local_1c + 1) {
    if (*(char *)(param_1 + local_1c) == '\0') {
      local_28 = 0x72;
    }
    else {
      local_28 = 0x77;
      if (*(char *)(param_1 + local_1c) != '\x01') {
        local_28 = 0x62;
      }
    }
    auStack_22[local_1c] = local_28;
  }
  local_18 = param_1;
  iVar1 = _printf("%s\n");
  return iVar1;
}



undefined8 entry(void)

{
  int iVar1;
  time_t tVar2;
  ulong uVar3;
  int local_20;
  undefined auStack_19 [5];
  undefined4 local_14;
  
  local_14 = 0;
  tVar2 = _time((time_t *)0x0);
  _srand((uint)tVar2);
  _rand();
  for (local_20 = 0; local_20 < 5; local_20 = local_20 + 1) {
    iVar1 = _rand();
    auStack_19[local_20] = (char)(int)(((double)iVar1 / 2147483647.0) * 3.0);
  }
  while (uVar3 = _issorted(auStack_19), (uVar3 & 1) != 0) {
    _printf("Accidentally still sorted: ");
    _printout(auStack_19);
    for (local_20 = 0; local_20 < 5; local_20 = local_20 + 1) {
      iVar1 = _rand();
      auStack_19[local_20] = (char)(int)(((double)iVar1 / 2147483647.0) * 3.0);
    }
  }
  _printf("Non-sorted: ");
  _printout();
  _qsort(auStack_19,5,1,(int *)_compar);
  uVar3 = _issorted(auStack_19);
  if ((uVar3 & 1) == 0) {
    _printf("Sort failed: ");
    _printout(auStack_19);
  }
  else {
    _printf("Sorted: ");
    _printout(auStack_19);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f1c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _qsort(void *param_1,size_t param_2,size_t param_3,int *param_4)

{
                    // WARNING: Could not recover jumptable at 0x000100003f28. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__qsort_100004008)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _rand(void)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f34. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__rand_100004010)();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _srand(uint param_1)

{
                    // WARNING: Could not recover jumptable at 0x000100003f40. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)PTR__srand_100004018)(param_1);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t _time(time_t *param_1)

{
  time_t tVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f4c. Too many branches
                    // WARNING: Treating indirect jump as call
  tVar1 = (*(code *)PTR__time_100004020)();
  return tVar1;
}


`
`#include<stdio.h>
long long seed;
long long random(){
        seed = seed * seed / 1000 % 1000000;
        return seed;
}
int main(){
        seed = 675248;
        for(int i=1;i<=5;i++)
                printf("%lld\n",random());
        return 0;
}
`,`#include "pseudo-random-numbers-middle-square-method.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

long _random(void)

{
  __seed = ((__seed * __seed) / 1000) % 1000000;
  return __seed;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 entry(void)

{
  int local_18;
  
  __seed = 0xa4db0;
  for (local_18 = 1; local_18 < 6; local_18 = local_18 + 1) {
    _random();
    _printf("%lld\n");
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _printf(char *param_1,...)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x000100003f94. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*(code *)PTR__printf_100004000)((int)param_1);
  return iVar1;
}


`
