`//FormAI DATASET v1.0 Category: Image Steganography ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//This program demonstrates a unique implementation of LSB steganography on an image

//Function to get image data
unsigned char* getImage(char *filename) {
    FILE *in;
    unsigned char *data;

    in = fopen(filename,"rb");

    if (in == NULL) {
        printf("Error opening file.\n");
        exit(1);
    }

    data = (unsigned char*) malloc(sizeof(unsigned char));

    fread(data,1,sizeof(unsigned char),in);

    fclose(in);

    return data;
}

//Function to write image data
void writeImage(char *filename, unsigned char *data) {
    FILE *out;

    out = fopen(filename,"wb");

    if (out == NULL) {
        printf("Error opening file.\n");
        exit(1);
    }

    fwrite(data,1,sizeof(unsigned char),out);

    fclose(out);

}

//Function to hide message in the least significant bits of the image data
void hideMessage(char *message, unsigned char *imageData) {
    int messageLength = strlen(message);
    int bitCount = 0;

    for (int i = 0; i < messageLength; i++) {
        for (int j = 0; j < 8; j++) {
            unsigned char bit = (message[i] >> j) & 1;
            if (bit) {
                imageData[bitCount] |= 1;
            } else {
                imageData[bitCount] &= 0xFE;
            }
            bitCount++;
        }
    }
}

//Function to get hidden message from the least significant bits of the image data
char* getMessage(unsigned char *imageData) {
    char *message = (char*) malloc(sizeof(char));
    int messageLength = 0;
    int bitCount = 0;

    while (1) {
        char ch = 0;
        for (int i = 0; i < 8; i++) {
            char bit = imageData[bitCount] & 1;
            ch |= bit << i;
            bitCount++;
        }
        if (ch == '\0') break;
        message[messageLength] = ch;
        messageLength++;
        message = (char*) realloc(message,sizeof(char) * (messageLength + 1));
    }
    message[messageLength] = '\0';

    return message;
}

int main() {

    printf("LSB Steganography Implementation on Images\n\n");

    char *message = "Hidden message!";
    unsigned char *imageData;

    //Get the image data
    imageData = getImage("image.bmp");

    //Hide the message in the image data
    hideMessage(message,imageData);

    //Write the new image data to a file
    writeImage("hidden.bmp",imageData);

    //Get the hidden message from the image data
    char *hiddenMessage = getMessage(imageData);

    printf("Message hidden in image: %s\n",hiddenMessage);

    //Free memory
    free(imageData);
    free(hiddenMessage);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall getImage(_QWORD); // weak
__int64 __fastcall writeImage(_QWORD, _QWORD); // weak
__int64 __fastcall hideMessage(_QWORD, _QWORD); // weak
__int64 __fastcall getMessage(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (0000000140001816) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *Message; // [rsp+28h] [rbp-18h]
  void *Block; // [rsp+30h] [rbp-10h]

  _main(argc, argv, envp);
  printf("LSB Steganography Implementation on Images\n\n");
  Block = (void *)getImage("image.bmp");
  hideMessage("Hidden message!", Block);
  writeImage("hidden.bmp", Block);
  Message = (char *)getMessage(Block);
  printf("Message hidden in image: %s\n", Message);
  free(Block);
  free(Message);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall getImage(_QWORD);
// 140001616: using guessed type __int64 __fastcall writeImage(_QWORD, _QWORD);
// 14000168E: using guessed type __int64 __fastcall hideMessage(_QWORD, _QWORD);
// 14000175A: using guessed type __int64 __fastcall getMessage(_QWORD);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

const int BOARD_SIZE = 4;

void generateBoard(int board[][BOARD_SIZE]) {
    int numPairs = (BOARD_SIZE * BOARD_SIZE) / 2;
    int pairs[numPairs];
    for (int i = 0; i < numPairs; i++) {
        pairs[i] = i;
    }

    srand(time(NULL));
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            int index = rand() % numPairs;
            board[i][j] = pairs[index];
            pairs[index] = pairs[numPairs - 1];
            numPairs--;
        }
    }
}

void printBoard(int board[][BOARD_SIZE], int revealed[][BOARD_SIZE]) {
    printf("   0 1 2 3\n");
    for (int i = 0; i < BOARD_SIZE; i++) {
        printf("%d ", i);
        for (int j = 0; j < BOARD_SIZE; j++) {
            if (revealed[i][j]) {
                printf("%d ", board[i][j]);
            } else {
                printf("X ");
            }
        }
        printf("\n");
    }
}

int main(void) {
    int board[BOARD_SIZE][BOARD_SIZE];
    int revealed[BOARD_SIZE][BOARD_SIZE];
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            revealed[i][j] = 0;
        }
    }
    generateBoard(board);

    int numPairsFound = 0;
    while (numPairsFound < (BOARD_SIZE * BOARD_SIZE) / 2) {
        printBoard(board, revealed);

        int x1, y1, x2, y2;
        printf("Enter first card coordinates: ");
        scanf("%d %d", &x1, &y1);

        while (revealed[x1][y1] == 1) {
            printf("That card has already been revealed. Enter new coordinates: ");
            scanf("%d %d", &x1, &y1);
        }

        revealed[x1][y1] = 1;
        printBoard(board, revealed);

        printf("Enter second card coordinates: ");
        scanf("%d %d", &x2, &y2);

        while (revealed[x2][y2] == 1) {
            printf("That card has already been revealed. Enter new coordinates: ");
            scanf("%d %d", &x2, &y2);
        }

        revealed[x2][y2] = 1;
        printBoard(board, revealed);

        if (board[x1][y1] == board[x2][y2]) {
            printf("Pair found!\n");
            numPairsFound++;
        } else {
            printf("No pair found.\n");
            revealed[x1][y1] = 0;
            revealed[x2][y2] = 0;
        }
    }

    printf("Congratulations! You have found all pairs.\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generateBoard(_QWORD); // weak
__int64 __fastcall printBoard(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018B3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  void *v4; // rsp
  __int64 v6; // [rsp+0h] [rbp-F0h] BYREF
  char v7; // [rsp+20h] [rbp-D0h] BYREF
  __int64 *v8; // [rsp+28h] [rbp-C8h]
  __int64 v9; // [rsp+30h] [rbp-C0h]
  __int64 v10; // [rsp+38h] [rbp-B8h]
  unsigned __int64 v11; // [rsp+40h] [rbp-B0h]
  __int64 v12; // [rsp+48h] [rbp-A8h]
  __int64 v13; // [rsp+50h] [rbp-A0h]
  __int64 v14; // [rsp+58h] [rbp-98h]
  __int64 v15; // [rsp+60h] [rbp-90h]
  __int64 v16; // [rsp+68h] [rbp-88h]
  __int64 v17; // [rsp+70h] [rbp-80h]
  __int64 v18; // [rsp+78h] [rbp-78h]
  __int64 v19; // [rsp+80h] [rbp-70h]
  __int64 v20; // [rsp+88h] [rbp-68h]
  __int64 v21; // [rsp+90h] [rbp-60h]
  __int64 v22; // [rsp+98h] [rbp-58h]
  int v23; // [rsp+A0h] [rbp-50h] BYREF
  int v24; // [rsp+A4h] [rbp-4Ch] BYREF
  int v25; // [rsp+A8h] [rbp-48h] BYREF
  int v26; // [rsp+ACh] [rbp-44h] BYREF
  char *v27; // [rsp+B0h] [rbp-40h]
  __int64 v28; // [rsp+B8h] [rbp-38h]
  __int64 v29; // [rsp+C0h] [rbp-30h]
  char *v30; // [rsp+C8h] [rbp-28h]
  __int64 v31; // [rsp+D0h] [rbp-20h]
  __int64 v32; // [rsp+D8h] [rbp-18h]
  int v33; // [rsp+E4h] [rbp-Ch]
  int j; // [rsp+E8h] [rbp-8h]
  int i; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  v8 = &v6;
  v32 = 3i64;
  v12 = 0i64;
  v11 = 16i64;
  v31 = 3i64;
  v21 = 4i64;
  v22 = 0i64;
  v19 = 4i64;
  v20 = 0i64;
  v3 = alloca(64i64);
  v30 = &v7;
  v29 = 3i64;
  v9 = 4i64;
  v10 = 0i64;
  v28 = 3i64;
  v17 = 4i64;
  v18 = 0i64;
  v15 = 4i64;
  v16 = 0i64;
  v13 = 4i64;
  v14 = 0i64;
  v4 = alloca(64i64);
  v27 = &v7;
  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4; ++j )
      *(_DWORD *)&v27[16 * i + 4 * j] = 0;
  }
  generateBoard(v30);
  v33 = 0;
  while ( v33 < 8 )
  {
    printBoard(v30, v27);
    printf("Enter first card coordinates: ");
    scanf("%d %d", &v26, &v25);
    while ( *(_DWORD *)&v27[16 * v26 + 4 * v25] == 1 )
    {
      printf("That card has already been revealed. Enter new coordinates: ");
      scanf("%d %d", &v26, &v25);
    }
    *(_DWORD *)&v27[16 * v26 + 4 * v25] = 1;
    printBoard(v30, v27);
    printf("Enter second card coordinates: ");
    scanf("%d %d", &v24, &v23);
    while ( *(_DWORD *)&v27[16 * v24 + 4 * v23] == 1 )
    {
      printf("That card has already been revealed. Enter new coordinates: ");
      scanf("%d %d", &v24, &v23);
    }
    *(_DWORD *)&v27[16 * v24 + 4 * v23] = 1;
    printBoard(v30, v27);
    if ( *(_DWORD *)&v30[4 * v25 + 4 * (v11 >> 2) * v26] == *(_DWORD *)&v30[4 * v23 + 4 * (v11 >> 2) * v24] )
    {
      printf("Pair found!\n");
      ++v33;
    }
    else
    {
      printf("No pair found.\n");
      *(_DWORD *)&v27[16 * v26 + 4 * v25] = 0;
      *(_DWORD *)&v27[16 * v24 + 4 * v23] = 0;
    }
  }
  printf("Congratulations! You have found all pairs.\n");
  return 0;
}
// 140001601: using guessed type __int64 __fastcall generateBoard(_QWORD);
// 14000177C: using guessed type __int64 __fastcall printBoard(_QWORD, _QWORD);
// 140001ED0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Mailing list manager ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define structure for each node in the mailing list
typedef struct node {
    char name[50];
    char email[50];
    struct node* next;
} node;

// Function to create a new node (member) in the mailing list
node* createNode(char name[], char email[]) {
    node* newNode = (node*) malloc(sizeof(node));
    strcpy(newNode->name, name);
    strcpy(newNode->email, email);
    newNode->next = NULL;
    return newNode;
}

// Function to add a new member to the mailing list
void addMember(node** head, char name[], char email[]) {
    if (*head == NULL) {
        // If there is no member in the list yet, create a new node and point the head to it
        node* newNode = createNode(name, email);
        *head = newNode;
        return;
    }
    // If there are already members in the list, traverse through the list until the end
    node* temp = *head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    // Add the new member to the end of the list
    node* newNode = createNode(name, email);
    temp->next = newNode;
}

// Function to remove a member from the mailing list
void removeMember(node** head, char name[]) {
    node* temp = *head;
    node* prev = NULL;
    // Traverse through the list to look for the member to be removed
    while (temp != NULL && strcmp(temp->name, name) != 0) {
        prev = temp;
        temp = temp->next;
    }
    if (temp == NULL) {
        // Member not found in the list
        printf("Member not found in the mailing list.\n");
        return;
    }
    if (prev == NULL) {
        // If the member to be removed is the first member in the list, point the head to the next member
        *head = temp->next;
    } else {
        // Remove the member by bypassing it in the list
        prev->next = temp->next;
    }
    free(temp); // Free up the memory used by the removed member
}

// Function to print all members in the mailing list
void printList(node* head) {
    node* temp = head;
    printf("Mailing list:\n");
    while (temp != NULL) {
        printf("%s, %s\n", temp->name, temp->email);
        temp = temp->next;
    }
}

int main() {
    node* head = NULL; // Initialize the mailing list to be empty
    char choice, name[50], email[50];
    do {
        printf("\nEnter A to add a member, R to remove a member, P to print the mailing list, or Q to quit: ");
        scanf(" %c", &choice);
        switch(choice) {
            case 'A': // Adding a new member
            case 'a':
                printf("Enter the member's name: ");
                scanf(" %[^\n]s", name);
                printf("Enter the member's email: ");
                scanf(" %[^\n]s", email);
                addMember(&head, name, email);
                printf("New member %s added to the mailing list.\n", name);
                break;
            case 'R': // Removing a member
            case 'r':
                printf("Enter the name of the member to be removed: ");
                scanf(" %[^\n]s", name);
                removeMember(&head, name);
                break;
            case 'P': // Printing the mailing list
            case 'p':
                printList(head);
                break;
            case 'Q': // Quitting the program
            case 'q':
                printf("Exiting the mailing list manager.\n");
                break;
            default: // Wrong input
                printf("Invalid input, please try again.\n");
        }
    } while (choice != 'Q' && choice != 'q');
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addMember(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall removeMember(_QWORD, _QWORD); // weak
__int64 __fastcall printList(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017CF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[64]; // [rsp+20h] [rbp-80h] BYREF
  char v5[55]; // [rsp+60h] [rbp-40h] BYREF
  char v6; // [rsp+97h] [rbp-9h] BYREF
  __int64 v7; // [rsp+98h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v7 = 0i64;
  do
  {
    printf("\nEnter A to add a member, R to remove a member, P to print the mailing list, or Q to quit: ");
    scanf(" %c", &v6);
    switch ( v6 )
    {
      case 'A':
      case 'a':
        printf("Enter the member's name: ");
        scanf(" %[^\n]s", v5);
        printf("Enter the member's email: ");
        scanf(" %[^\n]s", v4);
        addMember(&v7, v5, v4);
        printf("New member %s added to the mailing list.\n", v5);
        break;
      case 'P':
      case 'p':
        printList(v7);
        break;
      case 'Q':
      case 'q':
        printf("Exiting the mailing list manager.\n");
        break;
      case 'R':
      case 'r':
        printf("Enter the name of the member to be removed: ");
        scanf(" %[^\n]s", v5);
        removeMember(&v7, v5);
        break;
      default:
        printf("Invalid input, please try again.\n");
        break;
    }
  }
  while ( v6 != 81 && v6 != 113 );
  return 0;
}
// 14000163A: using guessed type __int64 __fastcall addMember(_QWORD, _QWORD, _QWORD);
// 1400016C7: using guessed type __int64 __fastcall removeMember(_QWORD, _QWORD);
// 14000176E: using guessed type __int64 __fastcall printList(_QWORD);
// 140001A00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Log analysis ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    printf("\n\n ********** Cyberpunk Style C Log Analysis ********** \n\n");

    FILE *log_file;
    char log_line[100];
    char *log_file_name = "cyber.log";
    int line_count = 0;
    int error_count = 0;
    char error_message[100];

    log_file = fopen(log_file_name, "r");

    if (log_file == NULL) {
        printf("Error opening log file\n");
        exit(0);
    }

    printf("Analyzing log file...\n\n");

    while (fgets(log_line, 100, log_file)) {
        line_count++;

        if (strstr(log_line, "ERROR") != NULL) {
            error_count++;
            strcpy(error_message, log_line);
            printf("ALERT: Error detected on line %d - %s", line_count, error_message);
        }
    }

    if (error_count == 0) {
        printf("No errors detected in log file\n");
    }

    printf("\n\n ********** End of Log Analysis **********\n\n");
    fclose(log_file);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// char *__cdecl strcpy(char *Destination, const char *Source);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Destination[112]; // [rsp+20h] [rbp-60h] BYREF
  char Str[104]; // [rsp+90h] [rbp+10h] BYREF
  FILE *Stream; // [rsp+F8h] [rbp+78h]
  char *FileName; // [rsp+100h] [rbp+80h]
  int v8; // [rsp+108h] [rbp+88h]
  unsigned int v9; // [rsp+10Ch] [rbp+8Ch]

  _main(argc, argv, envp);
  printf("\n\n ********** Cyberpunk Style C Log Analysis ********** \n\n");
  FileName = "cyber.log";
  v9 = 0;
  v8 = 0;
  Stream = fopen("cyber.log", "r");
  if ( !Stream )
  {
    printf("Error opening log file\n");
    exit(0);
  }
  printf("Analyzing log file...\n\n");
  while ( fgets(Str, 100, Stream) )
  {
    ++v9;
    if ( strstr(Str, "ERROR") )
    {
      ++v8;
      strcpy(Destination, Str);
      printf("ALERT: Error detected on line %d - %s", v9, Destination);
    }
  }
  if ( !v8 )
    printf("No errors detected in log file\n");
  printf("\n\n ********** End of Log Analysis **********\n\n");
  fclose(Stream);
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Music Library Management System ; Style: thoughtful
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct Song{
    char name[100];
    char artist[100];
    char album[100];
    int year;
};

void add_song(struct Song* songs, int* count){
    printf("Enter Song Name: ");
    scanf("%s", songs[*count].name);

    printf("Enter Artist Name: ");
    scanf("%s", songs[*count].artist);

    printf("Enter Album Name: ");
    scanf("%s", songs[*count].album);

    printf("Enter Release Year: ");
    scanf("%d", &songs[*count].year);

    printf("\nSong added successfully!\n");
    (*count)++;
}

void display_all_songs(struct Song* songs, int count){
    printf("All Songs\n");
    for(int i=0; i<count; i++){
        printf("%d. %s - %s [%s] (%d)\n", i+1, songs[i].name, songs[i].artist, songs[i].album, songs[i].year);
    }
}

void search_by_name(struct Song* songs, int count){
    char name[100];
    printf("Enter Name to Search: ");
    scanf("%s", name);
    
    for(int i=0; i<count; i++){
        if(strcmp(songs[i].name, name)==0){
            printf("%s - %s [%s] (%d)\n", songs[i].name, songs[i].artist, songs[i].album, songs[i].year);
        }
    }
}

void search_by_artist(struct Song* songs, int count){
    char artist[100];
    printf("Enter Artist Name to Search: ");
    scanf("%s", artist);

    for(int i=0; i<count; i++){
        if(strcmp(songs[i].artist, artist)==0){
            printf("%s - %s [%s] (%d)\n", songs[i].name, songs[i].artist, songs[i].album, songs[i].year);
        }
    }
}

int main(){
    int count = 0;  // initial count of songs
    int choice;

    printf("C Music Library Management System\n");

    struct Song songs[100];

    while(1){
        printf("\n---MENU---\n");
        printf("1. Add Song\n");
        printf("2. Display All Songs\n");
        printf("3. Search by Name\n");
        printf("4. Search by Artist\n");
        printf("5. Exit\n");
        printf("Enter Choice (1-5): ");
        scanf("%d", &choice);

        switch(choice){
            case 1:
                add_song(songs, &count);
                break;

            case 2:
                display_all_songs(songs, count);
                break;
            
            case 3:
                search_by_name(songs, count);
                break;

            case 4:
                search_by_artist(songs, count);
                break;

            case 5:
                printf("\nExiting C Music Library Management System\n");
                exit(0);

            default:
                printf("\nInvalid Choice! Please enter choice between 1 to 5.\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_song(_QWORD, _QWORD); // weak
__int64 __fastcall display_all_songs(_QWORD, _QWORD); // weak
__int64 __fastcall search_by_name(_QWORD, _QWORD); // weak
__int64 __fastcall search_by_artist(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001AF1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[30408]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+76E8h] [rbp+7668h] BYREF
  unsigned int v6; // [rsp+76ECh] [rbp+766Ch] BYREF

  _main(argc, argv, envp);
  v6 = 0;
  printf("C Music Library Management System\n");
  while ( 1 )
  {
    printf("\n---MENU---\n");
    printf("1. Add Song\n");
    printf("2. Display All Songs\n");
    printf("3. Search by Name\n");
    printf("4. Search by Artist\n");
    printf("5. Exit\n");
    printf("Enter Choice (1-5): ");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        add_song(v4, &v6);
        break;
      case 2:
        display_all_songs(v4, v6);
        break;
      case 3:
        search_by_name(v4, v6);
        break;
      case 4:
        search_by_artist(v4, v6);
        break;
      case 5:
        printf("\nExiting C Music Library Management System\n");
        exit(0);
      default:
        printf("\nInvalid Choice! Please enter choice between 1 to 5.\n");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 __fastcall add_song(_QWORD, _QWORD);
// 140001747: using guessed type __int64 __fastcall display_all_songs(_QWORD, _QWORD);
// 140001850: using guessed type __int64 __fastcall search_by_name(_QWORD, _QWORD);
// 1400019A0: using guessed type __int64 __fastcall search_by_artist(_QWORD, _QWORD);
// 140001D10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Phone Book ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Contact {
    char name[50];
    char phone[20];
    char email[50];
    char address[100];
};

void addContact(struct Contact contact);
void displayContacts();
void searchContacts(char name[]);
void removeContact(char name[]);
void modifyContact(char name[]);

int main() {
    int choice;
    struct Contact contact;

    while (1) {
        printf("\n1. Add Contact\n2. Display Contacts\n3. Search Contacts\n4. Remove Contact\n5. Modify Contact\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("\nEnter the contact details: ");
                printf("\nEnter name: "); scanf("%s", &contact.name);
                printf("\nEnter phone: "); scanf("%s", &contact.phone);
                printf("\nEnter email: "); scanf("%s", &contact.email);
                printf("\nEnter address: "); scanf("%s", &contact.address);
                addContact(contact);
                break;
            case 2:
                displayContacts();
                break;
            case 3:
                char name[50];
                printf("Enter contact name to search: ");
                scanf("%s", name);
                searchContacts(name);
                break;
            case 4:
                char name_remove[50];
                printf("Enter contact name to delete: ");
                scanf("%s", name_remove);
                removeContact(name_remove);
                break;
            case 5:
                char name_modify[50];
                printf("Enter contact name to modify: ");
                scanf("%s", name_modify);
                modifyContact(name_modify);
                break;
            case 6:
                exit(0);
            default:
                printf("\nInvalid choice. Please try again.\n");
                break;
        }
    }

    return 0;
}

void addContact(struct Contact contact) {
    FILE *fptr;
    fptr = fopen("contacts.txt", "a");
    fprintf(fptr, "%s, %s, %s, %s\n", contact.name, contact.phone, contact.email, contact.address);
    fclose(fptr);
    printf("\nContact added successfully.\n");
}

void displayContacts() {
    struct Contact contact;
    FILE *fptr;
    fptr = fopen("contacts.txt", "r");
    while (fscanf(fptr, "%[^,], %[^,], %[^,], %[^\n]\n", contact.name, contact.phone, contact.email, contact.address) != EOF) {
        printf("\nName: %s\nPhone: %s\nEmail: %s\nAddress: %s\n", contact.name, contact.phone, contact.email, contact.address);
    }
    fclose(fptr);
}

void searchContacts(char name[]) {
    struct Contact contact;
    FILE *fptr;
    fptr = fopen("contacts.txt", "r");
    int found = 0;
    while (fscanf(fptr, "%[^,], %[^,], %[^,], %[^\n]\n", contact.name, contact.phone, contact.email, contact.address) != EOF) {
        if (strcmp(contact.name, name) == 0) {
            found = 1;
            printf("\nName: %s\nPhone: %s\nEmail: %s\nAddress: %s\n", contact.name, contact.phone, contact.email, contact.address);
            break;
        }
    }
    fclose(fptr);
    if (!found) {
        printf("\nContact not found.\n");
    }
}

void removeContact(char name[]) {
    struct Contact contact;
    FILE *fptr1, *fptr2;
    fptr1 = fopen("contacts.txt", "r");
    fptr2 = fopen("temp.txt", "w");
    int found = 0;
    while (fscanf(fptr1, "%[^,], %[^,], %[^,], %[^\n]\n", contact.name, contact.phone, contact.email, contact.address) != EOF) {
        if (strcmp(contact.name, name) != 0) {
            fprintf(fptr2, "%s, %s, %s, %s\n", contact.name, contact.phone, contact.email, contact.address);
        } else {
            found = 1;
        }
    }
    fclose(fptr1);
    fclose(fptr2);
    remove("contacts.txt");
    rename("temp.txt", "contacts.txt");
    if (found) {
        printf("\nContact removed successfully.\n");
    } else {
        printf("\nContact not found.\n");
    }
}

void modifyContact(char name[]) {
    struct Contact contact;
    FILE *fptr1, *fptr2;
    fptr1 = fopen("contacts.txt", "r");
    fptr2 = fopen("temp.txt", "w");
    int found = 0;
    while (fscanf(fptr1, "%[^,], %[^,], %[^,], %[^\n]\n", contact.name, contact.phone, contact.email, contact.address) != EOF) {
        if (strcmp(contact.name, name) != 0) {
            fprintf(fptr2, "%s, %s, %s, %s\n", contact.name, contact.phone, contact.email, contact.address);
        } else {
            found = 1;
            printf("\nEnter new contact details: ");
            printf("\nEnter phone: "); scanf("%s", &contact.phone);
            printf("\nEnter email: "); scanf("%s", &contact.email);
            printf("\nEnter address: "); scanf("%s", &contact.address);
            fprintf(fptr2, "%s, %s, %s, %s\n", contact.name, contact.phone, contact.email, contact.address);
        }
    }
    fclose(fptr1);
    fclose(fptr2);
    remove("contacts.txt");
    rename("temp.txt", "contacts.txt");
    if (found) {
        printf("\nContact modified successfully.\n");
    } else {
        printf("\nContact not found.\n");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall addContact(_QWORD); // weak
__int64 displayContacts(void); // weak
__int64 __fastcall searchContacts(_QWORD); // weak
__int64 __fastcall removeContact(_QWORD); // weak
__int64 __fastcall modifyContact(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001668) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[27]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+F8h] [rbp+78h]
  char v6[64]; // [rsp+100h] [rbp+80h] BYREF
  __int64 v7[6]; // [rsp+140h] [rbp+C0h] BYREF
  __int64 v8[2]; // [rsp+170h] [rbp+F0h] BYREF
  __int64 v9[7]; // [rsp+180h] [rbp+100h] BYREF
  __int64 v10[12]; // [rsp+1B8h] [rbp+138h] BYREF
  int v11; // [rsp+218h] [rbp+198h]
  int v12; // [rsp+21Ch] [rbp+19Ch] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    printf("\n1. Add Contact\n2. Display Contacts\n3. Search Contacts\n4. Remove Contact\n5. Modify Contact\n6. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v12);
    switch ( v12 )
    {
      case 1:
        printf("\nEnter the contact details: ");
        printf("\nEnter name: ");
        scanf("%s", v7);
        printf("\nEnter phone: ");
        scanf("%s", (char *)v8 + 2);
        printf("\nEnter email: ");
        scanf("%s", (char *)v9 + 6);
        printf("\nEnter address: ");
        scanf("%s", v10);
        v4[0] = v7[0];
        v4[1] = v7[1];
        v4[2] = v7[2];
        v4[3] = v7[3];
        v4[4] = v7[4];
        v4[5] = v7[5];
        v4[6] = v8[0];
        v4[7] = v8[1];
        v4[8] = v9[0];
        v4[9] = v9[1];
        v4[10] = v9[2];
        v4[11] = v9[3];
        v4[12] = v9[4];
        v4[13] = v9[5];
        v4[14] = v9[6];
        v4[15] = v10[0];
        v4[16] = v10[1];
        v4[17] = v10[2];
        v4[18] = v10[3];
        v4[19] = v10[4];
        v4[20] = v10[5];
        v4[21] = v10[6];
        v4[22] = v10[7];
        v4[23] = v10[8];
        v4[24] = v10[9];
        v4[25] = v10[10];
        v4[26] = v10[11];
        v5 = v11;
        addContact(v4);
        break;
      case 2:
        displayContacts();
        break;
      case 3:
        printf("Enter contact name to search: ");
        scanf("%s", v6);
        searchContacts(v6);
        break;
      case 4:
        printf("Enter contact name to delete: ");
        scanf("%s", v6);
        removeContact(v6);
        break;
      case 5:
        printf("Enter contact name to modify: ");
        scanf("%s", v6);
        modifyContact(v6);
        break;
      case 6:
        exit(0);
      default:
        printf("\nInvalid choice. Please try again.\n");
        break;
    }
  }
}
// 1400019BA: using guessed type __int64 __fastcall addContact(_QWORD);
// 140001A37: using guessed type __int64 displayContacts(void);
// 140001B02: using guessed type __int64 __fastcall searchContacts(_QWORD);
// 140001C1D: using guessed type __int64 __fastcall removeContact(_QWORD);
// 140001DA9: using guessed type __int64 __fastcall modifyContact(_QWORD);
// 1400020C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: introspective
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main() {
  int counter;
  float speed;
  clock_t start_t, end_t; // variables to store clock ticks
  double total_t; // variables to store total time

  printf("Welcome to the Internet Speed Test Application!\n");

  // run the test 3 times and output average
  for (counter = 1; counter <= 3; counter++) {
    printf("\nTest #%d:\n", counter);

    // get start time
    start_t = clock();

    // simulate downloading a 100MB file
    for (int i = 0; i < 100000000; i++);

    // get end time
    end_t = clock();

    // calculate total time and convert to seconds
    total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;

    printf("Download speed was %.2f MB/s\n", 100 / total_t);
    speed += 100 / total_t;
  }
  
  printf("\n\nAverage speed: %.2f MB/s\n\n", speed/3);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// clock_t __cdecl clock();


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  double v5; // [rsp+20h] [rbp-20h]
  clock_t v6; // [rsp+30h] [rbp-10h]
  int j; // [rsp+34h] [rbp-Ch]
  float v8; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Internet Speed Test Application!\n");
  for ( i = 1; i <= 3; ++i )
  {
    printf("\nTest #%d:\n", (unsigned int)i);
    v6 = clock();
    for ( j = 0; j <= 99999999; ++j )
      ;
    v5 = (double)(clock() - v6) / 1000.0;
    printf("Download speed was %.2f MB/s\n", 100.0 / v5);
    v3 = 100.0 / v5 + v8;
    v8 = v3;
  }
  printf("\n\nAverage speed: %.2f MB/s\n\n", (float)(v8 / 3.0));
  return 0;
}
// 140001646: variable 'v8' is possibly undefined
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: grateful
#include <stdio.h>
#include <stdlib.h>

int main() {

  printf("Welcome to my unique C Memory management program!\n");

  // Allocating memory for an array of integers with the help of malloc() function
  int *ptr;
  ptr = (int*)malloc(5*sizeof(int)); // Allocating memory for 5 integers

  if(ptr == NULL) {
    printf("Memory allocation failed. Exiting the program...\n");
    exit(0);
  }

  printf("Memory allocation for 5 integers successful. Enter the values of the array:\n");

  // Taking user input to fill the array with values
  for(int i=0; i<5; i++) {
    scanf("%d", &ptr[i]);
  }

  // Displaying the elements of the array
  printf("Array elements entered by the user:\n");
  for(int i=0; i<5; i++) {
    printf("%d\n", ptr[i]);
  }

  // Reallocating memory for the array with the help of realloc() function
  int *ptr_new;
  ptr_new = (int*)realloc(ptr, 10*sizeof(int)); // Resizing the array to fit 10 integers

  if(ptr_new == NULL) {
    printf("Memory reallocation failed. Exiting the program...\n");
    free(ptr); // Freeing up the previously allocated memory before exiting
    exit(0);
  }

  printf("Memory reallocation for 5 more integers successful. Enter the values of the expanded array:\n");

  // Taking user input to fill the expanded array with values
  for(int i=5; i<10; i++) {
    scanf("%d", &ptr_new[i]);
  }

  // Displaying the elements of the expanded array
  printf("Expanded array elements entered by the user:\n");
  for(int i=0; i<10; i++) {
    printf("%d\n", ptr_new[i]);
  }

  // Freeing up the allocated memory before exiting the program
  free(ptr_new);
  printf("Memory has been freed up successfully. Exiting the program...\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v4; // [rsp+20h] [rbp-20h]
  char *Block; // [rsp+28h] [rbp-18h]
  int m; // [rsp+30h] [rbp-10h]
  int k; // [rsp+34h] [rbp-Ch]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to my unique C Memory management program!\n");
  Block = (char *)malloc(0x14ui64);
  if ( !Block )
  {
    printf("Memory allocation failed. Exiting the program...\n");
    exit(0);
  }
  printf("Memory allocation for 5 integers successful. Enter the values of the array:\n");
  for ( i = 0; i <= 4; ++i )
    scanf("%d", &Block[4 * i]);
  printf("Array elements entered by the user:\n");
  for ( j = 0; j <= 4; ++j )
    printf("%d\n", *(unsigned int *)&Block[4 * j]);
  v4 = (char *)realloc(Block, 0x28ui64);
  if ( !v4 )
  {
    printf("Memory reallocation failed. Exiting the program...\n");
    free(Block);
    exit(0);
  }
  printf("Memory reallocation for 5 more integers successful. Enter the values of the expanded array:\n");
  for ( k = 5; k <= 9; ++k )
    scanf("%d", &v4[4 * k]);
  printf("Expanded array elements entered by the user:\n");
  for ( m = 0; m <= 9; ++m )
    printf("%d\n", *(unsigned int *)&v4[4 * m]);
  free(v4);
  printf("Memory has been freed up successfully. Exiting the program...\n");
  return 0;
}
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Browser Plugin ; Style: innovative
#include <stdio.h>

// Define the function prototypes
void incrementCounter();
void displayCounter();

// Global variable to track counter
int counter = 0;

// Implementation of incrementCounter function
void incrementCounter() {
    counter++;
}

// Implementation of displayCounter function
void displayCounter() {
    printf("The current counter value is: %d\n", counter);
}

int main() {
    int choice;
    // Display the options to the user
    printf("Choose an option:\n");
    printf("1. Increment counter\n");
    printf("2. Display counter\n");
    printf("3. Exit\n");

    while (1) {
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                // Call incrementCounter function to increment the counter variable
                incrementCounter();
                printf("Counter incremented!\n");
                break;

            case 2:
                // Call displayCounter function to display the current counter value
                displayCounter();
                break;

            case 3:
                // Exit the program
                printf("Exiting program...\n");
                return 0;

            default:
                printf("Invalid choice! Please try again.\n");
                break;
        }

        // Display the options again
        printf("\nChoose an option:\n");
        printf("1. Increment counter\n");
        printf("2. Display counter\n");
        printf("3. Exit\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 incrementCounter(void); // weak
__int64 displayCounter(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000161E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Choose an option:\n");
  printf("1. Increment counter\n");
  printf("2. Display counter\n");
  printf("3. Exit\n");
  while ( 1 )
  {
    scanf("%d", &v4);
    if ( v4 == 3 )
      break;
    if ( v4 > 3 )
      goto LABEL_10;
    if ( v4 == 1 )
    {
      incrementCounter();
      printf("Counter incremented!\n");
      goto LABEL_11;
    }
    if ( v4 == 2 )
      displayCounter();
    else
LABEL_10:
      printf("Invalid choice! Please try again.\n");
LABEL_11:
    printf("\nChoose an option:\n");
    printf("1. Increment counter\n");
    printf("2. Display counter\n");
    printf("3. Exit\n");
  }
  printf("Exiting program...\n");
  return 0;
}
// 1400015E2: using guessed type __int64 incrementCounter(void);
// 1400015F8: using guessed type __int64 displayCounter(void);
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Movie Rating System ; Style: irregular
#include <stdio.h>

int main() {
  int rating;
  
  printf("Welcome to the Unique C Movie Rating System!\n");
  printf("Please enter your rating (1-10): ");
  scanf("%d", &rating);

  if (rating < 1 || rating > 10) {
    printf("Invalid rating, please enter a number between 1 and 10.\n");
  } else {
    printf("Thank you for rating the movie %d out of 10!\n", rating);
    
    if (rating == 1) {
      printf("Yikes, that's a terrible rating. We're sorry you didn't enjoy the movie.\n");
    } else if (rating > 1 && rating < 5) {
      printf("It sounds like this movie wasn't for you. Thanks for giving it a chance.\n");
    } else if (rating >= 5 && rating < 8) {
      printf("Glad to hear it was enjoyable! Any suggestions on how we can improve?\n");
    } else if (rating >= 8 && rating < 10) {
      printf("Wow, thanks for the high rating! We're thrilled to hear you enjoyed the movie.\n");
    } else if (rating == 10) {
      printf("Congratulations, you've given the movie a perfect rating! This is a huge accomplishment.\n");
    }
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Unique C Movie Rating System!\n");
  printf("Please enter your rating (1-10): ");
  scanf("%d", &v4);
  if ( v4 > 0 && v4 <= 10 )
  {
    printf("Thank you for rating the movie %d out of 10!\n", (unsigned int)v4);
    if ( v4 == 1 )
    {
      printf("Yikes, that's a terrible rating. We're sorry you didn't enjoy the movie.\n");
    }
    else if ( v4 <= 1 || v4 > 4 )
    {
      if ( v4 <= 4 || v4 > 7 )
      {
        if ( v4 <= 7 || v4 > 9 )
        {
          if ( v4 == 10 )
            printf("Congratulations, you've given the movie a perfect rating! This is a huge accomplishment.\n");
        }
        else
        {
          printf("Wow, thanks for the high rating! We're thrilled to hear you enjoyed the movie.\n");
        }
      }
      else
      {
        printf("Glad to hear it was enjoyable! Any suggestions on how we can improve?\n");
      }
    }
    else
    {
      printf("It sounds like this movie wasn't for you. Thanks for giving it a chance.\n");
    }
  }
  else
  {
    printf("Invalid rating, please enter a number between 1 and 10.\n");
  }
  return 0;
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Resume Parsing System ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct resume {
    char name[50];
    char email[50];
    char skillset1[20];
    char skillset2[20];
    char skillset3[20];
    char education[30];
    char experience[100];
};

int main() {
    struct resume employee;
    char input[500];
    char *token;

    printf("Enter employee details in the following format:\n{Name},{Email},{Skillset 1},{Skillset 2},{Skillset 3},{Education},{Experience}\n");
    fgets(input, 500, stdin);

    token = strtok(input, ",");
    strcpy(employee.name, token);

    token = strtok(NULL, ",");
    strcpy(employee.email, token);

    token = strtok(NULL, ",");
    strcpy(employee.skillset1, token);

    token = strtok(NULL, ",");
    strcpy(employee.skillset2, token);

    token = strtok(NULL, ",");
    strcpy(employee.skillset3, token);

    token = strtok(NULL, ",");
    strcpy(employee.education, token);

    token = strtok(NULL, ",");
    strcpy(employee.experience, token);

    printf("\nEmployee details: \n");
    printf("Name: %s\n", employee.name);
    printf("Email: %s\n", employee.email);
    printf("Skillset 1: %s\n", employee.skillset1);
    printf("Skillset 2: %s\n", employee.skillset2);
    printf("Skillset 3: %s\n", employee.skillset3);
    printf("Education: %s\n", employee.education);
    printf("Experience: %s\n", employee.experience);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[512]; // [rsp+20h] [rbp-60h] BYREF
  char Destination[50]; // [rsp+220h] [rbp+1A0h] BYREF
  char v7[50]; // [rsp+252h] [rbp+1D2h] BYREF
  char v8[20]; // [rsp+284h] [rbp+204h] BYREF
  char v9[20]; // [rsp+298h] [rbp+218h] BYREF
  char v10[20]; // [rsp+2ACh] [rbp+22Ch] BYREF
  char v11[30]; // [rsp+2C0h] [rbp+240h] BYREF
  char v12[106]; // [rsp+2DEh] [rbp+25Eh] BYREF
  char *Source; // [rsp+348h] [rbp+2C8h]

  _main(argc, argv, envp);
  printf(
    "Enter employee details in the following format:\n"
    "{Name},{Email},{Skillset 1},{Skillset 2},{Skillset 3},{Education},{Experience}\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 500, v3);
  Source = strtok(Buffer, ",");
  strcpy(Destination, Source);
  Source = strtok(0i64, ",");
  strcpy(v7, Source);
  Source = strtok(0i64, ",");
  strcpy(v8, Source);
  Source = strtok(0i64, ",");
  strcpy(v9, Source);
  Source = strtok(0i64, ",");
  strcpy(v10, Source);
  Source = strtok(0i64, ",");
  strcpy(v11, Source);
  Source = strtok(0i64, ",");
  strcpy(v12, Source);
  printf("\nEmployee details: \n");
  printf("Name: %s\n", Destination);
  printf("Email: %s\n", v7);
  printf("Skillset 1: %s\n", v8);
  printf("Skillset 2: %s\n", v9);
  printf("Skillset 3: %s\n", v10);
  printf("Education: %s\n", v11);
  printf("Experience: %s\n", v12);
  return 0;
}
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific ; Style: minimalist
#include <stdio.h>

int main() {
   int num1, num2, result;
   
   printf("Enter first number: ");
   scanf("%d", &num1);

   printf("Enter second number: ");
   scanf("%d", &num2);
   
   result = gcd(num1, num2);
   
   printf("GCD of %d and %d is %d.\n", num1, num2, result);
   
   return 0;
}

int gcd(int x, int y) {
   int r;
   
   while (y != 0) {
      r = x % y;
      x = y;
      y = r;
   }
   
   return x;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall gcd(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int v5; // [rsp+28h] [rbp-8h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter first number: ");
  scanf("%d", &v5);
  printf("Enter second number: ");
  scanf("%d", &v4);
  v6 = gcd(v5, v4);
  printf("GCD of %d and %d is %d.\n", v5, v4, v6);
  return 0;
}
// 140001674: using guessed type __int64 __fastcall gcd(_QWORD, _QWORD);
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Matrix operations ; Style: minimalist
#include <stdio.h>

void printMatrix(int rows, int cols, int mat[rows][cols]) {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      printf("%d ", mat[i][j]);
    }
    printf("\n");
  }
}

void addMatrices(int rows, int cols, int mat1[rows][cols], int mat2[rows][cols], int result[rows][cols]) {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      result[i][j] = mat1[i][j] + mat2[i][j];
    }
  }
}

void scalarMult(int rows, int cols, int mat[rows][cols], int scalar) {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      mat[i][j] *= scalar;
    }
  }
}

void transpose(int rows, int cols, int mat[rows][cols], int result[cols][rows]) {
  for (int i = 0; i < cols; i++) {
    for (int j = 0; j < rows; j++) {
      result[i][j] = mat[j][i];
    }
  }
}

int main() {
  int mat1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
  int mat2[3][3] = {{9, 8, 7}, {6, 5, 4}, {3, 2, 1}};
  int sumMat[3][3] = {0};
  int scalar = 2;
  int transMat[3][3] = {0};

  printf("Matrix 1:\n");
  printMatrix(3, 3, mat1);

  printf("\nMatrix 2:\n");
  printMatrix(3, 3, mat2);

  printf("\nSum of matrices:\n");
  addMatrices(3, 3, mat1, mat2, sumMat);
  printMatrix(3, 3, sumMat);

  printf("\nScalar multiplication of matrix 1:\n");
  scalarMult(3, 3, mat1, scalar);
  printMatrix(3, 3, mat1);

  printf("\nTranspose of matrix 2:\n");
  transpose(3, 3, mat2, transMat);
  printMatrix(3, 3, transMat);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printMatrix(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall addMatrices(_DWORD, _DWORD, _DWORD, _DWORD, __int64); // weak
__int64 __fastcall scalarMult(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall transpose(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018E4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[4]; // [rsp+30h] [rbp-C0h] BYREF
  int v5; // [rsp+50h] [rbp-A0h]
  __int64 v6[4]; // [rsp+60h] [rbp-90h] BYREF
  int v7; // [rsp+80h] [rbp-70h]
  int v8[12]; // [rsp+90h] [rbp-60h] BYREF
  int v9[11]; // [rsp+C0h] [rbp-30h] BYREF
  unsigned int v10; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  v9[0] = 1;
  v9[1] = 2;
  v9[2] = 3;
  v9[3] = 4;
  v9[4] = 5;
  v9[5] = 6;
  v9[6] = 7;
  v9[7] = 8;
  v9[8] = 9;
  v8[0] = 9;
  v8[1] = 8;
  v8[2] = 7;
  v8[3] = 6;
  v8[4] = 5;
  v8[5] = 4;
  v8[6] = 3;
  v8[7] = 2;
  v8[8] = 1;
  memset(v6, 0, sizeof(v6));
  v7 = 0;
  v10 = 2;
  memset(v4, 0, sizeof(v4));
  v5 = 0;
  printf("Matrix 1:\n");
  printMatrix(3i64, 3i64, v9);
  printf("\nMatrix 2:\n");
  printMatrix(3i64, 3i64, v8);
  printf("\nSum of matrices:\n");
  addMatrices(3, 3, (unsigned int)v9, (unsigned int)v8, (__int64)v6);
  printMatrix(3i64, 3i64, v6);
  printf("\nScalar multiplication of matrix 1:\n");
  scalarMult(3i64, 3i64, v9, v10);
  printMatrix(3i64, 3i64, v9);
  printf("\nTranspose of matrix 2:\n");
  transpose(3i64, 3i64, v8, v4);
  printMatrix(3i64, 3i64, v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printMatrix(_QWORD, _QWORD, _QWORD);
// 140001637: using guessed type __int64 __fastcall addMatrices(_DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 140001764: using guessed type __int64 __fastcall scalarMult(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001817: using guessed type __int64 __fastcall transpose(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001BC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct WarehouseItem {
    int ID;
    char itemName[50];
    int quantity;
    float price;
};

struct Warehouse {
    struct WarehouseItem* items;
    int capacity;
    int itemCount;
};

void initWarehouse(struct Warehouse* warehouse) {
    warehouse->capacity = 10;
    warehouse->itemCount = 0;
    warehouse->items = (struct WarehouseItem*)malloc(warehouse->capacity * sizeof(struct WarehouseItem));
}

void addItem(struct Warehouse* warehouse, struct WarehouseItem item) {
    if (warehouse->itemCount >= warehouse->capacity) {
        warehouse->capacity *= 2;
        warehouse->items = (struct WarehouseItem*)realloc(warehouse->items, warehouse->capacity * sizeof(struct WarehouseItem));
    }
    warehouse->items[warehouse->itemCount] = item;
    warehouse->itemCount++;
}

void removeItem(struct Warehouse* warehouse, int id) {
    int index = -1;
    for (int i = 0; i < warehouse->itemCount; i++) {
        if (warehouse->items[i].ID == id) {
            index = i;
            break;
        }
    }

    if (index == -1) {
        printf("Item with ID %d not found in warehouse.\n", id);
        return;
    }

    for (int i = index; i < warehouse->itemCount - 1; i++) {
        warehouse->items[i] = warehouse->items[i + 1];
    }
    warehouse->itemCount--;
}

void displayWarehouse(struct Warehouse* warehouse) {
    printf("Warehouse inventory:\n");
    for (int i = 0; i < warehouse->itemCount; i++) {
        struct WarehouseItem item = warehouse->items[i];
        printf("Item ID: %d | Item Name: %s | Quantity: %d | Price: $%.2f\n", item.ID, item.itemName, item.quantity, item.price);
    }
}

int main() {
    struct Warehouse warehouse;
    initWarehouse(&warehouse);

    struct WarehouseItem item1 = { 1, "Shoes", 20, 49.99 };
    addItem(&warehouse, item1);
    struct WarehouseItem item2 = { 2, "Bags", 15, 29.99 };
    addItem(&warehouse, item2);
    struct WarehouseItem item3 = { 3, "Hats", 30, 9.99 };
    addItem(&warehouse, item3);

    removeItem(&warehouse, 4);
    removeItem(&warehouse, 2);

    displayWarehouse(&warehouse);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall initWarehouse(_QWORD); // weak
__int64 __fastcall addItem(_QWORD, _QWORD); // weak
__int64 __fastcall removeItem(_QWORD, _QWORD); // weak
__int64 __fastcall displayWarehouse(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001886) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-60h] BYREF
  __int128 v5; // [rsp+28h] [rbp-58h]
  __int128 v6; // [rsp+38h] [rbp-48h]
  __int128 v7; // [rsp+48h] [rbp-38h]
  __int64 v8; // [rsp+58h] [rbp-28h]
  _BYTE v9[56]; // [rsp+60h] [rbp-20h] BYREF
  __int64 v10; // [rsp+98h] [rbp+18h]
  _BYTE v11[56]; // [rsp+A0h] [rbp+20h] BYREF
  __int64 v12; // [rsp+D8h] [rbp+58h]
  _BYTE v13[56]; // [rsp+E0h] [rbp+60h] BYREF
  __int64 v14; // [rsp+118h] [rbp+98h]
  char v15[16]; // [rsp+120h] [rbp+A0h] BYREF

  _main(argc, argv, envp);
  initWarehouse(v15);
  *(_DWORD *)v13 = 1;
  *(_OWORD *)&v13[4] = 0x73656F6853ui64;
  memset(&v13[20], 0, 34);
  v14 = 0x4247F5C300000014i64;
  v4 = *(_QWORD *)v13;
  v5 = *(_OWORD *)&v13[8];
  v6 = *(_OWORD *)&v13[24];
  v7 = *(_OWORD *)&v13[40];
  v8 = 0x4247F5C300000014i64;
  addItem(v15, &v4);
  *(_DWORD *)v11 = 2;
  *(_OWORD *)&v11[4] = 0x73676142ui64;
  memset(&v11[20], 0, 34);
  v12 = 0x41EFEB850000000Fi64;
  v4 = *(_QWORD *)v11;
  v5 = *(_OWORD *)&v11[8];
  v6 = *(_OWORD *)&v11[24];
  v7 = *(_OWORD *)&v11[40];
  v8 = 0x41EFEB850000000Fi64;
  addItem(v15, &v4);
  *(_DWORD *)v9 = 3;
  *(_OWORD *)&v9[4] = 0x73746148ui64;
  memset(&v9[20], 0, 34);
  v10 = 0x411FD70A0000001Ei64;
  v4 = *(_QWORD *)v9;
  v5 = *(_OWORD *)&v9[8];
  v6 = *(_OWORD *)&v9[24];
  v7 = *(_OWORD *)&v9[40];
  v8 = 0x411FD70A0000001Ei64;
  addItem(v15, &v4);
  removeItem(v15, 4i64);
  removeItem(v15, 2i64);
  displayWarehouse(v15);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall initWarehouse(_QWORD);
// 1400015D9: using guessed type __int64 __fastcall addItem(_QWORD, _QWORD);
// 1400016A2: using guessed type __int64 __fastcall removeItem(_QWORD, _QWORD);
// 1400017B0: using guessed type __int64 __fastcall displayWarehouse(_QWORD);
// 140001BB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: inquisitive
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int pushups = 0;
    int squats = 0;
    int crunches = 0;
    float distance = 0.0;
    int choice = 0;

    printf("Welcome to Fitness Tracker\n");

    do {
        printf("\nSelect an option:\n");
        printf("1. Add Pushups\n");
        printf("2. Add Squats\n");
        printf("3. Add Crunches\n");
        printf("4. Add Distance\n");
        printf("5. View Stats\n");
        printf("6. Exit\n");

        scanf("%d", &choice);

        switch (choice) {
            case 1:
                pushups++;
                break;
            case 2:
                squats++;
                break;
            case 3:
                crunches++;
                break;
            case 4:
                printf("Enter Distance(miles): ");
                scanf("%f", &distance);
                break;
            case 5:
                printf("\nFitness Stats:\n");
                printf("Pushups: %d\n", pushups);
                printf("Squats: %d\n", squats);
                printf("Crunches: %d\n", crunches);
                printf("Distance: %f miles\n", distance);
                break;
            case 6:
                printf("Thank you for using Fitness Tracker!");
                break;
            default:
                printf("Invalid Choice!");
        }

    } while (choice != 6);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-14h] BYREF
  float v5; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v6; // [rsp+34h] [rbp-Ch]
  unsigned int v7; // [rsp+38h] [rbp-8h]
  unsigned int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0.0;
  v4 = 0;
  printf("Welcome to Fitness Tracker\n");
  do
  {
    printf("\nSelect an option:\n");
    printf("1. Add Pushups\n");
    printf("2. Add Squats\n");
    printf("3. Add Crunches\n");
    printf("4. Add Distance\n");
    printf("5. View Stats\n");
    printf("6. Exit\n");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        ++v8;
        break;
      case 2:
        ++v7;
        break;
      case 3:
        ++v6;
        break;
      case 4:
        printf("Enter Distance(miles): ");
        scanf("%f", &v5);
        break;
      case 5:
        printf("\nFitness Stats:\n");
        printf("Pushups: %d\n", v8);
        printf("Squats: %d\n", v7);
        printf("Crunches: %d\n", v6);
        printf("Distance: %f miles\n", v5);
        break;
      case 6:
        printf("Thank you for using Fitness Tracker!");
        break;
      default:
        printf("Invalid Choice!");
        break;
    }
  }
  while ( v4 != 6 );
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Linked list operations ; Style: Ada Lovelace
#include <stdio.h>
#include <stdlib.h>

typedef struct node Node;

struct node
{
    int data;
    Node *next;
};

Node *createNode(int);
void insertAtBeginning(Node **, int);
void insertAtEnd(Node **, int);
void insertAtPosition(Node **, int, int);
void deleteAtBeginning(Node **);
void deleteAtEnd(Node **);
void deleteAtPosition(Node **, int);
void traverseList(Node *);

int main()
{
    Node *head = NULL;
    int choice, position, data;

    do
    {
        printf("\n================================\n");
        printf(" Linked List Operations\n");
        printf("================================\n");
        printf("1. Insert at beginning\n");
        printf("2. Insert at end\n");
        printf("3. Insert at a position\n");
        printf("4. Delete at beginning\n");
        printf("5. Delete at end\n");
        printf("6. Delete at a position\n");
        printf("7. Traverse the list\n");
        printf("8. Exit\n");
        printf("\nEnter your choice: ");

        scanf("%d", &choice);

        switch(choice)
        {
            case 1:
                printf("\nEnter data to be inserted at the beginning: ");
                scanf("%d", &data);
                insertAtBeginning(&head, data);
                break;
            case 2:
                printf("\nEnter data to be inserted at the end: ");
                scanf("%d", &data);
                insertAtEnd(&head, data);
                break;
            case 3:
                printf("\nEnter data to be inserted: ");
                scanf("%d", &data);
                printf("Enter position: ");
                scanf("%d", &position);
                insertAtPosition(&head, data, position);
                break;
            case 4:
                deleteAtBeginning(&head);
                break;
            case 5:
                deleteAtEnd(&head);
                break;
            case 6:
                printf("\nEnter the position of the node to be deleted: ");
                scanf("%d", &position);
                deleteAtPosition(&head, position);
                break;
            case 7:
                traverseList(head);
                break;
            case 8:
                printf("\nExiting the program...\n");
                exit(0);
            default:
                printf("\nInvalid choice, please try again...\n");
        }
    } while (choice != 8);

    return 0;
}

Node *createNode(int data)
{
    Node *newNode = (Node *) malloc(sizeof(Node));

    if (newNode == NULL)
    {
        printf("\nMemory allocation failed, exiting program...\n");
        exit(1);
    }

    newNode->data = data;
    newNode->next = NULL;

    return newNode;
}

void insertAtBeginning(Node **head, int data)
{
    Node *newNode = createNode(data);

    if (*head == NULL)
    {
        *head = newNode;
        return;
    }

    newNode->next = *head;
    *head = newNode;
}

void insertAtEnd(Node **head, int data)
{
    Node *newNode = createNode(data);
    Node *temp = *head;

    if (*head == NULL)
    {
        *head = newNode;
        return;
    }

    while (temp->next != NULL)
        temp = temp->next;

    temp->next = newNode;
}

void insertAtPosition(Node **head, int data, int position)
{
    if (position < 1)
    {
        printf("Invalid position, please try again...\n");
        return;
    }

    if (position == 1)
    {
        insertAtBeginning(head, data);
        return;
    }

    Node *newNode = createNode(data);
    Node *temp = *head;

    for (int i = 1; i < position - 1 && temp != NULL; i++)
        temp = temp->next;

    if (temp == NULL)
    {
        printf("Invalid position, please try again...\n");
        return;
    }

    newNode->next = temp->next;
    temp->next = newNode;
}

void deleteAtBeginning(Node **head)
{
    if (*head == NULL)
    {
        printf("\nList is empty, nothing to delete...\n");
        return;
    }

    Node *temp = *head;

    *head = (*head)->next;
    free(temp);

    printf("\nNode deleted successfully...\n");
}

void deleteAtEnd(Node **head)
{
    if (*head == NULL)
    {
        printf("\nList is empty, nothing to delete...\n");
        return;
    }

    Node *temp = *head;

    if ((*head)->next == NULL)
    {
        *head = NULL;
        free(temp);

        printf("\nNode deleted successfully...\n");
        return;
    }

    while (temp->next->next != NULL)
        temp = temp->next;

    free(temp->next);
    temp->next = NULL;

    printf("\nNode deleted successfully...\n");
}

void deleteAtPosition(Node **head, int position)
{
    if (*head == NULL)
    {
        printf("\nList is empty, nothing to delete...\n");
        return;
    }

    if (position < 1)
    {
        printf("\nInvalid position, please try again...\n");
        return;
    }

    Node *temp = *head;

    if (position == 1)
    {
        *head = (*head)->next;
        free(temp);

        printf("\nNode deleted successfully...\n");
        return;
    }

    for (int i = 1; i < position - 1 && temp != NULL; i++)
        temp = temp->next;

    if (temp == NULL || temp->next == NULL)
    {
        printf("\nInvalid position, please try again...\n");
        return;
    }

    Node *nodeToDelete = temp->next;
    temp->next = nodeToDelete->next;
    free(nodeToDelete);

    printf("\nNode deleted successfully...\n");
}

void traverseList(Node *head)
{
    if (head == NULL)
    {
        printf("\nList is empty...\n");
        return;
    }

    printf("\nThe list is: ");
    Node *temp = head;

    while (temp != NULL)
    {
        printf("%d ", temp->data);
        temp = temp->next;
    }

    printf("\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall insertAtBeginning(_QWORD, _QWORD); // weak
__int64 __fastcall insertAtEnd(_QWORD, _QWORD); // weak
__int64 __fastcall insertAtPosition(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall deleteAtBeginning(_QWORD); // weak
__int64 __fastcall deleteAtEnd(_QWORD); // weak
__int64 __fastcall deleteAtPosition(_QWORD, _QWORD); // weak
__int64 __fastcall traverseList(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v5; // [rsp+30h] [rbp-10h] BYREF
  int v6; // [rsp+34h] [rbp-Ch] BYREF
  __int64 v7; // [rsp+38h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  v7 = 0i64;
  do
  {
    printf("\n================================\n");
    printf(" Linked List Operations\n");
    printf("================================\n");
    printf("1. Insert at beginning\n");
    printf("2. Insert at end\n");
    printf("3. Insert at a position\n");
    printf("4. Delete at beginning\n");
    printf("5. Delete at end\n");
    printf("6. Delete at a position\n");
    printf("7. Traverse the list\n");
    printf("8. Exit\n");
    printf("\nEnter your choice: ");
    scanf("%d", &v6);
    switch ( v6 )
    {
      case 1:
        printf("\nEnter data to be inserted at the beginning: ");
        scanf("%d", &v4);
        insertAtBeginning(&v7, v4);
        break;
      case 2:
        printf("\nEnter data to be inserted at the end: ");
        scanf("%d", &v4);
        insertAtEnd(&v7, v4);
        break;
      case 3:
        printf("\nEnter data to be inserted: ");
        scanf("%d", &v4);
        printf("Enter position: ");
        scanf("%d", &v5);
        insertAtPosition(&v7, v4, v5);
        break;
      case 4:
        deleteAtBeginning(&v7);
        break;
      case 5:
        deleteAtEnd(&v7);
        break;
      case 6:
        printf("\nEnter the position of the node to be deleted: ");
        scanf("%d", &v5);
        deleteAtPosition(&v7, v5);
        break;
      case 7:
        traverseList(v7);
        break;
      case 8:
        printf("\nExiting the program...\n");
        exit(0);
      default:
        printf("\nInvalid choice, please try again...\n");
        break;
    }
  }
  while ( v6 != 8 );
  return 0;
}
// 1400018BC: using guessed type __int64 __fastcall insertAtBeginning(_QWORD, _QWORD);
// 140001912: using guessed type __int64 __fastcall insertAtEnd(_QWORD, _QWORD);
// 14000197E: using guessed type __int64 __fastcall insertAtPosition(_QWORD, _QWORD, _QWORD);
// 140001A3F: using guessed type __int64 __fastcall deleteAtBeginning(_QWORD);
// 140001AA7: using guessed type __int64 __fastcall deleteAtEnd(_QWORD);
// 140001B65: using guessed type __int64 __fastcall deleteAtPosition(_QWORD, _QWORD);
// 140001C7F: using guessed type __int64 __fastcall traverseList(_QWORD);
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: RAM usage monitor ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Function to calculate RAM usage
// Returns the percentage of RAM used
float calculate_ram_usage() {
    FILE *fp;
    char buffer[1024];
    float ram_total, ram_free, ram_used;

    fp = fopen("/proc/meminfo", "r");
    fgets(buffer, 1024, fp);
    sscanf(buffer, "MemTotal: %f kB", &ram_total);

    fgets(buffer, 1024, fp);
    sscanf(buffer, "MemFree: %f kB", &ram_free);

    ram_used = ram_total - ram_free;

    fclose(fp);

    return (ram_used / ram_total) * 100;
}

// Main function
int main() {
    float ram_usage;
    while (1) {
        ram_usage = calculate_ram_usage();
        printf("RAM usage: %.2f%%\n", ram_usage);
        sleep(1);  // Sleep for 1 second before checking RAM usage again
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
double calculate_ram_usage(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak


//----- (00000001400016BC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  float v5; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  while ( 1 )
  {
    *(double *)v3.m128i_i64 = calculate_ram_usage();
    v5 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
    v3 = (__m128i)COERCE_UNSIGNED_INT64(v5);
    printf("RAM usage: %.2f%%\n", v5);
    sleep(1i64);
  }
}
// 1400016CE: variable 'v3' is possibly undefined
// 1400015D4: using guessed type double calculate_ram_usage(void);
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002820: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int test_speed() {
    int speed_limit = 100; // set the maximum speed limit as 100 Mbps
    int speed = 0;
    int time_taken = 0;
    time_t start_time, end_time;
    double diff;

    start_time = time(NULL); // get the current time in seconds

    // download a file of size 100 MB to test internet speed
    system("wget -O /dev/null http://speedtest.dal01.softlayer.com/downloads/test100.zip");

    end_time = time(NULL); // get the time when the download completes
    diff = difftime(end_time, start_time);

    time_taken = (int) diff; // calculate the time taken to download the file in seconds

    if (time_taken == 0) {
        // if time taken is less than 1 second, set it to 1 second to avoid division by zero
        time_taken = 1;
    }

    speed = (100 / time_taken) * 8; // calculate the internet speed in Mbps

    if (speed > speed_limit) {
        return speed_limit; // if speed is greater than maximum speed limit, return maximum speed limit
    } else {
        return speed; // otherwise return the actual speed
    }
}

int main() {
    int speed = test_speed();

    printf("Your internet speed is %d Mbps.\n", speed);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 test_speed(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001683) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4 = test_speed();
  printf("Your internet speed is %d Mbps.\n", v4);
  return 0;
}
// 1400015E4: using guessed type __int64 test_speed(void);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: satisfied
#include <stdio.h>

#define MAX_ACTIVITIES 100

struct activity {
    int start, end;
};

int compare_activities(const void *a, const void *b) {
    struct activity *act_a = (struct activity*) a;
    struct activity *act_b = (struct activity*) b;
    return act_a->end - act_b->end;
}

void select_activities(struct activity activities[], int n) {
    qsort(activities, n, sizeof(struct activity), compare_activities);
    int selected[MAX_ACTIVITIES];
    int count = 0, last = -1;
    for (int i = 0; i < n; ++i) {
        if (activities[i].start >= last) {
            selected[count++] = i;
            last = activities[i].end;
        }
    }
    printf("Selected activities: ");
    for (int i = 0; i < count; ++i) {
        printf("(%d,%d) ", activities[selected[i]].start, activities[selected[i]].end);
    }
}

int main() {
    struct activity activities[] = {
        {1, 3},
        {5, 7},
        {2, 4},
        {6, 8},
        {8, 10},
        {9, 11},
        {11, 13},
        {12, 14},
        {3, 5},
        {4, 6}
    };
    int n = sizeof(activities) / sizeof(struct activity);
    select_activities(activities, n);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall select_activities(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001732) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[24]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  v4[0] = 1;
  v4[1] = 3;
  v4[2] = 5;
  v4[3] = 7;
  v4[4] = 2;
  v4[5] = 4;
  v4[6] = 6;
  v4[7] = 8;
  v4[8] = 8;
  v4[9] = 10;
  v4[10] = 9;
  v4[11] = 11;
  v4[12] = 11;
  v4[13] = 13;
  v4[14] = 12;
  v4[15] = 14;
  v4[16] = 3;
  v4[17] = 5;
  v4[18] = 4;
  v4[19] = 6;
  v4[23] = 10;
  select_activities(v4, 10i64);
  return 0;
}
// 1400015C9: using guessed type __int64 __fastcall select_activities(_QWORD, _QWORD);
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Watermarking ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to set the lowest bit of every pixel to zero, except for the watermark bit
void embed_watermark(char *image_path, char *output_path, char *watermark) {
    FILE *image_file = fopen(image_path, "rb");
    FILE *output_file = fopen(output_path, "wb");

    if (image_file == NULL || output_file == NULL) {
        printf("File error!\n");
        exit(1);
    }

    unsigned char header[54];
    fread(header, sizeof(unsigned char), 54, image_file);

    fwrite(header, sizeof(unsigned char), 54, output_file);

    int width = *(int *)&header[18];
    int height = *(int *)&header[22];
    int padding = (4 - (width * 3) % 4) % 4;

    // Embed the watermark text bit by bit
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            unsigned char pixel[3];
            fread(pixel, sizeof(unsigned char), 3, image_file);

            // Set the lowest bit of the red component to zero
            pixel[0] = pixel[0] & 0xFE;

            if (*watermark != '\0') {
                // If there are more bits in the watermark message, embed the next one
                if ((*watermark & 0x80) == 0x80) {
                    // Set the lowest bit of the red component to one
                    pixel[0] = pixel[0] | 0x01;
                }
                watermark++;
            }

            fwrite(pixel, sizeof(unsigned char), 3, output_file);
        }
        // Add padding to the end of each row
        fseek(image_file, padding, SEEK_CUR);
        for (int k = 0; k < padding; k++) {
            fputc(0x00, output_file);
        }
    }

    fclose(image_file);
    fclose(output_file);
}

// Function to extract the watermark from an image
void extract_watermark(char *image_path, int watermark_len) {
    FILE *image_file = fopen(image_path, "rb");

    if (image_file == NULL) {
        printf("File error!\n");
        exit(1);
    }

    unsigned char header[54];
    fread(header, sizeof(unsigned char), 54, image_file);

    int width = *(int *)&header[18];
    int height = *(int *)&header[22];
    int padding = (4 - (width * 3) % 4) % 4;

    char watermark[watermark_len + 1];
    memset(watermark, 0, watermark_len + 1);

    // Extract the watermark from the LSB of the red component of each pixel
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            unsigned char pixel[3];
            fread(pixel, sizeof(unsigned char), 3, image_file);

            // Extract the lowest bit of the red component
            if ((pixel[0] & 0x01) == 0x01) {
                watermark[i * width + j] = '1';
            } else {
                watermark[i * width + j] = '0';
            }

            if (i * width + j == watermark_len) {
                break;
            }
        }
        // Skip the padding at the end of each row
        fseek(image_file, padding, SEEK_CUR);
    }

    printf("Extracted watermark: %s\n", watermark);

    fclose(image_file);
}

int main() {
    char *image_path = "input.bmp";
    char *output_path = "output.bmp";
    char *watermark = "Hello, World!";
    int watermark_len = strlen(watermark) * 8;

    embed_watermark(image_path, output_path, watermark);

    extract_watermark(output_path, watermark_len);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall embed_watermark(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall extract_watermark(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (000000014000198A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-1Ch]

  _main(argc, argv, envp);
  v4 = 8 * strlen("Hello, World!");
  embed_watermark("input.bmp", "output.bmp", "Hello, World!");
  extract_watermark("output.bmp", v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall embed_watermark(_QWORD, _QWORD, _QWORD);
// 140001777: using guessed type __int64 __fastcall extract_watermark(_QWORD, _QWORD);
// 140001AB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define WIDTH 16
#define HEIGHT 16

void draw_pixel(char grid[WIDTH][HEIGHT], int x, int y, char color) {
  grid[x][y] = color;
}

void print_grid(char grid[WIDTH][HEIGHT]) {
  for (int y = 0; y < HEIGHT; y++) {
    for (int x = 0; x < WIDTH; x++) {
      printf("%c ", grid[x][y]);
    }
    printf("\n");
  }
}

int main() {
  char grid[WIDTH][HEIGHT];

  // Initialize grid to all white pixels
  for (int y = 0; y < HEIGHT; y++) {
    for (int x = 0; x < WIDTH; x++) {
      grid[x][y] = '.';
    }
  }

  // Randomly generate pixels
  srand(time(NULL));
  for (int i = 0; i < WIDTH * HEIGHT / 4; i++) {
    int x = rand() % WIDTH;
    int y = rand() % HEIGHT;
    char color = (rand() % 2 == 0) ? 'X' : 'O';
    draw_pixel(grid, x, y, color);
  }

  // Print the final grid
  print_grid(grid);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 __fastcall draw_pixel(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall print_grid(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001661) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v4; // al
  char v6[268]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v7; // [rsp+12Ch] [rbp+ACh]
  unsigned int v8; // [rsp+130h] [rbp+B0h]
  int k; // [rsp+134h] [rbp+B4h]
  int j; // [rsp+138h] [rbp+B8h]
  int i; // [rsp+13Ch] [rbp+BCh]

  _main(argc, argv, envp);
  for ( i = 0; i <= 15; ++i )
  {
    for ( j = 0; j <= 15; ++j )
      v6[16 * j + i] = 46;
  }
  v3 = time(0i64);
  srand(v3);
  for ( k = 0; k <= 63; ++k )
  {
    v8 = rand() % 16;
    v7 = rand() % 16;
    if ( (rand() & 1) != 0 )
      v4 = 79;
    else
      v4 = 88;
    v6[267] = v4;
    draw_pixel(v6, v8, v7, (unsigned int)v4);
  }
  print_grid(v6);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall draw_pixel(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400015E8: using guessed type __int64 __fastcall print_grid(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Educational ; Style: happy
#include <stdio.h>

int main() {
  printf("Welcome to the Happy Code Learning Program!\n\n");
  printf("Today, we are going to learn about arrays and loops!\n\n");

  int myArray[5] = {1, 2, 3, 4, 5};

  printf("My array is:");
  for(int i=0; i<5; i++) {
    printf(" %d", myArray[i]);
  }
  printf("\n\n");
  printf("Now, let's double each element in the array using a loop!\n\n");

  for(int i=0; i<5; i++) {
    myArray[i] = myArray[i] * 2;
    printf("Element %d is now %d\n", i+1, myArray[i]);
  }

  printf("\n\n");
  printf("The final array is:");
  for(int i=0; i<5; i++) {
    printf(" %d", myArray[i]);
  }
  printf("\n\n");
  printf("Great job! You've learned how to use arrays and loops in C!\n");
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[5]; // [rsp+20h] [rbp-20h]
  int k; // [rsp+34h] [rbp-Ch]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Happy Code Learning Program!\n\n");
  printf("Today, we are going to learn about arrays and loops!\n\n");
  v4[0] = 1;
  v4[1] = 2;
  v4[2] = 3;
  v4[3] = 4;
  v4[4] = 5;
  printf("My array is:");
  for ( i = 0; i <= 4; ++i )
    printf(" %d", (unsigned int)v4[i]);
  printf("\n\n");
  printf("Now, let's double each element in the array using a loop!\n\n");
  for ( j = 0; j <= 4; ++j )
  {
    v4[j] *= 2;
    printf("Element %d is now %d\n", (unsigned int)(j + 1), (unsigned int)v4[j]);
  }
  printf("\n\n");
  printf("The final array is:");
  for ( k = 0; k <= 4; ++k )
    printf(" %d", (unsigned int)v4[k]);
  printf("\n\n");
  printf("Great job! You've learned how to use arrays and loops in C!\n");
  return 0;
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Phone Book ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define maximum number of contacts
#define MAX_CONTACTS 1000

// Define structure for contacts
typedef struct {
    char name[50];
    char phone[20];
    char email[50];
} Contact;

// Define the phone book array and current number of contacts
Contact phone_book[MAX_CONTACTS];
int num_contacts = 0;

// Function to add a new contact to the phone book
void add_contact() {
    // Check if we have room for another contact
    if (num_contacts >= MAX_CONTACTS) {
        printf("The phone book is full!\n");
        return;
    }
    
    // Get user input for the new contact
    Contact new_contact;
    printf("Enter name: ");
    scanf("%s", new_contact.name);
    printf("Enter phone number: ");
    scanf("%s", new_contact.phone);
    printf("Enter email: ");
    scanf("%s", new_contact.email);
    
    // Add the new contact to the phone book
    phone_book[num_contacts] = new_contact;
    num_contacts++;
}

// Function to list all contacts in the phone book
void list_contacts() {
    // Print header
    printf("Phone Book:\n");
    printf("------------\n");
    
    // Loop through all contacts and print their info
    for (int i = 0; i < num_contacts; i++) {
        printf("Name: %s\n", phone_book[i].name);
        printf("Phone: %s\n", phone_book[i].phone);
        printf("Email: %s\n", phone_book[i].email);
        printf("\n");
    }
}

// Function to search for a contact by name
void search_contact() {
    // Get user input for the name to search for
    char search_name[50];
    printf("Enter name to search for: ");
    scanf("%s", search_name);
    
    // Loop through all contacts and search for the name
    for (int i = 0; i < num_contacts; i++) {
        if (strcmp(phone_book[i].name, search_name) == 0) {
            printf("Name: %s\n", phone_book[i].name);
            printf("Phone: %s\n", phone_book[i].phone);
            printf("Email: %s\n", phone_book[i].email);
            return;
        }
    }
    
    // If we haven't found the contact, print an error message
    printf("Contact not found!\n");
}

int main() {
    // Loop to prompt the user for commands
    while (1) {
        printf("Enter a command (add, list, search, exit): ");
        char command[10];
        scanf("%s", command);
        
        if (strcmp(command, "add") == 0) {
            add_contact();
        }
        else if (strcmp(command, "list") == 0) {
            list_contacts();
        }
        else if (strcmp(command, "search") == 0) {
            search_contact();
        }
        else if (strcmp(command, "exit") == 0) {
            return 0;
        }
        else {
            printf("Invalid command! Please try again.\n");
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_contact(void); // weak
__int64 list_contacts(void); // weak
__int64 search_contact(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (000000014000197E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[10]; // [rsp+26h] [rbp-Ah] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          printf("Enter a command (add, list, search, exit): ");
          scanf("%s", Str1);
          if ( strcmp(Str1, "add") )
            break;
          add_contact();
        }
        if ( strcmp(Str1, "list") )
          break;
        list_contacts();
      }
      if ( strcmp(Str1, "search") )
        break;
      search_contact();
    }
    if ( !strcmp(Str1, "exit") )
      break;
    printf("Invalid command! Please try again.\n");
  }
  return 0;
}
// 1400015E2: using guessed type __int64 add_contact(void);
// 14000174B: using guessed type __int64 list_contacts(void);
// 140001847: using guessed type __int64 search_contact(void);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Color Code Converter ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* hexToRgb(char*);
char* rgbToHex(char*);

int main() {
    char input[10];
    printf("Enter HEX or RGB color code: ");
    scanf("%s", input);

    char* result;
    if (input[0] == '#') {
        result = hexToRgb(input);
        printf("RGB code: %s", result);
    } else {
        result = rgbToHex(input);
        printf("HEX code: %s", result);
    }

    free(result);
    return 0;
}

char* hexToRgb(char* input) {
    char* output = malloc(sizeof(char) * 15);
    char hex[7];
    strncpy(hex, input + 1, 6);
    hex[6] = '\0';

    int r, g, b;
    sscanf(hex, "%02x%02x%02x", &r, &g, &b);
    sprintf(output, "%d,%d,%d", r, g, b);
    return output;
}

char* rgbToHex(char* input) {
    char* output = malloc(sizeof(char) * 8);
    int r, g, b;
    sscanf(input, "%d,%d,%d", &r, &g, &b);
    sprintf(output, "#%02x%02x%02x", r, g, b);
    return output;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall hexToRgb(_QWORD); // weak
__int64 __fastcall rgbToHex(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (0000000140001668) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[10]; // [rsp+2Eh] [rbp-12h] BYREF
  void *Block; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter HEX or RGB color code: ");
  scanf("%s", v4);
  if ( v4[0] == 35 )
  {
    Block = (void *)hexToRgb(v4);
    printf("RGB code: %s", (const char *)Block);
  }
  else
  {
    Block = (void *)rgbToHex(v4);
    printf("HEX code: %s", (const char *)Block);
  }
  free(Block);
  return 0;
}
// 140001707: using guessed type __int64 __fastcall hexToRgb(_QWORD);
// 14000179A: using guessed type __int64 __fastcall rgbToHex(_QWORD);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: A* Pathfinding Algorithm ; Style: real-life
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define ROW 10
#define COL 10

typedef struct Node {
    int f, g, h;
    int row, col;
    bool isBlocked;
    struct Node *parent;
} Node;

int heuristicCostEstimate(int startRow, int startCol, int endRow, int endCol) {
    int x = abs(startRow - endRow);
    int y = abs(startCol - endCol);
    int heuristic = x + y;
    return heuristic;
}

bool isNodeValid(int row, int col) {
    if (row < 0 || row >= ROW || col < 0 || col >= COL) {
        return false;
    }
    return true;
}

Node* getNode(int grid[][COL], int row, int col) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->f = 0;
    node->g = 0;
    node->h = 0;
    node->row = row;
    node->col = col;
    node->isBlocked = (grid[row][col] == 1) ? true : false;
    node->parent = NULL;
    return node;
}

void printPath(Node* node) {
    if (node != NULL) {
        printPath(node->parent);
        printf("[(%d,%d)] -> ", node->row, node->col);
    }
}

void aStar(int grid[][COL], int startRow, int startCol, int endRow, int endCol) {
    Node* startNode = getNode(grid, startRow, startCol);
    Node* endNode = getNode(grid, endRow, endCol);
    
    bool visited[ROW][COL] = {false};
    bool isFound = false;
    
    Node* openList[ROW*COL] = {NULL};
    int openCount = 0;
    
    startNode->f = startNode->g + heuristicCostEstimate(startRow, startCol, endRow, endCol);
    openList[openCount++] = startNode;
    
    while (openCount > 0) {
        Node* currentNode = openList[0];
        int currentIndex = 0;
        
        for (int i = 1; i < openCount; i++) {
            if (openList[i]->f < currentNode->f) {
                currentNode = openList[i];
                currentIndex = i;
            }
        }
        
        openList[currentIndex] = openList[--openCount];
        
        if (currentNode == endNode) {
            isFound = true;
            printf("Path found: ");
            printPath(currentNode);
            break;
        }
        
        int row = currentNode->row;
        int col = currentNode->col;
        
        visited[row][col] = true;
        
        for (int i = -1; i <= 1; i++) {
            for (int j = -1; j <= 1; j++) {
                if (i == 0 && j == 0) {
                    continue;
                }
                int nRow = row + i;
                int nCol = col + j;
                
                if (isNodeValid(nRow, nCol) && !visited[nRow][nCol]) {
                    Node* neighborNode = getNode(grid, nRow, nCol);
                    if (neighborNode->isBlocked) {
                        visited[nRow][nCol] = true;
                        continue;
                    }
                    int newG = currentNode->g + 1;
                    if (newG < neighborNode->g || neighborNode->g == 0) {
                        neighborNode->parent = currentNode;
                        neighborNode->g = newG;
                        neighborNode->h = heuristicCostEstimate(nRow, nCol, endRow, endCol);
                        neighborNode->f = neighborNode->g + neighborNode->h;
                        
                        if (openCount == 0) {
                            openList[openCount++] = neighborNode;
                        } else {
                            int k;
                            for (k = 0; k < openCount; k++) {
                                if (openList[k]->f > neighborNode->f) {
                                    break;
                                }
                            }
                            for (int m = openCount; m > k; m--) {
                                openList[m] = openList[m - 1];
                            }
                            openList[k] = neighborNode;
                            openCount++;
                        }
                    }
                }
            }
        }
    }
    
    if (!isFound) {
        printf("Path not found!\n");
    }
}

int main() {
    int grid[ROW][COL] = {
        {0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
        {0, 1, 1, 0, 1, 0, 0, 1, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
        {1, 1, 0, 0, 0, 0, 1, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},
        {0, 1, 0, 0, 1, 0, 0, 1, 0, 1},
        {0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 1, 0, 1, 1, 0},
        {0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
    };
    
    int startRow = 0;
    int startCol = 0;
    int endRow = 0;
    int endCol = 8;
    
    aStar(grid, startRow, startCol, endRow, endCol);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall aStar(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001C22) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[108]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  memset(v4, 0, 0x190ui64);
  v4[7] = 1;
  v4[11] = 1;
  v4[12] = 1;
  v4[14] = 1;
  v4[17] = 1;
  v4[33] = 1;
  v4[35] = 1;
  v4[40] = 1;
  v4[41] = 1;
  v4[46] = 1;
  v4[56] = 1;
  v4[58] = 1;
  v4[61] = 1;
  v4[64] = 1;
  v4[67] = 1;
  v4[69] = 1;
  v4[72] = 1;
  v4[85] = 1;
  v4[87] = 1;
  v4[88] = 1;
  v4[97] = 1;
  v4[103] = 0;
  v4[102] = 0;
  v4[101] = 0;
  v4[100] = 8;
  aStar((unsigned int)v4, 0, 0, 0, 8);
  return 0;
}
// 1400016F5: using guessed type __int64 __fastcall aStar(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001E20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Ebook reader ; Style: imaginative
#include<stdio.h>
#include<stdlib.h>

typedef struct Book {
   char title[50];
   char author[50];
   int pages;
   float price;
} Book;

int main() {
   Book book1;
   printf("Enter the book title: ");
   fgets(book1.title, sizeof(book1.title), stdin);
   printf("Enter the author name: ");
   fgets(book1.author, sizeof(book1.author), stdin);
   printf("Enter the number of pages: ");
   scanf("%d", &book1.pages);
   printf("Enter the price: ");
   scanf("%f", &book1.price);

   printf("\n\n*** Book Details ***\n\n");
   printf("Title: %s", book1.title);
   printf("Author: %s", book1.author);
   printf("Pages: %d", book1.pages);
   printf("Price: $%.2f", book1.price);

   FILE *file_pointer;
   file_pointer = fopen("book1.txt", "w");
   if (file_pointer == NULL) {
      printf("Error opening file.");
      exit(1);
   }

   fprintf(file_pointer, "*** Book Details ***\n\n");
   fprintf(file_pointer, "Title: %s", book1.title);
   fprintf(file_pointer, "Author: %s", book1.author);
   fprintf(file_pointer, "Pages: %d", book1.pages);
   fprintf(file_pointer, "Price: $%.2f", book1.price);

   fclose(file_pointer);
   printf("\n\nBook details saved to file.");
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Buffer[50]; // [rsp+20h] [rbp-80h] BYREF
  char v7[50]; // [rsp+52h] [rbp-4Eh] BYREF
  unsigned int v8; // [rsp+84h] [rbp-1Ch] BYREF
  float v9[4]; // [rsp+88h] [rbp-18h] BYREF
  FILE *Stream; // [rsp+98h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter the book title: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 50, v3);
  printf("Enter the author name: ");
  v4 = __acrt_iob_func(0);
  fgets(v7, 50, v4);
  printf("Enter the number of pages: ");
  scanf("%d", &v8);
  printf("Enter the price: ");
  scanf("%f", v9);
  printf("\n\n*** Book Details ***\n\n");
  printf("Title: %s", Buffer);
  printf("Author: %s", v7);
  printf("Pages: %d", v8);
  printf("Price: $%.2f", v9[0]);
  Stream = fopen("book1.txt", "w");
  if ( !Stream )
  {
    printf("Error opening file.");
    exit(1);
  }
  fprintf_0(Stream, "*** Book Details ***\n\n");
  fprintf_0(Stream, "Title: %s", Buffer);
  fprintf_0(Stream, "Author: %s", v7);
  fprintf_0(Stream, "Pages: %d", v8);
  fprintf_0(Stream, "Price: $%.2f", v9[0]);
  fclose(Stream);
  printf("\n\nBook details saved to file.");
  return 0;
}
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001625: using guessed type float var_18[4];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAX_PLANETS 10

typedef struct Vector {
    double x;
    double y;
} Vector;

typedef struct Planet {
    Vector position;
    Vector velocity;
    Vector acceleration;
    double mass;
} Planet;

typedef struct SolarSystem {
    Planet planets[MAX_PLANETS];
    int count;
} SolarSystem;

const double GRAV_CONST = 6.67e-11;

void calculate_gravity(Planet *p1, Planet *p2) {
    Vector diff = { p2->position.x - p1->position.x, p2->position.y - p1->position.y };
    double distance = sqrt(diff.x * diff.x + diff.y * diff.y);
    double force = GRAV_CONST * (p1->mass * p2->mass) / (distance * distance);
    Vector direction = { diff.x / distance, diff.y / distance };
    Vector gravity1 = { direction.x * force / p1->mass, direction.y * force / p1->mass };
    Vector gravity2 = { direction.x * force / p2->mass, direction.y * force / p2->mass };
    p1->acceleration.x += gravity2.x;
    p1->acceleration.y += gravity2.y;
    p2->acceleration.x -= gravity1.x;
    p2->acceleration.y -= gravity1.y;
}

void calculate_accelerations(SolarSystem *system) {
    for (int i = 0; i < system->count; i++) {
        system->planets[i].acceleration.x = 0;
        system->planets[i].acceleration.y = 0;
        for (int j = 0; j < system->count; j++) {
            if (i != j) {
                calculate_gravity(&system->planets[i], &system->planets[j]);
            }
        }
    }
}

void update_positions(SolarSystem *system, double time_step) {
    for (int i = 0; i < system->count; i++) {
        Planet *p = &system->planets[i];
        p->position.x += p->velocity.x * time_step + 0.5 * p->acceleration.x * time_step * time_step;
        p->position.y += p->velocity.y * time_step + 0.5 * p->acceleration.y * time_step * time_step;
    }
}

void update_velocities(SolarSystem *system, double time_step) {
    for (int i = 0; i < system->count; i++) {
        Planet *p = &system->planets[i];
        p->velocity.x += p->acceleration.x * time_step;
        p->velocity.y += p->acceleration.y * time_step;
    }
}

void simulate(SolarSystem *system, double time_step, int num_steps) {
    for (int i = 0; i < num_steps; i++) {
        calculate_accelerations(system);
        update_positions(system, time_step);
        calculate_accelerations(system);
        update_velocities(system, time_step);
    }
}

int main() {
    SolarSystem solar_system = { .count = 2 };
    solar_system.planets[0] = (Planet) { .position = { 0, 0 }, .velocity = { 0, 0 }, .acceleration = { 0, 0 }, .mass = 1.989e30 };
    solar_system.planets[1] = (Planet) { .position = { 0, 149.6e9 }, .velocity = { 29.29e3, 0 }, .acceleration = { 0, 0 }, .mass = 5.97e24 };
    double time_step = 3600;
    int num_steps = 24 * 365;
    simulate(&solar_system, time_step, num_steps);
    printf("Position of the Earth: (%lf, %lf)\n", solar_system.planets[1].position.x, solar_system.planets[1].position.y);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall simulate(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A24) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[72]; // [rsp+A0h] [rbp+20h] BYREF
  int v5; // [rsp+2E4h] [rbp+264h]
  __int64 v6; // [rsp+2E8h] [rbp+268h]

  _main(argc, argv, envp);
  memset(v4, 0, 0x238ui64);
  LODWORD(v4[70]) = 2;
  memset(v4, 0, 48);
  v4[6] = 0x46391ACE3D05AEF4i64;
  v4[7] = 0i64;
  v4[8] = 0x42416A6D6C000000i64;
  v4[9] = 0x40DC9A8000000000i64;
  memset(&v4[10], 0, 24);
  v4[13] = 0x4513C0C964D9C187i64;
  v6 = 0x40AC200000000000i64;
  v5 = 8760;
  simulate(v4, 8760i64, 8760i64);
  printf("Position of the Earth: (%lf, %lf)\n", v4[7], v4[8]);
  return 0;
}
// 1400019BC: using guessed type __int64 __fastcall simulate(_QWORD, _QWORD, _QWORD);
// 140001C30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Public-Key Algorithm Implementation ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

int gcd(int a, int b) {
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

int modInverse(int a, int m) {
    int m0 = m, t, q;
    int x0 = 0, x1 = 1;

    if (m == 1)
        return 0;

    while (a > 1) {
        q = a / m;
        t = m;

        m = a % m, a = t;
        t = x0;

        x0 = x1 - q * x0;
        x1 = t;
    }

    if (x1 < 0)
        x1 += m0;

    return x1;
}

int generateKeys(int *pub_key, int *prv_key) {
    int p, q, n, phiN, e, d, max, i, j, flag;
    int primes[10000];

    srand(time(0));

    printf("Generating prime numbers...\n");

    primes[0] = 2;
    primes[1] = 3;
    max = 2;

    for (i = 5; max < 10000; i += 2) {
        flag = 0;
        for (j = 1; primes[j] * primes[j] <= i; j++) {
            if (i % primes[j] == 0) {
                flag = 1;
                break;
            }
        }

        if (flag == 0) {
            primes[max++] = i;
        }
    }

    p = primes[rand() % 10000];
    q = primes[rand() % 10000];

    while (p == q) {
        q = primes[rand() % 10000];
    }

    n = p * q;
    phiN = (p - 1) * (q - 1);

    e = 10001;

    while (gcd(e, phiN) != 1) {
        e = primes[rand() % 10000];
    }

    d = modInverse(e, phiN);

    *pub_key = e;
    *prv_key = d;

    return n;
}

int main() {
    int pub_key, prv_key, n;
    int input, encrypted, decrypted;

    n = generateKeys(&pub_key, &prv_key);

    printf("Public Key: %d\nPrivate Key: %d\nN: %d\n", pub_key, prv_key, n);

    printf("Enter a number to encrypt: ");
    scanf("%d", &input);

    encrypted = (int)(pow(input, pub_key)) % n;
    decrypted = (int)(pow(encrypted, prv_key)) % n;

    printf("Encrypted: %d\n", encrypted);
    printf("Decrypted: %d\n", decrypted);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generateKeys(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);


//----- (000000014000193F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm0_8
  __int64 v4; // rtt
  int v6; // [rsp+28h] [rbp-18h] BYREF
  unsigned int v7; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v8; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v9; // [rsp+34h] [rbp-Ch]
  unsigned int v10; // [rsp+38h] [rbp-8h]
  unsigned int v11; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v11 = generateKeys(&v8, &v7);
  printf("Public Key: %d\nPrivate Key: %d\nN: %d\n", v8, v7, v11);
  printf("Enter a number to encrypt: ");
  scanf("%d", &v6);
  v3 = pow((double)v6, (double)(int)v8);
  v10 = (int)v3 % (int)v11;
  v4 = (int)pow((double)(int)v10, (double)(int)v7);
  v9 = v4 % (int)v11;
  printf("Encrypted: %d\n", v10);
  printf("Decrypted: %d\n", v9);
  return 0;
}
// 1400016BA: using guessed type __int64 __fastcall generateKeys(_QWORD, _QWORD);
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    int option;

    printf("Welcome to the Automated Fortune Teller\n");
    printf("Please choose your reading:\n");
    printf("1. Love and Relationships\n");
    printf("2. Career and Finances\n");
    printf("3. Life and Success\n");
    scanf("%d", &option);

    switch(option)
    {
        case 1:
            printf("You will soon meet someone special who will bring great joy and happiness into your life.\n");
            break;
        case 2:
            printf("Your hard work and dedication will pay off in your career. Expect a promotion or raise soon.\n");
            break;
        case 3:
            printf("You are destined for great success. Keep working hard and never give up on your dreams.\n");
            break;
        default:
            printf("Invalid option selected. Please choose from 1-3.\n");
            break;
    }

    // Generate a random number to predict a lucky number
    srand(time(0));
    int lucky_number = rand() % 10 + 1;

    printf("Your lucky number for today is: %d\n", lucky_number);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+28h] [rbp-8h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Automated Fortune Teller\n");
  printf("Please choose your reading:\n");
  printf("1. Love and Relationships\n");
  printf("2. Career and Finances\n");
  printf("3. Life and Success\n");
  scanf("%d", &v5);
  if ( v5 == 3 )
  {
    printf("You are destined for great success. Keep working hard and never give up on your dreams.\n");
  }
  else
  {
    if ( v5 > 3 )
    {
LABEL_9:
      printf("Invalid option selected. Please choose from 1-3.\n");
      goto LABEL_10;
    }
    if ( v5 == 1 )
    {
      printf("You will soon meet someone special who will bring great joy and happiness into your life.\n");
    }
    else
    {
      if ( v5 != 2 )
        goto LABEL_9;
      printf("Your hard work and dedication will pay off in your career. Expect a promotion or raise soon.\n");
    }
  }
LABEL_10:
  v3 = time(0i64);
  srand(v3);
  v6 = rand() % 10 + 1;
  printf("Your lucky number for today is: %d\n", v6);
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: calm
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b){
    int temp = *a;
    *a = *b;
    *b = temp;
}
void bubble_sort(int arr[], int n){
    int i, j;
    for(i=0; i<n-1; i++){
        for(j=0; j<n-i-1; j++){
            if(arr[j]>arr[j+1]){
                swap(&arr[j], &arr[j+1]);
            }
        }
    }
}

void selection_sort(int arr[], int n){
    int i, j, min_index;
    for(i=0; i<n-1; i++){
        min_index=i;
        for(j=i+1; j<n; j++){
            if(arr[j]<arr[min_index]){
                min_index=j;
            }
        }
        if(min_index!=i){
            swap(&arr[i], &arr[min_index]);
        }
    }
}

void insertion_sort(int arr[], int n){
    int i, j, key;
    for(i=1; i<n; i++){
        key=arr[i];
        j=i-1;

        while(j>=0 && arr[j]>key){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1] = key;
    }
}

int main(){
    int n, choice, i;

    printf("Enter the size of the array: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter %d elements in the array\n", n);
    for (i = 0; i < n; ++i){
        scanf("%d", &arr[i]);
    }

    printf("Which sorting method do you want to use:\n");
    printf("1. Bubble Sort\n");
    printf("2. Selection Sort\n");
    printf("3. Insertion Sort\n");

    scanf("%d", &choice);

    switch(choice){
        case 1:
            bubble_sort(arr, n);
            printf("The array sorted using Bubble Sort is:\n");
            break;
        case 2:
            selection_sort(arr, n);
            printf("The array sorted using Selection Sort is:\n");
            break;
        case 3:
            insertion_sort(arr, n);
            printf("The array sorted using Insertion Sort is:\n");
            break;
        default:
            printf("Invalid Input\n");
            exit(0);
    }

    for(i=0; i<n; i++){
        printf("%d ", arr[i]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall bubble_sort(_QWORD, _QWORD); // weak
__int64 __fastcall selection_sort(_QWORD, _QWORD); // weak
__int64 __fastcall insertion_sort(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (000000014000185B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  int v5; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v6; // [rsp+24h] [rbp-1Ch] BYREF
  int *v7; // [rsp+28h] [rbp-18h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the size of the array: ");
  scanf("%d", &v6);
  v8 = (int)v6 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(4i64 * (int)v6 + 15) >> 4));
  v7 = &v5;
  printf("Enter %d elements in the array\n", v6);
  for ( i = 0; i < (int)v6; ++i )
    scanf("%d", &v7[i]);
  printf("Which sorting method do you want to use:\n");
  printf("1. Bubble Sort\n");
  printf("2. Selection Sort\n");
  printf("3. Insertion Sort\n");
  scanf("%d", &v5);
  if ( v5 == 3 )
  {
    insertion_sort(v7, v6);
    printf("The array sorted using Insertion Sort is:\n");
  }
  else
  {
    if ( v5 > 3 )
      goto LABEL_12;
    if ( v5 == 1 )
    {
      bubble_sort(v7, v6);
      printf("The array sorted using Bubble Sort is:\n");
    }
    else
    {
      if ( v5 != 2 )
      {
LABEL_12:
        printf("Invalid Input\n");
        exit(0);
      }
      selection_sort(v7, v6);
      printf("The array sorted using Selection Sort is:\n");
    }
  }
  for ( i = 0; i < (int)v6; ++i )
    printf("%d ", (unsigned int)v7[i]);
  return 0;
}
// 140001617: using guessed type __int64 __fastcall bubble_sort(_QWORD, _QWORD);
// 1400016D0: using guessed type __int64 __fastcall selection_sort(_QWORD, _QWORD);
// 140001791: using guessed type __int64 __fastcall insertion_sort(_QWORD, _QWORD);
// 140001B20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Modern Encryption ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define SHIFT 3   // Shift value for the Caesar Cipher

// Encryption function
void encrypt(char *plaintext, int shift) {
    int i;

    for (i = 0; i < strlen(plaintext); i++) {
        // Shift uppercase letters
        if (isupper(plaintext[i])) {
            plaintext[i] = ((plaintext[i] - 'A') + shift) % 26 + 'A';
        }
        // Shift lowercase letters
        else if (islower(plaintext[i])) {
            plaintext[i] = ((plaintext[i] - 'a') + shift) % 26 + 'a';
        }
    }
}

int main(void) {
    char plaintext[100];
    int shift;

    // Get plaintext and shift value from user
    printf("Enter plaintext: ");
    scanf("%[^\n]", plaintext);
    printf("Enter shift value (1-25): ");
    scanf("%d", &shift);

    // Validate shift value
    while (shift < 1 || shift > 25) {
        printf("Invalid shift value. Please enter a value between 1 and 25: ");
        scanf("%d", &shift);
    }

    // Encrypt plaintext using Caesar Cipher
    encrypt(plaintext, shift);

    // Print encrypted text
    printf("Encrypted text: %s\n", plaintext);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000170B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-74h] BYREF
  char v5[112]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter plaintext: ");
  scanf("%[^\n]", v5);
  printf("Enter shift value (1-25): ");
  scanf("%d", &v4);
  while ( v4 <= 0 || v4 > 25 )
  {
    printf("Invalid shift value. Please enter a value between 1 and 25: ");
    scanf("%d", &v4);
  }
  encrypt(v5, (unsigned int)v4);
  printf("Encrypted text: %s\n", v5);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Clustering Algorithm Implementation ; Style: ultraprecise
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<math.h>

#define ROWS 10
#define COLS 2

float distance(float *a, float *b, int cols){   // function to calculate distance between points a and b
    float sum = 0.0;
    int i;
    for(i=0; i<cols; i++){
        sum += pow((b[i]-a[i]), 2.0);
    }
    return sqrt(sum);
}

int find_nearest(float *point, float **centroids, int k, int cols){   // function to find centroid nearest to the point
    int i, nearest;
    float d, min_d = 10000;   // initializing minimum distance to a large value
    for(i=0; i<k; i++){
        d = distance(point, centroids[i], cols);
        if(d < min_d){
            min_d = d;
            nearest = i;
        }
    }
    return nearest;
}

float** create_centroids(int k, int cols){   // function to create k random centroids in the range of 0 to 1
    int i, j;
    float **centroids = (float**)malloc(k*sizeof(float*));
    for(i=0; i<k; i++){
        centroids[i] = (float*)malloc(cols*sizeof(float));
        for(j=0; j<cols; j++){
            centroids[i][j] = (float)rand()/(float)RAND_MAX;
        }
    }
    return centroids;
}

int main(){
    srand(time(NULL));
    float data_points[ROWS][COLS] = {{0.1, 0.6}, {0.15, 0.71}, {0.08, 0.9}, {0.16, 0.85}, {0.2, 0.3}, {0.25, 0.5}, {0.24, 0.1}, {0.3, 0.2}, {0.35, 0.3}, {0.45, 0.2}};  // sample data points with 10 rows and 2 columns
    int k = 3, i, j, iter = 0;
    float **centroids = create_centroids(k, COLS);  // creating initial k random centroids
    int *cluster = (int*)malloc(ROWS*sizeof(int));   // array to store cluster assignments of each point
    int *old_cluster = (int*)malloc(ROWS*sizeof(int));  // array to store old cluster assignments for comparison
    while(1){                               // loop till the clusters no more change
        iter++;
        for(i=0; i<ROWS; i++){
            cluster[i] = find_nearest(data_points[i], centroids, k, COLS); // finding the nearest centroid for each point
        }
        if(iter != 1){
            int diff_count = 0;
            for(i=0; i<ROWS; i++){
                if(cluster[i] != old_cluster[i]){
                    diff_count++;
                }
            }
            if(diff_count == 0){         // if no point has changed cluster, break out of loop
                break;
            }
        }
        for(i=0; i<ROWS; i++){
            old_cluster[i] = cluster[i];
        }
        float **sum = (float**)malloc(k*sizeof(float*));
        int *count = (int*)malloc(k*sizeof(int));
        for(i=0; i<k; i++){
            sum[i] = (float*)calloc(COLS, sizeof(float));
            count[i] = 0;
        }
        for(i=0; i<ROWS; i++){          // calculating sum of points in each cluster
            int c = cluster[i];
            for(j=0; j<COLS; j++){
                sum[c][j] += data_points[i][j];
            }
            count[c]++;
        }
        for(i=0; i<k; i++){            // updating centroids
            for(j=0; j<COLS; j++){
                centroids[i][j] = sum[i][j]/count[i];
            }
        }
        for(i=0; i<k; i++){
            free(sum[i]);              // freeing memory
        }
        free(sum);
        free(count);
    }
    printf("Final clustering:\n");
    for(i=0; i<k; i++){
        printf("Cluster %d: ", i+1);
        for(j=0; j<ROWS; j++){
            if(cluster[j] == i){
                printf("(%f, %f) ", data_points[j][0], data_points[j][1]);
            }
        }
        printf("\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall find_nearest(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall create_centroids(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void *__cdecl calloc(size_t Count, size_t Size);


//----- (00000001400017CB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  _DWORD *v4; // rbx
  void **v5; // rbx
  int v7; // [rsp+20h] [rbp-A0h] BYREF
  int v8[22]; // [rsp+24h] [rbp-9Ch]
  int v9; // [rsp+7Ch] [rbp-44h]
  void *v10; // [rsp+80h] [rbp-40h]
  void *Block; // [rsp+88h] [rbp-38h]
  _DWORD *v12; // [rsp+90h] [rbp-30h]
  _DWORD *v13; // [rsp+98h] [rbp-28h]
  __int64 centroids; // [rsp+A0h] [rbp-20h]
  int v15; // [rsp+ACh] [rbp-14h]
  int v16; // [rsp+B0h] [rbp-10h]
  int v17; // [rsp+B4h] [rbp-Ch]
  int j; // [rsp+B8h] [rbp-8h]
  int i; // [rsp+BCh] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v7 = 1036831949;
  v8[0] = 1058642330;
  v8[1] = 1041865114;
  v8[2] = 1060487823;
  v8[3] = 1034147594;
  v8[4] = 1063675494;
  v8[5] = 1042536202;
  v8[6] = 1062836634;
  v8[7] = 1045220557;
  v8[8] = 1050253722;
  v8[9] = 1048576000;
  v8[10] = 1056964608;
  v8[11] = 1047904911;
  v8[12] = 1036831949;
  v8[13] = 1050253722;
  v8[14] = 1045220557;
  v8[15] = 1051931443;
  v8[16] = 1050253722;
  v8[17] = 1055286886;
  v8[18] = 1045220557;
  v15 = 3;
  v17 = 0;
  centroids = create_centroids(3i64, 2i64);
  v13 = malloc(0x28ui64);
  v12 = malloc(0x28ui64);
  while ( 1 )
  {
    ++v17;
    for ( i = 0; i <= 9; *v4 = find_nearest(&v8[2 * i++ - 1], centroids, (unsigned int)v15, 2i64) )
      v4 = &v13[i];
    if ( v17 != 1 )
    {
      v16 = 0;
      for ( i = 0; i <= 9; ++i )
      {
        if ( v13[i] != v12[i] )
          ++v16;
      }
      if ( !v16 )
        break;
    }
    for ( i = 0; i <= 9; ++i )
      v12[i] = v13[i];
    Block = malloc(8i64 * v15);
    v10 = malloc(4i64 * v15);
    for ( i = 0; i < v15; ++i )
    {
      v5 = (void **)((char *)Block + 8 * i);
      *v5 = calloc(2ui64, 4ui64);
      *((_DWORD *)v10 + i) = 0;
    }
    for ( i = 0; i <= 9; ++i )
    {
      v9 = v13[i];
      for ( j = 0; j <= 1; ++j )
        *(float *)(*((_QWORD *)Block + v9) + 4i64 * j) = *(float *)&v8[2 * i - 1 + j]
                                                       + *(float *)(*((_QWORD *)Block + v9) + 4i64 * j);
      ++*((_DWORD *)v10 + v9);
    }
    for ( i = 0; i < v15; ++i )
    {
      for ( j = 0; j <= 1; ++j )
        *(float *)(*(_QWORD *)(8i64 * i + centroids) + 4i64 * j) = *(float *)(*((_QWORD *)Block + i) + 4i64 * j)
                                                                 / (float)*((int *)v10 + i);
    }
    for ( i = 0; i < v15; ++i )
      free(*((void **)Block + i));
    free(Block);
    free(v10);
  }
  printf("Final clustering:\n");
  for ( i = 0; i < v15; ++i )
  {
    printf("Cluster %d: ", (unsigned int)(i + 1));
    for ( j = 0; j <= 9; ++j )
    {
      if ( i == v13[j] )
        printf("(%f, %f) ", *(float *)&v8[2 * j - 1], *(float *)&v8[2 * j]);
    }
    printf("\n");
  }
  return 0;
}
// 140001671: using guessed type __int64 __fastcall find_nearest(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400016FF: using guessed type __int64 __fastcall create_centroids(_QWORD, _QWORD);
// 140001E30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=150 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature monitor ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define LOWER_BOUND -50
#define UPPER_BOUND 150
#define NUM_READINGS 10
#define MIN_ACCEPTABLE_TEMP 0
#define MAX_ACCEPTABLE_TEMP 100

float readings[NUM_READINGS];

float get_temperature_reading() {
    float temp_reading = (float) (rand() % (UPPER_BOUND - LOWER_BOUND + 1)) + LOWER_BOUND;
    return temp_reading;
}

float get_average_temperature() {
    float total = 0;
    for(int i = 0; i < NUM_READINGS; i++) {
        total += readings[i];
    }
    float average = total / NUM_READINGS;
    return average;
}

int main(void) {
    srand(time(0));
    printf("Welcome to the temperature monitor!\n\n");
    for(int i = 0; i < NUM_READINGS; i++) {
        float temp_reading = get_temperature_reading();
        readings[i] = temp_reading;
        printf("Temperature reading %d: %.2f °C\n", i+1, temp_reading);
    }
    printf("\n");
    float average_temp = get_average_temperature();
    printf("The average temperature reading is: %.2f °C\n", average_temp);
    if(average_temp < MIN_ACCEPTABLE_TEMP || average_temp > MAX_ACCEPTABLE_TEMP) {
        printf("ALERT: Average temperature is outside acceptable range!\n");
    } else {
        printf("Average temperature is within acceptable range.\n");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
double get_temperature_reading(void); // weak
double get_average_temperature(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

float readings[16]; // weak


//----- (000000014000166E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  unsigned int v4; // eax
  float v6; // [rsp+24h] [rbp-Ch]
  float v7; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4 = time(0i64);
  srand(v4);
  printf("Welcome to the temperature monitor!\n\n");
  for ( i = 0; i <= 9; ++i )
  {
    *(double *)v3.m128i_i64 = get_temperature_reading();
    v6 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
    readings[i] = v6;
    v3 = (__m128i)COERCE_UNSIGNED_INT64(v6);
    printf("Temperature reading %d: %.2f °C\n", (unsigned int)(i + 1), v6);
  }
  printf("\n");
  *(double *)v3.m128i_i64 = get_average_temperature();
  v7 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
  printf("The average temperature reading is: %.2f °C\n", v7);
  if ( v7 >= 0.0 && v7 <= 100.0 )
    printf("Average temperature is within acceptable range.\n");
  else
    printf("ALERT: Average temperature is outside acceptable range!\n");
  return 0;
}
// 1400016A9: variable 'v3' is possibly undefined
// 1400015B0: using guessed type double get_temperature_reading(void);
// 140001602: using guessed type double get_average_temperature(void);
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type float readings[16];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: User Input Sanitizer ; Style: beginner-friendly
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#define MAX_INPUT_LENGTH 100

// This function trims leading and trailing spaces from a string
char *trimString(char *inputString) {
    char *end;

    // Trim leading spaces
    while (isspace((unsigned char)*inputString)) {
        inputString++;
    }

    // If all spaces are trimmed
    if (*inputString == '\0') {
        return inputString;
    }

    // Trim trailing spaces
    end = inputString + strlen(inputString) - 1;
    while (end > inputString && isspace((unsigned char)*end)) {
        end--;
    }

    // Null terminate the trimmed string
    *(end+1) = '\0';

    return inputString;
}

// This function converts all letters to lowercase
char *toLowerCase(char *inputString) {
    int i = 0;

    while (inputString[i]) {
        inputString[i] = tolower(inputString[i]);
        i++;
    }

    return inputString;
}

// This function checks if a string contains only digits
int isNumeric(const char *inputString) {
    while (*inputString) {
        if (!isdigit(*inputString)) {
            return 0;
        }
        inputString++;
    }
    return 1;
}

// Main function that sanitizes user input
int main() {
    char userInput[MAX_INPUT_LENGTH];

    // Prompt user for input
    printf("Enter a string: ");
    fgets(userInput, MAX_INPUT_LENGTH, stdin);

    // Remove newline character
    userInput[strcspn(userInput, "\n")] = 0;

    // Trim leading and trailing spaces
    char *trimmedInput = trimString(userInput);

    // Convert all letters to lowercase
    char *lowercaseInput = toLowerCase(trimmedInput);

    // Check if input contains only digits
    if (isNumeric(lowercaseInput)) {
        printf("You entered a numeric string: %s\n", lowercaseInput);
    } else {
        printf("You entered a non-numeric string: %s\n", lowercaseInput);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall trimString(_QWORD); // weak
__int64 __fastcall toLowerCase(_QWORD); // weak
__int64 __fastcall isNumeric(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016C5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[112]; // [rsp+20h] [rbp-80h] BYREF
  const char *v6; // [rsp+90h] [rbp-10h]
  __int64 v7; // [rsp+98h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  v7 = trimString(Buffer);
  v6 = (const char *)toLowerCase(v7);
  if ( (unsigned int)isNumeric(v6) )
    printf("You entered a numeric string: %s\n", v6);
  else
    printf("You entered a non-numeric string: %s\n", v6);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall trimString(_QWORD);
// 140001625: using guessed type __int64 __fastcall toLowerCase(_QWORD);
// 14000168B: using guessed type __int64 __fastcall isNumeric(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016C5: using guessed type char Buffer[112];

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>

int main()
{
    FILE *fp;
    char filename[20], ch;
    int count = 0;
    
    printf("Enter the name of file: ");
    scanf("%s", filename);
    
    // open the file
    fp = fopen(filename, "r");
    if(fp == NULL) // if file not found, exit the program
    {
        printf("File not found!\n");
        exit(0);
    }
    
    // read the file character by character and count the number of lines
    while ((ch = fgetc(fp)) != EOF)
    {
        if (ch == '\n')
            count++;
    }
    
    // close the file
    fclose(fp);
    
    printf("The file %s has %d lines.\n", filename, count);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char FileName[31]; // [rsp+20h] [rbp-30h] BYREF
  char v5; // [rsp+3Fh] [rbp-11h]
  FILE *Stream; // [rsp+40h] [rbp-10h]
  unsigned int v7; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 0;
  printf("Enter the name of file: ");
  scanf("%s", FileName);
  Stream = fopen(FileName, "r");
  if ( !Stream )
  {
    printf("File not found!\n");
    exit(0);
  }
  while ( 1 )
  {
    v5 = fgetc(Stream);
    if ( v5 == -1 )
      break;
    if ( v5 == 10 )
      ++v7;
  }
  fclose(Stream);
  printf("The file %s has %d lines.\n", FileName, v7);
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Poker Game ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DECK_SIZE 52
#define NUM_CARDS 2

int random_card();
int get_card_value(int card);
int determine_hand_value(int hand[], int num_cards);

int main() {
    int deck[DECK_SIZE]; // Array to represent the deck of cards
    int player_hand[NUM_CARDS]; // Array to hold the cards in the player's hand
    int dealer_hand[NUM_CARDS]; // Array to hold the cards in the dealer's hand
    int player_total, dealer_total;
    int player_score = 0, dealer_score = 0;
    int num_games = 1;
    char input;

    srand(time(NULL)); // Seed the random number generator

    while (1) { // Loop to play multiple games
        printf("Game %d:\n", num_games);
        num_games++;

        // Initialize the deck of cards
        for (int i = 0; i < DECK_SIZE; i++) {
            deck[i] = i;
        }

        // Shuffle the deck
        for (int i = 0; i < DECK_SIZE; i++) {
            int j = rand() % DECK_SIZE;
            int temp = deck[i];
            deck[i] = deck[j];
            deck[j] = temp;
        }

        // Deal the cards
        player_hand[0] = deck[0];
        dealer_hand[0] = deck[1];
        player_hand[1] = deck[2];
        dealer_hand[1] = deck[3];

        // Print the dealer's face up card
        printf("Dealer's face up card: %d\n", get_card_value(dealer_hand[0]));

        // Ask the player for their move
        printf("Your hand: %d, %d\n", get_card_value(player_hand[0]), get_card_value(player_hand[1]));
        printf("What do you want to do? (h)it or (s)tand? ");

        // Get the player's move
        input = getchar();
        while (input != 'h' && input != 's') {
            input = getchar();
        }
        while (getchar() != '\n'); // Clear any extra input

        // Player hits
        if (input == 'h') {
            player_hand[2] = deck[4];

            // Determine the value of the player's hand
            player_total = determine_hand_value(player_hand, 3);

            // Print the player's hand and total
            printf("Your hand: %d, %d, %d\n", get_card_value(player_hand[0]), get_card_value(player_hand[1]), get_card_value(player_hand[2]));
            printf("Your total: %d\n", player_total);

            // Determine the value of the dealer's hand
            dealer_total = determine_hand_value(dealer_hand, 2);

            // Dealer hits until they have a total of at least 17
            while (dealer_total < 17) {
                dealer_hand[2] = deck[5];
                dealer_total = determine_hand_value(dealer_hand, 3);
            }

            // Print the dealer's hand and total
            printf("Dealer's hand: %d, %d, %d\n", get_card_value(dealer_hand[0]), get_card_value(dealer_hand[1]), get_card_value(dealer_hand[2]));
            printf("Dealer's total: %d\n", dealer_total);

            // Determine the winner
            if ((player_total > dealer_total && player_total <= 21) || (dealer_total > 21 && player_total <= 21)) {
                printf("You win!\n");
                player_score++;
            }
            else if ((dealer_total > player_total && dealer_total <= 21) || (player_total > 21 && dealer_total <= 21)) {
                printf("Dealer wins!\n");
                dealer_score++;
            }
            else {
                printf("Draw!\n");
            }
        }
        // Player stands
        else if (input == 's') {
            // Determine the value of the player's hand
            player_total = determine_hand_value(player_hand, 2);

            // Determine the value of the dealer's hand
            dealer_total = determine_hand_value(dealer_hand, 2);

            // Dealer hits until they have a total of at least 17
            while (dealer_total < 17) {
                dealer_hand[2] = deck[4];
                dealer_total = determine_hand_value(dealer_hand, 3);
            }

            // Print the dealer's hand and total
            printf("Dealer's hand: %d, %d, %d\n", get_card_value(dealer_hand[0]), get_card_value(dealer_hand[1]), get_card_value(dealer_hand[2]));
            printf("Dealer's total: %d\n", dealer_total);

            // Determine the winner
            if ((player_total > dealer_total && player_total <= 21) || (dealer_total > 21 && player_total <= 21)) {
                printf("You win!\n");
                player_score++;
            }
            else if ((dealer_total > player_total && dealer_total <= 21) || (player_total > 21 && dealer_total <= 21)) {
                printf("Dealer wins!\n");
                dealer_score++;
            }
            else {
                printf("Draw!\n");
            }
        }

        // Print the current score
        printf("Score: You %d, Dealer %d\n", player_score, dealer_score);

        // Ask the player if they want to play again
        printf("Play again? (y/n) ");
        input = getchar();
        while (input != 'y' && input != 'n') {
            input = getchar();
        }
        while (getchar() != '\n'); // Clear any extra input

        if (input == 'n') {
            break;
        }

        printf("\n");
    }

    return 0;
}

// Function to get a random card from the deck
int random_card() {
    static int card_index = 0;
    return card_index++;
}

// Function to get the value of a card
int get_card_value(int card) {
    int value = (card % 13) + 1;
    if (value > 10) {
        value = 10;
    }
    return value;
}

// Function to determine the total value of a hand
int determine_hand_value(int hand[], int num_cards) {
    int total = 0;
    int num_aces = 0;

    for (int i = 0; i < num_cards; i++) {
        int card_value = get_card_value(hand[i]);
        if (card_value == 1) {
            num_aces++;
        }
        total += card_value;
    }

    // If there are aces in the hand, adjust the total for the highest possible value
    while (num_aces > 0 && total + 10 <= 21) {
        total += 10;
        num_aces--;
    }

    return total;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall get_card_value(_QWORD); // weak
__int64 __fastcall determine_hand_value(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int card_value; // eax
  unsigned int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // esi
  unsigned int v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // esi
  unsigned int v11; // ebx
  unsigned int v12; // eax
  unsigned int v13; // esi
  unsigned int v14; // ebx
  unsigned int v15; // eax
  unsigned int v17; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v18; // [rsp+24h] [rbp-5Ch]
  unsigned int v19; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v20; // [rsp+2Ch] [rbp-54h]
  unsigned int v21; // [rsp+30h] [rbp-50h]
  unsigned int v22; // [rsp+34h] [rbp-4Ch]
  unsigned int v23; // [rsp+38h] [rbp-48h]
  unsigned int v24; // [rsp+3Ch] [rbp-44h]
  unsigned int v25; // [rsp+40h] [rbp-40h]
  unsigned int v26; // [rsp+44h] [rbp-3Ch]
  unsigned int v27; // [rsp+108h] [rbp+88h]
  int v28; // [rsp+10Ch] [rbp+8Ch]
  int v29; // [rsp+110h] [rbp+90h]
  int j; // [rsp+114h] [rbp+94h]
  int i; // [rsp+118h] [rbp+98h]
  char k; // [rsp+11Fh] [rbp+9Fh]
  unsigned int v33; // [rsp+120h] [rbp+A0h]
  unsigned int v34; // [rsp+124h] [rbp+A4h]
  unsigned int v35; // [rsp+128h] [rbp+A8h]
  int m; // [rsp+12Ch] [rbp+ACh]

  _main(argc, argv, envp);
  v35 = 0;
  v34 = 0;
  v33 = 1;
  v3 = time(0i64);
  srand(v3);
  while ( 1 )
  {
    printf("Game %d:\n", v33++);
    for ( i = 0; i <= 51; ++i )
      *(&v21 + i) = i;
    for ( j = 0; j <= 51; ++j )
    {
      v28 = rand() % 52;
      v27 = *(&v21 + j);
      *(&v21 + j) = *(&v21 + v28);
      *(&v21 + v28) = v27;
    }
    v19 = v21;
    v17 = v22;
    v20 = v23;
    v18 = v24;
    card_value = get_card_value(v22);
    printf("Dealer's face up card: %d\n", card_value);
    v5 = get_card_value(v20);
    v6 = get_card_value(v19);
    printf("Your hand: %d, %d\n", v6, v5);
    printf("What do you want to do? (h)it or (s)tand? ");
    for ( k = getchar(); k != 104 && k != 115; k = getchar() )
      ;
    while ( getchar() != 10 )
      ;
    if ( k != 104 )
    {
      if ( k != 115 )
        goto LABEL_43;
      v29 = determine_hand_value(&v19, 2i64);
      for ( m = determine_hand_value(&v17, 2i64); m <= 16; m = determine_hand_value(&v17, 3i64) )
        v19 = v25;
      v13 = get_card_value(v19);
      v14 = get_card_value(v18);
      v15 = get_card_value(v17);
      printf("Dealer's hand: %d, %d, %d\n", v15, v14, v13);
      printf("Dealer's total: %d\n", (unsigned int)m);
      if ( v29 > m && v29 <= 21 || m > 21 && v29 <= 21 )
        goto LABEL_21;
      if ( (m <= v29 || m > 21) && (v29 <= 21 || m > 21) )
      {
LABEL_42:
        printf("Draw!\n");
        goto LABEL_43;
      }
LABEL_26:
      printf("Dealer wins!\n");
      ++v34;
      goto LABEL_43;
    }
    v21 = v25;
    v29 = determine_hand_value(&v19, 3i64);
    v7 = get_card_value(v21);
    v8 = get_card_value(v20);
    v9 = get_card_value(v19);
    printf("Your hand: %d, %d, %d\n", v9, v8, v7);
    printf("Your total: %d\n", (unsigned int)v29);
    for ( m = determine_hand_value(&v17, 2i64); m <= 16; m = determine_hand_value(&v17, 3i64) )
      v19 = v26;
    v10 = get_card_value(v19);
    v11 = get_card_value(v18);
    v12 = get_card_value(v17);
    printf("Dealer's hand: %d, %d, %d\n", v12, v11, v10);
    printf("Dealer's total: %d\n", (unsigned int)m);
    if ( (v29 <= m || v29 > 21) && (m <= 21 || v29 > 21) )
    {
      if ( (m <= v29 || m > 21) && (v29 <= 21 || m > 21) )
        goto LABEL_42;
      goto LABEL_26;
    }
LABEL_21:
    printf("You win!\n");
    ++v35;
LABEL_43:
    printf("Score: You %d, Dealer %d\n", v35, v34);
    printf("Play again? (y/n) ");
    for ( k = getchar(); k != 121 && k != 110; k = getchar() )
      ;
    while ( getchar() != 10 )
      ;
    if ( k == 110 )
      return 0;
    printf("\n");
  }
}
// 140001AFF: using guessed type __int64 __fastcall get_card_value(_QWORD);
// 140001B55: using guessed type __int64 __fastcall determine_hand_value(_QWORD, _QWORD);
// 140001C90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Haunted House Simulator ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL));
    int room = 1;
    int choice;
    int ghost = 0;
    int skeleton = 0;
    int spider = 0;
    int treasure = 0;

    printf("Welcome to the Haunted House!\n\n");
    printf("You find yourself standing outside a large, old house.\n");
    printf("Do you dare to enter? (1: yes / 2: no): ");
    scanf("%d", &choice);

    if (choice == 1) {
        printf("You hesitantly push the door open and step inside.\n");
        printf("The door slams shut behind you, and you hear it lock.\n\n");

        while (room <= 6) {
            printf("You are in Room %d. Choose your next move: \n", room);
            printf("1: Go forward\n2: Turn left\n3: Turn right\n4: Go back\n\n");
            scanf("%d", &choice);

            switch (choice) {
                case 1:
                    printf("You move forward and enter Room %d.\n", room+1);
                    room++;
                    break;
                case 2:
                    printf("You turn left and enter Room %d.\n", room+3);
                    room += 3;
                    break;
                case 3:
                    printf("You turn right and enter Room %d.\n", room+2);
                    room += 2;
                    break;
                case 4:
                    printf("You turn around and enter Room %d.\n", room-1);
                    room--;
                    break;
                default:
                    printf("Invalid choice. Try again.\n\n");
            }

            if (ghost == 1 && skeleton == 1 && spider == 1 && treasure == 1) {
                printf("\nYou have completed the game!\nCongratulations, you have found the treasure and escaped alive!\n");
                exit(0);
            }

            int event = rand() % 10 + 1;
            if (event <= 4) {
                printf("You hear strange noises...\n");

                int creature = rand() % 3 + 1;
                switch (creature) {
                    case 1:
                        if (ghost == 0) {
                            printf("A ghost appears out of nowhere and scares you!\n");
                            ghost = 1;
                        } else {
                            printf("The ghost appears again, but you are no longer scared.\n");
                        }
                        break;
                    case 2:
                        if (skeleton == 0) {
                            printf("A skeleton rises from the ground and attacks you!\n");
                            skeleton = 1;
                        } else {
                            printf("The skeleton is still there, but you have already defeated it.\n");
                        }
                        break;
                    case 3:
                        if (spider == 0) {
                            printf("A giant spider drops down from the ceiling and attacks you!\n");
                            spider = 1;
                        } else {
                            printf("The spider is still there, but you have already defeated it.\n");
                        }
                        break;
                }
            } else if (event == 10) {
                if (treasure == 0) {
                    printf("Congratulations! You have found the treasure!\n");
                    treasure = 1;
                } else {
                    printf("You have already found the treasure in this room.\n");
                }
            }
        }

        printf("\nYou have been trapped in the house forever...\nGAME OVER.\n");
    } else {
        printf("You chicken out and leave.\nGAME OVER.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // edx
  int v6; // [rsp+20h] [rbp-20h] BYREF
  int v7; // [rsp+24h] [rbp-1Ch]
  int v8; // [rsp+28h] [rbp-18h]
  int v9; // [rsp+2Ch] [rbp-14h]
  int v10; // [rsp+30h] [rbp-10h]
  int v11; // [rsp+34h] [rbp-Ch]
  int v12; // [rsp+38h] [rbp-8h]
  unsigned int v13; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v13 = 1;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  printf("Welcome to the Haunted House!\n\n");
  printf("You find yourself standing outside a large, old house.\n");
  printf("Do you dare to enter? (1: yes / 2: no): ");
  scanf("%d", &v6);
  if ( v6 != 1 )
  {
    printf("You chicken out and leave.\nGAME OVER.\n");
    return 0;
  }
  printf("You hesitantly push the door open and step inside.\n");
  printf("The door slams shut behind you, and you hear it lock.\n\n");
  while ( (int)v13 <= 6 )
  {
    printf("You are in Room %d. Choose your next move: \n", v13);
    printf("1: Go forward\n2: Turn left\n3: Turn right\n4: Go back\n\n");
    scanf("%d", &v6);
    if ( v6 == 4 )
    {
      printf("You turn around and enter Room %d.\n", --v13);
    }
    else
    {
      if ( v6 > 4 )
        goto LABEL_13;
      switch ( v6 )
      {
        case 3:
          printf("You turn right and enter Room %d.\n", v13 + 2);
          v13 += 2;
          break;
        case 1:
          printf("You move forward and enter Room %d.\n", ++v13);
          break;
        case 2:
          printf("You turn left and enter Room %d.\n", v13 + 3);
          v13 += 3;
          break;
        default:
LABEL_13:
          printf("Invalid choice. Try again.\n\n");
          break;
      }
    }
    if ( v12 == 1 && v11 == 1 && v10 == 1 && v9 == 1 )
    {
      printf("\nYou have completed the game!\nCongratulations, you have found the treasure and escaped alive!\n");
      exit(0);
    }
    v8 = rand() % 10 + 1;
    if ( v8 > 4 )
    {
      if ( v8 == 10 )
      {
        if ( v9 )
        {
          printf("You have already found the treasure in this room.\n");
        }
        else
        {
          printf("Congratulations! You have found the treasure!\n");
          v9 = 1;
        }
      }
    }
    else
    {
      printf("You hear strange noises...\n");
      v4 = rand() % 3;
      v7 = v4 + 1;
      if ( v4 == 2 )
      {
        if ( v10 )
        {
          printf("The spider is still there, but you have already defeated it.\n");
        }
        else
        {
          printf("A giant spider drops down from the ceiling and attacks you!\n");
          v10 = 1;
        }
      }
      else if ( v7 <= 3 )
      {
        if ( v7 == 1 )
        {
          if ( v12 )
          {
            printf("The ghost appears again, but you are no longer scared.\n");
          }
          else
          {
            printf("A ghost appears out of nowhere and scares you!\n");
            v12 = 1;
          }
        }
        else if ( v7 == 2 )
        {
          if ( v11 )
          {
            printf("The skeleton is still there, but you have already defeated it.\n");
          }
          else
          {
            printf("A skeleton rises from the ground and attacks you!\n");
            v11 = 1;
          }
        }
      }
    }
  }
  printf("\nYou have been trapped in the house forever...\nGAME OVER.\n");
  return 0;
}
// 140001706: conditional instruction was optimized away because %var_20.4<3
// 140001A20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Online Examination System ; Style: paranoid
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define constants for array sizes
#define MAX_QUESTIONS 100
#define MAX_ANSWER_LENGTH 20
#define MAX_NAME_LENGTH 50

// Define struct for questions
typedef struct {
    int question_number;
    char question_text[MAX_ANSWER_LENGTH];
    char correct_answer[MAX_ANSWER_LENGTH];
    int points;
} question;

// Define struct for student results
typedef struct {
    char name[MAX_NAME_LENGTH];
    int score;
} result;

// Declare array of questions and results
question exam_questions[MAX_QUESTIONS];
result exam_results[MAX_QUESTIONS];

// Declare function to print exam questions
void print_exam_questions() {
    for (int i = 0; i < MAX_QUESTIONS; i++) {
        printf("Question %d: %s\n", exam_questions[i].question_number, exam_questions[i].question_text);
    }
}

// Declare function to grade exam
void grade_exam() {
    // Prompt for student name
    char name[MAX_NAME_LENGTH];
    printf("Please enter your name: ");
    scanf("%[^\n]%*c", name);
    
    // Declare variables for grading
    int total_score = 0;
    int num_correct = 0;
    
    // Loop through each question
    for (int i = 0; i < MAX_QUESTIONS; i++) {
        // Prompt for answer
        printf("Question %d: %s\n", exam_questions[i].question_number, exam_questions[i].question_text);
        printf("Enter your answer: ");
        char answer[MAX_ANSWER_LENGTH];
        scanf("%s", answer);
        
        // Check if answer is correct
        if (strcmp(answer, exam_questions[i].correct_answer) == 0) {
            printf("Correct!\n");
            total_score += exam_questions[i].points;
            num_correct++;
        } else {
            printf("Incorrect.\n");
        }
    }
    
    // Save student results
    strcpy(exam_results[num_correct].name, name);
    exam_results[num_correct].score = total_score;
    
    // Display results
    printf("You answered %d questions correctly for a total score of %d.\n", num_correct, total_score);
}

int main() {
    // Initialize exam questions
    memset(exam_questions, 0, sizeof(exam_questions));
    exam_questions[0].question_number = 1;
    strcpy(exam_questions[0].question_text, "What is the capital of France?");
    strcpy(exam_questions[0].correct_answer, "Paris");
    exam_questions[0].points = 1;
    
    exam_questions[1].question_number = 2;
    strcpy(exam_questions[1].question_text, "What is the largest continent?");
    strcpy(exam_questions[1].correct_answer, "Asia");
    exam_questions[1].points = 1;
    
    exam_questions[2].question_number = 3;
    strcpy(exam_questions[2].question_text, "What color is the sky?");
    strcpy(exam_questions[2].correct_answer, "Blue");
    exam_questions[2].points = 1;
    
    exam_questions[3].question_number = 4;
    strcpy(exam_questions[3].question_text, "What is the square root of 64?");
    strcpy(exam_questions[3].correct_answer, "8");
    exam_questions[3].points = 1;
    
    exam_questions[4].question_number = 5;
    strcpy(exam_questions[4].question_text, "What is 2 + 2?");
    strcpy(exam_questions[4].correct_answer, "4");
    exam_questions[4].points = 1;
    
    // Print exam questions
    print_exam_questions();
    
    // Grade exam
    grade_exam();
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 print_exam_questions(void); // weak
__int64 grade_exam(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memset(void *, int Val, size_t Size);

//-------------------------------------------------------------------------
// Data declarations

int exam_questions; // weak
__int64 qword_140019044; // weak
int dword_14001905C; // weak
__int16 word_140019060; // weak
int dword_14001906C; // weak
int dword_140019070; // weak
__int64 qword_140019074; // weak
int dword_14001908C; // weak
__int16 word_140019090; // weak
int dword_14001909C; // weak
int dword_1400190A0; // weak
__int64 qword_1400190A4; // weak
int dword_1400190CC; // weak
int dword_1400190D0; // weak
__int64 qword_1400190D4; // weak
__int64 qword_1400190E4; // weak
int dword_1400190EC; // weak
int dword_1400190FC; // weak
int dword_140019100; // weak
__int64 qword_140019104; // weak
__int16 word_140019118; // weak
int dword_14001912C; // weak


//----- (0000000140001815) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  memset(&exam_questions, 0, 0x12C0ui64);
  exam_questions = 1;
  strcpy((char *)&qword_140019044, "What is the capital Paris");
  HIWORD(dword_14001905C) = 25454;
  strcpy((char *)&word_140019060, "e?");
  dword_14001906C = 1;
  dword_140019070 = 2;
  strcpy((char *)&qword_140019074, "What is the largest Asia");
  BYTE1(dword_14001908C) = 110;
  HIWORD(dword_14001908C) = 28261;
  strcpy((char *)&word_140019090, "t?");
  dword_14001909C = 1;
  dword_1400190A0 = 3;
  strcpy((char *)&qword_1400190A4, "What color is the skBlue");
  dword_1400190CC = 1;
  dword_1400190D0 = 4;
  strcpy((char *)&qword_1400190D4, "What is the square r8");
  HIWORD(qword_1400190E4) = 8308;
  strcpy((char *)&dword_1400190EC, "of 64?");
  dword_1400190FC = 1;
  dword_140019100 = 5;
  strcpy((char *)&qword_140019104, "What is 2 + 2?");
  word_140019118 = 52;
  dword_14001912C = 1;
  print_exam_questions();
  grade_exam();
  return 0;
}
// 1400015E2: using guessed type __int64 print_exam_questions(void);
// 14000165A: using guessed type __int64 grade_exam(void);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019040: using guessed type int exam_questions;
// 140019044: using guessed type __int64 qword_140019044;
// 14001905C: using guessed type int dword_14001905C;
// 140019060: using guessed type __int16 word_140019060;
// 14001906C: using guessed type int dword_14001906C;
// 140019070: using guessed type int dword_140019070;
// 140019074: using guessed type __int64 qword_140019074;
// 14001908C: using guessed type int dword_14001908C;
// 140019090: using guessed type __int16 word_140019090;
// 14001909C: using guessed type int dword_14001909C;
// 1400190A0: using guessed type int dword_1400190A0;
// 1400190A4: using guessed type __int64 qword_1400190A4;
// 1400190CC: using guessed type int dword_1400190CC;
// 1400190D0: using guessed type int dword_1400190D0;
// 1400190D4: using guessed type __int64 qword_1400190D4;
// 1400190E4: using guessed type __int64 qword_1400190E4;
// 1400190EC: using guessed type int dword_1400190EC;
// 1400190FC: using guessed type int dword_1400190FC;
// 140019100: using guessed type int dword_140019100;
// 140019104: using guessed type __int64 qword_140019104;
// 140019118: using guessed type __int16 word_140019118;
// 14001912C: using guessed type int dword_14001912C;

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image to ASCII art converter ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_WIDTH 100
#define MAX_HEIGHT 100

char image[MAX_HEIGHT][MAX_WIDTH];

char ascii_chars[] = {' ', '.', ':', '-', '=', '+', '*', '#', '%', '@'};

int max_gray_level;

void read_image(char *filename) {
    FILE *fp;
    char buffer[100];

    fp = fopen(filename, "r");

    // Skip the first two lines
    fgets(buffer, 100, fp);
    fgets(buffer, 100, fp);

    // Read the image information
    fscanf(fp, "%d %d\n", &max_gray_level, &max_gray_level);

    // Read the image pixels
    for (int i = 0; i < MAX_HEIGHT; i++) {
        for (int j = 0; j < MAX_WIDTH; j++) {
            int pixel;
            fscanf(fp, "%d", &pixel);
            image[i][j] = pixel;
        }
    }

    fclose(fp);
}

void convert_to_ascii() {
    for (int i = 0; i < MAX_HEIGHT; i++) {
        for (int j = 0; j < MAX_WIDTH; j++) {
            int gray_level = image[i][j] * 10 / max_gray_level;

            if (gray_level >= 10) {
                gray_level = 9;
            }

            char ascii_char = ascii_chars[gray_level];

            printf("%c", ascii_char);
        }

        printf("\n");
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        exit(1);
    }
    
    read_image(argv[1]);

    convert_to_ascii();

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall read_image(_QWORD); // weak
__int64 convert_to_ascii(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400017B7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  if ( argc != 2 )
  {
    printf("Usage: %s <filename>\n", *argv);
    exit(1);
  }
  read_image(argv[1]);
  convert_to_ascii();
  return 0;
}
// 1400015D4: using guessed type __int64 __fastcall read_image(_QWORD);
// 1400016E1: using guessed type __int64 convert_to_ascii(void);
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Airport Baggage Handling Simulation ; Style: energetic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    printf("Welcome to the Airport Baggage Handling Simulation!\n");

    // Set up variables for the simulation
    int total_waiting_time = 0;
    int total_bags_processed = 0;
    int max_waiting_time = 0;
    srand(time(NULL));

    // Simulation loop runs five times
    for (int i = 0; i < 5; i++) {

        printf("\nRunning simulation %d...\n", i + 1);

        // Generate random number of bags between 1 and 10
        int num_bags = rand() % 10 + 1;
        printf("Processing %d bags...\n", num_bags);

        // Set up variables for this simulation run
        int waiting_time = 0;
        int bags_processed = 0;

        // Loop through bags
        for (int j = 0; j < num_bags; j++) {

            // Generate random processing time between 1 and 5 seconds
            int processing_time = rand() % 5 + 1;

            // Add processing time to waiting time
            waiting_time += processing_time;

            // Print message for this bag
            printf("Processing bag %d (time: %d seconds)...\n", j + 1, processing_time);

            // Increment counter for bags processed
            bags_processed++;
        }

        // Print results for this simulation run
        printf("\nBags processed: %d\n", bags_processed);
        printf("Total waiting time: %d seconds\n", waiting_time);

        // Add results for this simulation run to total results
        total_bags_processed += bags_processed;
        total_waiting_time += waiting_time;

        // Keep track of the maximum waiting time
        if (waiting_time > max_waiting_time) {
            max_waiting_time = waiting_time;
        }
    }

    // Print total results for all simulation runs
    printf("\nOverall results:\n");
    printf("Total bags processed: %d\n", total_bags_processed);
    printf("Average waiting time: %d seconds\n", total_waiting_time / 5);
    printf("Maximum waiting time: %d seconds\n", max_waiting_time);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-24h]
  int v6; // [rsp+30h] [rbp-20h]
  int j; // [rsp+34h] [rbp-1Ch]
  unsigned int v8; // [rsp+38h] [rbp-18h]
  unsigned int v9; // [rsp+3Ch] [rbp-14h]
  int i; // [rsp+40h] [rbp-10h]
  unsigned int v11; // [rsp+44h] [rbp-Ch]
  unsigned int v12; // [rsp+48h] [rbp-8h]
  int v13; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Airport Baggage Handling Simulation!\n");
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 4; ++i )
  {
    printf("\nRunning simulation %d...\n", (unsigned int)(i + 1));
    v6 = rand() % 10 + 1;
    printf("Processing %d bags...\n", (unsigned int)v6);
    v9 = 0;
    v8 = 0;
    for ( j = 0; j < v6; ++j )
    {
      v5 = rand() % 5 + 1;
      v9 += v5;
      printf("Processing bag %d (time: %d seconds)...\n", (unsigned int)(j + 1), v5);
      ++v8;
    }
    printf("\nBags processed: %d\n", v8);
    printf("Total waiting time: %d seconds\n", v9);
    v12 += v8;
    v13 += v9;
    if ( (int)v9 > (int)v11 )
      v11 = v9;
  }
  printf("\nOverall results:\n");
  printf("Total bags processed: %d\n", v12);
  printf("Average waiting time: %d seconds\n", (unsigned int)(v13 / 5));
  printf("Maximum waiting time: %d seconds\n", v11);
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Phone Book ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure definition for contact in phone book
struct contact {
    char name[50];
    char number[12];
    int id;
};

// Function declarations
void displayMenu();
int getNextId();
void addContact(struct contact[], int*);
void searchContact(struct contact[], int);
void editContact(struct contact[], int);
void deleteContact(struct contact[], int*);

int main() {

    // Initialize phone book with capacity of 100 contacts
    struct contact phoneBook[100];
    int numOfContacts = 0;

    // Display menu and handle user choices until they exit
    int choice = 0;
    do {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                addContact(phoneBook, &numOfContacts);
                break;
            case 2:
                searchContact(phoneBook, numOfContacts);
                break;
            case 3:
                editContact(phoneBook, numOfContacts);
                break;
            case 4:
                deleteContact(phoneBook, &numOfContacts);
                break;
            case 5:
                printf("Thank you for using the phone book.\n\n");
                break;
            default:
                printf("Invalid choice. Please try again.\n\n");
                break;
        }
    } while (choice != 5);

    return 0;
}

// Function to display the menu of choices
void displayMenu() {
    printf("Phone Book\n");
    printf("-----------\n");
    printf("1. Add contact\n");
    printf("2. Search for contact\n");
    printf("3. Edit existing contact\n");
    printf("4. Delete contact\n");
    printf("5. Quit\n");
    printf("\nEnter your choice: ");
}

// Function to generate the next available ID for new contacts
int getNextId() {
    static int id = 0;
    return ++id;
}

// Function to add a new contact to the phone book
void addContact(struct contact phoneBook[], int *numOfContacts) {
    // Check if phone book is already full
    if (*numOfContacts == 100) {
        printf("Phone book is full. Cannot add new contact.\n\n");
        return;
    }

    // Create a new contact
    struct contact newContact;
    printf("Enter contact name: ");
    scanf("%s", newContact.name);
    printf("Enter contact number: ");
    scanf("%s", newContact.number);
    newContact.id = getNextId();

    // Add new contact to phone book
    phoneBook[*numOfContacts] = newContact;
    (*numOfContacts)++;

    printf("Contact added successfully.\n\n");
}

// Function to search for a contact by name or number
void searchContact(struct contact phoneBook[], int numOfContacts) {
    // Get search query from user
    char query[50];
    printf("Enter name or number to search: ");
    scanf("%s", query);

    // Search for contact
    printf("Search Results:\n");
    int resultsFound = 0;
    for (int i = 0; i < numOfContacts; i++) {
        if (strstr(phoneBook[i].name, query) != NULL || strstr(phoneBook[i].number, query) != NULL) {
            printf("%d. Name: %s - Number: %s\n", resultsFound+1, phoneBook[i].name, phoneBook[i].number);
            resultsFound++;
        }
    }

    // Display message if no results were found
    if (resultsFound == 0) {
        printf("No results found.\n");
    }

    printf("\n");
}

// Function to edit an existing contact
void editContact(struct contact phoneBook[], int numOfContacts) {
    // Get contact ID from user
    int contactId;
    printf("Enter ID of contact to edit: ");
    scanf("%d", &contactId);

    // Find contact with matching ID
    struct contact *contactToEdit = NULL;
    for (int i = 0; i < numOfContacts; i++) {
        if (phoneBook[i].id == contactId) {
            contactToEdit = &phoneBook[i];
            break;
        }
    }

    // Display error message if contact was not found
    if (contactToEdit == NULL) {
        printf("Contact with ID %d not found.\n\n", contactId);
        return;
    }

    // Edit contact
    printf("Enter new name (or leave blank to keep current): ");
    char newName[50];
    fflush(stdin);
    fgets(newName, 50, stdin);
    newName[strcspn(newName, "\r\n")] = 0; // Remove newline character at end of string

    if (strcmp(newName, "") != 0) {
        strcpy(contactToEdit->name, newName);
    }

    printf("Enter new number (or leave blank to keep current): ");
    char newNumber[12];
    fflush(stdin);
    fgets(newNumber, 12, stdin);
    newNumber[strcspn(newNumber, "\r\n")] = 0; // Remove newline character at end of string

    if (strcmp(newNumber, "") != 0) {
        strcpy(contactToEdit->number, newNumber);
    }

    printf("Contact edited successfully.\n\n");
}

// Function to delete an existing contact
void deleteContact(struct contact phoneBook[], int *numOfContacts) {
    // Get contact ID from user
    int contactId;
    printf("Enter ID of contact to delete: ");
    scanf("%d", &contactId);

    // Find index of contact with matching ID
    int indexToDelete = -1;
    for (int i = 0; i < *numOfContacts; i++) {
        if (phoneBook[i].id == contactId) {
            indexToDelete = i;
            break;
        }
    }

    // Display error message if contact was not found
    if (indexToDelete == -1) {
        printf("Contact with ID %d not found.\n\n", contactId);
        return;
    }

    // Shift all contacts after the one to be deleted back one index
    for (int i = indexToDelete; i < (*numOfContacts)-1; i++) {
        phoneBook[i] = phoneBook[i+1];
    }

    // Decrement number of contacts in phone book
    (*numOfContacts)--;

    printf("Contact deleted successfully.\n\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 displayMenu(void); // weak
__int64 __fastcall addContact(_QWORD, _QWORD); // weak
__int64 __fastcall searchContact(_QWORD, _QWORD); // weak
__int64 __fastcall editContact(_QWORD, _QWORD); // weak
__int64 __fastcall deleteContact(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[6800]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  v4 = 0;
  do
  {
    displayMenu();
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        addContact(v6, &v5);
        break;
      case 2:
        searchContact(v6, v5);
        break;
      case 3:
        editContact(v6, v5);
        break;
      case 4:
        deleteContact(v6, &v5);
        break;
      case 5:
        printf("Thank you for using the phone book.\n\n");
        break;
      default:
        printf("Invalid choice. Please try again.\n\n");
        break;
    }
  }
  while ( v4 != 5 );
  return 0;
}
// 1400016D1: using guessed type __int64 displayMenu(void);
// 140001773: using guessed type __int64 __fastcall addContact(_QWORD, _QWORD);
// 140001887: using guessed type __int64 __fastcall searchContact(_QWORD, _QWORD);
// 1400019E1: using guessed type __int64 __fastcall editContact(_QWORD, _QWORD);
// 140001BB2: using guessed type __int64 __fastcall deleteContact(_QWORD, _QWORD);
// 140001DE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System boot optimizer ; Style: complete
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void printHeader()
{
    printf("\n********************************\n");
    printf("\tSystem Boot Optimizer\n");
    printf("********************************\n\n");
}

void optimizeBoot()
{
    // Method to optimize the boot process
    printf("Optimizing the boot process...\n\n");
    // Your optimization code goes here
}

int main()
{
    char password[10] = "pass1234";
    char input[10];

    printHeader();

    printf("Enter the password to optimize the boot process: ");
    fgets(input, 10, stdin);
    if (strcmp(input, password) == 0)
    {
        optimizeBoot();
        printf("Boot process optimized successfully.\n");
    }
    else
    {
        printf("Incorrect password. Boot process optimization aborted.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 printHeader(void); // weak
__int64 optimizeBoot(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015EB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[10]; // [rsp+2Ch] [rbp-14h] BYREF
  char Str2[10]; // [rsp+36h] [rbp-Ah] BYREF

  _main(argc, argv, envp);
  strcpy(Str2, "pass1234");
  Str2[9] = 0;
  printHeader();
  printf("Enter the password to optimize the boot process: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 10, v3);
  if ( !strcmp(Buffer, Str2) )
  {
    optimizeBoot();
    printf("Boot process optimized successfully.\n");
  }
  else
  {
    printf("Incorrect password. Boot process optimization aborted.\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 printHeader(void);
// 1400015CD: using guessed type __int64 optimizeBoot(void);
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: multiplayer
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int binarySearch(int arr[], int l, int r, int x){
    while(l <= r){
        int mid = l + (r-l)/2;
 
        if(arr[mid] == x)
            return mid;
 
        if(arr[mid] < x)
            l = mid + 1;

        else
            r = mid - 1;
    }

    return -1;
}

int* generateRandomNumbers(int n){
    int *arr = malloc(n * sizeof(int));
    srand(time(NULL));
    for(int i = 0; i < n; i++){
        arr[i] = rand() % 100;
    }
    return arr;
}

int main(){
    int n, *arr, x;
    printf("Enter length of array: ");
    scanf("%d", &n);

    arr = generateRandomNumbers(n);
    printf("Generated Random Array: ");
    for(int i = 0; i < n; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Input value to search
    printf("Enter a value to search: ");
    scanf("%d", &x);

    int index = binarySearch(arr, 0, n-1, x);

    if(index == -1)
        printf("%d not found in the array\n", x);
    else
        printf("%d found at index %d\n", x, index);

    free(arr);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall generateRandomNumbers(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (0000000140001725) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-1Ch] BYREF
  unsigned int v5; // [rsp+28h] [rbp-18h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-14h]
  void *Block; // [rsp+30h] [rbp-10h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter length of array: ");
  scanf("%d", &v5);
  Block = (void *)generateRandomNumbers(v5);
  printf("Generated Random Array: ");
  for ( i = 0; i < (int)v5; ++i )
    printf("%d ", *((unsigned int *)Block + i));
  printf("\n");
  printf("Enter a value to search: ");
  scanf("%d", &v4);
  v6 = binarySearch(Block, 0i64, v5 - 1, v4);
  if ( v6 == -1 )
    printf("%d not found in the array\n", v4);
  else
    printf("%d found at index %d\n", v4, v6);
  free(Block);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001695: using guessed type __int64 __fastcall generateRandomNumbers(_QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital signal processing ; Style: standalone
#include <stdio.h>

#define MAX_SAMPLES 10000

float data[MAX_SAMPLES];
float filtered_data[MAX_SAMPLES];

void low_pass_filter(float *data, float *filtered_data, int length, float cutoff_freq, float sample_rate) {
    // Calculate filter coefficients
    float RC = 1.0 / (cutoff_freq * 2 * 3.14);
    float dt = 1.0 / sample_rate;
    float alpha = dt / (RC + dt);

    // Filter data
    float previous_output = 0;
    for (int i = 0; i < length; i++) {
        filtered_data[i] = alpha * data[i] + (1 - alpha) * previous_output;
        previous_output = filtered_data[i];
    }
}

int main() {
    int num_samples;
    float sample_rate, cutoff_freq;

    // Read input parameters
    printf("Enter number of samples: ");
    scanf("%d", &num_samples);
    printf("Enter sample rate: ");
    scanf("%f", &sample_rate);
    printf("Enter cutoff frequency: ");
    scanf("%f", &cutoff_freq);

    // Read data
    printf("Enter data:\n");
    for (int i = 0; i < num_samples; i++) {
        scanf("%f", &data[i]);
    }

    // Filter data
    low_pass_filter(data, filtered_data, num_samples, cutoff_freq, sample_rate);

    // Print filtered data
    printf("Filtered data:\n");
    for (int i = 0; i < num_samples; i++) {
        printf("%f\n", filtered_data[i]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall low_pass_filter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN data; // weak
float filtered_data[10000]; // weak


//----- (00000001400016EB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // r9d
  int v5; // [rsp+3Ch] [rbp-14h] BYREF
  int v6; // [rsp+40h] [rbp-10h] BYREF
  int v7; // [rsp+44h] [rbp-Ch] BYREF
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter number of samples: ");
  scanf("%d", &v7);
  printf("Enter sample rate: ");
  scanf("%f", &v6);
  printf("Enter cutoff frequency: ");
  scanf("%f", &v5);
  printf("Enter data:\n");
  for ( i = 0; i < v7; ++i )
    scanf("%f", (char *)&data + 4 * i);
  low_pass_filter((unsigned int)&data, (unsigned int)filtered_data, v7, v3, v6);
  printf("Filtered data:\n");
  for ( j = 0; j < v7; ++j )
    printf("%f\n", filtered_data[j]);
  return 0;
}
// 1400017E1: variable 'v3' is possibly undefined
// 1400015E2: using guessed type __int64 __fastcall low_pass_filter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140021C80: using guessed type float filtered_data[10000];

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Searching algorithm ; Style: grateful
#include <stdio.h>

// function for binary search
int binarySearch(int arr[], int low, int high, int key) {
    if (high >= low) {
        int mid = low + (high - low) / 2;

        // if the key is present at the middle itself
        if (arr[mid] == key)
            return mid;

        // if key is smaller than mid, then it can only be present in left subarray
        if (arr[mid] > key)
            return binarySearch(arr, low, mid - 1, key);

        // else the key lies in right subarray
        return binarySearch(arr, mid + 1, high, key);
    }

    // key not found
    return -1;
}

int main() {
    int arr[] = {2, 3, 4, 10, 40};
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 10;
    int result = binarySearch(arr, 0, n - 1, key);
    if (result == -1)
        printf("Element is not present in array");
    else
        printf("Element is present at index %d", result);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001651) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[5]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v5; // [rsp+34h] [rbp-Ch]
  int v6; // [rsp+38h] [rbp-8h]
  int v7; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 2;
  v4[1] = 3;
  v4[2] = 4;
  v4[3] = 10;
  v4[4] = 40;
  v7 = 5;
  v6 = 10;
  v5 = ((__int64 (__fastcall *)(int *, _QWORD, __int64, __int64))binarySearch)(v4, 0i64, 4i64, 10i64);
  if ( v5 == -1 )
    printf("Element is not present in array");
  else
    printf("Element is present at index %d", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall binarySearch(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Alien Invasion Probability Calculator ; Style: brave
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  srand(time(NULL)); // Initialize random seed
  int invasionProbability = rand() % 101; // Generate a random number from 0 to 100
  
  printf("Welcome to the Alien Invasion Probability Calculator!\n");
  printf("Based on our calculations, there is a %d%% chance of an alien invasion.\n", invasionProbability);
  
  if (invasionProbability == 0) {
    printf("Well, it looks like we're safe for now.\n");
  } else if (invasionProbability > 0 && invasionProbability <= 25) {
    printf("It's unlikely, but we should still prepare just in case.\n");
  } else if (invasionProbability > 25 && invasionProbability <= 50) {
    printf("Things are looking ominous. We need to start preparing for an attack.\n");
  } else if (invasionProbability > 50 && invasionProbability <= 75) {
    printf("This is getting serious. We need to evacuate major cities and set up a defensive perimeter.\n");
  } else {
    printf("This is not a drill. An alien invasion is imminent. We need to mobilize all available resources and fight for our survival!\n");
  }
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v5 = rand() % 101;
  printf("Welcome to the Alien Invasion Probability Calculator!\n");
  printf("Based on our calculations, there is a %d%% chance of an alien invasion.\n", (unsigned int)v5);
  if ( v5 )
  {
    if ( v5 <= 0 || v5 > 25 )
    {
      if ( v5 <= 25 || v5 > 50 )
      {
        if ( v5 <= 50 || v5 > 75 )
          printf(
            "This is not a drill. An alien invasion is imminent. We need to mobilize all available resources and fight fo"
            "r our survival!\n");
        else
          printf("This is getting serious. We need to evacuate major cities and set up a defensive perimeter.\n");
      }
      else
      {
        printf("Things are looking ominous. We need to start preparing for an attack.\n");
      }
    }
    else
    {
      printf("It's unlikely, but we should still prepare just in case.\n");
    }
  }
  else
  {
    printf("Well, it looks like we're safe for now.\n");
  }
  return 0;
}
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Subnet Calculator ; Style: excited
#include<stdio.h>

int main() {
    printf("Welcome to the C Subnet Calculator!\n");
    printf("Enter the IP address and the subnet mask to calculate the network address, broadcast address and number of hosts.\n");
    printf("IP address format: A.B.C.D (each between 0 and 255)\n");
    printf("Subnet mask format: A.B.C.D (each between 0 and 255)\n\n");

    // Declare variables
    int ip[4], mask[4];
    int network[4], broadcast[4];
    int num_hosts, num_bits;

    // Collect user input
    printf("Enter the IP address: ");
    scanf("%d.%d.%d.%d", &ip[0], &ip[1], &ip[2], &ip[3]);
    printf("Enter the subnet mask: ");
    scanf("%d.%d.%d.%d", &mask[0], &mask[1], &mask[2], &mask[3]);

    // Verify input
    for (int i = 0; i < 4; i++) {
        if (ip[i] < 0 || ip[i] > 255 || mask[i] < 0 || mask[i] > 255) {
            printf("Invalid input. Please enter values between 0 and 255.\n");
            return 0;
        }
    }

    // Calculate network and broadcast addresses
    for (int i = 0; i < 4; i++) {
        network[i] = ip[i] & mask[i];
        broadcast[i] = ip[i] | ~mask[i];
    }

    // Determine number of host bits
    num_bits = 0;
    for (int i = 0; i < 4; i++) {
        int quotient = mask[i], rem = 0;
        while (quotient) {
            rem += quotient & 1;
            quotient >>= 1;
        }
        num_bits += rem;
    }

    // Calculate number of hosts
    num_hosts = (1 << (32 - num_bits)) - 2;
    
    // Output results
    printf("\nNetwork address: %d.%d.%d.%d\n", network[0], network[1], network[2], network[3]);
    printf("Broadcast address: %d.%d.%d.%d\n", broadcast[0], broadcast[1], broadcast[2], broadcast[3]);
    printf("Number of host bits: %d\n", num_bits);
    printf("Number of hosts: %d\n\n", num_hosts);

    printf("Wow! That was fantastic! The C Subnet Calculator is now ready for use.\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-70h]
  __int64 v5; // [rsp+20h] [rbp-70h]
  int v6[4]; // [rsp+30h] [rbp-60h]
  int v7[4]; // [rsp+40h] [rbp-50h]
  int v8; // [rsp+50h] [rbp-40h] BYREF
  char v9; // [rsp+54h] [rbp-3Ch] BYREF
  char v10; // [rsp+58h] [rbp-38h] BYREF
  char v11; // [rsp+5Ch] [rbp-34h] BYREF
  int v12; // [rsp+60h] [rbp-30h] BYREF
  char v13; // [rsp+64h] [rbp-2Ch] BYREF
  char v14; // [rsp+68h] [rbp-28h] BYREF
  char v15; // [rsp+6Ch] [rbp-24h] BYREF
  unsigned int v16; // [rsp+74h] [rbp-1Ch]
  int v17; // [rsp+78h] [rbp-18h]
  int v18; // [rsp+7Ch] [rbp-14h]
  int k; // [rsp+80h] [rbp-10h]
  int j; // [rsp+84h] [rbp-Ch]
  int i; // [rsp+88h] [rbp-8h]
  unsigned int v22; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the C Subnet Calculator!\n");
  printf(
    "Enter the IP address and the subnet mask to calculate the network address, broadcast address and number of hosts.\n");
  printf("IP address format: A.B.C.D (each between 0 and 255)\n");
  printf("Subnet mask format: A.B.C.D (each between 0 and 255)\n\n");
  printf("Enter the IP address: ");
  scanf("%d.%d.%d.%d", &v12, &v13, &v14, &v15);
  printf("Enter the subnet mask: ");
  scanf("%d.%d.%d.%d", &v8, &v9, &v10, &v11);
  for ( i = 0; i <= 3; ++i )
  {
    if ( (unsigned int)*(&v12 + i) > 0xFF || (unsigned int)*(&v8 + i) >= 0x100 )
    {
      printf("Invalid input. Please enter values between 0 and 255.\n");
      return 0;
    }
  }
  for ( j = 0; j <= 3; ++j )
  {
    v7[j] = *(&v8 + j) & *(&v12 + j);
    v6[j] = ~*(&v8 + j) | *(&v12 + j);
  }
  v22 = 0;
  for ( k = 0; k <= 3; ++k )
  {
    v18 = *(&v8 + k);
    v17 = 0;
    while ( v18 )
    {
      v17 += v18 & 1;
      v18 >>= 1;
    }
    v22 += v17;
  }
  v16 = (1 << (32 - v22)) - 2;
  LODWORD(v4) = v7[3];
  printf("\nNetwork address: %d.%d.%d.%d\n", (unsigned int)v7[0], (unsigned int)v7[1], (unsigned int)v7[2], v4);
  LODWORD(v5) = v6[3];
  printf("Broadcast address: %d.%d.%d.%d\n", (unsigned int)v6[0], (unsigned int)v6[1], (unsigned int)v6[2], v5);
  printf("Number of host bits: %d\n", v22);
  printf("Number of hosts: %d\n\n", v16);
  printf("Wow! That was fantastic! The C Subnet Calculator is now ready for use.\n");
  return 0;
}
// 1400017F6: variable 'v4' is possibly undefined
// 14000181E: variable 'v5' is possibly undefined
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Appointment Scheduler ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// declaring global variables
int day = 0, hour = 0;

// declaring function to schedule an appointment
void scheduleAppointment(char* name, int chosenDay, int chosenHour) {
    // if day and hour is already taken, display error message
    if (chosenDay == day && chosenHour == hour) {
        printf("Sorry, that appointment slot has already been taken. Please select a different day and time.\n");
    } 
    else {
        // update global variables
        day = chosenDay;
        hour = chosenHour;
        // display success message
        printf("%s, your appointment has been scheduled for day %d at hour %d.\n", name, day, hour);
    }
}

int main() {
    // declaring variables
    char name[50], choice[10];
    int chosenDay, chosenHour;
    // loop until user decides to quit
    while (1) {
        // display menu options
        printf("\nAppointment Scheduler Menu:\n");
        printf("1. Schedule Appointment\n");
        printf("2. View Appointment\n");
        printf("3. Quit\n");
        printf("Enter your choice (1, 2 or 3): ");
        // read user's choice
        scanf("%s", choice);
        // perform corresponding action based on user's choice
        if (strcmp(choice, "1") == 0) {
            // read user's name, day and hour to schedule an appointment
            printf("Enter your name: ");
            scanf("%s", name);
            printf("Enter the day you want to schedule the appointment (1-7): ");
            scanf("%d", &chosenDay);
            printf("Enter the hour you want to schedule the appointment (8-17): ");
            scanf("%d", &chosenHour);
            // schedule the appointment
            scheduleAppointment(name, chosenDay, chosenHour);
        } 
        else if (strcmp(choice, "2") == 0) {
            // if no appointment has been scheduled yet, display message
            if (day == 0 && hour == 0) {
                printf("No appointment has been scheduled yet.\n");
            } 
            else {
                // display appointment details
                printf("Appointment for day %d at hour %d has been scheduled.\n", day, hour);
            }
        }
        else if (strcmp(choice, "3") == 0) {
            // quit the program
            printf("Thank you for using the Appointment Scheduler. Goodbye.\n");
            exit(0);
        } 
        else {
            // if user enters an invalid choice, display error message
            printf("Invalid choice. Please enter 1, 2 or 3.\n");
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall scheduleAppointment(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

int day; // weak
int hour; // weak


//----- (000000014000165B) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // [rsp+2Ch] [rbp-54h] BYREF
  unsigned int v4; // [rsp+30h] [rbp-50h] BYREF
  char Str1[10]; // [rsp+36h] [rbp-4Ah] BYREF
  char v6[64]; // [rsp+40h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        printf("\nAppointment Scheduler Menu:\n");
        printf("1. Schedule Appointment\n");
        printf("2. View Appointment\n");
        printf("3. Quit\n");
        printf("Enter your choice (1, 2 or 3): ");
        scanf("%s", Str1);
        if ( strcmp(Str1, "1") )
          break;
        printf("Enter your name: ");
        scanf("%s", v6);
        printf("Enter the day you want to schedule the appointment (1-7): ");
        scanf("%d", &v4);
        printf("Enter the hour you want to schedule the appointment (8-17): ");
        scanf("%d", &v3);
        scheduleAppointment(v6, v4, v3);
      }
      if ( strcmp(Str1, "2") )
        break;
      if ( day || hour )
        printf("Appointment for day %d at hour %d has been scheduled.\n", (unsigned int)day, (unsigned int)hour);
      else
        printf("No appointment has been scheduled yet.\n");
    }
    if ( !strcmp(Str1, "3") )
    {
      printf("Thank you for using the Appointment Scheduler. Goodbye.\n");
      exit(0);
    }
    printf("Invalid choice. Please enter 1, 2 or 3.\n");
  }
}
// 1400015E2: using guessed type __int64 __fastcall scheduleAppointment(_QWORD, _QWORD, _QWORD);
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140018040: using guessed type int day;
// 140018044: using guessed type int hour;
// 14000165B: using guessed type unsigned int var_50;

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Math exercise ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(){
    printf("Welcome to the Grateful Mathematics Exercise Program!\n\n");
    printf("This program is designed to help you improve your math skills while also cultivating gratitude.\n\n");
    printf("For each math problem, you will be prompted with a random addition question. You will then be asked to express gratitude for something related to the answer.\n\n");
    
    srand(time(0)); //Set random seed
    
    int num1, num2, ans;
    char response[50];
    int count = 0;
    while(count < 10){ //Loop through 10 math questions
        num1 = rand() % 11; //Generate random numbers between 0 and 10
        num2 = rand() % 11;
        ans = num1 + num2;
        
        printf("What is %d + %d?\n", num1, num2);
        scanf("%d", &response);
        
        if(response == ans){
            printf("Congratulations, that is correct! Now it's time to express gratitude.\n");
            printf("What are you grateful for that is related to the number %d?\n", ans);
            getchar(); //Clear input buffer
            fgets(response, sizeof(response), stdin); //Get user response
            printf("That's wonderful, keep up the gratitude!\n\n");
            count++;
        }
        else{
            printf("Sorry, that is incorrect. Please try again.\n\n");
        }
    }
    
    printf("Congratulations, you have completed the Grateful Mathematics Exercise Program!\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  FILE *v4; // rax
  char Buffer[64]; // [rsp+20h] [rbp-50h] BYREF
  unsigned int v7; // [rsp+60h] [rbp-10h]
  unsigned int v8; // [rsp+64h] [rbp-Ch]
  unsigned int v9; // [rsp+68h] [rbp-8h]
  int v10; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Grateful Mathematics Exercise Program!\n\n");
  printf("This program is designed to help you improve your math skills while also cultivating gratitude.\n\n");
  printf(
    "For each math problem, you will be prompted with a random addition question. You will then be asked to express grati"
    "tude for something related to the answer.\n"
    "\n");
  v3 = time(0i64);
  srand(v3);
  v10 = 0;
  while ( v10 <= 9 )
  {
    v9 = rand() % 11;
    v8 = rand() % 11;
    v7 = v9 + v8;
    printf("What is %d + %d?\n", v9, v8);
    scanf("%d", Buffer);
    if ( (char *)(int)v7 == Buffer )
    {
      printf("Congratulations, that is correct! Now it's time to express gratitude.\n");
      printf("What are you grateful for that is related to the number %d?\n", v7);
      getchar();
      v4 = __acrt_iob_func(0);
      fgets(Buffer, 50, v4);
      printf("That's wonderful, keep up the gratitude!\n\n");
      ++v10;
    }
    else
    {
      printf("Sorry, that is incorrect. Please try again.\n\n");
    }
  }
  printf("Congratulations, you have completed the Grateful Mathematics Exercise Program!\n");
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Network Quality of Service (QoS) monitor ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct {
    int packets_sent;
    int packets_dropped;
    float packet_loss;
} QoS;

int main(void) {
    int connection_speeds[3] = {10, 100, 1000};
    QoS net_quality[3];

    srand(time(NULL));

    for (int i = 0; i < 3; i++) {
        net_quality[i].packets_sent = rand() % 5000 + 1000; // random number of packets sent
        net_quality[i].packets_dropped = rand() % net_quality[i].packets_sent; // random number of packets dropped
        net_quality[i].packet_loss = (float)net_quality[i].packets_dropped / net_quality[i].packets_sent * 100;
        printf("QoS for connection speed %dMbps: %.2f%% packet loss\n", connection_speeds[i], net_quality[i].packet_loss);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  _BYTE v5[48]; // [rsp+20h] [rbp-40h]
  int v6[3]; // [rsp+50h] [rbp-10h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6[0] = 10;
  v6[1] = 100;
  v6[2] = 1000;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 2; ++i )
  {
    *(_DWORD *)&v5[12 * i] = rand() % 5000 + 1000;
    *(_DWORD *)&v5[12 * i + 4] = rand() % *(_DWORD *)&v5[12 * i];
    *(float *)&v5[12 * i + 8] = 100.0 * (float)((float)*(int *)&v5[12 * i + 4] / (float)*(int *)&v5[12 * i]);
    printf("QoS for connection speed %dMbps: %.2f%% packet loss\n", (unsigned int)v6[i], *(float *)&v5[12 * i + 8]);
  }
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Geometric algorithms ; Style: active
#include <stdio.h>
#include <math.h>

struct Point {
    int x;
    int y;
};

float getDistance(struct Point point1, struct Point point2) {
    float distance = sqrt(pow(point2.x - point1.x, 2) + pow(point2.y - point1.y, 2));
    return distance;
}

int main() {
    struct Point points[3];

    printf("Enter coordinates for point 1:\n");
    scanf("%d %d", &points[0].x, &points[0].y);

    printf("Enter coordinates for point 2:\n");
    scanf("%d %d", &points[1].x, &points[1].y);

    printf("Enter coordinates for point 3:\n");
    scanf("%d %d", &points[2].x, &points[2].y);

    float distance1 = getDistance(points[0], points[1]);
    float distance2 = getDistance(points[0], points[2]);
    float distance3 = getDistance(points[1], points[2]);

    if(distance1 + distance2 > distance3 && distance1 + distance3 > distance2 && distance2 + distance3 > distance1) {
        printf("The three points form a triangle.\n");

        float semiperimeter = (distance1 + distance2 + distance3) / 2;
        float area = sqrt(semiperimeter * (semiperimeter - distance1) * (semiperimeter - distance2) * (semiperimeter - distance3));
        printf("Area of the triangle: %.2f\n", area);

        if(distance1 == distance2 && distance1 == distance3) {
            printf("The triangle is equilateral.\n");
        } else if(distance1 == distance2 || distance1 == distance3 || distance2 == distance3) {
            printf("The triangle is isosceles.\n");
        } else {
            printf("The triangle is scalene.\n");
        }
    } else {
        printf("The three points do not form a triangle.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
double __fastcall getDistance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);


//----- (000000014000167D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __m128i v3; // xmm0
  float v4; // xmm0_4
  __int64 v6; // [rsp+20h] [rbp-30h] BYREF
  __int64 v7; // [rsp+28h] [rbp-28h] BYREF
  __int64 v8; // [rsp+30h] [rbp-20h] BYREF
  float v9; // [rsp+3Ch] [rbp-14h]
  float v10; // [rsp+40h] [rbp-10h]
  float v11; // [rsp+44h] [rbp-Ch]
  float v12; // [rsp+48h] [rbp-8h]
  float v13; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter coordinates for point 1:\n");
  scanf("%d %d", &v6, (char *)&v6 + 4);
  printf("Enter coordinates for point 2:\n");
  scanf("%d %d", &v7, (char *)&v7 + 4);
  printf("Enter coordinates for point 3:\n");
  scanf("%d %d", &v8, (char *)&v8 + 4);
  *(double *)v3.m128i_i64 = getDistance(v6, v7);
  v13 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
  *(double *)v3.m128i_i64 = getDistance(v6, v8);
  v12 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
  *(double *)v3.m128i_i64 = getDistance(v7, v8);
  v11 = COERCE_FLOAT(_mm_cvtsi128_si32(v3));
  if ( (float)(v13 + v12) <= v11 || (float)(v13 + v11) <= v12 || (float)(v12 + v11) <= v13 )
  {
    printf("The three points do not form a triangle.\n");
  }
  else
  {
    printf("The three points form a triangle.\n");
    v10 = (float)((float)(v13 + v12) + v11) / 2.0;
    v4 = sqrt((float)((float)(v10 - v11) * (float)((float)((float)(v10 - v13) * v10) * (float)(v10 - v12))));
    v9 = v4;
    printf("Area of the triangle: %.2f\n", v4);
    if ( v13 == v12 && v13 == v11 )
    {
      printf("The triangle is equilateral.\n");
    }
    else if ( v13 == v12 || v13 == v11 || v12 == v11 )
    {
      printf("The triangle is isosceles.\n");
    }
    else
    {
      printf("The triangle is scalene.\n");
    }
  }
  return 0;
}
// 140001732: variable 'v3' is possibly undefined
// 1400015E2: using guessed type double __fastcall getDistance(_QWORD, _QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Remote control Vehicle Simulation ; Style: visionary
// C Remote Control Vehicle Simulation
// by [insert your name here]

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int battery_level = 100;
    int position_x = 0;
    int position_y = 0;
    int speed = 0;
    int direction = 0;
    int distance_traveled = 0;

    srand(time(NULL));

    printf("Welcome to the Remote Control Vehicle Simulation!\n");
    printf("Battery level: %d%%\n", battery_level);

    while (battery_level > 0) {
        int action = rand() % 3; // randomly choose an action: 0 = move forward, 1 = move backward, 2 = change direction

        switch (action) {
            case 0: // move forward
                speed = rand() % 10; // randomly set speed between 0 and 9 mph
                distance_traveled += speed;
                position_x += speed * sin(direction);
                position_y += speed * cos(direction);
                printf("Moving forward at %d mph\n", speed);
                break;

            case 1: // move backward
                if (distance_traveled > 0) {
                    speed = rand() % 5; // randomly set speed between 0 and 4 mph
                    distance_traveled -= speed;
                    position_x -= speed * sin(direction);
                    position_y -= speed * cos(direction);
                    printf("Moving backward at %d mph\n", speed);
                } else {
                    printf("Cannot move backward - already at starting position\n");
                }
                break;

            case 2: // change direction
                direction = rand() % 360; // randomly set direction between 0 and 359 degrees
                printf("Changing direction to %d degrees\n", direction);
                break;
        }

        battery_level -= distance_traveled / 10; // decrease battery level in proportion to distance traveled
        printf("Battery level: %d%%\n", battery_level);
        printf("Position: (%d, %d)\n", position_x, position_y);
    }

    printf("Battery depleted - simulation ended\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl cos(double X);
double __cdecl sin(double X);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-1Ch]
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+28h] [rbp-18h]
  int v8; // [rsp+2Ch] [rbp-14h]
  int v9; // [rsp+30h] [rbp-10h]
  int v10; // [rsp+34h] [rbp-Ch]
  int v11; // [rsp+38h] [rbp-8h]
  int v12; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v12 = 100;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Remote Control Vehicle Simulation!\n");
  printf("Battery level: %d%%\n", 100i64);
  while ( v12 > 0 )
  {
    v5 = rand() % 3;
    if ( v5 == 2 )
    {
      v9 = rand() % 360;
      printf("Changing direction to %d degrees\n", (unsigned int)v9);
    }
    else if ( v5 <= 2 )
    {
      if ( v5 )
      {
        if ( v5 == 1 )
        {
          if ( v8 <= 0 )
          {
            printf("Cannot move backward - already at starting position\n");
          }
          else
          {
            v7 = rand() % 5;
            v8 -= v7;
            v11 = (int)((double)v11 - sin((double)v9) * (double)v7);
            v10 = (int)((double)v10 - cos((double)v9) * (double)v7);
            printf("Moving backward at %d mph\n", (unsigned int)v7);
          }
        }
      }
      else
      {
        v6 = rand() % 10;
        v8 += v6;
        v11 = (int)(sin((double)v9) * (double)v6 + (double)v11);
        v10 = (int)(cos((double)v9) * (double)v6 + (double)v10);
        printf("Moving forward at %d mph\n", (unsigned int)v6);
      }
    }
    v12 += v8 / -10;
    printf("Battery level: %d%%\n", (unsigned int)v12);
    printf("Position: (%d, %d)\n", (unsigned int)v11, (unsigned int)v10);
  }
  printf("Battery depleted - simulation ended\n");
  return 0;
}
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Greedy Algorithms ; Style: shocked
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    int *a = (int*) malloc(n * sizeof(int));
    for(int i=0; i<n; i++) {
        scanf("%d", &a[i]);
    }
    int *b = (int*) malloc(m * sizeof(int));
    for(int i=0; i<m; i++) {
        scanf("%d", &b[i]);
    }
    int ans = 0;
    for(int i=0; i<n; i++) {
        int max_val = a[i];
        for(int j=0; j<m; j++) {
            if(b[j] < max_val) {
                continue;
            }
            if(b[j] >= max_val) {
                ans++;
                b[j] = 0;
                break;
            }
        }
    }
    printf("%d", ans);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-34h] BYREF
  int v5; // [rsp+30h] [rbp-30h] BYREF
  int v6; // [rsp+34h] [rbp-2Ch]
  _DWORD *v7; // [rsp+38h] [rbp-28h]
  _DWORD *v8; // [rsp+40h] [rbp-20h]
  int m; // [rsp+4Ch] [rbp-14h]
  int k; // [rsp+50h] [rbp-10h]
  unsigned int v11; // [rsp+54h] [rbp-Ch]
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  scanf("%d %d", &v5, &v4);
  v8 = malloc(4i64 * v5);
  for ( i = 0; i < v5; ++i )
    scanf("%d", &v8[i]);
  v7 = malloc(4i64 * v4);
  for ( j = 0; j < v4; ++j )
    scanf("%d", &v7[j]);
  v11 = 0;
  for ( k = 0; k < v5; ++k )
  {
    v6 = v8[k];
    for ( m = 0; m < v4; ++m )
    {
      if ( v6 <= v7[m] )
      {
        ++v11;
        v7[m] = 0;
        break;
      }
    }
  }
  printf("%d", v11);
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data mining ; Style: complex
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char name[20];
    int age;
    float income;
} Person;

int main() {
    FILE *file;
    file = fopen("people.txt", "r");
    if (file == NULL) {
        printf("Error opening file.\n");
        exit(1);
    }

    int num_people;
    fscanf(file, "%d", &num_people);

    Person *people = (Person*) malloc(num_people * sizeof(Person));

    for (int i = 0; i < num_people; i++) {
        fscanf(file, "%s %d %f", people[i].name, &people[i].age, &people[i].income);
    }

    int index_of_richest = 0;
    for (int i = 1; i < num_people; i++) {
        if (people[i].income > people[index_of_richest].income) {
            index_of_richest = i;
        }
    }

    printf("%s is the richest person with an income of %.2f.\n", people[index_of_richest].name, people[index_of_richest].income);

    fclose(file);
    free(people);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+3Ch] [rbp-24h] BYREF
  void *Block; // [rsp+40h] [rbp-20h]
  FILE *Stream; // [rsp+48h] [rbp-18h]
  int j; // [rsp+54h] [rbp-Ch]
  int v8; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  Stream = fopen("people.txt", "r");
  if ( !Stream )
  {
    printf("Error opening file.\n");
    exit(1);
  }
  fscanf(Stream, "%d", &v4);
  Block = malloc(28i64 * v4);
  for ( i = 0; i < v4; ++i )
    fscanf(Stream, "%s %d %f", (char *)Block + 28 * i, (char *)Block + 28 * i + 20, (char *)Block + 28 * i + 24);
  v8 = 0;
  for ( j = 1; j < v4; ++j )
  {
    if ( *((float *)Block + 7 * j + 6) > *((float *)Block + 7 * v8 + 6) )
      v8 = j;
  }
  printf(
    "%s is the richest person with an income of %.2f.\n",
    (const char *)Block + 28 * v8,
    *((float *)Block + 7 * v8 + 6));
  fclose(Stream);
  free(Block);
  return 0;
}
// 1400018B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: peaceful
#include <stdio.h>
#include <string.h>

struct DiaryEntry {
    int day;
    int month;
    int year;
    char entry[1000];
};

int main() {
    struct DiaryEntry diary[365];
    int choice = 0;
    int entries = 0;
    int i;

    while (1) {
        printf("1. New Entry\n");
        printf("2. Display Entries\n");
        printf("3. Quit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                if (entries < 365) {
                    printf("Enter the date of entry (DD MM YYYY): ");
                    scanf("%d %d %d", &diary[entries].day, &diary[entries].month, &diary[entries].year);
                    printf("Enter your entry: ");
                    getchar();
                    fgets(diary[entries].entry, sizeof(diary[entries].entry), stdin);
                    entries++;
                } else {
                    printf("Sorry, diary is full.\n");
                }
                break;
            case 2:
                for (i = 0; i < entries; i++) {
                    printf("%d/%d/%d: %s", diary[i].day, diary[i].month, diary[i].year, diary[i].entry);
                }
                break;
            case 3:
                printf("Exiting...\n");
                return 0;
            default:
                printf("Invalid choice.\n");
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v5[17]; // [rsp+3Ch] [rbp-44h] BYREF
  _BYTE v6[369320]; // [rsp+80h] [rbp+0h] BYREF
  int i; // [rsp+5A328h] [rbp+5A2A8h]
  int v8; // [rsp+5A32Ch] [rbp+5A2ACh]

  _main(argc, argv, envp);
  v5[0] = 0;
  v8 = 0;
  while ( 1 )
  {
    printf("1. New Entry\n");
    printf("2. Display Entries\n");
    printf("3. Quit\n");
    printf("Enter your choice: ");
    scanf("%d", v5);
    if ( v5[0] == 3 )
      break;
    if ( v5[0] > 3 )
      goto LABEL_15;
    if ( v5[0] == 1 )
    {
      if ( v8 > 364 )
      {
        printf("Sorry, diary is full.\n");
      }
      else
      {
        printf("Enter the date of entry (DD MM YYYY): ");
        scanf("%d %d %d", &v5[253 * v8 + 1], &v5[253 * v8 + 2], &v5[253 * v8 + 3]);
        printf("Enter your entry: ");
        getchar();
        v3 = __acrt_iob_func(0);
        fgets((char *)&v5[253 * v8++ + 4], 1000, v3);
      }
    }
    else if ( v5[0] == 2 )
    {
      for ( i = 0; i < v8; ++i )
        printf(
          "%d/%d/%d: %s",
          *(unsigned int *)&v6[1012 * i - 64],
          *(unsigned int *)&v6[1012 * i - 60],
          *(unsigned int *)&v6[1012 * i - 56],
          (const char *)&v5[253 * i + 4]);
    }
    else
    {
LABEL_15:
      printf("Invalid choice.\n");
    }
  }
  printf("Exiting...\n");
  return 0;
}
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Geometric algorithms ; Style: calm
#include<stdio.h>
#include<stdlib.h>
#include<math.h>

/* Definition of a structure point with x and y coordinates */
struct Point{
    int x,y;
};

/* Definition of a structure line with two points */
struct Line{
    struct Point p1,p2;
};

/* Function to check if three points are in a straight line */
int isCollinear(struct Point p1, struct Point p2, struct Point p3){
    int collinear = (p2.y-p1.y)*(p3.x-p2.x) == (p3.y-p2.y)*(p2.x-p1.x);
    return collinear;
}

/* Function to calculate the distance between two points */
float distance(struct Point p1, struct Point p2){
    return sqrt(pow(p2.x-p1.x,2)+pow(p2.y-p1.y,2));
}

/* Function to calculate the area of a triangle */
float triangleArea(struct Point p1, struct Point p2, struct Point p3){
    float s = (distance(p1,p2) + distance(p2,p3) + distance(p3,p1))/2;
    float area = sqrt(s*(s-distance(p1,p2))*(s-distance(p2,p3))*(s-distance(p3,p1)));
    return area;
}

/* Function to find the intersection point of two lines */
struct Point findIntersection(struct Line l1, struct Line l2) {
    int x1 = l1.p1.x, x2 = l1.p2.x, x3 = l2.p1.x, x4 = l2.p2.x;
    int y1 = l1.p1.y, y2 = l1.p2.y, y3 = l2.p1.y, y4 = l2.p2.y;
    int numx = ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4));
    int denx = ((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
    int numy = ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4));
    int deny = ((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
    float x = (float)numx/denx;
    float y = (float)numy/deny;
    struct Point intersection = {x,y};
    return intersection;
}

/* Main function */
int main(){
    int n; // number of points
    struct Point *points;
    printf("Enter the number of points: ");
    scanf("%d", &n);
    points = (struct Point*) malloc(n*sizeof(struct Point)); // Dynamically allocate memory for array of points
    printf("\nEnter the coordinates of the points: ");
    for(int i=0; i<n ;i++){
        scanf("%d %d", &points[i].x, &points[i].y);
    }

    /* Steps to find the centroid of the polygon */
    float centroid_x=0, centroid_y=0;
    for(int i=0; i<n ;i++){
        centroid_x += points[i].x;
        centroid_y += points[i].y;
    }
    centroid_x /= n;
    centroid_y /= n;
    struct Point centroid = {centroid_x, centroid_y};
    printf("\nThe centroid of the polygon is (%.2f, %.2f).", centroid_x, centroid_y);

    /* Steps to find the area of the polygon */
    float area = 0;
    for(int i=0; i<n-2 ;i++){
        if(!isCollinear(points[i],points[i+1],points[i+2])){
            area += triangleArea(points[i],points[i+1],points[i+2]);
        }
    }
    printf("\nThe area of the polygon is %.2f.", area);

    /* Steps to find the shortest distance from a point to a line */
    struct Point p;
    struct Line l;
    printf("\nEnter the coordinates of the point: ");
    scanf("%d %d", &p.x, &p.y);
    printf("Enter the coordinates of the endpoints of the line: ");
    scanf("%d %d %d %d", &l.p1.x, &l.p1.y, &l.p2.x, &l.p2.y);
    float distance_point_line = (abs((l.p2.y-l.p1.y)*p.x - (l.p2.x-l.p1.x)*p.y + l.p2.x*l.p1.y - l.p2.y*l.p1.x))/sqrt(pow(l.p2.y-l.p1.y,2)+pow(l.p2.x-l.p1.x,2));
    printf("The shortest distance from the point (%d,%d) to the line passing through (%d,%d) and (%d,%d) is %.2f.", p.x, p.y, l.p1.x, l.p1.y, l.p2.x, l.p2.y, distance_point_line);

    /* Steps to find the intersection point of two lines */
    struct Line l1, l2;
    printf("\nEnter the coordinates of the endpoints of line 1: ");
    scanf("%d %d %d %d", &l1.p1.x, &l1.p1.y, &l1.p2.x, &l1.p2.y);
    printf("Enter the coordinates of the endpoints of line 2: ");
    scanf("%d %d %d %d", &l2.p1.x, &l2.p1.y, &l2.p2.x, &l2.p2.y);
    struct Point intersection_point = findIntersection(l1, l2);
    printf("The intersection point of the two lines is (%.2f, %.2f).", intersection_point.x, intersection_point.y);

    free(points); // Free the dynamically allocated memory
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall isCollinear(_QWORD, _QWORD, _QWORD); // weak
float __fastcall triangleArea(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall findIntersection(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl pow(double X, double Y);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);


//----- (0000000140001957) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm2_8
  float v4; // xmm0_4
  int v5; // eax
  double v6; // xmm6_8
  double v7; // xmm7_8
  double v8; // xmm0_8
  double v9; // xmm6_8
  int v10; // xmm0_4
  __int64 v12; // [rsp+20h] [rbp-C0h]
  int v13; // [rsp+28h] [rbp-B8h]
  int v14; // [rsp+30h] [rbp-B0h]
  __int64 v15[2]; // [rsp+40h] [rbp-A0h] BYREF
  __int64 v16[4]; // [rsp+50h] [rbp-90h] BYREF
  __int64 v17; // [rsp+70h] [rbp-70h] BYREF
  __int64 v18; // [rsp+78h] [rbp-68h] BYREF
  __int64 v19; // [rsp+80h] [rbp-60h] BYREF
  __int64 v20; // [rsp+88h] [rbp-58h] BYREF
  unsigned int v21; // [rsp+90h] [rbp-50h] BYREF
  int v22; // [rsp+94h] [rbp-4Ch] BYREF
  int v23; // [rsp+98h] [rbp-48h] BYREF
  int v24; // [rsp+9Ch] [rbp-44h] BYREF
  unsigned int v25; // [rsp+A8h] [rbp-38h] BYREF
  unsigned int v26; // [rsp+ACh] [rbp-34h] BYREF
  int v27; // [rsp+B0h] [rbp-30h]
  int v28; // [rsp+B4h] [rbp-2Ch]
  int v29[2]; // [rsp+B8h] [rbp-28h] BYREF
  void *Block; // [rsp+C0h] [rbp-20h]
  int k; // [rsp+C8h] [rbp-18h]
  float v32; // [rsp+CCh] [rbp-14h]
  int j; // [rsp+D0h] [rbp-10h]
  float v34; // [rsp+D4h] [rbp-Ch]
  float v35; // [rsp+D8h] [rbp-8h]
  int i; // [rsp+DCh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the number of points: ");
  scanf("%d", v29);
  Block = malloc(8i64 * v29[0]);
  printf("\nEnter the coordinates of the points: ");
  for ( i = 0; i < v29[0]; ++i )
    scanf("%d %d", (char *)Block + 8 * i, (char *)Block + 8 * i + 4);
  v35 = 0.0;
  v34 = 0.0;
  for ( j = 0; j < v29[0]; ++j )
  {
    v35 = (float)*((int *)Block + 2 * j) + v35;
    v34 = (float)*((int *)Block + 2 * j + 1) + v34;
  }
  v35 = v35 / (float)v29[0];
  v34 = v34 / (float)v29[0];
  v27 = (int)v35;
  v28 = (int)v34;
  v3 = v34;
  printf("\nThe centroid of the polygon is (%.2f, %.2f).", v35, v34);
  v32 = 0.0;
  for ( k = 0; k < v29[0] - 2; ++k )
  {
    if ( !(unsigned int)isCollinear(*((_QWORD *)Block + k), *((_QWORD *)Block + k + 1), *((_QWORD *)Block + k + 2)) )
    {
      v4 = triangleArea(*((_QWORD *)Block + k), *((_QWORD *)Block + k + 1), *((_QWORD *)Block + k + 2));
      v32 = v4 + v32;
    }
  }
  printf("\nThe area of the polygon is %.2f.", v32);
  printf("\nEnter the coordinates of the point: ");
  scanf("%d %d", &v25, &v26);
  printf("Enter the coordinates of the endpoints of the line: ");
  scanf("%d %d %d %d", &v21, &v22, &v23, &v24);
  v5 = v23 * v22 + (v24 - v22) * v25 - (v23 - v21) * v26 - v21 * v24;
  if ( (int)(v21 * v24 - (v23 * v22 + (v24 - v22) * v25 - (v23 - v21) * v26)) >= 0 )
    v5 = v21 * v24 - (v23 * v22 + (v24 - v22) * v25 - (v23 - v21) * v26);
  v6 = (double)v5;
  v7 = pow((double)(v24 - v22), 2.0);
  v8 = pow((double)(int)(v23 - v21), 2.0);
  v9 = v6 / sqrt(v7 + v8);
  *(float *)&v10 = v9;
  v29[1] = v10;
  v14 = v24;
  v13 = v23;
  LODWORD(v12) = v22;
  printf(
    "The shortest distance from the point (%d,%d) to the line passing through (%d,%d) and (%d,%d) is %.2f.",
    v25,
    v26,
    v21,
    v12,
    v13,
    v14,
    *(float *)&v10);
  printf("\nEnter the coordinates of the endpoints of line 1: ");
  scanf("%d %d %d %d", &v19, (char *)&v19 + 4, &v20, (char *)&v20 + 4);
  printf("Enter the coordinates of the endpoints of line 2: ");
  scanf("%d %d %d %d", &v17, (char *)&v17 + 4, &v18, (char *)&v18 + 4);
  v16[0] = v19;
  v16[1] = v20;
  v15[0] = v17;
  v15[1] = v18;
  v16[3] = findIntersection(v16, v15);
  printf("The intersection point of the two lines is (%.2f, %.2f).", v9, v3);
  free(Block);
  return 0;
}
// 140001DBC: variable 'v12' is possibly undefined
// 1400015E2: using guessed type __int64 __fastcall isCollinear(_QWORD, _QWORD, _QWORD);
// 1400016C9: using guessed type float __fastcall triangleArea(_QWORD, _QWORD, _QWORD);
// 1400017BF: using guessed type __int64 __fastcall findIntersection(_QWORD, _QWORD);
// 140001F90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cryptographic hash function ; Style: retro
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BLOCK_SIZE 64 // Block size in bytes
#define HASH_SIZE 32 // Hash size in bytes
#define WORD_SIZE 4 // Word size in bytes
#define ROTR(x, n) (((x) >> (n)) | ((x) << (32 - (n)))) // Rotate right
#define CH(x, y, z) (((x) & (y)) ^ ((~(x)) & (z))) // Choose
#define MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z))) // Majority
#define BSIG0(x) (ROTR((x), 2) ^ ROTR((x), 13) ^ ROTR((x), 22)) // Big sigma 0
#define BSIG1(x) (ROTR((x), 6) ^ ROTR((x), 11) ^ ROTR((x), 25)) // Big sigma 1
#define SSIG0(x) (ROTR((x), 7) ^ ROTR((x), 18) ^ ((x) >> 3)) // Small sigma 0
#define SSIG1(x) (ROTR((x), 17) ^ ROTR((x), 19) ^ ((x) >> 10)) // Small sigma 1

typedef struct state_t {
    unsigned char data[BLOCK_SIZE];
    unsigned int datalen;
    unsigned long long bitlen;
    unsigned int state[HASH_SIZE / WORD_SIZE];
} state;

const unsigned int K[] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

void init(state *s) {
    s->datalen = 0;
    s->bitlen = 0;
    s->state[0] = 0x6a09e667;
    s->state[1] = 0xbb67ae85;
    s->state[2] = 0x3c6ef372;
    s->state[3] = 0xa54ff53a;
    s->state[4] = 0x510e527f;
    s->state[5] = 0x9b05688c;
    s->state[6] = 0x1f83d9ab;
    s->state[7] = 0x5be0cd19;
}

void transform(state *s, const unsigned char* data) {
    unsigned int a, b, c, d, e, f, g, h, i, j, t1, t2, m[HASH_SIZE / WORD_SIZE];

    for (i = 0, j = 0; i < BLOCK_SIZE; ++i, j += 4) {
        m[i / WORD_SIZE] |= (unsigned int)data[j] << ((i % WORD_SIZE) * 8);
    }

    a = s->state[0];
    b = s->state[1];
    c = s->state[2];
    d = s->state[3];
    e = s->state[4];
    f = s->state[5];
    g = s->state[6];
    h = s->state[7];

    for (i = 0; i < 64; ++i) {
        if (i < 16) {
            t1 = m[i];
        } else {
            t1 = m[(i + 1) % 16];
            t1 = SSIG0(t1);
            t1 += m[(i + 14) % 16];
            t1 = SSIG1(t1);
            t1 += m[i % 16];
        }

        t1 += h;
        t1 += BSIG1(e);
        t1 += CH(e, f, g);
        t1 += K[i];
        t2 = BSIG0(a);
        t2 += MAJ(a, b, c);

        h = g;
        g = f;
        f = e;
        e = d + t1;
        d = c;
        c = b;
        b = a;
        a = t1 + t2;
    }

    s->state[0] += a;
    s->state[1] += b;
    s->state[2] += c;
    s->state[3] += d;
    s->state[4] += e;
    s->state[5] += f;
    s->state[6] += g;
    s->state[7] += h;
}

void update(state *s, const unsigned char *data, unsigned int len) {
    for (unsigned int i = 0; i < len; ++i) {
        s->data[s->datalen] = data[i];
        ++s->datalen;
        if (s->datalen == BLOCK_SIZE) {
            transform(s, s->data);
            s->bitlen += BLOCK_SIZE * 8;
            s->datalen = 0;
        }
    }
}

void final(state *s, unsigned char *hash) {
    unsigned int i;

    i = s->datalen;

    // Pad whatever data is left in the buffer.
    if (s->datalen < 56) {
        s->data[i++] = 0x80;
        while (i < 56) {
            s->data[i++] = 0x00;
        }
    } else {
        s->data[i++] = 0x80;
        while (i < BLOCK_SIZE) {
            s->data[i++] = 0x00;
        }
        transform(s, s->data);
        memset(s->data, 0, 56);
    }

    // Append to the padding the total message's length in bits and transform.
    s->bitlen += s->datalen * 8;
    s->data[63] = s->bitlen;
    s->data[62] = s->bitlen >> 8;
    s->data[61] = s->bitlen >> 16;
    s->data[60] = s->bitlen >> 24;
    s->data[59] = s->bitlen >> 32;
    s->data[58] = s->bitlen >> 40;
    s->data[57] = s->bitlen >> 48;
    s->data[56] = s->bitlen >> 56;
    transform(s, s->data);

    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.
    for (i = 0; i < 4; ++i) {
        hash[i] = (s->state[0] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 4] = (s->state[1] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 8] = (s->state[2] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 12] = (s->state[3] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 16] = (s->state[4] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 20] = (s->state[5] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 24] = (s->state[6] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 28] = (s->state[7] >> (24 - i * 8)) & 0x000000ff;
    }
}

int main() {
    state s;
    unsigned char hash[HASH_SIZE];
    char message[] = "The quick brown fox jumps over the lazy dog";
    init(&s);
    update(&s, (unsigned char*)message, strlen(message));
    final(&s, hash);

    printf("Hash: ");
    for (int i = 0; i < HASH_SIZE; ++i) {
        printf("%02x", hash[i]);
    }
    printf("\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall init(_QWORD); // weak
__int64 __fastcall update(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall final(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (0000000140001C24) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char Str[48]; // [rsp+20h] [rbp-D0h] BYREF
  char v6[32]; // [rsp+50h] [rbp-A0h] BYREF
  char v7[124]; // [rsp+70h] [rbp-80h] BYREF
  int i; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  strcpy(Str, "The quick brown fox jumps over the lazy dog");
  init(v7);
  v3 = strlen(Str);
  update(v7, Str, v3);
  final(v7, v6);
  printf("Hash: ");
  for ( i = 0; i <= 31; ++i )
    printf("%02x", (unsigned __int8)v6[i]);
  printf("\n");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall init(_QWORD);
// 1400018B0: using guessed type __int64 __fastcall update(_QWORD, _QWORD, _QWORD);
// 14000194D: using guessed type __int64 __fastcall final(_QWORD, _QWORD);
// 140001DF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001C24: using guessed type char var_A0[32];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sentiment analysis tool ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#define MAX_STRING_LENGTH 100

// Function to remove punctuation marks from a string
char* remove_punctuation(char *str) {
    int i, j;
    char *new_str = (char*) malloc(strlen(str) + 1);
    for(i = 0, j = 0; str[i]; i++) {
        if(!ispunct(str[i]) || str[i] == '\'') {
            new_str[j++] = str[i];
        }
    }
    new_str[j] = '\0';
    return new_str;
}

// Function to convert all characters in a string to lowercase
char* to_lower_case(char *str) {
    int i;
    char *new_str = (char*) malloc(strlen(str) + 1);
    for(i = 0; str[i]; i++) {
        new_str[i] = tolower(str[i]);
    }
    new_str[i] = '\0';
    return new_str;
}

// Function to calculate the sentiment score of a given word
int get_score(char *word) {
    int score = 0;
    if(strcmp(word, "good") == 0 || strcmp(word, "great") == 0 || strcmp(word, "excellent") == 0) {
        score = 2;
    } else if(strcmp(word, "bad") == 0 || strcmp(word, "terrible") == 0 || strcmp(word, "horrible") == 0) {
        score = -2;
    } else if(strcmp(word, "okay") == 0) {
        score = 0;
    } else {
        score = 1;
    }
    return score;
}

// Function to calculate the overall sentiment score of a given sentence
int get_sentiment_score(char *sentence) {
    int score = 0;
    char *token;
    char *delim = " ";
    char *new_sentence = remove_punctuation(sentence);
    char *lower_case_sentence = to_lower_case(new_sentence);
    token = strtok(lower_case_sentence, delim);
    while(token != NULL) {
        score += get_score(token);
        token = strtok(NULL, delim);
    }
    free(new_sentence);
    free(lower_case_sentence);
    return score;
}

int main() {
    char input_string[MAX_STRING_LENGTH];
    printf("Enter a sentence: ");
    fgets(input_string, MAX_STRING_LENGTH, stdin);
    input_string[strcspn(input_string, "\n")] = '\0'; // Remove trailing newline character
    int sentiment_score = get_sentiment_score(input_string);
    printf("The sentiment score of the sentence is %d\n", sentiment_score);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall get_sentiment_score(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000185F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[108]; // [rsp+20h] [rbp-70h] BYREF
  unsigned int sentiment_score; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter a sentence: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  sentiment_score = get_sentiment_score(Buffer);
  printf("The sentiment score of the sentence is %d\n", sentiment_score);
  return 0;
}
// 1400017C2: using guessed type __int64 __fastcall get_sentiment_score(_QWORD);
// 1400019A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000185F: using guessed type char Buffer[108];

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Count Tool ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_CHARS 1000

int main(){
    char text[MAX_CHARS];
    int wordCount = 0;
    char* word;
    printf("Welcome to the Unique C Word Count Tool\n\n");
    printf("Enter your text: ");

    fgets(text, MAX_CHARS, stdin);

    // make a duplicate text buffer to modify
    char duplicate[MAX_CHARS];
    strcpy(duplicate, text);

    // tokenize the text to count unique words
    word = strtok(text, " ,.!?;\n");

    // put all unique words in a separate array
    char unique_words[MAX_CHARS][MAX_CHARS];
    char* temp;
    int unique_word_count = 0;

    while(word != NULL){
        int is_unique = 1;
        for(int i = 0; i < unique_word_count; i++){
            if(strcmp(unique_words[i], word) == 0){
                is_unique = 0;
                break;
            }
        }
        if(is_unique){
            strcpy(unique_words[unique_word_count], word);
            unique_word_count++;
        }

        word = strtok(NULL, " ,.!?;\n");
    }

    printf("\nUnique Words:\n");

    for(int i = 0; i < unique_word_count; i++){
        printf("%s\n", unique_words[i]);
    }

    // print each unique word's count
    printf("\nWord Count:\n");

    word = strtok(duplicate, " ,.!?;\n");

    while(word != NULL){
        int count = 0;
        for(int i = 0; i < unique_word_count; i++){
            if(strcmp(unique_words[i], word) == 0){
                count++;
            }
        }
        printf("%s: %d\n", word, count);
        word = strtok(NULL, " ,.!?;\n");
        wordCount++;
    }

    printf("\nTotal word count: %d\n", wordCount);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char v5[1000000]; // [rsp+20h] [rbp-60h] BYREF
  char Destination[1008]; // [rsp+F4260h] [rbp+F41E0h] BYREF
  char Buffer[1000]; // [rsp+F4650h] [rbp+F45D0h] BYREF
  int k; // [rsp+F4A38h] [rbp+F49B8h]
  unsigned int v9; // [rsp+F4A3Ch] [rbp+F49BCh]
  int j; // [rsp+F4A40h] [rbp+F49C0h]
  int i; // [rsp+F4A44h] [rbp+F49C4h]
  int v12; // [rsp+F4A48h] [rbp+F49C8h]
  int v13; // [rsp+F4A4Ch] [rbp+F49CCh]
  char *Str2; // [rsp+F4A50h] [rbp+F49D0h]
  unsigned int v15; // [rsp+F4A5Ch] [rbp+F49DCh]

  _main(argc, argv, envp);
  v15 = 0;
  printf("Welcome to the Unique C Word Count Tool\n\n");
  printf("Enter your text: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  strcpy(Destination, Buffer);
  Str2 = strtok(Buffer, " ,.!?;\n");
  v13 = 0;
  while ( Str2 )
  {
    v12 = 1;
    for ( i = 0; i < v13; ++i )
    {
      if ( !strcmp(&v5[1000 * i], Str2) )
      {
        v12 = 0;
        break;
      }
    }
    if ( v12 )
      strcpy(&v5[1000 * v13++], Str2);
    Str2 = strtok(0i64, " ,.!?;\n");
  }
  printf("\nUnique Words:\n");
  for ( j = 0; j < v13; ++j )
    printf("%s\n", &v5[1000 * j]);
  printf("\nWord Count:\n");
  Str2 = strtok(Destination, " ,.!?;\n");
  while ( Str2 )
  {
    v9 = 0;
    for ( k = 0; k < v13; ++k )
    {
      if ( !strcmp(&v5[1000 * k], Str2) )
        ++v9;
    }
    printf("%s: %d\n", Str2, v9);
    Str2 = strtok(0i64, " ,.!?;\n");
    ++v15;
  }
  printf("\nTotal word count: %d\n", v15);
  return 0;
}
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char var_F4A40[1000000];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Ebook reader ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//Structure for book information
struct Book {
    char title[100];
    char author[100];
    int pageCount;
    float price;
};

//Structure for page information
struct Page {
    int pageNumber;
    char content[1000];
};

//Structure for Ebook information
struct Ebook {
    struct Book book;
    int currentPage;
    struct Page *pages;
};

//Function to read ebook information from file
void readEbookFromFile(struct Ebook *ebook, char *filename) {
    FILE *file = fopen(filename, "r");
    if (file == NULL) {
        printf("Could not open file %s\n", filename);
        exit(1);
    }

    //Read book information
    fscanf(file, "%s", ebook->book.title);
    fscanf(file, "%s", ebook->book.author);
    fscanf(file, "%d", &ebook->book.pageCount);
    fscanf(file, "%f", &ebook->book.price);

    //Allocate memory for pages
    ebook->pages = (struct Page *) malloc(ebook->book.pageCount * sizeof(struct Page));

    //Read page information
    int i;
    for (i = 0; i < ebook->book.pageCount; i++) {
        fscanf(file, "%d", &ebook->pages[i].pageNumber);
        fgets(ebook->pages[i].content, 1000, file);
    }

    fclose(file);
}

//Function to display ebook information
void displayEbook(struct Ebook ebook) {
    printf("Title: %s\n", ebook.book.title);
    printf("Author: %s\n", ebook.book.author);
    printf("Page count: %d\n", ebook.book.pageCount);
    printf("Price: %.2f\n", ebook.book.price);
    printf("Current page: %d\n", ebook.currentPage);
    printf("Content: %s\n", ebook.pages[ebook.currentPage - 1].content);
}

int main() {
    struct Ebook ebook;
    char filename[] = "ebook.txt";
    readEbookFromFile(&ebook, filename);

    //Start reading from first page
    ebook.currentPage = 1;

    //Display ebook information
    displayEbook(ebook);

    //Read pages until end of book is reached
    printf("Press enter key to continue reading...");
    while (ebook.currentPage <= ebook.book.pageCount) {
        getchar();

        //Move to next page
        ebook.currentPage++;

        //Display ebook information
        displayEbook(ebook);

        //If end of book is reached, break out of loop
        if (ebook.currentPage > ebook.book.pageCount) {
            break;
        }

        printf("Press enter key to continue reading...");
    }

    free(ebook.pages);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall readEbookFromFile(_QWORD, _QWORD); // weak
__int64 __fastcall displayEbook(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();
// void __cdecl free(void *Block);


//----- (0000000140001829) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-60h] BYREF
  __int64 v5; // [rsp+28h] [rbp-58h]
  __int64 v6; // [rsp+30h] [rbp-50h]
  __int64 v7; // [rsp+38h] [rbp-48h]
  __int64 v8; // [rsp+40h] [rbp-40h]
  __int64 v9; // [rsp+48h] [rbp-38h]
  __int64 v10; // [rsp+50h] [rbp-30h]
  __int64 v11; // [rsp+58h] [rbp-28h]
  __int64 v12; // [rsp+60h] [rbp-20h]
  __int64 v13; // [rsp+68h] [rbp-18h]
  __int64 v14; // [rsp+70h] [rbp-10h]
  __int64 v15; // [rsp+78h] [rbp-8h]
  __int64 v16; // [rsp+80h] [rbp+0h]
  __int64 v17; // [rsp+88h] [rbp+8h]
  __int64 v18; // [rsp+90h] [rbp+10h]
  __int64 v19; // [rsp+98h] [rbp+18h]
  __int64 v20; // [rsp+A0h] [rbp+20h]
  __int64 v21; // [rsp+A8h] [rbp+28h]
  __int64 v22; // [rsp+B0h] [rbp+30h]
  __int64 v23; // [rsp+B8h] [rbp+38h]
  __int64 v24; // [rsp+C0h] [rbp+40h]
  __int64 v25; // [rsp+C8h] [rbp+48h]
  __int64 v26; // [rsp+D0h] [rbp+50h]
  __int64 v27; // [rsp+D8h] [rbp+58h]
  __int64 v28; // [rsp+E0h] [rbp+60h]
  __int64 v29; // [rsp+E8h] [rbp+68h]
  __int64 v30; // [rsp+F0h] [rbp+70h]
  void *v31; // [rsp+F8h] [rbp+78h]
  _WORD v32[9]; // [rsp+106h] [rbp+86h] BYREF
  __int64 v33; // [rsp+118h] [rbp+98h]
  __int64 v34; // [rsp+120h] [rbp+A0h]
  __int64 v35; // [rsp+128h] [rbp+A8h]
  __int64 v36; // [rsp+130h] [rbp+B0h]
  __int64 v37; // [rsp+138h] [rbp+B8h]
  __int64 v38; // [rsp+140h] [rbp+C0h]
  __int64 v39; // [rsp+148h] [rbp+C8h]
  __int64 v40; // [rsp+150h] [rbp+D0h]
  __int64 v41; // [rsp+158h] [rbp+D8h]
  __int64 v42; // [rsp+160h] [rbp+E0h]
  __int64 v43; // [rsp+168h] [rbp+E8h]
  __int64 v44; // [rsp+170h] [rbp+F0h]
  __int64 v45; // [rsp+178h] [rbp+F8h]
  __int64 v46; // [rsp+180h] [rbp+100h]
  __int64 v47; // [rsp+188h] [rbp+108h]
  __int64 v48; // [rsp+190h] [rbp+110h]
  __int64 v49; // [rsp+198h] [rbp+118h]
  __int64 v50; // [rsp+1A0h] [rbp+120h]
  __int64 v51; // [rsp+1A8h] [rbp+128h]
  __int64 v52; // [rsp+1B0h] [rbp+130h]
  __int64 v53; // [rsp+1B8h] [rbp+138h]
  __int64 v54; // [rsp+1C0h] [rbp+140h]
  __int64 v55; // [rsp+1C8h] [rbp+148h]
  __int64 v56; // [rsp+1D0h] [rbp+150h]
  __int64 v57; // [rsp+1D8h] [rbp+158h]
  __int64 v58; // [rsp+1E0h] [rbp+160h]
  void *Block; // [rsp+1E8h] [rbp+168h]

  _main(argc, argv, envp);
  strcpy((char *)v32, "ebook.txt");
  readEbookFromFile(&v32[5], v32);
  LODWORD(v58) = 1;
  v4 = *(_QWORD *)&v32[5];
  v5 = v33;
  v6 = v34;
  v7 = v35;
  v8 = v36;
  v9 = v37;
  v10 = v38;
  v11 = v39;
  v12 = v40;
  v13 = v41;
  v14 = v42;
  v15 = v43;
  v16 = v44;
  v17 = v45;
  v18 = v46;
  v19 = v47;
  v20 = v48;
  v21 = v49;
  v22 = v50;
  v23 = v51;
  v24 = v52;
  v25 = v53;
  v26 = v54;
  v27 = v55;
  v28 = v56;
  v29 = v57;
  v30 = v58;
  v31 = Block;
  displayEbook(&v4);
  printf("Press enter key to continue reading...");
  while ( (int)v58 <= (int)v57 )
  {
    getchar();
    LODWORD(v58) = v58 + 1;
    v4 = *(_QWORD *)&v32[5];
    v5 = v33;
    v6 = v34;
    v7 = v35;
    v8 = v36;
    v9 = v37;
    v10 = v38;
    v11 = v39;
    v12 = v40;
    v13 = v41;
    v14 = v42;
    v15 = v43;
    v16 = v44;
    v17 = v45;
    v18 = v46;
    v19 = v47;
    v20 = v48;
    v21 = v49;
    v22 = v50;
    v23 = v51;
    v24 = v52;
    v25 = v53;
    v26 = v54;
    v27 = v55;
    v28 = v56;
    v29 = v57;
    v30 = v58;
    v31 = Block;
    displayEbook(&v4);
    if ( (int)v58 > (int)v57 )
      break;
    printf("Press enter key to continue reading...");
  }
  free(Block);
  return 0;
}
// 1400015D4: using guessed type __int64 __fastcall readEbookFromFile(_QWORD, _QWORD);
// 140001759: using guessed type __int64 __fastcall displayEbook(_QWORD);
// 140001C30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Appointment Scheduler ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>

// Define global variables
#define MAX_LENGTH 256
#define MAX_APPOINTMENTS 50

// Define struct for appointment
typedef struct Appointment {
    char date[MAX_LENGTH];
    char time[MAX_LENGTH];
    char name[MAX_LENGTH];
    char type[MAX_LENGTH];
} Appointment;

// Define function to display appointments
void display_appointments(Appointment* appointments, int num_appointments) {
    printf("\n%-15s%-15s%-15s%-15s\n", "Date", "Time", "Name", "Type");
    for(int i=0; i<num_appointments; i++) {
        printf("%-15s%-15s%-15s%-15s\n", 
            appointments[i].date, 
            appointments[i].time, 
            appointments[i].name, 
            appointments[i].type);
    }
}

// Define function to add new appointment
void add_appointment(Appointment* appointments, int* num_appointments) {
    // Check if there is already maximum number of appointments
    if(*num_appointments >= MAX_APPOINTMENTS) {
        printf("\nMaximum number of appointments reached. Cannot add more appointments.\n");
        return;
    }
    
    // Create new appointment
    Appointment new_appointment;
    printf("\nEnter date of appointment (MM/DD/YYYY format): ");
    scanf("%s", new_appointment.date);
    printf("Enter time of appointment (HH:MM format): ");
    scanf("%s", new_appointment.time);
    printf("Enter name of person for appointment: ");
    scanf("%s", new_appointment.name);
    printf("Enter type of appointment: ");
    scanf("%s", new_appointment.type);
    
    // Add new appointment to array
    appointments[*num_appointments] = new_appointment;
    *num_appointments += 1;
    
    printf("\nAppointment added!\n");
}

// Define function to remove existing appointment
void remove_appointment(Appointment* appointments, int* num_appointments) {
    // Check if there are any appointments
    if(*num_appointments == 0) {
        printf("\nNo appointments to remove.\n");
        return;
    }
    
    // Get user input for appointment to remove
    char name[MAX_LENGTH];
    printf("\nEnter name of person for appointment to remove: ");
    scanf("%s", name);
    
    // Find index of appointment with matching name
    int index = -1;
    for(int i=0; i<*num_appointments; i++) {
        if(strcmp(appointments[i].name, name) == 0) {
            index = i;
            break;
        }
    }
    
    // Check if appointment was found
    if(index == -1) {
        printf("\nNo appointment found with that name.\n");
        return;
    }
    
    // Remove appointment from array
    for(int i=index; i<*num_appointments-1; i++) {
        appointments[i] = appointments[i+1];
    }
    *num_appointments -= 1;
    
    printf("\nAppointment removed!\n");
}

// Define function to find appointments on given date
void find_appointments(Appointment* appointments, int num_appointments) {
    // Get user input for date to search
    char date[MAX_LENGTH];
    printf("\nEnter date to find appointments (MM/DD/YYYY format): ");
    scanf("%s", date);
    
    // Print appointment(s) with matching date
    printf("\nAppointments on %s:\n", date);
    bool found = false;
    for(int i=0; i<num_appointments; i++) {
        if(strcmp(appointments[i].date, date) == 0) {
            printf("%s: %s with %s (%s)\n", 
                appointments[i].time, 
                appointments[i].type, 
                appointments[i].name, 
                appointments[i].date);
            found = true;
        }
    }
    if(!found) {
        printf("No appointments found on that date.\n");
    }
}

int main() {
    // Define variables
    int num_appointments = 0;
    Appointment appointments[MAX_APPOINTMENTS];
    bool running = true;
    char command[MAX_LENGTH];
    
    // Loop until user quits
    while(running) {
        // Display menu
        printf("\n---Appointment Scheduler---\n");
        printf("1. Display appointments\n");
        printf("2. Add appointment\n");
        printf("3. Remove appointment\n");
        printf("4. Find appointments\n");
        printf("5. Quit\n");
        printf("---------------------------\n");
        printf("Enter command: ");
        scanf("%s", command);
        
        // Choose action based on command
        if(strcmp(command, "1") == 0) {
            display_appointments(appointments, num_appointments);
        } else if(strcmp(command, "2") == 0) {
            add_appointment(appointments, &num_appointments);
        } else if(strcmp(command, "3") == 0) {
            remove_appointment(appointments, &num_appointments);
        } else if(strcmp(command, "4") == 0) {
            find_appointments(appointments, num_appointments);
        } else if(strcmp(command, "5") == 0) {
            running = false;
            printf("\nGoodbye!\n");
        } else {
            printf("\nInvalid command.\n");
        }
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall display_appointments(_QWORD, _QWORD); // weak
__int64 __fastcall add_appointment(_QWORD, _QWORD); // weak
__int64 __fastcall remove_appointment(_QWORD, _QWORD); // weak
__int64 __fastcall find_appointments(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (0000000140001BA3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[256]; // [rsp+20h] [rbp-60h] BYREF
  char v5[51208]; // [rsp+120h] [rbp+A0h] BYREF
  unsigned int v6; // [rsp+C928h] [rbp+C8A8h] BYREF
  char v7; // [rsp+C92Fh] [rbp+C8AFh]

  _main(argc, argv, envp);
  v6 = 0;
  v7 = 1;
  while ( v7 )
  {
    printf("\n---Appointment Scheduler---\n");
    printf("1. Display appointments\n");
    printf("2. Add appointment\n");
    printf("3. Remove appointment\n");
    printf("4. Find appointments\n");
    printf("5. Quit\n");
    printf("---------------------------\n");
    printf("Enter command: ");
    scanf("%s", Str1);
    if ( !strcmp(Str1, "1") )
    {
      display_appointments(v5, v6);
    }
    else if ( !strcmp(Str1, "2") )
    {
      add_appointment(v5, &v6);
    }
    else if ( !strcmp(Str1, "3") )
    {
      remove_appointment(v5, &v6);
    }
    else if ( !strcmp(Str1, "4") )
    {
      find_appointments(v5, v6);
    }
    else if ( !strcmp(Str1, "5") )
    {
      v7 = 0;
      printf("\nGoodbye!\n");
    }
    else
    {
      printf("\nInvalid command.\n");
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall display_appointments(_QWORD, _QWORD);
// 1400016C5: using guessed type __int64 __fastcall add_appointment(_QWORD, _QWORD);
// 14000184D: using guessed type __int64 __fastcall remove_appointment(_QWORD, _QWORD);
// 140001A26: using guessed type __int64 __fastcall find_appointments(_QWORD, _QWORD);
// 140001E30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001BA3: using guessed type unsigned int var_8;

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ROWS 10
#define COLS 10

/* function to print the maze */
void printMaze(char maze[][COLS], int startRow, int startCol, int endRow, int endCol) {
    for(int i=0;i<ROWS;i++) {
        for(int j=0;j<COLS;j++) {
            if(i == startRow && j == startCol) {
                printf("| S ");
            } else if(i == endRow && j == endCol) {
                printf("| E ");
            } else {
                printf("| %c ", maze[i][j]);
            }
        }
        printf("|\n");
    }
}

/* function to find the path from start to end */
void findPath(char maze[][COLS], int startRow, int startCol, int endRow, int endCol) {
    int path[ROWS*COLS][2], top=-1;
    int visited[ROWS][COLS], flag=0;
    memset(visited, 0, sizeof(visited));
    visited[startRow][startCol] = 1;
    path[++top][0] = startRow;
    path[top][1] = startCol;
    
    while(top >= 0) {
        int row = path[top][0];
        int col = path[top][1];
        if(row == endRow && col == endCol) {
            flag = 1;
            break;
        }
        top--;
        if(row>0 && maze[row-1][col]=='0' && visited[row-1][col]==0) {
            path[++top][0] = row-1;
            path[top][1] = col;
            visited[row-1][col] = 1;
        }
        if(col>0 && maze[row][col-1]=='0' && visited[row][col-1]==0) {
            path[++top][0] = row;
            path[top][1] = col-1;
            visited[row][col-1] = 1;
        }
        if(row<ROWS-1 && maze[row+1][col]=='0' && visited[row+1][col]==0) {
            path[++top][0] = row+1;
            path[top][1] = col;
            visited[row+1][col] = 1;
        }
        if(col<COLS-1 && maze[row][col+1]=='0' && visited[row][col+1]==0) {
            path[++top][0] = row;
            path[top][1] = col+1;
            visited[row][col+1] = 1;
        }
    }
    if(flag == 0) {
        printf("\nPath not found!\n\n");
    } else {
        // print the path
        printf("\nPath:\n");
        for(int i=top;i>=0;i--) {
            printf("(%d,%d)\n", path[i][0], path[i][1]);
        }
        printf("\n");
    }
}

int main() {
    char maze[ROWS][COLS] = {
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '1', '1', '1', '1', '1', '1', '1', '0', '1'},
        {'0', '1', '0', '0', '0', '0', '0', '0', '0', '1'},
        {'0', '1', '1', '0', '1', '1', '1', '1', '0', '1'},
        {'0', '1', '0', '0', '1', '0', '0', '0', '0', '0'},
        {'0', '1', '1', '0', '1', '0', '1', '1', '1', '0'},
        {'0', '1', '0', '0', '1', '0', '1', '0', '0', '0'},
        {'0', '1', '0', '1', '1', '0', '1', '0', '1', '0'},
        {'0', '1', '1', '0', '0', '0', '0', '0', '0', '1'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'}
    };
    int startRow = 1, startCol = 1;
    int endRow = 8, endCol = 9;
    
    printf("\nMaze:\n");
    printMaze(maze, startRow, startCol, endRow, endCol);
    
    findPath(maze, startRow, startCol, endRow, endCol);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printMaze(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
__int64 __fastcall findPath(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001B72) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[14]; // [rsp+30h] [rbp-80h] BYREF
  int v5; // [rsp+A0h] [rbp-10h]
  int v6; // [rsp+A4h] [rbp-Ch]
  int v7; // [rsp+A8h] [rbp-8h]
  int v8; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  qmemcpy(
    v4,
    "0000000000011111110101000000010110111101010010000001101011100100101000010110101001100000010000000000",
    100);
  v8 = 1;
  v7 = 1;
  v6 = 8;
  v5 = 9;
  printf("\nMaze:\n");
  printMaze((unsigned int)v4, 1, 1, 8, 9);
  findPath((unsigned int)v4, v8, v7, v6, v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printMaze(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14000166F: using guessed type __int64 __fastcall findPath(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 140001D70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue Implementation ; Style: satisfied
#include <stdio.h> 
#define MAX_QUEUE_SIZE 100 

int queue[MAX_QUEUE_SIZE], front = -1, rear = -1; 

int isFull(){ //to check if queue is full
    return (rear == MAX_QUEUE_SIZE - 1); 
} 

int isEmpty(){ //to check if queue is empty
    return (front == -1 && rear == -1); 
} 

void enqueue(int data){ //to insert elements into queue
    if(isFull()){ 
        printf("\nError: Queue is full\n"); 
        return; 
    } 
    else if(isEmpty()){ 
        front = rear = 0; 
    } 
    else{ 
        rear++; 
    } 
    queue[rear] = data; 
    printf("\nInserted %d into queue", data); 
} 

void dequeue(){ //to remove elements from queue
    if(isEmpty()){ 
        printf("\nError: Queue is empty\n"); 
        return; 
    } 
    else if(front == rear){ 
        front = rear = -1; 
    } 
    else{ 
        front++; 
    } 
    printf("\nRemoved %d from queue", queue[front-1]); 
} 

void display(){ //to display the elements in the queue
    if(isEmpty()){ 
        printf("\nQueue is empty\n"); 
        return; 
    } 
    for(int i=front; i<=rear; i++){ 
        printf("%d ",queue[i]); 
    } 
} 

int main(){ 
    int choice, data; 

    do{ //loop to keep the program running until the user chooses to exit
        printf("\n\nQUEUE IMPLEMENTATION IN C\n"); 
        printf("\n1. Insert element into queue"); 
        printf("\n2. Remove element from queue"); 
        printf("\n3. Display elements in queue"); 
        printf("\n4. Exit"); 
        printf("\nEnter your choice: "); 

        scanf("%d", &choice); 

        switch(choice){ //switch statement to perform corresponding operation based on user choice
            case 1: printf("\nEnter data to insert: ");
                    scanf("%d", &data);
                    enqueue(data); 
                    break; 

            case 2: dequeue();
                    break; 

            case 3: display();
                    break; 

            case 4: printf("\nExiting program");
                    break; 

            default: printf("\nInvalid choice"); 
        } 
    }while(choice != 4); 

    return 0; 
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall enqueue(_QWORD); // weak
__int64 dequeue(void); // weak
__int64 display(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400017A2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-8h] BYREF
  int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("\n\nQUEUE IMPLEMENTATION IN C\n");
    printf("\n1. Insert element into queue");
    printf("\n2. Remove element from queue");
    printf("\n3. Display elements in queue");
    printf("\n4. Exit");
    printf("\nEnter your choice: ");
    scanf("%d", &v5);
    if ( v5 == 4 )
    {
      printf("\nExiting program");
    }
    else
    {
      if ( v5 <= 4 )
      {
        switch ( v5 )
        {
          case 3:
            display();
            continue;
          case 1:
            printf("\nEnter data to insert: ");
            scanf("%d", &v4);
            enqueue(v4);
            continue;
          case 2:
            dequeue();
            continue;
        }
      }
      printf("\nInvalid choice");
    }
  }
  while ( v5 != 4 );
  return 0;
}
// 140001834: conditional instruction was optimized away because %var_4.4<3
// 14000161F: using guessed type __int64 __fastcall enqueue(_QWORD);
// 1400016AA: using guessed type __int64 dequeue(void);
// 140001738: using guessed type __int64 display(void);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: Donald Knuth
#include <stdio.h>

void sorting(int arr[], int size) {
  int i, j, temp;

  for(i = 0; i < size - 1; i++) {
    for(j = i + 1; j < size; j++) {
      if(arr[i] > arr[j]) {
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
  }
}

void display(int arr[], int size) {
  int i;

  printf("Sorted Array\n");
  for(i = 0; i < size; i++) {
    printf("%d\n", arr[i]);
  }
}

int main() {
  int arr[] = {5, 1, 4, 2, 0, 6, 3};
  int size = sizeof(arr)/sizeof(arr[0]);

  printf("Unsorted Array\n");
  display(arr, size);

  sorting(arr, size);

  display(arr, size);
  
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall sorting(_QWORD, _QWORD); // weak
__int64 __fastcall display(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016D6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[7]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v5; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 5;
  v4[1] = 1;
  v4[2] = 4;
  v4[3] = 2;
  v4[4] = 0;
  v4[5] = 6;
  v4[6] = 3;
  v5 = 7;
  printf("Unsorted Array\n");
  display(v4, 7i64);
  sorting(v4, v5);
  display(v4, v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall sorting(_QWORD, _QWORD);
// 140001674: using guessed type __int64 __fastcall display(_QWORD, _QWORD);
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Hexadecimal Converter ; Style: high level of detail
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

// Function to convert decimal number to hexadecimal number
void decimalToHexadecimal(int num) {
    char hex[100];
    int i = 0, rem;
    while (num != 0) {
        rem = num % 16;
        if (rem < 10) {
            hex[i++] = rem + 48;
        } else {
            hex[i++] = rem + 55;
        }
        num /= 16;
    }

    printf("Hexadecimal number is: ");
    for (int j = i - 1; j >= 0; j--) {
        printf("%c", hex[j]);
    }
}

// Function to convert hexadecimal number to decimal number
int hexadecimalToDecimal(char *hex) {
    int decimal = 0, len = strlen(hex), base = 1;

    for (int i = len - 1; i >= 0; i--) {
        if (hex[i] >= '0' && hex[i] <= '9') {
            decimal += (hex[i] - 48) * base;
            base *= 16;
        } else if (hex[i] >= 'A' && hex[i] <= 'F') {
            decimal += (hex[i] - 55) * base;
            base *= 16;
        }
    }

    return decimal;
}

int main() {
    int choice;

    do {
        printf("1. Decimal to Hexadecimal Conversion\n");
        printf("2. Hexadecimal to Decimal Conversion\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                int decimal;
                printf("\nEnter decimal number: ");
                scanf("%d", &decimal);
                decimalToHexadecimal(decimal);
                printf("\n\n");
                break;
            case 2:
                char hex[100];
                printf("\nEnter hexadecimal number: ");
                scanf("%s", hex);
                printf("Decimal number is: %d\n\n", hexadecimalToDecimal(hex));
                break;
            case 3:
                printf("Thank you for using Hexadecimal Converter!\n\n");
                exit(0);
            default:
                printf("Invalid choice!\n\n");
        }
    } while (choice != 3);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall decimalToHexadecimal(_QWORD); // weak
__int64 __fastcall hexadecimalToDecimal(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001783) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[104]; // [rsp+20h] [rbp-70h] BYREF
  unsigned int v6; // [rsp+88h] [rbp-8h] BYREF
  int v7; // [rsp+8Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("1. Decimal to Hexadecimal Conversion\n");
    printf("2. Hexadecimal to Decimal Conversion\n");
    printf("3. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v7);
    if ( v7 == 3 )
    {
      printf("Thank you for using Hexadecimal Converter!\n\n");
      exit(0);
    }
    if ( v7 > 3 )
      goto LABEL_10;
    if ( v7 == 1 )
    {
      printf("\nEnter decimal number: ");
      scanf("%d", &v6);
      decimalToHexadecimal(v6);
      printf("\n\n");
      continue;
    }
    if ( v7 == 2 )
    {
      printf("\nEnter hexadecimal number: ");
      scanf("%s", v5);
      v3 = hexadecimalToDecimal(v5);
      printf("Decimal number is: %d\n\n", v3);
    }
    else
    {
LABEL_10:
      printf("Invalid choice!\n\n");
    }
  }
  while ( v7 != 3 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall decimalToHexadecimal(_QWORD);
// 1400016A4: using guessed type __int64 __fastcall hexadecimalToDecimal(_QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Product Inventory System ; Style: safe
#include <stdio.h>
#include <string.h>

#define MAX_PRODUCTS 100     // Maximum number of products that can be stored
#define MAX_NAME_LENGTH 50   // Maximum length of product name
#define MAX_CATEGORY_LENGTH 20  // Maximum length of category name
#define MAX_LOCATION_LENGTH 20  // Maximum length of storage location name

// Struct to hold information about a single product
typedef struct {
    int id;                    // Unique id of the product
    char name[MAX_NAME_LENGTH];    // Name of the product
    char category[MAX_CATEGORY_LENGTH];      // Category of the product
    char location[MAX_LOCATION_LENGTH];      // Storage location of the product
    int quantity;              // Quantity of the product
    float price;               // Price of the product
} Product;

// Function declarations
void initialize(Product *inventory, int *size);
void addProduct(Product *inventory, int *size);
void removeProduct(Product *inventory, int *size);
void displayProductInventory(Product *inventory, int size);
void showMenu();

// Main function
int main() {
    Product inventory[MAX_PRODUCTS];   // Array to hold product information
    int numProducts = 0;         // Number of products in the array
    int choice;                  // User's menu choice

    // Initialize the product inventory with default values
    initialize(inventory, &numProducts);

    do {
        // Display the menu and get the user's choice
        showMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);

        // Perform the appropriate action based on the user's choice
        switch (choice) {
            case 1:
                addProduct(inventory, &numProducts);
                break;
            case 2:
                removeProduct(inventory, &numProducts);
                break;
            case 3:
                displayProductInventory(inventory, numProducts);
                break;
            case 4:
                printf("Goodbye!\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    } while (choice != 4);

    return 0;
}

// Function to initialize the product inventory with default values
void initialize(Product *inventory, int *size) {
    *size = 4;

    inventory[0].id = 1;
    strcpy(inventory[0].name, "Watch");
    strcpy(inventory[0].category, "Accessories");
    strcpy(inventory[0].location, "Shelf 1");
    inventory[0].quantity = 10;
    inventory[0].price = 50.0;

    inventory[1].id = 2;
    strcpy(inventory[1].name, "T-shirt");
    strcpy(inventory[1].category, "Clothing");
    strcpy(inventory[1].location, "Rack 1");
    inventory[1].quantity = 20;
    inventory[1].price = 25.0;

    inventory[2].id = 3;
    strcpy(inventory[2].name, "Laptop");
    strcpy(inventory[2].category, "Electronics");
    strcpy(inventory[2].location, "Counter");
    inventory[2].quantity = 5;
    inventory[2].price = 1000.0;

    inventory[3].id = 4;
    strcpy(inventory[3].name, "Jeans");
    strcpy(inventory[3].category, "Clothing");
    strcpy(inventory[3].location, "Rack 2");
    inventory[3].quantity = 15;
    inventory[3].price = 50.0;
}

// Function to add a product to the inventory
void addProduct(Product *inventory, int *size) {
    Product newProduct;
    int idExists = 0;
    int id;

    // Get input from the user for the new product
    printf("Enter the name of the product: ");
    scanf("%s", newProduct.name);

    printf("Enter the category of the product: ");
    scanf("%s", newProduct.category);

    printf("Enter the storage location of the product: ");
    scanf("%s", newProduct.location);

    printf("Enter the quantity of the product: ");
    scanf("%d", &newProduct.quantity);

    printf("Enter the price of the product: ");
    scanf("%f", &newProduct.price);

    // Generate a unique id for the new product
    do {
        printf("Enter a unique id for the product: ");
        scanf("%d", &id);

        // Check if the id already exists in the inventory
        for (int i = 0; i < *size; i++) {
            if (inventory[i].id == id) {
                printf("Error: id already exists in inventory, please choose a different id.\n");
                idExists = 1;
                break;
            }
        }
    } while (idExists);

    // Assign the generated id to the new product
    newProduct.id = id;

    // Add the new product to the inventory
    inventory[*size] = newProduct;
    (*size)++;

    printf("Product added to inventory successfully!\n");
}

// Function to remove a product from the inventory
void removeProduct(Product *inventory, int *size) {
    int id, index, found = 0;

    // Get input from the user for the product to be removed
    printf("Enter the id of the product to be removed: ");
    scanf("%d", &id);

    // Search for the product in the inventory and get its index
    for (int i = 0; i < *size; i++) {
        if (inventory[i].id == id) {
            index = i;
            found = 1;
            break;
        }
    }

    // If the product is found, remove it from the inventory
    if (found) {
        for (int i = index; i < (*size - 1); i++) {
            inventory[i] = inventory[i + 1];
        }
        (*size)--;
        printf("Product removed from inventory successfully!\n");
    } else {
        printf("Error: product with id %d not found in inventory.\n", id);
    }
}

// Function to display the product inventory
void displayProductInventory(Product *inventory, int size) {
    printf("Product Inventory:\n");
    printf("ID\tName\t\tCategory\tLocation\tQuantity\tPrice\n");
    for (int i = 0; i < size; i++) {
        printf("%d\t%s\t\t%s\t\t%s\t\t%d\t\t%.2f\n", inventory[i].id, inventory[i].name,
             inventory[i].category, inventory[i].location, inventory[i].quantity, inventory[i].price);
    }
}

// Function to display the menu of options
void showMenu() {
    printf("\nProduct Inventory System\n");
    printf("------------------------\n");
    printf("1. Add a new product\n");
    printf("2. Remove a product\n");
    printf("3. Display inventory\n");
    printf("4. Quit\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall initialize(_QWORD, _QWORD); // weak
__int64 __fastcall addProduct(_QWORD, _QWORD); // weak
__int64 __fastcall removeProduct(_QWORD, _QWORD); // weak
__int64 __fastcall displayProductInventory(_QWORD, _QWORD); // weak
__int64 showMenu(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[10400]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  initialize(v6, &v5);
  do
  {
    showMenu();
    printf("Enter your choice: ");
    scanf("%d", &v4);
    if ( v4 == 4 )
    {
      printf("Goodbye!\n");
    }
    else
    {
      if ( v4 <= 4 )
      {
        switch ( v4 )
        {
          case 3:
            displayProductInventory(v6, v5);
            continue;
          case 1:
            addProduct(v6, &v5);
            continue;
          case 2:
            removeProduct(v6, &v5);
            continue;
        }
      }
      printf("Invalid choice, please try again.\n");
    }
  }
  while ( v4 != 4 );
  return 0;
}
// 140001653: conditional instruction was optimized away because %var_28A8.4<3
// 1400016D0: using guessed type __int64 __fastcall initialize(_QWORD, _QWORD);
// 1400018F0: using guessed type __int64 __fastcall addProduct(_QWORD, _QWORD);
// 140001B26: using guessed type __int64 __fastcall removeProduct(_QWORD, _QWORD);
// 140001CD1: using guessed type __int64 __fastcall displayProductInventory(_QWORD, _QWORD);
// 140001E37: using guessed type __int64 showMenu(void);
// 140001F50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Terminal Based Game ; Style: Romeo and Juliet
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(0));
    int romeo_health = 100, juliet_health = 100;

    printf("Welcome to Romeo and Juliet Battle Game!\n");
    printf("Romeo and Juliet will fight to the death!\n");

    // Start game loop
    while (1) {
        int round = rand() % 2; // Randomly choose turn order 1 for Romeo 0 for Juliet
        int damage, dodge;

        if (round) { // Romeo goes first
            dodge = rand() % 2; // Randomly choose if Juliet can dodge Romeo's attack
            printf("Romeo attacks Juliet!\n");
            if (dodge) {
                printf("Juliet dodges Romeo's attack!\n");
                continue;
            }
            damage = rand() % 30 + 10; // Randomly generate damage between 10 and 40
            juliet_health -= damage;
            printf("Juliet takes %d damage from Romeo's attack!\n", damage);
            printf("Juliet's health is now %d!\n", juliet_health);
        } else { // Juliet goes first
            dodge = rand() % 2; // Randomly choose if Romeo can dodge Juliet's attack
            printf("Juliet attacks Romeo!\n");
            if (dodge) {
                printf("Romeo dodges Juliet's attack!\n");
                continue;
            }
            damage = rand() % 30 + 10; // Randomly generate damage between 10 and 40
            romeo_health -= damage;
            printf("Romeo takes %d damage from Juliet's attack!\n", damage);
            printf("Romeo's health is now %d!\n", romeo_health);
        }

        // Check if either character has died
        if (romeo_health <= 0) {
            printf("Juliet has defeated Romeo! Romeo is dead!\n");
            break;
        }
        if (juliet_health <= 0) {
            printf("Romeo has defeated Juliet! Juliet is dead!\n");
            break;
        }
    }

    printf("\nThanks for playing Romeo and Juliet Battle Game!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-14h]
  unsigned int v6; // [rsp+2Ch] [rbp-14h]
  int v7; // [rsp+30h] [rbp-10h]
  int v8; // [rsp+30h] [rbp-10h]
  int v9; // [rsp+38h] [rbp-8h]
  int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v10 = 100;
  v9 = 100;
  printf("Welcome to Romeo and Juliet Battle Game!\n");
  printf("Romeo and Juliet will fight to the death!\n");
  do
  {
    while ( 1 )
    {
      while ( rand() % 2 )
      {
        v7 = rand() % 2;
        printf("Romeo attacks Juliet!\n");
        if ( !v7 )
        {
          v5 = rand() % 30 + 10;
          v9 -= v5;
          printf("Juliet takes %d damage from Romeo's attack!\n", v5);
          printf("Juliet's health is now %d!\n", (unsigned int)v9);
          goto LABEL_9;
        }
        printf("Juliet dodges Romeo's attack!\n");
      }
      v8 = rand() % 2;
      printf("Juliet attacks Romeo!\n");
      if ( !v8 )
        break;
      printf("Romeo dodges Juliet's attack!\n");
    }
    v6 = rand() % 30 + 10;
    v10 -= v6;
    printf("Romeo takes %d damage from Juliet's attack!\n", v6);
    printf("Romeo's health is now %d!\n", (unsigned int)v10);
LABEL_9:
    if ( v10 <= 0 )
    {
      printf("Juliet has defeated Romeo! Romeo is dead!\n");
      goto LABEL_13;
    }
  }
  while ( v9 > 0 );
  printf("Romeo has defeated Juliet! Juliet is dead!\n");
LABEL_13:
  printf("\nThanks for playing Romeo and Juliet Battle Game!\n");
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sudoku solver ; Style: ephemeral
#include <stdio.h>
#include <stdbool.h>

#define SIZE 9

void printBoard(int board[][SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf("%d ", board[i][j]);
        }
        printf("\n");
    }
}

bool rowContains(int board[][SIZE], int row, int num) {
    for (int i = 0; i < SIZE; i++) {
        if (board[row][i] == num) {
            return true;
        }
    }
    return false;
}

bool colContains(int board[][SIZE], int col, int num) {
    for (int i = 0; i < SIZE; i++) {
        if (board[i][col] == num) {
            return true;
        }
    }
    return false;
}

bool boxContains(int board[][SIZE], int boxStartRow, int boxStartCol, int num) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (board[i + boxStartRow][j + boxStartCol] == num) {
                return true;
            }
        }
    }
    return false;
}

bool isSafe(int board[][SIZE], int row, int col, int num) {
    return !rowContains(board, row, num) &&
           !colContains(board, col, num) &&
           !boxContains(board, row - row % 3, col - col % 3, num);
}

bool findEmptySpot(int board[][SIZE], int *row, int *col) {
    for (*row = 0; *row < SIZE; (*row)++) {
        for (*col = 0; *col < SIZE; (*col)++) {
            if (board[*row][*col] == 0) {
                return true;
            }
        }
    }
    return false;
}

bool solveSudoku(int board[][SIZE]) {
    int row, col;
    if (!findEmptySpot(board, &row, &col)) {
        return true;
    }
    for (int num = 1; num <= 9; num++) {
        if (isSafe(board, row, col, num)) {
            board[row][col] = num;
            if (solveSudoku(board)) {
                return true;
            }
            board[row][col] = 0;
        }
    }
    return false;
}

int main() {
    // Board to solve
    int board[SIZE][SIZE] = {
        {3, 0, 6, 5, 0, 8, 4, 0, 0},
        {5, 2, 0, 0, 0, 0, 0, 0, 0},
        {0, 8, 7, 0, 0, 0, 0, 3, 1},
        {0, 0, 3, 0, 0, 0, 0, 2, 0},
        {9, 0, 0, 8, 0, 0, 0, 0, 5},
        {0, 5, 0, 0, 0, 0, 6, 0, 0},
        {1, 3, 0, 0, 0, 0, 2, 5, 0},
        {0, 0, 0, 0, 0, 0, 0, 7, 4},
        {0, 0, 5, 2, 0, 6, 3, 0, 0}
    };

    // Print the unsolved board
    printf("Unsolved Sudoku Board:\n");
    printBoard(board);

    // Solve the Sudoku and print the solved board
    if (solveSudoku(board)) {
        printf("Solved Sudoku Board:\n");
        printBoard(board);
    } else {
        printf("No solution exists for this Sudoku Board\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printBoard(_QWORD); // weak
__int64 __fastcall solveSudoku(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (00000001400019AD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[352]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v4, &unk_14000A020, 0x144ui64);
  printf("Unsolved Sudoku Board:\n");
  printBoard(v4);
  if ( (unsigned __int8)solveSudoku(v4) )
  {
    printf("Solved Sudoku Board:\n");
    printBoard(v4);
  }
  else
  {
    printf("No solution exists for this Sudoku Board\n");
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printBoard(_QWORD);
// 1400018CE: using guessed type __int64 __fastcall solveSudoku(_QWORD);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Alien Invasion Probability Calculator ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int invasion_probability = 0;
    
    srand(time(NULL));
    
    // Determine the invasion probability
    for (int i = 0; i < 10; i++) {
        int alien_ships = (rand() % 100) + 1; // Generate random number between 1 to 100
        
        // If number is between 1 to 25, assign invasion_probability as high
        if (alien_ships >= 1 && alien_ships <= 25) {
            invasion_probability = invasion_probability + 30;
        }
        
        // If number is between 26 to 75, assign invasion_probability as medium
        else if (alien_ships >= 26 && alien_ships <= 75) {
            invasion_probability = invasion_probability + 20;
        }
        
        // If number is between 76 to 100, assign invasion_probability as low
        else if (alien_ships >= 76 && alien_ships <= 100) {
            invasion_probability = invasion_probability + 10;
        }
    }
    
    printf("Alien invasion probability: %d%%\n", invasion_probability);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-Ch]
  int i; // [rsp+28h] [rbp-8h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 0;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 9; ++i )
  {
    v5 = rand() % 100 + 1;
    if ( v5 <= 0 || v5 > 25 )
    {
      if ( v5 <= 25 || v5 > 75 )
      {
        if ( v5 > 75 && v5 <= 100 )
          v7 += 10;
      }
      else
      {
        v7 += 20;
      }
    }
    else
    {
      v7 += 30;
    }
  }
  printf("Alien invasion probability: %d%%\n", v7);
  return 0;
}
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>

int main() {
  float total_amount = 0.0, discount = 0.0, net_amount = 0.0, service_tax = 0.0, vat = 0.0, grand_total = 0.0;
  int num_items = 0, i = 0;
  char choice;

  printf("=============================================================\n");
  printf("                  WELCOME TO C CAFE BILLING SYSTEM            \n");
  printf("=============================================================\n");

  do {
    float price = 0.0;
    printf("\nEnter the price of item %d: ", i+1);
    scanf("%f", &price);
    
    // Add the price to the total amount
    total_amount += price;

    // Increment the number of items
    num_items++;

    printf("Do you want to add another item (Y/N)? ");
    scanf(" %c", &choice);
    i++;
  } while (choice == 'y' || choice == 'Y');

  printf("\nTotal amount of the items purchased: %.2f\n", total_amount);

  // Determine the discount based on the total amount
  if (total_amount >= 1000) {
    discount = 0.1 * total_amount;
  } else if (total_amount >= 500) {
    discount = 0.05 * total_amount;
  }

  printf("Discount applied: %.2f\n", discount);

  // Calculate the net amount
  net_amount = total_amount - discount;

  printf("Net amount: %.2f\n", net_amount);

  // Calculate the service tax
  service_tax = 0.14 * net_amount;

  printf("Service tax (14%% of net amount): %.2f\n", service_tax);

  // Calculate the VAT
  vat = 0.05 * net_amount;

  printf("VAT (5%% of net amount): %.2f\n", vat);

  // Calculate the grand total
  grand_total = net_amount + service_tax + vat;

  printf("Grand total: %.2f\n", grand_total);

  printf("\nThank you for dining with us. Please come again!\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  float v8; // [rsp+28h] [rbp-28h] BYREF
  char v9; // [rsp+2Fh] [rbp-21h] BYREF
  float v10; // [rsp+30h] [rbp-20h]
  float v11; // [rsp+34h] [rbp-1Ch]
  float v12; // [rsp+38h] [rbp-18h]
  float v13; // [rsp+3Ch] [rbp-14h]
  int v14; // [rsp+40h] [rbp-10h]
  int v15; // [rsp+44h] [rbp-Ch]
  float v16; // [rsp+48h] [rbp-8h]
  float v17; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v17 = 0.0;
  v16 = 0.0;
  v13 = 0.0;
  v12 = 0.0;
  v11 = 0.0;
  v10 = 0.0;
  v15 = 0;
  v14 = 0;
  printf("=============================================================\n");
  printf("                  WELCOME TO C CAFE BILLING SYSTEM            \n");
  printf("=============================================================\n");
  do
  {
    do
    {
      v8 = 0.0;
      printf("\nEnter the price of item %d: ", (unsigned int)(v14 + 1));
      scanf("%f", &v8);
      v17 = v8 + v17;
      ++v15;
      printf("Do you want to add another item (Y/N)? ");
      scanf(" %c", &v9);
      ++v14;
    }
    while ( v9 == 121 );
  }
  while ( v9 == 89 );
  printf("\nTotal amount of the items purchased: %.2f\n", v17);
  if ( v17 < 1000.0 )
  {
    if ( v17 >= 500.0 )
    {
      v4 = 0.05 * v17;
      v16 = v4;
    }
  }
  else
  {
    v3 = 0.1 * v17;
    v16 = v3;
  }
  printf("Discount applied: %.2f\n", v16);
  v13 = v17 - v16;
  printf("Net amount: %.2f\n", (float)(v17 - v16));
  v5 = 0.14 * v13;
  v12 = v5;
  printf("Service tax (14%% of net amount): %.2f\n", v5);
  v6 = 0.05 * v13;
  v11 = v6;
  printf("VAT (5%% of net amount): %.2f\n", v6);
  v10 = (float)(v13 + v12) + v11;
  printf("Grand total: %.2f\n", v10);
  printf("\nThank you for dining with us. Please come again!\n");
  return 0;
}
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type float var_28;

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: introspective
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

int main() {
  printf("Welcome to the C Internet Speed Test Application!\n\n");
  
  // Ask user for input
  char input[20];
  printf("Please enter the size of the test data in MB (e.g. 50): ");
  fgets(input, 20, stdin);
  int testSize = atoi(input);

  // Check for valid input
  if (testSize <= 0) {
    printf("Invalid test size. Please enter a positive integer.\n");
    return 1;
  }

  // Generate test data
  char* testData = (char*) malloc(sizeof(char) * 1024 * 1024 * testSize);
  
  // Start timer
  clock_t start = clock();

  // Perform test
  for (int i = 0; i < 1024 * 1024 * testSize; i++) {
    testData[i] = 'a';
  }

  // Stop timer
  clock_t end = clock();

  // Calculate results
  double totalTime = (double)(end - start) / CLOCKS_PER_SEC;
  double speed = (double) testSize / totalTime;

  // Display results
  printf("\nTest complete!\n");
  printf("Data size: %d MB\n", testSize);
  printf("Time taken: %.2lf seconds\n", totalTime);
  printf("Internet speed: %.2lf megabytes per second\n", speed);

  // Free memory
  free(testData);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// clock_t __cdecl clock();
// int __cdecl atoi(const char *String);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[24]; // [rsp+20h] [rbp-40h] BYREF
  double v6; // [rsp+38h] [rbp-28h]
  double v7; // [rsp+40h] [rbp-20h]
  clock_t v8; // [rsp+48h] [rbp-18h]
  clock_t v9; // [rsp+4Ch] [rbp-14h]
  void *Block; // [rsp+50h] [rbp-10h]
  int v11; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the C Internet Speed Test Application!\n\n");
  printf("Please enter the size of the test data in MB (e.g. 50): ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 20, v3);
  v11 = atoi(Buffer);
  if ( v11 > 0 )
  {
    Block = malloc((__int64)v11 << 20);
    v9 = clock();
    for ( i = 0; i < v11 << 20; ++i )
      *((_BYTE *)Block + i) = 97;
    v8 = clock();
    v7 = (double)(v8 - v9) / 1000.0;
    v6 = (double)v11 / v7;
    printf("\nTest complete!\n");
    printf("Data size: %d MB\n", (unsigned int)v11);
    printf("Time taken: %.2lf seconds\n", v7);
    printf("Internet speed: %.2lf megabytes per second\n", v6);
    free(Block);
    return 0;
  }
  else
  {
    printf("Invalid test size. Please enter a positive integer.\n");
    return 1;
  }
}
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Task Scheduler ; Style: enthusiastic
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef void (*TaskFunction)(void);

typedef struct {
    int interval;
    int remaining_time;
    TaskFunction task;
} Task;

void task1() {
    printf("I'm task 1!\n");
}

void task2() {
    printf("I'm task 2!\n");
}

int main() {
    Task tasks[2] = {
        {3, 3, &task1},
        {5, 5, &task2}
    };
    int num_tasks = sizeof(tasks) / sizeof(tasks[0]);

    while (1) {
        for (int i = 0; i < num_tasks; i++) {
            if (tasks[i].remaining_time == 0) {
                tasks[i].task();
                tasks[i].remaining_time = tasks[i].interval;
            } else {
                tasks[i].remaining_time--;
            }
        }
        usleep(100000); // sleep for 100ms
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall task1(); // weak
__int64 __fastcall task2(); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall usleep(_QWORD); // weak


//----- (00000001400015CD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int *v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  int v8; // [rsp+20h] [rbp-30h]
  int v9; // [rsp+24h] [rbp-2Ch] BYREF
  __int64 (__fastcall *v10)(); // [rsp+28h] [rbp-28h]
  int v11; // [rsp+30h] [rbp-20h]
  int v12; // [rsp+34h] [rbp-1Ch]
  __int64 (__fastcall *v13)(); // [rsp+38h] [rbp-18h]
  int v14; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 3;
  v9 = 3;
  v10 = task1;
  v11 = 5;
  v12 = 5;
  v13 = task2;
  v14 = 2;
  while ( 1 )
  {
    for ( i = 0; i < v14; ++i )
    {
      if ( *(&v9 + 4 * i) )
      {
        v3 = (int *)(unsigned int)(*(&v9 + 4 * i) - 1);
        *(&v9 + 4 * i) = (int)v3;
      }
      else
      {
        ((void (__fastcall *)(__int64, int *, __int64, __int64))*(&v10 + 2 * i))(v4, v3, v5, v6);
        v3 = &v9 + 4 * i;
        *v3 = *(&v8 + 4 * i);
      }
    }
    usleep(100000i64);
  }
}
// 140001645: variable 'v4' is possibly undefined
// 140001645: variable 'v3' is possibly undefined
// 140001645: variable 'v5' is possibly undefined
// 140001645: variable 'v6' is possibly undefined
// 140001591: using guessed type __int64 __fastcall task1();
// 1400015AF: using guessed type __int64 __fastcall task2();
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400027D0: using guessed type __int64 __fastcall usleep(_QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Spell checking ; Style: cheerful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// function to check if a word is correctly spelled
int spell_check(char *word)
{
    // list of correctly spelled words
    char *dictionary[] = {"happy", "cheerful", "excited", "joyful", "friendly", "fun"};

    // loop through the dictionary to check if the word is present
    for (int i = 0; i < 6; i++) {
        if (strcmp(word, dictionary[i]) == 0) {
            return 1; // word is correctly spelled
        }
    }

    return 0; // word is misspelled
}

// function to convert all letters to lowercase
void lowercase(char *string)
{
    for (int i = 0; i < strlen(string); i++) {
        string[i] = tolower(string[i]);
    }
}

int main()
{
    char input[100];

    printf("Hello! I am the cheerful spell checker!\n\n");

    while (1) {
        // get user input
        printf("Please enter a word to check (enter 'quit' to exit): ");
        fgets(input, sizeof(input), stdin);

        // remove newline character from input
        input[strcspn(input, "\n")] = 0;

        // convert input to lowercase
        lowercase(input);

        // check if user wants to quit
        if (strcmp(input, "quit") == 0) {
            printf("\nGoodbye! Have a great day!\n");
            break;
        }

        // check if word is correctly spelled
        if (spell_check(input)) {
            printf("\n%s is spelled correctly!\n\n", input);
        } else {
            printf("\nOops! It looks like %s is misspelled. Please try again.\n\n", input);
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall spell_check(_QWORD); // weak
__int64 __fastcall lowercase(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001686) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[112]; // [rsp+20h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Hello! I am the cheerful spell checker!\n\n");
  while ( 1 )
  {
    printf("Please enter a word to check (enter 'quit' to exit): ");
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 100, v3);
    Buffer[strcspn(Buffer, "\n")] = 0;
    lowercase(Buffer);
    if ( !strcmp(Buffer, "quit") )
      break;
    if ( (unsigned int)spell_check(Buffer) )
      printf("\n%s is spelled correctly!\n\n", Buffer);
    else
      printf("\nOops! It looks like %s is misspelled. Please try again.\n\n", Buffer);
  }
  printf("\nGoodbye! Have a great day!\n");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall spell_check(_QWORD);
// 14000161E: using guessed type __int64 __fastcall lowercase(_QWORD);
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001686: using guessed type char Buffer[112];

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: introspective
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int min(int a, int b, int c)
{
    if (a < b && a < c)
        return a;
    else if (b < c)
        return b;
    else
        return c;
}

int levenshtein_distance(char *s1, char *s2)
{
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    int **dp = (int **)malloc(sizeof(int *) * (len1 + 1));
    for (int i = 0; i <= len1; i++)
    {
        dp[i] = (int *)malloc(sizeof(int) * (len2 + 1));
    }

    for (int i = 0; i <= len1; i++)
        dp[i][0] = i;

    for (int j = 0; j <= len2; j++)
        dp[0][j] = j;

    for (int i = 1; i <= len1; i++)
    {
        for (int j = 1; j <= len2; j++)
        {
            int cost = s1[i - 1] == s2[j - 1] ? 0 : 1;
            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
        }
    }

    int result = dp[len1][len2];

    for (int i = 0; i <= len1; i++)
    {
        free(dp[i]);
    }

    free(dp);

    return result;
}

int main()
{
    char s1[100], s2[100];

    printf("Enter string 1: ");
    fgets(s1, 100, stdin);
    s1[strlen(s1) - 1] = '\0';

    printf("Enter string 2: ");
    fgets(s2, 100, stdin);
    s2[strlen(s2) - 1] = '\0';

    int result = levenshtein_distance(s1, s2);

    printf("Levenshtein distance between '%s' and '%s' is %d", s1, s2, result);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall levenshtein_distance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000183A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char Str[112]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[108]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v8; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  printf("Enter string 1: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strlen(Buffer) - 1] = 0;
  printf("Enter string 2: ");
  v4 = __acrt_iob_func(0);
  fgets(Str, 100, v4);
  Str[strlen(Str) - 1] = 0;
  v8 = levenshtein_distance(Buffer, Str);
  printf("Levenshtein distance between '%s' and '%s' is %d", Buffer, Str, v8);
  return 0;
}
// 1400015C6: using guessed type __int64 __fastcall levenshtein_distance(_QWORD, _QWORD);
// 1400019E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000183A: using guessed type char Buffer[108];
// 14000183A: using guessed type char Str[112];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Spell checking ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50
#define MAX_DICT_WORDS 10000
#define MAX_TEXT_WORDS 1000

// Struct to hold each word in the dictionary
typedef struct {
    char word[MAX_WORD_LENGTH];
} word;

// Function to check if a given word is in the dictionary
bool check_spelling(word* dict, int dict_size, char* word_to_check) {
    // Convert the word to lowercase
    char lowercase_word[MAX_WORD_LENGTH];
    strcpy(lowercase_word, word_to_check);
    for (int i = 0; lowercase_word[i]; i++) {
        lowercase_word[i] = tolower(lowercase_word[i]);
    }
    // Use binary search to find the word in the dictionary
    int left = 0, right = dict_size - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        int cmp = strcmp(lowercase_word, dict[mid].word);
        if (cmp == 0) {
            return true;
        } else if (cmp < 0) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return false;
}

int main() {
    // Load the dictionary into an array
    word* dict = malloc(MAX_DICT_WORDS * sizeof(word));
    if (dict == NULL) {
        printf("Error: malloc failed to allocate memory\n");
        return 1;
    }
    FILE* dict_file = fopen("dictionary.txt", "r");
    if (dict_file == NULL) {
        printf("Error: could not open dictionary file\n");
        free(dict);
        return 1;
    }
    int dict_size = 0;
    char buffer[MAX_WORD_LENGTH];
    while (fgets(buffer, MAX_WORD_LENGTH, dict_file) != NULL && dict_size < MAX_DICT_WORDS) {
        // Remove newline character from the end of the buffer
        buffer[strcspn(buffer, "\n")] = 0;
        strcpy(dict[dict_size].word, buffer);
        dict_size++;
    }
    fclose(dict_file);
    printf("Dictionary loaded successfully with %d words.\n", dict_size);

    // Get text to check spelling on
    char** text = malloc(MAX_TEXT_WORDS * sizeof(char*));
    if (text == NULL) {
        printf("Error: malloc failed to allocate memory\n");
        free(dict);
        return 1;
    }
    printf("Enter text to check spelling on (maximum of %d words):\n", MAX_TEXT_WORDS);
    int text_size = 0;
    while (text_size < MAX_TEXT_WORDS) {
        // Allocate memory for the next word
        char* new_word = malloc(MAX_WORD_LENGTH * sizeof(char));
        if (new_word == NULL) {
            printf("Error: malloc failed to allocate memory\n");
            for (int i = 0; i < text_size; i++) {
                free(text[i]);
            }
            free(text);
            free(dict);
            return 1;
        }
        // Read the next word
        scanf("%s", new_word);
        // Check if the word is in the dictionary
        if (!check_spelling(dict, dict_size, new_word)) {
            printf("Misspelled word: %s\n", new_word);
        }
        // Add the word to the text array
        text[text_size] = new_word;
        text_size++;
    }

    // Free memory and exit
    for (int i = 0; i < text_size; i++) {
        free(text[i]);
    }
    free(text);
    free(dict);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall check_spelling(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl strcpy(char *Destination, const char *Source);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400016DD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[64]; // [rsp+20h] [rbp-70h] BYREF
  const char *v5; // [rsp+60h] [rbp-30h]
  void *v6; // [rsp+68h] [rbp-28h]
  FILE *Stream; // [rsp+70h] [rbp-20h]
  void *Block; // [rsp+78h] [rbp-18h]
  int k; // [rsp+80h] [rbp-10h]
  int m; // [rsp+84h] [rbp-Ch]
  int j; // [rsp+88h] [rbp-8h]
  unsigned int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  Block = malloc(0x7A120ui64);
  if ( Block )
  {
    Stream = fopen("dictionary.txt", "r");
    if ( Stream )
    {
      for ( i = 0; fgets(Str, 50, Stream) && (int)i <= 9999; ++i )
      {
        Str[strcspn(Str, "\n")] = 0;
        strcpy((char *)Block + 50 * (int)i, Str);
      }
      fclose(Stream);
      printf("Dictionary loaded successfully with %d words.\n", i);
      v6 = malloc(0x1F40ui64);
      if ( v6 )
      {
        printf("Enter text to check spelling on (maximum of %d words):\n", 1000i64);
        for ( j = 0; ; ++j )
        {
          if ( j > 999 )
          {
            for ( k = 0; k < j; ++k )
              free(*((void **)v6 + k));
            free(v6);
            free(Block);
            return 0;
          }
          v5 = (const char *)malloc(0x32ui64);
          if ( !v5 )
            break;
          scanf("%s", v5);
          if ( (unsigned __int8)check_spelling(Block, i, v5) != 1 )
            printf("Misspelled word: %s\n", v5);
          *((_QWORD *)v6 + j) = v5;
        }
        printf("Error: malloc failed to allocate memory\n");
        for ( m = 0; m < j; ++m )
          free(*((void **)v6 + m));
        free(v6);
        free(Block);
        return 1;
      }
      else
      {
        printf("Error: malloc failed to allocate memory\n");
        free(Block);
        return 1;
      }
    }
    else
    {
      printf("Error: could not open dictionary file\n");
      free(Block);
      return 1;
    }
  }
  else
  {
    printf("Error: malloc failed to allocate memory\n");
    return 1;
  }
}
// 1400015E2: using guessed type __int64 __fastcall check_spelling(_QWORD, _QWORD, _QWORD);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016DD: using guessed type char Str[64];

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pac-Man Game Clone ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>

// Game board dimensions
#define ROWS 22
#define COLS 19

// Maze layout
char maze[ROWS][COLS] = {
    "+-----------------+",
    "|-----|-------|---|",
    "|-|-|-| |-|-| | |-|",
    "| |-|-| |-|-| | |-|",
    "|-|---| | | | | |-|",
    "| | |-| | | |-| | |",
    "| | |-| | | |-| | |",
    "|-|---| | | | | |-|",
    "|-|-|-| | |-| |-|-|",
    "|-|-|-| | |-| |-|-|",
    "| | | | | |   | | |",
    "|-|-|-| | |-| |-|-|",
    "|-|-|-| | |-| |-|-|",
    "|-|---| | | | | |-|",
    "| | |-| | | |-| | |",
    "| | |-| | | |-| | |",
    "|-|---| | | | | |-|",
    "|-|-|-| |-|-| | |-|",
    "|-|-|-| |-|-| | |-|",
    "+-----------------+"
};

// Pac-man starts here
int pacman_row = 11;
int pacman_col = 9;

// Ghosts
int ghost1_row = 9;
int ghost1_col = 9;
int ghost2_row = 9;
int ghost2_col = 10;
int ghost3_row = 9;
int ghost3_col = 11;
int ghost4_row = 9;
int ghost4_col = 12;

// Scoring
int score = 0;

// Game modes
enum GameMode { PLAYING, GAME_OVER };
enum GameMode game_mode = PLAYING;

// Consume a pellet and increase the score
void eat_pellet(int row, int col) {
    maze[row][col] = ' ';
    score += 10;
}

// Move pac-man
void move_pacman(int row, int col) {
    if (maze[row][col] == '.') {
        eat_pellet(row, col);
    }
    pacman_row = row;
    pacman_col = col;
}

// Move a ghost
void move_ghost(int* row_ptr, int* col_ptr) {
    int row = *row_ptr;
    int col = *col_ptr;
    int options[4] = { 0 };
    int direction_count = 0;
    if (maze[row - 1][col] != '-') {
        options[direction_count] = 1; // Up
        direction_count++;
    }
    if (maze[row][col - 1] != '|') {
        options[direction_count] = 2; // Left
        direction_count++;
    }
    if (maze[row + 1][col] != '-') {
        options[direction_count] = 3; // Down
        direction_count++;
    }
    if (maze[row][col + 1] != '|') {
        options[direction_count] = 4; // Right
        direction_count++;
    }
    int direction = options[rand() % direction_count];
    switch (direction) {
        case 1:
            row--;
            break;
        case 2:
            col--;
            break;
        case 3:
            row++;
            break;
        case 4:
            col++;
            break;
    }
    *row_ptr = row;
    *col_ptr = col;
}

// Check for collisions between pac-man and a ghost
bool check_collision(int pacman_row, int pacman_col, int ghost_row, int ghost_col) {
    return (pacman_row == ghost_row && pacman_col == ghost_col);
}

// Display the game board
void display_board() {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (i == pacman_row && j == pacman_col) {
                printf("%c", 'C'); // Pac-man
            } else if (i == ghost1_row && j == ghost1_col) {
                printf("%c", 'G'); // Ghost 1
            } else if (i == ghost2_row && j == ghost2_col) {
                printf("%c", 'G'); // Ghost 2
            } else if (i == ghost3_row && j == ghost3_col) {
                printf("%c", 'G'); // Ghost 3
            } else if (i == ghost4_row && j == ghost4_col) {
                printf("%c", 'G'); // Ghost 4
            } else {
                printf("%c", maze[i][j]);
            }
        }
        printf("\n");
    }
    printf("Score: %d\n", score);
}

int main() {
    srand(time(NULL)); // Seed the random number generator
    while (game_mode == PLAYING) {
        // Move pac-man
        char input;
        printf("Enter direction (up/down/left/right): ");
        scanf(" %c", &input);
        int target_row = pacman_row;
        int target_col = pacman_col;
        switch (input) {
            case 'up':
                target_row--;
                break;
            case 'down':
                target_row++;
                break;
            case 'left':
                target_col--;
                break;
            case 'right':
                target_col++;
                break;
        }
        if (maze[target_row][target_col] != '|' && maze[target_row][target_col] != '-') {
            move_pacman(target_row, target_col);
        }

        // Move ghosts
        move_ghost(&ghost1_row, &ghost1_col);
        move_ghost(&ghost2_row, &ghost2_col);
        move_ghost(&ghost3_row, &ghost3_col);
        move_ghost(&ghost4_row, &ghost4_col);

        // Check for collisions
        if (check_collision(pacman_row, pacman_col, ghost1_row, ghost1_col) ||
            check_collision(pacman_row, pacman_col, ghost2_row, ghost2_col) ||
            check_collision(pacman_row, pacman_col, ghost3_row, ghost3_col) ||
            check_collision(pacman_row, pacman_col, ghost4_row, ghost4_col)) {
            game_mode = GAME_OVER;
        }

        // Check for victory
        bool has_pellets = false;
        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                if (maze[i][j] == '.') {
                    has_pellets = true;
                    break;
                }
            }
            if (has_pellets) {
                break;
            }
        }
        if (!has_pellets) {
            printf("Congratulations! You have won the game!\n");
            game_mode = GAME_OVER;
        }

        // Display the game board
        printf("\n");
        display_board();
    }

    // Game over
    printf("\nGame over. Final score: %d\n", score);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall move_pacman(_QWORD, _QWORD); // weak
__int64 __fastcall move_ghost(_QWORD, _QWORD); // weak
__int64 __fastcall check_collision(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 display_board(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

char maze[381] = "+-----------------+|-----|-------|---||-|-|-| |-|-| | |-|| |-|-| |-|-| | |-||-|---| | | | | |-|| | |-| | | |-| | || | |-| | | |-| | ||-|---| | | | | |-||-|-|-| | |-| |-|-||-|-|-| | |-| |-|-|| | | | | |   | | ||-|-|-| | |-| |-|-||-|-|-| | |-| |-|-||-|---| | | | | |-|| | |-| | | |-| | || | |-| | | |-| | ||-|---| | | | | |-||-|-|-| |-|-| | |-||-|-|-| |-|-| | |-|+-----------------+"; // weak
int pacman_row = 11; // weak
int pacman_col = 9; // weak
int ghost1_row = 9; // weak
int ghost1_col = 9; // weak
int ghost2_row = 9; // weak
int ghost2_col = 10; // weak
int ghost3_row = 9; // weak
int ghost3_col = 11; // weak
int ghost4_row = 9; // weak
int ghost4_col = 12; // weak
int score; // weak
int game_mode; // weak


//----- (0000000140001A28) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5; // [rsp+2Bh] [rbp-15h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-14h]
  unsigned int v7; // [rsp+30h] [rbp-10h]
  int j; // [rsp+34h] [rbp-Ch]
  int i; // [rsp+38h] [rbp-8h]
  char v10; // [rsp+3Fh] [rbp-1h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  while ( !game_mode )
  {
    printf("Enter direction (up/down/left/right): ");
    scanf(" %c", &v5);
    v7 = pacman_row;
    v6 = pacman_col;
    if ( maze[19 * pacman_row + pacman_col] != 124 && maze[19 * v7 + v6] != 45 )
      move_pacman(v7, v6);
    move_ghost(&ghost1_row, &ghost1_col);
    move_ghost(&ghost2_row, &ghost2_col);
    move_ghost(&ghost3_row, &ghost3_col);
    move_ghost(&ghost4_row, &ghost4_col);
    if ( (unsigned __int8)check_collision(
                            (unsigned int)pacman_row,
                            (unsigned int)pacman_col,
                            (unsigned int)ghost1_row,
                            (unsigned int)ghost1_col)
      || (unsigned __int8)check_collision(
                            (unsigned int)pacman_row,
                            (unsigned int)pacman_col,
                            (unsigned int)ghost2_row,
                            (unsigned int)ghost2_col)
      || (unsigned __int8)check_collision(
                            (unsigned int)pacman_row,
                            (unsigned int)pacman_col,
                            (unsigned int)ghost3_row,
                            (unsigned int)ghost3_col)
      || (unsigned __int8)check_collision(
                            (unsigned int)pacman_row,
                            (unsigned int)pacman_col,
                            (unsigned int)ghost4_row,
                            (unsigned int)ghost4_col) )
    {
      game_mode = 1;
    }
    v10 = 0;
    for ( i = 0; i <= 21; ++i )
    {
      for ( j = 0; j <= 18; ++j )
      {
        if ( maze[19 * i + j] == 46 )
        {
          v10 = 1;
          break;
        }
      }
      if ( v10 )
        break;
    }
    if ( v10 != 1 )
    {
      printf("Congratulations! You have won the game!\n");
      game_mode = 1;
    }
    printf("\n");
    display_board();
  }
  printf("\nGame over. Final score: %d\n", (unsigned int)score);
  return 0;
}
// 14000164A: using guessed type __int64 __fastcall move_pacman(_QWORD, _QWORD);
// 1400016AF: using guessed type __int64 __fastcall move_ghost(_QWORD, _QWORD);
// 140001866: using guessed type __int64 __fastcall check_collision(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001899: using guessed type __int64 display_board(void);
// 140001D90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400141C4: using guessed type int pacman_row;
// 1400141C8: using guessed type int pacman_col;
// 1400141CC: using guessed type int ghost1_row;
// 1400141D0: using guessed type int ghost1_col;
// 1400141D4: using guessed type int ghost2_row;
// 1400141D8: using guessed type int ghost2_col;
// 1400141DC: using guessed type int ghost3_row;
// 1400141E0: using guessed type int ghost3_col;
// 1400141E4: using guessed type int ghost4_row;
// 1400141E8: using guessed type int ghost4_col;
// 140019040: using guessed type int score;
// 140019044: using guessed type int game_mode;

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Steganography ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// function to convert decimal to binary
int *decToBinary(int num, int array[]){
    for(int i=0; i<8; i++){
        array[i] = num % 2;
        num = num / 2;
    }
    return array;
}

// function to convert binary to decimal
int binaryToDec(int array[]){
    int num = 0, pow = 1;
    for(int i=0; i<8; i++){
        num = num + array[i] * pow;
        pow = pow * 2;
    }
    return num;
}

// function to hide message in image
void hideMessage(char message[], char imageName[]){
    FILE *fp1, *fp2;
    int count = 0, byte, pos = 0, binaryMessage[8], binaryByte[8], length;
    fp1 = fopen(imageName, "rb");
    fp2 = fopen("output.bmp", "wb");
    int headerSize;
    fread(&headerSize, 4, 1, fp1);
    fwrite(&headerSize, 4, 1, fp2);
    fseek(fp1, 4, SEEK_CUR);
    fread(&length, 4, 1, fp1);
    fwrite(&length, 4, 1, fp2);
    fseek(fp1, 12, SEEK_CUR);
    while(1){
        byte = fgetc(fp1);
        if(byte == EOF)
            break;
        decToBinary(byte, binaryByte);
        if(count < strlen(message)){
            decToBinary(message[count], binaryMessage);
            binaryByte[7] = binaryMessage[pos++];
            if(pos == 8){
                pos = 0;
                count++;
            }
        }
        byte = binaryToDec(binaryByte);
        fputc(byte, fp2);
    }
    fclose(fp1);
    fclose(fp2);
    printf("Message hidden successfully in %s image!", imageName);
}

// function to reveal message from image
void revealMessage(char imageName[]){
    FILE *fp;
    int byte, binaryByte[8], count = 0, pos = 0, length;
    char message[100];
    fp = fopen(imageName, "rb");
    int headerSize;
    fread(&headerSize, 4, 1, fp);
    fseek(fp, 4, SEEK_CUR);
    fread(&length, 4, 1, fp);
    fseek(fp, 12, SEEK_CUR);
    while(1){
        byte = fgetc(fp);
        if(byte == EOF)
            break;
        decToBinary(byte, binaryByte);
        if(count < length){
            message[count] = binaryByte[7] + '0';
            pos++;
            if(pos == 8){
                pos = 0;
                count++;
            }
        }
    }
    printf("Message revealed from %s image: %.*s", imageName, length, message);
}

int main(){
    char message[100], imageName[20];
    int choice;
    printf("Enter message to hide (max 100 characters): ");
    fgets(message, 100, stdin);
    message[strcspn(message, "\n")] = 0;
    printf("Enter name of image file to hide message in (max 20 characters): ");
    fgets(imageName, 20, stdin);
    imageName[strcspn(imageName, "\n")] = 0;
    printf("Do you want to hide message or reveal message?\n");
    printf("1. Hide message\n");
    printf("2. Reveal message\n");
    scanf("%d", &choice);
    switch(choice){
        case 1:
            hideMessage(message, imageName);
            break;
        case 2:
            revealMessage(imageName);
            break;
        default:
            printf("Invalid choice!");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall hideMessage(_QWORD, _QWORD); // weak
__int64 __fastcall revealMessage(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001999) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  int v6; // [rsp+2Ch] [rbp-94h] BYREF
  char Str[32]; // [rsp+30h] [rbp-90h] BYREF
  char Buffer[112]; // [rsp+50h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf("Enter message to hide (max 100 characters): ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  printf("Enter name of image file to hide message in (max 20 characters): ");
  v4 = __acrt_iob_func(0);
  fgets(Str, 20, v4);
  Str[strcspn(Str, "\n")] = 0;
  printf("Do you want to hide message or reveal message?\n");
  printf("1. Hide message\n");
  printf("2. Reveal message\n");
  scanf("%d", &v6);
  if ( v6 == 1 )
  {
    hideMessage(Buffer, Str);
  }
  else if ( v6 == 2 )
  {
    revealMessage(Str);
  }
  else
  {
    printf("Invalid choice!");
  }
  return 0;
}
// 14000169B: using guessed type __int64 __fastcall hideMessage(_QWORD, _QWORD);
// 140001874: using guessed type __int64 __fastcall revealMessage(_QWORD);
// 140001BA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001999: using guessed type char Buffer[112];
// 140001999: using guessed type char Str[32];

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Compression algorithms ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define CHUNK_SIZE 1024

int compress(char* original, char* compressed);

int main()
{
    char* original = "Hello, world!";
    char* compressed = (char*)malloc(strlen(original) * sizeof(char));
    int size = compress(original, compressed);

    printf("Original size: %lu\n", strlen(original));
    printf("Compressed size: %d\n", size);

    return 0;
}

int compress(char* original, char* compressed)
{
    int original_size = strlen(original);
    int chunk_size, num_chunks;

    if(original_size < CHUNK_SIZE) {
        chunk_size = original_size;
        num_chunks = 1;
    } else {
        // Divide original into chunks of CHUNK_SIZE
        chunk_size = CHUNK_SIZE;
        num_chunks = ceil(original_size / (float)CHUNK_SIZE);
    }

    int* chunk_sizes = (int*)calloc(num_chunks, sizeof(int));
    char** chunks = (char**)malloc(num_chunks * sizeof(char*));

    // Divide original into chunks
    int i, j, k;
    for(i = 0, k = 0; i < num_chunks; i++, k += chunk_size) {
        if(i == num_chunks - 1) {
            chunk_size = original_size - k;
        }
        chunks[i] = (char*)malloc(chunk_size * sizeof(char));
        memcpy(chunks[i], &original[k], chunk_size * sizeof(char));
        chunk_sizes[i] = chunk_size;
    }

    // Compress each chunk with RLE
    int compressed_size = 0;
    for(i = 0; i < num_chunks; i++) {
        char* chunk = chunks[i];
        int size = chunk_sizes[i];
        char curr_char = chunk[0];
        int count = 1;

        for(j = 1; j < size; j++) {
            if(chunk[j] == curr_char) {
                count++;
            } else {
                // Write compressed data to compressed array
                compressed[compressed_size++] = curr_char;
                compressed[compressed_size++] = count;
                curr_char = chunk[j];
                count = 1;
            }
        }

        // Write final compressed data to compressed array
        compressed[compressed_size++] = curr_char;
        compressed[compressed_size++] = count;
    }

    // Free dynamically allocated memory
    for(i = 0; i < num_chunks; i++) {
        free(chunks[i]);
    }
    free(chunks);
    free(chunk_sizes);

    return compressed_size;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall compress(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void *__cdecl malloc(size_t Size);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  size_t v3; // rax
  void *v4; // rdx
  size_t v5; // rax
  unsigned int v7; // [rsp+2Ch] [rbp-14h]

  _main(argc, argv, envp);
  v3 = strlen("Hello, world!");
  v4 = malloc(v3);
  v7 = compress("Hello, world!", v4);
  v5 = strlen("Hello, world!");
  printf("Original size: %lu\n", v5);
  printf("Compressed size: %d\n", v7);
  return 0;
}
// 140001611: using guessed type __int64 __fastcall compress(_QWORD, _QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Table Game ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
 
int main()
{
    int num, guess, tries = 0;
    srand(time(0)); // generates random seed for each run
 
    num = rand() % 100 + 1; // generates a random number between 1 and 100
 
    printf("Welcome to the Number Guessing Game!\n");
    printf("I'm thinking of a number between 1 and 100.\n");
    printf("You have to guess what it is in 10 tries or less.\n\n");
 
    do
    {
        printf("Guess a number: ");
        scanf("%d", &guess);
        tries++;
 
        if (guess > num)
        {
            printf("Too high! Try again.\n\n");
        }
        else if (guess < num)
        {
            printf("Too low! Try again.\n\n");
        }
        else
        {
            printf("Congratulations! You guessed the number in %d tries.\n", tries);
        }
 
    } while (guess != num && tries < 10);
 
    if (tries == 10)
    {
        printf("Sorry! You have used up all your tries. The number was %d.\n", num);
    }
 
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  int v6; // [rsp+28h] [rbp-8h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 0;
  v3 = time(0i64);
  srand(v3);
  v6 = rand() % 100 + 1;
  printf("Welcome to the Number Guessing Game!\n");
  printf("I'm thinking of a number between 1 and 100.\n");
  printf("You have to guess what it is in 10 tries or less.\n\n");
  do
  {
    printf("Guess a number: ");
    scanf("%d", &v5);
    ++v7;
    if ( v6 >= v5 )
    {
      if ( v6 <= v5 )
        printf("Congratulations! You guessed the number in %d tries.\n", v7);
      else
        printf("Too low! Try again.\n\n");
    }
    else
    {
      printf("Too high! Try again.\n\n");
    }
  }
  while ( v6 != v5 && (int)v7 <= 9 );
  if ( v7 == 10 )
    printf("Sorry! You have used up all your tries. The number was %d.\n", (unsigned int)v6);
  return 0;
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bucket Sort Implementation ; Style: secure
#include <stdio.h>
#include <stdlib.h>

#define ARRAY_SIZE 10
#define BUCKET_SIZE 5

void bucketSort(int *arr, int n) {
    int i, j;
    int min_val = arr[0], max_val = arr[0];

    for (i = 1; i < n; i++) {
        if (arr[i] < min_val) {
            min_val = arr[i];
        } else if (arr[i] > max_val) {
            max_val = arr[i];
        }
    }

    int num_buckets = ((max_val - min_val) / BUCKET_SIZE) + 1;

    int **buckets = (int **) malloc(num_buckets * sizeof(int *));
    for (i = 0; i < num_buckets; i++) {
        buckets[i] = (int *) malloc(BUCKET_SIZE * sizeof(int));
    }

    for (i = 0; i < num_buckets; i++) {
        for (j = 0; j < BUCKET_SIZE; j++) {
            buckets[i][j] = -1;
        }
    }

    int bucket_index;
    for (i = 0; i < n; i++) {
        bucket_index = (arr[i] - min_val) / BUCKET_SIZE;
        j = 0;
        while (buckets[bucket_index][j] != -1) {
            j++;
        }
        buckets[bucket_index][j] = arr[i];
    }

    for (i = 0; i < num_buckets; i++) {
        insertionSort(buckets[i], BUCKET_SIZE);
    }

    int index = 0;
    for (i = 0; i < num_buckets; i++) {
        for (j = 0; j < BUCKET_SIZE; j++) {
            if (buckets[i][j] != -1) {
                arr[index++] = buckets[i][j];
            }
        }
    }

    for (i = 0; i < num_buckets; i++) {
        free(buckets[i]);
    }
    free(buckets);
}

void insertionSort(int arr[], int n) {
    int i, j, key;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

int main() {
    int i;
    int arr[ARRAY_SIZE] = {6, 3, 8, 4, 2, 9, 1, 7, 5, 0};

    printf("Original Array: ");
    for (i = 0; i < ARRAY_SIZE; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    bucketSort(arr, ARRAY_SIZE);

    printf("Sorted Array: ");
    for (i = 0; i < ARRAY_SIZE; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall bucketSort(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400019A8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[11]; // [rsp+20h] [rbp-30h] BYREF
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 6;
  v4[1] = 3;
  v4[2] = 8;
  v4[3] = 4;
  v4[4] = 2;
  v4[5] = 9;
  v4[6] = 1;
  v4[7] = 7;
  v4[8] = 5;
  v4[9] = 0;
  printf("Original Array: ");
  for ( i = 0; i <= 9; ++i )
    printf("%d ", (unsigned int)v4[i]);
  printf("\n");
  bucketSort(v4, 10i64);
  printf("Sorted Array: ");
  for ( i = 0; i <= 9; ++i )
    printf("%d ", (unsigned int)v4[i]);
  printf("\n");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall bucketSort(_QWORD, _QWORD);
// 140001B60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Haunted House Simulator ; Style: light-weight
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>

int roomCount = 5; // Number of rooms in the house
int currentRoom = 0; // We start in room 0
int maxSteps = 10; // Maximum number of steps we can take
int currentSteps = 0; // Number of steps we have taken
bool endGame = false; // Have we reached the end of the game?

// Array of room descriptions
const char* roomDescriptions[] = {
    "You are in the foyer. There is a door to the north.",
    "You are in the living room. There is a door to the north and a door to the east.",
    "You are in the dining room. There is a door to the west and a door to the south.",
    "You are in the kitchen. There is a door to the east.",
    "You are in the bedroom. There is a door to the south."
};

// Array of room spooky descriptions
const char* roomSpookyDescriptions[] = {
    "You feel a chill run down your spine as you step into the foyer.",
    "You hear a faint whisper coming from the living room.",
    "You smell a faint scent of decaying flesh coming from the dining room.",
    "You hear a loud creaking noise coming from the kitchen.",
    "You see a shadowy figure in the bedroom."
};

// Function to randomly generate spooky descriptions
const char* getSpookyDescription() {
    int index = rand() % roomCount;
    return roomSpookyDescriptions[index];
}

// Function to handle the player moving to a new room
void moveToRoom(int roomIndex) {
    currentRoom = roomIndex;
    currentSteps++;
    
    printf("You walk into the room.\n\n");
    printf("%s\n\n", roomDescriptions[currentRoom]);
    
    // Occasionally print a spooky description
    int chance = rand() % 10; 
    if(chance == 0) {
        printf("%s\n\n", getSpookyDescription());
    }
    
    // If we have reached the last room, end the game
    if(currentRoom == roomCount - 1) {
        printf("You have reached the end of the haunted house!\n");
        endGame = true;
        return;
    }
    
    // If we have taken too many steps, end the game
    if(currentSteps >= maxSteps) {
        printf("You've run out of steps and have become lost in the haunted house...\n");
        endGame = true;
        return;
    }
}

int main() {
    // Seed random number generator
    srand(time(NULL));
    
    printf("Welcome to the Haunted House Simulator!\n");
    printf("You have 10 steps to navigate through the haunted house and reach the end.\n\n");
    
    // Start in the first room
    printf("%s\n\n", roomDescriptions[currentRoom]);
    
    // Main game loop
    while(!endGame) {
        // Ask the player which direction they want to go
        printf("Which direction do you want to go? (north/south/east/west)\n");
        char input[10];
        scanf("%s", input);
        
        int nextRoom = -1;
        
        // Figure out which room the player wants to enter
        if(strcmp(input, "north") == 0) {
            nextRoom = currentRoom + 1;
        }
        else if(strcmp(input, "south") == 0) {
            nextRoom = currentRoom - 1;
        }
        else if(strcmp(input, "east") == 0) {
            nextRoom = currentRoom + 2;
        }
        else if(strcmp(input, "west") == 0) {
            nextRoom = currentRoom - 2;
        }
        else {
            printf("Invalid direction!\n\n");
        }
        
        // If the next room is valid, move to it
        if(nextRoom >= 0 && nextRoom < roomCount) {
            moveToRoom(nextRoom);
        }
    }
    
    printf("Thanks for playing!\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall moveToRoom(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

int roomCount = 5; // weak
char *roomDescriptions[5] =
{
  "You are in the foyer. There is a door to the north.",
  "You are in the living room. There is a door to the north and a door to the east.",
  "You are in the dining room. There is a door to the west and a door to the south.",
  "You are in the kitchen. There is a door to the east.",
  "You are in the bedroom. There is a door to the south."
}; // weak
int currentRoom; // weak
char endGame; // weak


//----- (000000014000173F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char Str1[10]; // [rsp+22h] [rbp-Eh] BYREF
  int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Haunted House Simulator!\n");
  printf("You have 10 steps to navigate through the haunted house and reach the end.\n\n");
  printf("%s\n\n", roomDescriptions[currentRoom]);
  while ( endGame != 1 )
  {
    printf("Which direction do you want to go? (north/south/east/west)\n");
    scanf("%s", Str1);
    v6 = -1;
    if ( !strcmp(Str1, "north") )
    {
      v6 = currentRoom + 1;
    }
    else if ( !strcmp(Str1, "south") )
    {
      v6 = currentRoom - 1;
    }
    else if ( !strcmp(Str1, "east") )
    {
      v6 = currentRoom + 2;
    }
    else if ( !strcmp(Str1, "west") )
    {
      v6 = currentRoom - 2;
    }
    else
    {
      printf("Invalid direction!\n\n");
    }
    if ( v6 >= 0 && v6 < roomCount )
      moveToRoom((unsigned int)v6);
  }
  printf("Thanks for playing!\n");
  return 0;
}
// 140001638: using guessed type __int64 __fastcall moveToRoom(_QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140014020: using guessed type int roomCount;
// 140014040: using guessed type char *roomDescriptions[5];
// 140019040: using guessed type int currentRoom;
// 140019048: using guessed type char endGame;

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedurally Generated Maze ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 20
#define COLS 20

void generateMaze(int maze[][COLS], int startX, int startY);
void displayMaze(int maze[][COLS]);

int main(void)
{
    int maze[ROWS][COLS];
    int startX = 1;
    int startY = 1;
    
    srand(time(NULL)); // Use current time as seed for random generator
    
    generateMaze(maze, startX, startY);
    displayMaze(maze);
    
    return 0;
}

// Generate a maze using a random Prim's algorithm
void generateMaze(int maze[][COLS], int startX, int startY)
{
    // Initialize maze
    for (int i = 0; i < ROWS; i++)
    {
        for (int j = 0; j < COLS; j++)
        {
            maze[i][j] = 1; // 1 represents a wall
        }
    }
    
    maze[startX][startY] = 0; // Set starting point as path
    
    // Perform Prim's algorithm to create maze
    int frontier[ROWS*COLS][2];
    int numFrontier = 0;
    
    // Add surrounding cells of starting point to frontier
    if (startX+1 < ROWS && maze[startX+1][startY] == 1) // Down
    {
        frontier[numFrontier][0] = startX+1;
        frontier[numFrontier][1] = startY;
        numFrontier++;
    }
    if (startX-1 >= 0 && maze[startX-1][startY] == 1) // Up
    {
        frontier[numFrontier][0] = startX-1;
        frontier[numFrontier][1] = startY;
        numFrontier++;
    }
    if (startY+1 < COLS && maze[startX][startY+1] == 1) // Right
    {
        frontier[numFrontier][0] = startX;
        frontier[numFrontier][1] = startY+1;
        numFrontier++;
    }
    if (startY-1 >= 0 && maze[startX][startY-1] == 1) // Left
    {
        frontier[numFrontier][0] = startX;
        frontier[numFrontier][1] = startY-1;
        numFrontier++;
    }
    
    while (numFrontier > 0)
    {
        // Choose a random frontier cell
        int randIndex = rand() % numFrontier;
        int x = frontier[randIndex][0];
        int y = frontier[randIndex][1];
        
        // Get neighboring walls
        int walls[4][2] = {{x+1, y}, {x-1, y}, {x, y+1}, {x, y-1}};
        int numWalls = 0;
        
        for (int i = 0; i < 4; i++)
        {
            int wallX = walls[i][0];
            int wallY = walls[i][1];
            
            if (wallX >= 0 && wallX < ROWS && wallY >= 0 && wallY < COLS && maze[wallX][wallY] == 1)
            {
                walls[numWalls][0] = wallX;
                walls[numWalls][1] = wallY;
                numWalls++;
            }
        }
        
        // Choose a random wall and break it
        if (numWalls > 0)
        {
            int randIndex = rand() % numWalls;
            int wallX = walls[randIndex][0];
            int wallY = walls[randIndex][1];
            
            maze[wallX][wallY] = 0; // Set wall as path
            
            // Add surrounding cells of wall to frontier
            if (wallX+1 < ROWS && maze[wallX+1][wallY] == 1) // Down
            {
                frontier[numFrontier][0] = wallX+1;
                frontier[numFrontier][1] = wallY;
                numFrontier++;
            }
            if (wallX-1 >= 0 && maze[wallX-1][wallY] == 1) // Up
            {
                frontier[numFrontier][0] = wallX-1;
                frontier[numFrontier][1] = wallY;
                numFrontier++;
            }
            if (wallY+1 < COLS && maze[wallX][wallY+1] == 1) // Right
            {
                frontier[numFrontier][0] = wallX;
                frontier[numFrontier][1] = wallY+1;
                numFrontier++;
            }
            if (wallY-1 >= 0 && maze[wallX][wallY-1] == 1) // Left
            {
                frontier[numFrontier][0] = wallX;
                frontier[numFrontier][1] = wallY-1;
                numFrontier++;
            }
        }
        
        // Delete random frontier cell
        frontier[randIndex][0] = frontier[numFrontier-1][0];
        frontier[randIndex][1] = frontier[numFrontier-1][1];
        numFrontier--;
    }
}

// Display maze in console using ASCII characters
void displayMaze(int maze[][COLS])
{
    for (int i = 0; i < ROWS; i++)
    {
        for (int j = 0; j < COLS; j++)
        {
            if (maze[i][j] == 0) // 0 represents a path
            {
                printf(" ");
            }
            else
            {
                printf("#");
            }
        }
        
        printf("\n");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall generateMaze(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall displayMaze(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[1608]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v6; // [rsp+668h] [rbp+5E8h]
  unsigned int v7; // [rsp+66Ch] [rbp+5ECh]

  _main(argc, argv, envp);
  v7 = 1;
  v6 = 1;
  v3 = time(0i64);
  srand(v3);
  generateMaze(v5, v7, v6);
  displayMaze(v5);
  return 0;
}
// 14000161F: using guessed type __int64 __fastcall generateMaze(_QWORD, _QWORD, _QWORD);
// 140001C8D: using guessed type __int64 __fastcall displayMaze(_QWORD);
// 140001DD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue ; Style: brave
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

int queue[MAX_SIZE];
int front = -1;
int rear = -1;

void insert(int value) {
  if ((front == 0 && rear == MAX_SIZE - 1) || (front == rear + 1)) {
    printf("Queue Overflow\n");
    return;
  }

  if (front == -1) {
    front = 0;
    rear = 0;
  } else {
    if (rear == MAX_SIZE - 1) {
      rear = 0;
    } else {
      rear++;
    }
  }

  queue[rear] = value;
}

void delete() {
  if (front == -1) {
    printf("Queue Underflow\n");
    return;
  }

  printf("Deleted item is: %d\n", queue[front]);

  if (front == rear) {
    front = -1;
    rear = -1;
  } else {
    if (front == MAX_SIZE - 1) {
      front = 0;
    } else {
      front++;
    }
  }
}

void display() {
  int i;

  if (front == -1) {
    printf("Queue is empty\n");
    return;
  }

  printf("Queue elements are:\n");

  if (rear >= front) {
    for (i = front; i <= rear; i++) {
      printf("%d ", queue[i]);
    }
  } else {
    for (i = front; i < MAX_SIZE; i++) {
      printf("%d ", queue[i]);
    }

    for (i = 0; i <= rear; i++) {
      printf("%d ", queue[i]);
    }
  }

  printf("\n");
}

int main() {
  int choice, value;

  while (1) {
    printf("1. Insert\n");
    printf("2. Delete\n");
    printf("3. Display\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);

    switch (choice) {
      case 1:
        printf("Enter the value to be inserted: ");
        scanf("%d", &value);
        insert(value);
        break;
      case 2:
        delete();
        break;
      case 3:
        display();
        break;
      case 4:
        printf("Exiting the program\n");
        exit(0);
        break;
      default:
        printf("Invalid choice\n");
    }
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall insert(_QWORD); // weak
__int64 delete(void); // weak
__int64 display(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (000000014000184E) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // [rsp+28h] [rbp-8h] BYREF
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    printf("1. Insert\n");
    printf("2. Delete\n");
    printf("3. Display\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v4);
    if ( v4 == 4 )
    {
      printf("Exiting the program\n");
      exit(0);
    }
    if ( v4 > 4 )
    {
LABEL_12:
      printf("Invalid choice\n");
    }
    else
    {
      switch ( v4 )
      {
        case 3:
          display();
          break;
        case 1:
          printf("Enter the value to be inserted: ");
          scanf("%d", &v3);
          insert(v3);
          break;
        case 2:
          delete();
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 1400018D1: conditional instruction was optimized away because %var_4.4<3
// 1400015E2: using guessed type __int64 __fastcall insert(_QWORD);
// 140001690: using guessed type __int64 delete(void);
// 140001731: using guessed type __int64 display(void);
// 140001A00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: imaginative
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

//Function declarations
void printArray(int arr[], int size);
void selectionSort(int arr[], int size);

int main()
{
    printf("Welcome to the Magical Sorting program!\n\n");
    printf("In this program, we will demonstrate the magical power of selection sorting.\n");
    printf("We will use a magical array of randomly generated numbers to demonstrate how selection sorting works.\n\n");

    //Generate the magical array of numbers
    srand(time(0)); //Seed the random number generator
    int size = 10; //Size of the array
    int arr[size];
    printf("The magical array of numbers is: \n");
    for(int i=0; i<size; i++)
    {
        arr[i] = rand()%100; //Generate a random number between 0 and 99
        printf("%d ", arr[i]);
    }
    printf("\n\n");

    //Call the selection sort function to sort the array
    selectionSort(arr, size);

    printf("The magical array of numbers has been sorted using selection sorting.\n");
    printf("The sorted array is: \n");
    printArray(arr, size);

    return 0;
}

//Function to print the array
void printArray(int arr[], int size)
{
    for(int i=0; i<size; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n\n");
}

//Function to perform selection sorting on the array
void selectionSort(int arr[], int size)
{
    printf("The magical powers of selection sorting are now at work...\n\n");
    int min, temp;
    for(int i=0; i<size-1; i++)
    {
        min = i;
        for(int j=i+1; j<size; j++)
        {
            if(arr[j] < arr[min])
            {
                min = j;
            }
        }
        temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;
        printf("The magical sorting wand has waved, and the array has been transformed:\n");
        printArray(arr, size);
    }
    printf("The magical powers of selection sorting have been fully utilized.\n\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall printArray(_QWORD, _QWORD); // weak
__int64 __fastcall selectionSort(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  void *v4; // rsp
  char v6; // [rsp+20h] [rbp-20h] BYREF
  char *v7; // [rsp+28h] [rbp-18h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  unsigned int v9; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Magical Sorting program!\n\n");
  printf("In this program, we will demonstrate the magical power of selection sorting.\n");
  printf("We will use a magical array of randomly generated numbers to demonstrate how selection sorting works.\n\n");
  v3 = time(0i64);
  srand(v3);
  v9 = 10;
  v8 = 9i64;
  v4 = alloca(48i64);
  v7 = &v6;
  printf("The magical array of numbers is: \n");
  for ( i = 0; i < (int)v9; ++i )
  {
    *(_DWORD *)&v7[4 * i] = rand() % 100;
    printf("%d ", *(unsigned int *)&v7[4 * i]);
  }
  printf("\n\n");
  selectionSort(v7, v9);
  printf("The magical array of numbers has been sorted using selection sorting.\n");
  printf("The sorted array is: \n");
  printArray(v7, v9);
  return 0;
}
// 140001738: using guessed type __int64 __fastcall printArray(_QWORD, _QWORD);
// 140001799: using guessed type __int64 __fastcall selectionSort(_QWORD, _QWORD);
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Drone Remote Control ; Style: expert-level
#include <stdio.h>

struct remoteControl {
    int power; // variable to hold power status
    int pitch; // variable to hold pitch level
    int roll; // variable to hold roll level
    int yaw; // variable to hold yaw level
} drone; // create instance of remoteControl struct, named drone

int main() {
    // init the remote control, drone is off and at zero levels
    drone.power = 0;
    drone.pitch = 0;
    drone.roll = 0;
    drone.yaw = 0;

    // ask user if they want turn on or off the drone
    printf("Do you want to turn on the drone? (1=Yes, 0=No):\n");
    scanf("%d", &drone.power); // get user input and store in drone.power

    // check if the drone is power on or off
    if(drone.power == 1) {
        printf("Drone is powering on...\n");

        // prompt user for pitch level
        printf("Select pitch level (Range -100 to 100):\n");
        scanf("%d", &drone.pitch); // get user input and store in drone.pitch

        // prompt user for roll level
        printf("Select roll level (Range -100 to 100):\n");
        scanf("%d", &drone.roll); // get user input and store in drone.roll

        // prompt user for yaw level
        printf("Select yaw level (Range -100 to 100):\n");
        scanf("%d", &drone.yaw); // get user input and store in drone.yaw

        // send control signals to the drone
        printf("Sending control signals to the drone...\n");

        // print final control signal values
        printf("Control Signals:\n");
        printf("Pitch: %d\n", drone.pitch);
        printf("Roll: %d\n", drone.roll);
        printf("Yaw: %d\n", drone.yaw);
    } else {
        printf("Drone is powered off...\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

int drone; // weak
int dword_140018044; // weak
int dword_140018048; // weak
int dword_14001804C; // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  drone = 0;
  dword_140018044 = 0;
  dword_140018048 = 0;
  dword_14001804C = 0;
  printf("Do you want to turn on the drone? (1=Yes, 0=No):\n");
  scanf("%d", &drone);
  if ( drone == 1 )
  {
    printf("Drone is powering on...\n");
    printf("Select pitch level (Range -100 to 100):\n");
    scanf("%d", &dword_140018044);
    printf("Select roll level (Range -100 to 100):\n");
    scanf("%d", &dword_140018048);
    printf("Select yaw level (Range -100 to 100):\n");
    scanf("%d", &dword_14001804C);
    printf("Sending control signals to the drone...\n");
    printf("Control Signals:\n");
    printf("Pitch: %d\n", (unsigned int)dword_140018044);
    printf("Roll: %d\n", (unsigned int)dword_140018048);
    printf("Yaw: %d\n", (unsigned int)dword_14001804C);
  }
  else
  {
    printf("Drone is powered off...\n");
  }
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140018040: using guessed type int drone;
// 140018044: using guessed type int dword_140018044;
// 140018048: using guessed type int dword_140018048;
// 14001804C: using guessed type int dword_14001804C;

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Rogue-like Game with Procedural Generation ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAP_SIZE 20

char map[MAP_SIZE][MAP_SIZE];
int playerX, playerY;

void generateMap();
void printMap();
void movePlayer(int x, int y);

int main()
{
    srand(time(NULL));
    generateMap();
    playerX = MAP_SIZE/2;
    playerY = MAP_SIZE/2;
    map[playerX][playerY] = '@';
    printMap();
    char input;
    while (1) {
        input = getchar();
        switch (input) {
            case 'w':
                movePlayer(-1, 0);
                break;
            case 's':
                movePlayer(1, 0);
                break;
            case 'a':
                movePlayer(0, -1);
                break;
            case 'd':
                movePlayer(0, 1);
                break;
            default:
                break;
        }
        system("clear");
        printMap();
    }
}

void generateMap()
{
    int i, j;
    for (i = 0; i < MAP_SIZE; i++) {
        for (j = 0; j < MAP_SIZE; j++) {
            if (rand()%10 == 0) {
                map[i][j] = '#';
            } else {
                map[i][j] = '.';
            }
        }
    }
}

void printMap()
{
    int i, j;
    for (i = 0; i < MAP_SIZE; i++) {
        printf("|");
        for (j = 0; j < MAP_SIZE; j++) {
            printf("%c|", map[i][j]);
        }
        printf("\n");
    }
}

void movePlayer(int x, int y)
{
    if (playerX + x >= 0 && playerX + x < MAP_SIZE) {
        if (map[playerX+x][playerY+y] != '#') {
            map[playerX][playerY] = '.';
            playerX += x;
            playerY += y;
            map[playerX][playerY] = '@';
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 generateMap(void); // weak
__int64 printMap(void); // weak
__int64 __fastcall movePlayer(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl system(const char *Command);
// void __cdecl srand(unsigned int Seed);
// int __cdecl getchar();

//-------------------------------------------------------------------------
// Data declarations

_BYTE map[400]; // weak
int playerX; // weak
int playerY; // weak


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  generateMap();
  playerX = 10;
  playerY = 10;
  map[210] = 64;
  printMap();
  while ( 1 )
  {
    v4 = (char)getchar();
    if ( v4 == 119 )
    {
      movePlayer(0xFFFFFFFFi64, 0i64);
    }
    else if ( v4 <= 119 )
    {
      if ( v4 == 115 )
      {
        movePlayer(1i64, 0i64);
      }
      else if ( v4 <= 115 )
      {
        if ( v4 == 97 )
        {
          movePlayer(0i64, 0xFFFFFFFFi64);
        }
        else if ( v4 == 100 )
        {
          movePlayer(0i64, 1i64);
        }
      }
    }
    system("clear");
    printMap();
  }
}
// 1400016A7: using guessed type __int64 generateMap(void);
// 140001778: using guessed type __int64 printMap(void);
// 14000180B: using guessed type __int64 __fastcall movePlayer(_QWORD, _QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type _BYTE map[400];
// 14000F1D0: using guessed type int playerX;
// 14000F1D4: using guessed type int playerY;

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: high level of detail
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    printf("Welcome to the Automated Fortune Teller! \n");
    printf("Ask me a question and I will give you an answer. \n");

    // seed random number generator
    srand(time(NULL));

    // array of possible answers
    char* answers[] = {
        "It is certain.",
        "Without a doubt.",
        "You may rely on it.",
        "Yes, definitely.",
        "It is decidedly so.",
        "As I see it, yes.",
        "Most likely.",
        "Yes.",
        "Outlook good.",
        "Signs point to yes.",
        "Reply hazy, try again.",
        "Better not tell you now.",
        "Ask again later.",
        "Cannot predict now.",
        "Concentrate and ask again.",
        "Don't count on it.",
        "Outlook not so good.",
        "My sources say no.",
        "Very doubtful.",
        "My reply is no."
    };

    // generate random index and print answer
    int index = rand() % 20;
    printf("\n%s\n", answers[index]);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5[21]; // [rsp+20h] [rbp-B0h]
  int v6; // [rsp+CCh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Automated Fortune Teller! \n");
  printf("Ask me a question and I will give you an answer. \n");
  v3 = time(0i64);
  srand(v3);
  v5[0] = (__int64)"It is certain.";
  v5[1] = (__int64)"Without a doubt.";
  v5[2] = (__int64)"You may rely on it.";
  v5[3] = (__int64)"Yes, definitely.";
  v5[4] = (__int64)"It is decidedly so.";
  v5[5] = (__int64)"As I see it, yes.";
  v5[6] = (__int64)"Most likely.";
  v5[7] = (__int64)"Yes.";
  v5[8] = (__int64)"Outlook good.";
  v5[9] = (__int64)"Signs point to yes.";
  v5[10] = (__int64)"Reply hazy, try again.";
  v5[11] = (__int64)"Better not tell you now.";
  v5[12] = (__int64)"Ask again later.";
  v5[13] = (__int64)"Cannot predict now.";
  v5[14] = (__int64)"Concentrate and ask again.";
  v5[15] = (__int64)"Don't count on it.";
  v5[16] = (__int64)"Outlook not so good.";
  v5[17] = (__int64)"My sources say no.";
  v5[18] = (__int64)"Very doubtful.";
  v5[19] = (__int64)"My reply is no.";
  v6 = rand() % 20;
  printf("\n%s\n", (const char *)v5[v6]);
  return 0;
}
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedural Space Adventure ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Game constants
#define MAX_PLANETS 10
#define MAX_RESOURCES 3
#define MAX_ENEMIES 5
#define MAX_PLAYER_NAME 20
#define MAX_ENEMY_NAME 15

// Function prototypes
void displayWelcomeScreen();
void displayMainMenu();
void generatePlanets();
void displayPlanets();
void displayPlanetDetails(int planetNum);
void generateEnemies();
void displayEnemies();
void displayEnemyDetails(int enemyNum);
void travelToPlanet();
void shop();
void fightEnemy();
void displayPlayerStats();
void gameOver();

// Global variables
int currentPlanet = 0;
int enemiesDefeated = 0;
int playerHealth = 100;
int playerCredits = 100;
char playerName[MAX_PLAYER_NAME];
char resources[MAX_RESOURCES][15] = {"Fuel", "Food", "Water"};
char enemyNames[MAX_ENEMIES][MAX_ENEMY_NAME] = {"ExoGuardian", "Spaceling", "Toxic Spore", "Orbital Sentinel", "Galactic Spectre"};

// Planet structure definition
struct Planet {
    char planetName[15];
    int resourcePrices[MAX_RESOURCES];
};

// Enemy structure definition
struct Enemy {
    char enemyName[MAX_ENEMY_NAME];
    int enemyHealth;
    int enemyDamage;
};

struct Planet planets[MAX_PLANETS];
struct Enemy enemies[MAX_ENEMIES];

int main() {
    srand(time(NULL)); // Seed the random number generator
    displayWelcomeScreen();
    printf("Please enter your name: ");
    scanf("%s", playerName);
    generatePlanets();
    generateEnemies();
    while(1) {
        displayMainMenu();
        int choice;
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch(choice) {
            case 1:
                displayPlanets();
                break;
            case 2:
                travelToPlanet();
                break;
            case 3:
                shop();
                break;
            case 4:
                fightEnemy();
                break;
            case 5:
                displayPlayerStats();
                break;
            case 6:
                gameOver();
                break;
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }
    return 0;
}

// Displays the welcome screen
void displayWelcomeScreen() {
    printf("********************************************\n");
    printf("           Procedural Space Adventure         \n");
    printf("********************************************\n");
    printf("\n");
}

// Displays the main menu
void displayMainMenu() {
    printf("\n");
    printf("********************************************\n");
    printf("                    Main Menu                 \n");
    printf("********************************************\n");
    printf("1. View Planets\n");
    printf("2. Travel to Planet\n");
    printf("3. Shop\n");
    printf("4. Fight Enemy\n");
    printf("5. View Player Stats\n");
    printf("6. Quit Game\n");
    printf("********************************************\n");
}

// Generates the planets
void generatePlanets() {
    for(int i = 0; i < MAX_PLANETS; i++) {
        sprintf(planets[i].planetName, "Planet %d", i + 1);
        for(int j = 0; j < MAX_RESOURCES; j++) {
            int price = rand() % 11 + 5;
            planets[i].resourcePrices[j] = price;
        }
    }
}

// Displays the planet list
void displayPlanets() {
    printf("\n");
    printf("********************************************\n");
    printf("                  Planet List                \n");
    printf("********************************************\n");
    for(int i = 0; i < MAX_PLANETS; i++) {
        printf("%d. %s\n", i + 1, planets[i].planetName);
    }
    printf("********************************************\n");
}

// Displays the planet details
void displayPlanetDetails(int planetNum) {
    printf("\n");
    printf("********************************************\n");
    printf("               %s Planet Details             \n", planets[planetNum].planetName);
    printf("********************************************\n");
    for(int i = 0; i < MAX_RESOURCES; i++) {
        printf("%s: %d credits\n", resources[i], planets[planetNum].resourcePrices[i]);
    }
    printf("********************************************\n");
}

// Generates the enemies
void generateEnemies() {
    for(int i = 0; i < MAX_ENEMIES; i++) {
        sprintf(enemies[i].enemyName, "%s Class Enemy", enemyNames[i]);
        enemies[i].enemyHealth = rand() % 51 + 50;
        enemies[i].enemyDamage = rand() % 26 + 25;
    }
}

// Displays the enemy list
void displayEnemies() {
    printf("\n");
    printf("********************************************\n");
    printf("                  Enemy List                 \n");
    printf("********************************************\n");
    for(int i = 0; i < MAX_ENEMIES; i++) {
        printf("%d. %s\n", i + 1, enemies[i].enemyName);
    }
    printf("********************************************\n");
}

// Displays the enemy details
void displayEnemyDetails(int enemyNum) {
    printf("\n");
    printf("********************************************\n");
    printf("               %s Details             \n", enemies[enemyNum].enemyName);
    printf("********************************************\n");
    printf("Health: %d\n", enemies[enemyNum].enemyHealth);
    printf("Damage: %d\n", enemies[enemyNum].enemyDamage);
    printf("********************************************\n");
}

// Allows the player to travel to a planet
void travelToPlanet() {
    int choice;
    printf("\n");
    printf("********************************************\n");
    printf("                  Travel Menu                \n");
    printf("********************************************\n");
    printf("Current Planet: %s\n", planets[currentPlanet].planetName);
    displayPlanets();
    printf("Enter the number of the planet you want to travel to: ");
    scanf("%d", &choice);
    if(choice > 0 && choice <= MAX_PLANETS && choice != currentPlanet + 1) {
        int distance = abs(currentPlanet - (choice - 1));
        int travelCost = (distance + 1) * 10;
        if(playerCredits >= travelCost) {
            playerCredits -= travelCost;
            currentPlanet = choice - 1;
            printf("You have successfully travelled to %s planet.\n", planets[currentPlanet].planetName);
            displayPlanetDetails(currentPlanet);
        } else {
            printf("You do not have enough credits to make this trip.\n");
        }
    } else if(choice == currentPlanet + 1) {
        printf("You are already on this planet.\n");
    } else {
        printf("Invalid choice. Please try again.\n");
    }
}

// Allows the player to buy or sell resources
void shop() {
    int choice;
    printf("\n");
    printf("********************************************\n");
    printf("                     Shop                    \n");
    printf("********************************************\n");
    displayPlanetDetails(currentPlanet);
    printf("Credits: %d\n", playerCredits);
    printf("1. Buy Resources\n");
    printf("2. Sell Resources\n");
    printf("3. Exit Shop\n");
    printf("********************************************\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
    if(choice == 1) {
        printf("\n");
        printf("********************************************\n");
        printf("                   Buy Menu                  \n");
        printf("********************************************\n");
        for(int i = 0; i < MAX_RESOURCES; i++) {
            printf("%d. %s: %d credits\n", i + 1, resources[i], planets[currentPlanet].resourcePrices[i]);
        }
        printf("********************************************\n");
        printf("Enter the number of the resource you want to buy: ");
        int resourceChoice;
        scanf("%d", &resourceChoice);
        if(resourceChoice > 0 && resourceChoice <= MAX_RESOURCES) {
            printf("Enter the quantity you want to buy: ");
            int quantity;
            scanf("%d", &quantity);
            int totalPrice = quantity * planets[currentPlanet].resourcePrices[resourceChoice - 1];
            if(totalPrice > playerCredits) {
                printf("You do not have enough credits to make this purchase.\n");
            } else {
                playerCredits -= totalPrice;
                printf("You have successfully purchased %d units of %s.\n", quantity, resources[resourceChoice - 1]);
            }
        } else {
            printf("Invalid choice. Please try again.\n");
        }
    } else if(choice == 2) {
        printf("\n");
        printf("********************************************\n");
        printf("                   Sell Menu                 \n");
        printf("********************************************\n");
        for(int i = 0; i < MAX_RESOURCES; i++) {
            printf("%d. %s: %d credits\n", i + 1, resources[i], planets[currentPlanet].resourcePrices[i]);
        }
        printf("********************************************\n");
        printf("Enter the number of the resource you want to sell: ");
        int resourceChoice;
        scanf("%d", &resourceChoice);
        if(resourceChoice > 0 && resourceChoice <= MAX_RESOURCES) {
            printf("Enter the quantity you want to sell: ");
            int quantity;
            scanf("%d", &quantity);
            int totalPrice = quantity * planets[currentPlanet].resourcePrices[resourceChoice - 1];
            playerCredits += totalPrice;
            printf("You have successfully sold %d units of %s.\n", quantity, resources[resourceChoice - 1]);
        } else {
            printf("Invalid choice. Please try again.\n");
        }
    } else if(choice == 3) {
        printf("Exiting shop.\n");
    } else {
        printf("Invalid choice. Please try again.\n");
    }
}

// Allows the player to fight an enemy
void fightEnemy() {
    int choice;
    printf("\n");
    printf("********************************************\n");
    printf("               Choose an enemy                \n");
    printf("********************************************\n");
    displayEnemies();
    printf("Enter the number of the enemy you want to fight: ");
    scanf("%d", &choice);
    if(choice > 0 && choice <= MAX_ENEMIES) {
        displayEnemyDetails(choice - 1);
        printf("Are you ready to fight? (1. Yes 2. No): ");
        int ready;
        scanf("%d", &ready);
        if(ready == 1) {
            struct Enemy currentEnemy = enemies[choice - 1];
            int totalEnemyDamage = 0;
            int totalPlayerDamage = 0;
            while(playerHealth > 0 && currentEnemy.enemyHealth > 0) {
                int playerDamage = rand() % 11 + 5;
                totalPlayerDamage += playerDamage;
                printf("You attacked the enemy and did %d damage. Enemy health is now %d.\n", playerDamage, currentEnemy.enemyHealth - playerDamage);
                currentEnemy.enemyHealth -= playerDamage;
                if(currentEnemy.enemyHealth > 0) {
                    int enemyDamage = rand() % currentEnemy.enemyDamage + 1;
                    totalEnemyDamage += enemyDamage;
                    printf("The enemy attacked you and did %d damage. Your health is now %d.\n", enemyDamage, playerHealth - enemyDamage);
                    playerHealth -= enemyDamage;
                }
            }
            if(playerHealth <= 0) {
                printf("You lost the fight and have been transported back to your base planet.\n");
                currentPlanet = 0;
                playerCredits = 100;
                playerHealth = 100;
            } else {
                int lootCredits = rand() % 51 + 50;
                playerCredits += lootCredits;
                printf("Congratulations! You have won the fight and earned %d credits.\n", lootCredits);
                enemiesDefeated++;
            }
        } else if(ready == 2) {
            printf("You chickened out of the fight.\n");
        } else {
            printf("Invalid choice. Please try again.\n");
        }
    } else {
        printf("Invalid choice. Please try again.\n");
    }
}

// Displays the player stats
void displayPlayerStats() {
    printf("\n");
    printf("********************************************\n");
    printf("                  Player Stats               \n");
    printf("********************************************\n");
    printf("Name: %s\n", playerName);
    printf("Current Planet: %s\n", planets[currentPlanet].planetName);
    printf("Credits: %d\n", playerCredits);
    printf("Health: %d\n", playerHealth);
    printf("Enemies Defeated: %d\n", enemiesDefeated);
    printf("********************************************\n");
}

// Ends the game
void gameOver() {
    printf("Thank you for playing Procedural Space Adventure!\n");
    exit(EXIT_SUCCESS);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 displayWelcomeScreen(void); // weak
__int64 displayMainMenu(void); // weak
__int64 generatePlanets(void); // weak
__int64 displayPlanets(void); // weak
__int64 generateEnemies(void); // weak
__int64 travelToPlanet(void); // weak
__int64 shop(void); // weak
__int64 fightEnemy(void); // weak
__int64 displayPlayerStats(void); // weak
void __noreturn gameOver(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN playerName; // weak


//----- (0000000140001644) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  displayWelcomeScreen();
  printf("Please enter your name: ");
  scanf("%s", &playerName);
  generatePlanets();
  generateEnemies();
  while ( 1 )
  {
    displayMainMenu();
    printf("Enter your choice: ");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        displayPlanets();
        break;
      case 2:
        travelToPlanet();
        break;
      case 3:
        shop();
        break;
      case 4:
        fightEnemy();
        break;
      case 5:
        displayPlayerStats();
        break;
      case 6:
        gameOver();
      default:
        printf("Invalid choice. Please try again.\n");
        break;
    }
  }
}
// 14000172B: using guessed type __int64 displayWelcomeScreen(void);
// 140001776: using guessed type __int64 displayMainMenu(void);
// 14000182A: using guessed type __int64 generatePlanets(void);
// 140001907: using guessed type __int64 displayPlanets(void);
// 140001A9B: using guessed type __int64 generateEnemies(void);
// 140001D22: using guessed type __int64 travelToPlanet(void);
// 140001ECA: using guessed type __int64 shop(void);
// 14000237B: using guessed type __int64 fightEnemy(void);
// 140002636: using guessed type __int64 displayPlayerStats(void);
// 140002721: using guessed type void __noreturn gameOver(void);
// 140002800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=195 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Resume Parsing System ; Style: systematic
#include <stdio.h>
#include <string.h>
#include <ctype.h>

// function prototypes
void parseResume(char *resumeText);
int extractEducation(char *resumeText, char *educationLine[], int *numLines);
int extractExperience(char *resumeText, char *experienceLine[], int *numLines);

int main() {
    char resume[10000]; // assuming resume will not be longer than 10,000 characters
    printf("Enter your resume text:\n");
    fgets(resume, sizeof(resume), stdin); // read resume text from user

    parseResume(resume); // parse resume text and display extracted education and experience

    return 0;
}

// function to parse resume text and extract education and experience sections
void parseResume(char *resumeText) {
    char *educationLine[10]; // assuming maximum of 10 education lines
    int numEducationLines = extractEducation(resumeText, educationLine, &numEducationLines);
    printf("\nEDUCATION:\n");
    for (int i = 0; i < numEducationLines; i++) {
        printf("%s\n", educationLine[i]);
    }

    char *experienceLine[10]; // assuming maximum of 10 experience lines
    int numExperienceLines = extractExperience(resumeText, experienceLine, &numExperienceLines);
    printf("\nEXPERIENCE:\n");
    for (int i = 0; i < numExperienceLines; i++) {
        printf("%s\n", experienceLine[i]);
    }
}

// function to extract education section from resume text
int extractEducation(char *resumeText, char *educationLine[], int *numLines) {
    *numLines = 0;
    char *start = strstr(resumeText, "education");
    if (start == NULL) {
        return 0; // no education section found
    }

    start += strlen("education") + 1; // skip "education" and the following space
    char *end = strstr(start, "experience");
    if (end == NULL) {
        end = resumeText + strlen(resumeText); // if experience section not found, use end of resume text
    }

    // extract each line of education section
    int i = 0;
    while (start < end) {
        char *lineEnd = strstr(start, "\n");
        if (lineEnd == NULL || lineEnd > end) {
            lineEnd = end; // if end of line not found or crossed experience section, use end of education section
        }

        // trim leading and trailing spaces from line
        while (isspace(*start)) {
            start++;
        }
        while (isspace(*(lineEnd - 1))) {
            lineEnd--;
        }

        int len = lineEnd - start;
        educationLine[i] = malloc(len + 1); // allocate memory for line
        strncpy(educationLine[i], start, len);
        educationLine[i][len] = '\0'; // terminate string
        i++;

        *numLines = i;
        if (i >= 10) {
            break; // maximum of 10 lines extracted
        }

        start = lineEnd + 1;
    }

    return i;
}

// function to extract experience section from resume text
int extractExperience(char *resumeText, char *experienceLine[], int *numLines) {
    *numLines = 0;
    char *start = strstr(resumeText, "experience");
    if (start == NULL) {
        return 0; // no experience section found
    }

    start += strlen("experience") + 1; // skip "experience" and the following space

    // extract each line of experience section
    int i = 0;
    while (*start != '\0') {
        char *lineEnd = strstr(start, "\n");

        // trim leading and trailing spaces from line
        while (isspace(*start)) {
            start++;
        }
        while (isspace(*(lineEnd - 1))) {
            lineEnd--;
        }

        int len = lineEnd - start;
        experienceLine[i] = malloc(len + 1); // allocate memory for line
        strncpy(experienceLine[i], start, len);
        experienceLine[i][len] = '\0'; // terminate string
        i++;

        *numLines = i;
        if (i >= 10) {
            break; // maximum of 10 lines extracted
        }

        start = lineEnd + 1;
    }

    return i;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall parseResume(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[10000]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  printf("Enter your resume text:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 10000, v3);
  parseResume(Buffer);
  return 0;
}
// 1400015FA: using guessed type __int64 __fastcall parseResume(_QWORD);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: inquisitive
#include <stdio.h>

int main() {
  int x, y, n;
  printf("Let's print a C-shaped pattern. How many rows do you want? ");
  scanf("%d", &n);
  for (x = 0; x < n; x++) {
    for (y = 0; y <= n; y++) {
      if (y == 0 || (x == 0 && y < n) || (x == n/2 && y >= n/2) || (y == n/2 && x > n/2) || x == n-1) {
        printf("*");
      } else {
        printf(" ");
      }
    }
    printf("\n");
  }
  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Let's print a C-shaped pattern. How many rows do you want? ");
  scanf("%d", &v4);
  for ( i = 0; i < v4; ++i )
  {
    for ( j = 0; j <= v4; ++j )
    {
      if ( !j || !i && j < v4 || i == v4 / 2 && j >= v4 / 2 || j == v4 / 2 && i > v4 / 2 || i == v4 - 1 )
        printf("*");
      else
        printf(" ");
    }
    printf("\n");
  }
  return 0;
}
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: satisfied
#include<stdio.h>

int isPrime(int num){
    if(num == 2 || num == 3) return 1;   //2 and 3 are considered prime

    if(num == 1 || num % 2 == 0) return 0;   //1 is not prime and even numbers greater than 2 are not prime

    for(int i=3; i*i<=num; i+=2){    //iterate only through odd numbers
        if(num%i == 0) return 0;    //if the number is divisible by any of the odd numbers, then it is not prime
    }
    return 1;
}

int main(){
    int num, count = 0;

    printf("Enter the maximum limit till which prime numbers should be generated: ");
    scanf("%d", &num);

    printf("The prime numbers between 1 and %d are: ", num);
    for(int i = 1; i <= num; i++){
        if(isPrime(i)){
            count++;
            printf("%d ", i);
        }
    }
    printf("\n\nThere are a total of %d prime numbers from 1 to %d.\n", count, num);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall isPrime(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000164E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int i; // [rsp+28h] [rbp-8h]
  unsigned int v6; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  printf("Enter the maximum limit till which prime numbers should be generated: ");
  scanf("%d", &v4);
  printf("The prime numbers between 1 and %d are: ", v4);
  for ( i = 1; (int)i <= (int)v4; ++i )
  {
    if ( (unsigned int)isPrime(i) )
    {
      ++v6;
      printf("%d ", i);
    }
  }
  printf("\n\nThere are a total of %d prime numbers from 1 to %d.\n", v6, v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall isPrime(_QWORD);
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home light control ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>

#define LIGHT_ON 1
#define LIGHT_OFF 0

// Function to turn on the light
void turn_on_light() {
    printf("Light turned ON\n");
}

// Function to turn off the light
void turn_off_light() {
    printf("Light turned OFF\n");
}

// Main function
int main() {
    bool motion_detected = false;
    int current_light_status = LIGHT_OFF;

    while (true) {
        if (motion_detected) {
            if (current_light_status == LIGHT_OFF) {
                turn_on_light();
                current_light_status = LIGHT_ON;
            }
        } else {
            if (current_light_status == LIGHT_ON) {
                turn_off_light();
                current_light_status = LIGHT_OFF;
            }
        }

        // Wait for 2 seconds
        sleep(2);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 turn_on_light(void); // weak
__int64 turn_off_light(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak


//----- (00000001400015CD) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  while ( 1 )
    sleep(2i64);
}
// 1400015E9: conditional instruction was optimized away because %var_5.1==0
// 140001603: conditional instruction was optimized away because %var_4.4==0
// 140001591: using guessed type __int64 turn_on_light(void);
// 1400015AF: using guessed type __int64 turn_off_light(void);
// 1400016D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002730: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System event logger ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void log_event(char *event_type, char *message) {
    FILE *log_file;
    time_t current_time;

    // Open the log file in append mode
    log_file = fopen("event.log", "a");

    // Get the current time and format it
    time(&current_time);
    char timestamp[20];
    strftime(timestamp, 20, "%Y-%m-%d %H:%M:%S", localtime(&current_time));

    // Write the event details to the log file
    fprintf(log_file, "[%s] %s: %s\n", timestamp, event_type, message);

    // Close the log file
    fclose(log_file);
}

int main() {
    // Generate some sample events for testing
    log_event("INFO", "Program started");
    log_event("WARNING", "Resource usage approaching limit");
    log_event("ERROR", "Unable to open file");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall log_event(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000165E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  log_event("INFO", "Program started");
  log_event("WARNING", "Resource usage approaching limit");
  log_event("ERROR", "Unable to open file");
  return 0;
}
// 1400015C1: using guessed type __int64 __fastcall log_event(_QWORD, _QWORD);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Performance-Critical Component ; Style: brave
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ARRAY_SIZE 1000000
#define LOOP_COUNT 10000

int main() {
    srand(time(NULL));

    int array1[ARRAY_SIZE], array2[ARRAY_SIZE];

    // Initialize arrays with random values
    for (int i = 0; i < ARRAY_SIZE; i++) {
        array1[i] = rand() % 100;
        array2[i] = rand() % 100;
    }

    int result = 0;

    // Multiply the elements of the arrays
    clock_t start_time = clock();

    for (int j = 0; j < LOOP_COUNT; j++) {
        for (int i = 0; i < ARRAY_SIZE; i++) {
            result += array1[i] * array2[i];
        }
    }

    clock_t end_time = clock();

    double elapsed_time = ((double) (end_time - start_time)) / CLOCKS_PER_SEC;

    printf("Result: %d\n", result);
    printf("Elapsed time: %f seconds\n", elapsed_time);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (00000001400015B0) ----------------------------------------------------
#error "1400015B0: stack frame is too big (funcsize=0)"

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Hotel Management System ; Style: shape shifting
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct guest {
  char name[30];
  int room_number;
  int stay_length;
  float bill_total;
};

void add_guest(struct guest list[], int *num_guests);
void display_guests(struct guest list[], int num_guests);
void checkout_guest(struct guest list[], int *num_guests);
void print_menu();

int main() {
  int choice, num_guests=0;
  struct guest guest_list[50];
  do {
    print_menu();
    printf("Enter your choice: ");
    scanf("%d", &choice);
    switch(choice) {
      case 1:
        add_guest(guest_list, &num_guests);
        break;
      case 2:
        display_guests(guest_list, num_guests);
        break;
      case 3:
        checkout_guest(guest_list, &num_guests);
        break;
      case 4:
        printf("Thank you for using the Hotel Management System.\n");
        exit(0);
      default:
        printf("Invalid choice. Please choose again.\n");
        break;
    }
  } while(choice != 4);

  return 0;
}

void add_guest(struct guest list[], int *num_guests) {
  if(*num_guests == 50) {
    printf("The hotel is currently at maximum capacity.\n");
    return;
  }
  
  printf("Enter guest name: ");
  scanf("%s", list[*num_guests].name);
  printf("Enter room number (1-50): ");
  scanf("%d", &list[*num_guests].room_number);
  printf("Enter length of stay: ");
  scanf("%d", &list[*num_guests].stay_length);
  list[*num_guests].bill_total = list[*num_guests].stay_length * 100.0; //Assuming each night costs $100
  printf("Guest added successfully.\n");
  (*num_guests)++;
}

void display_guests(struct guest list[], int num_guests) {
  if(num_guests == 0) {
    printf("There are currently no guests at the hotel.\n");
    return;
  }
  
  printf("Name\tRoom Number\tStay Length\tBill Total\n");
  for(int i=0; i<num_guests; i++) {
    printf("%s\t%d\t%d\t$%.2f\n", list[i].name, list[i].room_number, list[i].stay_length, list[i].bill_total);
  }
}

void checkout_guest(struct guest list[], int *num_guests) {
  if(*num_guests == 0) {
    printf("There are currently no guests to checkout.\n");
    return;
  }
  
  char name[30];
  printf("Enter guest name to checkout: ");
  scanf("%s", name);
  for(int i=0; i<*num_guests; i++) {
    if(strcmp(list[i].name, name) == 0) {
      printf("Checkout complete. Guest bill is $%.2f.\n", list[i].bill_total);
      for(int j=i; j<*num_guests-1; j++) {
        list[j] = list[j+1]; //Shift all elements after the checked out guest
      }
      (*num_guests)--;
      return;
    }
  }
  printf("Guest not found in current guests.\n");
}

void print_menu() {
  printf("Welcome to the Hotel Management System.\n");
  printf("1. Add guest\n");
  printf("2. Display current guests\n");
  printf("3. Checkout guest\n");
  printf("4. Exit\n");
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall add_guest(_QWORD, _QWORD); // weak
__int64 __fastcall display_guests(_QWORD, _QWORD); // weak
__int64 __fastcall checkout_guest(_QWORD, _QWORD); // weak
__int64 print_menu(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[2200]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int v5; // [rsp+8B8h] [rbp+838h] BYREF
  int v6; // [rsp+8BCh] [rbp+83Ch] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  do
  {
    print_menu();
    printf("Enter your choice: ");
    scanf("%d", &v6);
    if ( v6 == 4 )
    {
      printf("Thank you for using the Hotel Management System.\n");
      exit(0);
    }
    if ( v6 <= 4 )
    {
      switch ( v6 )
      {
        case 3:
          checkout_guest(v4, &v5);
          continue;
        case 1:
          add_guest(v4, &v5);
          continue;
        case 2:
          display_guests(v4, v5);
          continue;
      }
    }
    printf("Invalid choice. Please choose again.\n");
  }
  while ( v6 != 4 );
  return 0;
}
// 140001646: conditional instruction was optimized away because %var_4.4<3
// 1400016D8: using guessed type __int64 __fastcall add_guest(_QWORD, _QWORD);
// 140001879: using guessed type __int64 __fastcall display_guests(_QWORD, _QWORD);
// 140001991: using guessed type __int64 __fastcall checkout_guest(_QWORD, _QWORD);
// 140001B4E: using guessed type __int64 print_menu(void);
// 140001C60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sorting ; Style: ultraprecise
#include <stdio.h>

int main() {
    int array[5] = { 5, 3, 2, 4, 1 };
    int i, j, temp, pass = 0;
    
    printf("Unsorted Array: ");
    for(i = 0; i < 5; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");

    for(i = 0; i < 4; i++) {
        for(j = i + 1; j < 5; j++) {
             if (array[i] > array[j]) {
                 temp = array[i];
                 array[i] = array[j];
                 array[j] = temp;
             }
        }
        printf("Pass %d: ", pass + 1);
        for(j = 0; j < 5; j++) {
            printf("%d ", array[j]);
        }
        printf("\n");
        pass++;
    }

    printf("Sorted Array: ");
    for(i = 0; i < 5; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[8]; // [rsp+20h] [rbp-30h]
  int v5; // [rsp+40h] [rbp-10h]
  int v6; // [rsp+44h] [rbp-Ch]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 5;
  v4[1] = 3;
  v4[2] = 2;
  v4[3] = 4;
  v4[4] = 1;
  v6 = 0;
  printf("Unsorted Array: ");
  for ( i = 0; i <= 4; ++i )
    printf("%d ", (unsigned int)v4[i]);
  printf("\n");
  for ( i = 0; i <= 3; ++i )
  {
    for ( j = i + 1; j <= 4; ++j )
    {
      if ( v4[i] > v4[j] )
      {
        v5 = v4[i];
        v4[i] = v4[j];
        v4[j] = v5;
      }
    }
    printf("Pass %d: ", (unsigned int)(v6 + 1));
    for ( j = 0; j <= 4; ++j )
      printf("%d ", (unsigned int)v4[j]);
    printf("\n");
    ++v6;
  }
  printf("Sorted Array: ");
  for ( i = 0; i <= 4; ++i )
    printf("%d ", (unsigned int)v4[i]);
  printf("\n");
  return 0;
}
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fitness Tracker ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

struct fitnessData {
    float weight;
    int steps;
    float caloriesBurned;
};

int main() {
    int currentDay = 1;
    struct fitnessData weekData[7]; // for 7 days of the week
    srand(time(NULL)); // for random data

    // loop to collect data for a week
    while (currentDay <= 7) {
        printf("\nDay %d\n", currentDay);

        // collect weight data
        printf("Enter your weight for the day (kg): ");
        scanf("%f", &weekData[currentDay-1].weight);

        // collect step data
        printf("Enter the steps taken for the day: ");
        scanf("%d", &weekData[currentDay-1].steps);

        // calculate calories burned with a random factor
        float calories = weekData[currentDay-1].steps / 20.0;
        calories *= (rand() % 30 + 70) / 100.0;
        weekData[currentDay-1].caloriesBurned = calories;

        currentDay++;
    }

    // print the data for the week
    printf("\nWeek's Data:\n");
    printf("Day | Weight | Steps | Calories Burned\n");
    for (int i = 0; i < 7; i++) {
        printf("%d | %.2f | %d | %.2f\n", i+1, weekData[i].weight, weekData[i].steps, weekData[i].caloriesBurned);
    }

    // calculate weekly averages
    float totalWeight = 0, totalSteps = 0, totalCalories = 0;
    for (int i = 0; i < 7; i++) {
        totalWeight += weekData[i].weight;
        totalSteps += weekData[i].steps;
        totalCalories += weekData[i].caloriesBurned;
    }
    float weightAvg = totalWeight / 7.0;
    float stepsAvg = totalSteps / 7.0;
    float caloriesAvg = totalCalories / 7.0;

    printf("\nWeekly Averages:\n");
    printf("Weight: %.2f kg\n", weightAvg);
    printf("Steps: %.2f\n", stepsAvg);
    printf("Calories Burned: %.2f\n", caloriesAvg);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v7[22]; // [rsp+30h] [rbp-80h] BYREF
  float v8; // [rsp+88h] [rbp-28h]
  float v9; // [rsp+8Ch] [rbp-24h]
  float v10; // [rsp+90h] [rbp-20h]
  float v11; // [rsp+94h] [rbp-1Ch]
  int j; // [rsp+98h] [rbp-18h]
  float v13; // [rsp+9Ch] [rbp-14h]
  float v14; // [rsp+A0h] [rbp-10h]
  float v15; // [rsp+A4h] [rbp-Ch]
  int i; // [rsp+A8h] [rbp-8h]
  unsigned int v17; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v17 = 1;
  v3 = time(0i64);
  srand(v3);
  while ( (int)v17 <= 7 )
  {
    printf("\nDay %d\n", v17);
    printf("Enter your weight for the day (kg): ");
    scanf("%f", &v7[3 * (v17 - 1)]);
    printf("Enter the steps taken for the day: ");
    scanf("%d", &v7[3 * (v17 - 1) + 1]);
    v4 = (double)SLODWORD(v7[3 * (v17 - 1) + 1]) / 20.0;
    v8 = v4;
    v5 = v4 * ((double)(rand() % 30 + 70) / 100.0);
    v8 = v5;
    v7[3 * (v17++ - 1) + 2] = v5;
  }
  printf("\nWeek's Data:\n");
  printf("Day | Weight | Steps | Calories Burned\n");
  for ( i = 0; i <= 6; ++i )
    printf("%d | %.2f | %d | %.2f\n", (unsigned int)(i + 1), v7[3 * i], v7[3 * i + 1], v7[3 * i + 2]);
  v15 = 0.0;
  v14 = 0.0;
  v13 = 0.0;
  for ( j = 0; j <= 6; ++j )
  {
    v15 = v7[3 * j] + v15;
    v14 = (float)SLODWORD(v7[3 * j + 1]) + v14;
    v13 = v7[3 * j + 2] + v13;
  }
  v11 = v15 / 7.0;
  v10 = v14 / 7.0;
  v9 = v13 / 7.0;
  printf("\nWeekly Averages:\n");
  printf("Weight: %.2f kg\n", v11);
  printf("Steps: %.2f\n", v10);
  printf("Calories Burned: %.2f\n", v9);
  return 0;
}
// 140001AB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001601: using guessed type float var_80[22];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Light Controller ; Style: rigorous
#include <stdio.h>

//function to switch lights and print the current state
void switchLights(int redTime, int greenTime, int yellowTime, int initialLight){
    int counter = 0; 
    int lightIndex = initialLight;
    while(counter < 10){
        switch(lightIndex){
            case 0:
                printf("Light is Green\n");
                counter += greenTime;
                break;
            case 1:
                printf("Light is Yellow\n");
                counter += yellowTime;
                break;
            case 2:
                printf("Light is Red\n");
                counter += redTime;
        }
        lightIndex = (lightIndex + 1) % 3;
    }
}

//main function
int main(){
    //initialize variables
    int redTime = 5;
    int greenTime = 10;
    int yellowTime = 2;
    int initialLight = 0;

    //call switchLights function 
    switchLights(redTime, greenTime, yellowTime, initialLight);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall switchLights(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001654) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  switchLights(5i64, 10i64, 2i64, 0i64, 0x200000000i64, 0x50000000Ai64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall switchLights(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140001760: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Binary Converter ; Style: Claude Shannon
#include <stdio.h>
#include <math.h>

// Function to convert decimal to binary
long long decimalToBinary(int decimalNumber)
{
    int remainder;
    long long binaryNumber = 0, i = 1;

    while (decimalNumber != 0)
    {
        remainder = decimalNumber % 2;
        decimalNumber /= 2;
        binaryNumber += remainder * i;
        i *= 10;
    }

    return binaryNumber;
}

// Function to convert binary to decimal
int binaryToDecimal(long long binaryNumber)
{
    int decimalNumber = 0, i = 0, remainder;

    while (binaryNumber != 0)
    {
        remainder = binaryNumber % 10;
        binaryNumber /= 10;
        decimalNumber += remainder * pow(2, i);
        ++i;
    }

    return decimalNumber;
}

int main()
{
    int choice, decimalNumber;
    long long binaryNumber;

    do
    {
        printf("Binary Converter Menu\n");
        printf("1. Convert decimal to binary\n");
        printf("2. Convert binary to decimal\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
            case 1:
                printf("Enter a decimal number: ");
                scanf("%d", &decimalNumber);
                binaryNumber = decimalToBinary(decimalNumber);
                printf("Binary number: %lld\n", binaryNumber);
                break;

            case 2:
                printf("Enter a binary number: ");
                scanf("%lld", &binaryNumber);
                decimalNumber = binaryToDecimal(binaryNumber);
                printf("Decimal number: %d\n", decimalNumber);
                break;

            case 3:
                printf("Exiting the program\n");
                break;

            default:
                printf("Invalid choice\n");
        }
    } while (choice != 3);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall decimalToBinary(_QWORD); // weak
__int64 __fastcall binaryToDecimal(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000173D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v5; // [rsp+28h] [rbp-8h] BYREF
  int v6; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("Binary Converter Menu\n");
    printf("1. Convert decimal to binary\n");
    printf("2. Convert binary to decimal\n");
    printf("3. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &v6);
    if ( v6 == 3 )
    {
      printf("Exiting the program\n");
    }
    else
    {
      if ( v6 > 3 )
        goto LABEL_10;
      if ( v6 == 1 )
      {
        printf("Enter a decimal number: ");
        scanf("%d", &v5);
        v4 = decimalToBinary(v5);
        printf("Binary number: %lld\n", v4);
        continue;
      }
      if ( v6 == 2 )
      {
        printf("Enter a binary number: ");
        scanf("%lld", &v4);
        v5 = binaryToDecimal(v4);
        printf("Decimal number: %d\n", v5);
      }
      else
      {
LABEL_10:
        printf("Invalid choice\n");
      }
    }
  }
  while ( v6 != 3 );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall decimalToBinary(_QWORD);
// 140001652: using guessed type __int64 __fastcall binaryToDecimal(_QWORD);
// 140001950: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    char answers[10][50] = {"Yes", "No", "Maybe", "It is uncertain", "Try again later", "Outlook not so good", "Ask again", "The future looks bright", "Cannot predict now", "Signs point to yes"};
    char question[100];

    printf("Welcome to the Automated Fortune Teller.\n");
    printf("Enter your question:\n");

    fgets(question, 100, stdin);
    printf("Thinking...\n");

    srand(time(NULL));
    int index = rand() % 10;

    printf("The answer to your question \"%s\" is: %s\n", question, answers[index]);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v4; // eax
  char Buffer[112]; // [rsp+20h] [rbp-60h] BYREF
  char v7[508]; // [rsp+90h] [rbp+10h] BYREF
  int v8; // [rsp+28Ch] [rbp+20Ch]

  _main(argc, argv, envp);
  qmemcpy(v7, &unk_14000A020, 0x1F4ui64);
  printf("Welcome to the Automated Fortune Teller.\n");
  printf("Enter your question:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  printf("Thinking...\n");
  v4 = time(0i64);
  srand(v4);
  v8 = rand() % 10;
  printf("The answer to your question \"%s\" is: %s\n", Buffer, &v7[50 * v8]);
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type char var_210[508];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital signal processing ; Style: active
#include<stdio.h>
#include<stdlib.h>
#include<math.h>

#define BLOCK_SIZE 32

int main()
{
    int input_samples[BLOCK_SIZE], output_samples[BLOCK_SIZE];
    float coefficients[BLOCK_SIZE], sum;
    int i, j;
    
    //initialize input_samples and coefficients
    for(i = 0; i < BLOCK_SIZE; i++){
        input_samples[i] = i+1;
        coefficients[i] = sin(i * M_PI / BLOCK_SIZE);
    }
    
    //perform convolution
    for(i = 0; i < BLOCK_SIZE; i++){
        sum = 0;
        for(j = 0; j <= i; j++){
            sum += input_samples[j] * coefficients[i-j];
        }
        output_samples[i] = (int)sum;
    }
    
    //print output
    printf("Output samples:\n");
    for(i = 0; i < BLOCK_SIZE; i++){
        printf("%d ", output_samples[i]);
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sin(double X);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // xmm0_4
  int v5[97]; // [rsp+20h] [rbp-60h]
  int j; // [rsp+1A4h] [rbp+124h]
  int i; // [rsp+1A8h] [rbp+128h]
  float v8; // [rsp+1ACh] [rbp+12Ch]

  _main(argc, argv, envp);
  for ( i = 0; i <= 31; ++i )
  {
    v5[i + 64] = i + 1;
    *(float *)&v3 = sin(3.141592653589793 * (double)i / 32.0);
    v5[i] = v3;
  }
  for ( i = 0; i <= 31; ++i )
  {
    v8 = 0.0;
    for ( j = 0; j <= i; ++j )
      v8 = (float)(*(float *)&v5[i - j] * (float)v5[j + 64]) + v8;
    v5[i + 32] = (int)v8;
  }
  printf("Output samples:\n");
  for ( i = 0; i <= 31; ++i )
    printf("%d ", (unsigned int)v5[i + 32]);
  return 0;
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific Calculator Implementation ; Style: curious
#include<stdio.h>
#include<math.h>

int main(){
    // Welcome Message
    printf("Welcome to the curious Scientific Calculator Program!\n");

    // User Input - Number 1
    printf("Enter your first number:\n");
    double num1;
    scanf("%lf", &num1);

    // User Input - Number 2
    printf("Enter your second number:\n");
    double num2;
    scanf("%lf", &num2);

    // User Input - Operation
    printf("Enter the operation you want to perform. Here are your options:\n");
    printf("+    - Addition\n");
    printf("-    - Subtraction\n");
    printf("*    - Multiplication\n");
    printf("/    - Division\n");
    printf("sin  - Sine\n");
    printf("cos  - Cosine\n");
    printf("tan  - Tangent\n");
    printf("log  - Logarithm with base 10\n");
    printf("ln   - Natural Logarithm\n");
    printf("pow  - Exponentiation\n");
    printf("sqrt - Square Root\n");
    printf("Enter the operation here:\n");

    char operation[10];
    scanf("%s", operation);

    // Calculation and Result
    if(strcmp(operation, "+") == 0){
        double result = num1 + num2;
        printf("%.2lf + %.2lf = %.2lf", num1, num2, result);
    } else if(strcmp(operation, "-") == 0){
        double result = num1 - num2;
        printf("%.2lf - %.2lf = %.2lf", num1, num2, result);
    } else if(strcmp(operation, "*") == 0){
        double result = num1 * num2;
        printf("%.2lf x %.2lf = %.2lf", num1, num2, result);
    } else if(strcmp(operation, "/") == 0){
        if(num2 == 0){
            printf("Undefined");
        } else {
            double result = num1 / num2;
            printf("%.2lf / %.2lf = %.2lf", num1, num2, result);
        }
    } else if(strcmp(operation, "sin") == 0){
        double result = sin(num1);
        printf("sin(%.2lf) = %.2lf", num1, result);
    } else if(strcmp(operation, "cos") == 0){
        double result = cos(num1);
        printf("cos(%.2lf) = %.2lf", num1, result);
    } else if(strcmp(operation, "tan") == 0){
        double result = tan(num1);
        printf("tan(%.2lf) = %.2lf", num1, result);
    } else if(strcmp(operation, "log") == 0){
        double result = log10(num1);
        printf("log(%.2lf) = %.2lf", num1, result);
    } else if(strcmp(operation, "ln") == 0){
        double result = log(num1);
        printf("ln(%.2lf) = %.2lf", num1, result);
    } else if(strcmp(operation, "pow") == 0){
        double result = pow(num1, num2);
        printf("%.2lf to the power of %.2lf = %.2lf", num1, num2, result);
    } else if(strcmp(operation, "sqrt") == 0){
        if(num1 < 0){
            printf("Undefined");
        } else {
            double result = sqrt(num1);
            printf("Square Root of %.2lf = %.2lf", num1, result);
        }
    } else{
        printf("Invalid Input");
    }

    // Thank You Message
    printf("\nThank you for using the curious Scientific Calculator Program!");

    // Program End
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl cos(double X);
double __cdecl log(double X);
double __cdecl pow(double X, double Y);
double __cdecl sin(double X);
// double __cdecl tan(double X);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// double __cdecl log10(double X);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str1[10]; // [rsp+2Eh] [rbp-72h] BYREF
  double Y; // [rsp+38h] [rbp-68h] BYREF
  double X[5]; // [rsp+40h] [rbp-60h] BYREF
  double v7; // [rsp+68h] [rbp-38h]
  double v8; // [rsp+70h] [rbp-30h]
  double v9; // [rsp+78h] [rbp-28h]
  double v10; // [rsp+80h] [rbp-20h]
  double v11; // [rsp+88h] [rbp-18h]
  double v12; // [rsp+90h] [rbp-10h]
  double v13; // [rsp+98h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Welcome to the curious Scientific Calculator Program!\n");
  printf("Enter your first number:\n");
  scanf("%lf", X);
  printf("Enter your second number:\n");
  scanf("%lf", &Y);
  printf("Enter the operation you want to perform. Here are your options:\n");
  printf("+    - Addition\n");
  printf("-    - Subtraction\n");
  printf("*    - Multiplication\n");
  printf("/    - Division\n");
  printf("sin  - Sine\n");
  printf("cos  - Cosine\n");
  printf("tan  - Tangent\n");
  printf("log  - Logarithm with base 10\n");
  printf("ln   - Natural Logarithm\n");
  printf("pow  - Exponentiation\n");
  printf("sqrt - Square Root\n");
  printf("Enter the operation here:\n");
  scanf("%s", Str1);
  if ( !strcmp(Str1, "+") )
  {
    X[1] = Y + X[0];
    printf("%.2lf + %.2lf = %.2lf", X[0], Y, Y + X[0]);
  }
  else if ( !strcmp(Str1, "-") )
  {
    X[2] = X[0] - Y;
    printf("%.2lf - %.2lf = %.2lf", X[0], Y, X[0] - Y);
  }
  else if ( !strcmp(Str1, "*") )
  {
    X[3] = Y * X[0];
    printf("%.2lf x %.2lf = %.2lf", X[0], Y, Y * X[0]);
  }
  else
  {
    if ( !strcmp(Str1, "/") )
    {
      if ( Y != 0.0 )
      {
        X[4] = X[0] / Y;
        printf("%.2lf / %.2lf = %.2lf", X[0], Y, X[0] / Y);
        goto LABEL_27;
      }
    }
    else
    {
      if ( !strcmp(Str1, "sin") )
      {
        v7 = sin(X[0]);
        printf("sin(%.2lf) = %.2lf", X[0], v7);
        goto LABEL_27;
      }
      if ( !strcmp(Str1, "cos") )
      {
        v8 = cos(X[0]);
        printf("cos(%.2lf) = %.2lf", X[0], v8);
        goto LABEL_27;
      }
      if ( !strcmp(Str1, "tan") )
      {
        v9 = tan(X[0]);
        printf("tan(%.2lf) = %.2lf", X[0], v9);
        goto LABEL_27;
      }
      if ( !strcmp(Str1, "log") )
      {
        v10 = log10(X[0]);
        printf("log(%.2lf) = %.2lf", X[0], v10);
        goto LABEL_27;
      }
      if ( !strcmp(Str1, "ln") )
      {
        v11 = log(X[0]);
        printf("ln(%.2lf) = %.2lf", X[0], v11);
        goto LABEL_27;
      }
      if ( !strcmp(Str1, "pow") )
      {
        v12 = pow(X[0], Y);
        printf("%.2lf to the power of %.2lf = %.2lf", X[0], Y, v12);
        goto LABEL_27;
      }
      if ( strcmp(Str1, "sqrt") )
      {
        printf("Invalid Input");
        goto LABEL_27;
      }
      if ( X[0] >= 0.0 )
      {
        v13 = sqrt(X[0]);
        printf("Square Root of %.2lf = %.2lf", X[0], v13);
        goto LABEL_27;
      }
    }
    printf("Undefined");
  }
LABEL_27:
  printf("\nThank you for using the curious Scientific Calculator Program!");
  return 0;
}
// 140001D30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=191 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to generate random number between min and max
int getRandomNumber(int min, int max) {
    return (rand() % (max - min + 1)) + min;
}

int main() {
    srand(time(NULL)); // Seed for generating random values
    int no_of_lanes, no_of_cars, simulation_time, i, j, total_cars_passed;

    printf("Enter the number of lanes: ");
    scanf("%d", &no_of_lanes);

    printf("Enter the number of cars in each lane: ");
    scanf("%d", &no_of_cars);

    int car_positions[no_of_lanes][no_of_cars+1]; // +1 for car waiting at traffic light
    int speeds[no_of_lanes][no_of_cars];

    // Initializing the car positions and speeds randomly
    for (i = 0; i < no_of_lanes; i++) {
        for (j = 0; j < no_of_cars; j++) {
            car_positions[i][j] = getRandomNumber(10, 1000);
            speeds[i][j] = getRandomNumber(10, 80);
        }
        car_positions[i][j] = 0; // Waiting at traffic light
    }

    printf("Enter the simulation time: ");
    scanf("%d", &simulation_time);

    // Simulation loop
    for (i = 0; i < simulation_time; i++) {

        // Traffic light timings (randomly generated between 2 and 5 seconds)
        int green_light_duration = getRandomNumber(2, 5);
        int red_light_duration = getRandomNumber(2, 5);

        // Car movement during green light
        for (int lane = 0; lane < no_of_lanes; lane++) {
            for (int car = 0; car < no_of_cars; car++) {
                if (car_positions[lane][car] < 500) {
                    car_positions[lane][car] += speeds[lane][car];
                }
                else {
                    // Car has passed the traffic light and is removed from the lane
                    car_positions[lane][car] = -1;
                }
            }
        }

        // Cars waiting at traffic light
        for (int lane = 0; lane < no_of_lanes; lane++) {
            if (car_positions[lane][no_of_cars] > 0) {
                car_positions[lane][no_of_cars] -= 1;
            }
            else if (car_positions[lane][no_of_cars] == 0) {
                car_positions[lane][no_of_cars] = -1; // Car has passed the traffic light
            }
        }

        // Counting number of cars that have passed the traffic light
        total_cars_passed = 0;
        for (int lane = 0; lane < no_of_lanes; lane++) {
            for (int car = 0; car < no_of_cars+1; car++) {
                if (car_positions[lane][car] == -1) {
                    total_cars_passed++;
                }
            }
        }

        // Printing the current state of the simulation
        printf("\nSimulation time: %d seconds\n", i);
        printf("Green light duration: %d seconds\n", green_light_duration);
        printf("Red light duration: %d seconds\n", red_light_duration);
        printf("Total cars passed: %d\n", total_cars_passed);
        printf("Current positions:\n");
        for (int lane = 0; lane < no_of_lanes; lane++) {
            printf("Lane %d: ", lane+1);
            for (int car = 0; car < no_of_cars+1; car++) {
                printf("%d ", car_positions[lane][car]);
            }
            printf("\n");
        }

        // Sleep for red light duration
        sleep(red_light_duration);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall getRandomNumber(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (000000014000162B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned __int64 v4; // rdi
  void *v5; // rsp
  unsigned __int64 v6; // rbx
  void *v7; // rsp
  __int64 v9; // [rsp+0h] [rbp-80h] BYREF
  char v10; // [rsp+20h] [rbp-60h] BYREF
  __int64 *v11; // [rsp+28h] [rbp-58h]
  __int64 v12; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  __int64 v14; // [rsp+40h] [rbp-40h]
  __int64 v15; // [rsp+48h] [rbp-38h]
  __int64 v16; // [rsp+50h] [rbp-30h]
  __int64 v17; // [rsp+58h] [rbp-28h]
  __int64 v18; // [rsp+60h] [rbp-20h]
  __int64 v19; // [rsp+68h] [rbp-18h]
  __int64 v20; // [rsp+70h] [rbp-10h]
  __int64 v21; // [rsp+78h] [rbp-8h]
  __int64 v22; // [rsp+80h] [rbp+0h]
  __int64 v23; // [rsp+88h] [rbp+8h]
  __int64 v24; // [rsp+90h] [rbp+10h]
  __int64 v25; // [rsp+98h] [rbp+18h]
  int v26; // [rsp+A4h] [rbp+24h] BYREF
  int v27; // [rsp+A8h] [rbp+28h] BYREF
  int v28; // [rsp+ACh] [rbp+2Ch] BYREF
  unsigned int v29; // [rsp+B0h] [rbp+30h]
  unsigned int RandomNumber; // [rsp+B4h] [rbp+34h]
  char *v31; // [rsp+B8h] [rbp+38h]
  __int64 v32; // [rsp+C0h] [rbp+40h]
  __int64 v33; // [rsp+C8h] [rbp+48h]
  char *v34; // [rsp+D0h] [rbp+50h]
  __int64 v35; // [rsp+D8h] [rbp+58h]
  __int64 v36; // [rsp+E0h] [rbp+60h]
  int mm; // [rsp+E8h] [rbp+68h]
  int kk; // [rsp+ECh] [rbp+6Ch]
  int jj; // [rsp+F0h] [rbp+70h]
  int ii; // [rsp+F4h] [rbp+74h]
  int n; // [rsp+F8h] [rbp+78h]
  int m; // [rsp+FCh] [rbp+7Ch]
  int k; // [rsp+100h] [rbp+80h]
  unsigned int v44; // [rsp+104h] [rbp+84h]
  int j; // [rsp+108h] [rbp+88h]
  int i; // [rsp+10Ch] [rbp+8Ch]

  _main(argc, argv, envp);
  v11 = &v9;
  v3 = time(0i64);
  srand(v3);
  printf("Enter the number of lanes: ");
  scanf("%d", &v28);
  printf("Enter the number of cars in each lane: ");
  scanf("%d", &v27);
  v36 = v27 + 1 - 1i64;
  v14 = v27 + 1;
  v15 = 0i64;
  v4 = 4 * v14;
  v35 = v28 - 1i64;
  v24 = v14;
  v25 = 0i64;
  v5 = alloca(16 * ((unsigned __int64)(4 * v14 * v28 + 15) >> 4));
  v34 = &v10;
  v33 = v27 - 1i64;
  v12 = v27;
  v13 = 0i64;
  v6 = 4i64 * v27;
  v32 = v35;
  v22 = v27;
  v23 = 0i64;
  v20 = v28;
  v21 = 0i64;
  v18 = v27;
  v19 = 0i64;
  v16 = v28;
  v17 = 0i64;
  v7 = alloca(16 * ((unsigned __int64)(4 * v27 * (__int64)v28 + 15) >> 4));
  v31 = &v10;
  for ( i = 0; i < v28; ++i )
  {
    for ( j = 0; j < v27; ++j )
    {
      *(_DWORD *)&v34[4 * j + 4 * (v4 >> 2) * i] = getRandomNumber(10i64, 1000i64);
      *(_DWORD *)&v31[4 * j + 4 * (v6 >> 2) * i] = getRandomNumber(10i64, 80i64);
    }
    *(_DWORD *)&v34[4 * j + 4 * (v4 >> 2) * i] = 0;
  }
  printf("Enter the simulation time: ");
  scanf("%d", &v26);
  for ( i = 0; i < v26; ++i )
  {
    RandomNumber = getRandomNumber(2i64, 5i64);
    v29 = getRandomNumber(2i64, 5i64);
    for ( k = 0; k < v28; ++k )
    {
      for ( m = 0; m < v27; ++m )
      {
        if ( *(int *)&v34[4 * m + 4 * (v4 >> 2) * k] > 499 )
          *(_DWORD *)&v34[4 * m + 4 * (v4 >> 2) * k] = -1;
        else
          *(_DWORD *)&v34[4 * m + 4 * (v4 >> 2) * k] += *(_DWORD *)&v31[4 * m + 4 * (v6 >> 2) * k];
      }
    }
    for ( n = 0; n < v28; ++n )
    {
      if ( *(int *)&v34[4 * v27 + 4 * (v4 >> 2) * n] <= 0 )
      {
        if ( !*(_DWORD *)&v34[4 * v27 + 4 * (v4 >> 2) * n] )
          *(_DWORD *)&v34[4 * v27 + 4 * (v4 >> 2) * n] = -1;
      }
      else
      {
        --*(_DWORD *)&v34[4 * v27 + 4 * (v4 >> 2) * n];
      }
    }
    v44 = 0;
    for ( ii = 0; ii < v28; ++ii )
    {
      for ( jj = 0; jj <= v27; ++jj )
      {
        if ( *(_DWORD *)&v34[4 * jj + 4 * (v4 >> 2) * ii] == -1 )
          ++v44;
      }
    }
    printf("\nSimulation time: %d seconds\n", (unsigned int)i);
    printf("Green light duration: %d seconds\n", RandomNumber);
    printf("Red light duration: %d seconds\n", v29);
    printf("Total cars passed: %d\n", v44);
    printf("Current positions:\n");
    for ( kk = 0; kk < v28; ++kk )
    {
      printf("Lane %d: ", (unsigned int)(kk + 1));
      for ( mm = 0; mm <= v27; ++mm )
        printf("%d ", *(unsigned int *)&v34[4 * mm + 4 * (v4 >> 2) * kk]);
      printf("\n");
    }
    sleep(v29);
  }
  return 0;
}
// 140001601: using guessed type __int64 __fastcall getRandomNumber(_QWORD, _QWORD);
// 140001DE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002E40: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Auction System ; Style: energetic
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

struct product{

char name[50];
int id;
int price;

};

void print_product(struct product p){

printf("Product ID: %d\n",p.id);
printf("Product Name: %s\n",p.name);
printf("Product Price: %d\n\n",p.price);

}

int main(){

srand(time(NULL));

struct product products[5];

strcpy(products[0].name,"Laptop");
strcpy(products[1].name,"Mobile Phone");
strcpy(products[2].name,"Television");
strcpy(products[3].name,"Digital Camera");
strcpy(products[4].name,"Headphones");

for(int i=0;i<5;i++){

products[i].id=i+1;
products[i].price=rand()%1000;

print_product(products[i]);

}


int max_bid=0;
int max_bid_index=-1;
int total_bids=0;

while(max_bid_index==-1){

int bid=-1;

while(bid==-1){

printf("Enter your bid: ");
scanf("%d",&bid);

if(bid<=max_bid){
    printf("You must bid a higher amount than the current highest bid of %d\n",max_bid);
    bid=-1;
}
else{
    max_bid=bid;
    max_bid_index=rand()%5;
    printf("You are currently the highest bidder on: "); 
    print_product(products[max_bid_index]);
    printf("Your bid: %d\n\n",max_bid);
    total_bids++;
}

}

}

printf("Auction over!\nTotal bids: %d\n",total_bids);
printf("Highest bidder on product no. %d: \n",products[max_bid_index].id);
print_product(products[max_bid_index]);

return 0;

}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall print_product(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001651) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  _BYTE *v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rbx
  _BYTE *v8; // rax
  __int64 v9; // rbx
  __int64 v10; // rbx
  __int64 v11; // rbx
  _BYTE *v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rbx
  __int64 v15; // rbx
  __int64 v17; // [rsp+20h] [rbp-60h] BYREF
  __int64 v18; // [rsp+28h] [rbp-58h]
  __int64 v19; // [rsp+30h] [rbp-50h]
  __int64 v20; // [rsp+38h] [rbp-48h]
  __int64 v21; // [rsp+40h] [rbp-40h]
  __int64 v22; // [rsp+48h] [rbp-38h]
  __int64 v23; // [rsp+50h] [rbp-30h]
  int v24; // [rsp+58h] [rbp-28h]
  int v25; // [rsp+6Ch] [rbp-14h] BYREF
  char v26[8]; // [rsp+70h] [rbp-10h] BYREF
  _BYTE v27[44]; // [rsp+80h] [rbp+0h] BYREF
  char v28[16]; // [rsp+ACh] [rbp+2Ch] BYREF
  char v29[16]; // [rsp+E8h] [rbp+68h] BYREF
  char v30[16]; // [rsp+124h] [rbp+A4h] BYREF
  char v31[16]; // [rsp+160h] [rbp+E0h] BYREF
  unsigned int v32; // [rsp+1A0h] [rbp+120h]
  int v33; // [rsp+1A4h] [rbp+124h]
  unsigned int v34; // [rsp+1A8h] [rbp+128h]
  int i; // [rsp+1ACh] [rbp+12Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  strcpy(v26, "Laptop");
  strcpy(v28, "Mobile Phone");
  strcpy(v29, "Television");
  strcpy(v30, "Digital Camera");
  strcpy(v31, "Headphones");
  for ( i = 0; i <= 4; ++i )
  {
    *(_DWORD *)&v27[60 * i + 36] = i + 1;
    *(_DWORD *)&v27[60 * i + 40] = rand() % 1000;
    v4 = &v27[60 * i - 16];
    v5 = *((_QWORD *)v4 + 1);
    v17 = *(_QWORD *)v4;
    v18 = v5;
    v6 = *((_QWORD *)v4 + 3);
    v19 = *((_QWORD *)v4 + 2);
    v20 = v6;
    v7 = *((_QWORD *)v4 + 5);
    v21 = *((_QWORD *)v4 + 4);
    v22 = v7;
    v23 = *((_QWORD *)v4 + 6);
    v24 = *((_DWORD *)v4 + 14);
    print_product(&v17);
  }
  v34 = 0;
  v33 = -1;
  v32 = 0;
  while ( v33 == -1 )
  {
    v25 = -1;
    while ( v25 == -1 )
    {
      printf("Enter your bid: ");
      scanf("%d", &v25);
      if ( (int)v34 < v25 )
      {
        v34 = v25;
        v33 = rand() % 5;
        printf("You are currently the highest bidder on: ");
        v8 = &v27[60 * v33 - 16];
        v9 = *((_QWORD *)v8 + 1);
        v17 = *(_QWORD *)v8;
        v18 = v9;
        v10 = *((_QWORD *)v8 + 3);
        v19 = *((_QWORD *)v8 + 2);
        v20 = v10;
        v11 = *((_QWORD *)v8 + 5);
        v21 = *((_QWORD *)v8 + 4);
        v22 = v11;
        v23 = *((_QWORD *)v8 + 6);
        v24 = *((_DWORD *)v8 + 14);
        print_product(&v17);
        printf("Your bid: %d\n\n", v34);
        ++v32;
      }
      else
      {
        printf("You must bid a higher amount than the current highest bid of %d\n", v34);
        v25 = -1;
      }
    }
  }
  printf("Auction over!\nTotal bids: %d\n", v32);
  printf("Highest bidder on product no. %d: \n", *(unsigned int *)&v27[60 * v33 + 36]);
  v12 = &v27[60 * v33 - 16];
  v13 = *((_QWORD *)v12 + 1);
  v17 = *(_QWORD *)v12;
  v18 = v13;
  v14 = *((_QWORD *)v12 + 3);
  v19 = *((_QWORD *)v12 + 2);
  v20 = v14;
  v15 = *((_QWORD *)v12 + 5);
  v21 = *((_QWORD *)v12 + 4);
  v22 = v15;
  v23 = *((_QWORD *)v12 + 6);
  v24 = *((_DWORD *)v12 + 14);
  print_product(&v17);
  return 0;
}
// 140001601: using guessed type __int64 __fastcall print_product(_QWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: irregular
#include <stdio.h>

// Function prototypes
void printFibonacci(int n);

int main() {
    int n;

    // Get input from user
    printf("Enter the number of terms for the Fibonacci sequence: ");
    scanf("%d", &n);

    // Print the sequence
    printFibonacci(n);

    return 0;
}

// Function to print the Fibonacci sequence
void printFibonacci(int n) {
    int a = 0, b = 1, c, i;

    // Print the first two terms of the sequence
    printf("%d %d ", a, b);

    // Print the rest of the terms in the sequence
    for(i = 2; i < n; i++) {
        c = a + b;
        a = b;
        b = c;

        // Print the term with some visual flair
        if(c % 3 == 0 && c % 5 == 0) {
            printf("*%d* ", c);
        }
        else if(c % 3 == 0) {
            printf("+%d+ ", c);
        }
        else if(c % 5 == 0) {
            printf("#%d# ", c);
        }
        else {
            printf("%d ", c);
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall printFibonacci(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the number of terms for the Fibonacci sequence: ");
  scanf("%d", &v4);
  printFibonacci(v4);
  return 0;
}
// 140001629: using guessed type __int64 __fastcall printFibonacci(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Encryption ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_MSG_LEN 50

/* Function that encrypts the message using a simple substitution cypher */
void encrypt(char msg[], int key) {
   int i;
   char ch;

   for(i = 0; msg[i] != '\0'; ++i) {
      ch = msg[i];

      if(ch >= 'a' && ch <= 'z') {
         ch = ch + key;

         if(ch > 'z') {
            ch = ch - 'z' + 'a' - 1;
         }

         msg[i] = ch;
      }
      else if(ch >= 'A' && ch <= 'Z') {
         ch = ch + key;

         if(ch > 'Z') {
            ch = ch - 'Z' + 'A' - 1;
         }

         msg[i] = ch;
      }
   }
}

/* Function that decrypts the message using the same key as the encryption */
void decrypt(char msg[], int key) {
   int i;
   char ch;

   for(i = 0; msg[i] != '\0'; ++i) {
      ch = msg[i];

      if(ch >= 'a' && ch <= 'z') {
         ch = ch - key;

         if(ch < 'a') {
            ch = ch + 'z' - 'a' + 1;
         }

         msg[i] = ch;
      }
      else if(ch >= 'A' && ch <= 'Z') {
         ch = ch - key;

         if(ch < 'A') {
            ch = ch + 'Z' - 'A' + 1;
         }

         msg[i] = ch;
      }
   }
}

/* Main function that demonstrates the encryption and decryption */
int main() {
   char msg[MAX_MSG_LEN];
   int key;

   // Get input from user
   printf("Enter message to be encrypted: ");
   fgets(msg, MAX_MSG_LEN, stdin);
   printf("Enter key: ");
   scanf("%d", &key);

   // Remove newline character from message input
   msg[strcspn(msg, "\n")] = '\0';

   // Encrypt message and print result
   encrypt(msg, key);
   printf("Encrypted message: %s\n", msg);

   // Decrypt message using the same key and print result
   decrypt(msg, key);
   printf("Decrypted message: %s\n", msg);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
__int64 __fastcall decrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000177A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v5; // [rsp+2Ch] [rbp-44h] BYREF
  char Buffer[64]; // [rsp+30h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  printf("Enter message to be encrypted: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 50, v3);
  printf("Enter key: ");
  scanf("%d", &v5);
  Buffer[strcspn(Buffer, "\n")] = 0;
  encrypt(Buffer, v5);
  printf("Encrypted message: %s\n", Buffer);
  decrypt(Buffer, v5);
  printf("Decrypted message: %s\n", Buffer);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 1400016B0: using guessed type __int64 __fastcall decrypt(_QWORD, _QWORD);
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000177A: using guessed type char Buffer[64];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Scientific Calculator Implementation ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main()
{
    float num1, num2, result;
    int choice;

    printf("Welcome to Scientific Calculator!\n");

    do {
        printf("\n");
        printf("Please select an operation to perform: \n");
        printf("1. Addition\n");
        printf("2. Subtraction\n");
        printf("3. Multiplication\n");
        printf("4. Division\n");
        printf("5. Exponentiation\n");
        printf("6. Square root\n");
        printf("7. Logarithm\n");
        printf("8. Exit\n\n");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the first number: ");
                scanf("%f", &num1);
                printf("Enter the second number: ");
                scanf("%f", &num2);
                result = num1 + num2;
                printf("Result: %f \n", result);
                break;

            case 2:
                printf("Enter the first number: ");
                scanf("%f", &num1);
                printf("Enter the second number: ");
                scanf("%f", &num2);
                result = num1 - num2;
                printf("Result: %f \n", result);
                break;

            case 3:
                printf("Enter the first number: ");
                scanf("%f", &num1);
                printf("Enter the second number: ");
                scanf("%f", &num2);
                result = num1 * num2;
                printf("Result: %f \n", result);
                break;

            case 4:
                printf("Enter the first number: ");
                scanf("%f", &num1);
                printf("Enter the second number: ");
                scanf("%f", &num2);
                result = num1 / num2;
                printf("Result: %f \n", result);
                break;

            case 5:
                printf("Enter the base number: ");
                scanf("%f", &num1);
                printf("Enter the exponent number: ");
                scanf("%f", &num2);
                result = pow(num1, num2);
                printf("Result: %f \n", result);
                break;

            case 6:
                printf("Enter the number: ");
                scanf("%f", &num1);
                result = sqrt(num1);
                printf("Result: %f \n", result);
                break;

            case 7:
                printf("Enter the number: ");
                scanf("%f", &num1);
                result = log10(num1);
                printf("Result: %f \n", result);
                break;

            case 8:
                printf("Thank you for using Scientific Calculator!\n");
                exit(0);
                break;

            default:
                printf("Invalid input! Please select a valid operation.\n");
                break;
        }
    } while (choice != 8);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl pow(double X, double Y);
// double __cdecl log10(double X);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  float v5; // xmm0_4
  int v7; // [rsp+20h] [rbp-10h] BYREF
  float v8; // [rsp+24h] [rbp-Ch] BYREF
  float v9; // [rsp+28h] [rbp-8h] BYREF
  float v10; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to Scientific Calculator!\n");
  do
  {
    printf("\n");
    printf("Please select an operation to perform: \n");
    printf("1. Addition\n");
    printf("2. Subtraction\n");
    printf("3. Multiplication\n");
    printf("4. Division\n");
    printf("5. Exponentiation\n");
    printf("6. Square root\n");
    printf("7. Logarithm\n");
    printf("8. Exit\n\n");
    scanf("%d", &v7);
    switch ( v7 )
    {
      case 1:
        printf("Enter the first number: ");
        scanf("%f", &v9);
        printf("Enter the second number: ");
        scanf("%f", &v8);
        v10 = v8 + v9;
        printf("Result: %f \n", (float)(v8 + v9));
        break;
      case 2:
        printf("Enter the first number: ");
        scanf("%f", &v9);
        printf("Enter the second number: ");
        scanf("%f", &v8);
        v10 = v9 - v8;
        printf("Result: %f \n", (float)(v9 - v8));
        break;
      case 3:
        printf("Enter the first number: ");
        scanf("%f", &v9);
        printf("Enter the second number: ");
        scanf("%f", &v8);
        v10 = v8 * v9;
        printf("Result: %f \n", (float)(v8 * v9));
        break;
      case 4:
        printf("Enter the first number: ");
        scanf("%f", &v9);
        printf("Enter the second number: ");
        scanf("%f", &v8);
        v10 = v9 / v8;
        printf("Result: %f \n", (float)(v9 / v8));
        break;
      case 5:
        printf("Enter the base number: ");
        scanf("%f", &v9);
        printf("Enter the exponent number: ");
        scanf("%f", &v8);
        v3 = pow(v9, v8);
        v10 = v3;
        printf("Result: %f \n", v3);
        break;
      case 6:
        printf("Enter the number: ");
        scanf("%f", &v9);
        v4 = sqrt(v9);
        v10 = v4;
        printf("Result: %f \n", v4);
        break;
      case 7:
        printf("Enter the number: ");
        scanf("%f", &v9);
        v5 = log10(v9);
        v10 = v5;
        printf("Result: %f \n", v5);
        break;
      case 8:
        printf("Thank you for using Scientific Calculator!\n");
        exit(0);
      default:
        printf("Invalid input! Please select a valid operation.\n");
        break;
    }
  }
  while ( v7 != 8 );
  return 0;
}
// 140001BA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: random
#include <stdio.h>
#include <time.h>
#include <string.h>

struct diary {
    char date[20];
    char content[200];
};

int main() {
    struct diary entries[365];
    time_t currentTime;
    struct tm *localTime;
    char date[20];
    int i = 0;

    // Get current date
    time(&currentTime);
    localTime = localtime(&currentTime);
    strftime(date, sizeof(date), "%Y/%m/%d", localTime);

    // Initialize empty diary
    for (i = 0; i < 365; i++) {
        strcpy(entries[i].date, "");
        strcpy(entries[i].content, "");
    }

    // Main loop to interact with user
    while (1) {
        char option;
        printf("\nWelcome to your digital diary! Today is %s\n", date);
        printf("Enter an option:\n");
        printf("1 - Add a new entry\n");
        printf("2 - View all entries\n");
        printf("3 - Search for entries by date\n");
        printf("4 - Exit\n");
        scanf(" %c", &option);

        if (option == '1') {
            // Add a new entry
            char content[200];
            printf("Enter your thoughts for today: ");
            scanf(" %[^\n]s", content);
            strcpy(entries[i].date, date);
            strcpy(entries[i].content, content);
            i++;
            printf("Entry added.\n");
        } else if (option == '2') {
            // View all entries
            if (i == 0) {
                printf("No entries yet.\n");
            } else {
                printf("All entries:\n");
                for (int j = 0; j < i; j++) {
                    printf("Date: %s\n", entries[j].date);
                    printf("Content: %s\n", entries[j].content);
                }
            }
        } else if (option == '3') {
            // Search for entries by date
            char searchDate[20];
            printf("Enter the date you want to search for (YYYY/MM/DD): ");
            scanf(" %s", searchDate);
            int foundEntries = 0;
            for (int j = 0; j < i; j++) {
                if (strcmp(entries[j].date, searchDate) == 0) {
                    foundEntries++;
                    printf("Date: %s\n", entries[j].date);
                    printf("Content: %s\n", entries[j].content);
                }
            }
            if (foundEntries == 0) {
                printf("No entries found for that date.\n");
            }
        } else if (option == '4') {
            // Exit program
            printf("Goodbye!\n");
            break;
        } else {
            printf("Invalid option. Please try again.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static struct tm *__cdecl localtime(const time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strftime(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (0000000140001620) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Source[208]; // [rsp+20h] [rbp-60h] BYREF
  char Str2[31]; // [rsp+F0h] [rbp+70h] BYREF
  char v6; // [rsp+10Fh] [rbp+8Fh] BYREF
  char Buffer[24]; // [rsp+110h] [rbp+90h] BYREF
  time_t Time; // [rsp+128h] [rbp+A8h] BYREF
  char v9[80312]; // [rsp+130h] [rbp+B0h] BYREF
  struct tm *Tm; // [rsp+13AE8h] [rbp+13A68h]
  int k; // [rsp+13AF0h] [rbp+13A70h]
  int v12; // [rsp+13AF4h] [rbp+13A74h]
  int j; // [rsp+13AF8h] [rbp+13A78h]
  int i; // [rsp+13AFCh] [rbp+13A7Ch]

  _main(argc, argv, envp);
  i = 0;
  time(&Time);
  Tm = localtime(&Time);
  strftime(Buffer, 0x14ui64, "%Y/%m/%d", Tm);
  for ( i = 0; i <= 364; ++i )
  {
    v9[220 * i] = 0;
    v9[220 * i + 20] = 0;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          printf("\nWelcome to your digital diary! Today is %s\n", Buffer);
          printf("Enter an option:\n");
          printf("1 - Add a new entry\n");
          printf("2 - View all entries\n");
          printf("3 - Search for entries by date\n");
          printf("4 - Exit\n");
          scanf(" %c", &v6);
          if ( v6 != 49 )
            break;
          printf("Enter your thoughts for today: ");
          scanf(" %[^\n]s", Source);
          strcpy(&v9[220 * i], Buffer);
          strcpy(&v9[220 * i++ + 20], Source);
          printf("Entry added.\n");
        }
        if ( v6 != 50 )
          break;
        if ( i )
        {
          printf("All entries:\n");
          for ( j = 0; j < i; ++j )
          {
            printf("Date: %s\n", &v9[220 * j]);
            printf("Content: %s\n", &v9[220 * j + 20]);
          }
        }
        else
        {
          printf("No entries yet.\n");
        }
      }
      if ( v6 != 51 )
        break;
      printf("Enter the date you want to search for (YYYY/MM/DD): ");
      scanf(" %s", Str2);
      v12 = 0;
      for ( k = 0; k < i; ++k )
      {
        if ( !strcmp(&v9[220 * k], Str2) )
        {
          ++v12;
          printf("Date: %s\n", &v9[220 * k]);
          printf("Content: %s\n", &v9[220 * k + 20]);
        }
      }
      if ( !v12 )
        printf("No entries found for that date.\n");
    }
    if ( v6 == 52 )
      break;
    printf("Invalid option. Please try again.\n");
  }
  printf("Goodbye!\n");
  return 0;
}
// 140001AE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001620: using guessed type char var_139D0[80312];

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cryptography Implementation ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LENGTH 1024
#define MAX_KEY_LENGTH 16

void xor_encrypt(char* message, char* key) {
    int message_length = strlen(message);
    int key_length = strlen(key);
    int i;
    for(i = 0; i < message_length; i++) {
        message[i] ^= key[i % key_length];
    }
}

int main() {
    char message[MAX_LENGTH];
    char key[MAX_KEY_LENGTH];
    printf("Enter the message to be encrypted: ");
    fgets(message, MAX_LENGTH, stdin);
    printf("Enter the encryption key: ");
    fgets(key, MAX_KEY_LENGTH, stdin);
    xor_encrypt(message, key);
    printf("The encrypted message is: %s\n", message);
    xor_encrypt(message, key);
    printf("The decrypted message is: %s\n", message);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall xor_encrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001610) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  char v6[16]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[1024]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  printf("Enter the message to be encrypted: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1024, v3);
  printf("Enter the encryption key: ");
  v4 = __acrt_iob_func(0);
  fgets(v6, 16, v4);
  xor_encrypt(Buffer, v6);
  printf("The encrypted message is: %s\n", Buffer);
  xor_encrypt(Buffer, v6);
  printf("The decrypted message is: %s\n", Buffer);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall xor_encrypt(_QWORD, _QWORD);
// 1400017A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Sentiment analysis tool ; Style: imaginative
#include <stdio.h>
#include <string.h>

void main() {
    char text[1000];
    int positiveCount = 0, negativeCount = 0, neutralCount = 0;

    printf("Enter some text to analyze the sentiment: ");
    fgets(text, 1000, stdin);

    // Splitting words
    char *token = strtok(text, " ");

    while (token != NULL) {
        // Matching words with sentiment keywords
        if (strcmp(token, "good") == 0 || strcmp(token, "great") == 0 || strcmp(token, "excellent") == 0) {
            positiveCount++;
        } else if (strcmp(token, "bad") == 0 || strcmp(token, "poor") == 0 || strcmp(token, "terrible") == 0) {
            negativeCount++;
        } else {
            neutralCount++;
        }

        token = strtok(NULL, " ");
    }

    printf("Analysis Result:\n");
    printf("Positive Keywords count: %d\n", positiveCount);
    printf("Negative Keywords count: %d\n", negativeCount);
    printf("Neutral Keywords count: %d\n", neutralCount);

    if (positiveCount > negativeCount) {
        printf("Overall Sentiment: Positive");
    } else if (positiveCount < negativeCount) {
        printf("Overall Sentiment: Negative");
    } else {
        printf("Overall Sentiment: Neutral");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1000]; // [rsp+20h] [rbp-60h] BYREF
  char *Str1; // [rsp+408h] [rbp+388h]
  unsigned int v7; // [rsp+414h] [rbp+394h]
  int v8; // [rsp+418h] [rbp+398h]
  int v9; // [rsp+41Ch] [rbp+39Ch]

  _main(argc, argv, envp);
  v9 = 0;
  v8 = 0;
  v7 = 0;
  printf("Enter some text to analyze the sentiment: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  for ( Str1 = strtok(Buffer, " "); Str1; Str1 = strtok(0i64, " ") )
  {
    if ( !strcmp(Str1, "good") || !strcmp(Str1, "great") || !strcmp(Str1, "excellent") )
    {
      ++v9;
    }
    else if ( !strcmp(Str1, "bad") || !strcmp(Str1, "poor") || !strcmp(Str1, "terrible") )
    {
      ++v8;
    }
    else
    {
      ++v7;
    }
  }
  printf("Analysis Result:\n");
  printf("Positive Keywords count: %d\n", (unsigned int)v9);
  printf("Negative Keywords count: %d\n", (unsigned int)v8);
  printf("Neutral Keywords count: %d\n", v7);
  if ( v9 > v8 )
    return printf("Overall Sentiment: Positive");
  if ( v9 >= v8 )
    return printf("Overall Sentiment: Neutral");
  return printf("Overall Sentiment: Negative");
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <omp.h>

// Parameters
#define L 100   // Road length
#define V_MAX 5 // Maximum car speed
#define P 0.3   // Probability of a car being present
#define T 100   // Number of simulation time steps

// Global variables
int x[L];       // Road cells
int v[L];       // Car speeds
int t = 0;      // Simulation time
int total_cars = 0; // Total number of cars in the simulation

// Initializes the road with cars and empty spaces
void init_road() {
    srand(time(NULL));
    for(int i=0; i<L; i++) {
        if((double)rand()/(double)RAND_MAX < P) {
            x[i] = 1;
            total_cars++;
            v[i] = rand() % V_MAX + 1;
        } else {
            x[i] = 0;
            v[i] = 0;
        }
    }
}

// Prints the current state of the road
void print_road() {
    for(int i=0; i<L; i++) {
        if(x[i] == 0) {
            putchar('.');
        } else {
            putchar('*');
        }
    }
    putchar('\n');
}

// Advances the simulation by one time step
void advance() {
    // Acceleration
    #pragma omp parallel for
    for(int i=0; i<L; i++) {
        if(x[i] == 1 && v[i] < V_MAX) {
            v[i]++;
        }
    }

    // Deceleration
    #pragma omp parallel for
    for(int i=0; i<L; i++) {
        int d = 1;
        while(d <= v[i]) {
            if(x[(i + d) % L] != 0) {
                if(d - 1 < v[i]) {
                    v[i] = d - 1;
                }
                break;
            }
            d++;
        }
    }

    // Randomization
    #pragma omp parallel for
    for(int i=0; i<L; i++) {
        if(x[i] == 1 && v[i] > 0 && (double)rand()/(double)RAND_MAX < 0.5) {
            v[i]--;
        }
    }

    // Movement
    #pragma omp parallel for
    for(int i=0; i<L; i++) {
        if(x[i] == 1) {
            x[i] = 0;
            x[(i + v[i]) % L] = 1;
        }
    }

    t++; // Increase simulation time
}

int main() {
    init_road(); // Initialize road

    // Run simulation
    while(t < T) {
        printf("Time: %d\n", t);
        print_road();
        advance();
    }

    printf("Simulation complete\n");
    printf("Total number of cars: %d\n", total_cars);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 init_road(void); // weak
__int64 print_road(void); // weak
__int64 advance(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

int t; // weak
int total_cars; // weak


//----- (00000001400019C5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  init_road();
  while ( t <= 99 )
  {
    printf("Time: %d\n", (unsigned int)t);
    print_road();
    advance();
  }
  printf("Simulation complete\n");
  printf("Total number of cars: %d\n", (unsigned int)total_cars);
  return 0;
}
// 1400015B0: using guessed type __int64 init_road(void);
// 1400016B9: using guessed type __int64 print_road(void);
// 140001716: using guessed type __int64 advance(void);
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F370: using guessed type int t;
// 14000F374: using guessed type int total_cars;

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Math exercise ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_NUM 100     // the maximum number for the calculation
#define MAX_FACTOR 10   // the maximum factor for the multiplication
#define MAX_TIME 60     // the maximum time limit for the game

int main(void) {
    int score = 0;      // initialize the score as 0
    time_t start, end;  // variables for recording the time

    printf("Welcome to the Math Game!\n\n");

    printf("Rules: You will have %d seconds to answer as many multiplication questions as possible.\n", MAX_TIME);
    printf("       Each question will have a random factor between 1 and %d.\n", MAX_FACTOR);
    printf("       The result will be less than or equal to %d.\n", MAX_NUM);
    printf("       Type your answer and press Enter.\n");
    printf("       Each correct answer will earn you 1 point. No penalties for wrong answers.\n");
    printf("\nReady? Press Enter to start the game!");
    getchar();

    // start the game
    time(&start);   // record the start time
    while (difftime(time(NULL), start) < MAX_TIME) {    // keep playing until time's up
        // generate two random factors and ask the user to multiply them
        int factor1 = rand() % MAX_FACTOR + 1;
        int factor2 = rand() % MAX_FACTOR + 1;
        int expected = factor1 * factor2;
        printf("%d. What is %d x %d?  ", score + 1, factor1, factor2);

        // read the user's answer
        char input[10];
        fgets(input, 10, stdin);
        int answer = atoi(input);

        // check the answer and update the score
        if (answer == expected) {
            printf("Correct!\n");
            score++;
        } else {
            printf("Wrong. The correct answer is %d.\n", expected);
        }
    }
    time(&end); // record the end time

    // show the final score and time used
    printf("\nTime's up! Your final score is: %d\n", score);
    printf("You played for %.0f seconds.\n", difftime(end, start));

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static double __cdecl difftime(const time_t Time1, const time_t Time2);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();
// int __cdecl getchar();
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl atoi(const char *String);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  time_t v4; // rbx
  time_t v5; // rax
  double v6; // xmm0_8
  char Buffer[10]; // [rsp+2Eh] [rbp-32h] BYREF
  time_t Time1; // [rsp+38h] [rbp-28h] BYREF
  time_t Time; // [rsp+40h] [rbp-20h] BYREF
  int v11; // [rsp+4Ch] [rbp-14h]
  unsigned int v12; // [rsp+50h] [rbp-10h]
  unsigned int v13; // [rsp+54h] [rbp-Ch]
  unsigned int v14; // [rsp+58h] [rbp-8h]
  unsigned int v15; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  v15 = 0;
  printf("Welcome to the Math Game!\n\n");
  printf("Rules: You will have %d seconds to answer as many multiplication questions as possible.\n", 60i64);
  printf("       Each question will have a random factor between 1 and %d.\n", 10i64);
  printf("       The result will be less than or equal to %d.\n", 100i64);
  printf("       Type your answer and press Enter.\n");
  printf("       Each correct answer will earn you 1 point. No penalties for wrong answers.\n");
  printf("\nReady? Press Enter to start the game!");
  getchar();
  time(&Time);
  while ( 1 )
  {
    v4 = Time;
    v5 = time(0i64);
    if ( difftime(v5, v4) >= 60.0 )
      break;
    v14 = rand() % 10 + 1;
    v13 = rand() % 10 + 1;
    v12 = v13 * v14;
    printf("%d. What is %d x %d?  ", v15 + 1, v14, v13);
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 10, v3);
    v11 = atoi(Buffer);
    if ( v11 == v12 )
    {
      printf("Correct!\n");
      ++v15;
    }
    else
    {
      printf("Wrong. The correct answer is %d.\n", v12);
    }
  }
  time(&Time1);
  printf("\nTime's up! Your final score is: %d\n", v15);
  v6 = difftime(Time1, Time);
  printf("You played for %.0f seconds.\n", v6);
  return 0;
}
// 1400018D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bingo Simulator ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 5
#define COLS 5

// Function to check if a number is already present in the Bingo board
int checkDuplicate(int arr[ROWS][COLS], int num)
{
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (arr[i][j] == num) {
                return 1;
            }
        }
    }
    return 0;
}

// Function to check if any row, column or diagonal is completed
int checkBingo(int arr[ROWS][COLS])
{
    int count = 0;

    // Check rows
    for (int i = 0; i < ROWS; i++) {
        count = 0;
        for (int j = 0; j < COLS; j++) {
            if (arr[i][j] == -1) {
                count++;
            }
        }
        if (count == COLS) {
            printf("BINGO! You have completed row %d\n", i+1);
            return 1;
        }
    }

    // Check columns
    for (int i = 0; i < COLS; i++) {
        count = 0;
        for (int j = 0; j < ROWS; j++) {
            if (arr[j][i] == -1) {
                count++;
            }
        }
        if (count == ROWS) {
            printf("BINGO! You have completed column %d\n", i+1);
            return 1;
        }
    }

    // Check diagonal 1 (top-left to bottom-right)
    count = 0;
    for (int i = 0; i < ROWS; i++) {
        if (arr[i][i] == -1) {
            count++;
        }
    }
    if (count == ROWS) {
        printf("BINGO! You have completed diagonal 1\n");
        return 1;
    }

    // Check diagonal 2 (top-right to bottom-left)
    count = 0;
    for (int i = 0; i < ROWS; i++) {
        if (arr[i][COLS-i-1] == -1) {
            count++;
        }
    }
    if (count == ROWS) {
        printf("BINGO! You have completed diagonal 2\n");
        return 1;
    }

    return 0;
}

int main()
{
    int nums[75];
    for (int i = 0; i < 75; i++) {
        nums[i] = i+1;
    }

    srand(time(NULL));
    int board[ROWS][COLS];
    int index;

    // Initialize the Bingo board with -1
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            board[i][j] = -1;
        }
    }

    while (!checkBingo(board)) {
        // Generate a random number between 1 and 75
        index = rand() % 75;
        while (checkDuplicate(board, nums[index])) {
            index = rand() % 75;
        }

        // Mark the number on the Bingo board
        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                if (board[i][j] == nums[index]) {
                    board[i][j] = -1;
                }
            }
        }

        // Add the number to the board
        int added = 0;
        while (!added) {
            index = rand() % 25;
            if (board[index/5][index%5] == -1) {
                board[index/5][index%5] = nums[index];
                added = 1;
            }
        }

        // Print the updated Bingo board
        printf("\n");
        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                if (board[i][j] == -1) {
                    printf("   ");
                } else {
                    printf("%2d ", board[i][j]);
                }
            }
            printf("\n");
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall checkDuplicate(_QWORD, _QWORD); // weak
__int64 __fastcall checkBingo(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001815) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[103]; // [rsp+20h] [rbp-60h] BYREF
  int jj; // [rsp+1BCh] [rbp+13Ch]
  int ii; // [rsp+1C0h] [rbp+140h]
  int v8; // [rsp+1C4h] [rbp+144h]
  int n; // [rsp+1C8h] [rbp+148h]
  int m; // [rsp+1CCh] [rbp+14Ch]
  int k; // [rsp+1D0h] [rbp+150h]
  int j; // [rsp+1D4h] [rbp+154h]
  int v13; // [rsp+1D8h] [rbp+158h]
  int i; // [rsp+1DCh] [rbp+15Ch]

  _main(argc, argv, envp);
  for ( i = 0; i <= 74; ++i )
    v5[i + 28] = i + 1;
  v3 = time(0i64);
  srand(v3);
  for ( j = 0; j <= 4; ++j )
  {
    for ( k = 0; k <= 4; ++k )
      v5[5 * j + k] = -1;
  }
  while ( !(unsigned int)checkBingo(v5) )
  {
    do
      v13 = rand() % 75;
    while ( (unsigned int)checkDuplicate(v5, (unsigned int)v5[v13 + 28]) );
    for ( m = 0; m <= 4; ++m )
    {
      for ( n = 0; n <= 4; ++n )
      {
        if ( v5[5 * m + n] == v5[v13 + 28] )
          v5[5 * m + n] = -1;
      }
    }
    v8 = 0;
    while ( !v8 )
    {
      v13 = rand() % 25;
      if ( v5[5 * (v13 / 5) + v13 % 5] == -1 )
      {
        v5[5 * (v13 / 5) + v13 % 5] = v5[v13 + 28];
        v8 = 1;
      }
    }
    printf("\n");
    for ( ii = 0; ii <= 4; ++ii )
    {
      for ( jj = 0; jj <= 4; ++jj )
      {
        if ( v5[5 * ii + jj] == -1 )
          printf("   ");
        else
          printf("%2d ", (unsigned int)v5[5 * ii + jj]);
      }
      printf("\n");
    }
    printf("\n");
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall checkDuplicate(_QWORD, _QWORD);
// 140001622: using guessed type __int64 __fastcall checkBingo(_QWORD);
// 140001CD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text processing ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*function to replace all occurrences of a character in a string*/
char *replaceChar(char *str, char oldChar, char newChar) {
    int i;
    int len = strlen(str);
    /*iterate through the string*/
    for (i = 0; i < len; i++) {
        /*if a character in the string matches the oldChar, replace it with the newChar*/
        if (str[i] == oldChar) {
            str[i] = newChar;
        }
    }
    return str;
}

/*function to count the number of occurrences of a character in a string*/
int countChar(char *str, char ch) {
    int i;
    int count = 0;
    /*iterate through the string*/
    for (i = 0; str[i] != '\0'; i++) {
        /*if a character in the string matches the searched character, increment the count*/
        if (str[i] == ch) {
            count++;
        }
    }
    return count;
}

int main() {
    char str[100];
    char oldChar, newChar;
    printf("Enter a string: ");
    scanf("%[^\n]%*c", str); /*read input including spaces*/
    printf("Enter the character you want to replace: ");
    scanf("%c", &oldChar);
    printf("Enter the new character: ");
    scanf(" %c", &newChar); /*the space before %c is to consume the newline character*/
    
    /*replace all occurrences of the oldChar with newChar in the string*/
    char *newStr = replaceChar(str, oldChar, newChar);
    printf("String after replacing '%c' with '%c': %s\n", oldChar, newChar, newStr);
    
    /*count the number of occurrences of a character*/
    printf("Enter a character: ");
    char ch;
    scanf(" %c", &ch);
    int count = countChar(str, ch);
    printf("The character '%c' appears %d times in the string.\n", ch, count);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall replaceChar(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall countChar(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016A9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+2Dh] [rbp-73h] BYREF
  char v5; // [rsp+2Eh] [rbp-72h] BYREF
  char v6; // [rsp+2Fh] [rbp-71h] BYREF
  char v7[100]; // [rsp+30h] [rbp-70h] BYREF
  unsigned int v8; // [rsp+94h] [rbp-Ch]
  const char *v9; // [rsp+98h] [rbp-8h]

  _main(argc, argv, envp);
  printf("Enter a string: ");
  scanf("%[^\n]%*c", v7);
  printf("Enter the character you want to replace: ");
  scanf("%c", &v6);
  printf("Enter the new character: ");
  scanf(" %c", &v5);
  v9 = (const char *)replaceChar(v7, (unsigned int)v6, (unsigned int)v5);
  printf("String after replacing '%c' with '%c': %s\n", (unsigned int)v6, (unsigned int)v5, v9);
  printf("Enter a character: ");
  scanf(" %c", &v4);
  v8 = countChar(v7, (unsigned int)v4);
  printf("The character '%c' appears %d times in the string.\n", (unsigned int)v4, v8);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall replaceChar(_QWORD, _QWORD, _QWORD);
// 14000164E: using guessed type __int64 __fastcall countChar(_QWORD, _QWORD);
// 140001890: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to ASCII art generator ; Style: systematic
#include <stdio.h>

// Define the height and width of the art
#define ART_HEIGHT 5
#define ART_WIDTH 10

// Define the ASCII characters used to draw the art
#define ART_BLANK ' '
#define ART_FILL '-'
#define ART_BORDER '|'

int main() {
    // Declare and initialize the art character array
    char art[ART_HEIGHT][ART_WIDTH] = { { ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL },
                                         { ART_FILL, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_FILL },
                                         { ART_FILL, ART_BORDER, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BORDER, ART_FILL },
                                         { ART_FILL, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_BLANK, ART_FILL },
                                         { ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL, ART_FILL } };

    // Draw the art
    for (int row = 0; row < ART_HEIGHT; row++) {
        for (int col = 0; col < ART_WIDTH; col++) {
            printf("%c", art[row][col]);
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[7]; // [rsp+20h] [rbp-40h] BYREF
  int j; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]
  __int64 savedregs; // [rsp+60h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v4, "-----------        --|      |--        -----------", 50);
  for ( i = 0; i <= 4; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      printf("%c", (unsigned int)*((char *)&savedregs + 10 * i + j - 64));
    printf("\n");
  }
  return 0;
}
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int min(int a, int b, int c)
{
    if (a < b && a < c)
        return a;
    if (b < a && b < c)
        return b;
    return c;
}

int ShapeShiftingLevenshteinDistance(char *s, char *t)
{
    int m = strlen(s);
    int n = strlen(t);
    int d[m + 1][n + 1];
    int i, j, cost;

    for (i = 0; i <= m; i++)
    {
        for (j = 0; j <= n; j++)
        {
            if (i == 0)
                d[i][j] = j;

            else if (j == 0)
                d[i][j] = i;

            else if (s[i - 1] == t[j - 1])
                d[i][j] = d[i - 1][j - 1];

            else
            {
                cost = 1;

                if (i > 2 && s[i - 3] == t[j - 1])
                    cost = 0;

                if (j > 2 && s[i - 1] == t[j - 3])
                    cost = 0;

                if (i > 2 && j > 2 && s[i - 3] == t[j - 3])
                {
                    if (s[i - 2] == t[j - 1] || s[i - 1] == t[j - 2])
                        cost = 0;
                }

                d[i][j] = min(d[i - 1][j] + 1, // deletion
                              d[i][j - 1] + 1, // insertion
                              d[i - 1][j - 1] + cost); // substitution
            }
        }
    }

    return d[m][n];
}

int main()
{
    char str1[] = "Hello World!";
    char str2[] = "Holla Warld!";
    printf("The Levenshtein Distance between \"%s\" and \"%s\" is: %d\n", str1, str2, ShapeShiftingLevenshteinDistance(str1, str2));
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall ShapeShiftingLevenshteinDistance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400019FA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char var1A[34]; // [rsp+26h] [rbp-1Ah] BYREF

  _main(argc, argv, envp);
  strcpy(&var1A[13], "Hello World!");
  strcpy(var1A, "Holla Warld!");
  v3 = ShapeShiftingLevenshteinDistance(&var1A[13], var1A);
  printf("The Levenshtein Distance between \"%s\" and \"%s\" is: %d\n", &var1A[13], var1A, v3);
  return 0;
}
// 1400015CE: using guessed type __int64 __fastcall ShapeShiftingLevenshteinDistance(_QWORD, _QWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature monitor ; Style: beginner-friendly
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float celsius, fahrenheit;
    
    printf("Enter the temperature in Celsius: ");
    scanf("%f", &celsius);
    
    fahrenheit = (celsius * 9 / 5) + 32;
    
    printf("The temperature in Fahrenheit is: %.2f\n", fahrenheit);
    
    if (fahrenheit <= 32)
    {
        printf("It's freezing cold!\n");
    }
    else if (fahrenheit > 32 && fahrenheit <= 60)
    {
        printf("It's chilly!\n");
    }
    else if (fahrenheit > 60 && fahrenheit <= 80)
    {
        printf("It's nice and warm!\n");
    }
    else
    {
        printf("It's hot outside!\n");
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+28h] [rbp-8h] BYREF
  float v5; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the temperature in Celsius: ");
  scanf("%f", &v4);
  v5 = (float)((float)(9.0 * v4) / 5.0) + 32.0;
  printf("The temperature in Fahrenheit is: %.2f\n", v5);
  if ( v5 > 32.0 )
  {
    if ( v5 > 60.0 )
    {
      if ( v5 > 80.0 )
        printf("It's hot outside!\n");
      else
        printf("It's nice and warm!\n");
    }
    else
    {
      printf("It's chilly!\n");
    }
  }
  else
  {
    printf("It's freezing cold!\n");
  }
  return 0;
}
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>

void fib(int n) {
    int arr[n];
    arr[0] = 0;
    arr[1] = 1;

    for(int i = 2; i < n; i++) {
        arr[i] = arr[i-1] + arr[i-2];
    }

    printf("Fibonacci Sequence:\n");

    for(int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
}

void printRow(int num, int* arr, int curr, int length) {
    int mid = length / 2;
    if(num > curr) {
        printRow(num, arr, curr * 2, length);
    }
    int spaces = mid - curr / 2;
    for(int i = 0; i < spaces; i++) {
        printf(" ");
    }
    for(int i = 0; i < curr; i++) {
        if(mid - i <= 0 || mid + i >= length) {
            break;
        }
        printf("%d", arr[num - (mid-i-1)]);
    }
    printf("\n");
}

void printFibonacciVisualization(int n) {
    if(n == 0) {
        printf("0\n");
        return;
    }
    if(n == 1) {
        printf("0 \n1\n");
        return;
    }

    int arr[n];
    arr[0] = 0;
    arr[1] = 1;

    for(int i = 2; i < n; i++) {
        arr[i] = arr[i-1] + arr[i-2];
    }

    int maxNum = arr[n-1];
    int curr = 2;
    while(curr < n && arr[curr] <= maxNum) {
        curr++;
    }
    curr--;

    for(int i = curr; i >= 0; i--) {
        printRow(i, arr, 1, curr * 2 + 1);
    }
}

int main() {
    int n;
    printf("Enter the number of terms: ");
    scanf("%d", &n);

    printf("\n\n");

    fib(n);

    printf("\n\n");

    printf("Fibonacci Visualization:\n\n");

    printFibonacciVisualization(n);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall fib(_QWORD); // weak
__int64 __fastcall printFibonacciVisualization(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001961) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the number of terms: ");
  scanf("%d", &v4);
  printf("\n\n");
  fib(v4);
  printf("\n\n");
  printf("Fibonacci Visualization:\n\n");
  printFibonacciVisualization(v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall fib(_QWORD);
// 1400017ED: using guessed type __int64 __fastcall printFibonacciVisualization(_QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Light Controller ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int red = 1, yellow = 0, green = 0;
  int time = 0, duration = 0;
  
  printf("Welcome to the Traffic Light Controller.\n");
  printf("The light is currently RED.\n\n");

  while(1) {
    printf("How long should RED be on for? ");
    scanf("%d", &duration);
    time += duration;
    printf("RED is on for %d seconds.\n", duration);
    printf("Yellow will be on for 3 seconds.\n");
    printf("Green will be on for 10 seconds.\n");

    red = 0;
    yellow = 1;
    green = 0;

    printf("\nYELLOW\n");
    printf("Remaining time: %d seconds.\n", 3 - time);
    while(time < 3) {
      time++;
      sleep(1);
      printf("Remaining time: %d seconds.\n", 3 - time);
    }

    red = 0;
    yellow = 0;
    green = 1;
    time = 0;

    printf("\nGREEN\n");
    printf("Remaining time: %d seconds.\n", 10 - time);
    while(time < 10) {
      time++;
      sleep(1);
      printf("Remaining time: %d seconds.\n", 10 - time);
    }

    red = 1;
    yellow = 0;
    green = 0;
    time = 0;

    printf("\nRED\n");
    printf("Remaining time: %d seconds.\n", duration - time);
    while(time < duration) {
      time++;
      sleep(1);
      printf("Remaining time: %d seconds.\n", duration - time);
    }
  }

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sleep(_QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-14h] BYREF
  int v5; // [rsp+30h] [rbp-10h]
  int v6; // [rsp+34h] [rbp-Ch]
  int v7; // [rsp+38h] [rbp-8h]
  int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7 = 1;
  v6 = 0;
  v5 = 0;
  v8 = 0;
  v4 = 0;
  printf("Welcome to the Traffic Light Controller.\n");
  printf("The light is currently RED.\n\n");
  while ( 1 )
  {
    printf("How long should RED be on for? ");
    scanf("%d", &v4);
    v8 += v4;
    printf("RED is on for %d seconds.\n", v4);
    printf("Yellow will be on for 3 seconds.\n");
    printf("Green will be on for 10 seconds.\n");
    v7 = 0;
    v6 = 1;
    v5 = 0;
    printf("\nYELLOW\n");
    printf("Remaining time: %d seconds.\n", (unsigned int)(3 - v8));
    while ( v8 <= 2 )
    {
      ++v8;
      sleep(1i64);
      printf("Remaining time: %d seconds.\n", (unsigned int)(3 - v8));
    }
    v7 = 0;
    v6 = 0;
    v5 = 1;
    v8 = 0;
    printf("\nGREEN\n");
    printf("Remaining time: %d seconds.\n", (unsigned int)(10 - v8));
    while ( v8 <= 9 )
    {
      ++v8;
      sleep(1i64);
      printf("Remaining time: %d seconds.\n", (unsigned int)(10 - v8));
    }
    v7 = 1;
    v6 = 0;
    v5 = 0;
    v8 = 0;
    printf("\nRED\n");
    printf("Remaining time: %d seconds.\n", v4 - v8);
    while ( v8 < (int)v4 )
    {
      ++v8;
      sleep(1i64);
      printf("Remaining time: %d seconds.\n", v4 - v8);
    }
  }
}
// 1400018A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002900: using guessed type __int64 __fastcall sleep(_QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text Summarizer ; Style: Ada Lovelace
// Ada Lovelace Style Unique C Text Summarizer Example Program

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_STRING_LEN 1000
#define MAX_SUMMARY_LEN 100

int main() {
    char input_string[MAX_STRING_LEN];
    char summary[MAX_SUMMARY_LEN];
    int i, j;

    printf("Enter the input string: ");
    fgets(input_string, MAX_STRING_LEN, stdin);

    // Count number of sentences
    int sentence_count = 0;
    for (i = 0; input_string[i] != '\0'; i++) {
        if (input_string[i] == '.') {
            sentence_count++;
        }
    }

    // Allocate memory for the sentences
    char *sentences[sentence_count];
    for (i = 0; i < sentence_count; i++) {
        sentences[i] = (char *)malloc(MAX_STRING_LEN);
        memset(sentences[i], 0, MAX_STRING_LEN);
    }

    // Store the sentences
    int sentence_index = 0;
    int start_index = 0;
    for (i = 0; input_string[i] != '\0'; i++) {
        if (input_string[i] == '.') {
            strncpy(sentences[sentence_index++], input_string + start_index, i - start_index + 1);
            start_index = i + 1;
        }
    }

    // Calculate the score for each sentence
    float sentence_score[sentence_count];
    memset(sentence_score, 0, sentence_count * sizeof(float));
    for (i = 0; i < sentence_count; i++) {
        for (j = 0; j < sentence_count; j++) {
            if (i != j) {
                char *temp_sentence = (char *)malloc(MAX_STRING_LEN);
                strcpy(temp_sentence, sentences[i]);
                char *token = strtok(temp_sentence, " ");
                int common_word_count = 0;
                int total_word_count = 0;
                while (token != NULL) {
                    if (strstr(sentences[j], token) != NULL) {
                        common_word_count++;
                    }
                    total_word_count++;
                    token = strtok(NULL, " ");
                }
                free(temp_sentence);
                sentence_score[i] += (float)common_word_count / (float)total_word_count;
            }
        }
    }

    // Calculate the threshold score
    float threshold_score = 0;
    for (i = 0; i < sentence_count; i++) {
        threshold_score += sentence_score[i];
    }
    threshold_score /= sentence_count;

    // Generate the summary
    int summary_index = 0;
    for (i = 0; i < sentence_count; i++) {
        if (sentence_score[i] >= threshold_score && summary_index + strlen(sentences[i]) <= MAX_SUMMARY_LEN) {
            strncpy(summary + summary_index, sentences[i], strlen(sentences[i]));
            summary_index += strlen(sentences[i]);
        }
    }

    printf("Summary: %s\n", summary);

    // Free the memory
    for (i = 0; i < sentence_count; i++) {
        free(sentences[i]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  void *v4; // rsp
  int v5; // eax
  void *v6; // rsp
  size_t v7; // rax
  __int64 v9[4]; // [rsp+20h] [rbp-60h] BYREF
  char v10[112]; // [rsp+40h] [rbp-40h] BYREF
  char Buffer[1000]; // [rsp+B0h] [rbp+30h] BYREF
  char *Destination; // [rsp+498h] [rbp+418h]
  void *v13; // [rsp+4A0h] [rbp+420h]
  __int64 v14; // [rsp+4A8h] [rbp+428h]
  __int64 *v15; // [rsp+4B0h] [rbp+430h]
  __int64 v16; // [rsp+4B8h] [rbp+438h]
  int v17; // [rsp+4C0h] [rbp+440h]
  float v18; // [rsp+4C4h] [rbp+444h]
  int v19; // [rsp+4C8h] [rbp+448h]
  int v20; // [rsp+4CCh] [rbp+44Ch]
  char *SubStr; // [rsp+4D0h] [rbp+450h]
  int v22; // [rsp+4DCh] [rbp+45Ch]
  int v23; // [rsp+4E0h] [rbp+460h]
  int v24; // [rsp+4E4h] [rbp+464h]
  int j; // [rsp+4E8h] [rbp+468h]
  int i; // [rsp+4ECh] [rbp+46Ch]

  _main(argc, argv, envp);
  printf("Enter the input string: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v24 = 0;
  for ( i = 0; Buffer[i]; ++i )
  {
    if ( Buffer[i] == 46 )
      ++v24;
  }
  v16 = v24 - 1i64;
  v9[2] = v24;
  v9[3] = 0i64;
  v9[0] = v24;
  v9[1] = 0i64;
  v4 = alloca(16 * ((unsigned __int64)(8i64 * v24 + 15) >> 4));
  v15 = v9;
  for ( i = 0; i < v24; ++i )
  {
    v15[i] = (__int64)malloc(0x3E8ui64);
    memset((void *)v15[i], 0, 0x3E8ui64);
  }
  v23 = 0;
  v22 = 0;
  for ( i = 0; Buffer[i]; ++i )
  {
    if ( Buffer[i] == 46 )
    {
      v5 = v23++;
      strncpy((char *)v15[v5], &Buffer[v22], i - v22 + 1);
      v22 = i + 1;
    }
  }
  v14 = v24 - 1i64;
  v6 = alloca(16 * ((unsigned __int64)(4i64 * v24 + 15) >> 4));
  v13 = v9;
  memset(v9, 0, 4i64 * v24);
  for ( i = 0; i < v24; ++i )
  {
    for ( j = 0; j < v24; ++j )
    {
      if ( i != j )
      {
        Destination = (char *)malloc(0x3E8ui64);
        strcpy(Destination, (const char *)v15[i]);
        SubStr = strtok(Destination, " ");
        v20 = 0;
        v19 = 0;
        while ( SubStr )
        {
          if ( strstr((const char *)v15[j], SubStr) )
            ++v20;
          ++v19;
          SubStr = strtok(0i64, " ");
        }
        free(Destination);
        *((float *)v13 + i) = (float)((float)v20 / (float)v19) + *((float *)v13 + i);
      }
    }
  }
  v18 = 0.0;
  for ( i = 0; i < v24; ++i )
    v18 = *((float *)v13 + i) + v18;
  v18 = v18 / (float)v24;
  v17 = 0;
  for ( i = 0; i < v24; ++i )
  {
    if ( *((float *)v13 + i) >= v18 && v17 + strlen((const char *)v15[i]) <= 0x64 )
    {
      v7 = strlen((const char *)v15[i]);
      strncpy(&v10[v17], (const char *)v15[i], v7);
      v17 += strlen((const char *)v15[i]);
    }
  }
  printf("Summary: %s\n", v10);
  for ( i = 0; i < v24; ++i )
    free((void *)v15[i]);
  return 0;
}
// 140001C30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[1000];
// 140001591: using guessed type char var_4E0[112];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Computer Biology ; Style: creative
#include <stdio.h>

// Function to calculate the hamming distance between two strings
int hammingDistance(char* str1, char* str2)
{
    int distance = 0;
    for(int i=0; str1[i] && str2[i]; i++)
    {
        if (str1[i] != str2[i])
        {
            distance++;
        }
    }
    return distance;
}

// Function to convert a DNA sequence to RNA 
char* dnaToRna(char* dnaSequence)
{
    int i=0;
    while(dnaSequence[i])
    {
        if(dnaSequence[i] == 'T')
            dnaSequence[i] = 'U';
        i++;
    }
    return dnaSequence;
}

int main()
{
    // Input DNA sequence
    char dnaSequence[100];
    printf("Enter a DNA sequence: ");
    scanf("%s", dnaSequence);
    
    // Convert to RNA
    char* rnaSequence = dnaToRna(dnaSequence);
    
    // Input a reference RNA sequence
    char referenceRnaSequence[100];
    printf("Enter a reference RNA sequence: ");
    scanf("%s", referenceRnaSequence);
    
    // Calculate hamming distance between DNA sequence and reference RNA sequence
    int distance = hammingDistance(rnaSequence, referenceRnaSequence);
    
    // Output the result
    printf("The hamming distance between DNA sequence and reference RNA sequence is: %d", distance);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall hammingDistance(_QWORD, _QWORD); // weak
__int64 __fastcall dnaToRna(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016BA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[112]; // [rsp+20h] [rbp-60h] BYREF
  char v5[100]; // [rsp+90h] [rbp+10h] BYREF
  unsigned int v6; // [rsp+F4h] [rbp+74h]
  __int64 v7; // [rsp+F8h] [rbp+78h]

  _main(argc, argv, envp);
  printf("Enter a DNA sequence: ");
  scanf("%s", v5);
  v7 = dnaToRna(v5);
  printf("Enter a reference RNA sequence: ");
  scanf("%s", v4);
  v6 = hammingDistance(v7, v4);
  printf("The hamming distance between DNA sequence and reference RNA sequence is: %d", v6);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall hammingDistance(_QWORD, _QWORD);
// 14000165F: using guessed type __int64 __fastcall dnaToRna(_QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Encyptor ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILENAME_LENGTH 256
#define MAX_PASSWORD_LENGTH 40
#define MAX_BUFFER_SIZE 1024

void encryptDecryptFile(char* file_path, char* password);
void encryptBuffer(unsigned char* buffer, size_t bufferLength, char* password);
unsigned long getFileSize(FILE* file);

int main() {
    char file_path[MAX_FILENAME_LENGTH];
    char password[MAX_PASSWORD_LENGTH];
    
    printf("Enter file path: ");
    scanf("%s", file_path);

    printf("Enter password: ");
    scanf("%s", password);
    
    encryptDecryptFile(file_path, password);

    printf("File encryption/decryption completed!\n");

    return 0;
}

void encryptDecryptFile(char* file_path, char* password) {
    FILE *fp;
    unsigned char buffer[MAX_BUFFER_SIZE];
    size_t bytesRead;
    unsigned long fileSize;

    fp = fopen(file_path, "rb+");
    if(fp == NULL) {
        printf("Error opening file: %s\n", file_path);
        exit(1);
    }

    fileSize = getFileSize(fp);
    if(fileSize == 0) {
        printf("File is empty\n");
        exit(1);
    }

    bytesRead = fread(buffer, sizeof(buffer[0]), MAX_BUFFER_SIZE, fp);
    while(bytesRead != 0) {
        encryptBuffer(buffer, bytesRead, password);

        fseek(fp, -((long)bytesRead), SEEK_CUR);
        fwrite(buffer, sizeof(buffer[0]), bytesRead, fp);

        fseek(fp, 0, SEEK_CUR);
        bytesRead = fread(buffer, sizeof(buffer[0]), MAX_BUFFER_SIZE, fp);
    }

    fclose(fp);
}

void encryptBuffer(unsigned char* buffer, size_t bufferLength, char* password) {
    size_t passwordLength = strlen(password);
    unsigned char temp;
    
    for(size_t i = 0; i < bufferLength; i++) {
        temp = buffer[i] ^ password[i % passwordLength];
        buffer[i] = temp;
    }
}

unsigned long getFileSize(FILE* file) {
    unsigned long fileSize;
    fseek(file, 0, SEEK_END);
    fileSize = ftell(file);
    fseek(file, 0, SEEK_SET);
    return fileSize;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall encryptDecryptFile(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[48]; // [rsp+20h] [rbp-60h] BYREF
  char v5[256]; // [rsp+50h] [rbp-30h] BYREF

  _main(argc, argv, envp);
  printf("Enter file path: ");
  scanf("%s", v5);
  printf("Enter password: ");
  scanf("%s", v4);
  encryptDecryptFile(v5, v4);
  printf("File encryption/decryption completed!\n");
  return 0;
}
// 14000166E: using guessed type __int64 __fastcall encryptDecryptFile(_QWORD, _QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=184 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Chess engine ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 8
#define COLUMNS 8

int board[ROWS][COLUMNS];

void initializeBoard() {
    int i, j;

    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLUMNS; j++) {
            board[i][j] = 0;
        }
    }
}

int possibleMoves(int x, int y) {
    int i, j, count = 0;
    int moveX, moveY;

    for (i = -2; i <= 2; i++) {
        for (j = -2; j <= 2; j++) {
            if (abs(i) != abs(j) && x+i >= 0 && x+i < ROWS && y+j >= 0 && y+j < COLUMNS) {
                moveX = x+i;
                moveY = y+j;
                if (board[moveX][moveY] == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}

void makeMove(int x, int y) {
    int i, j;
    int moveX, moveY;

    for (i = -2; i <= 2; i++) {
        for (j = -2; j <= 2; j++) {
            if (abs(i) != abs(j) && x+i >= 0 && x+i < ROWS && y+j >= 0 && y+j < COLUMNS) {
                moveX = x+i;
                moveY = y+j;
                if (board[moveX][moveY] == 0) {
                    board[moveX][moveY] = 1;
                }
            }
        }
    }
}

void printBoard() {
    int i, j;

    printf("\n");

    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLUMNS; j++) {
            printf("%d ", board[i][j]);
        }
        printf("\n");
    }
}

int main() {
    initializeBoard();

    srand(time(NULL));

    int i, j;

    for (i = 0; i < 8; i++) {
        for (j = 0; j < 8; j++) {
            int moves = possibleMoves(i, j);
            //Don't perform a move if there are no available spots
            if (moves > 0) {
                //Pick a random available spot
                int randomMove = rand() % moves;
                int count = 0;
                //Perform the move
                for (int a = -2; a <= 2; a++) {
                    for (int b = -2; b <= 2; b++) {
                        if (abs(a) != abs(b) && i+a >= 0 && i+a < ROWS && j+b >= 0 && j+b < COLUMNS) {
                            int moveX = i+a;
                            int moveY = j+b;
                            if (board[moveX][moveY] == 0) {
                                if (count == randomMove) {
                                    makeMove(moveX, moveY);
                                    break;
                                } else {
                                    count++;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    printBoard();

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 initializeBoard(void); // weak
__int64 __fastcall possibleMoves(_QWORD, _QWORD); // weak
__int64 __fastcall makeMove(_QWORD, _QWORD); // weak
__int64 printBoard(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();

//-------------------------------------------------------------------------
// Data declarations

_DWORD board[64]; // weak


//----- (0000000140001877) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // edx
  int v5; // eax
  int v7; // [rsp+34h] [rbp-1Ch]
  int v8; // [rsp+38h] [rbp-18h]
  int m; // [rsp+3Ch] [rbp-14h]
  int k; // [rsp+40h] [rbp-10h]
  int v11; // [rsp+44h] [rbp-Ch]
  int j; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  initializeBoard();
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 7; ++i )
  {
    for ( j = 0; j <= 7; ++j )
    {
      v8 = possibleMoves((unsigned int)i, (unsigned int)j);
      if ( v8 > 0 )
      {
        v7 = rand() % v8;
        v11 = 0;
        for ( k = -2; k <= 2; ++k )
        {
          for ( m = -2; m <= 2; ++m )
          {
            v4 = -k;
            if ( k > 0 )
              v4 = k;
            v5 = m;
            if ( m <= 0 )
              v5 = -m;
            if ( v4 != v5 && (unsigned int)(i + k) <= 7 && (unsigned int)(j + m) <= 7 && !board[8 * i + 8 * k + j + m] )
            {
              if ( v11 == v7 )
              {
                makeMove((unsigned int)(i + k), (unsigned int)(j + m));
                break;
              }
              ++v11;
            }
          }
        }
      }
    }
  }
  printBoard();
  return 0;
}
// 1400015B0: using guessed type __int64 initializeBoard(void);
// 14000160E: using guessed type __int64 __fastcall possibleMoves(_QWORD, _QWORD);
// 1400016EC: using guessed type __int64 __fastcall makeMove(_QWORD, _QWORD);
// 1400017EE: using guessed type __int64 printBoard(void);
// 140001AA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type _DWORD board[64];

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Spam Detection System ; Style: interoperable
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_INPUT_LEN 1000
#define SPAM_THRESHOLD 0.5

int count_occurrences(char *string, char *substring) {
    int count = 0;
    char *tmp = string;

    while ((tmp = strstr(tmp, substring))) {
        count++;
        tmp += strlen(substring);
    }

    return count;
}

double check_spam(char *input) {
    // list of keywords that are commonly found in spam messages
    char *keywords[] = {"earn", "money", "investment", "opportunity", "limited time offer", "act now"};

    double spam_score = 0;
    int num_keywords = sizeof(keywords) / sizeof(keywords[0]);

    for (int i = 0; i < num_keywords; i++) {
        int occurrences = count_occurrences(input, keywords[i]);
        spam_score += (double) occurrences / (double) strlen(input);
    }

    return spam_score;
}

int main() {
    char input[MAX_INPUT_LEN];
    printf("Enter your message: ");
    fgets(input, MAX_INPUT_LEN, stdin);

    double spam_score = check_spam(input);

    if (spam_score > SPAM_THRESHOLD) {
        printf("This message appears to be spam.\n");
    } else {
        printf("This message seems legit.\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
double __fastcall check_spam(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016E6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[1000]; // [rsp+20h] [rbp-60h] BYREF
  double v6; // [rsp+408h] [rbp+388h]

  _main(argc, argv, envp);
  printf("Enter your message: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1000, v3);
  v6 = check_spam(Buffer);
  if ( v6 <= 0.5 )
    printf("This message seems legit.\n");
  else
    printf("This message appears to be spam.\n");
  return 0;
}
// 1400015EA: using guessed type double __fastcall check_spam(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ITEMS 50

// Struct to store item details
typedef struct {
    char name[20];
    int quantity;
    float price;
} item;

// Initialize menu items
item menu[MAX_ITEMS] = {
    {"Coffee", 10, 2.50},
    {"Tea", 15, 1.25},
    {"Sandwich", 5, 5.00},
    {"Pastry", 20, 2.50},
    {"Donut", 30, 1.50}
};

int main() {
    int num_items = sizeof(menu) / sizeof(item);
    int order_qty[num_items];
    float order_total = 0;

    printf("*** Welcome to the Future Cafe! ***\n");
    printf("Here is our menu:\n");

    for (int i = 0; i < num_items; i++) {
        printf("%d. %s - $%.2f\n", i+1, menu[i].name, menu[i].price);
    }

    printf("\nPlease enter your order below:\n");

    // Take customer's order
    for (int i = 0; i < num_items; i++) {
        printf("%s - Enter qty: ", menu[i].name);
        scanf("%d", &order_qty[i]);
        order_total += order_qty[i] * menu[i].price;

        // Check if ordered qty is greater than available qty
        if (order_qty[i] > menu[i].quantity) {
            printf("We don't have enough %s in stock. Your order has been adjusted accordingly.\n", menu[i].name);
            order_qty[i] = menu[i].quantity;
            order_total -= (order_qty[i] * menu[i].price);
        }

        // Update available qty
        menu[i].quantity -= order_qty[i];
    }

    // Print invoice
    printf("\n\n*** INVOICE ***\n");

    for (int i = 0; i < num_items; i++) {
        if (order_qty[i] > 0) {
            printf("%s x %d - $%.2f\n", menu[i].name, order_qty[i], (order_qty[i] * menu[i].price));
        }
    }

    // Add tax and calculate total amount
    float tax = order_total * 0.07;
    float total_amount = order_total + tax;
    printf("\nTax (7%%) - $%.2f\n", tax);
    printf("Total Amount - $%.2f\n", total_amount);

    printf("\n\nThank you for ordering from Future Cafe!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char menu[7] = "Coffee"; // weak
char asc_140014034[2] = "\n"; // weak
float flt_140014038[346] =
{
  2.5,
  ?flt,
  0.0,
  0.0,
  0.0,
  0.0,
  ?flt,
  1.25,
  1.7589352e22,
  4.2956907e24,
  0.0,
  0.0,
  0.0,
  ?flt,
  5.0,
  7.7130241e31,
  ?flt,
  0.0,
  0.0,
  0.0,
  ?flt,
  2.5,
  3.022518e32,
  ?flt,
  0.0,
  0.0,
  0.0,
  ?flt,
  1.5,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0,
  0.0
}; // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  int v4; // xmm0_4
  int v6[2]; // [rsp+20h] [rbp-30h] BYREF
  int *v7; // [rsp+28h] [rbp-28h]
  __int64 v8; // [rsp+30h] [rbp-20h]
  int v9; // [rsp+3Ch] [rbp-14h]
  int k; // [rsp+40h] [rbp-10h]
  int j; // [rsp+44h] [rbp-Ch]
  int i; // [rsp+48h] [rbp-8h]
  float v13; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 50;
  v8 = 49i64;
  v3 = alloca(208i64);
  v7 = v6;
  v13 = 0.0;
  printf("*** Welcome to the Future Cafe! ***\n");
  printf("Here is our menu:\n");
  for ( i = 0; i < v9; ++i )
    printf("%d. %s - $%.2f\n", (unsigned int)(i + 1), &menu[28 * i], flt_140014038[7 * i]);
  printf("\nPlease enter your order below:\n");
  for ( j = 0; j < v9; ++j )
  {
    printf("%s - Enter qty: ", &menu[28 * j]);
    scanf("%d", &v7[j]);
    v13 = (float)(flt_140014038[7 * j] * (float)v7[j]) + v13;
    if ( v7[j] > *(_DWORD *)&asc_140014034[28 * j] )
    {
      printf("We don't have enough %s in stock. Your order has been adjusted accordingly.\n", &menu[28 * j]);
      v7[j] = *(_DWORD *)&asc_140014034[28 * j];
      v13 = v13 - (float)((float)v7[j] * flt_140014038[7 * j]);
    }
    *(_DWORD *)&asc_140014034[28 * j] -= v7[j];
  }
  printf("\n\n*** INVOICE ***\n");
  for ( k = 0; k < v9; ++k )
  {
    if ( v7[k] > 0 )
      printf("%s x %d - $%.2f\n", &menu[28 * k], (unsigned int)v7[k], (float)(flt_140014038[7 * k] * (float)v7[k]));
  }
  *(float *)&v4 = 0.07000000000000001 * v13;
  v6[1] = v4;
  *(float *)v6 = v13 + *(float *)&v4;
  printf("\nTax (7%%) - $%.2f\n", *(float *)&v4);
  printf("Total Amount - $%.2f\n", *(float *)v6);
  printf("\n\nThank you for ordering from Future Cafe!\n");
  return 0;
}
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140014038: using guessed type float flt_140014038[346];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: excited
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main()
{
    int i=0, j=0, k=0, l=0;
    int car_count = 0;
    int cars[10];
    int current_pos = -1;
    int next_pos = 0;
    char sim_grid[4][10];

    srand(time(NULL)); // to get different random values each time

    // Initializing simulation grid for the traffic flow simulation
    for(i=0; i<4; i++)
    {
        for(j=0; j<10; j++)
        {
            sim_grid[i][j] = '-';
        }
    }

    // Creating the initial traffic flow by randomly placing cars on the grid
    for(i=0; i<5; i++)
    {
        current_pos = rand() % 4;
        next_pos = rand() % 10;
        if(sim_grid[current_pos][next_pos] != 'C')
        {
            sim_grid[current_pos][next_pos] = 'C';
            cars[car_count] = current_pos*10 + next_pos; // storing car position as single integer
            car_count++;
        }
        else
        {
            i--; // if position already occupied by a car, try again with new random values
        }
    }

    // Printing the initial traffic flow configuration
    printf("Initial Traffic Flow Configuration\n");
    for(i=0; i<4; i++)
    {
        for(j=0; j<10; j++)
        {
            printf("%c ", sim_grid[i][j]);
        }
        printf("\n");
    }
    printf("\n");

    // Moving the cars on the simulation grid based on traffic rules
    for(k=0; k<30; k++)
    {
        for(l=0; l<car_count; l++)
        {
            current_pos = cars[l] / 10;
            next_pos = cars[l] % 10;
            sim_grid[current_pos][next_pos] = '-'; // emptying the current position

            // Checking traffic rules for moving the car to next position
            if(current_pos == 0 && next_pos == 9)
            {
                sim_grid[3][0] = 'C';
                cars[l] = 30;
            }
            else if(current_pos == 3 && next_pos == 0)
            {
                sim_grid[0][9] = 'C';
                cars[l] = 9;
            }
            else if(next_pos == 9)
            {
                if(sim_grid[current_pos+1][0] != 'C')
                {
                    sim_grid[current_pos+1][0] = 'C';
                    cars[l] = (current_pos+1)*10;
                }
                else
                {
                    sim_grid[current_pos][next_pos] = 'C';
                    cars[l] = current_pos*10 + next_pos;
                }
            }
            else
            {
                if(sim_grid[current_pos][next_pos+1] != 'C')
                {
                    sim_grid[current_pos][next_pos+1] = 'C';
                    cars[l] = current_pos*10 + next_pos+1;
                }
                else
                {
                    sim_grid[current_pos][next_pos] = 'C';
                    cars[l] = current_pos*10 + next_pos;
                }
            }
        }

        // Printing the updated traffic flow configuration
        printf("Traffic Flow Configuration after Step %d\n", k+1);
        for(i=0; i<4; i++)
        {
            for(j=0; j<10; j++)
            {
                printf("%c ", sim_grid[i][j]);
            }
            printf("\n");
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  _WORD v5[4]; // [rsp+20h] [rbp-80h]
  char v6; // [rsp+29h] [rbp-77h]
  char v7; // [rsp+3Eh] [rbp-62h]
  int v8[13]; // [rsp+50h] [rbp-50h]
  int v9; // [rsp+84h] [rbp-1Ch]
  int v10; // [rsp+88h] [rbp-18h]
  int v11; // [rsp+8Ch] [rbp-14h]
  int m; // [rsp+90h] [rbp-10h]
  int k; // [rsp+94h] [rbp-Ch]
  int j; // [rsp+98h] [rbp-8h]
  int i; // [rsp+9Ch] [rbp-4h]
  __int64 savedregs; // [rsp+A0h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  j = 0;
  k = 0;
  m = 0;
  v11 = 0;
  v10 = -1;
  v9 = 0;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 3; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      *((_BYTE *)&savedregs + 10 * i + j - 128) = 45;
  }
  for ( i = 0; i <= 4; ++i )
  {
    v10 = rand() % 4;
    v9 = rand() % 10;
    if ( *((_BYTE *)&savedregs + 10 * v10 + v9 - 128) == 67 )
    {
      --i;
    }
    else
    {
      *((_BYTE *)&savedregs + 10 * v10 + v9 - 128) = 67;
      v8[v11++] = v9 + 10 * v10;
    }
  }
  printf("Initial Traffic Flow Configuration\n");
  for ( i = 0; i <= 3; ++i )
  {
    for ( j = 0; j <= 9; ++j )
      printf("%c ", (unsigned int)*((char *)&savedregs + 10 * i + j - 128));
    printf("\n");
  }
  printf("\n");
  for ( k = 0; k <= 29; ++k )
  {
    for ( m = 0; m < v11; ++m )
    {
      v10 = v8[m] / 10;
      v9 = v8[m] % 10;
      *((_BYTE *)&savedregs + 10 * v10 + v9 - 128) = 45;
      if ( v10 || v9 != 9 )
      {
        if ( v10 != 3 || v9 )
        {
          if ( v9 == 9 )
          {
            if ( LOBYTE(v5[5 * v10 + 5]) == 67 )
            {
              *((_BYTE *)&savedregs + 10 * v10 + v9 - 128) = 67;
              v8[m] = v9 + 10 * v10;
            }
            else
            {
              LOBYTE(v5[5 * v10 + 5]) = 67;
              v8[m] = 10 * (v10 + 1);
            }
          }
          else if ( *((_BYTE *)&savedregs + 10 * v10 + v9 - 127) == 67 )
          {
            *((_BYTE *)&savedregs + 10 * v10 + v9 - 128) = 67;
            v8[m] = v9 + 10 * v10;
          }
          else
          {
            *((_BYTE *)&savedregs + 10 * v10 + v9 - 127) = 67;
            v8[m] = 10 * v10 + v9 + 1;
          }
        }
        else
        {
          v6 = 67;
          v8[m] = 9;
        }
      }
      else
      {
        v7 = 67;
        v8[m] = 30;
      }
    }
    printf("Traffic Flow Configuration after Step %d\n", (unsigned int)(k + 1));
    for ( i = 0; i <= 3; ++i )
    {
      for ( j = 0; j <= 9; ++j )
        printf("%c ", (unsigned int)*((char *)&savedregs + 10 * i + j - 128));
      printf("\n");
    }
    printf("\n");
  }
  return 0;
}
// 140001B70: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type int var_50[13];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

double calculate_speed();

int main(){
    srand(time(NULL)); //initialize random seed
    
    double speed = calculate_speed();
    
    printf("Your internet speed is %.2f Mbps\n", speed);
    
    return 0;
}

double calculate_speed(){
    double max = 100.0;
    double min = 5.0;
    
    double random_num = (rand()/(double)RAND_MAX)*(max-min) + min; //generate random number between min and max
    
    return random_num;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
double calculate_speed(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  double v4; // xmm0_8

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v4 = calculate_speed();
  printf("Your internet speed is %.2f Mbps\n", v4);
  return 0;
}
// 140001606: using guessed type double calculate_speed(void);
// 140001730: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: imaginative
#include <stdio.h>

int prime(int n) {
    int i;
    if (n <= 1) {
        return 0;
    }
    for (i = 2; i <= n/2; i++) {
        if (n%i == 0) {
            return 0;
        }
    }
    return 1;
}

void primeGenerator(int N) {
    int i, count = 0;
    printf("List of prime numbers between 1 and %d: \n", N);
    for (i = 2; i <= N; i++) {
        if (prime(i)) {
            printf("%d ", i);
            count++;
        }
    }
    printf("\nTotal number of prime numbers in the list: %d\n", count);
}

int main() {
    int n;
    printf("Enter the upper limit of the range you want to generate prime numbers for: ");
    scanf("%d", &n);
    primeGenerator(n);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall primeGenerator(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016B1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the upper limit of the range you want to generate prime numbers for: ");
  scanf("%d", &v4);
  primeGenerator(v4);
  return 0;
}
// 140001637: using guessed type __int64 __fastcall primeGenerator(_QWORD);
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *ptr1, *ptr2, *ptr3, *ptr4; //pointer declaration

    //Allocating memory using malloc
    ptr1 = (int *)malloc(5 * sizeof(int));
    ptr2 = (int *)malloc(10 * sizeof(int));
    ptr3 = (int *)malloc(15 * sizeof(int));

    //Checking for malloc error
    if (ptr1 == NULL || ptr2 == NULL || ptr3 == NULL) {
        printf("Memory Allocation Error!\n");
        return -1;
    }

    //Printing the allocated memory addresses
    printf("Memory Addresses Allocated:\n");
    printf("ptr1: %p\n", ptr1);
    printf("ptr2: %p\n", ptr2);
    printf("ptr3: %p\n", ptr3);

    //Freeing up allocated memory using free
    free(ptr1);

    //Allocating memory using calloc
    ptr4 = (int *)calloc(20, sizeof(int));

    //Checking for calloc error
    if (ptr4 == NULL) {
        printf("Memory Allocation Error!\n");
        return -1;
    }

    //Printing the allocated memory address
    printf("ptr4: %p\n", ptr4);

    //Reallocating memory using realloc
    ptr2 = (int *)realloc(ptr2, 20 * sizeof(int));

    //Checking for realloc error
    if (ptr2 == NULL) {
        printf("Memory Allocation Error!\n");
        return -1;
    }

    //Printing the reallocated memory address
    printf("ptr2: %p\n", ptr2);

    //Freeing up the rest of the allocated memory
    free(ptr2);
    free(ptr3);
    free(ptr4);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void *__cdecl calloc(size_t Count, size_t Size);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v4; // [rsp+20h] [rbp-20h]
  void *v5; // [rsp+28h] [rbp-18h]
  void *v6; // [rsp+30h] [rbp-10h]
  void *v7; // [rsp+30h] [rbp-10h]
  void *Block; // [rsp+38h] [rbp-8h]

  _main(argc, argv, envp);
  Block = malloc(0x14ui64);
  v6 = malloc(0x28ui64);
  v5 = malloc(0x3Cui64);
  if ( !Block )
    goto LABEL_7;
  if ( !v6 )
    goto LABEL_7;
  if ( !v5 )
    goto LABEL_7;
  printf("Memory Addresses Allocated:\n");
  printf("ptr1: %p\n", Block);
  printf("ptr2: %p\n", v6);
  printf("ptr3: %p\n", v5);
  free(Block);
  v4 = calloc(0x14ui64, 4ui64);
  if ( !v4 )
    goto LABEL_7;
  printf("ptr4: %p\n", v4);
  v7 = realloc(v6, 0x50ui64);
  if ( v7 )
  {
    printf("ptr2: %p\n", v7);
    free(v7);
    free(v5);
    free(v4);
    return 0;
  }
  else
  {
LABEL_7:
    printf("Memory Allocation Error!\n");
    return -1;
  }
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue Implementation ; Style: automated
#include<stdio.h>
#include<stdlib.h>

#define QUEUE_MAX_SIZE 10

typedef struct Queue {
    int data[QUEUE_MAX_SIZE];
    int front, rear;
} Queue;

// function prototypes
Queue* queue_init();
void enqueue(Queue*, int);
int dequeue(Queue*);
void display(Queue*);
int is_empty(Queue*);
int is_full(Queue*);

int main() {
    int option, element;
    Queue* queue = NULL;

    // display menu
    do {
        printf("\nSelect an option:\n");
        printf("1. Initialize Queue\n");
        printf("2. Enqueue\n");
        printf("3. Dequeue\n");
        printf("4. Display Queue\n");
        printf("5. Exit\n");
        printf("Enter option number: ");

        scanf("%d", &option);

        switch(option) {
            case 1:
                queue = queue_init();
                printf("Queue initialized\n");
                break;
            case 2:
                if(queue == NULL) {
                    printf("Queue not initialized\n");
                    break;
                }
                printf("Enter element to be enqueued: ");
                scanf("%d", &element);
                enqueue(queue, element);
                break;
            case 3:
                if(queue == NULL) {
                    printf("Queue not initialized\n");
                    break;
                }
                element = dequeue(queue);
                if(element != -1)
                    printf("%d dequeued from queue\n", element);
                break;
            case 4:
                if(queue == NULL) {
                    printf("Queue not initialized\n");
                    break;
                }
                display(queue);
                break;
            case 5:
                printf("Exiting program...");
                break;
            default:
                printf("Invalid option entered\n");
        }
    } while(option != 5);

    return 0;
}

// initialize a new queue
Queue* queue_init() {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->front = -1;
    queue->rear = -1;
    return queue;
}

// add element to queue
void enqueue(Queue* queue, int element) {
    if(is_full(queue)) {
        printf("Queue is full\n");
        return;
    }
    if(is_empty(queue))
        queue->front++;
    queue->rear++;
    queue->data[queue->rear] = element;
    printf("%d enqueued into queue\n", element);
}

// remove element from queue
int dequeue(Queue* queue) {
    if(is_empty(queue)) {
        printf("Queue is empty\n");
        return -1;
    }
    int element = queue->data[queue->front];
    queue->front++;
    if(queue->front > queue->rear) {
        queue->front = -1;
        queue->rear = -1;
    }
    return element;
}

// display all elements in queue
void display(Queue* queue) {
    if(is_empty(queue)) {
        printf("Queue is empty\n");
        return;
    }
    printf("Queue elements: ");
    for(int i = queue->front; i <= queue->rear; i++)
        printf("%d\t", queue->data[i]);
    printf("\n");
}

// check if queue is empty
int is_empty(Queue* queue) {
    return (queue->front == -1 && queue->rear == -1);
}

// check if queue is full
int is_full(Queue* queue) {
    return ((queue->rear + 1) % QUEUE_MAX_SIZE == queue->front);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 queue_init(void); // weak
__int64 __fastcall enqueue(_QWORD, _QWORD); // weak
__int64 __fastcall dequeue(_QWORD); // weak
__int64 __fastcall display(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-10h] BYREF
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  __int64 v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v6 = 0i64;
  do
  {
    printf("\nSelect an option:\n");
    printf("1. Initialize Queue\n");
    printf("2. Enqueue\n");
    printf("3. Dequeue\n");
    printf("4. Display Queue\n");
    printf("5. Exit\n");
    printf("Enter option number: ");
    scanf("%d", &v5);
    switch ( v5 )
    {
      case 1:
        v6 = queue_init();
        printf("Queue initialized\n");
        break;
      case 2:
        if ( !v6 )
          goto LABEL_11;
        printf("Enter element to be enqueued: ");
        scanf("%d", &v4);
        enqueue(v6, v4);
        break;
      case 3:
        if ( !v6 )
          goto LABEL_11;
        v4 = dequeue(v6);
        if ( v4 != -1 )
          printf("%d dequeued from queue\n", v4);
        break;
      case 4:
        if ( v6 )
          display(v6);
        else
LABEL_11:
          printf("Queue not initialized\n");
        break;
      case 5:
        printf("Exiting program...");
        break;
      default:
        printf("Invalid option entered\n");
        break;
    }
  }
  while ( v5 != 5 );
  return 0;
}
// 1400017BA: using guessed type __int64 queue_init(void);
// 1400017F0: using guessed type __int64 __fastcall enqueue(_QWORD, _QWORD);
// 14000187B: using guessed type __int64 __fastcall dequeue(_QWORD);
// 140001900: using guessed type __int64 __fastcall display(_QWORD);
// 140001AC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Error handling ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

void func(int *p) {
    if (p == NULL) {
        fprintf(stderr, "Error: null pointer passed to function\n");
        exit(EXIT_FAILURE);
    }
    /* function logic here */
}

int main(void)
{
    int *p = NULL;
    int ret;

    p = malloc(sizeof(int));
    if (p == NULL) {
        perror("malloc error");
        exit(EXIT_FAILURE);
    }

    printf("Enter a positive integer: ");
    ret = scanf("%d", p);
    if (ret == 0 || *p <= 0) {
        fprintf(stderr, "Error: invalid input\n");
        free(p);
        exit(EXIT_FAILURE);
    }

    func(p);

    free(p);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall func(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl perror(const char *ErrMsg);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001669) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int *Block; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  Block = (int *)malloc(4ui64);
  if ( !Block )
  {
    perror("malloc error");
    exit(1);
  }
  printf("Enter a positive integer: ");
  if ( !scanf("%d", Block) || *Block <= 0 )
  {
    v3 = __acrt_iob_func(2u);
    fprintf_0(v3, "Error: invalid input\n");
    free(Block);
    exit(1);
  }
  func(Block);
  free(Block);
  return 0;
}
// 140001625: using guessed type __int64 __fastcall func(_QWORD);
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Database simulation ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int id;
    char name[20];
    int age;
    float salary;
} Employee;

int main() {
    Employee employees[50];
    int numEmployees = 0;
    char input[100];
    int inputLength;
    int id;
    char name[20];
    char ageString[3];
    int age;
    char salaryString[10];
    float salary;

    while (1) {
        printf("1: Add an employee\n");
        printf("2: Search for an employee\n");
        printf("3: Display all employees\n");
        printf("4: Quit\n");
        printf("Enter your choice: ");

        fgets(input, 100, stdin);
        inputLength = strlen(input);
        if (input[inputLength-1] == '\n') {
            input[inputLength-1] = '\0';
        }

        switch (atoi(input)) {
            case 1:
                printf("Enter employee id: ");
                fgets(input, 100, stdin);
                id = atoi(input);

                printf("Enter employee name: ");
                fgets(name, 20, stdin);
                name[strlen(name)-1] = '\0';

                printf("Enter employee age: ");
                fgets(ageString, 3, stdin);
                age = atoi(ageString);

                printf("Enter employee salary: ");
                fgets(salaryString, 10, stdin);
                salaryString[strlen(salaryString)-1] = '\0';
                salary = atof(salaryString);

                Employee newEmployee = {.id=id, .age=age, .salary=salary};
                strcpy(newEmployee.name, name);

                employees[numEmployees] = newEmployee;
                numEmployees++;

                printf("Employee added successfully.\n");
                break;
            case 2:
                printf("Enter employee id: ");
                fgets(input, 100, stdin);
                id = atoi(input);

                for (int i = 0; i < numEmployees; i++) {
                    if (employees[i].id == id) {
                        printf("ID: %d\n", employees[i].id);
                        printf("Name: %s\n", employees[i].name);
                        printf("Age: %d\n", employees[i].age);
                        printf("Salary: %.2f\n", employees[i].salary);
                    }
                }
                break;
            case 3:
                for (int i = 0; i < numEmployees; i++) {
                    printf("ID: %d\n", employees[i].id);
                    printf("Name: %s\n", employees[i].name);
                    printf("Age: %d\n", employees[i].age);
                    printf("Salary: %.2f\n", employees[i].salary);
                    printf("\n");
                }
                break;
            case 4:
                printf("Goodbye!\n");
                exit(0);
            default:
                printf("Invalid choice. Try again.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
// int __cdecl atoi(const char *String);
// double __cdecl atof(const char *String);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  int v4; // eax
  FILE *v5; // rax
  FILE *v6; // rax
  FILE *v7; // rax
  FILE *v8; // rax
  unsigned int v9; // xmm0_4
  _QWORD *v10; // rcx
  __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  FILE *v13; // rax
  __int64 v14; // [rsp+20h] [rbp-60h] BYREF
  __int64 v15; // [rsp+28h] [rbp-58h]
  __int64 v16; // [rsp+30h] [rbp-50h]
  unsigned __int64 v17; // [rsp+38h] [rbp-48h]
  char v18[10]; // [rsp+43h] [rbp-3Dh] BYREF
  char String[3]; // [rsp+4Dh] [rbp-33h] BYREF
  char Str[32]; // [rsp+50h] [rbp-30h] BYREF
  char Buffer[16]; // [rsp+70h] [rbp-10h] BYREF
  _DWORD v22[426]; // [rsp+80h] [rbp+0h] BYREF
  int v23; // [rsp+728h] [rbp+6A8h]
  unsigned int v24; // [rsp+72Ch] [rbp+6ACh]
  int v25; // [rsp+730h] [rbp+6B0h]
  int i; // [rsp+734h] [rbp+6B4h]
  int j; // [rsp+738h] [rbp+6B8h]
  int v28; // [rsp+73Ch] [rbp+6BCh]

  _main(argc, argv, envp);
  v28 = 0;
  while ( 1 )
  {
    printf("1: Add an employee\n");
    printf("2: Search for an employee\n");
    printf("3: Display all employees\n");
    printf("4: Quit\n");
    printf("Enter your choice: ");
    v3 = __acrt_iob_func(0);
    fgets(Buffer, 100, v3);
    v25 = strlen(Buffer);
    if ( Buffer[v25 - 1] == 10 )
      Buffer[v25 - 1] = 0;
    v4 = atoi(Buffer);
    if ( v4 == 4 )
    {
      printf("Goodbye!\n");
      exit(0);
    }
    if ( v4 > 4 )
    {
LABEL_22:
      printf("Invalid choice. Try again.\n");
    }
    else
    {
      switch ( v4 )
      {
        case 3:
          for ( i = 0; i < v28; ++i )
          {
            printf("ID: %d\n", (unsigned int)v22[8 * i + 24]);
            printf("Name: %s\n", (const char *)&v22[8 * i + 25]);
            printf("Age: %d\n", (unsigned int)v22[8 * i + 30]);
            printf("Salary: %.2f\n", *(float *)&v22[8 * i + 31]);
            printf("\n");
          }
          break;
        case 1:
          printf("Enter employee id: ");
          v5 = __acrt_iob_func(0);
          fgets(Buffer, 100, v5);
          v24 = atoi(Buffer);
          printf("Enter employee name: ");
          v6 = __acrt_iob_func(0);
          fgets(Str, 20, v6);
          Str[strlen(Str) - 1] = 0;
          printf("Enter employee age: ");
          v7 = __acrt_iob_func(0);
          fgets(String, 3, v7);
          v23 = atoi(String);
          printf("Enter employee salary: ");
          v8 = __acrt_iob_func(0);
          fgets(v18, 10, v8);
          v18[strlen(v18) - 1] = 0;
          *(float *)&v9 = atof(v18);
          v22[425] = v9;
          v15 = 0i64;
          v16 = 0i64;
          v14 = v24;
          v17 = __PAIR64__(v9, v23);
          strcpy((char *)&v14 + 4, Str);
          v10 = &v22[8 * v28 + 24];
          v11 = v15;
          *v10 = v14;
          v10[1] = v11;
          v12 = v17;
          v10[2] = v16;
          v10[3] = v12;
          ++v28;
          printf("Employee added successfully.\n");
          break;
        case 2:
          printf("Enter employee id: ");
          v13 = __acrt_iob_func(0);
          fgets(Buffer, 100, v13);
          v24 = atoi(Buffer);
          for ( j = 0; j < v28; ++j )
          {
            if ( v24 == v22[8 * j + 24] )
            {
              printf("ID: %d\n", (unsigned int)v22[8 * j + 24]);
              printf("Name: %s\n", (const char *)&v22[8 * j + 25]);
              printf("Age: %d\n", (unsigned int)v22[8 * j + 30]);
              printf("Salary: %.2f\n", *(float *)&v22[8 * j + 31]);
            }
          }
          break;
        default:
          goto LABEL_22;
      }
    }
  }
}
// 140001680: conditional instruction was optimized away because eax.4<3
// 140001BD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[16];
// 140001591: using guessed type char Str[32];
// 140001591: using guessed type char var_6FD[10];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: light-weight
#include<stdio.h>
#include<stdlib.h>

int main(){
    FILE *filepointer;
    char ch, filename[20], content[200];

    printf("Enter file name: ");
    scanf("%s", filename);

    printf("Enter the content of the file: ");
    scanf(" %[^\n]s", content);

    // Write content to the file
    filepointer = fopen(filename, "w"); //Open file for Writing
    if(filepointer == NULL){
        printf("Can't create file!\n");
        exit(0);
    }

    fprintf(filepointer, "%s", content); //Write content to file
    printf("Content successfully added to file %s\n", filename);
    fclose(filepointer);

    // Read content from the file
    filepointer = fopen(filename, "r"); //Open file for Reading
    if(filepointer == NULL){
        printf("Can't open file!\n");
        exit(0);
    }

    printf("Content of file %s is: \n", filename);
    while((ch = fgetc(filepointer)) != EOF){ //Read content from file until end of file
        printf("%c", ch);
    }
    printf("\n");

    fclose(filepointer);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[208]; // [rsp+20h] [rbp-60h] BYREF
  char FileName[23]; // [rsp+F0h] [rbp+70h] BYREF
  char v6; // [rsp+107h] [rbp+87h]
  FILE *Stream; // [rsp+108h] [rbp+88h]

  _main(argc, argv, envp);
  printf("Enter file name: ");
  scanf("%s", FileName);
  printf("Enter the content of the file: ");
  scanf(" %[^\n]s", v4);
  Stream = fopen(FileName, "w");
  if ( !Stream )
  {
    printf("Can't create file!\n");
    exit(0);
  }
  fprintf_0(Stream, "%s", v4);
  printf("Content successfully added to file %s\n", FileName);
  fclose(Stream);
  Stream = fopen(FileName, "r");
  if ( !Stream )
  {
    printf("Can't open file!\n");
    exit(0);
  }
  printf("Content of file %s is: \n", FileName);
  while ( 1 )
  {
    v6 = fgetc(Stream);
    if ( v6 == -1 )
      break;
    printf("%c", (unsigned int)v6);
  }
  printf("\n");
  fclose(Stream);
  return 0;
}
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: System event logger ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define LOG_FILE "event_log.txt"

/* Function to log events to the file */
void log_event(char* event) {
   time_t t = time(NULL);
   struct tm tm = *localtime(&t);
   FILE* log_file = fopen(LOG_FILE, "a");
   fprintf(log_file, "%d/%02d/%02d %02d:%02d:%02d - %s\n", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, event);
   fclose(log_file);
}

int main() {
   log_event("Application started");

   /* Sample event */
   int a = 10, b = 20;
   if (a < b) {
      log_event("a is less than b");
   } else {
      log_event("b is less than or equal to a");
   }

   log_event("Application exited");

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall log_event(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000169B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  log_event("Application started");
  log_event("a is less than b");
  log_event("Application exited");
  return 0;
}
// 1400015C1: using guessed type __int64 __fastcall log_event(_QWORD);
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Log analysis ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_LINE_SIZE 1000

//Function to parse a line of the log file and store relevant information
void parseLogLine(char* line, char* date, char* time, char* ip, char* method, char* path, char* protocol, int* status, int* bytes){
    sscanf(line, "%s %s %s %s %s %d %d", date, time, ip, method, path, status, bytes);
    if(strcmp(protocol, "HTTP/1.0")==0 || strcmp(protocol, "HTTP/1.1")==0 || strcmp(protocol, "")==0){
        //Protocol accepted
    }
    else{
        *status = -1; //Invalid protocol
    }
}

//Function to read the log file line by line and parse each line using the parseLogLine function
void readLogFile(char* filename){
    FILE* file = fopen(filename, "r");
    if(file == NULL){
        printf("Error: Cannot open file %s\n", filename);
        exit(1);
    }
    char line[MAX_LINE_SIZE];
    char date[MAX_LINE_SIZE];
    char time[MAX_LINE_SIZE];
    char ip[MAX_LINE_SIZE];
    char method[MAX_LINE_SIZE];
    char path[MAX_LINE_SIZE];
    char protocol[MAX_LINE_SIZE];
    int status;
    int bytes;
    int lineNum = 0;
    int errorLines = 0;
    int successfulRequests = 0;
    int totalBytes = 0;
    while(fgets(line, MAX_LINE_SIZE, file) != NULL){
        lineNum++;
        parseLogLine(line, date, time, ip, method, path, protocol, &status, &bytes);
        if(status==-1){
            printf("Error: Invalid protocol at line %d\n%s\n", lineNum, line);
            errorLines++;
        }
        else if(status>=400 && status<=499){
            printf("Warning: Client error at line %d\n%s\n", lineNum, line);
            errorLines++;
        }
        else if(status>=500 && status<=599){
            printf("Warning: Server error at line %d\n%s\n", line);
            errorLines++;
        }
        else{
            successfulRequests++;
            totalBytes += bytes;
        }
    }
    printf("Processed %d lines of log file %s\n", lineNum, filename);
    printf("%d successful requests with total of %d bytes\n", successfulRequests, totalBytes);
    printf("%d errors detected\n", errorLines);
    fclose(file);
}

int main(){
    char* filename = "access.log";
    readLogFile(filename);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall readLogFile(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018C4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  readLogFile("access.log");
  return 0;
}
// 140001687: using guessed type __int64 __fastcall readLogFile(_QWORD);
// 1400019B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: mathematical
#include<stdio.h>
#include<math.h>

int main()
{
   int n, i, j, space;
   printf("Enter the value of n: ");
   scanf("%d",&n);
   
   for(i=n; i>=1; i--)
   {
      for(space=0; space<n-i; space++)
         printf("  ");
         
      for(j=i; j<=2*i-1; j++)
         printf("%d ",j);
        
      for(j=0; j<i-1; j++)
         printf("%d ",j+i);
        
      printf("\n");
   }
    
   for(i=2; i<=n; i++)
   {
      for(space=0; space<n-i; space++)
         printf("  ");
         
      for(j=i; j<=2*i-1; j++)
         printf("%d ",j);
        
      for(j=0; j<i-1; j++)
         printf("%d ",j+i);
        
      printf("\n");
   }
   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-10h] BYREF
  int j; // [rsp+24h] [rbp-Ch]
  int k; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the value of n: ");
  scanf("%d", &v4);
  for ( i = v4; i > 0; --i )
  {
    for ( j = 0; j < v4 - i; ++j )
      printf("  ");
    for ( k = i; k < 2 * i; ++k )
      printf("%d ", (unsigned int)k);
    for ( k = 0; k < i - 1; ++k )
      printf("%d ", (unsigned int)(k + i));
    printf("\n");
  }
  for ( i = 2; i <= v4; ++i )
  {
    for ( j = 0; j < v4 - i; ++j )
      printf("  ");
    for ( k = i; k < 2 * i; ++k )
      printf("%d ", (unsigned int)k);
    for ( k = 0; k < i - 1; ++k )
      printf("%d ", (unsigned int)(k + i));
    printf("\n");
  }
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Ebook reader ; Style: excited
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50

typedef struct {
    char word[MAX_WORD_LENGTH];
    int count;
} Word;

int compare_words(const void* a, const void* b) {
    const Word* word1 = (const Word*)a;
    const Word* word2 = (const Word*)b;
    return word2->count - word1->count;
}

void display_exciting_message() {
    printf("\n\n\tWelcome to the C Ebook Reader!");
    printf("\n\tPrepare to embark on a thrilling journey through the world of C programming!");
    printf("\n\tFasten your seatbelt and get ready to learn some amazing concepts!");
}

void display_word_cloud(Word* words, int num_words) {
    printf("\n\n\tHere's a word cloud of the most frequently occurring words in the ebook:\n");
    for (int i = 0; i < num_words; i++) {
        for (int j = 0; j < words[i].count; j++) {
            printf("* ");
        }
        printf("%s\n", words[i].word);
    }
}

int main(int argc, char** argv) {
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    FILE* fp = fopen(argv[1], "r");
    if (!fp) {
        printf("Error: could not open file %s\n", argv[1]);
        return 1;
    }
    Word* words = malloc(sizeof(Word));
    int num_words = 0;
    char word[MAX_WORD_LENGTH] = { 0 };
    int c;
    while ((c = fgetc(fp)) != EOF) {
        if (isspace(c)) {
            if (strlen(word) > 0) {
                int found = 0;
                for (int i = 0; i < num_words; i++) {
                    if (strcmp(word, words[i].word) == 0) {
                        words[i].count++;
                        found = 1;
                        break;
                    }
                }
                if (!found || num_words == 0) {
                    num_words++;
                    words = realloc(words, num_words * sizeof(Word));
                    strcpy(words[num_words - 1].word, word);
                    words[num_words - 1].count = 1;
                }
            }
            memset(word, 0, sizeof(word));
        } else {
            strncat(word, &c, 1);
        }
    }
    qsort(words, num_words, sizeof(Word), compare_words);
    display_exciting_message();
    display_word_cloud(words, num_words);
    fclose(fp);
    free(words);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __cdecl compare_words(const void *, const void *); // idb
__int64 display_exciting_message(void); // weak
__int64 __fastcall display_word_cloud(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strncat(char *Destination, const char *Source, size_t Count);
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl realloc(void *Block, size_t Size);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fgetc(FILE *Stream);
// int __cdecl fclose(FILE *Stream);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isspace)(int C);


//----- (00000001400016B2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int C; // [rsp+2Ch] [rbp-64h] BYREF
  char Str1[64]; // [rsp+30h] [rbp-60h] BYREF
  FILE *Stream; // [rsp+70h] [rbp-20h]
  int i; // [rsp+7Ch] [rbp-14h]
  int v8; // [rsp+80h] [rbp-10h]
  unsigned int v9; // [rsp+84h] [rbp-Ch]
  void *Block; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc == 2 )
  {
    Stream = fopen(argv[1], "r");
    if ( Stream )
    {
      Block = malloc(0x38ui64);
      v9 = 0;
      memset(Str1, 0, 50);
      while ( 1 )
      {
        C = fgetc(Stream);
        if ( C == -1 )
          break;
        if ( isspace(C) )
        {
          if ( Str1[0] )
          {
            v8 = 0;
            for ( i = 0; i < (int)v9; ++i )
            {
              if ( !strcmp(Str1, (const char *)Block + 56 * i) )
              {
                ++*((_DWORD *)Block + 14 * i + 13);
                v8 = 1;
                break;
              }
            }
            if ( !v8 || !v9 )
            {
              Block = realloc(Block, 56i64 * (int)++v9);
              strcpy((char *)Block + 56 * (int)v9 - 56, Str1);
              *((_DWORD *)Block + 14 * (int)v9 - 1) = 1;
            }
          }
          memset(Str1, 0, 0x32ui64);
        }
        else
        {
          strncat(Str1, (const char *)&C, 1ui64);
        }
      }
      qsort(Block, (int)v9, 0x38ui64, compare_words);
      display_exciting_message();
      display_word_cloud(Block, v9);
      fclose(Stream);
      free(Block);
      return 0;
    }
    else
    {
      printf("Error: could not open file %s\n", argv[1]);
      return 1;
    }
  }
  else
  {
    printf("Usage: %s <filename>\n", *argv);
    return 1;
  }
}
// 1400015C9: using guessed type __int64 display_exciting_message(void);
// 140001605: using guessed type __int64 __fastcall display_word_cloud(_QWORD, _QWORD);
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=149 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Queue ; Style: grateful
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 5

struct queue {
    int items[MAX_SIZE];
    int front;
    int rear;
};

struct queue* createQueue() {
    struct queue* q = malloc(sizeof(struct queue));
    q->front = -1;
    q->rear = -1;
    return q;
}

int isFull(struct queue* q) {
    if(q->rear == MAX_SIZE - 1) {
        return 1;
    } else {
        return 0;
    }
}

int isEmpty(struct queue* q) {
    if(q->front == -1 && q->rear == -1) {
        return 1;
    } else {
        return 0;
    }
}

void enqueue(struct queue* q, int value) {
    if(isFull(q)) {
        printf("Queue is full! Cannot add another item.\n");
    } else {
        if(q->front == -1) {
            q->front = 0;
        }
        q->rear++;
        q->items[q->rear] = value;
        printf("%d added to the queue.\n", value);
    }
}

int dequeue(struct queue* q) {
    int item = 0;
    if(isEmpty(q)) {
        printf("Queue is empty! Cannot dequeue anything.\n");
        return -1;
    } else {
        item = q->items[q->front];
        q->front++;
    }
    return item;
}

void printQueue(struct queue* q) {
    if(isEmpty(q)) {
        printf("Queue is empty!\n");
    } else {
        printf("Current queue:\n");
        for(int i = q->front; i <= q->rear; i++) {
            printf("%d ", q->items[i]);
        }
        printf("\n");
    }
}

int main() {
    struct queue* q = createQueue();

    enqueue(q, 1);
    enqueue(q, 2);
    enqueue(q, 3);
    enqueue(q, 4);
    enqueue(q, 5);
    printf("\n");
    printQueue(q);

    dequeue(q);
    dequeue(q);
    printf("\n");
    printQueue(q);

    enqueue(q, 6);
    printf("\n");
    printQueue(q);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 createQueue(void); // weak
__int64 __fastcall enqueue(_QWORD, _QWORD); // weak
__int64 __fastcall dequeue(_QWORD); // weak
__int64 __fastcall printQueue(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001788) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 Queue; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  Queue = createQueue();
  enqueue(Queue, 1i64);
  enqueue(Queue, 2i64);
  enqueue(Queue, 3i64);
  enqueue(Queue, 4i64);
  enqueue(Queue, 5i64);
  printf("\n");
  printQueue(Queue);
  dequeue(Queue);
  dequeue(Queue);
  printf("\n");
  printQueue(Queue);
  enqueue(Queue, 6i64);
  printf("\n");
  printQueue(Queue);
  return 0;
}
// 140001591: using guessed type __int64 createQueue(void);
// 140001617: using guessed type __int64 __fastcall enqueue(_QWORD, _QWORD);
// 14000169B: using guessed type __int64 __fastcall dequeue(_QWORD);
// 1400016FF: using guessed type __int64 __fastcall printQueue(_QWORD);
// 140001930: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File Backup System ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILENAME_SIZE 20
#define MAX_NUM_FILES 10

typedef struct {
    char filename[MAX_FILENAME_SIZE];
    char contents[1024];
} File;

typedef struct {
    File files[MAX_NUM_FILES];
    int num_files;
} Backup;

void add_file(Backup* backup, char* filename, char* contents) {
    if (backup->num_files == MAX_NUM_FILES) {
        printf("Backup is full, cannot add file %s\n", filename);
        return;
    }
    strcpy(backup->files[backup->num_files].filename, filename);
    strcpy(backup->files[backup->num_files].contents, contents);
    backup->num_files++;
    printf("File %s added to backup\n", filename);
}

void remove_file(Backup* backup, char* filename) {
    int i, index = -1;
    for (i = 0; i < backup->num_files; i++) {
        if (strcmp(backup->files[i].filename, filename) == 0) {
            index = i;
            break;
        }
    }
    if (index == -1) {
        printf("File %s not found in backup\n", filename);
        return;
    }
    for (i = index; i < backup->num_files-1; i++) {
        backup->files[i] = backup->files[i+1];
    }
    backup->num_files--;
    printf("File %s removed from backup\n", filename);
}

void list_files(Backup* backup) {
    int i;
    printf("Backup contents:\n");
    for (i = 0; i < backup->num_files; i++) {
        printf("%s\n", backup->files[i].filename);
    }
}

int main() {
    Backup backup = {0};
    char filename[MAX_FILENAME_SIZE];
    char contents[1024];
    int choice;
    while (1) {
        printf("Backup menu:\n");
        printf("1) Add file\n");
        printf("2) Remove file\n");
        printf("3) List files\n");
        printf("4) Quit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                printf("Enter filename: ");
                scanf("%s", filename);
                printf("Enter contents: ");
                scanf("%s", contents);
                add_file(&backup, filename, contents);
                break;
            case 2:
                printf("Enter filename: ");
                scanf("%s", filename);
                remove_file(&backup, filename);
                break;
            case 3:
                list_files(&backup);
                break;
            case 4:
                printf("Terminating backup system...\n");
                exit(0);
            default:
                printf("Invalid choice, please try again\n");
                break;
        }
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_file(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall remove_file(_QWORD, _QWORD); // weak
__int64 __fastcall list_files(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memset(void *, int Val, size_t Size);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001860) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+2Ch] [rbp-54h] BYREF
  char v4[1024]; // [rsp+30h] [rbp-50h] BYREF
  char v5[32]; // [rsp+430h] [rbp+3B0h] BYREF
  char v6[10448]; // [rsp+450h] [rbp+3D0h] BYREF

  _main(argc, argv, envp);
  memset(v6, 0, 0x28CCui64);
  while ( 1 )
  {
    printf("Backup menu:\n");
    printf("1) Add file\n");
    printf("2) Remove file\n");
    printf("3) List files\n");
    printf("4) Quit\n");
    printf("Enter choice: ");
    scanf("%d", &v3);
    if ( v3 == 4 )
    {
      printf("Terminating backup system...\n");
      exit(0);
    }
    if ( v3 > 4 )
    {
LABEL_12:
      printf("Invalid choice, please try again\n");
    }
    else
    {
      switch ( v3 )
      {
        case 3:
          list_files(v6);
          break;
        case 1:
          printf("Enter filename: ");
          scanf("%s", v5);
          printf("Enter contents: ");
          scanf("%s", v4);
          add_file(v6, v5, v4);
          break;
        case 2:
          printf("Enter filename: ");
          scanf("%s", v5);
          remove_file(v6, v5);
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 140001928: conditional instruction was optimized away because %var_2CF4.4<3
// 1400015E2: using guessed type __int64 __fastcall add_file(_QWORD, _QWORD, _QWORD);
// 1400016A9: using guessed type __int64 __fastcall remove_file(_QWORD, _QWORD);
// 1400017FC: using guessed type __int64 __fastcall list_files(_QWORD);
// 140001AE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: romantic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() 
{
    char name[20];
    int birth_year, curr_year, age, lucky_number, fortune;

    printf("Welcome to the Love and Destiny Fortune Teller Program.\n");
    printf("Please enter your name: ");
    scanf("%s", name);
    printf("Please enter your birth year: ");
    scanf("%d", &birth_year);
    printf("Please enter the current year: ");
    scanf("%d", &curr_year);

    age = curr_year - birth_year;

    printf("You are %d years old, %s.\n", age, name);
    printf("Now, please enter a number between 1 and 100: ");
    scanf("%d", &lucky_number);

    srand(time(0));
    fortune = rand() % 5;
    switch(fortune)
    {
        case 0:
            printf("\nYour destiny awaits...");
            printf("\n\n%s, it is written in the stars that you will meet your soulmate in the near future.\n", name);
            printf("You must be patient and believe in true love. Remember, good things come to those who wait.\n");
            printf("Your lucky number %d will bring you great fortune in all aspects of your life.\n", lucky_number);
            break;

        case 1:
            printf("\nYour destiny awaits...");
            printf("\n\n%s, you will soon encounter a difficult decision regarding love.\n", name);
            printf("Remember to listen to your heart and trust your instincts.\n");
            printf("Your lucky number %d will guide you towards making the right choice.\n", lucky_number);
            break;

        case 2:
            printf("\nYour destiny awaits...");
            printf("\n\n%s, you may face some obstacles in your love life in the upcoming days.\n", name);
            printf("But please don't lose heart. Remember, true love never runs smooth.\n");
            printf("Your lucky number %d will be your guide through the tough times.\n", lucky_number);
            break;

        case 3:
            printf("\nYour destiny awaits...");
            printf("\n\n%s, your romantic life will be filled with passion and excitement in the coming days.\n", name);
            printf("You will experience things you never thought possible.\n");
            printf("Your lucky number %d will bring you the love and happiness you deserve.\n", lucky_number);
            break;

        case 4:
            printf("\nYour destiny awaits...");
            printf("\n\n%s, your love life will take a surprising turn in the upcoming weeks.\n", name);
            printf("Be ready for a twist in the plot... this could be just what you need to find your true soulmate.\n");
            printf("Your lucky number %d will play a crucial role in this new chapter of your life.\n", lucky_number);
            break;

        default:
            printf("\nHmmm... something seems off.");
            printf("\nPlease try again later.");
            break;
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+24h] [rbp-2Ch] BYREF
  int v6; // [rsp+28h] [rbp-28h] BYREF
  int v7; // [rsp+2Ch] [rbp-24h] BYREF
  char v8[24]; // [rsp+30h] [rbp-20h] BYREF
  int v9; // [rsp+48h] [rbp-8h]
  int v10; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Love and Destiny Fortune Teller Program.\n");
  printf("Please enter your name: ");
  scanf("%s", v8);
  printf("Please enter your birth year: ");
  scanf("%d", &v7);
  printf("Please enter the current year: ");
  scanf("%d", &v6);
  v10 = v6 - v7;
  printf("You are %d years old, %s.\n", (unsigned int)(v6 - v7), v8);
  printf("Now, please enter a number between 1 and 100: ");
  scanf("%d", &v5);
  v3 = time(0i64);
  srand(v3);
  v9 = rand() % 5;
  switch ( v9 )
  {
    case 0:
      printf("\nYour destiny awaits...");
      printf("\n\n%s, it is written in the stars that you will meet your soulmate in the near future.\n", v8);
      printf("You must be patient and believe in true love. Remember, good things come to those who wait.\n");
      printf("Your lucky number %d will bring you great fortune in all aspects of your life.\n", v5);
      break;
    case 1:
      printf("\nYour destiny awaits...");
      printf("\n\n%s, you will soon encounter a difficult decision regarding love.\n", v8);
      printf("Remember to listen to your heart and trust your instincts.\n");
      printf("Your lucky number %d will guide you towards making the right choice.\n", v5);
      break;
    case 2:
      printf("\nYour destiny awaits...");
      printf("\n\n%s, you may face some obstacles in your love life in the upcoming days.\n", v8);
      printf("But please don't lose heart. Remember, true love never runs smooth.\n");
      printf("Your lucky number %d will be your guide through the tough times.\n", v5);
      break;
    case 3:
      printf("\nYour destiny awaits...");
      printf("\n\n%s, your romantic life will be filled with passion and excitement in the coming days.\n", v8);
      printf("You will experience things you never thought possible.\n");
      printf("Your lucky number %d will bring you the love and happiness you deserve.\n", v5);
      break;
    case 4:
      printf("\nYour destiny awaits...");
      printf("\n\n%s, your love life will take a surprising turn in the upcoming weeks.\n", v8);
      printf("Be ready for a twist in the plot... this could be just what you need to find your true soulmate.\n");
      printf("Your lucky number %d will play a crucial role in this new chapter of your life.\n", v5);
      break;
    default:
      printf("\nHmmm... something seems off.");
      printf("\nPlease try again later.");
      break;
  }
  return 0;
}
// 1400019A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Data structures visualization ; Style: Ada Lovelace
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Define a structure representing a card
typedef struct {
    int value;
    char suit;
} Card;

// Define a function to generate a shuffled deck of cards
Card* generate_deck() {
    Card* deck = (Card*)malloc(52*sizeof(Card)); // Allocate memory for 52 cards
    char suits[4] = {'H', 'D', 'S', 'C'}; // Define the four suits
    int values[13] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}; // Define the thirteen card values
    int index = 0;
    // Loop through all combinations of suits and values, adding each card to the deck
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 13; j++) {
            deck[index].value = values[j];
            deck[index].suit = suits[i];
            index++;
        }
    }
    // Shuffle the deck using the Fisher-Yates algorithm
    for (int i = 51; i > 0; i--) {
        int j = rand() % (i+1);
        Card temp = deck[i];
        deck[i] = deck[j];
        deck[j] = temp;
    }
    return deck;
}

// Define a function to print a card in a visually appealing way
void print_card(Card card) {
    if (card.value == 10) {
        printf(" %c10", card.suit);
    }
    else {
        printf(" %c%d ", card.suit, card.value);
    }
}

// Define a function to print a visual representation of a hand of cards
void print_hand(Card* hand, int size) {
    for (int i = 0; i < size; i++) {
        print_card(hand[i]);
        printf("|");
    }
    printf("\n");
}

// Define the main function
int main() {
    srand(time(NULL)); // Seed the random number generator
    Card* deck = generate_deck(); // Generate a shuffled deck of cards
    printf("Here is a shuffled deck of cards:\n");
    print_hand(deck, 52); // Print the deck
    int i = 0;
    int j = 0;
    Card temp;
    // Sort the cards using a modified bubble sort algorithm
    for (i = 0; i < 52; i++) {
        for (j = 0; j < 52-i-1; j++) {
            if (deck[j].value > deck[j+1].value) {
                temp = deck[j];
                deck[j] = deck[j+1];
                deck[j+1] = temp;
                printf("Swapping:");
                print_hand(&deck[j], 2); // Print the two cards being swapped
            }
        }
    }
    printf("Here is the sorted deck of cards:\n");
    print_hand(deck, 52); // Print the sorted deck
    free(deck); // Free the heap memory occupied by the deck
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 generate_deck(void); // weak
__int64 __fastcall print_hand(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// void __cdecl free(void *Block);


//----- (00000001400017EA) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5; // [rsp+28h] [rbp-18h]
  _QWORD *Block; // [rsp+30h] [rbp-10h]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  Block = (_QWORD *)generate_deck();
  printf("Here is a shuffled deck of cards:\n");
  print_hand(Block, 52i64);
  for ( i = 0; i <= 51; ++i )
  {
    for ( j = 0; j < 51 - i; ++j )
    {
      if ( SLODWORD(Block[j]) > SLODWORD(Block[j + 1]) )
      {
        v5 = Block[j];
        Block[j] = Block[j + 1];
        Block[j + 1] = v5;
        printf("Swapping:");
        print_hand(&Block[j], 2i64);
      }
    }
  }
  printf("Here is the sorted deck of cards:\n");
  print_hand(Block, 52i64);
  free(Block);
  return 0;
}
// 1400015B0: using guessed type __int64 generate_deck(void);
// 140001785: using guessed type __int64 __fastcall print_hand(_QWORD, _QWORD);
// 140001A40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Word Count Tool ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 50

struct node {
    char word[MAX_WORD_LENGTH];
    int count;
    struct node *next;
};

void add_word(struct node **head, char *word) {
    if (*head == NULL) {
        *head = malloc(sizeof(struct node));
        strcpy((*head)->word, word);
        (*head)->count = 1;
        (*head)->next = NULL;
        return;
    }

    struct node *prev_node = NULL;
    struct node *curr_node = *head;

    while (curr_node != NULL) {
        if (strcmp(curr_node->word, word) == 0) {
            curr_node->count += 1;
            return;
        }

        prev_node = curr_node;
        curr_node = curr_node->next;
    }

    prev_node->next = malloc(sizeof(struct node));
    strcpy(prev_node->next->word, word);
    prev_node->next->count = 1;
    prev_node->next->next = NULL;
}

void print_word_counts(struct node *head) {
    struct node *curr_node = head;
    while (curr_node != NULL) {
        printf("%s: %d\n", curr_node->word, curr_node->count);
        curr_node = curr_node->next;
    }
}

int main(int argc, char **argv) {
    FILE *fp;
    char filename[MAX_WORD_LENGTH];
    char word[MAX_WORD_LENGTH];
    struct node *word_counts = NULL;

    if (argc < 2) {
        printf("Usage: %s filename\n", argv[0]);
        exit(1);
    }

    strcpy(filename, argv[1]);

    fp = fopen(filename, "r");
    if (fp == NULL) {
        printf("Error opening file: %s\n", filename);
        exit(1);
    }

    while (fscanf(fp, "%s", word) != EOF) {
        char *p = word;
        while (*p != '\0') {
            *p = tolower(*p);
            p++;
        }
        add_word(&word_counts, word);
    }

    fclose(fp);

    print_word_counts(word_counts);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_word(_QWORD, _QWORD); // weak
__int64 __fastcall print_word_counts(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strcpy(char *Destination, const char *Source);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *tolower)(int C);


//----- (0000000140001735) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-98h] BYREF
  char v5[64]; // [rsp+30h] [rbp-90h] BYREF
  char Destination[64]; // [rsp+70h] [rbp-50h] BYREF
  FILE *Stream; // [rsp+B0h] [rbp-10h]
  char *i; // [rsp+B8h] [rbp-8h]

  _main(argc, argv, envp);
  v4 = 0i64;
  if ( argc <= 1 )
  {
    printf("Usage: %s filename\n", *argv);
    exit(1);
  }
  strcpy(Destination, argv[1]);
  Stream = fopen(Destination, "r");
  if ( !Stream )
  {
    printf("Error opening file: %s\n", Destination);
    exit(1);
  }
  while ( fscanf(Stream, "%s", v5) != -1 )
  {
    for ( i = v5; *i; ++i )
      *i = tolower(*i);
    add_word(&v4, v5);
  }
  fclose(Stream);
  print_word_counts(v4);
  return 0;
}
// 1400015D4: using guessed type __int64 __fastcall add_word(_QWORD, _QWORD);
// 1400016E4: using guessed type __int64 __fastcall print_word_counts(_QWORD);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Cat Language Translator ; Style: Ada Lovelace
#include <stdio.h>
#include <string.h>

/* Constants */
#define MAX_INPUT_LENGTH 100
#define MAX_OUTPUT_LENGTH 1000

/* Function prototypes */
void translate(char *input, char *output);

/* Main function */
int main()
{
    // Get the input from the user
    char input[MAX_INPUT_LENGTH];
    printf("Enter text in Cat language: ");
    fgets(input, MAX_INPUT_LENGTH, stdin);

    // Translate the input and print the output
    char output[MAX_OUTPUT_LENGTH];
    translate(input, output);
    printf("Translated text: %s\n", output);

    return 0;
}

/* Translate function */
void translate(char *input, char *output)
{
    // Initialize the output string
    strcpy(output, "");

    // Loop through each character of the input string
    for(int i = 0; i < strlen(input); i++)
    {
        // Check if the character is a cat sound
        if(input[i] == 'M')
        {
            strcat(output, "Meow ");
        }
        else if(input[i] == 'P')
        {
            strcat(output, "Purr ");
        }
        else if(input[i] == 'H')
        {
            strcat(output, "Hiss ");
        }
        else
        {
            // If the character is not a cat sound, just copy it over
            char temp[2];
            temp[0] = input[i];
            temp[1] = '\0';
            strcat(output, temp);
        }
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall translate(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char v5[1008]; // [rsp+20h] [rbp-60h] BYREF
  char Buffer[112]; // [rsp+410h] [rbp+390h] BYREF

  _main(argc, argv, envp);
  printf("Enter text in Cat language: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  translate(Buffer, v5);
  printf("Translated text: %s\n", v5);
  return 0;
}
// 140001614: using guessed type __int64 __fastcall translate(_QWORD, _QWORD);
// 1400017F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Terminal Based Game ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {

    int userChoice, computerChoice, flag = 1, userScore = 0, computerScore = 0;
    
    printf("Welcome to Rock-Paper-Scissors!\n");

    while (flag) {
    
        printf("\nChoose your weapon:\n");
        printf("1. Rock\n");
        printf("2. Paper\n");
        printf("3. Scissors\n");
        printf("4. Quit game\n");
        
        scanf("%d", &userChoice);

        switch(userChoice) {

            case 1: 
                printf("\nYou chose Rock!\n");
                break;

            case 2:
                printf("\nYou chose Paper!\n");
                break;

            case 3:
                printf("\nYou chose Scissors!\n");
                break;

            case 4:
                printf("\nThank you for playing!\n");
                flag = 0;
                break;

            default:
                printf("\nInvalid choice! Please try again.\n");
                continue;
        }

        if (flag == 0) {
            break;
        }

        srand(time(NULL));
        computerChoice = rand() % 3 + 1;

        switch(computerChoice) {

            case 1: 
                printf("The computer chose Rock!\n");
                break;

            case 2:
                printf("The computer chose Paper!\n");
                break;

            case 3:
                printf("The computer chose Scissors!\n");
                break;

            default:
                printf("The computer has malfunctioned.\n");
                break;
        }

        if (userChoice == 1 && computerChoice == 3) {
            printf("\nRock crushes Scissors! You win!\n");
            userScore++;
        }
        else if (userChoice == 1 && computerChoice == 2) {
            printf("\nPaper covers Rock! You lose!\n");
            computerScore++;
        }
        else if (userChoice == 2 && computerChoice == 1) {
            printf("\nPaper covers Rock! You win!\n");
            userScore++;
        }
        else if (userChoice == 2 && computerChoice == 3) {
            printf("\nScissors cuts Paper! You lose!\n");
            computerScore++;
        }
        else if (userChoice == 3 && computerChoice == 1) {
            printf("\nRock crushes Scissors! You lose!\n");
            computerScore++;
        }
        else if (userChoice == 3 && computerChoice == 2) {
            printf("\nScissors cuts Paper! You win!\n");
            userScore++;
        }
        else {
            printf("\nIt's a tie!\n");
        }

        printf("\nScore:\n You: %d\n Computer: %d\n", userScore, computerScore);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // edx
  int v6; // [rsp+2Ch] [rbp-14h] BYREF
  int v7; // [rsp+30h] [rbp-10h]
  unsigned int v8; // [rsp+34h] [rbp-Ch]
  unsigned int v9; // [rsp+38h] [rbp-8h]
  int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 1;
  v9 = 0;
  v8 = 0;
  printf("Welcome to Rock-Paper-Scissors!\n");
  while ( v10 )
  {
    printf("\nChoose your weapon:\n");
    printf("1. Rock\n");
    printf("2. Paper\n");
    printf("3. Scissors\n");
    printf("4. Quit game\n");
    scanf("%d", &v6);
    if ( v6 == 4 )
    {
      printf("\nThank you for playing!\n");
      v10 = 0;
LABEL_13:
      if ( !v10 )
        return 0;
      v3 = time(0i64);
      srand(v3);
      v4 = rand() % 3;
      v7 = v4 + 1;
      if ( v4 == 2 )
      {
        printf("The computer chose Scissors!\n");
      }
      else
      {
        if ( v7 > 3 )
          goto LABEL_22;
        if ( v7 == 1 )
        {
          printf("The computer chose Rock!\n");
        }
        else
        {
          if ( v7 != 2 )
          {
LABEL_22:
            printf("The computer has malfunctioned.\n");
            goto LABEL_23;
          }
          printf("The computer chose Paper!\n");
        }
      }
LABEL_23:
      if ( v6 == 1 && v7 == 3 )
      {
        printf("\nRock crushes Scissors! You win!\n");
        ++v9;
      }
      else if ( v6 == 1 && v7 == 2 )
      {
        printf("\nPaper covers Rock! You lose!\n");
        ++v8;
      }
      else if ( v6 == 2 && v7 == 1 )
      {
        printf("\nPaper covers Rock! You win!\n");
        ++v9;
      }
      else if ( v6 == 2 && v7 == 3 )
      {
        printf("\nScissors cuts Paper! You lose!\n");
        ++v8;
      }
      else if ( v6 == 3 && v7 == 1 )
      {
        printf("\nRock crushes Scissors! You lose!\n");
        ++v8;
      }
      else if ( v6 == 3 && v7 == 2 )
      {
        printf("\nScissors cuts Paper! You win!\n");
        ++v9;
      }
      else
      {
        printf("\nIt's a tie!\n");
      }
      printf("\nScore:\n You: %d\n Computer: %d\n", v9, v8);
    }
    else
    {
      if ( v6 > 4 )
        goto LABEL_12;
      switch ( v6 )
      {
        case 3:
          printf("\nYou chose Scissors!\n");
          goto LABEL_13;
        case 1:
          printf("\nYou chose Rock!\n");
          goto LABEL_13;
        case 2:
          printf("\nYou chose Paper!\n");
          goto LABEL_13;
      }
LABEL_12:
      printf("\nInvalid choice! Please try again.\n");
    }
  }
  return 0;
}
// 1400016AD: conditional instruction was optimized away because %var_14.4<3
// 140001990: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory management ; Style: accurate
#include <stdio.h>
#include <stdlib.h>

void* memoryAllocation(size_t size) {
    void* ptr = malloc(size);
    if (ptr == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }
    printf("Allocated %zu bytes of memory at address: %p\n", size, ptr);
    return ptr;
}

void memoryDeallocation(void* ptr) {
    if (ptr == NULL) {
        printf("Can not free NULL pointer.\n");
        return;
    }
    printf("Deallocated memory at address: %p\n", ptr);
    free(ptr);
}

int main() {
    int* ptr1 = (int*) memoryAllocation(sizeof(int));
    *ptr1 = 10;
    printf("value of ptr1: %d\n", *ptr1);

    double* ptr2 = (double*) memoryAllocation(sizeof(double));
    *ptr2 = 3.14;
    printf("value of ptr2: %.2lf\n", *ptr2);

    // reallocation of memory
    ptr1 = (int*) realloc(ptr1, 2 * sizeof(int));
    if (ptr1 == NULL) {
        printf("Reallocation of memory failed.\n");
        exit(1);
    }
    printf("Reallocated memory at address: %p\n", ptr1);
    *(ptr1+1) = 20;
    printf("value of ptr1[1]: %d\n", *(ptr1+1));

    memoryDeallocation(ptr1);
    memoryDeallocation(ptr2);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall memoryAllocation(_QWORD); // weak
__int64 __fastcall memoryDeallocation(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001635) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _QWORD *v4; // [rsp+20h] [rbp-10h]
  unsigned int *Blocka; // [rsp+28h] [rbp-8h]
  _DWORD *Block; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  Blocka = (unsigned int *)memoryAllocation(4i64);
  *Blocka = 10;
  printf("value of ptr1: %d\n", *Blocka);
  v4 = (_QWORD *)memoryAllocation(8i64);
  *v4 = 0x40091EB851EB851Fi64;
  printf("value of ptr2: %.2lf\n", *v4);
  Block = realloc(Blocka, 8ui64);
  if ( !Block )
  {
    printf("Reallocation of memory failed.\n");
    exit(1);
  }
  printf("Reallocated memory at address: %p\n", Block);
  Block[1] = 20;
  printf("value of ptr1[1]: %d\n", (unsigned int)Block[1]);
  memoryDeallocation(Block);
  memoryDeallocation(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall memoryAllocation(_QWORD);
// 1400015EE: using guessed type __int64 __fastcall memoryDeallocation(_QWORD);
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Digital Diary ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Structure for diary entry */
struct diaryEntry {
    char date[11];
    char time[6];
    char title[100];
    char description[500];
};

/* Function to add a new diary entry */
void addEntry(struct diaryEntry *entry, int n) {
    printf("Enter date (dd/mm/yyyy): ");
    scanf("%10s", entry[n].date);
    printf("Enter time (hh:mm): ");
    scanf("%5s", entry[n].time);
    printf("Enter title: ");
    scanf(" %[^\n]", entry[n].title);
    printf("Enter description: ");
    scanf(" %[^\n]", entry[n].description);
}

/* Function to search for diary entries by date */
void searchEntry(struct diaryEntry *entry, int n) {
    char date[11];
    printf("Enter date to search (dd/mm/yyyy): ");
    scanf("%10s", date);
    for (int i = 0; i < n; i++) {
        if (strcmp(entry[i].date, date) == 0) {
            printf("Date: %s\nTime: %s\nTitle: %s\nDescription: %s\n", 
                entry[i].date, entry[i].time, entry[i].title, entry[i].description);
        }
    }
}

/* Function to display all diary entries */
void displayEntries(struct diaryEntry *entry, int n) {
    if (n == 0) {
        printf("No diary entries to display.\n");
    }
    else {
        printf("All diary entries:\n");
        for (int i = 0; i < n; i++) {
            printf("Date: %s\nTime: %s\nTitle: %s\nDescription: %s\n", 
                entry[i].date, entry[i].time, entry[i].title, entry[i].description);
        }
    }
}

/* Main function */
int main() {
    int choice, numEntries = 0;
    struct diaryEntry entry[100];
    do {
        printf("\nDigital Diary Menu:\n");
        printf("1. Add a new entry\n");
        printf("2. Search for entries by date\n");
        printf("3. Display all entries\n");
        printf("4. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                addEntry(entry, numEntries);
                numEntries++;
                break;
            case 2:
                searchEntry(entry, numEntries);
                break;
            case 3:
                displayEntries(entry, numEntries);
                break;
            case 4:
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice.\n");
        }
    } while (choice != 4);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addEntry(_QWORD, _QWORD); // weak
__int64 __fastcall searchEntry(_QWORD, _QWORD); // weak
__int64 __fastcall displayEntries(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001894) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[61704]; // [rsp+20h] [rbp-60h] BYREF
  int v5; // [rsp+F128h] [rbp+F0A8h] BYREF
  unsigned int v6; // [rsp+F12Ch] [rbp+F0ACh]

  _main(argc, argv, envp);
  v6 = 0;
  do
  {
    printf("\nDigital Diary Menu:\n");
    printf("1. Add a new entry\n");
    printf("2. Search for entries by date\n");
    printf("3. Display all entries\n");
    printf("4. Exit\n");
    printf("Enter choice: ");
    scanf("%d", &v5);
    if ( v5 == 4 )
    {
      printf("Exiting program.\n");
    }
    else
    {
      if ( v5 <= 4 )
      {
        switch ( v5 )
        {
          case 3:
            displayEntries(v4, v6);
            continue;
          case 1:
            addEntry(v4, v6++);
            continue;
          case 2:
            searchEntry(v4, v6);
            continue;
        }
      }
      printf("Invalid choice.\n");
    }
  }
  while ( v5 != 4 );
  return 0;
}
// 140001944: conditional instruction was optimized away because %var_8.4<3
// 1400015E2: using guessed type __int64 __fastcall addEntry(_QWORD, _QWORD);
// 1400016D4: using guessed type __int64 __fastcall searchEntry(_QWORD, _QWORD);
// 1400017C7: using guessed type __int64 __fastcall displayEntries(_QWORD, _QWORD);
// 140001A90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: File handling ; Style: retro
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Defining a structure to hold the details of retro video games
struct retro_game {
    char title[50];
    char platform[20];
    int release_year;
    float rating;
};

// Function to add new game details to the file
void add_game() {
    FILE *file_pointer;
    struct retro_game game;

    // Opening the file in append mode
    file_pointer = fopen("retro_games.txt", "a");

    if (file_pointer == NULL) {
        printf("\nError opening file!\n");
        exit(1);
    }

    printf("\nEnter the title of the game: ");
    fflush(stdin);
    fgets(game.title, 50, stdin);

    printf("\nEnter the platform of the game: ");
    fflush(stdin);
    fgets(game.platform, 20, stdin);

    printf("\nEnter the release year of the game: ");
    scanf("%d", &game.release_year);

    printf("\nEnter the rating of the game (out of 10): ");
    scanf("%f", &game.rating);

    fprintf(file_pointer, "%s%s%d%.1f\n", game.title, game.platform, game.release_year, game.rating);

    printf("\nGame details added successfully!\n");
    fclose(file_pointer);
}

// Function to display all the games in the file
void display_all_games() {
    FILE *file_pointer;
    struct retro_game game;

    // Opening the file in read mode
    file_pointer = fopen("retro_games.txt", "r");

    if (file_pointer == NULL) {
        printf("\nError opening file!\n");
        exit(1);
    }

    printf("\nTitle\tPlatform\tYear\tRating\n");

    // Reading game details from the file and displaying them
    while(fscanf(file_pointer, "%s%s%d%f", game.title, game.platform, &game.release_year, &game.rating) != EOF) {
        printf("%s\t%s\t%d\t%.1f\n", game.title, game.platform, game.release_year, game.rating);
    }

    fclose(file_pointer);
}

// Function to search for games based on their title
void search_game_by_title() {
    FILE *file_pointer;
    struct retro_game game;
    char title[50], found = 0;

    // Opening the file in read mode
    file_pointer = fopen("retro_games.txt", "r");

    if (file_pointer == NULL) {
        printf("\nError opening file!\n");
        exit(1);
    }

    printf("\nEnter the title of the game to search: ");
    fflush(stdin);
    fgets(title, 50, stdin);

    // Reading game details from the file and searching for the given title
    while(fscanf(file_pointer, "%s%s%d%f", game.title, game.platform, &game.release_year, &game.rating) != EOF) {
        if (strstr(game.title, title) != NULL) {
            printf("\nTitle\tPlatform\tYear\tRating\n");
            printf("%s\t%s\t%d\t%.1f\n", game.title, game.platform, game.release_year, game.rating);
            found = 1;
            break;
        }
    }

    if (!found) {
        printf("\nGame not found!\n");
    }

    fclose(file_pointer);
}

int main() {
    int choice;

    // Creating a menu for the user
    do {
        printf("\nRetro games file handling\n");
        printf("1. Add a new game\n");
        printf("2. Display all games\n");
        printf("3. Search for games based on title\n");
        printf("4. Exit\n");

        printf("\nEnter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                add_game();
                break;

            case 2:
                display_all_games();
                break;

            case 3:
                search_game_by_title();
                break;

            case 4:
                printf("\nExiting...\n");
                exit(0);

            default:
                printf("\nInvalid choice!\n");
                break;
        }
    } while (choice != 4);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_game(void); // weak
__int64 display_all_games(void); // weak
__int64 search_game_by_title(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001A54) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf("\nRetro games file handling\n");
    printf("1. Add a new game\n");
    printf("2. Display all games\n");
    printf("3. Search for games based on title\n");
    printf("4. Exit\n");
    printf("\nEnter your choice: ");
    scanf("%d", &v4);
    if ( v4 == 4 )
    {
      printf("\nExiting...\n");
      exit(0);
    }
    if ( v4 <= 4 )
    {
      switch ( v4 )
      {
        case 3:
          search_game_by_title();
          continue;
        case 1:
          add_game();
          continue;
        case 2:
          display_all_games();
          continue;
      }
    }
    printf("\nInvalid choice!\n");
  }
  while ( v4 != 4 );
  return 0;
}
// 140001AE6: conditional instruction was optimized away because %var_4.4<3
// 140001668: using guessed type __int64 add_game(void);
// 1400017FA: using guessed type __int64 display_all_games(void);
// 1400018E3: using guessed type __int64 search_game_by_title(void);
// 140001C00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=186 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Performance-Critical Component ; Style: Linus Torvalds
/*
 * This is a performance-critical component that optimizes matrix multiply.
 * I do not apologize for the complexity of the code. Optimization is not for the weak.
 *
 * Written by Linus Torvalds (not really)
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MATRIX_SIZE 1000

void multiply_matrices(double *A, double *B, double *C, int size)
{
    int i, j, k;

    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            C[i*size+j] = 0.0;
            for (k = 0; k < size; k++) {
                C[i*size+j] += A[i*size+k] * B[k*size+j];
            }
        }
    }
}

int main()
{
    double *A, *B, *C;
    clock_t start, end;
    double cpu_time_used;

    // Allocate memory for matrices
    A = (double*) malloc(MATRIX_SIZE * MATRIX_SIZE * sizeof(double));
    B = (double*) malloc(MATRIX_SIZE * MATRIX_SIZE * sizeof(double));
    C = (double*) malloc(MATRIX_SIZE * MATRIX_SIZE * sizeof(double));

    // Initialize matrices with random values between 0.0 and 1.0
    srand(time(NULL));
    for (int i = 0; i < MATRIX_SIZE * MATRIX_SIZE; i++) {
        A[i] = ((double) rand()) / ((double) RAND_MAX);
        B[i] = ((double) rand()) / ((double) RAND_MAX);
    }

    // Multiply matrices and time it
    start = clock();
    multiply_matrices(A, B, C, MATRIX_SIZE);
    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

    printf("Matrix size = %d x %d\n", MATRIX_SIZE, MATRIX_SIZE);
    printf("Execution time = %f seconds\n", cpu_time_used);

    // Free memory
    free(A);
    free(B);
    free(C);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall multiply_matrices(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// clock_t __cdecl clock();


//----- (00000001400016DF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  double v5; // [rsp+20h] [rbp-30h]
  clock_t v6; // [rsp+2Ch] [rbp-24h]
  void *v7; // [rsp+30h] [rbp-20h]
  double *v8; // [rsp+38h] [rbp-18h]
  double *Block; // [rsp+40h] [rbp-10h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  Block = (double *)malloc(0x7A1200ui64);
  v8 = (double *)malloc(0x7A1200ui64);
  v7 = malloc(0x7A1200ui64);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 999999; ++i )
  {
    Block[i] = (double)rand() / 32767.0;
    v8[i] = (double)rand() / 32767.0;
  }
  v6 = clock();
  multiply_matrices(Block, v8, v7, 1000i64);
  v5 = (double)(clock() - v6) / 1000.0;
  printf("Matrix size = %d x %d\n", 1000i64, 1000i64);
  printf("Execution time = %f seconds\n", v5);
  free(Block);
  free(v8);
  free(v7);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall multiply_matrices(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001910: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Bitwise operations ; Style: thoughtful
#include <stdio.h>

int main() {
    // declare two integers
    int a = 10, b = 7;
    
    // perform bitwise AND (&) operation
    int and_result = a & b;
    
    // perform bitwise OR (|) operation
    int or_result = a | b;
    
    // perform bitwise XOR (^) operation
    int xor_result = a ^ b;
    
    // perform bitwise NOT (~) operation
    int not_result = ~a;
    
    printf("Bitwise AND result: %d\n", and_result);
    printf("Bitwise OR result: %d\n", or_result);
    printf("Bitwise XOR result: %d\n", xor_result);
    printf("Bitwise NOT result: %d\n", not_result);
    
    // perform left shift (<<) operation
    int left_shift_result = a << 2;
    
    // perform right shift (>>) operation
    int right_shift_result = a >> 2;
    
    printf("Left shift result: %d\n", left_shift_result);
    printf("Right shift result: %d\n", right_shift_result);
    
    // create a mask to clear the last 3 bits of a
    int mask = ~0 << 3;
    
    // clear the last 3 bits of a using the mask and bitwise AND
    int new_a = a & mask;
    
    printf("New a value after clearing last 3 bits: %d\n", new_a);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("Bitwise AND result: %d\n", 2i64);
  printf("Bitwise OR result: %d\n", 15i64);
  printf("Bitwise XOR result: %d\n", 13i64);
  printf("Bitwise NOT result: %d\n", 4294967285i64);
  printf("Left shift result: %d\n", 40i64);
  printf("Right shift result: %d\n", 2i64);
  printf("New a value after clearing last 3 bits: %d\n", 8i64);
  return 0;
}
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[50];
    int quantity;
} Item;

typedef struct {
    Item items[100];
    int count;
} Inventory;

typedef struct {
    char name[50];
    Inventory* inventory;
} Warehouse;

void add_item(Warehouse* warehouse, char* name, int quantity) {
    for (int i = 0; i < warehouse->inventory->count; i++) {
        if (strcmp(name, warehouse->inventory->items[i].name) == 0) {
            warehouse->inventory->items[i].quantity += quantity;
            printf("%d units of %s added to %s.\n", quantity, name, warehouse->name);
            return;
        }
    }
    if (warehouse->inventory->count >= 100) {
        printf("Error: Warehouse inventory is full.\n");
        return;
    }
    Item item;
    strncpy(item.name, name, sizeof(item.name));
    item.quantity = quantity;
    warehouse->inventory->items[warehouse->inventory->count++] = item;
    printf("%d units of %s added to %s.\n", quantity, name, warehouse->name);
}

void remove_item(Warehouse* warehouse, char* name, int quantity) {
    for (int i = 0; i < warehouse->inventory->count; i++) {
        if (strcmp(name, warehouse->inventory->items[i].name) == 0) {
            if (warehouse->inventory->items[i].quantity >= quantity) {
                warehouse->inventory->items[i].quantity -= quantity;
                printf("%d units of %s removed from %s.\n", quantity, name, warehouse->name);
                if (warehouse->inventory->items[i].quantity == 0) {
                    for (int j = i; j < warehouse->inventory->count - 1; j++) {
                        warehouse->inventory->items[j] = warehouse->inventory->items[j+1];
                    }
                    warehouse->inventory->count--;
                }
            } else {
                printf("Error: Not enough units of %s in %s.\n", name, warehouse->name);
            }
            return;
        }
    }
    printf("Error: %s does not have %s in inventory.\n", warehouse->name, name);
}

void move_item(Warehouse* source, Warehouse* destination, char* name, int quantity) {
    for (int i = 0; i < source->inventory->count; i++) {
        if (strcmp(name, source->inventory->items[i].name) == 0) {
            if (source->inventory->items[i].quantity >= quantity) {
                remove_item(source, name, quantity);
                add_item(destination, name, quantity);
                printf("%d units of %s moved from %s to %s.\n", quantity, name, source->name, destination->name);
            } else {
                printf("Error: Not enough units of %s in %s.\n", name, source->name);
            }
            return;
        }
    }
    printf("Error: %s does not have %s in inventory.\n", source->name, name);
}

int main() {
    Inventory inventory1 = {.count = 0};
    Inventory inventory2 = {.count = 0};
    Warehouse warehouse1 = {.name = "Warehouse 1", .inventory = &inventory1};
    Warehouse warehouse2 = {.name = "Warehouse 2", .inventory = &inventory2};

    add_item(&warehouse1, "Laptop", 10);
    add_item(&warehouse1, "Tablet", 20);
    add_item(&warehouse2, "Laptop", 5);

    remove_item(&warehouse1, "Laptop", 3);
    remove_item(&warehouse1, "Tablet", 25);

    move_item(&warehouse1, &warehouse2, "Laptop", 4);
    move_item(&warehouse2, &warehouse1, "Tablet", 15);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall add_item(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall remove_item(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall move_item(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001AC1) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4[6]; // [rsp+20h] [rbp-60h] BYREF
  __int16 v5; // [rsp+50h] [rbp-30h]
  char *v6; // [rsp+58h] [rbp-28h]
  __int64 v7[6]; // [rsp+60h] [rbp-20h] BYREF
  __int16 v8; // [rsp+90h] [rbp+10h]
  char *v9; // [rsp+98h] [rbp+18h]
  char v10[5600]; // [rsp+A0h] [rbp+20h] BYREF
  int v11; // [rsp+1680h] [rbp+1600h]
  char v12[5600]; // [rsp+1690h] [rbp+1610h] BYREF
  int v13; // [rsp+2C70h] [rbp+2BF0h]

  _main(argc, argv, envp);
  memset(v12, 0, sizeof(v12));
  v13 = 0;
  memset(v10, 0, sizeof(v10));
  v11 = 0;
  v7[0] = 0x73756F6865726157i64;
  v7[1] = 3219557i64;
  memset(&v7[2], 0, 32);
  v8 = 0;
  v9 = v12;
  v4[0] = 0x73756F6865726157i64;
  v4[1] = 3285093i64;
  memset(&v4[2], 0, 32);
  v5 = 0;
  v6 = v10;
  add_item(v7, "Laptop", 10i64);
  add_item(v7, "Tablet", 20i64);
  add_item(v4, "Laptop", 5i64);
  remove_item(v7, "Laptop", 3i64);
  remove_item(v7, "Tablet", 25i64);
  move_item(v7, v4, "Laptop", 4i64);
  move_item(v4, v7, "Tablet", 15i64);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall add_item(_QWORD, _QWORD, _QWORD);
// 14000174D: using guessed type __int64 __fastcall remove_item(_QWORD, _QWORD, _QWORD);
// 140001988: using guessed type __int64 __fastcall move_item(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001D20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Educational ; Style: rigorous
#include <stdio.h>

// function to calculate factorial of a number 
int factorial(int n) {
    if (n < 0) {
        return -1; // error handling if the number is negative
    }
    int fact = 1;
    for (int i = 1; i <= n; i++) {
        fact *= i;
    }
    return fact;
}

// function to calculate fibonacci series up to n terms
void fibonacci(int n) {
    int term1 = 0, term2 = 1;
    printf("%d %d ", term1, term2);
    for (int i = 2; i < n; i++) {
        int nextTerm = term1 + term2;
        printf("%d ", nextTerm);
        term1 = term2;
        term2 = nextTerm;
    }
}

// program to demonstrate the usage of functions
int main() {
    int choice, n;
    printf("Choose an option:\n1. Calculate Factorial\n2. Generate Fibonacci Series\n");
    scanf("%d", &choice);
    switch(choice) {
        case 1:
            printf("Enter a number: ");
            scanf("%d", &n);
            printf("Factorial of %d is %d", n, factorial(n));
            break;
        case 2:
            printf("Enter the number of terms: ");
            scanf("%d", &n);
            printf("Fibonacci Series up to %d terms: ", n);
            fibonacci(n);
            break;
        default:
            printf("Invalid option");
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall factorial(_QWORD); // weak
__int64 __fastcall fibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016A4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+28h] [rbp-8h] BYREF
  int v6; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Choose an option:\n1. Calculate Factorial\n2. Generate Fibonacci Series\n");
  scanf("%d", &v6);
  if ( v6 == 1 )
  {
    printf("Enter a number: ");
    scanf("%d", &v5);
    v3 = factorial(v5);
    printf("Factorial of %d is %d", v5, v3);
  }
  else if ( v6 == 2 )
  {
    printf("Enter the number of terms: ");
    scanf("%d", &v5);
    printf("Fibonacci Series up to %d terms: ", v5);
    fibonacci(v5);
  }
  else
  {
    printf("Invalid option");
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall factorial(_QWORD);
// 140001629: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Time Travel Simulator ; Style: ultraprecise
#include <stdio.h>
#include <time.h>

int main() {
  struct tm start_time = {0};

  start_time.tm_year = 2021 - 1900; // January 1 2021
  start_time.tm_mon = 0;
  start_time.tm_mday = 1;

  time_t current_time = mktime(&start_time);

  struct tm dest_time = {0};
  dest_time.tm_year = 5500 - 1900; // The year 5500
  dest_time.tm_mon = 0;
  dest_time.tm_mday = 1;

  time_t dest_timestamp = mktime(&dest_time);

  printf("Starting from January 1, 2021, we will travel through time to the year 5500.\n");

  while (current_time < dest_timestamp) {
    printf("Time Traveling to the year: %d\n", 1900 + dest_time.tm_year);
    current_time += 86400; // Add one day
    struct tm* updated_time = localtime(&current_time);
    printf("Date is now: %d-%02d-%02d\n", 1900 + updated_time->tm_year, updated_time->tm_mon + 1, updated_time->tm_mday);
    printf("====================================\n");
  }

  printf("Time Traveling Complete.\n");

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static struct tm *__cdecl localtime(const time_t *const Time);
static time_t __cdecl mktime(struct tm *const Tm);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015CF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  struct tm v4; // [rsp+20h] [rbp-70h] BYREF
  time_t Time; // [rsp+48h] [rbp-48h] BYREF
  struct tm Tm; // [rsp+50h] [rbp-40h] BYREF
  struct tm *v7; // [rsp+80h] [rbp-10h]
  time_t v8; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  *(_QWORD *)&Tm.tm_sec = 0i64;
  *(_QWORD *)&Tm.tm_hour = 0x100000000i64;
  *(_QWORD *)&Tm.tm_mon = 0x7900000000i64;
  *(_QWORD *)&Tm.tm_wday = 0i64;
  Tm.tm_isdst = 0;
  Time = mktime(&Tm);
  *(_QWORD *)&v4.tm_sec = 0i64;
  *(_QWORD *)&v4.tm_hour = 0x100000000i64;
  *(_QWORD *)&v4.tm_mon = 0xE1000000000i64;
  *(_QWORD *)&v4.tm_wday = 0i64;
  v4.tm_isdst = 0;
  v8 = mktime(&v4);
  printf("Starting from January 1, 2021, we will travel through time to the year 5500.\n");
  while ( v8 > Time )
  {
    printf("Time Traveling to the year: %d\n", (unsigned int)(v4.tm_year + 1900));
    Time += 86400i64;
    v7 = localtime(&Time);
    printf(
      "Date is now: %d-%02d-%02d\n",
      (unsigned int)(v7->tm_year + 1900),
      (unsigned int)(v7->tm_mon + 1),
      (unsigned int)v7->tm_mday);
    printf("====================================\n");
  }
  printf("Time Traveling Complete.\n");
  return 0;
}
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Benchmarking ; Style: recursive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int fibonacci(int n)
{
    if(n == 0)
        return 0;
    else if(n == 1)
        return 1;
    else
        return (fibonacci(n-1) + fibonacci(n-2));
}

int main()
{
    clock_t start, end;
    double cpu_time_used;
    start = clock();
    
    int n = 30; // change the value to change fibonacci term to be calculated
    
    printf("Fibonacci term %d is %d\n", n, fibonacci(n));
    
    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
    
    printf("Time taken: %f seconds\n", cpu_time_used);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall fibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// clock_t __cdecl clock();


//----- (00000001400015DE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  double v5; // [rsp+28h] [rbp-18h]
  clock_t v6; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = clock();
  v3 = fibonacci(30i64);
  printf("Fibonacci term %d is %d\n", 30i64, v3);
  v5 = (double)(clock() - v6) / 1000.0;
  printf("Time taken: %f seconds\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001720: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Image Classification system ; Style: romantic
#include <stdio.h>
#include <stdlib.h>

int main() {

    printf("My Love, let me show you how much you mean to me.\n");
    printf("I have created a special image classification system just for you.\n");
    printf("It will help us identify the most beautiful images of us together.\n");
    
    // Load the image classification model
    printf("Loading the model...\n");
    // TODO: Code to load the model
    
    // Load the images to classify
    printf("Loading the images to classify...\n");
    // TODO: Code to load the images
    
    // Classify the images
    printf("Classifying the images...\n");
    // TODO: Code to classify the images
    
    // Display the most beautiful image
    printf("The most beautiful image of us together is:\n");
    // TODO: Code to display the most beautiful image

    printf("My Love, I hope you like the system that I have created for us.\n");
    printf("For me, the most beautiful image is the one of us holding hands,\n");
    printf("walking towards the sunset, with a heart full of love and happiness.\n");
    printf("I want to be with you forever.\n");
    printf("I love you more than anything else in the world.\n");
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf("My Love, let me show you how much you mean to me.\n");
  printf("I have created a special image classification system just for you.\n");
  printf("It will help us identify the most beautiful images of us together.\n");
  printf("Loading the model...\n");
  printf("Loading the images to classify...\n");
  printf("Classifying the images...\n");
  printf("The most beautiful image of us together is:\n");
  printf("My Love, I hope you like the system that I have created for us.\n");
  printf("For me, the most beautiful image is the one of us holding hands,\n");
  printf("walking towards the sunset, with a heart full of love and happiness.\n");
  printf("I want to be with you forever.\n");
  printf("I love you more than anything else in the world.\n");
  return 0;
}
// 140001710: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home automation ; Style: futuristic
#include <stdio.h>
#include <stdbool.h>

//function prototypes
void turnOnLights(void);
void turnOffLights(void);
void turnOnAC(void);
void turnOffAC(void);
void queryTemperature(void);

//global variables
bool areLightsOn = false;
bool isACOn = false;
int temperature = 25;

int main()
{
    printf("\n***Welcome to Futuristic Smart Home Automation System***\n\n");

    int choice = 0;

    do {
        printf("Please choose an option:\n");
        printf("1. Turn on lights\n");
        printf("2. Turn off lights\n");
        printf("3. Turn on AC\n");
        printf("4. Turn off AC\n");
        printf("5. Query temperature\n");
        printf("6. Exit\n");

        scanf("%d", &choice);

        switch(choice) {
            case 1:
                if(!areLightsOn) {
                    turnOnLights();
                    areLightsOn = true;
                }
                else {
                    printf("Lights are already on!\n");
                }
                break;

            case 2:
                if(areLightsOn) {
                    turnOffLights();
                    areLightsOn = false;
                }
                else {
                    printf("Lights are already off!\n");
                }
                break;

            case 3:
                if(!isACOn) {
                    turnOnAC();
                    isACOn = true;
                }
                else {
                    printf("AC is already on!\n");
                }
                break;

            case 4:
                if(isACOn) {
                    turnOffAC();
                    isACOn = false;
                }
                else {
                    printf("AC is already off!\n");
                }
                break;

            case 5:
                queryTemperature();
                break;

            case 6:
                printf("Thank you for using the system!\n");
                break;

            default:
                printf("Invalid option, please try again...\n");
                break;
        }
    } while (choice != 6);

    return 0;
}

void turnOnLights(void) {
    printf("Turning on lights...\n");
    //code to turn on the lights
}

void turnOffLights(void) {
    printf("Turning off lights...\n");
    //code to turn off the lights
}

void turnOnAC(void) {
    printf("Turning on AC...\n");
    //code to turn on the AC
}

void turnOffAC(void) {
    printf("Turning off AC...\n");
    //code to turn off the AC
}

void queryTemperature(void) {
    printf("Current temperature is %d degrees Celsius.\n", temperature);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 turnOnLights(void); // weak
__int64 turnOffLights(void); // weak
__int64 turnOnAC(void); // weak
__int64 turnOffAC(void); // weak
__int64 queryTemperature(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char areLightsOn; // weak
char isACOn; // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("\n***Welcome to Futuristic Smart Home Automation System***\n\n");
  v4 = 0;
  do
  {
    printf("Please choose an option:\n");
    printf("1. Turn on lights\n");
    printf("2. Turn off lights\n");
    printf("3. Turn on AC\n");
    printf("4. Turn off AC\n");
    printf("5. Query temperature\n");
    printf("6. Exit\n");
    scanf("%d", &v4);
    switch ( v4 )
    {
      case 1:
        if ( areLightsOn != 1 )
        {
          turnOnLights();
          areLightsOn = 1;
        }
        else
        {
          printf("Lights are already on!\n");
        }
        break;
      case 2:
        if ( areLightsOn )
        {
          turnOffLights();
          areLightsOn = 0;
        }
        else
        {
          printf("Lights are already off!\n");
        }
        break;
      case 3:
        if ( isACOn != 1 )
        {
          turnOnAC();
          isACOn = 1;
        }
        else
        {
          printf("AC is already on!\n");
        }
        break;
      case 4:
        if ( isACOn )
        {
          turnOffAC();
          isACOn = 0;
        }
        else
        {
          printf("AC is already off!\n");
        }
        break;
      case 5:
        queryTemperature();
        break;
      case 6:
        printf("Thank you for using the system!\n");
        break;
      default:
        printf("Invalid option, please try again...\n");
        break;
    }
  }
  while ( v4 != 6 );
  return 0;
}
// 1400017A8: using guessed type __int64 turnOnLights(void);
// 1400017C6: using guessed type __int64 turnOffLights(void);
// 1400017E4: using guessed type __int64 turnOnAC(void);
// 140001802: using guessed type __int64 turnOffAC(void);
// 140001820: using guessed type __int64 queryTemperature(void);
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140018040: using guessed type char areLightsOn;
// 140018041: using guessed type char isACOn;

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Procedural Space Adventure ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Function prototypes
void clearScreen();
void displayIntro();
void generatePlanets(char *planetNames[], int numPlanets);
int launchGame(int numPlanets, char *planetNames[]);
void planetMenu(char *planetName);
void explorePlanet(char *planetName);
void minePlanet(char *planetName);

int main() {
    // Seed random number generator for use later
    srand(time(NULL)); 

    char *planetNames[] = {
        "Arcturus",
        "Betelgeuse",
        "Ceti Alpha V",
        "Dagobah",
        "Ego",
        "Fhloston",
        "Gotham",
        "Hoth",
        "Icarus",
        "Jupiter",
        "Krypton",
        "Luna",
        "Mars",
        "Neptune",
        "Orion",
        "Pandora",
        "Quasar",
        "Rigel",
        "Serenity",
        "Tatooine",
        "Uranus",
        "Vulcan",
        "Wadiya",
        "Xandar",
        "Yavin IV",
        "Zephyr"
    };
    int numPlanets = sizeof(planetNames) / sizeof(char *);

    clearScreen();
    displayIntro();

    int playAgain = 1;
    while (playAgain) {
        generatePlanets(planetNames, numPlanets);
        int choice = launchGame(numPlanets, planetNames);

        if (choice == 1) {
            playAgain = 1;
            clearScreen();
        } else {
            playAgain = 0;
            printf("\nThank you for playing!\n");
        }
    }
    return 0;
}

// Function to clear the screen and reset the cursor position
void clearScreen() {
    printf("\033[2J\033[1;1H");
}

// Function to display the game intro
void displayIntro() {
    printf("Welcome to Procedural Space Adventure!\n\n");
    printf("Space adventure is the ultimate adventure game where you travel across the galaxy\n");
    printf("to explore strange new worlds, to seek out new life and new civilizations,\n");
    printf("to boldly go where no one has gone before. Good luck and have fun!\n\n");
    printf("Press enter to begin.\n");
    getchar();
    clearScreen();
}

// Function to randomly shuffle the array of planet names
void generatePlanets(char *planetNames[], int numPlanets) {
    for (int i = 0; i < numPlanets; i++) {
        int randomIndex = rand() % numPlanets;
        char *temp = planetNames[i];
        planetNames[i] = planetNames[randomIndex];
        planetNames[randomIndex] = temp;
    }
}

// Function to launch the game and select a planet to visit
int launchGame(int numPlanets, char *planetNames[]) {
    printf("Here are the planets available to visit:\n\n");
    for (int i = 0; i < numPlanets; i++) {
        printf("%d. %s\n", i+1, planetNames[i]);
    }
    printf("%d. Exit game\n", numPlanets+1);

    int choice = 0;
    int maxChoice = numPlanets + 1;
    while (choice < 1 || choice > maxChoice) {
        printf("\nEnter the number of the planet you would like to visit (1-%d): ", maxChoice);
        scanf("%d", &choice);
        if (choice < 1 || choice > maxChoice) {
            printf("Invalid choice.\n");
        }
    }

    if (choice == maxChoice) {
        return 2;
    } else {
        clearScreen();
        planetMenu(planetNames[choice-1]);
        return 1;
    }
}

// Function to display the planet menu
void planetMenu(char *planetName) {
    printf("Welcome to %s!\n", planetName);
    printf("What would you like to do?\n");
    printf("1. Explore the planet\n");
    printf("2. Mine resources\n");
    printf("3. Return to planet selection\n");

    int choice = 0;
    while (choice < 1 || choice > 3) {
        printf("\nEnter the number of your choice (1-3): ");
        scanf("%d", &choice);
        if (choice < 1 || choice > 3) {
            printf("Invalid choice.\n");
        }
    }

    switch(choice) {
        case 1:
            explorePlanet(planetName);
            break;
        case 2:
            minePlanet(planetName);
            break;
        case 3:
            clearScreen();
            break;
    }
}

// Function to explore the planet
void explorePlanet(char *planetName) {
    printf("You explore %s and discover many strange and wonderful things.\n", planetName);
    printf("Unfortunately, you got lost and couldn't find your way back to your ship.\n");
    printf("You died. Game over. Try again?\n");

    printf("\nPress enter to continue.\n");
    getchar();
}

// Function to mine the planet for resources
void minePlanet(char *planetName) {
    printf("You mine %s for resources and find an abundance of valuable materials.\n", planetName);
    printf("You get rich and retire to a life of luxury. Congratulations, you win!\n");

    printf("\nPress enter to continue.\n");
    getchar();
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall clearScreen(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 displayIntro(void); // weak
__int64 __fastcall generatePlanets(_QWORD, _QWORD); // weak
__int64 __fastcall launchGame(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v13[26]; // [rsp+20h] [rbp-60h] BYREF
  int v14; // [rsp+F4h] [rbp+74h]
  unsigned int v15; // [rsp+F8h] [rbp+78h]
  int v16; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v13[22] = (__int64)"Wadiya";
  v13[23] = (__int64)"Xandar";
  v13[24] = (__int64)"Yavin IV";
  v13[25] = (__int64)"Zephyr";
  v15 = 26;
  clearScreen(
    v5,
    v4,
    v6,
    v7,
    "Arcturus",
    "Betelgeuse",
    "Ceti Alpha V",
    "Dagobah",
    "Ego",
    "Fhloston",
    "Gotham",
    "Hoth",
    "Icarus",
    "Jupiter",
    "Krypton",
    "Luna",
    "Mars",
    "Neptune",
    "Orion",
    "Pandora",
    "Quasar",
    "Rigel",
    "Serenity",
    "Tatooine",
    "Uranus",
    "Vulcan");
  displayIntro();
  v16 = 1;
  while ( v16 )
  {
    generatePlanets(v13, v15);
    v14 = launchGame(v15, v13);
    if ( v14 == 1 )
    {
      v16 = 1;
      clearScreen(
        v9,
        v8,
        v10,
        v11,
        v13[0],
        v13[1],
        v13[2],
        v13[3],
        v13[4],
        v13[5],
        v13[6],
        v13[7],
        v13[8],
        v13[9],
        v13[10],
        v13[11],
        v13[12],
        v13[13],
        v13[14],
        v13[15],
        v13[16],
        v13[17],
        v13[18],
        v13[19],
        v13[20],
        v13[21]);
    }
    else
    {
      v16 = 0;
      printf("\nThank you for playing!\n");
    }
  }
  return 0;
}
// 14000174C: variable 'v5' is possibly undefined
// 14000174C: variable 'v4' is possibly undefined
// 14000174C: variable 'v6' is possibly undefined
// 14000174C: variable 'v7' is possibly undefined
// 14000178C: variable 'v9' is possibly undefined
// 14000178C: variable 'v8' is possibly undefined
// 14000178C: variable 'v10' is possibly undefined
// 14000178C: variable 'v11' is possibly undefined
// 1400017BD: using guessed type __int64 __fastcall clearScreen(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400017DB: using guessed type __int64 displayIntro(void);
// 14000183F: using guessed type __int64 __fastcall generatePlanets(_QWORD, _QWORD);
// 1400018DC: using guessed type __int64 __fastcall launchGame(_QWORD, _QWORD);
// 140001C50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Pattern printing ; Style: medieval
#include <stdio.h>

int main() {
    int n = 5;
    // Printing the top half part
    for (int i = n; i >= 1; i--) {
        printf("%*c", i, ' '); // Printing the left spaces
        for (int j = 1; j <= i + n - 1; j++) {
            if (j <= i) {
                printf("%c", '*'); // Printing asterisks for the left part
            } else {
                printf("%c", '+'); // Printing plus signs for the right part
            }
        }
        printf("\n");
    }

    // Printing the bottom half part
    for (int i = 2; i <= n; i++) {
        printf("%*c", i, ' '); // Printing the left spaces
        for (int j = 1; j <= i + n - 1; j++) {
            if (j <= i) {
                printf("%c", '+'); // Printing plus signs for the left part
            } else {
                printf("%c", '*'); // Printing asterisks for the right part
            }
        }
        printf("\n");
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int m; // [rsp+30h] [rbp-10h]
  int k; // [rsp+34h] [rbp-Ch]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  for ( i = 5; i > 0; --i )
  {
    printf("%*c", i, 32i64);
    for ( j = 1; j < i + 5; ++j )
    {
      if ( j > i )
        printf("%c", 43i64);
      else
        printf("%c", 42i64);
    }
    printf("\n");
  }
  for ( k = 2; k <= 5; ++k )
  {
    printf("%*c", k, 32i64);
    for ( m = 1; m < k + 5; ++m )
    {
      if ( m > k )
        printf("%c", 42i64);
      else
        printf("%c", 43i64);
    }
    printf("\n");
  }
  return 0;
}
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Text to ASCII art generator ; Style: satisfied
#include <stdio.h>
#include <string.h>

#define MAX_LEN 255 // max length of input string

// function to convert character to ASCII art
void charToArt(char c) {
    switch(c) {
        case 'a':
        case 'A':
            printf("  /\\  \n /  \\ \n/____\\\n/\\   /\\ \n/  \\ /  \\ \n");
            break;
        case 'b':
        case 'B':
            printf("||||| \n||||| \n||||| \n||||| \n||||| \n");
            break;
        case 'c':
        case 'C':
            printf("   _____ \n /      \\\n/        \\\n\\        /\n \\_____/\n");
            break;
        // add more cases for each character
        // ...
        default:
            printf("Cannot convert '%c' to ASCII art.\n", c);
            break;
    }
}

int main() {
    char input[MAX_LEN];
    printf("Enter a string to convert to ASCII art:\n");
    fgets(input, MAX_LEN, stdin);   // read input string from user
    input[strcspn(input, "\n")] = '\0';   // remove newline character
    
    int len = strlen(input);
    for(int i=0; i<len; i++) {
        charToArt(input[i]);    // convert each character to ASCII art
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall charToArt(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001655) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[264]; // [rsp+20h] [rbp-60h] BYREF
  int v6; // [rsp+128h] [rbp+A8h]
  int i; // [rsp+12Ch] [rbp+ACh]

  _main(argc, argv, envp);
  printf("Enter a string to convert to ASCII art:\n");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 255, v3);
  Buffer[strcspn(Buffer, "\n")] = 0;
  v6 = strlen(Buffer);
  for ( i = 0; i < v6; ++i )
    charToArt((unsigned int)Buffer[i]);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall charToArt(_QWORD);
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001655: using guessed type char Buffer[264];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Unit converter ; Style: statistical
#include<stdio.h>

/* This program converts units from metric to imperial and vice versa*/

int main(){

    float input_val, output_val;
    char unit_type;

    printf("Welcome to the Unit Converter Program! \n\n");
    printf("Please enter the input value: ");
    scanf("%f", &input_val);

    printf("Please enter the unit type (m for metric, i for imperial): ");
    scanf(" %c", &unit_type);

    if(unit_type == 'm'){ // if input unit is metric
        printf("\nInput value in metric: %.2f\n", input_val);
        printf("Converted value in imperial: %.2f feet\n", input_val * 3.28);
        output_val = input_val * 3.28;
    }
    else if(unit_type == 'i'){ // if input unit is imperial
        printf("\nInput value in imperial: %.2f feet\n", input_val);
        printf("Converted value in metric: %.2f meters\n", input_val * 0.3048);
        output_val = input_val * 0.3048;
    }
    else{ // if invalid input unit is entered
        printf("Invalid unit type! Please enter 'm' for metric or 'i' for imperial. \n");
        return 0;
    }

    printf("\nThank you for using the Unit Converter Program! \n\n");
    printf("The input value was: %.2f\n", input_val);
    printf("The converted value is: %.2f \n", output_val);

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  char v6; // [rsp+27h] [rbp-9h] BYREF
  float v7; // [rsp+28h] [rbp-8h] BYREF
  float v8; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Unit Converter Program! \n\n");
  printf("Please enter the input value: ");
  scanf("%f", &v7);
  printf("Please enter the unit type (m for metric, i for imperial): ");
  scanf(" %c", &v6);
  if ( v6 == 109 )
  {
    printf("\nInput value in metric: %.2f\n", v7);
    printf("Converted value in imperial: %.2f feet\n", 3.28 * v7);
    v3 = 3.28 * v7;
    v8 = v3;
  }
  else
  {
    if ( v6 != 105 )
    {
      printf("Invalid unit type! Please enter 'm' for metric or 'i' for imperial. \n");
      return 0;
    }
    printf("\nInput value in imperial: %.2f feet\n", v7);
    printf("Converted value in metric: %.2f meters\n", 0.3048 * v7);
    v4 = 0.3048 * v7;
    v8 = v4;
  }
  printf("\nThank you for using the Unit Converter Program! \n\n");
  printf("The input value was: %.2f\n", v7);
  printf("The converted value is: %.2f \n", v8);
  return 0;
}
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Color Code Converter ; Style: careful
#include <stdio.h>
#include <stdlib.h>

void rgb_to_hex(int r, int g, int b);
void hex_to_rgb(char *hex);

int main()
{
    int choice;

    printf("1. Convert RGB to HEX\n");
    printf("2. Convert HEX to RGB\n");
    printf("Choose your option: ");
    scanf("%d", &choice);

    if (choice == 1) {
        int r, g, b;
        printf("Enter the RGB values (0-255): ");
        scanf("%d %d %d", &r, &g, &b);
        rgb_to_hex(r, g, b);
    } else if (choice == 2) {
        char hex[7];
        printf("Enter the HEX value (example: FF00FF): ");
        scanf("%s", hex);
        hex_to_rgb(hex);
    } else {
        printf("Invalid choice!\n");
        exit(1);
    }

    return 0;
}

void rgb_to_hex(int r, int g, int b)
{
    char hex[7];
    sprintf(hex, "%02X%02X%02X", r, g, b);

    printf("HEX value: #%s\n", hex);
}

void hex_to_rgb(char *hex)
{
    if (hex[0] == '#') hex++;

    int r, g, b;
    sscanf(hex, "%02x%02x%02x", &r, &g, &b);

    printf("RGB values: %d %d %d\n", r, g, b);
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall rgb_to_hex(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall hex_to_rgb(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001668) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[7]; // [rsp+29h] [rbp-17h] BYREF
  unsigned int v5; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v6; // [rsp+34h] [rbp-Ch] BYREF
  unsigned int v7; // [rsp+38h] [rbp-8h] BYREF
  int v8; // [rsp+3Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("1. Convert RGB to HEX\n");
  printf("2. Convert HEX to RGB\n");
  printf("Choose your option: ");
  scanf("%d", &v8);
  if ( v8 == 1 )
  {
    printf("Enter the RGB values (0-255): ");
    scanf("%d %d %d", &v7, &v6, &v5);
    rgb_to_hex(v7, v6, v5);
  }
  else
  {
    if ( v8 != 2 )
    {
      printf("Invalid choice!\n");
      exit(1);
    }
    printf("Enter the HEX value (example: FF00FF): ");
    scanf("%s", v4);
    hex_to_rgb(v4);
  }
  return 0;
}
// 140001767: using guessed type __int64 __fastcall rgb_to_hex(_QWORD, _QWORD, _QWORD);
// 1400017BA: using guessed type __int64 __fastcall hex_to_rgb(_QWORD);
// 1400018E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: QR code reader ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_LENGTH 100

// Function to check if a string is a valid QR code format
bool isValidQRCode(char* qrCode) {
    if (strlen(qrCode) != 11) {
        return false;
    }
    if (qrCode[0] != 'C' || qrCode[1] != '-') {
        return false;
    }
    for (int i = 2; i < 11; i++) {
        if (qrCode[i] < '0' || qrCode[i] > '9') {
            return false;
        }
    }
    return true;
}

// Function to read QR code and return the numeric value
int readQRCode(char* qrCode) {
    if (!isValidQRCode(qrCode)) {
        return -1;
    }
    int value = 0;
    for (int i = 2; i < 11; i++) {
        value = value * 10 + (qrCode[i] - '0');
    }
    return value;
}

// Main function
int main() {
    char qrCode[MAX_LENGTH];
    printf("Enter the QR code: ");
    fgets(qrCode, MAX_LENGTH, stdin);
    // Remove newline character if present
    if (qrCode[strlen(qrCode) - 1] == '\n') {
        qrCode[strlen(qrCode) - 1] = '\0';
    }
    int value = readQRCode(qrCode);
    if (value == -1) {
        printf("Invalid QR code!\n");
        return -1;
    }
    printf("QR code value: %d\n", value);
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall readQRCode(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001690) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[108]; // [rsp+20h] [rbp-70h] BYREF
  unsigned int QRCode; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf("Enter the QR code: ");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  if ( Buffer[strlen(Buffer) - 1] == 10 )
    Buffer[strlen(Buffer) - 1] = 0;
  QRCode = readQRCode(Buffer);
  if ( QRCode == -1 )
  {
    printf("Invalid QR code!\n");
    return -1;
  }
  else
  {
    printf("QR code value: %d\n", QRCode);
    return 0;
  }
}
// 140001621: using guessed type __int64 __fastcall readQRCode(_QWORD);
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001690: using guessed type char Buffer[108];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Geometric algorithms ; Style: shape shifting
#include<stdio.h>

int main(){
    int shape;
    float length, breadth, radius, side;
    printf("Enter the initial shape (1: Square, 2: Rectangle, 3: Circle): ");
    scanf("%d",&shape);
    switch(shape){
        case 1:
            printf("Enter the side length of the square: ");
            scanf("%f",&side);
            printf("The square with side length %.2f has perimeter %.2f and area %.2f\n",side,(4*side),(side*side));
            printf("Enter the radius of the circle: ");
            scanf("%f",&radius);
            printf("The circle with radius %.2f has circumference %.2f and area %.2f\n",radius,(2*3.1416*radius),(3.1416*radius*radius));
            printf("Enter the length and breadth of the rectangle: ");
            scanf("%f%f",&length,&breadth);
            printf("The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",length,breadth,(2*(length+breadth)),(length*breadth));
            break;
        case 2:
            printf("Enter the length and breadth of the rectangle: ");
            scanf("%f%f",&length,&breadth);
            printf("The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",length,breadth,(2*(length+breadth)),(length*breadth));
            printf("Enter the side length of the square: ");
            scanf("%f",&side);
            printf("The square with side length %.2f has perimeter %.2f and area %.2f\n",side,(4*side),(side*side));
            printf("Enter the radius of the circle: ");
            scanf("%f",&radius);
            printf("The circle with radius %.2f has circumference %.2f and area %.2f\n",radius,(2*3.1416*radius),(3.1416*radius*radius));
            break;
        case 3:
            printf("Enter the radius of the circle: ");
            scanf("%f",&radius);
            printf("The circle with radius %.2f has circumference %.2f and area %.2f\n",radius,(2*3.1416*radius),(3.1416*radius*radius));
            printf("Enter the length and breadth of the rectangle: ");
            scanf("%f%f",&length,&breadth);
            printf("The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",length,breadth,(2*(length+breadth)),(length*breadth));
            printf("Enter the side length of the square: ");
            scanf("%f",&side);
            printf("The square with side length %.2f has perimeter %.2f and area %.2f\n",side,(4*side),(side*side));
            break;
        default:
            printf("Invalid choice, please enter valid input!\n");
            break;
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4; // [rsp+3Ch] [rbp-14h] BYREF
  float v5; // [rsp+40h] [rbp-10h] BYREF
  float v6; // [rsp+44h] [rbp-Ch] BYREF
  float v7; // [rsp+48h] [rbp-8h] BYREF
  int v8; // [rsp+4Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter the initial shape (1: Square, 2: Rectangle, 3: Circle): ");
  scanf("%d", &v8);
  if ( v8 == 3 )
  {
    printf("Enter the radius of the circle: ");
    scanf("%f", &v5);
    printf("The circle with radius %.2f has circumference %.2f and area %.2f\n", v5, v5 * 6.2832, v5 * 3.1416 * v5);
    printf("Enter the length and breadth of the rectangle: ");
    scanf("%f%f", &v7, &v6);
    printf(
      "The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",
      v7,
      v6,
      (float)((float)(v6 + v7) + (float)(v6 + v7)),
      (float)(v6 * v7));
    printf("Enter the side length of the square: ");
    scanf("%f", &v4);
    printf(
      "The square with side length %.2f has perimeter %.2f and area %.2f\n",
      v4,
      (float)(4.0 * v4),
      (float)(v4 * v4));
  }
  else
  {
    if ( v8 > 3 )
    {
LABEL_9:
      printf("Invalid choice, please enter valid input!\n");
      return 0;
    }
    if ( v8 == 1 )
    {
      printf("Enter the side length of the square: ");
      scanf("%f", &v4);
      printf(
        "The square with side length %.2f has perimeter %.2f and area %.2f\n",
        v4,
        (float)(4.0 * v4),
        (float)(v4 * v4));
      printf("Enter the radius of the circle: ");
      scanf("%f", &v5);
      printf("The circle with radius %.2f has circumference %.2f and area %.2f\n", v5, v5 * 6.2832, v5 * 3.1416 * v5);
      printf("Enter the length and breadth of the rectangle: ");
      scanf("%f%f", &v7, &v6);
      printf(
        "The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",
        v7,
        v6,
        (float)((float)(v6 + v7) + (float)(v6 + v7)),
        (float)(v6 * v7));
    }
    else
    {
      if ( v8 != 2 )
        goto LABEL_9;
      printf("Enter the length and breadth of the rectangle: ");
      scanf("%f%f", &v7, &v6);
      printf(
        "The rectangle with length %.2f and breadth %.2f has perimeter %.2f and area %.2f\n",
        v7,
        v6,
        (float)((float)(v6 + v7) + (float)(v6 + v7)),
        (float)(v6 * v7));
      printf("Enter the side length of the square: ");
      scanf("%f", &v4);
      printf(
        "The square with side length %.2f has perimeter %.2f and area %.2f\n",
        v4,
        (float)(4.0 * v4),
        (float)(v4 * v4));
      printf("Enter the radius of the circle: ");
      scanf("%f", &v5);
      printf("The circle with radius %.2f has circumference %.2f and area %.2f\n", v5, v5 * 6.2832, v5 * 3.1416 * v5);
    }
  }
  return 0;
}
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Performance-Critical Component ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(0));

    int arr[1000000]; //a big array to make things interesting

    //populate array with random numbers
    for(int i=0; i<1000000; i++) {
        arr[i] = rand();
    }

    //perform bubble sort algorithm
    for(int i=0; i<1000000-1; i++) {
        for(int j=0; j<1000000-i-1; j++) {
            if(arr[j] > arr[j+1]) {
                //swap elements
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }

    printf("Array sorted successfully! Here are the first 10 elements:\n");

    //print first 10 elements
    for(int i=0; i<10; i++) {
        printf("%d\n", arr[i]);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>



//----- (00000001400015B0) ----------------------------------------------------
#error "1400015B0: stack frame is too big (funcsize=0)"

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1 function(s)"
`
`//FormAI DATASET v1.0 Category: Electronic Voting System ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_VOTERS 1000 // maximum number of voters
#define MAX_CANDIDATES 30 // maximum number of candidates
#define MAX_NAME_LENGTH 50 // maximum length of a candidate's name

// struct for a candidate
typedef struct {
    int id;
    char name[MAX_NAME_LENGTH];
    int votes;
} Candidate;

// struct for a voter
typedef struct {
    int id;
    bool hasVoted;
} Voter;

// array of candidates and voters
Candidate candidates[MAX_CANDIDATES];
Voter voters[MAX_VOTERS];

int numCandidates = 0; // number of candidates
int numVoters = 0; // number of voters

// function to add a candidate
void addCandidate(char* name) {
    if (numCandidates == MAX_CANDIDATES) {
        printf("Max number of candidates reached!\n");
        return;
    }
    Candidate candidate;
    candidate.id = numCandidates + 1;
    strcpy(candidate.name, name);
    candidate.votes = 0;
    candidates[numCandidates] = candidate;
    numCandidates++;
}

// function to print all candidates
void printCandidates() {
    printf("ID\tName\t\tVotes\n");
    for (int i = 0; i < numCandidates; i++) {
        printf("%d\t%s\t\t%d\n", candidates[i].id, candidates[i].name, candidates[i].votes);
    }
}

// function to vote for a candidate
void vote(int voterId, int candidateId) {
    if (voters[voterId].hasVoted) {
        printf("Voter has already voted!\n");
        return;
    }
    if (candidateId < 1 || candidateId > numCandidates) {
        printf("Invalid candidate ID!\n");
        return;
    }
    candidates[candidateId - 1].votes++;
    voters[voterId].hasVoted = true;
    printf("Vote cast for %s!\n", candidates[candidateId - 1].name);
}

// function to print all voters
void printVoters() {
    printf("ID\tVoted?\n");
    for (int i = 0; i < numVoters; i++) {
        printf("%d\t%s\n", voters[i].id, voters[i].hasVoted ? "Yes" : "No");
    }
}

int main() {
    // add candidates
    addCandidate("John");
    addCandidate("Jane");
    addCandidate("Jim");
    
    // add voters
    for (int i = 0; i < 10; i++) {
        Voter voter;
        voter.id = numVoters + 1;
        voter.hasVoted = false;
        voters[numVoters] = voter;
        numVoters++;
    }
    
    // print initial state
    printf("Initial state:\n");
    printCandidates();
    printVoters();
    
    // conduct election
    vote(0, 1);
    vote(1, 2);
    vote(2, 1);
    vote(3, 1);
    vote(4, 3);
    vote(5, 2);
    vote(6, 1);
    vote(7, 2);
    vote(8, 3);
    vote(9, 1);
    
    // print final state
    printf("\nFinal state:\n");
    printCandidates();
    printVoters();
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall addCandidate(_QWORD); // weak
__int64 printCandidates(void); // weak
__int64 __fastcall vote(_QWORD, _QWORD); // weak
__int64 printVoters(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN voters; // weak
int numVoters; // weak


//----- (00000001400018A0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+24h] [rbp-Ch]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  addCandidate("John");
  addCandidate("Jane");
  addCandidate("Jim");
  for ( i = 0; i <= 9; ++i )
  {
    LODWORD(v4) = numVoters + 1;
    BYTE4(v4) = 0;
    *((_QWORD *)&voters + numVoters++) = v4;
  }
  printf("Initial state:\n");
  printCandidates();
  printVoters();
  vote(0i64, 1i64);
  vote(1i64, 2i64);
  vote(2i64, 1i64);
  vote(3i64, 1i64);
  vote(4i64, 3i64);
  vote(5i64, 2i64);
  vote(6i64, 1i64);
  vote(7i64, 2i64);
  vote(8i64, 3i64);
  vote(9i64, 1i64);
  printf("\nFinal state:\n");
  printCandidates();
  printVoters();
  return 0;
}
// 14000190E: variable 'v4' is possibly undefined
// 140001591: using guessed type __int64 __fastcall addCandidate(_QWORD);
// 140001662: using guessed type __int64 printCandidates(void);
// 140001715: using guessed type __int64 __fastcall vote(_QWORD, _QWORD);
// 140001813: using guessed type __int64 printVoters(void);
// 140001AB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400116A4: using guessed type int numVoters;

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Memory Game ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define BOARD_SIZE 4

// Function to shuffle the elements of an array
void shuffle(int arr[], int n)
{
    srand(time(NULL));
    for (int i = n - 1; i > 0; i--)
    {
        int j = rand() % (i + 1);
        
        // Swap arr[i] and arr[j]
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

// Function to print the game board
void print_board(int board[BOARD_SIZE][BOARD_SIZE])
{
    printf("\n");
    for (int i = 0; i < BOARD_SIZE; i++)
    {
        for (int j = 0; j < BOARD_SIZE; j++)
        {
            printf("%d ", board[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

int main()
{
    int board[BOARD_SIZE][BOARD_SIZE] = {0};
    
    // Populate the board with numbers
    int numbers[BOARD_SIZE*BOARD_SIZE/2];
    for (int i = 0; i < BOARD_SIZE*BOARD_SIZE/2; i++)
    {
        numbers[i] = i+1;
    }
    shuffle(numbers, BOARD_SIZE*BOARD_SIZE/2);
    
    // Place numbers on the board
    int index = 0;
    for (int i = 0; i < BOARD_SIZE; i++)
    {
        for (int j = 0; j < BOARD_SIZE; j++)
        {
            if (index >= BOARD_SIZE*BOARD_SIZE/2)
            {
                break;
            }
            board[i][j] = numbers[index];
            board[BOARD_SIZE-i-1][BOARD_SIZE-j-1] = numbers[index];
            index++;
        }
        if (index >= BOARD_SIZE*BOARD_SIZE/2)
        {
            break;
        }
    }
    
    // Print the initial board
    print_board(board);
    
    // Main loop of the game
    int row1, col1, row2, col2;
    int remaining_pairs = BOARD_SIZE*BOARD_SIZE/2;
    while (remaining_pairs > 0)
    {
        // Get user input for the first card
        printf("Enter the row and column of the first card: ");
        scanf("%d %d", &row1, &col1);
        while (board[row1][col1] == -1)
        {
            printf("That card has already been matched or is invalid, please choose another: ");
            scanf("%d %d", &row1, &col1);
        }
        printf("The first card is %d\n", board[row1][col1]);
        board[row1][col1] = -1;
        print_board(board);
        
        // Get user input for the second card
        printf("Enter the row and column of the second card: ");
        scanf("%d %d", &row2, &col2);
        while (board[row2][col2] == -1 || (row1 == row2 && col1 == col2))
        {
            printf("That card has already been matched or is invalid, please choose another: ");
            scanf("%d %d", &row2, &col2);
        }
        printf("The second card is %d\n", board[row2][col2]);
        if (board[row1][col1] == board[row2][col2])
        {
            printf("Pair matched!\n");
            board[row2][col2] = -1;
            remaining_pairs--;
        }
        else
        {
            board[row1][col1] = board[row2][col2] = 0;
        }
        print_board(board);
    }
    
    printf("Congratulations, you have found all the pairs!\n");
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall shuffle(_QWORD, _QWORD); // weak
__int64 __fastcall print_board(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001740) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int v4; // edx
  int v6; // [rsp+20h] [rbp-90h] BYREF
  int v7; // [rsp+24h] [rbp-8Ch] BYREF
  int v8; // [rsp+28h] [rbp-88h] BYREF
  int v9; // [rsp+2Ch] [rbp-84h] BYREF
  int v10[8]; // [rsp+30h] [rbp-80h] BYREF
  __int64 v11[9]; // [rsp+50h] [rbp-60h] BYREF
  int v12; // [rsp+9Ch] [rbp-14h]
  int k; // [rsp+A0h] [rbp-10h]
  int j; // [rsp+A4h] [rbp-Ch]
  int v15; // [rsp+A8h] [rbp-8h]
  int i; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  memset(v11, 0, 64);
  for ( i = 0; i <= 7; ++i )
    v10[i] = i + 1;
  shuffle(v10, 8i64);
  v15 = 0;
  for ( j = 0; j <= 3; ++j )
  {
    for ( k = 0; k <= 3 && v15 <= 7; ++k )
    {
      *((_DWORD *)&v11[2 * j] + k) = v10[v15];
      *((_DWORD *)&v11[2 * (3 - j)] + 3 - k) = v10[v15++];
    }
    if ( v15 > 7 )
      break;
  }
  print_board(v11);
  v12 = 8;
  while ( v12 > 0 )
  {
    printf("Enter the row and column of the first card: ");
    scanf("%d %d", &v9, &v8);
    while ( *((_DWORD *)&v11[2 * v9] + v8) == -1 )
    {
      printf("That card has already been matched or is invalid, please choose another: ");
      scanf("%d %d", &v9, &v8);
    }
    printf("The first card is %d\n", *((unsigned int *)&v11[2 * v9] + v8));
    *((_DWORD *)&v11[2 * v9] + v8) = -1;
    print_board(v11);
    printf("Enter the row and column of the second card: ");
    scanf("%d %d", &v7, &v6);
    while ( *((_DWORD *)&v11[2 * v7] + v6) == -1 || v9 == v7 && v8 == v6 )
    {
      printf("That card has already been matched or is invalid, please choose another: ");
      scanf("%d %d", &v7, &v6);
    }
    printf("The second card is %d\n", *((unsigned int *)&v11[2 * v7] + v6));
    if ( *((_DWORD *)&v11[2 * v9] + v8) == *((_DWORD *)&v11[2 * v7] + v6) )
    {
      printf("Pair matched!\n");
      *((_DWORD *)&v11[2 * v7] + v6) = -1;
      --v12;
    }
    else
    {
      v3 = v7;
      v4 = v6;
      *((_DWORD *)&v11[2 * v7] + v6) = 0;
      *((_DWORD *)&v11[2 * v9] + v8) = *((_DWORD *)&v11[2 * v3] + v4);
    }
    print_board(v11);
  }
  printf("Congratulations, you have found all the pairs!\n");
  return 0;
}
// 140001601: using guessed type __int64 __fastcall shuffle(_QWORD, _QWORD);
// 1400016AE: using guessed type __int64 __fastcall print_board(_QWORD);
// 140001BD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001740: using guessed type int var_80[8];

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Binary Converter ; Style: romantic
#include <stdio.h>

// Function to convert decimal to binary
void decimalToBinary(int num) {
    int binaryNum[32];
    int i = 0;
    while (num > 0) {
        binaryNum[i] = num % 2;
        num = num / 2;
        i++;
    }
    for (int j = i - 1; j >= 0; j--)
        printf("%d", binaryNum[j]);
}

// Function to convert binary to decimal
int binaryToDecimal(long long num) {
    int decimalNum = 0, base = 1, rem;
    while (num > 0) {
        rem = num % 10;
        num = num / 10;
        decimalNum = decimalNum + rem * base;
        base = base * 2;
    }
    return decimalNum;
}

int main() {
    int decimalNum;
    long long binaryNum;

    printf("Enter decimal number: ");
    scanf("%d", &decimalNum);

    printf("Binary equivalent: ");
    decimalToBinary(decimalNum);

    printf("\n\nEnter binary number: ");
    scanf("%lld", &binaryNum);

    printf("Decimal equivalent: %d", binaryToDecimal(binaryNum));

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall decimalToBinary(_QWORD); // weak
__int64 __fastcall binaryToDecimal(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000170B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Enter decimal number: ");
  scanf("%d", &v6);
  printf("Binary equivalent: ");
  decimalToBinary(v6);
  printf("\n\nEnter binary number: ");
  scanf("%lld", &v5);
  v3 = binaryToDecimal(v5);
  printf("Decimal equivalent: %d", v3);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall decimalToBinary(_QWORD);
// 14000166B: using guessed type __int64 __fastcall binaryToDecimal(_QWORD);
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000170B: using guessed type __int64 var_10;

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Temperature Converter ; Style: lively
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Display welcome message
    printf("*** Temperature Converter ***\n");

    // Variables for user input and converted temperature
    double temp, converted_temp;
    char unit;

    // Prompt user for temperature
    printf("Enter temperature: ");
    scanf("%lf", &temp);

    // Prompt user for temperature unit
    printf("Enter unit (C/F): ");
    scanf(" %c", &unit);

    // Determine conversion factor based on temperature unit
    double factor;
    if (unit == 'F' || unit == 'f') {
        factor = 5.0 / 9.0;
    } else if (unit == 'C' || unit == 'c') {
        factor = 9.0 / 5.0;
    } else {
        printf("Invalid unit. Exiting program.\n");
        exit(0);
    }

    // Convert temperature and display result
    if (unit == 'F' || unit == 'f') {
        converted_temp = (temp - 32.0) * factor;
        printf("%0.2f%cF is equivalent to %0.2f%cC\n", temp, unit, converted_temp, 'C');
    } else if (unit == 'C' || unit == 'c') {
        converted_temp = (temp * factor) + 32.0;
        printf("%0.2f%cC is equivalent to %0.2f%cF\n", temp, unit, converted_temp, 'F');
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-30h]
  int v5; // [rsp+20h] [rbp-30h]
  char v6; // [rsp+37h] [rbp-19h] BYREF
  double v7; // [rsp+38h] [rbp-18h] BYREF
  double v8; // [rsp+40h] [rbp-10h]
  double v9; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  printf("*** Temperature Converter ***\n");
  printf("Enter temperature: ");
  scanf("%lf", &v7);
  printf("Enter unit (C/F): ");
  scanf(" %c", &v6);
  if ( v6 == 70 || v6 == 102 )
  {
    v9 = 0.5555555555555556;
  }
  else
  {
    if ( v6 != 67 && v6 != 99 )
    {
      printf("Invalid unit. Exiting program.\n");
      exit(0);
    }
    v9 = 1.8;
  }
  if ( v6 == 70 || v6 == 102 )
  {
    v8 = (v7 - 32.0) * v9;
    v4 = 67;
    printf("%0.2f%cF is equivalent to %0.2f%cC\n", v7, (unsigned int)v6, v8, v4);
  }
  else
  {
    v8 = v7 * v9 + 32.0;
    v5 = 70;
    printf("%0.2f%cC is equivalent to %0.2f%cF\n", v7, (unsigned int)v6, v8, v5);
  }
  return 0;
}
// 140001724: conditional instruction was optimized away because %var_19.1==63
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Dice Roller ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to roll dice
int rollDice(int numDice, int sides) {
    int total = 0;
    for (int i = 0; i < numDice; i++) {
        total += (rand() % sides) + 1;
    }
    return total;
}

int main() {
    int numDice, sides, rollCount;
    char input;

    // Seed the random number generator
    srand(time(NULL));

    // Welcome message
    printf("Welcome to the Dice Roller!\n\n");

    do {
        // Prompt the user for input
        printf("How many dice would you like to roll? (1-10): ");
        scanf("%d", &numDice);

        // Validate input
        while (numDice < 1 || numDice > 10) {
            printf("Invalid input, please choose a value between 1 and 10: ");
            scanf("%d", &numDice);
        }

        printf("How many sides should the dice have? (2-100): ");
        scanf("%d", &sides);

        // Validate input
        while (sides < 2 || sides > 100) {
            printf("Invalid input, please choose a value between 2 and 100: ");
            scanf("%d", &sides);
        }

        printf("How many times do you want to roll the dice? (1-100): ");
        scanf("%d", &rollCount);

        // Validate input
        while (rollCount < 1 || rollCount > 100) {
            printf("Invalid input, please choose a value between 1 and 100: ");
            scanf("%d", &rollCount);
        }

        // Roll the dice and print the results
        printf("\nRolling %d %d-sided dice %d times...\n\n", numDice, sides, rollCount);

        for (int i = 0; i < rollCount; i++) {
            printf("Roll %d: %d\n", i+1, rollDice(numDice, sides));
        }

        // Prompt the user to play again
        printf("\nWould you like to roll again? (y/n): ");
        scanf(" %c", &input);

    } while (input == 'y' || input == 'Y');

    // Thank you message
    printf("\nThank you for using the Dice Roller! Have a great day!\n");

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall rollDice(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001645) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  char v6; // [rsp+2Fh] [rbp-11h] BYREF
  int v7; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v8; // [rsp+34h] [rbp-Ch] BYREF
  unsigned int v9; // [rsp+38h] [rbp-8h] BYREF
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf("Welcome to the Dice Roller!\n\n");
  do
  {
    printf("How many dice would you like to roll? (1-10): ");
    scanf("%d", &v9);
    while ( (int)v9 <= 0 || (int)v9 > 10 )
    {
      printf("Invalid input, please choose a value between 1 and 10: ");
      scanf("%d", &v9);
    }
    printf("How many sides should the dice have? (2-100): ");
    scanf("%d", &v8);
    while ( (int)v8 <= 1 || (int)v8 > 100 )
    {
      printf("Invalid input, please choose a value between 2 and 100: ");
      scanf("%d", &v8);
    }
    printf("How many times do you want to roll the dice? (1-100): ");
    scanf("%d", &v7);
    while ( v7 <= 0 || v7 > 100 )
    {
      printf("Invalid input, please choose a value between 1 and 100: ");
      scanf("%d", &v7);
    }
    printf("\nRolling %d %d-sided dice %d times...\n\n", v9, v8, (unsigned int)v7);
    for ( i = 0; i < v7; ++i )
    {
      v4 = rollDice(v9, v8);
      printf("Roll %d: %d\n", (unsigned int)(i + 1), v4);
    }
    printf("\nWould you like to roll again? (y/n): ");
    scanf(" %c", &v6);
  }
  while ( v6 == 121 || v6 == 89 );
  printf("\nThank you for using the Dice Roller! Have a great day!\n");
  return 0;
}
// 140001601: using guessed type __int64 __fastcall rollDice(_QWORD, _QWORD);
// 1400018F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Game of Life ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define WIDTH 50 // Width of the grid
#define HEIGHT 20 // Height of the grid
#define GENERATIONS 1000 // Number of generations to simulate

// Function to update the grid based on the rules of Game of Life
void updateGrid(int grid[][WIDTH]) {
    int nextGrid[HEIGHT][WIDTH]; // Array to hold the updated grid

    // Loop through every cell in the grid
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            
            // Count the number of live neighbors for this cell
            int liveNeighbors = 0;
            for (int j = -1; j <= 1; j++) {
                for (int i = -1; i <= 1; i++) {
                    if (!(i == 0 && j == 0)) { // Ignore the current cell
                        int dx = x + i;
                        int dy = y + j;
                        if (dx >= 0 && dx < WIDTH && dy >= 0 && dy < HEIGHT && grid[dy][dx] == 1) {
                            liveNeighbors++;
                        }
                    }
                }
            }
            
            // Update the cell based on the rules of Game of Life
            if (grid[y][x] == 1) {
                if (liveNeighbors < 2 || liveNeighbors > 3) {
                    nextGrid[y][x] = 0; // Cell dies
                } else {
                    nextGrid[y][x] = 1; // Cell lives
                }
            } else {
                if (liveNeighbors == 3) {
                    nextGrid[y][x] = 1; // New cell is born
                } else {
                    nextGrid[y][x] = 0; // Cell stays dead
                }
            }
        }
    }
    
    // Copy the updated grid back to the original grid
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            grid[y][x] = nextGrid[y][x];
        }
    }
}

// Function to randomly initialize the grid
void initGrid(int grid[][WIDTH]) {
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            if (rand() % 2 == 0) {
                grid[y][x] = 1; // Cell is alive
            } else {
                grid[y][x] = 0; // Cell is dead
            }
        }
    }
}

// Function to print the grid
void printGrid(int grid[][WIDTH], int generation) {
    printf("Generation %d:\n", generation);
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            if (grid[y][x] == 1) {
                printf("*"); // Cell is alive
            } else {
                printf("."); // Cell is dead
            }
        }
        printf("\n");
    }
}

int main() {
    srand(time(NULL)); // Seed the random number generator
    
    int grid[HEIGHT][WIDTH]; // 2D array to hold the grid
    
    initGrid(grid); // Initialize the grid
    
    printGrid(grid, 0); // Print the initial grid
    
    for (int i = 1; i <= GENERATIONS; i++) {
        updateGrid(grid); // Update the grid
        printGrid(grid, i); // Print the updated grid
    }
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 __fastcall updateGrid(_QWORD); // weak
__int64 __fastcall initGrid(_QWORD); // weak
__int64 __fastcall printGrid(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001A73) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[4012]; // [rsp+20h] [rbp-60h] BYREF
  unsigned int i; // [rsp+FCCh] [rbp+F4Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  initGrid(v5);
  printGrid(v5, 0i64);
  for ( i = 1; (int)i <= 1000; ++i )
  {
    updateGrid(v5);
    printGrid(v5, i);
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall updateGrid(_QWORD);
// 1400018FC: using guessed type __int64 __fastcall initGrid(_QWORD);
// 1400019B9: using guessed type __int64 __fastcall printGrid(_QWORD, _QWORD);
// 140001BC0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Planet Gravity Simulation ; Style: scientific
#include <stdio.h>
#include <math.h>

#define G 6.67408e-11 // gravitational constant
#define DELTA_T 1 // time step
#define NUM_PLANETS 4 // number of planets

typedef struct {
    char name[20];
    double mass;
    double x, y, z; // position
    double vx, vy, vz; // velocity
} Planet;

int main() {
    Planet planets[NUM_PLANETS] = {
        {"Earth", 5.97e24, 0, 0, 0, 0, 0, 0},
        {"Moon", 7.34e22, 3.84e8, 0, 0, 0, 1022, 0},
        {"Mars", 6.39e23, 2.28e11, 0, 0, 0, 0, 24130},
        {"Jupiter", 1.9e27, 7.78e11, 0, 0, 0, 0, 13052}
    };

    for (int i = 0; i < NUM_PLANETS; i++) {
        printf("%s position: (%.2e, %.2e, %.2e)\n", 
            planets[i].name, planets[i].x, planets[i].y, planets[i].z);
    }

    for (int i = 0; i < 1000; i++) { // simulate for 1000 time steps
        for (int j = 0; j < NUM_PLANETS; j++) {
            double ax = 0, ay = 0, az = 0; // acceleration
            for (int k = 0; k < NUM_PLANETS; k++) {
                if (j == k) continue;
                double dx = planets[k].x - planets[j].x;
                double dy = planets[k].y - planets[j].y;
                double dz = planets[k].z - planets[j].z;
                double d = sqrt(dx * dx + dy * dy + dz * dz); // distance
                double f = G * planets[j].mass * planets[k].mass / (d * d); // force
                ax += f * dx / d / planets[j].mass;
                ay += f * dy / d / planets[j].mass;
                az += f * dz / d / planets[j].mass;
            }
            planets[j].vx += ax * DELTA_T;
            planets[j].vy += ay * DELTA_T;
            planets[j].vz += az * DELTA_T;
            planets[j].x += planets[j].vx * DELTA_T;
            planets[j].y += planets[j].vy * DELTA_T;
            planets[j].z += planets[j].vz * DELTA_T;
        }
    }

    for (int i = 0; i < NUM_PLANETS; i++) {
        printf("%s position: (%.2e, %.2e, %.2e)\n", 
            planets[i].name, planets[i].x, planets[i].y, planets[i].z);
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);

//-------------------------------------------------------------------------
// Data declarations

char aEarth[6] = "Earth"; // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[328]; // [rsp+30h] [rbp-50h] BYREF
  double v5; // [rsp+178h] [rbp+F8h]
  double v6; // [rsp+180h] [rbp+100h]
  double v7; // [rsp+188h] [rbp+108h]
  double v8; // [rsp+190h] [rbp+110h]
  double v9; // [rsp+198h] [rbp+118h]
  int n; // [rsp+1A0h] [rbp+120h]
  int m; // [rsp+1A4h] [rbp+124h]
  double v12; // [rsp+1A8h] [rbp+128h]
  double v13; // [rsp+1B0h] [rbp+130h]
  double v14; // [rsp+1B8h] [rbp+138h]
  int k; // [rsp+1C4h] [rbp+144h]
  int j; // [rsp+1C8h] [rbp+148h]
  int i; // [rsp+1CCh] [rbp+14Ch]

  _main(argc, argv, envp);
  qmemcpy(v4, aEarth, 0x140ui64);
  for ( i = 0; i <= 3; ++i )
    printf(
      "%s position: (%.2e, %.2e, %.2e)\n",
      &v4[80 * i],
      *(double *)&v4[80 * i + 32],
      *(double *)&v4[80 * i + 40],
      *(double *)&v4[80 * i + 48]);
  for ( j = 0; j <= 999; ++j )
  {
    for ( k = 0; k <= 3; ++k )
    {
      v14 = 0.0;
      v13 = 0.0;
      v12 = 0.0;
      for ( m = 0; m <= 3; ++m )
      {
        if ( k != m )
        {
          v9 = *(double *)&v4[80 * m + 32] - *(double *)&v4[80 * k + 32];
          v8 = *(double *)&v4[80 * m + 40] - *(double *)&v4[80 * k + 40];
          v7 = *(double *)&v4[80 * m + 48] - *(double *)&v4[80 * k + 48];
          v6 = sqrt(v9 * v9 + v8 * v8 + v7 * v7);
          v5 = *(double *)&v4[80 * k + 24] * 6.67408e-11 * *(double *)&v4[80 * m + 24] / (v6 * v6);
          v14 = v5 * v9 / v6 / *(double *)&v4[80 * k + 24] + v14;
          v13 = v5 * v8 / v6 / *(double *)&v4[80 * k + 24] + v13;
          v12 = v5 * v7 / v6 / *(double *)&v4[80 * k + 24] + v12;
        }
      }
      *(double *)&v4[80 * k + 56] = *(double *)&v4[80 * k + 56] + v14;
      *(double *)&v4[80 * k + 64] = *(double *)&v4[80 * k + 64] + v13;
      *(double *)&v4[80 * k + 72] = *(double *)&v4[80 * k + 72] + v12;
      *(double *)&v4[80 * k + 32] = *(double *)&v4[80 * k + 56] + *(double *)&v4[80 * k + 32];
      *(double *)&v4[80 * k + 40] = *(double *)&v4[80 * k + 64] + *(double *)&v4[80 * k + 40];
      *(double *)&v4[80 * k + 48] = *(double *)&v4[80 * k + 72] + *(double *)&v4[80 * k + 48];
    }
  }
  for ( n = 0; n <= 3; ++n )
    printf(
      "%s position: (%.2e, %.2e, %.2e)\n",
      &v4[80 * n],
      *(double *)&v4[80 * n + 32],
      *(double *)&v4[80 * n + 40],
      *(double *)&v4[80 * n + 48]);
  return 0;
}
// 140001EF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char var_1B0[328];

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Date and time ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
   time_t current_time;
   struct tm * time_info;
   char time_string[40];

   time(&current_time);
   time_info = localtime(&current_time);

   strftime(time_string, sizeof(time_string), "%m/%d/%Y %H:%M:%S", time_info);

   printf("Current time: %s\n", time_string);

   return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
static struct tm *__cdecl localtime(const time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strftime(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);


//----- (00000001400015CF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[48]; // [rsp+20h] [rbp-40h] BYREF
  time_t Time; // [rsp+50h] [rbp-10h] BYREF
  struct tm *Tm; // [rsp+58h] [rbp-8h]

  _main(argc, argv, envp);
  time(&Time);
  Tm = localtime(&Time);
  strftime(Buffer, 0x28ui64, "%m/%d/%Y %H:%M:%S", Tm);
  printf("Current time: %s\n", Buffer);
  return 0;
}
// 1400016F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Secure Password Generator ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

// Function to generate a random password
void generatePassword(char *password, int length) {
    srand(time(NULL));
    char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=";
    int maxChar = strlen(charset);
    
    for(int i = 0; i < length; i++) {
        password[i] = charset[rand() % maxChar];
    }
    password[length] = '\0';
}

int main() {
    int length = 0;
    char password[50];
    
    // Prompt user for password length
    printf("Enter desired length of password (between 8 and 50): ");
    scanf("%d", &length);
    
    // Check if length is within valid range
    if(length < 8 || length > 50) {
        printf("Invalid length. Password must be between 8 and 50 characters long.\n");
        return 1;
    }
    
    // Generate password and display to user
    generatePassword(password, length);
    printf("Your secure password is: %s\n", password);
    
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generatePassword(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001707) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[60]; // [rsp+20h] [rbp-40h] BYREF
  int v5; // [rsp+5Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  printf("Enter desired length of password (between 8 and 50): ");
  scanf("%d", &v5);
  if ( v5 > 7 && v5 <= 50 )
  {
    generatePassword(v4, (unsigned int)v5);
    printf("Your secure password is: %s\n", v4);
    return 0;
  }
  else
  {
    printf("Invalid length. Password must be between 8 and 50 characters long.\n");
    return 1;
  }
}
// 140001601: using guessed type __int64 __fastcall generatePassword(_QWORD, _QWORD);
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Smart home automation ; Style: portable
#include <stdio.h>
#include <stdlib.h>

#define LIGHTS 0
#define AC 1
#define DOOR 2

int main()
{
  int room1[3] = {0, 0, 0};
  int room2[3] = {0, 0, 0};

  printf("Welcome to the Smart Home Automation Program\n");

  int input;
  char c;

  do {
    printf("\n\n1. Turn on lights\n");
    printf("2. Turn off lights\n");
    printf("3. Turn on AC\n");
    printf("4. Turn off AC\n");
    printf("5. Unlock door\n");
    printf("6. Lock door\n");
    printf("7. Exit Program\n");

    printf("\nPlease enter your choice: ");
    scanf("%d",&input);
    scanf("%c", &c);

    int room, device;
    switch(input) {
      case 1:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &room);
        printf("Turning on lights in room %d...", room);
        room == 1 ? (room1[LIGHTS] = 1) : (room2[LIGHTS] = 1);
        break;
      case 2:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &room);
        printf("Turning off lights in room %d...", room);
        room == 1 ? (room1[LIGHTS] = 0) : (room2[LIGHTS] = 0);
        break;
      case 3:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &room);
        printf("Turning on AC in room %d...", room);
        room == 1 ? (room1[AC] = 1) : (room2[AC] = 1);
        break;
      case 4:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &room);
        printf("Turning off AC in room %d...", room);
        room == 1 ? (room1[AC] = 0) : (room2[AC] = 0);
        break;
      case 5:
        printf("\nUnlocking door...");
        room1[DOOR] = 1;
        break;
      case 6:
        printf("\nLocking door...");
        room1[DOOR] = 0;
        break;
      case 7:
        printf("\nExiting program...");
        break;
      default:
        printf("\nInvalid input! Please choose again.\n");
        continue;
    }

    printf("\n\nCurrent status of the house:\n");
    printf("Room 1: Lights %s, AC %s, Door %s\n", room1[LIGHTS] ? "ON" : "OFF", room1[AC] ? "ON" : "OFF", room1[DOOR] ? "UNLOCKED" : "LOCKED");
    printf("Room 2: Lights %s, AC %s\n", room2[LIGHTS] ? "ON" : "OFF", room2[AC] ? "ON" : "OFF");
  } while (input != 7);

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rcx
  const char *v4; // rdx
  const char *v5; // rax
  const char *v6; // rdx
  const char *v7; // rax
  unsigned int v9; // [rsp+2Ch] [rbp-24h] BYREF
  char v10; // [rsp+33h] [rbp-1Dh] BYREF
  int v11; // [rsp+34h] [rbp-1Ch] BYREF
  int v12; // [rsp+38h] [rbp-18h]
  int v13; // [rsp+3Ch] [rbp-14h]
  int v14; // [rsp+40h] [rbp-10h]
  int v15; // [rsp+44h] [rbp-Ch]
  int v16; // [rsp+48h] [rbp-8h]
  int v17; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  printf("Welcome to the Smart Home Automation Program\n");
  do
  {
    printf("\n\n1. Turn on lights\n");
    printf("2. Turn off lights\n");
    printf("3. Turn on AC\n");
    printf("4. Turn off AC\n");
    printf("5. Unlock door\n");
    printf("6. Lock door\n");
    printf("7. Exit Program\n");
    printf("\nPlease enter your choice: ");
    scanf("%d", &v11);
    scanf("%c", &v10);
    switch ( v11 )
    {
      case 1:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &v9);
        printf("Turning on lights in room %d...", v9);
        if ( v9 == 1 )
          v15 = 1;
        else
          v12 = 1;
        goto LABEL_19;
      case 2:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &v9);
        printf("Turning off lights in room %d...", v9);
        if ( v9 == 1 )
          v15 = 0;
        else
          v12 = 0;
        goto LABEL_19;
      case 3:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &v9);
        printf("Turning on AC in room %d...", v9);
        if ( v9 == 1 )
          v16 = 1;
        else
          v13 = 1;
        goto LABEL_19;
      case 4:
        printf("\nPlease enter the room number (1 or 2): ");
        scanf("%d", &v9);
        printf("Turning off AC in room %d...", v9);
        if ( v9 == 1 )
          v16 = 0;
        else
          v13 = 0;
        goto LABEL_19;
      case 5:
        printf("\nUnlocking door...");
        v17 = 1;
        goto LABEL_19;
      case 6:
        printf("\nLocking door...");
        v17 = 0;
        goto LABEL_19;
      case 7:
        printf("\nExiting program...");
LABEL_19:
        printf("\n\nCurrent status of the house:\n");
        if ( v17 )
          v3 = "UNLOCKED";
        else
          v3 = "LOCKED";
        if ( v16 )
          v4 = "ON";
        else
          v4 = "OFF";
        if ( v15 )
          v5 = "ON";
        else
          v5 = "OFF";
        printf("Room 1: Lights %s, AC %s, Door %s\n", v5, v4, v3);
        if ( v13 )
          v6 = "ON";
        else
          v6 = "OFF";
        if ( v12 )
          v7 = "ON";
        else
          v7 = "OFF";
        printf("Room 2: Lights %s, AC %s\n", v7, v6);
        break;
      default:
        printf("\nInvalid input! Please choose again.\n");
        break;
    }
  }
  while ( v11 != 7 );
  return 0;
}
// 140001A30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type unsigned int var_24;

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Chess AI ; Style: puzzling
#include<stdio.h>
#include<stdlib.h>

#define KING_WEIGHT 200 // The weightage of a king
#define QUEEN_WEIGHT 9 // The weightage of a queen
#define KNIGHT_WEIGHT 3 // The weightage of a knight
#define BISHOP_WEIGHT 3 // The weightage of a bishop
#define ROOK_WEIGHT 5 // The weightage of a rook
#define PAWN_WEIGHT 1 // The weightage of a pawn

/** Structure to hold a chess piece*/
struct piece {
    char color;
    char type;
    int x;
    int y;
};

/** Function to print the chess board */
void printBoard(char board[][8]) {
    printf("\n  a b c d e f g h\n");
    for(int i=0; i<8; i++) {
      printf("%d ", i+1);
      for(int j=0; j<8; j++) {
          printf("%c ", board[i][j]);
      }
      printf("%d\n", i+1);
    }
    printf("  a b c d e f g h\n\n");
}

/** Function to get the value of a chess piece */
int getValue(char type) {
    if(type == 'K') {
        return KING_WEIGHT;
    } else if(type == 'Q') {
        return QUEEN_WEIGHT;
    } else if(type == 'N') {
        return KNIGHT_WEIGHT;
    } else if(type == 'B') {
        return BISHOP_WEIGHT;
    } else if(type == 'R') {
        return ROOK_WEIGHT;
    } else {
        return PAWN_WEIGHT;
    }
}

/** Function to check if a move is valid */
int isValidMove(char board[][8], struct piece p, int newX, int newY) {
    if(newX < 0 || newX > 7 || newY < 0 || newY > 7) {
        return 0;
    }
    if(p.x == newX && p.y == newY) {
        return 0;
    }
    if(board[newX][newY] != ' ') {
        if(board[newX][newY] == 'K' && p.type != 'P') {
            return 0;
        } else if(board[newX][newY] == p.type && p.type != 'P') {
            return 0;
        } else if(board[newX][newY] != p.type && p.type == 'P') {
            return 0;
        }
    }
    if(p.type == 'K') {
        if(abs(p.x - newX) > 1 || abs(p.y - newY) > 1) {
            return 0;
        }
    } else if(p.type == 'Q') {
        if(p.x != newX && p.y != newY && abs(p.x - newX) != abs(p.y - newY)) {
            return 0;
        }
        int dx = p.x < newX ? 1 : (p.x > newX ? -1 : 0);
        int dy = p.y < newY ? 1 : (p.y > newY ? -1 : 0);
        for(int i=p.x+dx,j=p.y+dy;i!=newX || j!=newY;i+=dx,j+=dy) {
            if(board[i][j] != ' ' && (i != p.x || j != p.y)) {
                return 0;
            }
        }
    } else if(p.type == 'N') {
        if(abs(p.x - newX) == 2 && abs(p.y - newY) == 1) {
            return 1;
        } else if(abs(p.x - newX) == 1 && abs(p.y - newY) == 2) {
            return 1;
        } else {
            return 0;
        }
    } else if(p.type == 'B') {
        if(abs(p.x - newX) != abs(p.y - newY)) {
            return 0;
        }
        int dx = p.x < newX ? 1 : -1;
        int dy = p.y < newY ? 1 : -1;
        for(int i=p.x+dx,j=p.y+dy;i!=newX+dx;i+=dx,j+=dy) {
            if(board[i][j] != ' ' && (i != p.x || j != p.y)) {
                return 0;
            }
        }
    } else if(p.type == 'R') {
        if(p.x != newX && p.y != newY) {
            return 0;
        }
        int dx = p.x == newX ? 0 : (p.x < newX ? 1 : -1);
        int dy = p.y == newY ? 0 : (p.y < newY ? 1 : -1);
        for(int i=p.x+dx,j=p.y+dy;i!=newX+dx || j!=newY+dy;i+=dx,j+=dy) {
            if(board[i][j] != ' ' && (i != p.x || j != p.y)) {
                return 0;
            }
        }
    } else if(p.type == 'P') {
        if(p.color == 'W') {
            if(newY == p.y && newX == p.x-1 && board[newX][newY] == ' ') {
                return 1;
            } else if(newY == p.y+1 && newX == p.x-1 && board[newX][newY] != ' ') {
                return 1;
            } else if(newY == p.y-1 && newX == p.x-1 && board[newX][newY] != ' ') {
                return 1;
            } else if(newY == p.y && newX == p.x-2 && p.x == 6 && board[newX][newY] == ' ' && board[p.x-1][newY] == ' ') {
                return 1;
            } else {
                return 0;
            }
        } else {
            if(newY == p.y && newX == p.x+1 && board[newX][newY] == ' ') {
                return 1;
            } else if(newY == p.y-1 && newX == p.x+1 && board[newX][newY] != ' ') {
                return 1;
            } else if(newY == p.y+1 && newX == p.x+1 && board[newX][newY] != ' ') {
                return 1;
            } else if(newY == p.y && newX == p.x+2 && p.x == 1 && board[newX][newY] == ' ' && board[p.x+1][newY] == ' ') {
                return 1;
            } else {
                return 0;
            }
        }
    }
    return 1;
}

/** Function to get the best move for the AI player */
void getBestMove(char board[][8], char color) {
    struct piece pieces[16];
    int pieceCount = 0;
    for(int i=0; i<8; i++) {
        for(int j=0; j<8; j++) {
            if(board[i][j] != ' ' && (color == 'B' ? board[i][j] >= 'a' : board[i][j] <= 'Z')) {
                struct piece p = {
                    .color = board[i][j] >= 'a' ? 'B' : 'W',
                    .type = board[i][j] >= 'a' ? board[i][j] - 32 : board[i][j],
                    .x = i,
                    .y = j
                };
                pieces[pieceCount] = p;
                pieceCount++;
            }
        }
    }
    int bestMoveValue = -1;
    int bestMoveIndex = -1;
    for(int i=0; i<pieceCount; i++) {
        struct piece p = pieces[i];
        for(int a=0; a<8; a++) {
            for(int b=0; b<8; b++) {
                if(isValidMove(board, p, a, b)) {
                    int value = getValue(p.type);
                    if(board[a][b] != ' ') {
                        value += getValue(board[a][b]);
                    }
                    if(value > bestMoveValue) {
                        bestMoveValue = value;
                        bestMoveIndex = i;
                    }
                }
            }
        }
    }
    struct piece p = pieces[bestMoveIndex];
    int newX, newY;
    int bestMoveValueForPiece = -1;
    for(int a=0; a<8; a++) {
        for(int b=0; b<8; b++) {
            if(isValidMove(board, p, a, b)) {
                int value = getValue(p.type);
                if(board[a][b] != ' ') {
                    value += getValue(board[a][b]);
                }
                if(value > bestMoveValueForPiece) {
                    bestMoveValueForPiece = value;
                    newX = a;
                    newY = b;
                }
            }
        }
    }
    printf("\nAI Player moves from %c%d to %c%d\n", p.y+'a', p.x+1, newY+'a', newX+1);
    board[newX][newY] = board[p.x][p.y];
    board[p.x][p.y] = ' ';
}

/** The main function */
int main() {
    char board[8][8] = {
        {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'},
        {'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'},
        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
        {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
        {'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'},
        {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'}
    };
    int gameOver = 0;
    char turn = 'W';
    while(!gameOver) {
        system("clear");
        printf("Chess Game\n");
        printBoard(board);
        if(turn == 'W') {
            printf("White Player's turn\n");
            char start[3], end[3];
            printf("Enter starting position (ex: e2) : ");
            scanf("%s", start);
            printf("Enter ending position (ex: e4) : ");
            scanf("%s", end);
            struct piece p = {
                .color = 'W',
                .type = toupper(board[start[1]-'0'-1][start[0]-'a']),
                .x = start[1]-'0'-1,
                .y = start[0]-'a'
            };
            if(isValidMove(board, p, end[1]-'0'-1, end[0]-'a')) {
                board[end[1]-'0'-1][end[0]-'a'] = board[p.x][p.y];
                board[p.x][p.y] = ' ';
                turn = 'B';
            } else {
                printf("Invalid move.\n");
                getchar();
            }
        } else {
            printf("AI Player's turn\n");
            getBestMove(board, 'B');
            turn = 'W';
            getchar();
        }
        /* Implement game over logic */
    }
    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall printBoard(_QWORD); // weak
__int64 __fastcall isValidMove(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD); // weak
__int64 __fastcall getBestMove(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl toupper(int C);
// int __cdecl system(const char *Command);
// int __cdecl getchar();


//----- (0000000140002395) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-80h] BYREF
  int v5; // [rsp+28h] [rbp-78h]
  __int64 v6; // [rsp+3Ch] [rbp-64h]
  int v7; // [rsp+44h] [rbp-5Ch]
  char v8; // [rsp+4Ah] [rbp-56h] BYREF
  char v9; // [rsp+4Bh] [rbp-55h]
  char v10; // [rsp+4Dh] [rbp-53h] BYREF
  char v11; // [rsp+4Eh] [rbp-52h]
  __int64 v12[9]; // [rsp+50h] [rbp-50h] BYREF
  int v13; // [rsp+98h] [rbp-8h]
  char v14; // [rsp+9Fh] [rbp-1h]
  __int64 savedregs; // [rsp+A0h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v12, "rnbqkbnrpppppppp                                PPPPPPPPRNBQKBNR", 64);
  v13 = 0;
  v14 = 87;
  while ( !v13 )
  {
    system("clear");
    printf("Chess Game\n");
    printBoard(v12);
    if ( v14 == 87 )
    {
      printf("White Player's turn\n");
      printf("Enter starting position (ex: e2) : ");
      scanf("%s", &v10);
      printf("Enter ending position (ex: e4) : ");
      scanf("%s", &v8);
      LOBYTE(v6) = 87;
      BYTE1(v6) = toupper(*((char *)&savedregs + 8 * v11 + v10 - 569));
      HIDWORD(v6) = v11 - 49;
      v7 = v10 - 97;
      v4 = v6;
      v5 = v7;
      if ( (unsigned int)((__int64 (__fastcall *)(__int64 *, __int64 *, _QWORD, _QWORD))isValidMove)(
                           v12,
                           &v4,
                           (unsigned int)(v9 - 49),
                           (unsigned int)(v8 - 97)) )
      {
        *((_BYTE *)&savedregs + 8 * v9 + v8 - 569) = *((_BYTE *)&savedregs + 8 * SHIDWORD(v6) + v7 - 80);
        *((_BYTE *)&savedregs + 8 * SHIDWORD(v6) + v7 - 80) = 32;
        v14 = 66;
      }
      else
      {
        printf("Invalid move.\n");
        getchar();
      }
    }
    else
    {
      printf("AI Player's turn\n");
      getBestMove(v12, 66i64);
      v14 = 87;
      getchar();
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall printBoard(_QWORD);
// 1400016E9: using guessed type __int64 __fastcall isValidMove(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 140001DF4: using guessed type __int64 __fastcall getBestMove(_QWORD, _QWORD);
// 1400026A0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password management ; Style: innovative
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<ctype.h>
#include<time.h>

void generatePassword(char *password, int length) {
    // Generating random password
    char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789#$&*@";
    int i;
    int charsetLen = strlen(charset);
    srand(time(NULL)); // Seed for random number generator

    for(i=0; i<length; i++) {
        int randomIndex = rand()%charsetLen; // Generating random index within the length of charset
        password[i] = charset[randomIndex]; // Getting character from the charset using random index
    }

    password[length] = '\0'; // Adding null terminator at end of password
}

int main() {
    char masterPassword[20], newPassword[20], confirmNewPassword[20], savedPassword[20];
    FILE *fp;

    printf("Welcome to the Password Management System\n");
    printf("Please enter your Master Password: ");
    scanf("%s", masterPassword);

    // Open file containing saved password
    fp = fopen("saved_password.txt", "r");

    if(fp == NULL) {
        printf("No saved password found. Creating a new password now.\n");
        printf("Please choose a new password (8-20 characters long, containing uppercase/lowercase letters, numbers and symbols): ");
        scanf("%s", newPassword);

        // Checking password length
        if(strlen(newPassword) < 8 || strlen(newPassword) > 20) {
            printf("Password should be 8-20 characters long. Please try again.\n");
            exit(0);
        }

        // Checking password contains atleast one uppercase, one lowercase, one number and one symbol
        int i, hasUpper=0, hasLower=0, hasNumber=0, hasSymbol=0;
        for(i=0; i<strlen(newPassword); i++) {
            char c = newPassword[i];
            if(isupper(c)) hasUpper=1;
            if(islower(c)) hasLower=1;
            if(isdigit(c)) hasNumber=1;
            if(!isalnum(c)) hasSymbol=1;
        }
        if(!hasUpper || !hasLower || !hasNumber || !hasSymbol) {
            printf("Password should contain atleast one uppercase, one lowercase, one number and one symbol. Please try again.\n");
            exit(0);
        }

        // Confirming new password
        printf("Please confirm your new password: ");
        scanf("%s", confirmNewPassword);

        if(strcmp(newPassword, confirmNewPassword) != 0) {
            printf("New passwords do not match. Try again.\n");
            exit(0);
        }

        // Generating random password for saved password
        char savedPassword[11];
        generatePassword(savedPassword, 10);

        // Saving new password in file
        fp = fopen("saved_password.txt", "w");
        fprintf(fp, "%s\n%s", newPassword, savedPassword);
        fclose(fp);

        printf("New password created successfully.\n");
    }
    else {
        fscanf(fp, "%s %s", savedPassword, masterPassword);

        // Checking if entered password matches saved password
        if(strcmp(masterPassword, savedPassword) != 0) {
            printf("Incorrect password. You do not have permission to access this system.\n");
            exit(0);
        }

        printf("Access granted.\n");

        // Enable user to change saved password
        char newSavedPassword[20];
        printf("Would you like to change your saved password? (Y/N) ");
        getchar(); // To clear input buffer
        char option = getchar();

        if(option == 'Y' || option == 'y') {
            printf("Please enter a new saved password: ");
            scanf("%s", newSavedPassword);

            printf("Please enter your current (master) password to confirm: ");
            scanf("%s", masterPassword);

            if(strcmp(masterPassword, savedPassword) != 0) {
                printf("Incorrect password. Please try again later.\n");
                exit(0);
            }

            fp = fopen("saved_password.txt", "w");
            fprintf(fp, "%s\n%s", newSavedPassword, newSavedPassword);
            fclose(fp);

            printf("Saved password changed successfully.\n");
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int fscanf(FILE *const Stream, const char *const Format, ...);
int fprintf_0(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall generatePassword(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// int __cdecl getchar();
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isalnum)(int C);
// extern int (__cdecl *islower)(int C);
// extern int (__cdecl *isupper)(int C);


//----- (000000014000177E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[21]; // [rsp+20h] [rbp-C0h] BYREF
  char v5[11]; // [rsp+35h] [rbp-ABh] BYREF
  char v6[32]; // [rsp+40h] [rbp-A0h] BYREF
  char Str2[32]; // [rsp+60h] [rbp-80h] BYREF
  char Str[32]; // [rsp+80h] [rbp-60h] BYREF
  char Str1[30]; // [rsp+A0h] [rbp-40h] BYREF
  char v10; // [rsp+BEh] [rbp-22h]
  char v11; // [rsp+BFh] [rbp-21h]
  FILE *Stream; // [rsp+C0h] [rbp-20h]
  int v13; // [rsp+CCh] [rbp-14h]
  int v14; // [rsp+D0h] [rbp-10h]
  int v15; // [rsp+D4h] [rbp-Ch]
  int v16; // [rsp+D8h] [rbp-8h]
  int i; // [rsp+DCh] [rbp-4h]

  _main(argc, argv, envp);
  printf("Welcome to the Password Management System\n");
  printf("Please enter your Master Password: ");
  scanf("%s", Str1);
  Stream = fopen("saved_password.txt", "r");
  if ( Stream )
  {
    fscanf(Stream, "%s %s", v6, Str1);
    if ( strcmp(Str1, v6) )
    {
      printf("Incorrect password. You do not have permission to access this system.\n");
      exit(0);
    }
    printf("Access granted.\n");
    printf("Would you like to change your saved password? (Y/N) ");
    getchar();
    v11 = getchar();
    if ( v11 == 89 || v11 == 121 )
    {
      printf("Please enter a new saved password: ");
      scanf("%s", v4);
      printf("Please enter your current (master) password to confirm: ");
      scanf("%s", Str1);
      if ( strcmp(Str1, v6) )
      {
        printf("Incorrect password. Please try again later.\n");
        exit(0);
      }
      Stream = fopen("saved_password.txt", "w");
      fprintf_0(Stream, "%s\n%s", v4, v4);
      fclose(Stream);
      printf("Saved password changed successfully.\n");
    }
  }
  else
  {
    printf("No saved password found. Creating a new password now.\n");
    printf(
      "Please choose a new password (8-20 characters long, containing uppercase/lowercase letters, numbers and symbols): ");
    scanf("%s", Str);
    if ( strlen(Str) <= 7 || strlen(Str) > 0x14 )
    {
      printf("Password should be 8-20 characters long. Please try again.\n");
      exit(0);
    }
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v13 = 0;
    for ( i = 0; i < strlen(Str); ++i )
    {
      v10 = Str[i];
      if ( isupper(v10) )
        v16 = 1;
      if ( islower(v10) )
        v15 = 1;
      if ( (unsigned int)(v10 - 48) <= 9 )
        v14 = 1;
      if ( !isalnum(v10) )
        v13 = 1;
    }
    if ( !v16 || !v15 || !v14 || !v13 )
    {
      printf("Password should contain atleast one uppercase, one lowercase, one number and one symbol. Please try again.\n");
      exit(0);
    }
    printf("Please confirm your new password: ");
    scanf("%s", Str2);
    if ( strcmp(Str, Str2) )
    {
      printf("New passwords do not match. Try again.\n");
      exit(0);
    }
    generatePassword(v5, 10i64);
    Stream = fopen("saved_password.txt", "w");
    fprintf_0(Stream, "%s\n%s", Str, v5);
    fclose(Stream);
    printf("New password created successfully.\n");
  }
  return 0;
}
// 140001687: using guessed type __int64 __fastcall generatePassword(_QWORD, _QWORD);
// 140001C40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000177E: using guessed type char Str[32];

// nfuncs=188 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

// struct to represent a vehicle
typedef struct {
    int speed;  // in mph
    int position;  // in miles
    bool active;  // whether vehicle is on the road
} Vehicle;

// function to initialize a vehicle with random speed and position
Vehicle initVehicle() {
    Vehicle vehicle;
    vehicle.speed = rand() % 31 + 30;  // random speed between 30-60mph
    vehicle.position = rand() % 11;  // random position on the road
    vehicle.active = true;
    return vehicle;
}

int main() {
    // seed the random number generator
    srand(time(0));

    int numVehicles = 20;  // number of vehicles on the road
    Vehicle vehicles[numVehicles];

    // init vehicles
    for (int i = 0; i < numVehicles; i++) {
        vehicles[i] = initVehicle();
    }

    int timeStep = 1;  // each timestep represents 1 minute
    int gameTime = 120;  // game lasts for 2 hours (120 minutes)

    // main game loop
    for (int t = 0; t < gameTime; t += timeStep) {
        // print the current state of the road
        printf("Time: %d minutes\n", t);
        for (int j = 0; j < numVehicles; j++) {
            if (vehicles[j].active) {  // only print active vehicles
                printf("Vehicle %d: Speed %d mph, Position %d miles\n", j+1, vehicles[j].speed, vehicles[j].position);
            }
        }
        printf("\n");

        // update positions of each vehicle
        for (int k = 0; k < numVehicles; k++) {
            if (vehicles[k].active) {
                vehicles[k].position += vehicles[k].speed / 60 * timeStep;  // update position based on speed
            }
        }

        // check if any collisions occurred
        for (int m = 0; m < numVehicles; m++) {
            if (vehicles[m].active) {
                for (int n = m+1; n < numVehicles; n++) {
                    if (vehicles[n].active) {
                        if (vehicles[m].position == vehicles[n].position) {  // collision occurred
                            printf("Collision occurred at time %d between Vehicle %d and Vehicle %d\n", t, m+1, n+1);
                            vehicles[m].active = false;  // both vehicles become inactive after a collision
                            vehicles[n].active = false;
                        }
                    }
                }
            }
        }
    }

    return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall initVehicle(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001640) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  void *v4; // rsp
  char *v5; // rbx
  __int64 v7; // [rsp+20h] [rbp-50h] BYREF
  int v8; // [rsp+28h] [rbp-48h]
  int v9; // [rsp+38h] [rbp-38h]
  int v10; // [rsp+3Ch] [rbp-34h]
  __int64 *v11; // [rsp+40h] [rbp-30h]
  __int64 v12; // [rsp+48h] [rbp-28h]
  int v13; // [rsp+54h] [rbp-1Ch]
  int ii; // [rsp+58h] [rbp-18h]
  int n; // [rsp+5Ch] [rbp-14h]
  int m; // [rsp+60h] [rbp-10h]
  int k; // [rsp+64h] [rbp-Ch]
  unsigned int j; // [rsp+68h] [rbp-8h]
  int i; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v13 = 20;
  v12 = 19i64;
  v4 = alloca(240i64);
  v11 = &v7;
  for ( i = 0; i < v13; ++i )
  {
    v5 = (char *)v11 + 12 * i;
    initVehicle(&v7);
    *(_QWORD *)v5 = v7;
    *((_DWORD *)v5 + 2) = v8;
  }
  v10 = 1;
  v9 = 120;
  for ( j = 0; (int)j < v9; j += v10 )
  {
    printf("Time: %d minutes\n", j);
    for ( k = 0; k < v13; ++k )
    {
      if ( *((_BYTE *)v11 + 12 * k + 8) )
        printf(
          "Vehicle %d: Speed %d mph, Position %d miles\n",
          (unsigned int)(k + 1),
          *((unsigned int *)v11 + 3 * k),
          *((unsigned int *)v11 + 3 * k + 1));
    }
    printf("\n");
    for ( m = 0; m < v13; ++m )
    {
      if ( *((_BYTE *)v11 + 12 * m + 8) )
        *((_DWORD *)v11 + 3 * m + 1) += v10 * (*((_DWORD *)v11 + 3 * m) / 60);
    }
    for ( n = 0; n < v13; ++n )
    {
      if ( *((_BYTE *)v11 + 12 * n + 8) )
      {
        for ( ii = n + 1; ii < v13; ++ii )
        {
          if ( *((_BYTE *)v11 + 12 * ii + 8) && *((_DWORD *)v11 + 3 * n + 1) == *((_DWORD *)v11 + 3 * ii + 1) )
          {
            printf(
              "Collision occurred at time %d between Vehicle %d and Vehicle %d\n",
              j,
              (unsigned int)(n + 1),
              (unsigned int)(ii + 1));
            *((_BYTE *)v11 + 12 * n + 8) = 0;
            *((_BYTE *)v11 + 12 * ii + 8) = 0;
          }
        }
      }
    }
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall initVehicle(_QWORD);
// 140001B10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Arithmetic ; Style: synchronous
#include <stdio.h>

/* Function to calculate the sum of array using synchronous programming */
int synchronous_sum(int arr[], int size) {
  int sum = 0;
  for (int i = 0; i < size; i++) {
    sum += arr[i];
  }
  return sum;
}

/* Function to calculate the product of array using synchronous programming */
int synchronous_product(int arr[], int size) {
  int product = 1;
  for (int i = 0; i < size; i++) {
    product *= arr[i];
  }
  return product;
}

/* Function to calculate the average of array using synchronous programming */
float synchronous_average(int arr[], int size) {
  float sum = synchronous_sum(arr, size);
  return sum / size;
}

int main() {
  int arr[] = { 1, 2, 3, 4, 5 };
  int size = sizeof(arr)/sizeof(arr[0]); // calculating the length of the array

  printf("The sum of the array is %d.\n", synchronous_sum(arr, size));

  printf("The product of the array is %d.\n", synchronous_product(arr, size));

  printf("The average of the array is %.2f.\n", synchronous_average(arr, size));

  return 0;
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall synchronous_sum(_QWORD, _QWORD); // weak
__int64 __fastcall synchronous_product(_QWORD, _QWORD); // weak
float __fastcall synchronous_average(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001673) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  float v5; // xmm0_4
  int v7[7]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v7[0] = 1;
  v7[1] = 2;
  v7[2] = 3;
  v7[3] = 4;
  v7[4] = 5;
  v8 = 5;
  v3 = synchronous_sum(v7, 5i64);
  printf("The sum of the array is %d.\n", v3);
  v4 = synchronous_product(v7, v8);
  printf("The product of the array is %d.\n", v4);
  v5 = synchronous_average(v7, v8);
  printf("The average of the array is %.2f.\n", v5);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall synchronous_sum(_QWORD, _QWORD);
// 1400015DE: using guessed type __int64 __fastcall synchronous_product(_QWORD, _QWORD);
// 140001631: using guessed type float __fastcall synchronous_average(_QWORD, _QWORD);
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
`//FormAI DATASET v1.0 Category: Password management ; Style: beginner-friendly
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define MAX 30 // Maximum number of passwords

// Password structure
typedef struct{
    char website[50];
    char username[30];
    char password[30];
}Password;

int count = 0; // Count variable to keep track of number of passwords stored

Password passwords[MAX]; // Array to store passwords

// Function prototypes
void add_password();
void view_passwords();
void search_website();


int main(){
    int choice;

    printf("Welcome to the Password Manager!\n\n");

    while(1){
        printf("Please choose an option:\n");
        printf("1. Add new password\n");
        printf("2. View saved passwords\n");
        printf("3. Search passwords by website\n");
        printf("4. Exit\n");

        scanf("%d", &choice);

        switch(choice){
            case 1:
                add_password();
                break;
            case 2:
                view_passwords();
                break;
            case 3:
                search_website();
                break;
            case 4:
                printf("\nThank you for using the Password Manager!");
                exit(0); // Exit the program
            default:
                printf("\nInvalid choice, please try again.\n");
        }
    }

    return 0;
}


// Function to add a new password
void add_password(){
    if(count == MAX){
        printf("\nYou have reached the maximum number of passwords that can be stored.\n");
        return;
    }

    Password new_password;

    printf("\nPlease enter the website name: ");
    scanf("%s", new_password.website);

    printf("Please enter the username: ");
    scanf("%s", new_password.username);

    printf("Please enter the password: ");
    scanf("%s", new_password.password);

    passwords[count++] = new_password;

    printf("\nThe password has been added successfully!\n\n");
}


// Function to view all saved passwords
void view_passwords(){
    if(count == 0){
        printf("\nNo passwords have been saved yet.\n\n");
        return;
    }

    printf("\nWebsite\t\tUsername\t\tPassword\n");

    for(int i=0; i<count; i++){
        printf("%s\t\t%s\t\t%s\n", passwords[i].website, passwords[i].username, passwords[i].password);
    }

    printf("\n");
}


// Function to search for a stored password b website
void search_website(){
    if(count == 0){
        printf("\nNo passwords have been saved yet.\n\n");
        return;
    }

    char website[50];
    int found = 0;

    printf("\nPlease enter the website name to search for: ");
    scanf("%s", website);

    for(int i=0; i<count; i++){
        if(strcmp(passwords[i].website, website) == 0){
            found = 1;
            printf("\nWebsite: %s\n", passwords[i].website);
            printf("Username: %s\n", passwords[i].username);
            printf("Password: %s\n", passwords[i].password);
            break;
        }
    }

    if(!found){
        printf("\nThe website you searched for could not be found.\n\n");
    }
}`,`/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 add_password(void); // weak
__int64 view_passwords(void); // weak
__int64 search_website(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf("Welcome to the Password Manager!\n\n");
  while ( 1 )
  {
    printf("Please choose an option:\n");
    printf("1. Add new password\n");
    printf("2. View saved passwords\n");
    printf("3. Search passwords by website\n");
    printf("4. Exit\n");
    scanf("%d", &v3);
    if ( v3 == 4 )
    {
      printf("\nThank you for using the Password Manager!");
      exit(0);
    }
    if ( v3 > 4 )
    {
LABEL_12:
      printf("\nInvalid choice, please try again.\n");
    }
    else
    {
      switch ( v3 )
      {
        case 3:
          search_website();
          break;
        case 1:
          add_password();
          break;
        case 2:
          view_passwords();
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 140001674: conditional instruction was optimized away because %var_4.4<3
// 1400016C4: using guessed type __int64 add_password(void);
// 140001825: using guessed type __int64 view_passwords(void);
// 1400018E6: using guessed type __int64 search_website(void);
// 140001AD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
`
